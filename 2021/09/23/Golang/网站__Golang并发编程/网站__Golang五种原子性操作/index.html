<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="原子性的解释如下："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Golang五种原子性操作 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-09-23</div></div></div><div class="container post-header"><h1>Golang五种原子性操作</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">Go 语言提供了哪些原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E8%B7%9F%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">互斥锁跟原子操作的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">比较并交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic-Value%E4%BF%9D%E8%AF%81%E4%BB%BB%E6%84%8F%E5%80%BC%E7%9A%84%E8%AF%BB%E5%86%99%E5%AE%89%E5%85%A8"><span class="toc-number">4.</span> <span class="toc-text">atomic.Value保证任意值的读写安全</span></a></li></ol></details></div><div class="container post-content"><p>原子性的解释如下：</p>
<blockquote>
<p>一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为<em>原子性（atomicity）</em> 。这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。</p>
</blockquote>
<p><code>CPU</code>执行一系列操作时不可能不发生中断，但如果我们在执行多个操作时，能让他们的<strong>中间状态对外不可见</strong>，那我们就可以宣称他们拥有了”不可分割”的原子性。</p>
<h3 id="Go-语言提供了哪些原子操作"><a href="#Go-语言提供了哪些原子操作" class="headerlink" title="Go 语言提供了哪些原子操作"></a>Go 语言提供了哪些原子操作</h3><p><code>Go</code>语言通过内置包<code>sync/atomic</code>提供了对原子操作的支持，其提供的原子操作有以下几大类：</p>
<ul>
<li>增减，操作方法的命名方式为<code>AddXXXType</code>，保证对操作数进行原子的增减，支持的类型为<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>，使用时以实际类型替换前面我说的<code>XXXType</code>就是对应的操作方法。</li>
<li>载入，保证了读取到操作数前没有其他任务对它进行变更，操作方法的命名方式为<code>LoadXXXType</code>，支持的类型除了基础类型外还支持<code>Pointer</code>，也就是支持载入任何类型的指针。</li>
<li>存储，有载入了就必然有存储操作，这类操作的方法名以<code>Store</code>开头，支持的类型跟载入操作支持的那些一样。</li>
<li>比较并交换，也就是<code>CAS</code> （Compare And Swap），像<code>Go</code>的很多并发原语实现就是依赖的<code>CAS</code>操作，同样是支持上面列的那些类型。</li>
<li>交换，这个简单粗暴一些，不比较直接交换，这个操作很少会用。</li>
</ul>
<h3 id="互斥锁跟原子操作的区别"><a href="#互斥锁跟原子操作的区别" class="headerlink" title="互斥锁跟原子操作的区别"></a>互斥锁跟原子操作的区别</h3><p>平日里，在并发编程里，Go语言<code>sync</code>包里的同步原语<code>Mutex</code>是我们经常用来保证并发安全的，那么他跟<code>atomic</code>包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：</p>
<ul>
<li>使用目的：<strong>互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护</strong>。</li>
<li>底层实现：<code>Mutex</code>由<strong>操作系统</strong>的调度器实现，而<code>atomic</code>包中的原子操作则由<strong>底层硬件指令</strong>直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在<code>lock-free</code>的情况下保证并发安全，并且它的性能也能做到随<code>CPU</code>个数的增多而线性扩展。</li>
</ul>
<p>对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算机多核的优势。</p>
<p>比如下面这个，使用互斥锁的并发计数器程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutexAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int32</span> =  <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            mu.Lock()</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">            mu.Unlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    timeSpends := time.Now().Sub(start).Nanoseconds()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;use mutex a is %d, spend time: %v\n&quot;</span>, a, timeSpends)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>Mutex</code>改成用方法<code>atomic.AddInt32(&amp;a, 1)</code>调用，在不加锁的情况下仍然能确保对变量递增的并发安全。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AtomicAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int32</span> =  <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            atomic.AddInt32(&amp;a, <span class="number">1</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    timeSpends := time.Now().Sub(start).Nanoseconds()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;use atomic a is %d, spend time: %v\n&quot;</span>, atomic.LoadInt32(&amp;a), timeSpends)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，所有原子操作方法的被操作数形参必须是指针类型，通过指针变量可以获取被操作数在内存中的地址，从而施加特殊的CPU指令，确保同一时间只有一个goroutine能够进行操作</strong>。</p>
<h3 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h3><p>该操作简称<code>CAS</code> (Compare And Swap)。 这类操作的前缀为 <code>CompareAndSwap</code> :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>该操作在<strong>进行交换前首先确保被操作数的值未被更改，即仍然保存着参数 <code>old</code> 所记录的值，满足此前提条件下才进行交换操作</strong>。<code>CAS</code>的做法类似操作数据库时常见的乐观锁机制。</p>
<p>需要注意的是，当有大量的goroutine 对变量进行读写操作时，可能导致<code>CAS</code>操作无法成功，这时可以利用<code>for</code>循环多次尝试。</p>
<p>上面我只列出了比较典型的<code>int32</code>和<code>unsafe.Pointer</code>类型的<code>CAS</code>方法，主要是想说除了读数值类型进行比较交换，还支持对指针进行比较交换。</p>
<blockquote>
<p>unsafe.Pointer提供了绕过Go语言指针类型限制的方法，unsafe指的并不是说不安全，而是说官方并不保证向后兼容。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个struct类型P</span></span><br><span class="line"><span class="keyword">type</span> P <span class="keyword">struct</span>&#123; x, y, z <span class="keyword">int</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行类型P的指针</span></span><br><span class="line"><span class="keyword">var</span> pP *P</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个执行unsafe.Pointer值的指针变量</span></span><br><span class="line">    <span class="keyword">var</span> unsafe1 = (*unsafe.Pointer)(unsafe.Pointer(&amp;pP))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Old pointer</span></span><br><span class="line">    <span class="keyword">var</span> sy P</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了演示效果先将unsafe1设置成Old Pointer</span></span><br><span class="line">    px := atomic.SwapPointer(</span><br><span class="line">        unsafe1, unsafe.Pointer(&amp;sy))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行CAS操作，交换成功，结果返回true</span></span><br><span class="line">    y := atomic.CompareAndSwapPointer(unsafe1, unsafe.Pointer(&amp;sy), px)</span><br><span class="line"></span><br><span class="line">    fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例并不是在并发环境下进行的<code>CAS</code>，只是为了演示效果，先把被操作数设置成了<code>Old Pointer</code>。</p>
<p>其实<code>Mutex</code>的底层实现也是依赖原子操作中的<code>CAS</code>实现的，原子操作的<code>atomic</code>包相当于是<code>sync</code>包里的那些同步原语的实现依赖。</p>
<p>比如互斥锁<code>Mutex</code>的结构里有一个<code>state</code>字段，其是表示锁状态的状态位。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span></span><br><span class="line">    sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便理解，我们在这里将它的状态定义为0和1，0代表目前该锁空闲，1代表已被加锁，以下是<code>sync.Mutex</code>中<code>Lock</code>方法的部分实现代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">   <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">       <span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">           race.Acquire(unsafe.Pointer(m))</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked)</code>中，<code>m.state</code>代表锁的状态，通过<code>CAS</code>方法，判断锁此时的状态是否空闲（<code>m.state==0</code>），是，则对其加锁（<code>mutexLocked</code>常量的值为1）。</p>
<h3 id="atomic-Value保证任意值的读写安全"><a href="#atomic-Value保证任意值的读写安全" class="headerlink" title="atomic.Value保证任意值的读写安全"></a>atomic.Value保证任意值的读写安全</h3><p><code>atomic</code>包里提供了一套<code>Store</code>开头的方法，用来保证各种类型变量的并发写安全，避免其他操作读到了修改变量过程中的脏数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="keyword">int32</span>, val <span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="keyword">int64</span>, val <span class="keyword">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这些操作方法的定义与上面介绍的那些操作的方法类似。</p>
<p>值得一提的是如果你想要并发安全的设置一个结构体的多个字段，除了把结构体转换为指针，通过<code>StorePointer</code>设置外，还可以使用<code>atomic</code>包后来引入的<code>atomic.Value</code>，它在底层为我们完成了从具体指针类型到<code>unsafe.Pointer</code>之间的转换。</p>
<p>有了<code>atomic.Value</code>后，它使得我们可以不依赖于不保证兼容性的<code>unsafe.Pointer</code>类型，同时又能将任意数据类型的读写操作封装成原子性操作（中间状态对外不可见）。</p>
<p><code>atomic.Value</code>类型对外暴露了两个方法：</p>
<ul>
<li><code>v.Store(c)</code> - 写操作，将原始的变量<code>c</code>存放到一个<code>atomic.Value</code>类型的<code>v</code>里。</li>
<li><code>c := v.Load()</code> - 读操作，从线程安全的<code>v</code>中读取上一步存放的内容。</li>
</ul>
<p>1.17 版本我看还增加了<code>Swap</code>和<code>CompareAndSwap</code>方法。</p>
<p>简洁的接口使得它的使用也很简单，只需将需要做并发保护的变量读取和赋值操作用<code>Load()</code>和<code>Store()</code>代替就行了。</p>
<p>由于<code>Load()</code>返回的是一个<code>interface&#123;&#125;</code>类型，所以在使用前我们记得要先转换成具体类型的值，再使用。下面是一个简单的例子演示<code>atomic.Value</code>的用法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    length <span class="keyword">int</span></span><br><span class="line">    width  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect atomic.Value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(width, length <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    rectLocal := <span class="built_in">new</span>(Rectangle)</span><br><span class="line">    rectLocal.width = width</span><br><span class="line">    rectLocal.length = length</span><br><span class="line">    rect.Store(rectLocal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 10 个协程并发更新</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            update(i, i+<span class="number">5</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    _r := rect.Load().(*Rectangle)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;rect.width=%d\nrect.length=%d\n&quot;</span>, _r.width, _r.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以试试，不用<code>atomic.Value</code>，直接给<code>Rectange</code>类型的指针变量赋值，看看在并发条件下，两个字段的值是不是能跟预期的一样变成10和15。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>