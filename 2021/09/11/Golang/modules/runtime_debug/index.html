<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;debug&quot;&gt;&lt;a href=&quot;#debug&quot; class=&quot;headerlink&quot; title=&quot;debug&quot;&gt;&lt;/a&gt;debug&lt;/h2&gt;&lt;p&gt;程序包调试了包含程序在运行时进行调试功能"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>runtime_debug | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-09-11</div></div></div><div class="container post-header"><h1>runtime_debug</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#debug"><span class="toc-number">1.</span> <span class="toc-text">debug</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-FreeOSMemory%EF%BC%9A%E5%BC%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.1.</span> <span class="toc-text">1. FreeOSMemory：强制进行垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SetGCPercent%EF%BC%9A%E8%AE%BE%E5%AE%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E7%9B%AE%E6%A0%87%E7%99%BE%E5%88%86%E6%AF%94"><span class="toc-number">1.2.</span> <span class="toc-text">2. SetGCPercent：设定垃圾收集的目标百分比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SetMaxStack%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%A2%AB%E5%8D%95%E4%B8%AAgo%E5%8D%8F%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A0%88%E5%8F%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.3.</span> <span class="toc-text">3. SetMaxStack：设置被单个go协程调用栈可使用的内存最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-SetMaxThreads%EF%BC%9A%E8%AE%BE%E7%BD%AEgo%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">4. SetMaxThreads：设置go程序可以使用的最大操作系统线程数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-SetPanicOnFault%EF%BC%9A%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E8%AF%B7%E6%B1%82%E8%BF%90%E8%A1%8C%E6%98%AF%E5%8F%AA%E8%A7%A6%E5%8F%91panic-%E8%80%8C%E4%B8%8D%E5%B4%A9%E6%BA%83"><span class="toc-number">1.5.</span> <span class="toc-text">5. SetPanicOnFault：设置程序请求运行是只触发panic,而不崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ReadGCStats%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF%E7%9A%84%E5%86%99%E5%85%A5stats%E4%B8%AD"><span class="toc-number">1.6.</span> <span class="toc-text">6. ReadGCStats：垃圾收集信息的写入stats中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-WriteHeapDump%EF%BC%9A%E5%B0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%A0%86%E5%92%8C%E5%85%B6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">1.7.</span> <span class="toc-text">7. WriteHeapDump：将内存分配堆和其中对象的描述写入文件中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Stack%EF%BC%9A%E8%8E%B7%E5%8F%96go%E5%8D%8F%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A0%88%E8%B8%AA%E8%BF%B9"><span class="toc-number">1.8.</span> <span class="toc-text">8. Stack：获取go协程调用栈踪迹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-PrintStack%EF%BC%9A%E5%B0%86Stack%E8%BF%94%E5%9B%9E%E4%BF%A1%E6%81%AF%E6%89%93%E5%8D%B0%E5%88%B0%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA"><span class="toc-number">1.9.</span> <span class="toc-text">9. PrintStack：将Stack返回信息打印到标准错误输出</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>程序包调试了包含程序在运行时进行调试功能</p>
<ul>
<li>强制进行垃圾回收</li>
<li>设置垃圾回收的目标百分比</li>
<li>设置被单个go协程调用栈可使用的内存最大值</li>
<li>设置go程序可以使用的最大操作系统线程数</li>
<li>设置程序请求运行是只触发panic,而不崩溃</li>
<li>垃圾收集信息的写入stats中</li>
<li>将内存分配堆和其中对象的描述写入文件中</li>
<li>获取go协程调用栈踪迹</li>
<li>将堆栈踪迹打印到标准错误</li>
</ul>
<h3 id="1-FreeOSMemory：强制进行垃圾回收"><a href="#1-FreeOSMemory：强制进行垃圾回收" class="headerlink" title="1. FreeOSMemory：强制进行垃圾回收"></a>1. FreeOSMemory：强制进行垃圾回收</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func FreeOSMemory()</span><br></pre></td></tr></table></figure>

<p>FreeOSMemory强制进行一次垃圾收集，以释放尽量多的内存回操作系统。（即使没有调用，运行时环境也会在后台任务里逐渐将内存释放给系统）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> dic = <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">  <span class="comment">// 设置析构函数</span></span><br><span class="line">  runtime.SetFinalizer(dic, <span class="function"><span class="keyword">func</span><span class="params">(dic *<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;内存回收&quot;</span>) <span class="comment">// 没有执行</span></span><br><span class="line">  &#125;)</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为没有执行垃圾回收，所以fmt.Println(&quot;内存回收&quot;)析构函数没有执行，也就是说dict对象没有被执行回收操作</span></span><br></pre></td></tr></table></figure>

<p>下面我们调用这个方法,runtime.SetFinalizer 对象内存释放触发这个方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> dic = <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">  runtime.SetFinalizer(dic, <span class="function"><span class="keyword">func</span><span class="params">(dic *<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;内存回收&quot;</span>) <span class="comment">// 成功执行</span></span><br><span class="line">  &#125;)</span><br><span class="line">  debug.FreeOSMemory()  <span class="comment">// 手动执行垃圾回收</span></span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-SetGCPercent：设定垃圾收集的目标百分比"><a href="#2-SetGCPercent：设定垃圾收集的目标百分比" class="headerlink" title="2. SetGCPercent：设定垃圾收集的目标百分比"></a>2. SetGCPercent：设定垃圾收集的目标百分比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func SetGCPercent(percent int) int</span><br></pre></td></tr></table></figure>

<ul>
<li>当新申请的内存大小占前次垃圾收集剩余可用内存大小的比率达到设定值时，就会触发垃圾收集。</li>
<li>SetGCPercent返回之前的设定。初始值设定为环境变量GOGC的值；如果没有设置该环境变量，初始值为100。percent参数如果是负数值，会关闭垃圾收集</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(debug.SetGCPercent(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> dic = <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">  runtime.SetFinalizer(&amp;dic, <span class="function"><span class="keyword">func</span><span class="params">(dic *[]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;内存回收1&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 立即回收</span></span><br><span class="line">  runtime.GC()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">  runtime.SetFinalizer(&amp;s, <span class="function"><span class="keyword">func</span><span class="params">(dic *[]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;内存回收2&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  d := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">300</span>,<span class="number">300</span>)</span><br><span class="line">  <span class="keyword">for</span> index,_ := <span class="keyword">range</span> d &#123;</span><br><span class="line">    d[index] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(d)</span><br><span class="line"></span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 1处我们创建了一块内存空间100字节，只有我们调用了<code>runtime.GC()</code>立即回收了内存，</li>
<li>2处我们又创建了一块100字节的内存，等待回收，当我们执行到3处的时候，创建了一个300字节的内存,已大于垃圾回收剩余内存,所以系统继续立即回收内存。</li>
</ul>
<h3 id="3-SetMaxStack：设置被单个go协程调用栈可使用的内存最大值"><a href="#3-SetMaxStack：设置被单个go协程调用栈可使用的内存最大值" class="headerlink" title="3. SetMaxStack：设置被单个go协程调用栈可使用的内存最大值"></a>3. SetMaxStack：设置被单个go协程调用栈可使用的内存最大值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func SetMaxStack(bytes int) int</span><br></pre></td></tr></table></figure>

<p>我们在main函数中使用for循环启用了1000个go协程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt; <span class="number">1000</span>;i++&#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="built_in">print</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功执行</span></span><br></pre></td></tr></table></figure>

<p>接下来我们来限制一下栈的内存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  debug.SetMaxStack(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt; <span class="number">1000</span>;i++&#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="built_in">print</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime:goroutine stack exceeds 1-byte limit </span></span><br><span class="line"><span class="comment">// fatal err: stack overflow</span></span><br></pre></td></tr></table></figure>

<p><code>fmt.Println(debug.SetMaxStack(1))</code> 查看到默认系统为1000 000 000 字节</p>
<p>系统报了一个栈溢出的错误,这个方法的主要作用是限制无限递归go成带来的灾难，默认的设置32位系统是250MB,64位为1GB</p>
<h3 id="4-SetMaxThreads：设置go程序可以使用的最大操作系统线程数"><a href="#4-SetMaxThreads：设置go程序可以使用的最大操作系统线程数" class="headerlink" title="4. SetMaxThreads：设置go程序可以使用的最大操作系统线程数"></a>4. SetMaxThreads：设置go程序可以使用的最大操作系统线程数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func SetMaxThreads(threads int) int</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  debug.SetMaxThreads(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="built_in">print</span>()</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime：program exceeds 1-thread limit</span></span><br><span class="line"><span class="comment">// fatal error: theread exhaustion</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们把程序的组大可使用的线程（不是协程）数设置为1，如果程序试图超过这个限制,程序就会崩溃，初始设置为10000个线程</li>
<li> 什么时候会创建新的线程呢? 现有的线程阻塞，cgo或者runtime.LockOSThread函数阻塞其他go协程</li>
</ul>
<h3 id="5-SetPanicOnFault：设置程序请求运行是只触发panic-而不崩溃"><a href="#5-SetPanicOnFault：设置程序请求运行是只触发panic-而不崩溃" class="headerlink" title="5. SetPanicOnFault：设置程序请求运行是只触发panic,而不崩溃"></a>5. SetPanicOnFault：设置程序请求运行是只触发panic,而不崩溃</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func SetPanicOnFault(enabled bool) bool</span><br></pre></td></tr></table></figure>

<ul>
<li>SetPanicOnFault控制程序在不期望（非nil）的地址出错时的运行时行为。</li>
<li>这些错误一般是因为运行时内存破坏的bug引起的，因此默认反应是使程序崩溃</li>
<li>。使用内存映射的文件或进行内存的不安全操作的程序可能会在非nil的地址出现错误；SetPanicOnFault允许这些程序请求运行时只触发一个panic，而不是崩溃。</li>
<li>SetPanicOnFault只用于当前的go程</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="built_in">print</span>()</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="built_in">recover</span>()&#125;()</span><br><span class="line">  fmt.Println(debug.SetPanicOnFault(<span class="literal">true</span>))</span><br><span class="line">  <span class="keyword">var</span> s *<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line">  *s = <span class="number">34</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// ddd</span></span><br></pre></td></tr></table></figure>

<p>我们发现指针为nil 发生了panic 但是我们进行了恢复,程序继续执行</p>
<h3 id="6-ReadGCStats：垃圾收集信息的写入stats中"><a href="#6-ReadGCStats：垃圾收集信息的写入stats中" class="headerlink" title="6. ReadGCStats：垃圾收集信息的写入stats中"></a>6. ReadGCStats：垃圾收集信息的写入stats中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ReadGCStats(stats *GCStats)</span><br></pre></td></tr></table></figure>

<p> 我们看一下CGStats的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GCStats <span class="keyword">struct</span> &#123;</span><br><span class="line">    LastGC         time.Time       <span class="comment">// 最近一次垃圾收集的时间</span></span><br><span class="line">    NumGC          <span class="keyword">int64</span>           <span class="comment">// 垃圾收集的次数</span></span><br><span class="line">    PauseTotal     time.Duration   <span class="comment">// 所有暂停收集垃圾消耗的总时间</span></span><br><span class="line">    Pause          []time.Duration <span class="comment">// 每次暂停收集垃圾的消耗的时间</span></span><br><span class="line">    PauseQuantiles []time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写一个示例演示一下用法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1000</span>,<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">println</span>(data)</span><br><span class="line">  runtime.GC()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> stats debug.GCStats</span><br><span class="line">  debug.ReadGCStats(&amp;stats)</span><br><span class="line">  fmt.Println(stats.NumGC)</span><br><span class="line">  fmt.Println(stats.LastGC)</span><br><span class="line">  fmt.Println(stats.Pause)</span><br><span class="line">  fmt.Println(stats.PauseTotal)</span><br><span class="line">  fmt.Println(stats.PauseEnd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-WriteHeapDump：将内存分配堆和其中对象的描述写入文件中"><a href="#7-WriteHeapDump：将内存分配堆和其中对象的描述写入文件中" class="headerlink" title="7. WriteHeapDump：将内存分配堆和其中对象的描述写入文件中"></a>7. WriteHeapDump：将内存分配堆和其中对象的描述写入文件中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WriteHeapDump(fd uintptr)</span><br></pre></td></tr></table></figure>

<p> WriteHeapDump将内存分配堆和其中对象的描述写入给定文件描述符fd指定的文件。</p>
<blockquote>
<p>堆转储格式参见<a target="_blank" rel="noopener" href="http://golang.org/s/go13heapdump">http://golang.org/s/go13heapdump</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">   <span class="string">&quot;runtime&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fd,_ := os.OpenFile(<span class="string">&quot;/Users/xujie/go/src/awesomeProject/main/log.txt&quot;</span>,os.O_RDWR|os.O_CREATE,<span class="number">0666</span>)</span><br><span class="line">  debug.WriteHeapDump(fd.Fd())</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">  <span class="built_in">println</span>(data)</span><br><span class="line">  runtime.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-Stack：获取go协程调用栈踪迹"><a href="#8-Stack：获取go协程调用栈踪迹" class="headerlink" title="8. Stack：获取go协程调用栈踪迹"></a>8. Stack：获取go协程调用栈踪迹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Stack() []byte</span><br></pre></td></tr></table></figure>

<ul>
<li>Stack 返回格式化的go程的调用栈踪迹。 </li>
<li>对于每一个调用栈，它包括原文件的行信息和PC值；</li>
<li>对go函数还会尝试获取调用该函数的函数或方法，及调用所在行的文本</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">go</span> <span class="built_in">print</span>()</span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(debug.Stack()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用runtime包中的方法查看更相信的内容</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">go</span> <span class="built_in">print</span>()</span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  callers := <span class="built_in">make</span>([]<span class="keyword">uintptr</span>,<span class="number">100</span>)</span><br><span class="line">  n:=runtime.Callers(<span class="number">1</span>,callers)</span><br><span class="line">  <span class="keyword">for</span> _,pc:= <span class="keyword">range</span> callers[:n]&#123;</span><br><span class="line">    funcPc := runtime.FuncForPC(pc)</span><br><span class="line">    fmt.Println(funcPc.Name())</span><br><span class="line">    fmt.Println(funcPc.FileLine(pc))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-PrintStack：将Stack返回信息打印到标准错误输出"><a href="#9-PrintStack：将Stack返回信息打印到标准错误输出" class="headerlink" title="9. PrintStack：将Stack返回信息打印到标准错误输出"></a>9. PrintStack：将Stack返回信息打印到标准错误输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func PrintStack()</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">      <span class="string">&quot;time&quot;</span></span><br><span class="line">      <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">go</span> <span class="built_in">print</span>()</span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">  debug.PrintStack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>