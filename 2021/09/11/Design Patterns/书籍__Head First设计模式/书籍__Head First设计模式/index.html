<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;面向对象设计的原则&quot;&gt;&lt;a href=&quot;#面向对象设计的原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象设计的原则&quot;&gt;&lt;/a&gt;面向对象设计的原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;封装变化: &lt;strong&gt;把会变化的部分取出并且封装起来&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;多用组合,少用继承&lt;/li&gt;
&lt;li&gt;针对接口编程,不针对实现编程&lt;/li&gt;
&lt;li&gt;交互对象之间尽量松耦合&lt;/li&gt;
&lt;li&gt;类应该对修改封闭,对扩展开放&lt;/li&gt;
&lt;li&gt;要依赖抽象,不要依赖具体类&lt;/li&gt;
&lt;li&gt;最少知识: 减少对象的交互&lt;/li&gt;
&lt;li&gt;防止依赖腐败: 不允许低层组件调用高层组件,但是允许低层组件将自己挂钩到系统上,高层组件会决定什么时候和怎么样使用这些底层组件.&lt;/li&gt;
&lt;li&gt;单一责任原则：一个类应该只有一个引起变化的原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;th&gt;包括&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;创建型模式&lt;/td&gt;
&lt;td&gt;这些设计模式提供一种 在创建对象同时隐藏逻 辑的方式。而不是使用 new运算符直接实例化 对象。&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/01_FactoryPattern&quot;&gt;工厂模式 (Factory Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/02_AbstractFactoryPattern&quot;&gt;抽象工厂模式 (Abstract Factory Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/03_SingletonPattern&quot;&gt;单例模式 (Singleton Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/04_BuilderPattern&quot;&gt;建造者模式 (Builder Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/05_PrototypePattern&quot;&gt;原型模式 (Prototype Pattern)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;结构型模式&lt;/td&gt;
&lt;td&gt;这些设计模式关注类和 对象的组合。继承的概念 被用来组合接口和定义 组合对象获取得新功能 的方式&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/06_AdapterPattern&quot;&gt;适配器模式 (Adapter Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/07_BridgePattern&quot;&gt;桥接模式 (Bridge Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/08_FilterPattern&quot;&gt;过滤器模式 (Filter Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/09_CompositePattern&quot;&gt;组合模式 (Composite Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/10_DecoratorPattern&quot;&gt;装饰器模式Decorator Pattern&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/11_FacadePattern&quot;&gt;外观模式 (Facade Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/12_FlyweightPattern&quot;&gt;享元模式 (Flyweight Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/13_ProxyPattern&quot;&gt;代理模式 (Proxy Pattern)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;行为模式&lt;/td&gt;
&lt;td&gt;这些设计模式特别&lt;strong&gt;关注 对象之间的通信&lt;/strong&gt;。&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/14_ChainOfResponsibilityPattern&quot;&gt;责任链模式 (Chain of Responsibility Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/15_CommandPattern&quot;&gt;命令模式 (Command Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/16_InterpreterPattern&quot;&gt;解释器模式 (Interpreter Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/17_IteratorPattern&quot;&gt;迭代器模式 (Iterator Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/18_MediatorPattern&quot;&gt;中介者模式 (Mediator Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/19_MementoPattern&quot;&gt;备忘录模式 (Memento Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/20_ObserverPattern&quot;&gt;观察者模式 (Observer Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/21_StatePattern&quot;&gt;状态模式 (State Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/24_NullObjectPattern&quot;&gt;空对象模式 (Null Object Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/22_StrategyPattern&quot;&gt;策略模式 (Strategy Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/23_TemplatePattern&quot;&gt;模板模式 (Template Pattern)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;策略模式: 定义了算法族,分别封装起来,让他们之间可以互相替换,此模式让算法的变化独立于使用算法的客户."><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Head First设计模式 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Design-Patterns/" rel="tag">Design Patterns</a></div><div class="post-time">2021-09-11</div></div></div><div class="container post-header"><h1>Head First设计模式</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">面向对象设计的原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98-delegate"><span class="toc-number">3.1.</span> <span class="toc-text">委托(delegate)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AE%BE%E5%AE%9A%E6%96%B9%E6%B3%95%E6%9D%A5%E9%9A%8F%E6%97%B6%E6%94%B9%E5%8F%98Handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.</span> <span class="toc-text">通过设定方法来随时改变Handler的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#has-a-VS-is-a"><span class="toc-number">3.3.</span> <span class="toc-text">has-a VS is-a</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.4.</span> <span class="toc-text">使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E5%AE%9A%E4%B9%89"><span class="toc-number">3.5.</span> <span class="toc-text">回顾定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%BE%E8%80%A6%E5%90%88"><span class="toc-number">4.1.</span> <span class="toc-text">松耦合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-%E6%8E%A8"><span class="toc-number">4.2.</span> <span class="toc-text">步骤(推)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-%E6%8E%A8%E6%8B%89%E5%B9%B6%E8%93%84"><span class="toc-number">4.3.</span> <span class="toc-text">步骤(推拉并蓄)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E5%93%AA%E9%87%8C%E8%83%BD%E9%81%87%E5%88%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">还有哪里能遇到观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-VS-%E7%BB%84%E5%90%88"><span class="toc-number">5.1.</span> <span class="toc-text">继承 VS 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">工厂模式分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">1. 简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">6.3.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">6.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">2. 工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">6.4.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">6.4.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">3. 抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.1.</span> <span class="toc-text">抽象工厂解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">6.5.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">6.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">6.6.</span> <span class="toc-text">三个模式有何关系与区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E4%B8%8E%E6%80%9D%E7%BB%B4%E5%80%92%E7%BD%AE"><span class="toc-number">6.7.</span> <span class="toc-text">依赖倒置与思维倒置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AF%BC%E6%96%B9%E9%92%88"><span class="toc-number">6.8.</span> <span class="toc-text">指导方针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%EF%BC%88Lazy-Loading%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">懒汉模式（Lazy Loading）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E9%94%81%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">带锁的单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%A3%80%E6%9F%A5%E9%94%81%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">带检查锁的单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.</span> <span class="toc-text">原始的单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.5.</span> <span class="toc-text">go风格的单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">7.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">8.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">9.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">9.2.</span> <span class="toc-text">使用适配器的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E4%B8%8E%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">9.3.</span> <span class="toc-text">类适配器与对象适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%8C%85%E8%A3%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">本质是包装模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">9.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">10.1.</span> <span class="toc-text">外观模型的角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%A7%82-%E8%A3%85%E9%A5%B0-%E9%80%82%E9%85%8D%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">10.2.</span> <span class="toc-text">外观,装饰,适配的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">10.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99"><span class="toc-number">10.4.</span> <span class="toc-text">最少知识原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">10.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E5%92%8C%E7%AD%96%E7%95%A5%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.1.</span> <span class="toc-text">模板方法和策略和工厂方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">11.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E9%87%8C%E7%9A%84%E9%92%A9%E5%AD%90"><span class="toc-number">11.3.</span> <span class="toc-text">模板方法里的钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E8%8E%B1%E5%9D%9E%E5%8E%9F%E5%88%99"><span class="toc-number">11.4.</span> <span class="toc-text">好莱坞原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-number">11.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">12.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%B4%A3%E4%BB%BB%E5%8E%9F%E5%88%99"><span class="toc-number">12.2.</span> <span class="toc-text">单一责任原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-number">12.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">13.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E6%80%A7"><span class="toc-number">13.2.</span> <span class="toc-text">透明性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%88%B6%E4%BA%B2%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">13.3.</span> <span class="toc-text">指向父亲的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E4%BA%B2%E8%8A%82%E7%82%B9%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">13.4.</span> <span class="toc-text">父亲节点的缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-number">13.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">14.1.</span> <span class="toc-text">有限状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">14.2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">14.3.</span> <span class="toc-text">策略模式和状态模式区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">14.4.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-number">14.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E4%BB%A3%E7%90%86%E4%BE%8B%E5%AD%90"><span class="toc-number">15.1.</span> <span class="toc-text">几种代理例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">15.2.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">15.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-14"><span class="toc-number">15.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="面向对象设计的原则"><a href="#面向对象设计的原则" class="headerlink" title="面向对象设计的原则"></a>面向对象设计的原则</h2><ul>
<li>封装变化: <strong>把会变化的部分取出并且封装起来</strong></li>
<li>多用组合,少用继承</li>
<li>针对接口编程,不针对实现编程</li>
<li>交互对象之间尽量松耦合</li>
<li>类应该对修改封闭,对扩展开放</li>
<li>要依赖抽象,不要依赖具体类</li>
<li>最少知识: 减少对象的交互</li>
<li>防止依赖腐败: 不允许低层组件调用高层组件,但是允许低层组件将自己挂钩到系统上,高层组件会决定什么时候和怎么样使用这些底层组件.</li>
<li>单一责任原则：一个类应该只有一个引起变化的原因。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><table>
<thead>
<tr>
<th>模式</th>
<th>简介</th>
<th>包括</th>
</tr>
</thead>
<tbody><tr>
<td>创建型模式</td>
<td>这些设计模式提供一种 在创建对象同时隐藏逻 辑的方式。而不是使用 new运算符直接实例化 对象。</td>
<td><a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/01_FactoryPattern">工厂模式 (Factory Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/02_AbstractFactoryPattern">抽象工厂模式 (Abstract Factory Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/03_SingletonPattern">单例模式 (Singleton Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/04_BuilderPattern">建造者模式 (Builder Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/05_PrototypePattern">原型模式 (Prototype Pattern)</a></td>
</tr>
<tr>
<td>结构型模式</td>
<td>这些设计模式关注类和 对象的组合。继承的概念 被用来组合接口和定义 组合对象获取得新功能 的方式</td>
<td><a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/06_AdapterPattern">适配器模式 (Adapter Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/07_BridgePattern">桥接模式 (Bridge Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/08_FilterPattern">过滤器模式 (Filter Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/09_CompositePattern">组合模式 (Composite Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/10_DecoratorPattern">装饰器模式Decorator Pattern</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/11_FacadePattern">外观模式 (Facade Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/12_FlyweightPattern">享元模式 (Flyweight Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/13_ProxyPattern">代理模式 (Proxy Pattern)</a></td>
</tr>
<tr>
<td>行为模式</td>
<td>这些设计模式特别<strong>关注 对象之间的通信</strong>。</td>
<td><a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/14_ChainOfResponsibilityPattern">责任链模式 (Chain of Responsibility Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/15_CommandPattern">命令模式 (Command Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/16_InterpreterPattern">解释器模式 (Interpreter Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/17_IteratorPattern">迭代器模式 (Iterator Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/18_MediatorPattern">中介者模式 (Mediator Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/19_MementoPattern">备忘录模式 (Memento Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/20_ObserverPattern">观察者模式 (Observer Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/21_StatePattern">状态模式 (State Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/24_NullObjectPattern">空对象模式 (Null Object Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/22_StrategyPattern">策略模式 (Strategy Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/23_TemplatePattern">模板模式 (Template Pattern)</a></td>
</tr>
</tbody></table>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p>策略模式: 定义了算法族,分别封装起来,让他们之间可以互相替换,此模式让算法的变化独立于使用算法的客户.</p>
<p>所谓的<code>策略模式</code>: 当我们遇到不同的情况时,需要及时<code>选择不同的策略</code>.</p>
</blockquote>
<p>我们将创建一个定义活动的 <em>Strategy</em> 接口和实现了 <em>Strategy</em> 接口的实体策略类。<em>Context</em> 是一个使用了某种策略的类。</p>
<p><em>StrategyPatternDemo</em>，我们的演示类使用 <em>Context</em> 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</p>
<p><img src="/images/strategy_pattern_uml_diagram.jpg" alt="策略模式的 UML 图"></p>
<h3 id="委托-delegate"><a href="#委托-delegate" class="headerlink" title="委托(delegate)"></a>委托(delegate)</h3><p><code>委托</code>: 将本来应该在这个类方法里实现逻辑,委托给另一个类实现.</p>
<p>当我们执行一长串逻辑,但是中间的部分逻辑是会变的,这时我们就可以将中间的抽离成一个interface,然后直接使用这个interface的方法</p>
<blockquote>
<p>注意:只能将<code>变</code>的部分抽出成委托</p>
</blockquote>
<ul>
<li><p>现在有一个duck类，需要实现walk(),swimming()。但是现在有一个Duck需要实现fly()方法。该怎么做。</p>
</li>
<li><p>为了分开<strong>会变化的部分</strong>和<strong>不会变化的部分</strong>，我们可以将walk，swimming，fly各自实现一个类,或者是一个接口。</p>
<blockquote>
<ul>
<li>duck类不会负责实现Flying和Swimming接口，反而是由一组其他类专门实现FlyBehavior和WalkBehavior。这就称为“行为”类。</li>
<li>这样，把具体的实现不在duck里实现，而是还给其他专门处理的类，实现了<code>按层抽离</code>.所以实际的实现不会绑死在Deck的子类中</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>其实这样也是有奇怪的地方:</p>
<p>class一般是一个东西,但是这里的FlyBehavior却是一个行为.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  <span class="function">flyBehavior FlyBehavior</span></span><br><span class="line"><span class="function">  walkBehavior WalkBehavior</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将本来应该由perfomFly实现的逻辑,交给flyBehavior类来实现</span></span><br><span class="line">    <span class="comment">// 又因为flyBehavior是外部传过来的参数,所以:通过传递不同的flybehavior来控制perfomFly的行为</span></span><br><span class="line">    flyBehavior.fly()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performWalk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    walkBehavior.walk()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg2</span></span><br><span class="line"><span class="keyword">type</span> Spider <span class="keyword">struct</span> &#123;</span><br><span class="line">  requester Requester</span><br><span class="line">  parser Parser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Spider)</span> <span class="title">crawl</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  content,_ := requester.request()</span><br><span class="line">  res,_ := parser.parse(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Requester <span class="keyword">interface</span> &#123;</span><br><span class="line">  request() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Parser <span class="keyword">interface</span> &#123;</span><br><span class="line">  parse() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HomePageRequester <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(s *HomePageRequester)</span> <span class="title">request</span><span class="params">()</span> <span class="title">error</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>现在有很多的handler,但是这些handler都有很多个共同的逻辑,唯一不同的就是adjust方法和extra方法.</p>
<p>所以我们可以将这两个方法委托给Adjuster和ExtraOperater接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// baseHandler用于抽离出所有的公共逻辑</span></span><br><span class="line"><span class="keyword">type</span> BaseHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	Files    []*MarkdownFile</span><br><span class="line">	TrashBin []*MarkdownFile</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BaseHandler还有很多公共方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *BaseHandler)</span> <span class="title">Collect</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *BaseHandler)</span> <span class="title">Rewrite</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">	*BaseHandler</span><br><span class="line">	adjuster Adjuster</span><br><span class="line">	extra ExtraOperater</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := h.Collect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 委托给ajuster</span></span><br><span class="line">		h.adjuster.Adjust()</span><br><span class="line">    <span class="comment">// 委托给extra</span></span><br><span class="line">		<span class="keyword">if</span> err := h.extra.Extra(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">if</span> err := h.Rewrite(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    h.Report()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adjuster <span class="keyword">interface</span> &#123;</span><br><span class="line">	adjust()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExtraOperater <span class="keyword">interface</span> &#123;</span><br><span class="line">	Extra() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的adjuster</span></span><br><span class="line"><span class="keyword">type</span> myAdjuster <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *myAdjuster)</span> <span class="title">adjust</span> <span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的ExtraOperater</span></span><br><span class="line"><span class="keyword">type</span> myExtraOperater <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *myExtraOperater)</span> <span class="title">Extra</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的Handler</span></span><br><span class="line"><span class="keyword">var</span> myHandler = &amp;Handler&#123;</span><br><span class="line">  *BaseHandler,</span><br><span class="line">  <span class="built_in">new</span>(myAdjuster),</span><br><span class="line">  <span class="built_in">new</span>(myExtraOperater),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(hs []Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> hs &#123;</span><br><span class="line">    h.run()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过设定方法来随时改变Handler的行为"><a href="#通过设定方法来随时改变Handler的行为" class="headerlink" title="通过设定方法来随时改变Handler的行为"></a>通过设定方法来随时改变Handler的行为</h3><p>上面的Handler,我们还可以给两个设定方法.这样,我们就可以随时改变Handler的行为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">	*BaseHandler</span><br><span class="line">	adjuster Adjuster</span><br><span class="line">	extra ExtraOperater</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">setAdjuster</span><span class="params">(adjuster Adjuster)</span></span> &#123;</span><br><span class="line">  h.adjuster=adjuster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">setExtraOperater</span><span class="params">(extra ExtraOperater)</span></span> &#123;</span><br><span class="line">  h.extra=extra</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  h := &amp;Handler&#123;</span><br><span class="line">    *BaseHandler,</span><br><span class="line">    <span class="built_in">new</span>(myAdjuster),</span><br><span class="line">    <span class="built_in">new</span>(myExtraOperater),</span><br><span class="line">  &#125;</span><br><span class="line">  h.extra.Extra()</span><br><span class="line">  <span class="comment">// 改变行为</span></span><br><span class="line">  h.setExtraOperater(...)</span><br><span class="line">  h.extra.Extra()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="has-a-VS-is-a"><a href="#has-a-VS-is-a" class="headerlink" title="has-a VS is-a"></a>has-a VS is-a</h3><p>策略模式其实是<code>有一个(has-a)</code>的思想的体现.</p>
<p>每一个Handler都有一个Adjuster,好将调整的逻辑委托给他代为处理</p>
<p>使用组合建立系统具有很大的弹性,不仅可以将算法族封装成类,更可以<code>在运行时动态的改变行为</code>,只要组合的行为对象符合正确的接口标准即可.</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>定义策略执行者</li>
<li>定位设置不同策略的方法</li>
<li>调用策略中的方法,执行策略</li>
<li>定义不同的策略</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现此接口，则为一个策略</span></span><br><span class="line"><span class="keyword">type</span> IStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    do(<span class="keyword">int</span>, <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="keyword">type</span> add <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*add)</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line"><span class="keyword">type</span> reduce <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*reduce)</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略的执行者</span></span><br><span class="line"><span class="keyword">type</span> Operator <span class="keyword">struct</span> &#123;</span><br><span class="line">    strategy IStrategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(operator *Operator)</span> <span class="title">setStrategy</span><span class="params">(strategy IStrategy)</span></span> &#123;</span><br><span class="line">    operator.strategy = strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用策略中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(operator *Operator)</span> <span class="title">calculate</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> operator.strategy.do(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   operator := Operator&#123;&#125;</span><br><span class="line"></span><br><span class="line">   operator.setStrategy(&amp;add&#123;&#125;)</span><br><span class="line">   result := operator.calculate(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;add:&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">   operator.setStrategy(&amp;reduce&#123;&#125;)</span><br><span class="line">   result = operator.calculate(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;reduce:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回顾定义"><a href="#回顾定义" class="headerlink" title="回顾定义"></a>回顾定义</h3><blockquote>
<p>策略模式: 定义了算法族,分别封装起来,让他们之间可以互相替换,此模式让算法的变化独立于使用算法的客户</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">	*BaseHandler</span><br><span class="line">	adjuster Adjuster</span><br><span class="line">	extra ExtraOperater</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := h.Collect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 委托给ajuster</span></span><br><span class="line">		h.adjuster.Adjust()</span><br><span class="line">    <span class="comment">// 委托给extra</span></span><br><span class="line">		<span class="keyword">if</span> err := h.extra.Extra(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">if</span> err := h.Rewrite(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    h.Report()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myAdjuster <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *myAdjuster)</span> <span class="title">adjust</span> <span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myAdjuster2 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *myAdjuster)</span> <span class="title">adjust</span> <span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myAdjuster3 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *myAdjuster)</span> <span class="title">adjust</span> <span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在run方法中,我们把调整的逻辑委托给了<code>Adjuster</code>接口.因此每种不同的调整行为,就需要一个Adjuster接口的实现.(也就是struct) .我们把这些struct,成为<code>算法族</code></li>
<li>因为我们把<code>变化</code>的逻辑委托给了算法族,所以我们的run方法是静态的,也就是说:模式让算法的变化独立于使用算法的客户</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
</li>
<li><p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
</li>
<li><p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
</li>
<li><p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p>
</li>
<li><p><strong>关键代码：实现同一个接口。</strong></p>
</li>
<li><p>应用实例：</p>
<ul>
<li>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 </li>
<li>旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 </li>
<li>JAVA AWT 中的 LayoutManager。</li>
</ul>
</li>
<li><p>优点： </p>
<ul>
<li>算法可以自由切换。 </li>
<li>避免使用多重条件判断。 </li>
<li>扩展性良好。</li>
</ul>
</li>
<li><p>缺点： </p>
<ul>
<li>策略类会增多。 </li>
<li>所有策略类都需要对外暴露。</li>
</ul>
</li>
<li><p>使用场景： </p>
<ul>
<li><strong>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</strong> </li>
<li>一个系统需要动态地在几种算法中选择一种。 </li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
</ul>
</li>
<li><p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>观察者模式: 定义了对象之间的一对多依赖,这样一来,当一个对象改变状态的时候,他的所有依赖者都会收到通知并自动更新.</p>
</blockquote>
<p><code>观察者模式</code>: 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p>
<p>其实观察者模式就是订阅模式.比如很多人的微信订阅了某个公众号.当这个公众号更新的时候,就要通知所有的订阅者.其中这个公众号称为<code>主题(Subject)</code>,订阅者称为<code>观察者(Observer)</code></p>
<blockquote>
<ul>
<li>在观察者模式中,会改变的是主题的状态,以及观察者的数目和类型</li>
<li>主题与观察者都是用接口:<ul>
<li>观察者利用主题的接口向主题注册.</li>
<li>主题利用观察者的接口通知观察者.</li>
</ul>
</li>
</ul>
</blockquote>
<p>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 <em>Subject</em> 类、<em>Observer</em> 抽象类和扩展了抽象类 <em>Observer</em> 的实体类。</p>
<p><em>ObserverPatternDemo</em>，我们的演示类使用 <em>Subject</em> 和实体类对象来演示观察者模式。</p>
<p><img src="/images/observer_pattern_uml_diagram.jpg" alt="观察者模式的 UML 图"></p>
<h3 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h3><ul>
<li>当两个对象之间松耦合,<strong>他们依然可以交互,但是不太清楚彼此的细节.</strong></li>
<li>观察者模式提供了一种对象设计,让主题和观察者之间松耦合.</li>
</ul>
<p>关于观察者的一切,主题只知道观察者实现了某个接口(也就是Observer接口).主题不需要知道观察者的具体类是谁,做了些什么或是其他的细节.</p>
<p>任何时候我们都可以增加新的观察者,因为主题唯一依赖的就是一个实现Observer接口的对象列表.</p>
<h3 id="步骤-推"><a href="#步骤-推" class="headerlink" title="步骤(推)"></a>步骤(推)</h3><ol>
<li>创建 Subject 类。</li>
<li>创建 Observer 类。</li>
<li>创建实体观察者类。</li>
<li>使用 <em>Subject</em> 和实体观察者对象。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户</span></span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 其实update最好设计成</span></span><br><span class="line">    <span class="comment">// update(o *Object, arg int)</span></span><br><span class="line">    <span class="comment">// 第一个参数为object本身,这样观察者就知道是哪个主题下发的通知.</span></span><br><span class="line">    update()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomerA <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomerA)</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我是客户A, 我收到报纸了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomerB <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomerB)</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我是客户B, 我收到报纸了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报社 （被观察者)</span></span><br><span class="line"><span class="keyword">type</span> NewsOffice <span class="keyword">struct</span> &#123;</span><br><span class="line">    customers []Customer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">addCustomer</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line">    n.customers = <span class="built_in">append</span>(n.customers, customer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">newspaperCome</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通知所有客户</span></span><br><span class="line">    n.notifyAllCustomer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">notifyAllCustomer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, customer := <span class="keyword">range</span> n.customers &#123;</span><br><span class="line">        customer.update()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestObserver</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    customerA := &amp;CustomerA&#123;&#125;</span><br><span class="line">    customerB := &amp;CustomerB&#123;&#125;</span><br><span class="line"></span><br><span class="line">    office := &amp;NewsOffice&#123;&#125;</span><br><span class="line">    <span class="comment">// 模拟客户订阅</span></span><br><span class="line">    office.addCustomer(customerA)</span><br><span class="line">    office.addCustomer(customerB)</span><br><span class="line">    <span class="comment">// 新的报纸</span></span><br><span class="line">    office.newspaperCome()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤-推拉并蓄"><a href="#步骤-推拉并蓄" class="headerlink" title="步骤(推拉并蓄)"></a>步骤(推拉并蓄)</h3><p>observer能自己拉取subject的<code>状态</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	StateNormal = <span class="number">1</span></span><br><span class="line">	StateError  = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户</span></span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">interface</span> &#123;</span><br><span class="line">	update()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomerA <span class="keyword">struct</span> &#123;</span><br><span class="line">	office *NewsOffice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomerA)</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是客户A, 我收到报纸了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomerB <span class="keyword">struct</span> &#123;</span><br><span class="line">	office *NewsOffice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomerB)</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是客户B, 我收到报纸了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报社 （被观察者)</span></span><br><span class="line"><span class="keyword">type</span> NewsOffice <span class="keyword">struct</span> &#123;</span><br><span class="line">	state     State</span><br><span class="line">	customers []Customer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">addCustomer</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line">	n.customers = <span class="built_in">append</span>(n.customers, customer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">newspaperCome</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n.state = StateNormal</span><br><span class="line">	<span class="comment">// 通知所有客户</span></span><br><span class="line">	n.notifyAllCustomer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">notifyAllCustomer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, customer := <span class="keyword">range</span> n.customers &#123;</span><br><span class="line">		customer.update()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">setState</span><span class="params">(state State)</span></span>  &#123;</span><br><span class="line">	n.state = state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	office := &amp;NewsOffice&#123;&#125;</span><br><span class="line"></span><br><span class="line">	customerA := &amp;CustomerA&#123;office&#125;</span><br><span class="line">	customerB := &amp;CustomerB&#123;office&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟客户订阅</span></span><br><span class="line">	office.addCustomer(customerA)</span><br><span class="line">	office.addCustomer(customerB)</span><br><span class="line">	<span class="comment">// 新的报纸</span></span><br><span class="line">	office.newspaperCome()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> customerA.office.state == StateNormal &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;observer主动获取subject状态&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="还有哪里能遇到观察者模式"><a href="#还有哪里能遇到观察者模式" class="headerlink" title="还有哪里能遇到观察者模式"></a>还有哪里能遇到观察者模式</h3><p>js中的<code>addLister()</code>就是观察者模式.</p>
<p>实际上,这种<code>监听者</code>都是观察者模式.</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</li>
<li><p>主要解决：<strong>一个对象状态改变给其他对象通知的问题</strong>，而且要考虑到易用和低耦合，保证高度的协作。</p>
</li>
<li><p>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
</li>
<li><p>如何解决：使用面向对象技术，可以将这种依赖关系弱化。</p>
</li>
<li><p>关键代码：<strong>被观察者持有了集合存放观察者</strong> (在抽象类里有一个 ArrayList 存放观察者们).</p>
</li>
<li><p>应用实例： </p>
<ul>
<li>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 </li>
<li>MVC 模式，当 model 改变时，View 视图会自动改变，model 为被观察者，View 为观察者</li>
<li>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</li>
</ul>
</li>
<li><p>优点： </p>
<ul>
<li>观察者和被观察者是抽象耦合的。 </li>
<li>建立一套触发机制。</li>
</ul>
</li>
<li><p>缺点： </p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 </li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 </li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
</li>
<li><p>注意事项： </p>
<ul>
<li>JAVA 中已经有了对观察者模式的支持类。 </li>
<li>避免循环引用。 </li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</li>
</ul>
</li>
</ul>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote>
<p><code>装饰者模式</code>: 动态地将责任附加到对象上.若要扩展功能,装饰者提供了比继承更有弹性的替代方案.</p>
</blockquote>
<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，<strong>它是作为现有的类的一个包装</strong>。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<blockquote>
<p>注意:装饰者和被装饰者必须要有一样的类型.</p>
</blockquote>
<p>装饰者模式适合“零件组合”的情况. 比如奶茶分成加糖,加冰,加奶,加珍珠,加奶昔,加果粒等等.我们就可以<strong>把每类选择都做成一个装饰器</strong>.然后自由组合.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sugger</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ice</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fruit</span>:</span> ...</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 加糖加冰</span></span><br><span class="line"><span class="meta">@Ice</span></span><br><span class="line"><span class="meta">@Sugger</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">naicha</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加糖加果粒</span></span><br><span class="line"><span class="meta">@fruit</span></span><br><span class="line"><span class="meta">@Sugger</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">naicha</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<p>我们将创建一个 <em>Shape</em> 接口和实现了 <em>Shape</em> 接口的实体类。然后我们创建一个实现了 <em>Shape</em> 接口的抽象装饰类 <em>ShapeDecorator</em>，并把 <em>Shape</em> 对象作为它的实例变量。</p>
<p><em>RedShapeDecorator</em> 是实现了 <em>ShapeDecorator</em> 的实体类。</p>
<p><em>DecoratorPatternDemo</em> 类使用 <em>RedShapeDecorator</em> 来装饰 <em>Shape</em> 对象。</p>
<p><img src="/images/image-20210427021402615.png" alt="image-20210427021402615"></p>
<h3 id="继承-VS-组合"><a href="#继承-VS-组合" class="headerlink" title="继承 VS 组合"></a>继承 VS 组合</h3><ul>
<li>利用继承来设计子类的行为,是在编译时静态决定的,而且所有的子类都会继承到相同的行为.</li>
<li>如果能利用组合的做法扩展对象的行为,就可以在运行时动态的进行扩展.</li>
</ul>
<p>这样,我们就可以把多个新的职责,甚至是设计超类时还没有想到的职责加在对象上.而且可以不用修改原来的代码.</p>
<p>这就是所谓的<code>对修改封闭,对扩展开放</code></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>声明一个<code>Beverage</code>接口，作为后续实现的标准(后续的所有类都需要继承这个接口)</li>
<li>声明一个基础结构体<code>Beverage</code>,同时实现getDescription, cost方法即实现了接口</li>
<li>声明一个装饰结构体叫<code>Mocha</code>,将<code>Beverage</code>接口内嵌入此结构体,并实现<code>getDescription()</code>方法和<code>cost()</code>方法, 在里面调用接口<code>Beverage</code>里的<code>getDescription()</code>方法和<code>cost()</code>方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  饮料接口</span></span><br><span class="line"><span class="keyword">type</span> Beverage <span class="keyword">interface</span> &#123;</span><br><span class="line">    getDescription() <span class="keyword">string</span></span><br><span class="line">    cost() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现咖啡的过程</span></span><br><span class="line"><span class="keyword">type</span> Coffee <span class="keyword">struct</span> &#123;</span><br><span class="line">    description <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Coffee)</span> <span class="title">getDescription</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.description</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Coffee)</span> <span class="title">cost</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mocha 实现</span></span><br><span class="line"><span class="keyword">type</span> Mocha <span class="keyword">struct</span> &#123;</span><br><span class="line">    beverage Beverage</span><br><span class="line">    description <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Mocha)</span> <span class="title">getDescription</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用了委托</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, %s&quot;</span>, this.beverage.getDescription(), this.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Mocha)</span> <span class="title">cost</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.beverage.cost() + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whip 实现</span></span><br><span class="line"><span class="keyword">type</span> Whip <span class="keyword">struct</span> &#123;</span><br><span class="line">    beverage Beverage</span><br><span class="line">    description <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Whip)</span> <span class="title">getDescription</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, %s&quot;</span>, this.beverage.getDescription(), this.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Whip)</span> <span class="title">cost</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.beverage.cost() + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> beverage Beverage</span><br><span class="line">    <span class="comment">// 买了一杯咖啡</span></span><br><span class="line">    beverage = Coffee&#123;description:<span class="string">&quot;houseBlend&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 给咖啡加上 Mocha</span></span><br><span class="line">    beverage = Mocha&#123;beverage:beverage, description:<span class="string">&quot;Mocha&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 给咖啡加上 Whip</span></span><br><span class="line">    beverage = Whip&#123;beverage:beverage, description:<span class="string">&quot;whip&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 最后计算 Coffee 的价格</span></span><br><span class="line">    fmt.Println(beverage.getDescription(), <span class="string">&quot;, cost is &quot;</span>, beverage.cost())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</li>
<li>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，<strong>由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</strong></li>
<li><strong>何时使用：在不想增加很多子类的情况下扩展类。</strong></li>
<li>如何解决：将具体功能职责划分，同时继承装饰者模式。</li>
<li>关键代码： <ul>
<li>Component 类充当抽象角色，不应该具体实现。 </li>
<li>修饰类引用和继承 Component 类，具体扩展类重写父类方法。</li>
</ul>
</li>
<li>应用实例： <ul>
<li>孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 </li>
<li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</li>
</ul>
</li>
<li>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li>
<li>缺点：多层装饰比较复杂。</li>
<li>使用场景： <ul>
<li>扩展一个类的功能。 </li>
<li>动态增加功能，动态撤销。</li>
</ul>
</li>
<li>注意事项：可代替继承。</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p><code>工厂模式</code>: 定义了一个创建对象方法的接口,但是由子类决定要实例化的类是哪一个.工厂方法让类把实例化推迟到子类.</p>
</blockquote>
<p>在下述情况下可以考虑使用工厂模式：</p>
<ol>
<li>在编码时不能预见需要创建哪种类的实例。</li>
<li>系统不应依赖于产品类实例如何被创建、组合和表达的细节。</li>
</ol>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>意图：<strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</strong></li>
<li>主要解决：主要解决接口选择的问题。</li>
<li>何时使用：我们明确地计划不同条件下创建不同实例时。</li>
<li>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</li>
<li>关键代码：创建过程在其子类执行，返回的实例都实现同一接口。</li>
<li>应用实例： <ul>
<li>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</li>
<li>Hibernate 换数据库只需换方言和驱动就可以。</li>
</ul>
</li>
<li>优点： <ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。 </li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 </li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
</li>
<li>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li>
<li>使用场景：<ul>
<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </li>
<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </li>
<li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li>
</ul>
</li>
<li>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</li>
</ul>
<h3 id="工厂模式分类"><a href="#工厂模式分类" class="headerlink" title="工厂模式分类"></a>工厂模式分类</h3><p>有的人把工厂模式分成三类：简单工厂模式，工厂方法模式，抽象工厂模式</p>
<p>有的人把工厂模式分成两类，剔除简单工厂模式，将工厂方法模式更名为工厂模式，所以就是：工厂模式，抽象工厂模式</p>
<p><img src="/images/v2-70766d571df02a647149475c5eb207c9_1440w.jpg" alt="img"></p>
<ul>
<li>简单工厂 ： 用来生产同一等级结构中的任意产品。（新增产品就要修改工厂类。符合单一职责原则。不符合开放-封闭原则）</li>
<li>工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品，新增产品时不需要更改已有的工厂，需要增加该产品对应的工厂。符合单一职责原则、符合开放-封闭原则。但是引入了复杂性。）</li>
<li>抽象工厂 ：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开放-封闭原则，降低了复杂性）</li>
</ul>
<blockquote>
<ul>
<li>简单工厂：唯一工厂类，一个产品抽象类，工厂类的创建方法依据入参判断并创建具体产品对象。</li>
<li>工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。</li>
<li>抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。</li>
</ul>
</blockquote>
<h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><ul>
<li>简单工厂模式又叫<code>静态方法模式</code>（因为工厂类定义了一个静态方法）</li>
<li>现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。</li>
</ul>
<p><img src="/images/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg" alt="工厂模式的 UML 图"></p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p><img src="/images/image-20210427184034341.png" alt="image-20210427184034341"></p>
<ol>
<li>创建一个Phone接口</li>
<li>创建实现接口的实体类XiaomiPhone，HuaweiPhone</li>
<li>创建一个工厂Factory，生成基于给定信息的实体类的对象(<code>&amp;XiaomiPhone&#123;&#125;</code>/<code>&amp;HuaweiPhone&#123;&#125;</code>)。</li>
<li>使用该工厂，通过传递类型信息来获取实体类的对象。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂模式</span></span><br><span class="line"><span class="keyword">package</span> pattern</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">	Call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiPhone <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xm *XiaomiPhone)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi phone call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiPhone <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *HuaweiPhone)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei phone call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory)</span> <span class="title">GetPhone</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Phone</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;xiaomi&quot;</span> &#123;</span><br><span class="line">		p = &amp;XiaomiPhone&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;huawei&quot;</span> &#123;</span><br><span class="line">		p = &amp;HuaweiPhone&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSimpleFactory</span><span class="params">(*testing.T)</span></span> &#123;</span><br><span class="line">	f := &amp;Factory&#123;&#125;</span><br><span class="line">	xiaomiPhone := f.GetPhone(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">	xiaomiPhone.Call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>优点</p>
<ul>
<li>可以对创建的对象进行一些 “加工” ，而且客户端并不知道，因为工厂隐藏了这些细节。如果，没有工厂的话，那我们是不是就得自己在客户端上写这些代码，这就好比本来可以在工厂里生产的东西，拿来自己手工制作，不仅麻烦以后还不好维护。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>每次增加子类或者删除子类对象的创建都需要打开这简单工厂类来进行修改。这会导致这个简单工厂类很庞大臃肿、耦合性高，而且增加、删除某个子类对象的创建都需要打开简单工厂类来进行修改代码也违反了开-闭原则。</li>
</ul>
</li>
</ul>
<h3 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a>2. 工厂方法模式</h3><p><strong>工厂方法是为了解决简单工厂增加新的子类就必须增加新的if-else的情况</strong>,所以干脆给FactoryStore类添加一个Factory属性,通过传递不同的Factory来创建不同的Product.</p>
<p><img src="/images/aaa.png" alt="UML类图"></p>
<p>和简单工厂模式的区别：</p>
<ul>
<li>简单工厂模式是：Factory -&gt; xiaomiPhone</li>
<li>抽象工厂模式是：FactoryStore -&gt; xiaomiFactory -&gt; xiaomiPhone</li>
</ul>
<p>因为Factory和Product都有多个struct，因此Factory和Product都有对应的Interface</p>
<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><p><img src="/images/image-20210427184104583.png" alt="image-20210427184104583"></p>
<ol>
<li>创建<strong>抽象产品类</strong>(Phone)，定义具体产品的公共接口；</li>
<li>创建<strong>抽象工厂类</strong>(Factory)，定义具体工厂的公共接口(XiaomiFactory,HuaweiFactory)；</li>
<li>创建<strong>具体产品类</strong>（继承抽象产品类） &amp; 定义生产的具体产品(XiaomiPhone6,XiaomiPhone7,HuaweiPhone10,HuaweiPhone11)；</li>
<li>创建<strong>具体工厂类</strong>（继承抽象工厂类）(FactoryStore)，定义创建对应具体产品实例的方法(GetPhone)；</li>
<li>外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法模式</span></span><br><span class="line"><span class="keyword">package</span> pattern_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">	Call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiPhone6 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xm *XiaomiPhone6)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi phone6 call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiPhone7 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xm *XiaomiPhone7)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi phone7 call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiPhone10 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *HuaweiPhone10)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei phone10 call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiPhone11 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *HuaweiPhone11)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei phone11 call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">interface</span> &#123;</span><br><span class="line">	CreatePhone(name <span class="keyword">string</span>) Phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xmf *XiaomiFactory)</span> <span class="title">CreatePhone</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Phone</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;xiaomi6&quot;</span> &#123;</span><br><span class="line">		p = &amp;XiaomiPhone6&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;xiaomi7&quot;</span> &#123;</span><br><span class="line">		p = &amp;XiaomiPhone7&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hwf *HuaweiFactory)</span> <span class="title">CreatePhone</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Phone</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;huawei10&quot;</span> &#123;</span><br><span class="line">		p = &amp;HuaweiPhone10&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;huawei11&quot;</span> &#123;</span><br><span class="line">		p = &amp;HuaweiPhone11&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FactoryStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory Factory</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *FactoryStore)</span> <span class="title">GetPhone</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fs.factory.CreatePhone(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFactoryMethod</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fs := &amp;FactoryStore&#123;&amp;HuaweiFactory&#123;&#125;&#125;</span><br><span class="line">	phone := fs.GetPhone(<span class="string">&quot;huawei10&quot;</span>)</span><br><span class="line">	phone.Call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>优点</p>
<ul>
<li><strong>更符合开-闭原则</strong>：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可（简单工厂模式需要修改工厂类的判断逻辑）</li>
<li><strong>符合单一职责原则</strong>：每个具体工厂类只负责创建对应的产品（简单工厂中的工厂类存在复杂的switch逻辑判断）</li>
<li><strong>不使用静态工厂方法，可以形成基于继承的等级结构</strong>：简单工厂模式的工厂类使用静态工厂方法</li>
</ul>
<blockquote>
<p>工厂方法模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p>
</blockquote>
</li>
<li><p>缺点</p>
<ul>
<li>添加新产品时，<strong>除了增加新产品类外，还要提供与之对应的具体工厂类</strong>，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。<br>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li>
<li>一个具体工厂只能创建一种具体产品</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>当一个类不知道它所需要的对象的类时</li>
<li>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；<br>当一个类希望通过其子类来指定创建对象时</li>
<li>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
</li>
</ul>
<h3 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h3><p>抽象工厂模式: 提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类.</p>
<p>抽象工厂模式(Abstra Factory Pattern)是<strong>围绕一个超级工厂，创建其他的工厂</strong>。</p>
<blockquote>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
</blockquote>
<p>为了缩减工厂实现子类的数量，不必给每一个产品分配一个工厂类，可以<strong>将产品进行分组，每组中的不同产品由同一个工厂类的不同方法来创建</strong>。</p>
<p>例如，键盘、主机这2种产品可以分到同一个分组——电脑，而不同品牌的电脑由不同的制造商工厂来创建。</p>
<p><img src="/images/v2-26c774778cddec1ae164116df8c1a86e_1440w.jpg" alt="img"></p>
<p>类似这种把产品类分组，组内不同产品由同一工厂类的不同方法实现的设计模式，就是抽象工厂模式。</p>
<p>抽象工厂适用于以下情况：</p>
<ol>
<li>一个系统要独立于它的产品的创建、组合和表示时；</li>
<li>一个系统要由多个产品系列中的一个来配置时；</li>
<li>要强调一系列相关的产品对象的设计以便进行联合使用时；</li>
<li>当你提供一个产品类库，而只想显示它们的接口而不是实现时；</li>
</ol>
<p><img src="/images/image-20210427120638766.png" alt="image-20210427120638766"></p>
<p><img src="/images/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg" alt="抽象工厂模式的 UML 图"></p>
<h4 id="抽象工厂解决的问题"><a href="#抽象工厂解决的问题" class="headerlink" title="抽象工厂解决的问题"></a>抽象工厂解决的问题</h4><p>在工厂模式中，<strong>一个具体的工厂对应一种具体的产品</strong>。但是，有时候我们需要工厂可以提供多个产品对象，而不是单一产品对象。我们首先要理解两个概念</p>
<ul>
<li><strong>产品等级结构</strong> 产品的等级结构就是产品的继承结构，如一个模型工厂，可以画出圆形，长方形和正方形的模型。这里抽象的模型工厂和具体的模型构成了产品等级结构。</li>
<li><strong>产品族</strong> 在抽象工厂模式中，产品族指的是同一个工厂生产的，位于不同产品等级结构的一组产品。如模具厂生产的红色圆形模具，圆形模型属于模型产品等级结构中，红色属于颜料产品等级结构中。</li>
</ul>
<p>例如我们的衣服，上衣由一个工厂生产，有卫衣，有衬衫，有西服。裤子由一个工厂生产，有短裤，有休闲裤，有西裤。这样，不同的上衣和不同的裤子组合起来，就是成了一套衣服，<br>就像QQ秀一样，当你在商城买了一套衣服裤子的时候，就是由这个抽象工厂所生产的。抽象工厂从几个具体的工厂中获取衣服，裤子，帽子等。组合成一套进行成套的售卖。</p>
<p><img src="/images/v2-981e27a93befe8436c8d98eca8e44911_r.jpg" alt="preview"></p>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><p><img src="/images/image-20210427184137080.png" alt="image-20210427184137080"></p>
<ol>
<li>为Phone创建一个接口。</li>
<li>为Phone创建实现接口的实体类(XiaomiPhone,HuaweiPhone)。</li>
<li>为Computer创建一个接口。</li>
<li>为Computer创建实现接口的实体类(XiaomiComputer,HuaweiComputer)。</li>
<li>创建抽象类AbstractFactory来获取 Phone 和 Computer 对象。</li>
<li>创建扩展了 AbstractFactory 的工厂类(XiaomiFactory,HuaweiFactory)，基于给定的信息生成实体类的对象(XiaomiPhone,HuaweiPhone,XiaomiComputer,HuaweiComputer)。</li>
<li>创建一个工厂创造器/生成器类(FactoryProducer)，其GetFactory方法通过传递手机或电脑信息来获取工厂(XiaomiFactory,HuaweiFactory)。</li>
<li>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test_pattern</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">	Call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MiaomiPhone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MiaomiPhone)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiPhone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HuaweiPhone)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Play()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MiaomiComputer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MiaomiComputer)</span> <span class="title">Play</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi play you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiComputer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HuaweiComputer)</span> <span class="title">Play</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei play you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">	CreatePhone() Phone</span><br><span class="line">	CreateComputer() Computer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xf *XiaomiFactory)</span> <span class="title">CreatePhone</span><span class="params">()</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MiaomiPhone&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xf *XiaomiFactory)</span> <span class="title">CreateComputer</span><span class="params">()</span> <span class="title">Computer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MiaomiComputer&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hf *HuaweiFactory)</span> <span class="title">CreatePhone</span><span class="params">()</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;HuaweiPhone&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hf *HuaweiFactory)</span> <span class="title">CreateComputer</span><span class="params">()</span> <span class="title">Computer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;HuaweiComputer&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FactoryProvider <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fp *FactoryProvider)</span> <span class="title">GetFactory</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">AbstractFactory</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f AbstractFactory</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;xiaomi&quot;</span> &#123;</span><br><span class="line">		f = &amp;XiaomiFactory&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;huawei&quot;</span> &#123;</span><br><span class="line">		f = &amp;HuaweiFactory&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAbstractFactory</span><span class="params">(*testing.T)</span></span> &#123;</span><br><span class="line">	fp := &amp;FactoryProvider&#123;&#125;</span><br><span class="line">	xiaomiFactory := fp.GetFactory(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">	xiaomiPhone := xiaomiFactory.CreatePhone()</span><br><span class="line">	xiaomiPhone.Call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>抽象工厂模式说到底就是<strong>多了一层抽象，减少了工厂的数量</strong>。</p>
</li>
<li><p>意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</li>
<li><p>主要解决：主要解决接口选择的问题。</p>
</li>
<li><p>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
</li>
<li><p>如何解决：在一个产品族里面，定义多个产品。</p>
</li>
<li><p>关键代码：在一个工厂里聚合多个同类产品。</p>
</li>
<li><p>应用实例：</p>
<ol>
<li>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。</li>
<li><strong>假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。</strong></li>
<li>用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</li>
</ol>
</li>
<li><p>优点：<strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</strong></p>
</li>
<li><p>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
</li>
<li><p>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
</li>
<li><p>注意事项：产品族难扩展，产品等级易扩展。</p>
</li>
</ul>
<h3 id="三个模式有何关系与区别"><a href="#三个模式有何关系与区别" class="headerlink" title="三个模式有何关系与区别"></a>三个模式有何关系与区别</h3><ol>
<li><p>简单工厂模式屏蔽了创建对象的细节</p>
</li>
<li><p>简单工厂的缺点是:每次增加新的子类就必须增加新的if-else的情况.</p>
<p>工厂方法就是为了解决此问题,所以干脆给FactoryStore类添加一个Factory属性,通过传递不同的Factory来创建不同的Product.</p>
</li>
<li><p>工厂方法的缺点是:<strong>每一种品牌都需要有一个工厂</strong>，如果业务涉及的子类越来越多，会使得系统中类的个数成倍增加，增加了代码的复杂度。抽象工厂就是为了解决此问题. </p>
</li>
</ol>
<blockquote>
<p>简单工厂模式：生产<strong>一个产品</strong>（能生产小米手机和华为手机）</p>
<p>工厂方法模式：生产<strong>一个产品，多个系列</strong>（能生产小米手机和华为手机，且支持小米1，小米2，华为1，华为2）</p>
<p>抽象工厂模式：生产<strong>多个产品，多个系列</strong>（能生产小米手机，小米电脑和华为手机，华为电脑，且支持小米手机1，小米手机2，华为手机1，华为手机2，小米电脑1，小米电脑2，华为电脑1，华为电脑2）</p>
</blockquote>
<p>从最终使用上看</p>
<ol>
<li>简单工厂: 直接调用struct自己的Create方法</li>
<li>工厂方法: 通过委托给factory属性,让factory调用Create方法</li>
<li>抽象工厂: 根据不同种类创建不同的Factory,最后由一个超级工厂进行汇总</li>
</ol>
<p>因为<code>工厂方法</code>比<code>简单工厂</code>多了一个组合,于是就可以通过传入不同的factory属性来创建不同的工厂</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="keyword">type</span> SimpleFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SimpleFactory)</span> <span class="title">CreateGirl</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Girl</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g Girl</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;thin&quot;</span> &#123;</span><br><span class="line">		g = &amp;ThinGirl&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;fat&quot;</span> &#123;</span><br><span class="line">		g = &amp;ThinGirl&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line"><span class="keyword">type</span> FactoryStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory Factory</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *FactoryStore)</span> <span class="title">CreateProduct</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fs.factory.CreateProduct(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">	CreatePhone(name <span class="keyword">string</span>) Phone</span><br><span class="line">	CreateComputer(name <span class="keyword">string</span>) Computer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> FactoryProducer <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fp *FactoryProducer)</span> <span class="title">GetFactory</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">AbstractFactory</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f AbstractFactory</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;phone&quot;</span> &#123;</span><br><span class="line">		f = &amp;PhoneFactory&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;computer&quot;</span> &#123;</span><br><span class="line">		f = &amp;ComputerFactory&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="依赖倒置与思维倒置"><a href="#依赖倒置与思维倒置" class="headerlink" title="依赖倒置与思维倒置"></a>依赖倒置与思维倒置</h3><p>回顾一下工厂方法模式:</p>
<ol>
<li>我们最终的需求是设计PhoneFactory,他支持传入一个name,然后生成一个Phone</li>
<li>既然都是Phone,那么他们应该共享一个Phone接口</li>
<li>既然已经有一个Phon抽象了,当我们设计PhoneFactory的时候就可以直接使用Phone接口,不必使用具体的Phone类了</li>
</ol>
<ul>
<li>正常我们的逻辑是,先设计出PhoneFactory,然后设计他的CreatePhone方法.但是现在,我们先考虑最终设计的Phone是怎么样的,再考虑怎么设计一个Factory去实现Phone.</li>
<li>整个流程是<code>倒置思维</code>的,这里的倒置指的就是和一般的OO设计的思考方向完全相反</li>
</ul>
<h3 id="指导方针"><a href="#指导方针" class="headerlink" title="指导方针"></a>指导方针</h3><p>下面的指导方针能避免违反依赖倒置原则:</p>
<ul>
<li><p>变量不可以持有具体类的引用</p>
<p>如果使用new,就会持有具体类的引用.你可以改用工厂类避开这样的做法.</p>
</li>
<li><p>不要让类派生自具体类<br>如果派生自具体类,你就会依赖具体类.请派生自一个抽象(接口或者重现```抽象类)</p>
</li>
<li><p>不要覆盖基类中已经实现的方法</p>
<p>如果覆盖基类已经实现的方法,那么你的基类就不是一个真正适合被继承的抽象.<strong>基类中已经实现的方法应该由所有的子类共享.</strong></p>
</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>单例模式: 确保一个类只有一个实例,并提供一个全局访问点.</p>
</blockquote>
<h3 id="懒汉模式（Lazy-Loading）"><a href="#懒汉模式（Lazy-Loading）" class="headerlink" title="懒汉模式（Lazy Loading）"></a>懒汉模式（Lazy Loading）</h3><p>懒汉模式是开源项目中使用最多的一种，最大的缺点是非线程安全的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// private</span></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"></span><br><span class="line"><span class="comment">// public</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;     <span class="comment">// not thread safe</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="带锁的单例模式"><a href="#带锁的单例模式" class="headerlink" title="带锁的单例模式"></a>带锁的单例模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;  <span class="comment">// unnecessary locking if instance already created</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="带检查锁的单例模式"><a href="#带检查锁的单例模式" class="headerlink" title="带检查锁的单例模式"></a>带检查锁的单例模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initialized <span class="keyword">uint32</span></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUInt32(&amp;initialized) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initialized == <span class="number">0</span> &#123;</span><br><span class="line">         instance = &amp;singleton&#123;&#125;</span><br><span class="line">         atomic.StoreUint32(&amp;initialized, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="原始的单例模式"><a href="#原始的单例模式" class="headerlink" title="原始的单例模式"></a>原始的单例模式</h3><p>通过双重检查来保证性能和线程安全</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    instance *Instance</span><br><span class="line">    lock     sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重检查保证线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Instance</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果不存在instance,才进入同步区块</span></span><br><span class="line">    <span class="comment">// 因为只有第一次的时候,instance==nil,也就是说,只有第一次才执行同步逻辑,以后都直接返回instance即可,这样就保证了线程安全.</span></span><br><span class="line">    <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">            instance = &amp;Instance&#123;Name: name&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="go风格的单例模式"><a href="#go风格的单例模式" class="headerlink" title="go风格的单例模式"></a>go风格的单例模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    goInstance *Instance</span><br><span class="line">    once       sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用go 实现单例模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoInstance</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Instance</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> goInstance == <span class="literal">nil</span> &#123;</span><br><span class="line">        once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            goInstance = &amp;Instance&#123;Name: name&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> goInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</li>
<li><p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
</li>
<li><p>何时使用：当您想控制实例数目，节省系统资源的时候。</p>
</li>
<li><p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
</li>
<li><p>关键代码：构造函数是私有的。</p>
</li>
<li><p>应用实例：</p>
<ol>
<li>一个班级只有一个班主任。</li>
<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
</ol>
</li>
<li><p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
</li>
<li><p>使用场景：</p>
<ol>
<li>要求生产唯一序列号。</li>
<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ol>
</li>
<li><p>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
</li>
</ul>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote>
<p><code>命令模式（Command Pattern）</code>: 是一种数据驱动的设计模式，它属于行为型模式。</p>
<p>请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
</blockquote>
<p>说人话: </p>
<ol>
<li>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；</li>
<li>对请求排队或者记录请求日志，以及支持可撤销的操作</li>
</ol>
<p>说的再直白一下:</p>
<ul>
<li>将动作的请求封装成一个对象, 将动作的执行封装成另一个对象,两个对象使用一个broker(list)连接</li>
<li>这样就实现了将<strong>动作的请求者和动作的执行者解耦</strong>。也就是将<code>发出请求的对象</code>和<code>接受与执行这些请求的对象</code>分割开来.</li>
</ul>
<p><img src="/images/commanduml.jpg" alt="img"></p>
<p>举例:</p>
<ol>
<li>将<code>购买股票</code>和<code>卖出股票</code>封装成一个对象,这两个对象都接受stock_uuid作为参数</li>
<li>设计一个broker类用于接收这些请求类</li>
<li>设计一个order类,其参数为broker</li>
<li>这样,order类里就有这些请求类,只要遍历,即可购买/卖出股票</li>
</ol>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ul>
<li>在软件系统中，行为的请求者和行为的实现者是一种紧耦合的关系。当我们要对行为进行记录、撤销、或者重做、事物等处理时，这样紧耦合的设计就不太适合。</li>
<li>为了让<strong>行为的请求者和行为的实现者解耦</strong>。我们将一组行为抽象成对象，通过调用者调用接受者来执行命令。</li>
<li>顺序为调用者-&gt;命令-&gt;接受者</li>
</ul>
<blockquote>
<p><strong>命令模式</strong>可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
</blockquote>
<blockquote>
<p>一个 GUI 对象传递一些参数来调用一个业务逻辑对象。 这个过程通常被描述为一个对象发送<em>请求</em>给另一个对象。</p>
<p>GUI 层可以直接访问业务逻辑层：</p>
<p><img src="/images/solution1-zh.png" alt="GUI 层可以直接访问业务逻辑层"></p>
<p>命令模式建议 GUI 对象不直接提交这些请求。 你应该将请求的所有细节 （例如调用的对象、 方法名称和参数列表） 抽取出来组成<em>命令</em>类， 该类中仅包含一个用于触发请求的方法。</p>
<p>命令对象负责连接不同的 GUI 和业务逻辑对象。 此后， GUI 对象无需了解业务逻辑对象是否获得了请求， 也无需了解其对请求进行处理的方式。 GUI 对象触发命令即可， 命令对象会自行处理所有细节工作。</p>
<p><img src="/images/solution2-zh.png" alt="通过命令访问业务逻辑层。"></p>
</blockquote>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令接口 -- 可以保存在请求队形中，方便请求队形处理命令，具体对命令的执行体在实现这个接口的类型结构体中保存着</span></span><br><span class="line"><span class="keyword">type</span> Command <span class="keyword">interface</span> &#123;</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求队形，保存命令列表，在ExecuteCommand函数中遍历执行命令</span></span><br><span class="line"><span class="keyword">type</span> Invoker <span class="keyword">struct</span> &#123;</span><br><span class="line">	comlist []Command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *Invoker)</span> <span class="title">AddCommand</span><span class="params">(c Command)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	i.comlist = <span class="built_in">append</span>(i.comlist, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *Invoker)</span> <span class="title">ExecuteCommand</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> i.comlist &#123;</span><br><span class="line">		val.Run()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInvoker</span><span class="params">()</span> *<span class="title">Invoker</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Invoker&#123;[]Command&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令,实现Command接口，保存一个对该命令如何处理的执行体</span></span><br><span class="line"><span class="keyword">type</span> ConcreteCommandA <span class="keyword">struct</span> &#123;</span><br><span class="line">	receiver ReceiverA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteCommandA)</span> <span class="title">SetReceiver</span><span class="params">(r ReceiverA)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.receiver = r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令的执行体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteCommandA)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.receiver.Execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteCommandA</span><span class="params">()</span> *<span class="title">ConcreteCommandA</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConcreteCommandA&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对ConcreteCommand，如何处理该命令</span></span><br><span class="line"><span class="keyword">type</span> ReceiverA <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReceiverA)</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;针对ConcreteCommandA，如何处理该命令&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReceiverA</span><span class="params">()</span> *<span class="title">ReceiverA</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ReceiverA&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令,实现Command接口，保存一个对该命令如何处理的执行体</span></span><br><span class="line"><span class="keyword">type</span> ConcreteCommandB <span class="keyword">struct</span> &#123;</span><br><span class="line">	receiver ReceiverB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteCommandB)</span> <span class="title">SetReceiver</span><span class="params">(r ReceiverB)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.receiver = r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令的执行体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteCommandB)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.receiver.Execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteCommandB</span><span class="params">()</span> *<span class="title">ConcreteCommandB</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConcreteCommandB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对ConcreteCommandB，如何处理该命令</span></span><br><span class="line"><span class="keyword">type</span> ReceiverB <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ReceiverB)</span> <span class="title">Execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;针对ConcreteCommandB，如何处理该命令&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReceiverB</span><span class="params">()</span> *<span class="title">ReceiverB</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ReceiverB&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCommand</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	invoker := NewInvoker()</span><br><span class="line">  </span><br><span class="line">	concomA := NewConcreteCommandA()</span><br><span class="line">	receA := NewReceiverA()</span><br><span class="line">	concomA.SetReceiver(*receA)</span><br><span class="line">	invoker.AddCommand(concomA)</span><br><span class="line"></span><br><span class="line">	concomB := NewConcreteCommandB()</span><br><span class="line">	receB := NewReceiverB()</span><br><span class="line">	concomB.SetReceiver(*receB)</span><br><span class="line">	invoker.AddCommand(concomB)</span><br><span class="line"></span><br><span class="line">	invoker.ExecuteCommand()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
</li>
<li><p>主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要<strong>对行为进行记录</strong>、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
</li>
<li><p>何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
</li>
<li><p>如何使用：在使用命令模式时,建议将对象拆分成<code>调用者</code>和<code>命令</code>和<code>接收者</code>,其中接收者可以看成是命令的参数,因此接收者会被集成在命令中,作为命令的属性字段存在.</p>
</li>
<li><p>如何解决：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。</p>
</li>
<li><p>关键代码：定义三个角色：</p>
<ol>
<li><strong>receiver：真正的命令执行对象</strong> </li>
<li>Command</li>
<li>invoker：使用命令对象的入口</li>
</ol>
</li>
<li><p>应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p>
</li>
<li><p>优点： </p>
<ol>
<li>降低了系统耦合度。 </li>
<li>新的命令可以很容易添加到系统中去。</li>
</ol>
</li>
<li><p>缺点：使用命令模式可能会导致某些系统有过多的具体命令类。</p>
</li>
<li><p>使用场景：认为是命令的地方都可以使用命令模式，比如： </p>
<ol>
<li>GUI 中每一个按钮都是一条命令。 </li>
<li>模拟 CMD。</li>
</ol>
</li>
<li><p>注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p>
</li>
</ul>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p><code>适配器模式（Adapter Pattern）</code>：是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p>将一个类的接口,转换成客户期望的另一个接口.适配器让原本接口不兼容的类型可以合作无间.</p>
</blockquote>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。<strong>您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡</strong>。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> perttern</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸭子Duck接口，具备呱呱叫和飞行的能力</span></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	quack() <span class="comment">//呱呱叫</span></span><br><span class="line">	fly()   <span class="comment">//飞行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 火鸡Turkey接口</span></span><br><span class="line"><span class="keyword">type</span> Turkey <span class="keyword">interface</span> &#123;</span><br><span class="line">	gobble() <span class="comment">//火鸡不会呱呱叫，只会咯咯叫（gobble）</span></span><br><span class="line">	fly()    <span class="comment">//火鸡也会飞，虽然飞不远</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 野鸭:实现了Duck接口</span></span><br><span class="line"><span class="keyword">type</span> MallardDuck <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MallardDuck)</span> <span class="title">quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Quack...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MallardDuck)</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I&#x27;m flying&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 野火鸡:实现了Turkey接口</span></span><br><span class="line"><span class="keyword">type</span> WildTurkey <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*WildTurkey)</span> <span class="title">gobble</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Gobble...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*WildTurkey)</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;I&#x27;m flying a short distance&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，需要实现想转换成的类型接口，也就是</span></span><br><span class="line"><span class="comment">// 客户所期望看到的接口</span></span><br><span class="line"><span class="keyword">type</span> TurkeyAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">	turkey Turkey</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着，需要取得适配的对象引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTurkeyAdapter</span><span class="params">(turkey Turkey)</span> *<span class="title">TurkeyAdapter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;TurkeyAdapter&#123;turkey&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在需要实现接口中所有的方法，</span></span><br><span class="line"><span class="comment">// quack在类之间的转换很简单，调用gobble就可以。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TurkeyAdapter)</span> <span class="title">quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	this.turkey.gobble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个接口都具备了fly方法，火鸡飞行距离短，</span></span><br><span class="line"><span class="comment">// 要让火鸡和鸭子的飞行能对应，必须连续五次调用火鸡的fly</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *TurkeyAdapter)</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		this.turkey.fly()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdapter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	duck := &amp;MallardDuck&#123;&#125;</span><br><span class="line">	turkey := &amp;WildTurkey&#123;&#125;</span><br><span class="line">	turkeyAdapter := NewTurkeyAdapter(turkey)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;The Turkey says...&quot;</span>)</span><br><span class="line">	turkey.gobble()</span><br><span class="line">	turkey.fly()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;The Duck says...&quot;</span>)</span><br><span class="line">	duck.quack()</span><br><span class="line">	duck.fly()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;The TurkeyAdapter says...&quot;</span>)</span><br><span class="line">	<span class="comment">// 让Turkey也能执行quack()函数 -&gt; 内部其实是执行gobble()函数</span></span><br><span class="line">	turkeyAdapter.quack()</span><br><span class="line">	turkeyAdapter.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用适配器的过程"><a href="#使用适配器的过程" class="headerlink" title="使用适配器的过程"></a>使用适配器的过程</h3><p>现在我们知道什么是适配器了，再看看各部分之间的关系：</p>
<p><img src="/images/2tokbisrk12.JPEG" alt="Golang 设计模式 学习笔记（七）适配器模式"></p>
<p>客户使用适配器的过程如下：</p>
<ol>
<li>客户通过目标接口调用适配器的方法对适配器发出请求。</li>
<li>适配器使用被适配者接口把请求转换成被适配者的一个或者多个调用接口。</li>
<li>客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。</li>
</ol>
<h3 id="类适配器与对象适配器"><a href="#类适配器与对象适配器" class="headerlink" title="类适配器与对象适配器"></a>类适配器与对象适配器</h3><ol>
<li><p>2种适配器都有3个类分别是Target, Adaptee,adapter。2种模式嫁接的方式不同。</p>
</li>
<li><p>client希望使用的是Target.request()。而既有类使用的是Adaptee.SpecificRequest()。request()和SpecificRequest()可能在返回值，参数列表都不同。类适配器模式和对象适配器模式都是通过嫁接一个Adapter进行转换。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;被适配类具有 特殊功能...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标接口，或称为标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体目标类，只提供普通功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;普通类 具有 普通功能...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>类适配器模式采用的是多重继承的方式。</p>
<p>因为 Adapter 类既继承了 Adaptee （被适配类），也实现了 Target 接口（因为 Java 不支持多继承，所以这样来实现），在 Client 类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器类，继承了被适配类，同时实现标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.specificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用普通功能类</span></span><br><span class="line">		Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">		concreteTarget.request();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 使用特殊功能类，即适配类</span></span><br><span class="line">		Target adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">		adapter.request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对象适配器采用的是包含的方式</p>
<p>它不是使用多继承或继承再实现的方式，而是使用<strong>直接关联</strong>，或者称为<strong>委托</strong>的方式。使用对象适配器模式，可以使得 Adapter 类（适配类）根据传入的 Adaptee 对象达到适配多个不同被适配类的功能，当然，此时我们可以为多个被适配类提取出一个接口或抽象类。这样看起来的话，似乎对象适配器模式更加灵活一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器类，直接关联被适配类，同时实现标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">	<span class="comment">// 直接关联被适配类</span></span><br><span class="line">	<span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Adapter</span> <span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 这里是使用委托的方式完成特殊功能</span></span><br><span class="line">		<span class="keyword">this</span>.adaptee.specificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用普通功能类</span></span><br><span class="line">		Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">		concreteTarget.request();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 使用特殊功能类，即适配类，</span></span><br><span class="line">		<span class="comment">// 需要先创建一个被适配类的对象作为参数</span></span><br><span class="line">		Target adapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">		adapter.request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>两者的区别</p>
<ol>
<li>类适配器模式需要创建自身来创建一个Adaptee。对象适配器模式可以直接使用一个已有的Adaptee的实例来转换接口。</li>
<li>类适配器继承了Adaptee,所以可以通过覆写来扩展SpecificRequest()。对象适配器和Adaptee是包含关系不能扩展。</li>
<li>适配器模式因为是继承所以相对静态，而对象适配器模式是包含是组合相对灵活(可以通过写adaptee子类扩展功能)</li>
</ol>
</li>
<li><p>总结:</p>
<ol>
<li>对象适配器:将功能委托给组合的对象</li>
<li>类适配器:将功能委托给父类</li>
</ol>
</li>
</ol>
<h3 id="本质是包装模式"><a href="#本质是包装模式" class="headerlink" title="本质是包装模式"></a>本质是包装模式</h3><ol>
<li>适配器模式也是一种<strong>包装模式</strong>，与之前的 Decorator 装饰模式同样具有包装的功能；此外，对象适配器模式还具有显式委托的意思在里面（其实类适配器也有这种意思，只不过比较隐含而已），那么我在认为它与 Proxy 代理模式也有点类似；</li>
<li>从上面一点对比来看， Decorator 、 Proxy、 Adapter 在实现了自身的最主要目的（这个得看各个模式的最初动机、描述）之外，都<strong>可以在包装的前后进行额外的、特殊的功能上的增减</strong>，因为我认为它们都有委托的实现意思在里面；</li>
<li>适配器模式不适合在详细设计阶段使用它，它是一种<strong>补偿模式</strong>，专用来在系统后期扩展、修改时所用。</li>
<li>适配器模式应该只用于接口的转换工作,如果在接口转换过程中,还涉及其他的功能,比如限流,保护.那么就应该使用装饰器模式.因此,适配器其实可以看成是装饰器的变体.</li>
</ol>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li>意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
<li>主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</li>
<li>何时使用：<ol>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。 </li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 </li>
<li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li>
</ol>
</li>
<li>如何解决：继承或依赖（推荐）。</li>
<li>关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。</li>
<li>应用实例： <ol>
<li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 </li>
<li>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 </li>
<li>在 LINUX 上运行 WINDOWS 程序。 </li>
<li>JAVA 中的 jdbc。</li>
</ol>
</li>
<li>优点： <ol>
<li>可以让任何两个没有关联的类一起运行。 </li>
<li>提高了类的复用。 </li>
<li>增加了类的透明度。 </li>
<li>灵活性好。</li>
</ol>
</li>
<li>缺点： <ol>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 </li>
<li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li>
</ol>
</li>
<li>使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</li>
<li>注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</li>
</ul>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote>
<p>外观模式:<strong>提供了一个统一的接口,用来访问子系统中的一群接口.</strong></p>
<p>外观定义了一个高层接口,让子系统更容易使用.</p>
</blockquote>
<h3 id="外观模型的角色"><a href="#外观模型的角色" class="headerlink" title="外观模型的角色"></a>外观模型的角色</h3><ol>
<li><strong>外观（Facade）角色</strong>：为多个子系统对外提供一个共同的接口。</li>
<li><strong>子系统（Sub System）角色</strong>：实现系统的部分功能，客户可以通过外观角色访问它。</li>
<li><strong>客户（Client）角色</strong>：通过一个外观角色访问各个子系统的功能。</li>
</ol>
<p><img src="/images/2016-04-20_57175853a499f.jpg" alt="img"></p>
<h3 id="外观-装饰-适配的目的"><a href="#外观-装饰-适配的目的" class="headerlink" title="外观,装饰,适配的目的"></a>外观,装饰,适配的目的</h3><p><code>外观模式</code>,<code>装饰器模式</code>,<code>适配器模式</code>的目的:</p>
<ul>
<li>适配模式: 将一个接口转成另一个接口</li>
<li>装饰模式: 不改变接口,但是加入责任</li>
<li>外观模式: 让接口更加简单.</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> facade</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CPU</span></span><br><span class="line"><span class="keyword">type</span> CPU <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(CPU)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;启动CPU。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存</span></span><br><span class="line"><span class="keyword">type</span> Memory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Memory)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;启动内存管理。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬盘</span></span><br><span class="line"><span class="keyword">type</span> Disk <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Disk)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;启动硬盘。。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开机键</span></span><br><span class="line"><span class="keyword">type</span> StartBtn <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(StartBtn)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cpu := &amp;CPU&#123;&#125;</span><br><span class="line">    cpu.start()</span><br><span class="line">  </span><br><span class="line">    memory := &amp;Memory&#123;&#125;</span><br><span class="line">    memory.start()</span><br><span class="line">  </span><br><span class="line">    disk := &amp;Disk&#123;&#125;</span><br><span class="line">    disk.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFacade</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    startBtn := &amp;StartBtn&#123;&#125;</span><br><span class="line">    startBtn.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h3><p><strong>不要调用 从另一个调用中返回对象的方法</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    temp Temp = station.getTemp();</span><br><span class="line">    <span class="keyword">return</span> temp.getTemp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  station Station;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> station.getTemp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个对象 只能调用:</p>
<ol>
<li>自己</li>
<li>传入 自己的方法 的参数</li>
<li>上述参数 所创建或实例化的对象</li>
<li>内嵌入自己的对象(就是has-a的属性)</li>
</ol>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>外观模式<strong>没有封装</strong>子系统,外观只是提供简化的接口.所以客户如果觉得有必要,依然可以直接使用子系统的类.这是外观模式一个很好的特性:提供简化的接口的同时,依然将系统完整的功能暴露出来.</p>
</li>
<li><p><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。</p>
</li>
<li><p><strong>何时使用：</strong></p>
<ol>
<li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 </li>
<li>定义系统的入口。</li>
</ol>
</li>
<li><p><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。</p>
</li>
<li><p><strong>关键代码：</strong>在<strong>客户端和复杂系统之间再加一层</strong>，这一层将调用顺序、依赖关系等处理好。</p>
</li>
<li><p><strong>应用实例：</strong> </p>
<ol>
<li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 </li>
<li>JAVA 的三层开发模式。</li>
</ol>
</li>
<li><p><strong>优点：</strong> </p>
<ol>
<li>减少系统相互依赖。 </li>
<li>提高灵活性。 </li>
<li>提高了安全性。</li>
</ol>
</li>
<li><p><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
</li>
<li><p><strong>使用场景：</strong> </p>
<ol>
<li>为复杂的模块或子系统提供外界访问的模块。 </li>
<li>子系统相对独立。 </li>
<li>预防低水平人员带来的风险。</li>
</ol>
</li>
<li><p><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
</li>
</ol>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><blockquote>
<p><code>模板方法模式</code>: 在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中,模板方法使得子类可以在不改变算法结构的情况下,重新定义算法中的某些步骤.</p>
<p>装饰器模式,适配器模式等等都是<code>封装对象</code>,而模板方法模式是<code>封装算法</code></p>
</blockquote>
<p>模板方法在框架中及其常见,因为对创建框架来说,由框架控制如何做事情,由你指定框架算法中每个步骤的细节.</p>
<h3 id="模板方法和策略和工厂方法的区别"><a href="#模板方法和策略和工厂方法的区别" class="headerlink" title="模板方法和策略和工厂方法的区别"></a>模板方法和策略和工厂方法的区别</h3><ul>
<li><code>模板方法</code>: 子类决定如何实现算法中的步骤</li>
<li><code>策略</code>: 封装可互换的行为,然后使用委托来决定要采用哪一个行为</li>
<li><code>工厂方法</code>: 由子类自己决定实例化哪个具体类</li>
</ul>
<blockquote>
<p>从某种角度上说,工厂方法其实就是模板方法的变种:工厂方法操作是用来创建并返回对象的.</p>
</blockquote>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pattern</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cooker <span class="keyword">interface</span> &#123;</span><br><span class="line">	open()</span><br><span class="line">	fire()</span><br><span class="line">	cooke()</span><br><span class="line">	outfire()</span><br><span class="line">	<span class="built_in">close</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于一个抽象类</span></span><br><span class="line"><span class="keyword">type</span> CookMenu <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(CookMenu)</span> <span class="title">open</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;打开开关&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(CookMenu)</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;开火&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做菜，交给具体的子类实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(CookMenu)</span> <span class="title">cooke</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(CookMenu)</span> <span class="title">outfire</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;关火&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(CookMenu)</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;关闭开关&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装具体步骤</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCook</span><span class="params">(cook Cooker)</span></span> &#123;</span><br><span class="line">	cook.open()</span><br><span class="line">	cook.fire()</span><br><span class="line">	cook.cooke()</span><br><span class="line">	cook.outfire()</span><br><span class="line">	cook.<span class="built_in">close</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiHongShi <span class="keyword">struct</span> &#123;</span><br><span class="line">	CookMenu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*XiHongShi)</span> <span class="title">cooke</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;做西红柿&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ChaoJiDan <span class="keyword">struct</span> &#123;</span><br><span class="line">	CookMenu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ChaoJiDan)</span> <span class="title">cooke</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;做炒鸡蛋&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTemplate</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 做西红柿</span></span><br><span class="line">	xihongshi := &amp;XiHongShi&#123;&#125;</span><br><span class="line">	doCook(xihongshi)</span><br><span class="line">	<span class="comment">// 做炒鸡蛋</span></span><br><span class="line">	chaojidan := &amp;ChaoJiDan&#123;&#125;</span><br><span class="line">	doCook(chaojidan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="模板方法里的钩子"><a href="#模板方法里的钩子" class="headerlink" title="模板方法里的钩子"></a>模板方法里的钩子</h3><p>钩子的作用: 交给子类去实现,控制是否执行某部分算法.</p>
<p>也就是说,<strong>钩子用于可选算法</strong>.同时让子类有机会对模板方法中某些即将发生的步骤做出反应.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面的例子,可以使用一个CustomWantsCondiments函数作为钩子,如果为true表示需要添加调料</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCook</span><span class="params">(cook Cooker)</span></span> &#123;</span><br><span class="line">	cook.open()</span><br><span class="line">	cook.fire()</span><br><span class="line">  <span class="keyword">if</span> CustomWantsCondiments() &#123;</span><br><span class="line">    addConiments()</span><br><span class="line">  &#125;</span><br><span class="line">	cook.cooke()</span><br><span class="line">	cook.outfire()</span><br><span class="line">	cook.<span class="built_in">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h3><p>不允许低层组件调用高层组件,但是允许低层组件将自己挂钩到系统上,高层组件会决定什么时候和怎么样使用这些底层组件.</p>
<p>也就是说: 由超类主控一切, 当他们需要的时候,自然会去调用子类.</p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
<li><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</li>
<li><strong>何时使用：</strong>有一些通用的方法。</li>
<li><strong>如何解决：</strong>将这些通用算法抽象出来。</li>
<li><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。</li>
<li><strong>应用实例：</strong> <ol>
<li>在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 </li>
<li>西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 </li>
<li>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li>
</ol>
</li>
<li><strong>优点：</strong> <ol>
<li>封装不变部分，扩展可变部分。 </li>
<li>提取公共代码，便于维护。 </li>
<li>行为由父类控制，子类实现。</li>
</ol>
</li>
<li><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li>
<li><strong>使用场景：</strong> <ol>
<li>有多个子类共有的方法，且逻辑相同。 </li>
<li>重要的、复杂的方法，可以考虑作为模板方法。</li>
</ol>
</li>
<li><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。</li>
</ol>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p><code>迭代器模式（Iterator Pattern）</code>: 提供一种方法顺序访问哪一个聚合对象中的各个元素,而又不暴露其内部的表示.</p>
<p>迭代器模式是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
</blockquote>
<p>迭代器的作用: 封装遍历</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iterator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//NameRepository 姓名仓库</span></span><br><span class="line"><span class="keyword">type</span> NameRepository <span class="keyword">struct</span> &#123;</span><br><span class="line">	Names []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewNameRepository 实例化姓名仓库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNameRepository</span><span class="params">()</span> *<span class="title">NameRepository</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;NameRepository&#123;</span><br><span class="line">		Names: <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetIterator 获取姓名仓库的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nr *NameRepository)</span> <span class="title">GetIterator</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(nr.Names) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		name, ok = nr.Names[index], <span class="literal">true</span></span><br><span class="line">		index++</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SetName 向姓名仓库添加名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nr *NameRepository)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	nr.Names = <span class="built_in">append</span>(nr.Names, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetIteratorTest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	nameRepository := NewNameRepository()</span><br><span class="line">	nameRepository.SetName(<span class="string">&quot;Jay&quot;</span>)</span><br><span class="line">	nameRepository.SetName(<span class="string">&quot;JJ&quot;</span>)</span><br><span class="line">	nameRepository.SetName(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">	nameRepository.SetName(<span class="string">&quot;Mary&quot;</span>)</span><br><span class="line"></span><br><span class="line">	it := nameRepository.GetIterator()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		name, ok := it()</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Get name: &quot;</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h3><p>一个类应该只有一个引起变化的原因。**也就是说每一个类只负责自己的事情。</p>
<blockquote>
<ul>
<li>在OOP里面，高内聚、低耦合是软件设计追求的目标，而单一职责原则可以看做是高内聚、低耦合的引申，将职责定义为引起变化的原因，以提高内聚性，以此来减少引起变化的原因。</li>
<li>职责过多，可能引起变化的原因就越多，这将是导致职责依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。</li>
<li>单一职责通常意味着单一的功能，因此不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。</li>
</ul>
</blockquote>
<p>我们首先以手机作为单一职责去设计接口，方案如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 充电电源类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricSource</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMobilePhone</span></span>&#123;</span><br><span class="line">  <span class="comment">//运行内存</span></span><br><span class="line">  string RAM &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//手机存储内存</span></span><br><span class="line">  string ROM &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//CPU主频</span></span><br><span class="line">  string CPU &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//屏幕大小</span></span><br><span class="line">  <span class="keyword">int</span> Size &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//手机充电接口</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Charging</span><span class="params">(ElectricSource oElectricsource)</span></span>;</span><br><span class="line">  <span class="comment">//打电话</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RingUp</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//接电话</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReceiveUp</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//上网</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SurfInternet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种设计有没有问题呢？这是一个很有争议的话题。单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情，<strong>原则上来说，我们以手机作为单一职责去设计，也是有一定的道理的，因为我们接口里面都是定义的手机相关属性和行为，引起接口变化的原因只可能是手机的属性或者行为发生变化，从这方面考虑，这种设计是有它的合理性的，如果你能保证需求不会变化或者变化的可能性比较小，那么这种设计就是合理的。</strong></p>
<p>但实际情况我们知道，现代科技日新月异，科技的进步促使着人们不断在手机原有基础上增加新的属性和功能。比如有一天，我们给手机增加了摄像头，那么需要新增一个像素的属性，我们的接口和实现就得改吧，又有一天，我们增加移动办公的功能，那么我们的接口实现是不是也得改。由于上面的设计没有细化到一定的粒度，导致任何一个细小的改动都会引起从上到下的变化，有一种“牵一发而动全身”的感觉。所以需要细化粒度，下面来看看我们如何变更设计。</p>
<p>我们将接口细化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手机属性接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMobilePhoneProperty</span></span>&#123;</span><br><span class="line">  <span class="comment">//运行内存</span></span><br><span class="line">  string RAM &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//手机存储内存</span></span><br><span class="line">  string ROM &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//CPU主频</span></span><br><span class="line">  string CPU &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//屏幕大小</span></span><br><span class="line">  <span class="keyword">int</span> Size &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//摄像头像素</span></span><br><span class="line">  string Pixel &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机功能接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMobilePhoneFunction</span></span>&#123;</span><br><span class="line">  <span class="comment">//手机充电接口</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Charging</span><span class="params">(ElectricSource oElectricsource)</span></span>;</span><br><span class="line">  <span class="comment">//打电话</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RingUp</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//接电话</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReceiveUp</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//上网</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SurfInternet</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//移动办公</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MobileOA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面题的问题，这种设计能够比较方便的解决，如果是增加属性，只需要修改IMobilePhoneProperty和MobileProperty即可；如果是增加功能，只需要修改IMobilePhoneFunction和MobileFunction即可。</p>
<p>貌似完胜第一种解决方案。那么是否这种解决方案就完美了呢？答案还是看情况。<strong>原则上，我们将手机的属性和功能分开了，使得职责更加明确，所有的属性都由IMobilePhoneProperty接口负责，所有的功能都由IMobilePhoneFunction接口负责，如果是需求的粒度仅仅到了属性和功能这一级，这种设计确实是比较好的。</strong></p>
<p>反之，如果粒度再细小一些呢，那我们这种职责划分是否完美呢？比如我们普通的老人机只需要一些最基础的功能，比如它只需要充电、打电话、接电话的功能，但是按照上面的设计，它也要实现IMobilePhoneFunction接口，某一天，我们增加了一个新的功能玩游戏，那么我们就需要在接口上面增加一个方法PlayGame()。可是我们老人机根本用不着实现这个功能，可是由于它实现了该接口，它的内部实现也得重新去写。从这点来说，以上的设计还是存在它的问题。那么，我们如何继续细化接口粒度呢？</p>
<p>接口细化粒度设计如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手机基础属性接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMobilePhoneBaseProperty</span></span>&#123;</span><br><span class="line">  <span class="comment">//运行内存</span></span><br><span class="line">  string RAM &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//手机存储内存</span></span><br><span class="line">  string ROM &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//CPU主频</span></span><br><span class="line">  string CPU &#123; get; set; &#125;</span><br><span class="line">  <span class="comment">//屏幕大小</span></span><br><span class="line">  <span class="keyword">int</span> Size &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机扩展属性接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMobilePhoneExtentionProperty</span></span>&#123;</span><br><span class="line">  <span class="comment">//摄像头像素</span></span><br><span class="line">  string Pixel &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机基础功能接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMobilePhoneBaseFunc</span></span>&#123;</span><br><span class="line">  <span class="comment">//手机充电接口</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Charging</span><span class="params">(ElectricSource oElectricsource)</span></span>;</span><br><span class="line">  <span class="comment">//打电话</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RingUp</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//接电话</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReceiveUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机扩展功能接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMobilePhoneExtentionFunc</span></span>&#123;</span><br><span class="line">  <span class="comment">//上网</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SurfInternet</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//移动办公</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MobileOA</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//玩游戏</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PlayGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><ul>
<li>意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</li>
<li>主要解决：不同的方式来遍历整个整合对象。</li>
<li>何时使用：遍历一个聚合对象。</li>
<li>如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。</li>
<li>关键代码：定义接口：hasNext, next。</li>
<li>应用实例：JAVA 中的 iterator。</li>
<li>优点： <ol>
<li>它支持以不同的方式遍历一个聚合对象。 </li>
<li>迭代器简化了聚合类。 </li>
<li>在同一个聚合上可以有多个遍历。 </li>
<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
</ol>
</li>
<li>缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li>
<li>使用场景： <ol>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。 </li>
<li>需要为聚合对象提供多种遍历方式。 </li>
<li>为遍历不同的聚合结构提供一个统一的接口。</li>
</ol>
</li>
<li>注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</li>
</ul>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p><code>组合模式</code>: 允许你将对象组合成树形结构来表现“整体/部分”层次结构.</p>
<p>组合能让客户以一致的方式处理个别对象以及对象组合.</p>
</blockquote>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Composite</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有的时候是父节点，叶子</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">	Parent() Component</span><br><span class="line">	SetParent(Component)</span><br><span class="line">	Name() <span class="keyword">string</span></span><br><span class="line">	SetName(<span class="keyword">string</span>)</span><br><span class="line">	AddChild(Component)</span><br><span class="line">	Print(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	LeafNode = <span class="literal">iota</span></span><br><span class="line">	CompositeNode</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> component <span class="keyword">struct</span> &#123;</span><br><span class="line">	parent Component</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewComponent</span><span class="params">(kind <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> <span class="title">Component</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Component</span><br><span class="line">	<span class="keyword">switch</span> kind &#123;</span><br><span class="line">	<span class="keyword">case</span> LeafNode: <span class="comment">//根据不同的类型</span></span><br><span class="line">		c = NewLeaf()</span><br><span class="line">	<span class="keyword">case</span> CompositeNode:</span><br><span class="line">		c = NewComposite()</span><br><span class="line">	&#125;</span><br><span class="line">	c.SetName(name)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">Parent</span><span class="params">()</span> <span class="title">Component</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">SetParent</span><span class="params">(parent Component)</span></span> &#123;</span><br><span class="line">	c.parent = parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	c.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">AddChild</span><span class="params">(child Component)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *component)</span> <span class="title">Print</span><span class="params">(string2 <span class="keyword">string</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Leaf <span class="keyword">struct</span> &#123;</span><br><span class="line">	component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeaf</span><span class="params">()</span> *<span class="title">Leaf</span></span> &#123; <span class="comment">// 开辟一个叶子</span></span><br><span class="line">	<span class="keyword">return</span> &amp;Leaf&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Leaf)</span> <span class="title">Print</span><span class="params">(pre <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(pre, c.Name())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Composite <span class="keyword">struct</span> &#123;</span><br><span class="line">	component</span><br><span class="line">	childs []Component <span class="comment">// 叶子集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个组合结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewComposite</span><span class="params">()</span> *<span class="title">Composite</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Composite&#123;childs: <span class="built_in">make</span>([]Component, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Composite)</span> <span class="title">AddChild</span><span class="params">(child Component)</span></span> &#123;</span><br><span class="line">	child.SetParent(c)</span><br><span class="line">	c.childs = <span class="built_in">append</span>(c.childs, child)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Composite)</span> <span class="title">Print</span><span class="params">(pre <span class="keyword">string</span>)</span></span> &#123; <span class="comment">// 打印显示每一个节点</span></span><br><span class="line">	fmt.Println(pre, c.name)</span><br><span class="line">	pre += <span class="string">&quot;   &quot;</span></span><br><span class="line">	<span class="keyword">for</span> _, comp := <span class="keyword">range</span> c.childs &#123;</span><br><span class="line">		comp.Print(pre)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	root := NewComponent(CompositeNode, <span class="string">&quot;root&quot;</span>)</span><br><span class="line">	r1 := NewComponent(CompositeNode, <span class="string">&quot;r1&quot;</span>)</span><br><span class="line">	r2 := NewComponent(CompositeNode, <span class="string">&quot;r2&quot;</span>)</span><br><span class="line">	r3 := NewComponent(CompositeNode, <span class="string">&quot;r3&quot;</span>)</span><br><span class="line">	l1 := NewComponent(LeafNode, <span class="string">&quot;l1&quot;</span>)</span><br><span class="line">	l2 := NewComponent(LeafNode, <span class="string">&quot;l2&quot;</span>)</span><br><span class="line">	l3 := NewComponent(LeafNode, <span class="string">&quot;l3&quot;</span>)</span><br><span class="line">	root.AddChild(r1)</span><br><span class="line">	root.AddChild(r2)</span><br><span class="line">	root.AddChild(r3)</span><br><span class="line">	r1.AddChild(l1)</span><br><span class="line">	r2.AddChild(l2)</span><br><span class="line">	r3.AddChild(l3)</span><br><span class="line">	root.Print(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="透明性"><a href="#透明性" class="headerlink" title="透明性"></a>透明性</h3><ol>
<li>组合模式其实是违背单一责任原则的: <strong>组合模式不但要管理层次结构,而且还要执行节点的操作</strong>.</li>
<li>组合模式以单一责任原则换取透明性.通过让组件的接口同时包含一些管理子节点和叶节点的操作,客户就可以将组合和叶节点一视同仁.也就是说,<strong>一个元素究竟是组合还是叶节点,对客户是透明的</strong>.</li>
<li>组合模式的特点就是: 父亲节点和子节点之间具有相同的方法,也就是说每一个对象都有相同的接口.万一有些对象的行为不太一样,就会出现问题,这就是组合模式缺点.</li>
<li>当有一些对象有一些没有意义的方法调用时,可以将这些方法返回null或false.通常可以将其解释为: 把叶节点想象成一个没有子节点的对象,那么这些方法对叶节点来说也是有意义的.</li>
</ol>
<h3 id="指向父亲的指针"><a href="#指向父亲的指针" class="headerlink" title="指向父亲的指针"></a>指向父亲的指针</h3><p>父亲节点拥有指向孩子的指针,而孩子也可以指向父亲,以便在游走的时候更加方便</p>
<h3 id="父亲节点的缓存"><a href="#父亲节点的缓存" class="headerlink" title="父亲节点的缓存"></a>父亲节点的缓存</h3><p>组合结构很复杂,或者遍历成本太高的情况(比如每个字节点都需要进行计算)下,可以使用缓存临时保存结果,省去遍历的开支.</p>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</li>
<li><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</li>
<li><strong>何时使用：</strong><ol>
<li>您想表示对象的部分-整体层次结构（树形结构）。 </li>
<li>您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ol>
</li>
<li><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。</li>
<li><strong>关键代码：</strong>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</li>
<li><strong>应用实例：</strong> <ol>
<li>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 </li>
<li>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li>
</ol>
</li>
<li><strong>优点：</strong> <ol>
<li>高层模块调用简单。 </li>
<li>节点自由增加。</li>
</ol>
</li>
<li><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</li>
<li><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。</li>
<li><strong>注意事项：</strong>定义时为具体类。</li>
</ol>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><blockquote>
<p>状态模式: 允许对象在内部状态改变时改变他的行为,对象看起来好像修改了她的类.</p>
<p>适用于<code>有限状态机</code>。常用在工作流引擎、工单等涉及到很多状态的场景。</p>
</blockquote>
<h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p><strong>有限状态机（Finite State Machine）</strong>：有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。</p>
<p>有 3 个组成部分：状态（State）、事件（Event）、动作（Action），事件触发状态的转移及动作的执行。</p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li>做法: 状态模式将状态封装成为独立的类,将每个状态的行为局部化到它自己的类中, 并将动作委托到代表当前状态的对象.</li>
<li>从客户的视角来看, 如果说你使用的对象能够完全改变她的行为, 那么你会觉得这个对象实际上是从别的类实例化而来的,然而实际上,我们是在使用组合通过简单应用不同的状态对象来造成类改变的假象.</li>
</ul>
<h3 id="策略模式和状态模式区别"><a href="#策略模式和状态模式区别" class="headerlink" title="策略模式和状态模式区别"></a>策略模式和状态模式区别</h3><ul>
<li>策略模式和状态模式时双胞胎,在出生时才分开.<ul>
<li>策略模式时围绕可以互换的算法来创建成功的业务的,</li>
<li>状态模式通过改变内部的状态来帮助对象自己的行为.</li>
</ul>
</li>
<li>把策略模式想成是: 除了继承之外的一种弹性替代方案. 如果你使用继承定义了一个类的行为,你将被这个行为困住, 甚至要修改她都很难, 有了策略模式, 你可以通过组合不同的对象来改变行为.</li>
<li>把状态模式想成是: 不用在context中防止许多条件判断的替代方案. 通过将行为包装进状态对象中,你可以通过在context内简单的改变状态对象来改变context的行为.</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这里以儿时手柄游戏”超级玛丽“中的马里奥的状态作为例子来讲解。马里奥的状态有4种：小马里奥（Small Mario）、超级马里奥（Super Mario）、超级火焰马里奥（Super Fire Mario）、游戏结束时的马里奥（Dead Mario）</p>
<p>假设游戏里会遇到的事件：</p>
<ul>
<li>E1：吃蘑菇，加100分</li>
<li>E2：吃火焰花，加200分</li>
<li>E3：撞到怪物</li>
</ul>
<p>几种状态转移如下图：</p>
<p><img src="/images/v2-035518ac9cc88d0d0e5e4107cf1b2e9c_1440w.jpg" alt="img"></p>
<p>可以抽象一个状态接口如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IMarioState <span class="keyword">interface</span> &#123;</span><br><span class="line">  getState() State</span><br><span class="line">  obtainMushRoom(*MarioStateMachine)</span><br><span class="line">  obtainFireFlower(*MarioStateMachine)</span><br><span class="line">  meetMonster(*MarioStateMachine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每种状态，实现这个接口，如当马里奥为Small状态时，碰到三种事件时要做出的反应，对应的状态转移和动作（即额外逻辑，这个例子中为加分）是怎样的。</p>
<p>代码中的MarioStateMachine可以理解为状态机，里面含有成员变量IMarioState，状态机遇到什么事件做怎样的状态流转，即演示了上图状态转移的流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pattern_me</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	StateSmall     = State(<span class="string">&quot;Small&quot;</span>)</span><br><span class="line">	StateSuper     = State(<span class="string">&quot;Super&quot;</span>)</span><br><span class="line">	StateSuperFire = State(<span class="string">&quot;SuperFire&quot;</span>)</span><br><span class="line">	StateDead      = State(<span class="string">&quot;Dead&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	SmallMarioInstance     = &amp;SmallMario&#123;&#125;</span><br><span class="line">	SuperMarioInstance     = &amp;SuperMario&#123;&#125;</span><br><span class="line">	SuperFireMarioInstance = &amp;SuperFireMario&#123;&#125;</span><br><span class="line">	DeadMarioInstance      = &amp;DeadMario&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IMarioState <span class="keyword">interface</span> &#123;</span><br><span class="line">	getState() State</span><br><span class="line">	obtainMushRoom(*MarioStateMachine)</span><br><span class="line">	obtainFireFlower(*MarioStateMachine)</span><br><span class="line">	meetMonster(*MarioStateMachine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机</span></span><br><span class="line"><span class="keyword">type</span> MarioStateMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">	score      <span class="keyword">int</span></span><br><span class="line">	marioState IMarioState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitialMarioStateMachine</span><span class="params">()</span> *<span class="title">MarioStateMachine</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MarioStateMachine&#123;</span><br><span class="line">		score:      <span class="number">0</span>,</span><br><span class="line">		marioState: &amp;SmallMario&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MarioStateMachine)</span> <span class="title">ObtainMushRoom</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.marioState.obtainMushRoom(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MarioStateMachine)</span> <span class="title">ObtainFireFlower</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.marioState.obtainFireFlower(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MarioStateMachine)</span> <span class="title">MeetMonster</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.marioState.meetMonster(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MarioStateMachine)</span> <span class="title">Score</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MarioStateMachine)</span> <span class="title">State</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.marioState.getState()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Small</span></span><br><span class="line"><span class="keyword">type</span> SmallMario <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SmallMario)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> StateSmall</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SmallMario)</span> <span class="title">obtainMushRoom</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;</span><br><span class="line">	sm.score += <span class="number">100</span></span><br><span class="line">	sm.marioState = SuperMarioInstance</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SmallMario)</span> <span class="title">obtainFireFlower</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;</span><br><span class="line">	<span class="comment">// will not happen</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SmallMario)</span> <span class="title">meetMonster</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;</span><br><span class="line">	sm.marioState = DeadMarioInstance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Super</span></span><br><span class="line"><span class="keyword">type</span> SuperMario <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SuperMario)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> StateSuper</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SuperMario)</span> <span class="title">obtainMushRoom</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;</span><br><span class="line">	<span class="comment">// will not happen</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SuperMario)</span> <span class="title">obtainFireFlower</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;</span><br><span class="line">	sm.score += <span class="number">200</span></span><br><span class="line">	sm.marioState = SuperFireMarioInstance</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SuperMario)</span> <span class="title">meetMonster</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;</span><br><span class="line">	sm.marioState = SmallMarioInstance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SuperFire</span></span><br><span class="line"><span class="keyword">type</span> SuperFireMario <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SuperFireMario)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> StateSuperFire</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SuperFireMario)</span> <span class="title">obtainMushRoom</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;</span><br><span class="line">	<span class="comment">// will not happen</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SuperFireMario)</span> <span class="title">obtainFireFlower</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;</span><br><span class="line">	sm.score += <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SuperFireMario)</span> <span class="title">meetMonster</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;</span><br><span class="line">	sm.marioState = SmallMarioInstance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dead</span></span><br><span class="line"><span class="keyword">type</span> DeadMario <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *DeadMario)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> StateDead</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *DeadMario)</span> <span class="title">obtainMushRoom</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *DeadMario)</span> <span class="title">obtainFireFlower</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *DeadMario)</span> <span class="title">meetMonster</span><span class="params">(sm *MarioStateMachine)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestState</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fsm := InitialMarioStateMachine()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v %v\n&quot;</span>, fsm.State(), fsm.Score())</span><br><span class="line">	fsm.MeetMonster()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v %v\n&quot;</span>, fsm.State(), fsm.Score())</span><br><span class="line"></span><br><span class="line">	fsm = InitialMarioStateMachine()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v %v\n&quot;</span>, fsm.State(), fsm.Score())</span><br><span class="line">	fsm.ObtainMushRoom()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v %v\n&quot;</span>, fsm.State(), fsm.Score())</span><br><span class="line">	fsm.ObtainFireFlower()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v %v\n&quot;</span>, fsm.State(), fsm.Score())</span><br><span class="line">	fsm.MeetMonster()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v %v\n&quot;</span>, fsm.State(), fsm.Score())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</li>
<li><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</li>
<li><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</li>
<li><strong>如何解决：</strong>将各种具体的状态类抽象出来。</li>
<li><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</li>
<li><strong>应用实例：</strong> <ol>
<li>打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 </li>
<li>曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</li>
</ol>
</li>
<li><strong>优点：</strong> <ol>
<li>封装了转换规则。 </li>
<li>枚举可能的状态，在枚举状态之前需要确定状态种类。 </li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 </li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 </li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ol>
</li>
<li><strong>缺点：</strong> <ol>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 </li>
<li>状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ol>
</li>
<li><strong>使用场景：</strong> <ol>
<li>行为随状态改变而改变的场景。 </li>
<li>条件、分支语句的代替者。</li>
</ol>
</li>
<li><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</li>
</ol>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>代理模式: 为另一个对象提供一个替身或占位符以控制对这个对象的访问.</p>
</blockquote>
<ul>
<li>你是一个白脸,提供很好的友善的服务,但是你希望每个人都叫你做事,所以你找了黑脸控制对你的访问.这就是代理要做的: 控制和管理访问</li>
<li>所谓代理, 就是代表某个真实的对象.</li>
<li>比如说远程代理: 就是代理假装他是真正的对象,但是其实一切动作是它利用网络和真正的对象沟通.</li>
</ul>
<h3 id="几种代理例子"><a href="#几种代理例子" class="headerlink" title="几种代理例子"></a>几种代理例子</h3><ul>
<li><code>远程代理</code>控制访问对象</li>
<li><code>虚拟代理</code>控制访问创建开销大的对象</li>
<li><code>保护代理</code>基于权限控制对资源的访问</li>
</ul>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul>
<li>动态代理之所以被称为动态, 是因为运行时才将他的类创建出来. 代码开始执行时, 还没有proxy类,他是根据需要从你传入的接口集创建的.</li>
</ul>
<h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Modem 猫，负责访问网页</span></span><br><span class="line"><span class="keyword">type</span> Modem <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Modem)</span> <span class="title">Access</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;正常访问：&quot;</span> + url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果小孩想上网查资料，但是又不想让他上和学习无关的网站，就需要对网络的访问进行控制。</span></span><br><span class="line"><span class="comment">//Proxy 代理了Modem的网络访问功能</span></span><br><span class="line"><span class="keyword">type</span> Proxy <span class="keyword">struct</span> &#123;</span><br><span class="line">    blacklist []<span class="keyword">string</span></span><br><span class="line">    m         Modem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FilterAccess 可以看到这里增加了控制，限制某些网站的访问</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Proxy)</span> <span class="title">FilterAccess</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> t.blacklist &#123;</span><br><span class="line">        <span class="keyword">if</span> v == url &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;禁止访问：&quot;</span> + url)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.m.Access(url) <span class="comment">//最终访问网络还是使用的Modem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Proxy&#123;blacklist: []<span class="keyword">string</span>&#123;<span class="string">&quot;www.bilibili.com&quot;</span>, <span class="string">&quot;www.youku.com&quot;</span>&#125;, m: Modem&#123;&#125;&#125;</span><br><span class="line">    p.FilterAccess(<span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line">    p.FilterAccess(<span class="string">&quot;www.bilibili.com&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 正常访问：www.baidu.com</span></span><br><span class="line"><span class="comment">// 禁止访问：www.bilibili.com</span></span><br></pre></td></tr></table></figure>



<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</li>
<li><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</li>
<li><strong>何时使用：</strong>想在访问一个类时做一些控制。</li>
<li><strong>如何解决：</strong>增加中间层。</li>
<li><strong>关键代码：</strong>实现与被代理类组合。</li>
<li><strong>应用实例：</strong> <ol>
<li>Windows 里面的快捷方式。 </li>
<li>猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 </li>
<li>买火车票不一定在火车站买，也可以去代售点。 </li>
<li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 </li>
<li>spring aop。</li>
</ol>
</li>
<li><strong>优点：</strong> <ol>
<li>职责清晰。 </li>
<li>高扩展性。 </li>
<li>智能化。</li>
</ol>
</li>
<li><strong>缺点：</strong> <ol>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 </li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ol>
</li>
<li><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： <ol>
<li>远程代理。 </li>
<li>虚拟代理。 </li>
<li>Copy-on-Write 代理。 </li>
<li>保护（Protect or Access）代理。 </li>
<li>Cache代理。 </li>
<li>防火墙（Firewall）代理。 </li>
<li>同步化（Synchronization）代理。 </li>
<li>智能引用（Smart Reference）代理。</li>
</ol>
</li>
<li><strong>注意事项：</strong> <ol>
<li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 </li>
<li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li>
</ol>
</li>
</ol>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>