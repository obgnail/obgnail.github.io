<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;interface是一组method签名的组合，我们通过interface来定义对象的一组行为。&lt;strong&gt;interface 是一种类型&lt;/strong&gt;，定义如下："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>真的理解go interface了吗？ | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-09-14</div></div></div><div class="container post-header"><h1>真的理解go interface了吗？</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">实现接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">两种接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#interface%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">interface内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-type"><span class="toc-number">2.1.1.</span> <span class="toc-text">runtime_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-itab"><span class="toc-number">2.1.2.</span> <span class="toc-text">runtime_itab</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E7%9A%84interface%EF%BC%88runtime-eface%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">空的interface（runtime.eface）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80"><span class="toc-number">3.1.</span> <span class="toc-text">问题一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C"><span class="toc-number">3.2.</span> <span class="toc-text">问题二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89"><span class="toc-number">3.3.</span> <span class="toc-text">问题三</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>interface是一组method签名的组合，我们通过interface来定义对象的一组行为。<strong>interface 是一种类型</strong>，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">    Eat(food <span class="keyword">string</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的定义可以看出来用了 type 关键字，更准确的说 interface 是一种<strong>具有一组方法的类型</strong>，这些方法定义了 interface 的行为。<code>golang</code>接口定义不能包含变量，但是允许不带任何方法，这种类型的接口叫<code>empty interface</code>。</p>
<p><strong>如果一个类型实现了一个<code>interface</code>中所有方法，我们就可以说该类型实现了该<code>interface</code>，所以我们我们的所有类型都实现了<code>empty interface</code>，因为任何一种类型至少实现了0个方法。</strong></p>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>这里先拿<code>java</code>语言来举例，在<code>java</code>中，我们要实现一个<code>interface</code>需要这样声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWriter</span> <span class="title">implments</span> <span class="title">io</span>.<span class="title">Writer</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这就意味着对于接口的实现都需要显示声明，在代码编写方面有依赖限制，同时需要处理包的依赖，而在<code>Go</code>语言中实现接口就是隐式的，举例说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RPCError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Code    <span class="keyword">int64</span></span><br><span class="line">    Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *RPCError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, code=%d&quot;</span>, e.Message, e.Code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，并没有<code>error</code>接口的影子，我们只需要实现<code>Error() string</code>方法就实现了<code>error</code>接口。在<code>Go</code>中，实现接口的所有方法就隐式地实现了接口。我们使用上述 <code>RPCError</code> 结构体时并不关心它实现了哪些接口，Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查。</p>
<p><code>Go</code>语言的这种写法很方便，不用引入包依赖。但是<code>interface</code>底层实现的时候会动态检测也会引入一些问题：</p>
<ul>
<li>性能下降。使用interface作为函数参数，runtime 的时候会动态的确定行为。使用具体类型则会在编译期就确定类型。</li>
<li>不能清楚的看出struct实现了哪些接口，需要借助ide或其它工具。</li>
</ul>
<h2 id="两种接口"><a href="#两种接口" class="headerlink" title="两种接口"></a>两种接口</h2><p>Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：</p>
<ul>
<li>使用<code>runtime.iface</code>表示包含方法的接口。</li>
<li>使用<code>runtime.eface</code>表示不包含任何方法的 <code>interface&#123;&#125;</code> 类型，第二种在我们日常开发中经常使用到，所以在实现时使用了特殊的类型。</li>
</ul>
<p>从编译角度来看，golang并不支持泛型编程。但还是可以用<code>interface&#123;&#125;</code> 来替换参数，而实现泛型。</p>
<h3 id="interface内部结构"><a href="#interface内部结构" class="headerlink" title="interface内部结构"></a>interface内部结构</h3><p><code>runtime.eface</code>结构体在<code>Go</code>语言中的定义是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只包含指向底层数据和类型的两个指针，从这个<code>type</code>我们也可以推断出Go语言的任意类型都可以转换成<code>interface</code>。</p>
<p>另一个用于表示接口的结构体是 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?url=https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a>，这个结构体中有指向原始数据的指针 <code>data</code>，不过更重要的是 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?url=https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 类型的 <code>tab</code> 字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们一起看看<code>interface</code>中这两个类型：</p>
<h4 id="runtime-type"><a href="#runtime-type" class="headerlink" title="runtime_type"></a>runtime_type</h4><p><code>runtime_type</code>是 Go 语言类型的运行时表示。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldAlign <span class="keyword">uint8</span></span><br><span class="line">    kind       <span class="keyword">uint8</span></span><br><span class="line">    equal      <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line">    gcdata     *<span class="keyword">byte</span></span><br><span class="line">    str        nameOff</span><br><span class="line">    ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我只对几个比较重要的字段进行讲解：</p>
<ul>
<li><code>size</code> 字段存储了类型占用的内存空间，为内存空间的分配提供信息；</li>
<li><code>hash</code> 字段能够帮助我们快速确定类型是否相等；</li>
<li><code>equal</code> 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 <code>typeAlg</code> 结构体中迁移过来的)；</li>
</ul>
<h4 id="runtime-itab"><a href="#runtime-itab" class="headerlink" title="runtime_itab"></a>runtime_itab</h4><p><code>runtime.itab</code>结构体是接口类型的核心组成部分，每一个 <code>runtime.itab</code> 都占 32 字节，我们可以将其看成接口类型和具体类型的组合，它们分别用 <code>inter</code> 和 <code>_type</code> 两个字段表示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123; <span class="comment">// 32 字节</span></span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  <span class="keyword">uint32</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inter</code>和<code>_type</code>是用于表示类型的字段，<code>hash</code>是对<code>_type.hash</code>的拷贝，当我们想将 <code>interface</code> 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 <code>runtime._type</code>是否一致，<code>fun</code>是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 <code>fun</code> 数组中保存的元素数量是不确定的；</p>
<p>内部结构就做一个简单介绍吧，有兴趣的同学可以自行深入学习。</p>
<h3 id="空的interface（runtime-eface）"><a href="#空的interface（runtime-eface）" class="headerlink" title="空的interface（runtime.eface）"></a>空的interface（<code>runtime.eface</code>）</h3><p>前文已经介绍了什么是空的<code>interface</code>，下面我们来看一看空的<code>interface</code>如何使用。定义函数入参如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的入参是<code>interface</code>类型，要注意的是，<code>interface</code>类型不是任意类型，他与C语言中的<code>void *</code>不同，如果我们将类型转换成了 <code>interface&#123;&#125;</code> 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 <code>interface&#123;&#125;</code>，之所以函数可以接受任何类型是在 go 执行时传递到函数的任何类型都被自动转换成 <code>interface&#123;&#125;</code>。</p>
<p>那么我们可以才来一个猜想，既然空的 interface 可以接受任何类型的参数，那么一个 <code>interface&#123;&#125;</code>类型的 slice 是不是就可以接受任何类型的 slice ？下面我们就来尝试一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStr</span><span class="params">(str []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> str &#123;</span><br><span class="line">        fmt.Println(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    names := []<span class="keyword">string</span>&#123;<span class="string">&quot;stanley&quot;</span>, <span class="string">&quot;david&quot;</span>, <span class="string">&quot;oscar&quot;</span>&#125;</span><br><span class="line">    printStr(names)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./main.go:15:10: cannot use names (type []string) as type []interface &#123;&#125; in argument to printStr</span></span><br></pre></td></tr></table></figure>

<p>这里我也是很疑惑，为什么<code>Go</code>没有帮助我们自动把<code>slice</code>转换成<code>interface</code>类型的<code>slice</code>，之前做项目就想这么用，结果失败了。后来我终于找到了<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?url=https://github.com/golang/go/wiki/InterfaceSlice">答案</a>，有兴趣的可以看看原文，这里简单总结一下：<code>interface</code>会占用两个字长的存储空间，一个是自身的 methods 数据，一个是指向其存储值的指针，也就是 interface 变量存储的值，因而 slice []interface{} 其长度是固定的<code>N*2</code>，但是 []T 的长度是<code>N*sizeof(T)</code>，两种 slice 实际存储值的大小是有区别的。</p>
<p>既然这种方法行不通，那可以怎样解决呢？我们可以直接使用元素类型是interface的切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []<span class="keyword">int</span> = foo()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>上面介绍了<code>interface</code>的基本使用方法及可能会遇到的一些问题，下面出三个题，看看你们真的掌握了吗？</p>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>下面代码，哪一行存在编译错误？（多选）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Set</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(x *<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Student&#123;&#125;</span><br><span class="line">    p := &amp;s</span><br><span class="line">    <span class="comment">// A B C D</span></span><br><span class="line">    Set(s)</span><br><span class="line">    Get(s)</span><br><span class="line">    Set(p)</span><br><span class="line">    Get(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：B、D；解析：我们上文提到过，<code>interface</code>是所有<code>go</code>类型的父类，所以<code>Get</code>方法只能接口<code>*interface&#123;&#125;</code>类型的参数，其他任何类型都不可以。</p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>这段代码的运行结果是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintInterface</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;this is empty interface&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is non-empty interface&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pointer *<span class="keyword">string</span> = <span class="literal">nil</span></span><br><span class="line">    PrintInterface(pointer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：<code>this is non-empty interface</code>。解析：这里的<code>interface&#123;&#125;</code>是空接口类型，他的结构如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在调用函数<code>PrintInterface</code>时发生了<strong>隐式的类型转换</strong>，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，<code>*string</code>类型会转换成<code>interface</code>类型，发生值拷贝，所以<code>eface struct&#123;&#125;</code>是不为<code>nil</code>，不过<code>data</code>指针指向的<code>poniter</code>为<code>nil</code>。</p>
<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>这段代码的运行结果是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">Walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAnimal</span><span class="params">()</span> <span class="title">Animal</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d *Dog</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> NewAnimal() == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;this is empty interface&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;this is non-empty interface&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：<code>this is non-empty interface</code>. 解析：这里的<code>interface</code>是非空接口<code>iface</code>，他的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>d</code>是一个指向nil的空指针，但是最后<code>return d</code> 会触发<code>匿名变量 Animal = p</code>值拷贝动作，所以最后<code>NewAnimal()</code>返回给上层的是一个<code>Animal interface&#123;&#125;</code>类型，也就是一个<code>iface struct&#123;&#125;</code>类型。</li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>