<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="地址:&lt;a href=&quot;https://www.bilibili.com/video/BV1pt41127FZ&quot;&gt;https://www.bilibili.com/video/BV1pt41127FZ&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>尚硅谷韩顺平Go语言核心编程 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-10-30</div></div></div><div class="container post-header"><h1>尚硅谷韩顺平Go语言核心编程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Go 的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E6%B3%A8%E6%84%8F%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4"><span class="toc-number">2.</span> <span class="toc-text">除法注意类型保持一致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">string类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E8%BD%AC%E6%88%90-string-%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">基本类型 转成 string 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fmt-Sprintf"><span class="toc-number">3.1.1.</span> <span class="toc-text">fmt.Sprintf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#conv-FormatInt"><span class="toc-number">3.1.2.</span> <span class="toc-text">conv.FormatInt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strconv-Itoa"><span class="toc-number">3.1.3.</span> <span class="toc-text">strconv.Itoa</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E7%B1%BB%E5%9E%8B-%E8%BD%AC%E6%88%90-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">string 类型 转成 基本类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">4.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%9C%AC%E8%BA%AB%E4%B9%9F%E6%9C%89%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.</span> <span class="toc-text">指针本身也有地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">值类型和引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="toc-number">6.</span> <span class="toc-text">键盘输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#label"><span class="toc-number">7.</span> <span class="toc-text">label</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">8.</span> <span class="toc-text">包引用的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91"><span class="toc-number">9.</span> <span class="toc-text">代码执行的底层逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">自定义函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">11.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer%E5%92%8Cdefer%E6%A0%88"><span class="toc-number">12.</span> <span class="toc-text">defer和defer栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%87%BD%E6%95%B0%E5%A4%96%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">13.</span> <span class="toc-text">短赋值语句不能在函数外执行的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">时间和日期的相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Time%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">14.1.</span> <span class="toc-text">Time结构体和格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E5%92%8C%E4%BC%91%E7%9C%A0"><span class="toc-number">14.2.</span> <span class="toc-text">时间间隔和休眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">14.3.</span> <span class="toc-text">时间戳</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">内置函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">15.1.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make"><span class="toc-number">15.2.</span> <span class="toc-text">make</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defer-recover%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">16.1.</span> <span class="toc-text">defer+recover的错误处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">16.2.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%BC%BA%E8%A1%8C%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84"><span class="toc-number">17.</span> <span class="toc-text">使用指针强行改变数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">18.</span> <span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%92%8Cslice%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">18.1.</span> <span class="toc-text">string和slice的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%BD%A2%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">二维数组的内存形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">20.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">21.</span> <span class="toc-text">引用类型的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%BD%A2%E5%BC%8F"><span class="toc-number">22.</span> <span class="toc-text">结构体的内存形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E8%80%85%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">23.</span> <span class="toc-text">接收者是值类型还是指针类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84String-%E6%96%B9%E6%B3%95"><span class="toc-number">23.1.</span> <span class="toc-text">结构体的String()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">24.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">25.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">25.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99"><span class="toc-number">25.2.</span> <span class="toc-text">就近原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5"><span class="toc-number">25.3.</span> <span class="toc-text">将基本类型作为匿名结构体嵌入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">26.1.</span> <span class="toc-text">鸭子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97"><span class="toc-number">26.2.</span> <span class="toc-text">接口嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface%E7%B1%BB%E5%9E%8B"><span class="toc-number">26.3.</span> <span class="toc-text">interface类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">26.4.</span> <span class="toc-text">接口和继承的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">26.5.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">26.6.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">27.</span> <span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E8%AF%BB%E5%8F%96ReadString"><span class="toc-number">27.1.</span> <span class="toc-text">带缓冲读取ReadString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E8%A1%8C%E8%AF%BB%E5%8F%96ReadLine"><span class="toc-number">27.2.</span> <span class="toc-text">按行读取ReadLine()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9ioutil-ReadFile"><span class="toc-number">27.3.</span> <span class="toc-text">一次性读取所有内容ioutil.ReadFile()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5WriteString"><span class="toc-number">27.4.</span> <span class="toc-text">写入WriteString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">27.5.</span> <span class="toc-text">文件操作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">27.6.</span> <span class="toc-text">复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">27.7.</span> <span class="toc-text">判断文件是否存在</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">28.</span> <span class="toc-text">命令行参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os-Args"><span class="toc-number">28.1.</span> <span class="toc-text">os.Args</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flag%E5%8C%85"><span class="toc-number">28.2.</span> <span class="toc-text">flag包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Json%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">29.</span> <span class="toc-text">Json序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-tag"><span class="toc-number">29.1.</span> <span class="toc-text">struct tag</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Json%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">30.</span> <span class="toc-text">Json反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">31.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#goroutine"><span class="toc-number">32.</span> <span class="toc-text">goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">32.1.</span> <span class="toc-text">goroutine调用说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MPG%E6%A8%A1%E5%9E%8B"><span class="toc-number">32.2.</span> <span class="toc-text">MPG模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEgolang%E7%A8%8B%E5%BA%8F%E7%9A%84CPU%E6%95%B0%E9%87%8F"><span class="toc-number">32.3.</span> <span class="toc-text">设置golang程序的CPU数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">32.4.</span> <span class="toc-text">goroutine可能出现的两个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%981-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%85%88%E4%BA%8Egoroutine%E7%BB%93%E6%9D%9F"><span class="toc-number">32.4.1.</span> <span class="toc-text">问题1 : 主线程先于goroutine结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982-goroutine%E8%B5%84%E6%BA%90%E4%BA%89%E6%8A%A2"><span class="toc-number">32.4.2.</span> <span class="toc-text">问题2 : goroutine资源争抢</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8Cgoroutine%E8%BF%9B%E8%A1%8C%E9%80%9A%E8%AE%AF"><span class="toc-number">33.</span> <span class="toc-text">不同goroutine进行通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B7%BB%E5%8A%A0%E9%94%81"><span class="toc-number">33.1.</span> <span class="toc-text">全局变量添加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel"><span class="toc-number">33.2.</span> <span class="toc-text">channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chan%E6%93%8D%E4%BD%9C"><span class="toc-number">33.2.1.</span> <span class="toc-text">chan操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chan%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">33.2.2.</span> <span class="toc-text">chan使用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chan%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B2"><span class="toc-number">33.2.3.</span> <span class="toc-text">chan使用案例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%8F%AA%E5%86%99%E7%AE%A1%E9%81%93"><span class="toc-number">33.2.4.</span> <span class="toc-text">只读只写管道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select"><span class="toc-number">34.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">35.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect-Kind-%E5%92%8C-reflect-Type%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">35.1.</span> <span class="toc-text">reflect.Kind 和 reflect.Type的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface-reflect-Value-%E5%92%8C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC"><span class="toc-number">35.2.</span> <span class="toc-text">interface , reflect.Value 和 变量类型互转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%8F%8D%E5%B0%84%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BF%AE%E6%94%B9int%E5%80%BC"><span class="toc-number">35.3.</span> <span class="toc-text">在反射函数中修改int值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E6%AE%B5-%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95-%E8%8E%B7%E5%8F%96stuct-tag%E5%80%BC"><span class="toc-number">35.4.</span> <span class="toc-text">使用反射遍历结构体的字段,调用结构体方法,获取stuct tag值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">35.5.</span> <span class="toc-text">go的适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="toc-number">36.</span> <span class="toc-text">自定义错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DAO"><span class="toc-number">37.</span> <span class="toc-text">DAO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%BC%96%E7%A8%8B"><span class="toc-number">38.</span> <span class="toc-text">TCP编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">39.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">39.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">39.2.</span> <span class="toc-text">Redis连接池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="toc-number">40.</span> <span class="toc-text">稀疏数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="toc-number">41.</span> <span class="toc-text">环形队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="toc-number">41.1.</span> <span class="toc-text">数组模拟环形队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">41.2.</span> <span class="toc-text">环形单向链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">42.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">43.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">43.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">43.2.</span> <span class="toc-text">插入排序</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>地址:<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pt41127FZ">https://www.bilibili.com/video/BV1pt41127FZ</a></p>
<h2 id="Go-的执行过程"><a href="#Go-的执行过程" class="headerlink" title="Go 的执行过程"></a>Go 的执行过程</h2><p><img src="/images/init-1591940814843.png" alt="init"></p>
<h2 id="除法注意类型保持一致"><a href="#除法注意类型保持一致" class="headerlink" title="除法注意类型保持一致"></a>除法注意类型保持一致</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num1 := <span class="number">10.0</span></span><br><span class="line">	num3 := <span class="number">2</span></span><br><span class="line">	fmt.Println(num1 / <span class="number">2</span>) <span class="comment">// 5</span></span><br><span class="line">	<span class="comment">// fmt.Println(num1 / num3)  error</span></span><br><span class="line">	fmt.Println(num1 / <span class="keyword">float64</span>(num3))</span><br><span class="line">  fmt.Println(<span class="number">100</span> / <span class="number">2</span>) <span class="comment">// 5</span></span><br><span class="line">	fmt.Println(num1 / <span class="number">2</span>)<span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第4行正确</li>
<li>第5行会报错</li>
<li>第6行正确</li>
</ul>
<blockquote>
<p>原因 : 变量是由有类型的 , 但是<code>2</code>是常量值，是无类型的</p>
<ul>
<li>对于除数而言 , 必须保证类型一致 : 所以<code>fmt.Println(num1 / 2)</code>正确 , 但是 <code>num3 := 2</code>,<code>fmt.Println(num1 / num3)</code>错误</li>
<li>但是对于被除数而言就没有, 所以第7,8行执行成功</li>
</ul>
</blockquote>
<h2 id="string类型转换"><a href="#string类型转换" class="headerlink" title="string类型转换"></a>string类型转换</h2><h3 id="基本类型-转成-string-类型"><a href="#基本类型-转成-string-类型" class="headerlink" title="基本类型 转成 string 类型"></a>基本类型 转成 string 类型</h3><h4 id="fmt-Sprintf"><a href="#fmt-Sprintf" class="headerlink" title="fmt.Sprintf"></a>fmt.Sprintf</h4><p>根据format参数 , 格式化的字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num1 := <span class="number">99</span></span><br><span class="line">	str := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,num1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T , %q&quot;</span>,str,str) <span class="comment">// string , &quot;99&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="conv-FormatInt"><a href="#conv-FormatInt" class="headerlink" title="conv.FormatInt"></a>conv.FormatInt</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num1 := <span class="number">99</span></span><br><span class="line">	str := strconv.FormatInt(<span class="keyword">int64</span>(num1),<span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T , %q&quot;</span>,str,str) <span class="comment">// string , &quot;99&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="strconv-Itoa"><a href="#strconv-Itoa" class="headerlink" title="strconv.Itoa"></a>strconv.Itoa</h4><p>参数是一个整型数字，它可以将数字转换成对应的字符串类型的数字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	string_number := <span class="number">97</span></span><br><span class="line">	result := strconv.Itoa(string_number)</span><br><span class="line"> </span><br><span class="line">	fmt.Println(result) <span class="comment">// 97</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, result) <span class="comment">// string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="string-类型-转成-基本类型"><a href="#string-类型-转成-基本类型" class="headerlink" title="string 类型 转成 基本类型"></a>string 类型 转成 基本类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myStr := <span class="string">&quot;true&quot;</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">	b, _ = strconv.ParseBool(myStr)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T ,%v&quot;</span>, b, b) <span class="comment">// bool ,true</span></span><br><span class="line"></span><br><span class="line">	myStr2 := <span class="string">&quot;999&quot;</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int64</span></span><br><span class="line">	i, _ = strconv.ParseInt(myStr2,<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T ,%v&quot;</span>, i, i) <span class="comment">// int64 ,999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在将 String类型转成基本数据类型时，要确保 String类型能够转成有效的数据，</li>
<li>比如我们可以把“123”，转成一个整数，但是不能把hello转成一个整数，</li>
<li>如果这样做，直接返回数据类型的默认值(<code>零值</code>)</li>
</ul>
</blockquote>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针本身也有地址"><a href="#指针本身也有地址" class="headerlink" title="指针本身也有地址"></a>指针本身也有地址</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;num的地址为%p&quot;</span>,&amp;num) <span class="comment">// num的地址为0xc0000140b0</span></span><br><span class="line"></span><br><span class="line">	ptr := &amp;num</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ptr的地址为%p&quot;</span>,&amp;ptr) <span class="comment">// ptr的地址为0xc0000ca020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关系如下:</p>
<ul>
<li>ptr本身也要在内存中开辟一块小内存</li>
<li>这个小内存的地址就是0xc0000ca020</li>
<li>这个小内存的值就是num的地址值</li>
</ul>
<p><img src="/images/1591112038636.png" alt="1591112038636"></p>
<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><ul>
<li>值类型：变量直接存储值，内存通常在栈中分配</li>
<li>引用类型：<strong>变量存储的是一个地址，这个地址对应的空间才真正存储数据（值）</strong>，内存通常在<code>堆</code>上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收</li>
</ul>
<ul>
<li>值类型：int系列，float系列，bool，string、array和struct</li>
<li>引用类型：指针、slice切片、map、管道chan、interface</li>
</ul>
<h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><ul>
<li>fmt.Scanln() : 换行时才停止扫描</li>
<li>fmt.Scanf() : 自定义格式输入</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;input your name&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;name) <span class="comment">// 将用户输入 填充到 name变量中</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> isMarry <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;输入姓名,年龄,是否结婚,按空格分隔&quot;</span>)</span><br><span class="line">	fmt.Scanf(<span class="string">&quot;%s %d %b&quot;</span>, &amp;name, &amp;age, &amp;isMarry)</span><br><span class="line">	fmt.Println(name, age, isMarry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p>使用label可以直接跳出外层循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">outer:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//inner:</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= i; j++ &#123;</span><br><span class="line">			fmt.Print(i, <span class="string">&quot;*&quot;</span>, j, <span class="string">&quot;=&quot;</span>, i*j, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">7</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> outer</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="包引用的本质"><a href="#包引用的本质" class="headerlink" title="包引用的本质"></a>包引用的本质</h2><p>正常用法 : new目录下的包的包名就叫做<code>new</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello/new/aaa.go</span></span><br><span class="line"><span class="keyword">package</span> <span class="built_in">new</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Name = <span class="string">&quot;heyingliang&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello/cf/bbb.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello/new&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="built_in">new</span>.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>非正常用法 : new目录下的包的包名不合目录名一致 , 叫做<code>abc</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello/new/aaa.go</span></span><br><span class="line"><span class="keyword">package</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Name = <span class="string">&quot;heyingliang&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello/cf/bbb.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello/new&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(abc.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>就是说 , <code>import &quot;hello/new&quot;</code>这句话本身就包含as语句 : </p>
<p><code>import &quot;hello/new as new目录下的package_name</code></p>
</blockquote>
<h2 id="代码执行的底层逻辑"><a href="#代码执行的底层逻辑" class="headerlink" title="代码执行的底层逻辑"></a>代码执行的底层逻辑</h2><p><img src="/images/1591151865916.png" alt="1591151865916"></p>
<ol>
<li>在调用一个函数时，会给该函数分配一个新的空间，编译器会通过自身的处理让这个新的空间其它的栈的空间区分开来</li>
<li>在每个函数对应的栈中，数据空间是空间的，不会混淆</li>
<li>当一个函数调用完毕（执行完毕）后，程序会销毁这个函数对应的栈空间。</li>
</ol>
<h2 id="自定义函数类型"><a href="#自定义函数类型" class="headerlink" title="自定义函数类型"></a>自定义函数类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> myFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deco</span><span class="params">(f myFunc)</span> <span class="title">myFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;========&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> f(num1, num2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(num1 <span class="keyword">int</span> , num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	add := deco(add)</span><br><span class="line">	fmt.Println(add(<span class="number">11</span>,<span class="number">88</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//========</span></span><br><span class="line"><span class="comment">//99</span></span><br></pre></td></tr></table></figure>



<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>一个函数返回的是一个匿名函数，</li>
<li>但是这个<strong>匿名函数引用到函数外的变量，因此这个匿名函数就和该变量形成个整体</strong>，构成闭包。</li>
</ul>
<h2 id="defer和defer栈"><a href="#defer和defer栈" class="headerlink" title="defer和defer栈"></a>defer和defer栈</h2><ul>
<li>defer是栈</li>
<li><strong>defer不是引用</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok1&quot;</span>, n1)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok2&quot;</span>, n2)</span><br><span class="line">	n1++</span><br><span class="line">	n2++</span><br><span class="line">	res := n1 + n2</span><br><span class="line">	fmt.Println(<span class="string">&quot;ok3&quot;</span>, res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ok3 5</span></span><br><span class="line"><span class="comment">//ok2 2</span></span><br><span class="line"><span class="comment">//ok1 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDefer</span><span class="params">(arr []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">1</span>, arr)</span><br><span class="line">	arr = <span class="built_in">append</span>(arr, <span class="string">&quot;999&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="number">2</span>, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">string</span>&#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;345&quot;</span>,<span class="string">&quot;456&quot;</span>&#125;</span><br><span class="line">	test_go.TestDefer(arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [123 345 456]</span></span><br><span class="line"><span class="comment">// 2 [123 345 456 999]</span></span><br><span class="line"><span class="comment">// 1 [123 345 456]</span></span><br></pre></td></tr></table></figure>



<h2 id="短赋值语句不能在函数外执行的原因"><a href="#短赋值语句不能在函数外执行的原因" class="headerlink" title="短赋值语句不能在函数外执行的原因"></a>短赋值语句不能在函数外执行的原因</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name := <span class="string">&quot;heyingliang&quot;</span> <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>Name:=&quot;heyingliang&quot;</code>等价于</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Name <span class="keyword">string</span> </span><br><span class="line">Name = <span class="string">&quot;heyingliang&quot;</span> <span class="comment">// 这句话不能在函数外执行</span></span><br></pre></td></tr></table></figure>



<h2 id="时间和日期的相关函数"><a href="#时间和日期的相关函数" class="headerlink" title="时间和日期的相关函数"></a>时间和日期的相关函数</h2><h3 id="Time结构体和格式化"><a href="#Time结构体和格式化" class="headerlink" title="Time结构体和格式化"></a>Time结构体和格式化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Time结构体</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v , %T&quot;</span>, now, now)</span><br><span class="line">	<span class="comment">// 2020-06-03 13:44:43.4144992 +0800 CST m=+0.002991801 , time.Time</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Time结构体属性</span></span><br><span class="line">	fmt.Println(now.Year()) <span class="comment">// 2020</span></span><br><span class="line">	fmt.Println(now.Month(),<span class="keyword">int</span>(now.Month())) <span class="comment">// June 6</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 格式化</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d-%d-%d %d %d %d&quot;</span>,</span><br><span class="line">		now.Year(),now.Month(),now.Day(),</span><br><span class="line">		now.Hour(),now.Minute(),now.Second()) <span class="comment">// 2020-6-3 13 50 36</span></span><br><span class="line"></span><br><span class="line">	dateStr := fmt.Sprintf(<span class="string">&quot;%d-%d-%d %d %d %d&quot;</span>,</span><br><span class="line">		now.Year(),now.Month(),now.Day(),</span><br><span class="line">		now.Hour(),now.Minute(),now.Second())</span><br><span class="line">	fmt.Println(dateStr) <span class="comment">// 2020-6-3 13 51 36</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种格式化,通过2006/01/02 15:04:05这个标准的排列组合(定死的标准)来修改时间格式</span></span><br><span class="line">	fmt.Printf(now.Format(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>)) <span class="comment">// 2020/06/03 13:55:48</span></span><br><span class="line">	fmt.Printf(now.Format(<span class="string">&quot;2006-01-02 15 04 05&quot;</span>)) <span class="comment">// 2020-06-03 13 55 48</span></span><br><span class="line">	fmt.Printf(now.Format(<span class="string">&quot;01/02 15:04:05&quot;</span>)) <span class="comment">// 06/03 13:55:48</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="时间间隔和休眠"><a href="#时间间隔和休眠" class="headerlink" title="时间间隔和休眠"></a>时间间隔和休眠</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">	Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">	Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">	Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">	Minute               = <span class="number">60</span> * Second</span><br><span class="line">	Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sleep</span><span class="params">(d Duration)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>在python中 , 我们使用<code>time.sleep(100)</code> , 使用数字100来表示休眠的时间</li>
<li>但是golang中 , 使用了一个自定义的Duration的数据类型来表示休眠时间</li>
<li>所以 , 我们只能给<code>Sleep()</code>函数Duration类型的数据</li>
<li>注意 , Duration类型的数据 <code>限死了不能使用除法</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">		<span class="comment">//time.Sleep(time.Second * 0.1) error:不能使用除法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	fmt.Println(now.Unix())     <span class="comment">// 秒数:1591164601</span></span><br><span class="line">	fmt.Println(now.UnixNano()) <span class="comment">// 纳秒数:1591164601433357600</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试执行时间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(num ...<span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> num &#123;</span><br><span class="line">		res += n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now().UnixNano()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ &#123;</span><br><span class="line">		sum([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;...)</span><br><span class="line">	&#125;</span><br><span class="line">	end := time.Now().UnixNano()</span><br><span class="line">	fmt.Println((end-start)/<span class="number">1000</span>/<span class="number">1000</span>, <span class="string">&quot;ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型零值的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num1 := <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%v,%v\n&quot;</span>, num1, num1, &amp;num1)</span><br><span class="line">	<span class="comment">// int,100,0xc0000a0068</span></span><br><span class="line"></span><br><span class="line">	num2 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T,%v,%v,%v\n&quot;</span>, num2, num2, &amp;num2, *num2)</span><br><span class="line">	<span class="comment">// *int,0xc0000140e0,0xc000006030,0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>用来分配内存 , 主要用来分配引用类型 , 比如chan . map . slice </p>
<blockquote>
<p>跟 new 不同的是，make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(Type, size IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<ul>
<li>new 的作用是**初始化一个指向类型的指针(*T)**，</li>
<li>make 的作用是为 slice，map 或 chan **初始化并返回引用(T)**。</li>
</ul>
</blockquote>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="defer-recover的错误处理方式"><a href="#defer-recover的错误处理方式" class="headerlink" title="defer+recover的错误处理方式"></a>defer+recover的错误处理方式</h3><ul>
<li>Go语言不支持传统的try…catch…finally这种处理。</li>
<li>Go中引入的处理方式为：defer，panic，recover</li>
<li>这几个异常的使用场景可以这么简单描述：<ol>
<li>Go中可以抛出一个 <code>panic</code> 的异常，</li>
<li>然后在 defer中通过 <code>recover</code>捕获这个异常，</li>
<li>然后正常处理</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testError</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := <span class="built_in">recover</span>() <span class="comment">// recover捕获错误</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;err=&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	num1 := <span class="number">10</span></span><br><span class="line">	num2 := <span class="number">0</span></span><br><span class="line">	res := num1 / num2</span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;---start---&quot;</span>)</span><br><span class="line">	testError()</span><br><span class="line">	fmt.Println(<span class="string">&quot;---end---&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---start---</span></span><br><span class="line"><span class="comment">//err= runtime error: integer divide by zero</span></span><br><span class="line"><span class="comment">//---end---</span></span><br></pre></td></tr></table></figure>



<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul>
<li>使用 <code>errors.New</code>和<code>panic</code>内置函数</li>
<li>errors.New(“错误说明”)，会返回一个error类型的值，表示一个错误</li>
<li>panic内置函数，接收一个 interface类型的值（也就是任何值了）作为参数，可以接收error类型的变量，<strong>输出错误信息，并退出程序</strong>。</li>
</ul>
<blockquote>
<p>panic 类似于python中的<code>raise</code></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数读取配置文件config.ini的信息</span></span><br><span class="line"><span class="comment">// 如果文件名传入错误,返回一个自定义的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;config.ini&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testErr</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := readConf(<span class="string">&quot;config.ini&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err) <span class="comment">// 抛出异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;-- end --&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	testErr()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用指针强行改变数组"><a href="#使用指针强行改变数组" class="headerlink" title="使用指针强行改变数组"></a>使用指针强行改变数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArr</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span> [3]<span class="title">int</span></span> &#123;</span><br><span class="line">	(*arr)[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">	<span class="keyword">return</span> *arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	res := changeArr(&amp;arr)</span><br><span class="line">	fmt.Println(res) <span class="comment">// [1000 2 3]</span></span><br><span class="line">	fmt.Println(arr) <span class="comment">// [1000 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul>
<li>切片是数组的一个引用，因此切片是引用类型，<strong>在进行传递时，遵守引用传递的机制</strong></li>
<li>改变切片的某个索引的数据值 , 本质就是<code>通过指针强制修改底层数组的值</code></li>
</ul>
<h3 id="string和slice的关系"><a href="#string和slice的关系" class="headerlink" title="string和slice的关系"></a>string和slice的关系</h3><ul>
<li>string底层是一个数组</li>
</ul>
<h2 id="二维数组的内存形式"><a href="#二维数组的内存形式" class="headerlink" title="二维数组的内存形式"></a>二维数组的内存形式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> table [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">	table[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	table[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">	table[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">	<span class="comment">// 0 1 0</span></span><br><span class="line">	<span class="comment">// 2 0 3</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;table[<span class="number">0</span>])    <span class="comment">// 0xc0000b4060</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;table[<span class="number">1</span>])    <span class="comment">// 0xc0000b4078</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;table[<span class="number">0</span>][<span class="number">0</span>]) <span class="comment">// 0xc0000b4060</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;table[<span class="number">1</span>][<span class="number">0</span>]) <span class="comment">// 0xc0000b4078</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>二维数组的底层是<code>一维数组</code>的形式存储的</strong></li>
<li><code>table[0]</code> , <code>table[1]</code>内部存储了底层一维数组的指针</li>
</ul>
<p><img src="/images/1591182883025.png" alt="1591182883025"></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><strong>map声明是不会分配内存的</strong> , 初始化需要使用<code>make</code> , 分配内存后才能赋值和使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 在使用map前,需要先make</span></span><br><span class="line">	<span class="comment">//make的作用就是给map分配数据空间</span></span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">	m[<span class="string">&quot;no1&quot;</span>] = <span class="string">&quot;123&quot;</span></span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="引用类型的初始化"><a href="#引用类型的初始化" class="headerlink" title="引用类型的初始化"></a>引用类型的初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr []<span class="keyword">int</span></span><br><span class="line">	arr[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// error</span></span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr []<span class="keyword">int</span></span><br><span class="line">	arr = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">	arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么所有的引用类型在使用<code>var</code>定义后 , 都要使用<code>make</code>来分配空间 : </p>
<ul>
<li>因为引用类型的零值是<code>nil</code></li>
<li>需要使用<code>make</code> , 给他在内存中分配一块区域</li>
</ul>
</blockquote>
<p><img src="/images/1591192286856.png" alt="1591192286856"></p>
<h2 id="结构体的内存形式"><a href="#结构体的内存形式" class="headerlink" title="结构体的内存形式"></a>结构体的内存形式</h2><blockquote>
<p><strong>结构体的所有<code>字段</code>在内存中是连续的</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="keyword">int</span></span><br><span class="line">	y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123;</span><br><span class="line">	leftUp Point</span><br><span class="line">	rightDown Point</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r1 := Rect&#123;</span><br><span class="line">		Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">		Point&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p,%p\n&quot;</span>,</span><br><span class="line">		&amp;r1.leftUp,&amp;r1.rightDown)</span><br><span class="line">	<span class="comment">// 0xc00009e120,0xc00009e130</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(</span><br><span class="line">  	<span class="string">&quot;%p,%p,%p,%p&quot;</span>,</span><br><span class="line">		&amp;r1.leftUp.x,&amp;r1.leftUp.y,</span><br><span class="line">		&amp;r1.rightDown.x,&amp;r1.rightDown.y,</span><br><span class="line">  )</span><br><span class="line">	<span class="comment">// 0xc00009e120,0xc00009e128,0xc00009e130,0xc00009e138</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/1591194574244.png" alt="1591194574244"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="keyword">int</span></span><br><span class="line">	y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123;</span><br><span class="line">	leftUp    *Point</span><br><span class="line">	rightDown *Point</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r2 := Rect&#123;</span><br><span class="line">		&amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">		&amp;Point&#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p,%p\n&quot;</span>,&amp;r2.leftUp, &amp;r2.rightDown)</span><br><span class="line">	<span class="comment">// 0xc0000881e0,0xc0000881e8</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p,%p\n&quot;</span>,r2.leftUp, r2.rightDown)</span><br><span class="line">	<span class="comment">// 0xc0000140b0,0xc0000140c0</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p,%p,%p,%p\n&quot;</span>,</span><br><span class="line">		&amp;r2.leftUp.x, &amp;r2.leftUp.y,</span><br><span class="line">		&amp;r2.rightDown.x, &amp;r2.rightDown.y)</span><br><span class="line">	<span class="comment">// 0xc0000140b0,0xc0000140b8,0xc0000140c0,0xc0000140c8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/1591195284667.png" alt="1591195284667"></p>
<h2 id="接收者是值类型还是指针类型"><a href="#接收者是值类型还是指针类型" class="headerlink" title="接收者是值类型还是指针类型"></a>接收者是值类型还是指针类型</h2><ul>
<li><p>不管接收者是<code>值类型</code>还是<code>指针类型</code> , 都可以调用<code>值类型方法</code>和<code>指针类型方法</code></p>
<blockquote>
<p>简单来说 , </p>
<ul>
<li>任意类型都可以调用任意方法 . </li>
<li>但是最终是传值还是传地址的<strong>最终决定权在于方法的接受者类型</strong></li>
</ul>
</blockquote>
</li>
<li><p>但是对于 , <code>隐式继承接口</code> , </p>
<ul>
<li>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</li>
<li>如果实现了接收者是指针类型的方法 ，那么必须传入指针类型的结构体实例</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">	debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;I am coding %s language\n&quot;</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;I am debuging %s language\n&quot;</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c1 coder = &amp;Gopher&#123;<span class="string">&quot;Go&quot;</span>&#125;</span><br><span class="line">	c1.code()</span><br><span class="line">	c1.debug()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于 var c2 Gopher = Gopher&#123;&quot;Go&quot;&#125; , 注意区别于 var c3 coder = Gopher&#123;&quot;Go&quot;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> c2 = Gopher&#123;<span class="string">&quot;Go&quot;</span>&#125;</span><br><span class="line">	fmt.Println(c2)</span><br><span class="line">	c2.code()</span><br><span class="line">	c2.debug()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Type does not implement &#x27;coder&#x27; as &#x27;debug&#x27; method has a pointer receiver</span></span><br><span class="line">	<span class="keyword">var</span> c3 coder = Gopher&#123;<span class="string">&quot;Go&quot;</span>&#125; <span class="comment">// error</span></span><br><span class="line">	fmt.Println(c3)</span><br><span class="line">	c3.code()</span><br><span class="line">	c3.debug() <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因 : </p>
<ul>
<li>实现coder接口的是<code>*Gopher</code> , </li>
<li>如果传入一个<code>Gopher</code>(值类型)则报编译错误</li>
</ul>
</blockquote>
<h3 id="结构体的String-方法"><a href="#结构体的String-方法" class="headerlink" title="结构体的String()方法"></a>结构体的String()方法</h3><p>如果一个变量实现了 String()这个方法，那么<code> fmt.PrintIn</code>默认会调用这个变量的String()进行输出</p>
<blockquote>
<ul>
<li>类似于python中的<code>__str__</code> 或 <code>__repr__</code>方法</li>
<li>这也体现了Golang具有<code>鸭子类型</code></li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&lt;&lt; &quot;</span> + s.Name + <span class="string">&quot; &gt;&gt;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := Student&#123;<span class="string">&quot;heyingliang&quot;</span>, <span class="number">21</span>&#125;</span><br><span class="line">	fmt.Println(s) <span class="comment">// &lt;&lt; heyingliang &gt;&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>go的工厂模式有点类似于其他语言中的<code>构造函数</code> , 比如python中的<code>__init__</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Student&#123;name, age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := NewStudent(<span class="string">&quot;heyingliang&quot;</span>, <span class="number">21</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>甚至于 , 我们可以使用类似于<code>java bean</code>的方式 , 提供一个获取设置方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">GetStudentName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">SetStudentName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	s.Name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>Go面向对象编程非常简洁，去掉了传统OOP语言的<code>继承</code>、<code>方法重载</code>、<code>构造函数</code>和<code>析构函数</code>、<code>隐藏的this指针</code>等</li>
<li>Go仍然有面向对象编程的继承，封装和多态的特性，只是实现的方式和其它OOP语言不一样 . 比如<code>继承</code>：Go没有extends关键字，继承是通过<code>匿名字段</code>来实现。</li>
<li>Go通过接口interface关联，耦合性低，也非常灵活。</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><code>在结构体中嵌入 另一个匿名结构体</code> , 以此来实现继承</li>
<li>也就是说：在 Golang中，如果一个 struct嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性。</li>
</ul>
<blockquote>
<ul>
<li><p><strong>嵌入类型</strong>：是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的<strong>内部类型</strong>。</p>
<p><strong>实现方法重写</strong>：外部类型也可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或者方法。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>注意声明字段和嵌入类型在语法上的不同 ，嵌入类型直接是写个类型名就行</li>
<li><strong>内部类型的标识符提升到了外部类型</strong>，可以直接通过外部类型的值来访问内部类型的标识符。 也可以通过内部类型的名间接访问内部类型方法和标识符。</li>
<li>若内部类型实现了接口，外部类型默认也实现了该接口。注意方法集的规则。</li>
<li>如果内部类型和外部类型同时实现一个接口，就近原则，外部类型不会直接调用内部类型实现的同名方法，而是自己的。当然可以通过内部类型间接显示的去调用内部类型的方法。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHuman</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Human</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Human&#123;name, age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">GetHumanName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SetHumanName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	h.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello , my name is&quot;</span>, h.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖Human的sayHello方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello222 , my name is&quot;</span>, s.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意: 不可使用s := &amp;Student&#123;&quot;heyingliang&quot;,21&#125;</span></span><br><span class="line">	s := &amp;Student&#123;&#125;</span><br><span class="line">	s.SetHumanName(<span class="string">&quot;heyingliang&quot;</span>)</span><br><span class="line">	s.Age = <span class="number">21</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	s.sayHello()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值</span></span><br><span class="line">  s2 := &amp;Student&#123;Human&#123;Name: <span class="string">&quot;heyingliang&quot;</span>, Age: <span class="number">21</span>&#125;&#125;</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="就近原则"><a href="#就近原则" class="headerlink" title="就近原则"></a>就近原则</h3><ul>
<li>当结构体和匿名结构体有相同的字段或者方法时编译器采用<code>就近访问</code>原则访问</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此方法被子类覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(h.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此方法没有被子类覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">sayHello2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(h.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖Human的sayHello方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(s.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := &amp;Student&#123;&#125;</span><br><span class="line">	s.Name = <span class="string">&quot;StudentName&quot;</span></span><br><span class="line">	s.Human.Name = <span class="string">&quot;HumanName&quot;</span></span><br><span class="line">	fmt.Println(s.Name,s.Human.Name) <span class="comment">// StudentName HumanName</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对于子类覆盖父类的方法,采用子类的属性</span></span><br><span class="line">	s.sayHello() <span class="comment">// StudentName</span></span><br><span class="line">	s.Human.sayHello() <span class="comment">// HumanName</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 对于没有覆盖父类的方法,采用父类的属性</span></span><br><span class="line">	s.sayHello2() <span class="comment">// HumanName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="将基本类型作为匿名结构体嵌入"><a href="#将基本类型作为匿名结构体嵌入" class="headerlink" title="将基本类型作为匿名结构体嵌入"></a>将基本类型作为匿名结构体嵌入</h3><p>照常使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Human</span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s2 := &amp;Student&#123;&amp;Human&#123;Name: <span class="string">&quot;heyingliang&quot;</span>, Age: <span class="number">21</span>&#125;,<span class="number">9</span>&#125;</span><br><span class="line">	fmt.Println(s2.Name,s2.Age)</span><br><span class="line">	fmt.Println(s2.<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>Golang中的接口，不需要显式的实现。</li>
<li><strong>只要一个变量含有接口类型中的所有方法，那么个变量就实现这个接口。</strong></li>
<li>因此，Golang中没有<code>implement</code>这样的关键字 </li>
<li>所以你很难知道某个结构体实现了哪些接口</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Usb接口声明了两个没有实现的方法</span></span><br><span class="line">	start()</span><br><span class="line">	stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// Phone实现了Usb接口的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机接入usb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机拔出usb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Camera)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机接入usb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Camera)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机拔出usb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// working方法接收一个Usb接口类型变量</span></span><br><span class="line"><span class="comment">// 所谓的思想Usb接口,就是指 实现了Usb接口的所有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">working</span><span class="params">(usb Usb)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;== start ==&quot;</span>)</span><br><span class="line">	usb.start() <span class="comment">// 通过Usb接口变量来调用Start和Stop方法</span></span><br><span class="line">	usb.stop()</span><br><span class="line">	fmt.Println(<span class="string">&quot;== stop ==&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	computer := &amp;Computer&#123;&#125;</span><br><span class="line">	phone := &amp;Phone&#123;&#125;</span><br><span class="line">	camera := &amp;Camera&#123;&#125;</span><br><span class="line">	computer.working(phone)</span><br><span class="line">	computer.working(camera)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Data)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">	Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">	Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只要是实现了<code>Data</code>这个接口(也就是实现了Len,Less,Swap三个方法)的<code>结构体</code>或<code>自定义类型</code> , 就可以调用Sort方法</p>
</blockquote>
<p>这其实就是架构师和程序员的关系</p>
<ul>
<li>架构师定义了Data这个接口 , 并且编写了Sort方法</li>
<li>程序员自己去编写一个结构体 , 让这个结构体去实现Len,Less,Swap三个方法</li>
</ul>
<p>如下 : </p>
<ol>
<li>自定义HeroSlice</li>
<li>实现Data接口 , </li>
<li>使用sort.Sort方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hero <span class="keyword">struct</span>&#123; Age <span class="keyword">int</span> &#125;</span><br><span class="line"><span class="keyword">type</span> HeroSlice []Hero</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HeroSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(*h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HeroSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> (*h)[i].Age &lt; (*h)[j].Age &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HeroSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; (*h)[i], (*h)[j] = (*h)[j], (*h)[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hs := HeroSlice&#123;</span><br><span class="line">		Hero&#123;<span class="number">99</span>&#125;,</span><br><span class="line">		Hero&#123;<span class="number">66</span>&#125;,</span><br><span class="line">		Hero&#123;<span class="number">33</span>&#125;,</span><br><span class="line">		Hero&#123;<span class="number">55</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(hs) <span class="comment">// [&#123;99&#125; &#123;66&#125; &#123;33&#125; &#123;55&#125;]</span></span><br><span class="line">	sort.Sort(&amp;hs)</span><br><span class="line">	fmt.Println(hs) <span class="comment">// [&#123;33&#125; &#123;55&#125; &#123;66&#125; &#123;99&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h3><p>一个接口可以继承另一接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> baseInterface1 <span class="keyword">interface</span>&#123; func1() &#125;</span><br><span class="line"><span class="keyword">type</span> baseInterface2 <span class="keyword">interface</span>&#123; func2() &#125;</span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	baseInterface1</span><br><span class="line">	baseInterface2</span><br><span class="line">	func3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">func1</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;this is func1&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">func2</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;this is func2&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">func3</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;this is func3&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testing1</span><span class="params">(i baseInterface1)</span></span> &#123; i.func1() &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testing2</span><span class="params">(i baseInterface2)</span></span> &#123; i.func2() &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testing3</span><span class="params">(i Interface)</span></span> &#123;</span><br><span class="line">	i.func1()</span><br><span class="line">	i.func2()</span><br><span class="line">	i.func3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	testing1(&amp;Student&#123;&#125;)</span><br><span class="line">	testing2(&amp;Student&#123;&#125;)</span><br><span class="line">	testing3(&amp;Student&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s baseInterface1 = &amp;Student&#123;&#125;</span><br><span class="line">	s.func1()</span><br><span class="line">	<span class="keyword">var</span> s2 baseInterface2 = &amp;Student&#123;&#125;</span><br><span class="line">	s2.func2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在嵌套过程中 , <strong>不允许两个子接口拥有相同的方法名</strong></li>
<li>错误原因 : 因为这样相当于<strong>Interface3这个接口同时定义了两个相同名称的方法</strong> , 也就是<code>重复定义</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> baseInterface1 <span class="keyword">interface</span>&#123; func1() &#125;</span><br><span class="line"><span class="keyword">type</span> baseInterface2 <span class="keyword">interface</span>&#123; func1() &#125;</span><br><span class="line"><span class="keyword">type</span> Interface3 <span class="keyword">interface</span> &#123;</span><br><span class="line">	baseInterface1</span><br><span class="line">	baseInterface2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面Interface3相当于 , 重复定义</span></span><br><span class="line"><span class="keyword">type</span> Interface3 <span class="keyword">interface</span> &#123;</span><br><span class="line">	func1()</span><br><span class="line">	func1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h3><ul>
<li>interface类型默认是一个指针(引用类型)</li>
<li>interface类型零值是nil , 如果没有对interface初始化就使用 , 那么会输出nil</li>
<li>空接口<code>interface&#123;&#125;</code> 没有任何方法 , 所以所有类型都实现了空接口 , 即<strong>我们可以把任何一个变量赋给空接口</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">interface</span> &#123;&#125; <span class="comment">// 空接口</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t T = Human&#123;&#125;</span><br><span class="line">	fmt.Println(t)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 简写如下</span></span><br><span class="line">	<span class="keyword">var</span> t2 <span class="keyword">interface</span>&#123;&#125; = Human&#123;&#125;</span><br><span class="line">	fmt.Println(t2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接口和继承的区别"><a href="#接口和继承的区别" class="headerlink" title="接口和继承的区别"></a>接口和继承的区别</h3><ul>
<li>接口和继承解决的解决的问题不同 :<ul>
<li>继承的价值主要在于：解决代码的<strong>复用性</strong>和可维护性</li>
<li>接口的价值主要在于：<strong>设计</strong>，设计好各种规范（方法），让其它自定义类型去实现这些方法。</li>
</ul>
</li>
<li>接口比继承更加灵活 : <ul>
<li>继承是满足<code>is-a</code>的关系，而接口只需满足<code>like-a</code>的关系。</li>
</ul>
</li>
<li>接口在一定程度上实现代码解耦</li>
</ul>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><ul>
<li>由于接口是一般类型，不知道具体类型，如果要<strong>将一般类型转成具体类型</strong>，就需要使用类型断言</li>
<li><code>x.(T)</code> 检查x的动态类型是否是T，其中x必须是接口值。</li>
<li>类型断言的本质，跟类型转换类似，都是类型之间进行转换，不同之处在于，<strong>类型断言是在接口之间进行</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空接口,可以接受任意类型</span></span><br><span class="line">	<span class="comment">// x是空接口,但是指向的是float32类型</span></span><br><span class="line">	x = b </span><br><span class="line"></span><br><span class="line">	y := x.(<span class="keyword">float32</span>) <span class="comment">// 使用类型断言,将x变成float32</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;y的类型是 %T,值是=%v\n&quot;</span>, y, y) <span class="comment">// y的类型是 float32,值是=1.1</span></span><br><span class="line"></span><br><span class="line">	y2 := x.(<span class="keyword">float64</span>) <span class="comment">// panic: interface conversion: interface &#123;&#125; is float32, not float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在类型断言时 , 带上检测机制</p>
<blockquote>
<p>就是说 , 类型转换失败的时候不要引发panic</p>
</blockquote>
<p>十分简单 , 只要将<code>y := x.(float32)</code> 改成 <code>y,ok := x.(float32)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空接口,可以接受任意类型</span></span><br><span class="line">	<span class="comment">// x是空接口,但是指向的是float32类型</span></span><br><span class="line">	x = b</span><br><span class="line"></span><br><span class="line">	y := x.(<span class="keyword">float32</span>)                     <span class="comment">// 使用类型断言,将x变成float32</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;y的类型是 %T,值是=%v\n&quot;</span>, y, y) <span class="comment">// y的类型是 float32,值是=1.1</span></span><br><span class="line"></span><br><span class="line">	y2, ok := x.(<span class="keyword">float64</span>)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;y2的类型是 %T,值是=%v\n&quot;</span>, y2, y2) <span class="comment">// 没有执行</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;转换失败,x的类型是 %T,值是=%v\n&quot;</span>, x, x) <span class="comment">// 转换失败,x的类型是 float32,值是=1.1</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;y2的类型是 %T,值是=%v\n&quot;</span>, y2, y2) <span class="comment">// y2的类型是 float64,值是=0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>判断类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckType</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(res []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">		<span class="comment">// .(type)是固定写法</span></span><br><span class="line">		<span class="keyword">switch</span> item.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="string">&quot;bool&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="string">&quot;string&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int64</span>:</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="string">&quot;int&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">float64</span> , <span class="keyword">float32</span>:</span><br><span class="line">			res = <span class="built_in">append</span>(res, <span class="string">&quot;float64&quot;</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			res = <span class="built_in">append</span>(res, fmt.Sprintf(<span class="string">&quot;%T&quot;</span>, item))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := CheckType(<span class="number">1</span>, <span class="string">&quot;w&quot;</span>, <span class="number">1.2</span>, <span class="literal">true</span>, Student&#123;&#125;, &amp;Student&#123;&#125;)</span><br><span class="line">	fmt.Println(res) <span class="comment">// [int string float64 bool main.Student *main.Student]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>多态参数<ul>
<li>在前面的Usb接口案例，<code>Usb usb</code>即可以接收Phone变量，又可以接收Camera变量，就体现了Usb接口多态</li>
</ul>
</li>
<li>多态数组<ul>
<li>定义一个usb接口数组，可以存放 Phone和 Camera的结构体变量 , 然后遍历这个数组 , 根据元素不同类型使用不同的方法</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span>&#123; working() &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">working</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;phone is working&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">call</span><span class="params">()</span></span>    &#123; fmt.Println(<span class="string">&quot;phone is calling&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Camera)</span> <span class="title">working</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;camera is working&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> MachineSlice = <span class="built_in">make</span>([]Usb, <span class="number">4</span>)</span><br><span class="line">	MachineSlice[<span class="number">0</span>] = &amp;Phone&#123;&#125;</span><br><span class="line">	MachineSlice[<span class="number">1</span>] = &amp;Camera&#123;&#125;</span><br><span class="line">	MachineSlice[<span class="number">2</span>] = &amp;Camera&#123;&#125;</span><br><span class="line">	MachineSlice[<span class="number">3</span>] = &amp;Phone&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, instance := <span class="keyword">range</span> MachineSlice &#123;</span><br><span class="line">		<span class="keyword">if</span> phone, ok := instance.(*Phone); ok &#123;</span><br><span class="line">			phone.call()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			instance.working()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//phone is calling</span></span><br><span class="line"><span class="comment">//camera is working</span></span><br><span class="line"><span class="comment">//camera is working</span></span><br><span class="line"><span class="comment">//phone is calling</span></span><br></pre></td></tr></table></figure>



<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li>文件在程序中是以<code>流</code>的形式来操作的</li>
</ul>
<blockquote>
<ul>
<li>流：数据在数据源（文件）和程序（内存）之间经历的路径</li>
<li>输入流：数据从数据源（文件）到程序（内存）的路径</li>
<li>输出流：数据从程序（内存）到数据源（文件）的路径</li>
</ul>
</blockquote>
<ul>
<li><code>os.File</code>封装所有文件相关操作，File是一个结构体。</li>
</ul>
<h3 id="带缓冲读取ReadString"><a href="#带缓冲读取ReadString" class="headerlink" title="带缓冲读取ReadString()"></a>带缓冲读取ReadString()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;C:/gopath/src/hello/test.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 带缓冲的读取流</span></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到一个换行符就结束</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件读取结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="按行读取ReadLine"><a href="#按行读取ReadLine" class="headerlink" title="按行读取ReadLine()"></a>按行读取ReadLine()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;C:/gopath/src/hello/test2.txt&quot;</span></span><br><span class="line">	<span class="comment">// 只写模式和创建模式(文件不存在则创建)</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_RDONLY, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, _, err := reader.ReadLine()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(line))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一次性读取所有内容ioutil-ReadFile"><a href="#一次性读取所有内容ioutil-ReadFile" class="headerlink" title="一次性读取所有内容ioutil.ReadFile()"></a>一次性读取所有内容ioutil.ReadFile()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file := <span class="string">&quot;C:/gopath/src/hello/test.txt&quot;</span></span><br><span class="line">	content, err := ioutil.ReadFile(file) <span class="comment">// 一次性加载文件所有内容</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="keyword">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="写入WriteString"><a href="#写入WriteString" class="headerlink" title="写入WriteString()"></a>写入WriteString()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;C:/gopath/src/hello/test2.txt&quot;</span></span><br><span class="line">	<span class="comment">// 追加模式(文件末尾追加内容)和创建模式(文件不存在则创建)</span></span><br><span class="line">	file, err := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	str := <span class="string">&quot;北京\n&quot;</span></span><br><span class="line">	writer := bufio.NewWriter(file) <span class="comment">// 带缓冲的写入流</span></span><br><span class="line">	byteNum, err := writer.WriteString(str)</span><br><span class="line"></span><br><span class="line">	fmt.Println(byteNum, err) <span class="comment">// 7 &lt;nil&gt;</span></span><br><span class="line">	err = writer.Flush()</span><br><span class="line">	fmt.Println(err) <span class="comment">// &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="文件操作模式"><a href="#文件操作模式" class="headerlink" title="文件操作模式"></a>文件操作模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">	O_WRONLY <span class="keyword">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">	O_RDWR <span class="keyword">int</span> = syscall.O_RDWR <span class="comment">// 读写模式打开文件</span></span><br><span class="line">	O_APPEND <span class="keyword">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">	O_CREATE <span class="keyword">int</span> = syscall.O_CREAT <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">	O_EXCL <span class="keyword">int</span> = syscall.O_EXCL <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">	O_SYNC <span class="keyword">int</span> = syscall.O_SYNC <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">	O_TRUNC <span class="keyword">int</span> = syscall.O_TRUNC <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	originFilePath := <span class="string">&quot;C:/gopath/src/hello/test2.txt&quot;</span></span><br><span class="line">	toFilePath := <span class="string">&quot;C:/gopath/src/hello/test3.txt&quot;</span></span><br><span class="line">	originFile, err1 := os.OpenFile(originFilePath, os.O_RDONLY, <span class="number">0666</span>)</span><br><span class="line">	toFile, err2 := os.OpenFile(toFilePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;fmt.Println(<span class="string">&quot;open origin file error&quot;</span>)&#125;</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;fmt.Println(<span class="string">&quot;open to file error&quot;</span>)&#125;</span><br><span class="line">	<span class="keyword">defer</span> originFile.Close()</span><br><span class="line">	<span class="keyword">defer</span> toFile.Close()</span><br><span class="line"></span><br><span class="line">	originReader := bufio.NewReader(originFile)</span><br><span class="line">	toWriter := bufio.NewWriter(toFile)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, err := originReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		toWriter.WriteString(line)</span><br><span class="line">	&#125;</span><br><span class="line">	toWriter.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>或者 直接使用<code>io.Copy</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">originReader := bufio.NewReader(originFile)</span><br><span class="line">toWriter := bufio.NewWriter(toFile)</span><br><span class="line"></span><br><span class="line">io.Copy(toWriter, originReader)</span><br></pre></td></tr></table></figure>



<h3 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExists</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	_, err := os.Stat(path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><h3 id="os-Args"><a href="#os-Args" class="headerlink" title="os.Args"></a>os.Args</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// os.Args是一个 []string</span></span><br><span class="line">	<span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">		fmt.Println(arg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们执行`aaa.exe 123 qwe 何应良`时 , 就会得到下面输出</span></span><br><span class="line"><span class="comment">// aaa.exe</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// qwe</span></span><br><span class="line"><span class="comment">// 何应良</span></span><br></pre></td></tr></table></figure>



<h3 id="flag包"><a href="#flag包" class="headerlink" title="flag包"></a>flag包</h3><p>命令行参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySQLLink <span class="keyword">struct</span> &#123;</span><br><span class="line">	user <span class="keyword">string</span></span><br><span class="line">	pwd  <span class="keyword">string</span></span><br><span class="line">	host <span class="keyword">string</span></span><br><span class="line">	port <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> link MySQLLink</span><br><span class="line">	flag.StringVar(&amp;link.user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;用户名,默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;link.pwd, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;密码,默认为空&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;link.host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;IP,默认为空&quot;</span>)</span><br><span class="line">	flag.IntVar(&amp;link.port, <span class="string">&quot;port&quot;</span>, <span class="number">6666</span>, <span class="string">&quot;端口,默认为6666&quot;</span>)</span><br><span class="line"></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Println(link.user, link.pwd, link.host, link.port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们执行aaa.exe -u heyingliang -p liangbo4869 -h 127.0.0.1 -port 9999 ,得到</span></span><br><span class="line"><span class="comment">// heyingliang liangbo4869 127.0.0.1 9999</span></span><br></pre></td></tr></table></figure>



<h2 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 结构体序列化</span></span><br><span class="line">	me := Student&#123;<span class="string">&quot;heyingliang&quot;</span>, <span class="number">21</span>&#125;</span><br><span class="line">	data, err := json.Marshal(&amp;me)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(data)) <span class="comment">// &#123;&quot;Name&quot;:&quot;heyingliang&quot;,&quot;Age&quot;:21&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// map序列化</span></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	m[<span class="string">&quot;123&quot;</span>] = <span class="number">123</span></span><br><span class="line">	m[<span class="string">&quot;456&quot;</span>] = <span class="literal">true</span></span><br><span class="line">	m[<span class="string">&quot;789&quot;</span>] = Student&#123;&#125;</span><br><span class="line">	m[<span class="string">&quot;111&quot;</span>] = &amp;Student&#123;&#125;</span><br><span class="line">	data2, err := json.Marshal(&amp;m)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(data2)) <span class="comment">// &#123;&quot;111&quot;:&#123;&quot;Name&quot;:&quot;&quot;,&quot;Age&quot;:0&#125;,&quot;123&quot;:123,&quot;456&quot;:true,&quot;789&quot;:&#123;&quot;Name&quot;:&quot;&quot;,&quot;Age&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// slice序列化</span></span><br><span class="line">	slc := []<span class="keyword">string</span>&#123;<span class="string">&quot;qwe&quot;</span>, <span class="string">&quot;asd&quot;</span>, <span class="string">&quot;zxc&quot;</span>&#125;</span><br><span class="line">	data3, err := json.Marshal(&amp;slc)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(data3)) <span class="comment">// [&quot;qwe&quot;,&quot;asd&quot;,&quot;zxc&quot;]</span></span><br><span class="line">	slc2 := []Student&#123;Student&#123;<span class="string">&quot;123&quot;</span>, <span class="number">1</span>&#125;, Student&#123;<span class="string">&quot;456&quot;</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">	data4, err := json.Marshal(&amp;slc2)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(data4)) <span class="comment">// [&#123;&quot;Name&quot;:&quot;123&quot;,&quot;Age&quot;:1&#125;,&#123;&quot;Name&quot;:&quot;456&quot;,&quot;Age&quot;:1&#125;]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复杂对象序列化 [&#123;&quot;123&quot;:&#123;&quot;Name&quot;:&quot;heyingliang&quot;,&quot;Age&quot;:45&#125;&#125;]</span></span><br><span class="line">	slc3 := []<span class="keyword">map</span>[<span class="keyword">string</span>]Student&#123;</span><br><span class="line">		&#123;<span class="string">&quot;0&quot;</span>: &#123;<span class="string">&quot;heyingliang&quot;</span>, <span class="number">45</span>&#125;&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;1&quot;</span>: &#123;<span class="string">&quot;heyingliang&quot;</span>, <span class="number">45</span>&#125;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	data5, _ := json.Marshal(slc3)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(data5)) <span class="comment">// [&#123;&quot;0&quot;:&#123;&quot;Name&quot;:&quot;heyingliang&quot;,&quot;Age&quot;:45&#125;&#125;,&#123;&quot;1&quot;:&#123;&quot;Name&quot;:&quot;heyingliang&quot;,&quot;Age&quot;:45&#125;&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="struct-tag"><a href="#struct-tag" class="headerlink" title="struct tag"></a>struct tag</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age  <span class="keyword">int</span>    <span class="string">`json:&quot;nianling&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slc := []Student&#123;</span><br><span class="line">		&#123;<span class="string">&quot;heyingliang&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;chenzhuji&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data, _ := json.Marshal(&amp;slc)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">	<span class="comment">// [&#123;&quot;name&quot;:&quot;heyingliang&quot;,&quot;nianling&quot;:1&#125;,&#123;&quot;name&quot;:&quot;chenzhuji&quot;,&quot;nianling&quot;:2&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Json反序列化"><a href="#Json反序列化" class="headerlink" title="Json反序列化"></a>Json反序列化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 反序列化结构体</span></span><br><span class="line">	str := <span class="string">&quot;&#123;\&quot;Name\&quot;:\&quot;heyingliang\&quot;,\&quot;Age\&quot;:1&#125;&quot;</span></span><br><span class="line">	<span class="keyword">var</span> s Student</span><br><span class="line">	err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(s) <span class="comment">// &#123;heyingliang 1&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反序列化Slice</span></span><br><span class="line">	str2 := <span class="string">&quot;[&#123;\&quot;Name\&quot;:\&quot;heyingliang\&quot;,\&quot;Age\&quot;:1&#125;,&#123;\&quot;Name\&quot;:\&quot;chenzhuji\&quot;,\&quot;Age\&quot;:2&#125;]&quot;</span></span><br><span class="line">	<span class="keyword">var</span> StuSlc []Student</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str2), &amp;StuSlc)</span><br><span class="line">	fmt.Println(StuSlc) <span class="comment">// [&#123;heyingliang 1&#125; &#123;chenzhuji 2&#125;]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 放序列化map</span></span><br><span class="line">	str3 := <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;何应良\&quot;,\&quot;school\&quot;:\&quot;gdgydx\&quot;&#125;&quot;</span></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str3), &amp;m)</span><br><span class="line">	fmt.Println(m) <span class="comment">// map[name:何应良 school:gdgydx]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反序列化也可以使用<code>struct tag</code> , 甚至可以<strong>混搭</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age  <span class="keyword">int</span> <span class="string">`json:&quot;nianling&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 混搭 : Name和nianling</span></span><br><span class="line">	str2 := <span class="string">&quot;[&#123;\&quot;Name\&quot;:\&quot;heyingliang\&quot;,\&quot;nianling\&quot;:1&#125;,&#123;\&quot;Name\&quot;:\&quot;chenzhuji\&quot;,\&quot;nianling\&quot;:2&#125;]&quot;</span></span><br><span class="line">	<span class="keyword">var</span> StuSlc []Student</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str2), &amp;StuSlc)</span><br><span class="line">	fmt.Println(StuSlc) <span class="comment">// [&#123;heyingliang 1&#125; &#123;chenzhuji 2&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li>Go自带一个轻量级的测试框架<code>testing</code> 和 自带的<code>go test </code>命令 来实现单元测试和性能测试</li>
<li>测试文件必须以<code>_test.go</code>结尾</li>
<li>测试用例必须包含<code>TestXxx</code>函数</li>
<li>命令行键入<code>go test -v</code>进行测试 (<code>-v</code> 无论测试是否通过 , 都输出日志)</li>
</ul>
<blockquote>
<ul>
<li>使用<code>t.Fatalf</code> 来格式化输出错误信息 , 并退出程序</li>
<li>使用<code>t.Logf</code> 方法输出日志</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>测试单个文件时 , 一定要带上被测试的源文件 <ul>
<li>比如 : <code>go test -v cal_test.go cal.go</code></li>
</ul>
</li>
<li>测试单个方法 , <code>go test -v -test.run  </code> + 方法名<ul>
<li>比如 : <code>go test -v -test.run TestAddUpper</code></li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibo</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fibo(n<span class="number">-1</span>) + fibo(n<span class="number">-2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test开头,且下一个字母必须大写(这里是F)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFibo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	res := fibo(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">if</span> res != <span class="number">10</span> &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;函数错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果正确,输出日志</span></span><br><span class="line">	t.Logf(<span class="string">&quot;函数正确&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=== RUN   TestFibo</span></span><br><span class="line"><span class="comment">//TestFibo: fibo_test.go:23: 函数正确</span></span><br><span class="line"><span class="comment">//--- PASS: TestFibo (0.00s)</span></span><br><span class="line"><span class="comment">//PASS</span></span><br><span class="line"><span class="comment">//ok      hello/cf/test   0.177s</span></span><br></pre></td></tr></table></figure>



<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go协程的特点</p>
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
</ul>
<blockquote>
<ul>
<li>主线程是一个<strong>物理线程</strong>，直接作用在cpu上的。是重量级的，非常耗费cpu资源。</li>
<li>协程从主线程开启的，是轻量级的线程，是逻辑态。对资源消耗相对小。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;this is goroutine&quot;</span>, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> testGoroutine()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;this is main string&quot;</span>, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="goroutine调用说明"><a href="#goroutine调用说明" class="headerlink" title="goroutine调用说明"></a>goroutine调用说明</h3><ol>
<li><p>一个线程就是一个<code>栈</code>加<code>堆资源</code>。操作系统一会让cpu跑线程A，一会让cpu跑线程B，<strong>靠A和B的栈来保存A和B的执行状态。</strong>每个线程都有他自己的栈。</p>
</li>
<li><p>但是线程又老贵了，花不起那个钱，所以go发明了 goroutine。大致就是说给每个goroutine弄一个分配在<code>资源堆</code>里面的<code>栈</code>来模拟线程栈。</p>
</li>
<li><p>比方说有3个goroutine,A,B,C，就在<code>资源堆</code>上弄<strong>三</strong>个栈出来。然后Go让一个单线程的scheduler开始跑他们仨。相当于<code>&#123; A(); B(); C() &#125;</code>，连续的，串行的跑。</p>
</li>
<li><p>和操作系统不太一样的是，操作系统可以随时随地把你线程停掉，切换到另一个线程。这个单线程的  scheduler没那个能力啊，他跑着A的时候控制权是在A的代码里面的. A自己不退出谁也没办法。</p>
</li>
<li><p>所以A跑一小段后需要主动说，老大（scheduler），我不想跑了，帮我把我的所有的状态保存在我自己的栈上面，让我歇一会吧。这时候你可以看做A返回了。</p>
</li>
<li><p>A返回了B就可以跑了，然后B跑一小段说，跑够了，保存状态，返回，然后C再跑。C跑一段也返回了。</p>
</li>
<li><p>这样跑完<code>&#123; A(); B(); C() &#125;</code>之后，我们发现，好像他们都只跑了一小段啊。所以外面要包一个循环，大致是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goroutine_list = [A,B,C]</span><br><span class="line"><span class="keyword">while</span> (goroutine_list):</span><br><span class="line">    <span class="keyword">for</span> goroutine <span class="keyword">in</span> goroutine_list:</span><br><span class="line">        r = goroutine()</span><br><span class="line">        <span class="keyword">if</span> r.isFinished():</span><br><span class="line">            goroutine_list.remove(r)</span><br></pre></td></tr></table></figure>

<p>比如跑完一圈A,B,C之后谁也没执行完，那么就在回到A执行一次。由于我们把A的栈保存在了<code>资源堆</code>里，这时候可以把A的栈复制粘贴回系统栈里，然后再调用A，这时候由于A是跑到一半自己说跳出来的，所以会从刚刚跳出来的地方继续执行。</p>
</li>
<li><p>所以你看出来了，关键就在于每个 goroutine跑一跑就要让一让。一般支持这种玩意（叫做 coroutine）的语言都是让每个coroutine自己说，我跑够了，换人。goroutine比较文艺的地方就在于，他可以来帮你判断啥时候“跑够了”。</p>
<p>比如说python , 就需要使用<code>await</code>关键字表明, 该函数跑够了 , 该暂时让出资源了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x) <span class="comment"># 在此处暂停,执行权交给其他函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(x)</span><br></pre></td></tr></table></figure></li>
<li><p>go 是如何做到这一点的呢? go把每一个能异步并发的操作，包成一个同步的“方法” , 但是这个方法里其实会调用“异步并发”的操作.</p>
<p>比如<code>string s = go.file.readFile(&quot;/root&quot;)</code>其实go偷偷在里面执行了操作系统的API asyncReadFIle。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 实际上</span></span><br><span class="line">handler h = OS.asyncReadFile(<span class="string">&quot;/root&quot;</span>) <span class="comment">#很快返回一个handler</span></span><br><span class="line"><span class="keyword">while</span> (!h.finishedAsyncReadFile()): <span class="comment">#很快返回Y/N</span></span><br><span class="line">  go.scheduler.保存现状()</span><br><span class="line">  <span class="keyword">yield</span> go.scheduler.跑够了_换人() <span class="comment"># 相当于return，不过下次会从这里的下一句开始执行</span></span><br><span class="line">string s = h.getResultFromAsyncRead()</span><br></pre></td></tr></table></figure></li>
<li><p>然后scheduler就换下一个goroutine跑了。等下次再<strong>跑回</strong>刚才那个goroutine的时候，他就看看，说那个asyncReadFile到底执行完没有啊，如果没有，就再换个人吧。如果执行完了，那就把结果拿出来，该干嘛干嘛。所以你看似写了个同步的操作，已经被go替换成异步操作了。</p>
</li>
<li><p>还有另外一种情况是，某个goroutine执行了某个<strong>不能异步调用</strong>的 , 会阻塞的系统调用，这个时候goroutine就没法玩那种异步调用的把戏了。他会把你挪到一个真正的线程里让你在那个线程里等着，他接茬去跑别的goroutine。</p>
<p>比如A这么定义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>:</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">  go.os.调用一些真正复杂的会阻塞的函数()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;do something 2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>go会帮你转成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 真实的<span class="title">A</span>:</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">  Thread t = new Thread( () =&gt; &#123;</span><br><span class="line">    go.os.调用一些真正复杂的会阻塞的函数()</span><br><span class="line">  &#125;)</span><br><span class="line">  t.start()</span><br><span class="line">  <span class="keyword">while</span> !t.finished():</span><br><span class="line">    go.scheduler.保存现状</span><br><span class="line">    go.scheduler.跑够了_换人</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;finished&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>所以真实的A还是不会blocking，还是可以跟别的小伙伴(goroutine)愉快地玩耍（轮流往复的被执行），但他其实已经占了一个真实的系统线程了。</p>
</li>
</ol>
<h3 id="MPG模型"><a href="#MPG模型" class="headerlink" title="MPG模型"></a>MPG模型</h3><ul>
<li>M：操作系统的主线程（是物理线程）</li>
<li>P：代表了M所需的上下文环境，<strong>用于协调M和G的执行</strong>，内核线程只有拿到了P才对 goroutine继续调度执行，一般都是通过限定P的个数来控制 galang的并发度</li>
<li>G：协程</li>
</ul>
<p><img src="/images/1591414922123.png" alt="1591414922123"></p>
<ol>
<li>当前程序有三个M，如果三个M都在一个cpu运行，就是并发，如果在不同的cpu运行就是并行</li>
<li><code>M1</code> ,<code> M2</code>，<code>M3</code>正在执行一个G ，M1的协程队列有3个，M2的协程队列有3个，M3协程队列有2个</li>
<li>图中灰色的那些 goroutine并没有运行，而是出于read的就绪态，正在等待被调度。P维护着这个队列（称之为 runqueue）</li>
<li>从上图可以看到：Go的协程是轻量级的线程，是<strong>逻辑态</strong>的，Go可以容易的起上万个协程。其它程序c/java的多线程，往往是内核态的，比较重量级。几千个线程可能耗光CPU。</li>
</ol>
<h3 id="设置golang程序的CPU数量"><a href="#设置golang程序的CPU数量" class="headerlink" title="设置golang程序的CPU数量"></a>设置golang程序的CPU数量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前系统CPU的数量</span></span><br><span class="line">	num := runtime.NumCPU()</span><br><span class="line">	<span class="comment">// 设置程序使用的cpu数量</span></span><br><span class="line">	runtime.GOMAXPROCS(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="goroutine可能出现的两个问题"><a href="#goroutine可能出现的两个问题" class="headerlink" title="goroutine可能出现的两个问题"></a>goroutine可能出现的两个问题</h3><h4 id="问题1-主线程先于goroutine结束"><a href="#问题1-主线程先于goroutine结束" class="headerlink" title="问题1 : 主线程先于goroutine结束"></a>问题1 : 主线程先于goroutine结束</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line">	m[n] = res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Factorial(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出不确定 , 有时输出如下 , 有时没有输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map[5]=120</span><br><span class="line">map[7]=5040</span><br><span class="line">map[10]=3628800</span><br><span class="line">map[1]=1</span><br><span class="line">map[3]=6</span><br><span class="line">map[4]=24</span><br><span class="line">map[9]=362880</span><br><span class="line">map[2]=2</span><br><span class="line">map[6]=720</span><br><span class="line">map[8]=40320</span><br></pre></td></tr></table></figure>

<p>原因很简单 : 有可能主线程先于协程结束 , 有可能主线程慢于协程结束</p>
<h4 id="问题2-goroutine资源争抢"><a href="#问题2-goroutine资源争抢" class="headerlink" title="问题2 : goroutine资源争抢"></a>问题2 : goroutine资源争抢</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line">	m[n] = res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Factorial(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码 把问题1的代码的10次循环改成200 , 并添加<code>time.Sleep</code> , 保证了主线程慢于协程结束</p>
<p>但是依旧会报错 :</p>
<ul>
<li>map由多协程同时读和写就会出现<code>fatal error:concurrent map read and map write</code>的错误</li>
<li>多个协程同时写也会出现<code>fatal error: concurrent map writes</code>的错误</li>
</ul>
<p>原因 : </p>
<ul>
<li>因为map为引用类型，所以即使函数传值调用，参数副本依然指向映射m, 所以多个goroutine并发写同一个映射m， 对于共享变量，资源，并发读写会产生竞争的， 故共享资源遭到破坏</li>
</ul>
<p>我们使用<code>go build -race bbb.go</code> , <code>bbb.exe</code> 查看资源竞争情况 , 发现有2个数据发生争抢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">map[19]=121645100408832000</span><br><span class="line">map[80]=0</span><br><span class="line">map[87]=0</span><br><span class="line">map[185]=0</span><br><span class="line">map[197]=0</span><br><span class="line">Found 2 data race(s)</span><br></pre></td></tr></table></figure>



<h2 id="不同goroutine进行通讯"><a href="#不同goroutine进行通讯" class="headerlink" title="不同goroutine进行通讯"></a>不同goroutine进行通讯</h2><h3 id="全局变量添加锁"><a href="#全局变量添加锁" class="headerlink" title="全局变量添加锁"></a>全局变量添加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个全局的互斥锁</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Lock() <span class="comment">// 在写入的时候加锁</span></span><br><span class="line">	m[n] = res</span><br><span class="line">	lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Factorial(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	lock.Lock() <span class="comment">// 在读取的时候加锁</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>读取为什么需要加互斥锁?</li>
<li>按理说5秒后协程都应该执行完，后面就不应该出现资源竞争的问题了，</li>
<li>但是在实际运行中，还是可能在读取的时候出现竞争问题（运行时增加<code>-race</code>参数确实会发现有资源竞争问题），</li>
<li>因为我们程序从设计上可以知道5秒就执行完所有协程，但是主线程并不知道，因此底层可能仍然岀现资源争夺，因此加入互斥锁即可解决问题</li>
</ul>
</blockquote>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><ul>
<li>本质是<code>队列</code></li>
<li>channel 是有类型的 , string类型就需要放到string类型的channel</li>
<li>当我们给channel写入数据时 , 不能超出channel的容量</li>
<li>在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报告<code>deadlock</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	num := <span class="number">10</span></span><br><span class="line">	intChan &lt;- num</span><br><span class="line">	intChan &lt;- <span class="number">20</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan)) <span class="comment">// 2 3</span></span><br><span class="line">	num2 := &lt;-intChan</span><br><span class="line">	fmt.Println(num2)                       <span class="comment">// 10</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan)) <span class="comment">// 1 3</span></span><br><span class="line"></span><br><span class="line">	mapChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">	mapChan &lt;- <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;heyingliang&quot;</span>: <span class="number">21</span>&#125;</span><br><span class="line">	fmt.Println(&lt;-mapChan) <span class="comment">// map[heyingliang:21]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用空接口作为chan的时候 , 在取出后注意需要进行<code>类型断言</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	allChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">	allChan &lt;- Student&#123;<span class="string">&quot;heyingliang&quot;</span>, <span class="number">21</span>&#125;</span><br><span class="line">	allChan &lt;- <span class="number">12</span></span><br><span class="line">	allChan &lt;- <span class="string">&quot;heyingling&quot;</span></span><br><span class="line">	allChan &lt;- &amp;Student&#123;<span class="string">&quot;123&quot;</span>, <span class="number">123</span>&#125;</span><br><span class="line">	allChan &lt;- <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;heyingliang&quot;</span>: <span class="number">21</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意需要类型断言</span></span><br><span class="line">	fmt.Println((&lt;-allChan).(Student).Name) <span class="comment">// heyingliang</span></span><br><span class="line">	fmt.Println((&lt;-allChan).(<span class="keyword">int</span>) + <span class="number">22</span>) <span class="comment">// 34</span></span><br><span class="line">	fmt.Println((&lt;-allChan).(<span class="keyword">string</span>) + <span class="string">&quot;is sb&quot;</span>) <span class="comment">// heyinglingis sb</span></span><br><span class="line">	fmt.Println((&lt;-allChan).(*Student).Name) <span class="comment">// 123</span></span><br><span class="line">	m := (&lt;-allChan).(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	m[<span class="string">&quot;czj&quot;</span>] = <span class="number">22</span></span><br><span class="line">	fmt.Println(m[<span class="string">&quot;czj&quot;</span>]) <span class="comment">// 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="chan操作"><a href="#chan操作" class="headerlink" title="chan操作"></a>chan操作</h4><ul>
<li><p>关闭 : 关闭后只允许读取 , 不允许写入</p>
<ul>
<li>严格来说 , 应该是 : 在最后发送的值被接收后停止该通道。</li>
</ul>
</li>
<li><p>遍历 : <code>for--range</code></p>
<ul>
<li><p>不能使用<code>for-index,val</code> 原因 : chan取值是<code>弹出操作</code> , 所以每次取值之后,chan的长度会-1 . 这样的话100个数据最后只能拿到50个数据</p>
<blockquote>
<p>这也说明了为什么遍历是<code>for val := range chan</code> ,而不是<code>for idx ,val :=range chan</code> . </p>
<p>因为chan本身就是<code>队列</code> , 没有下标</p>
</blockquote>
</li>
<li><p><strong>在遍历时，如果channe没有关闭，则会出现 deadlock的错误</strong></p>
<blockquote>
<p>为什么会出现<code>deadlock的错误</code>?</p>
<p>因为 : 在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报告<code>deadlock</code></p>
<p>当chan的最后一个值被取出后 , 再取就报错</p>
</blockquote>
</li>
<li><p>在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退岀遍历</p>
</li>
</ul>
</li>
<li><p>检查Channel是否已经被关闭了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">	c &lt;- <span class="number">2</span></span><br><span class="line">	c &lt;- <span class="number">3</span></span><br><span class="line">	c &lt;- <span class="number">4</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 关闭管道</span></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">	val, ok := &lt;-c</span><br><span class="line">	fmt.Println(val, ok) <span class="comment">// 1 true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历管道</span></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(v) <span class="comment">// 2 3 4</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="chan使用案例"><a href="#chan使用案例" class="headerlink" title="chan使用案例"></a>chan使用案例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> exitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteData</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;write&quot;</span>, i)</span><br><span class="line">		intChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadData</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		v, ok := &lt;-intChan</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;read&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	exitChan &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> WriteData()</span><br><span class="line">	<span class="keyword">go</span> ReadData()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, ok := &lt;-exitChan</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的<code>intChan</code>长度只有10 , 但是写入了50个元素 , 结果没有报错 , 原因 : <code>管道的阻塞机制</code></p>
<ul>
<li>如果编译器发现管道只有写，而没有读，则该管道会发生阻塞 , 报错。</li>
<li>写管道和读管道的频率不一致，一样能运行通过。</li>
</ul>
</blockquote>
<h4 id="chan使用案例2"><a href="#chan使用案例2" class="headerlink" title="chan使用案例2"></a>chan使用案例2</h4><p>求出1-20000中的质数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">var</span> outputChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="keyword">var</span> exitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inputData</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= num; i++ &#123;</span><br><span class="line">		inputChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(inputChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oddNum</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		isOdd := <span class="literal">true</span></span><br><span class="line">		val, ok := &lt;-inputChan</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			exitChan &lt;- <span class="literal">true</span></span><br><span class="line">			fmt.Println(num, <span class="string">&quot;is stopping&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= val/<span class="number">2</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> val%i == <span class="number">0</span> &#123;</span><br><span class="line">				isOdd = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> isOdd &#123;</span><br><span class="line">			outputChan &lt;- val</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> inputData(<span class="number">8000</span>)</span><br><span class="line">	<span class="keyword">go</span> oddNum(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> oddNum(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> oddNum(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">go</span> oddNum(<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(exitChan) == <span class="number">4</span> &#123;</span><br><span class="line">				<span class="built_in">close</span>(outputChan)</span><br><span class="line">				<span class="built_in">close</span>(exitChan)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> val := <span class="keyword">range</span> outputChan &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="只读只写管道"><a href="#只读只写管道" class="headerlink" title="只读只写管道"></a>只读只写管道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认支持读写</span></span><br><span class="line"><span class="comment">// var chan1 chan int</span></span><br><span class="line"><span class="keyword">var</span> chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明只读</span></span><br><span class="line"><span class="keyword">var</span> chan2 = <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明只写</span></span><br><span class="line"><span class="keyword">var</span> chan3 = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<p>用法 : </p>
<p>将函数参数的chan改成<code>只写</code>或<code>只读</code> , 防止误操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeChan</span><span class="params">(intchan <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	intchan &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readChan</span><span class="params">(intchan &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(&lt;-intchan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><ul>
<li><p>select 是 Go 中的一个控制结构，类似于用于<strong>通信的 switch 语句</strong>。</p>
</li>
<li><p>每个 case 必须是一个通信操作，要么是发送要么是接收。</p>
</li>
<li><p>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</p>
<p>(如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。)</p>
</li>
<li><p>一个默认的子句应该总是可运行的。</p>
</li>
</ul>
<blockquote>
<ol>
<li><p>如果有 default 子句，则执行该语句。</p>
</li>
<li><p>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</p>
</li>
</ol>
<p>所以沒有 <code>default</code> 的 select 就會遇到 blocking，假設沒有送 value 進去 Channel 就會造成 panic。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">var</span> stringChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++ &#123;</span><br><span class="line">		intChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++ &#123;</span><br><span class="line">		stringChan &lt;- <span class="string">&quot;hyl&quot;</span> + fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-intChan:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;intChan %d\n&quot;</span>, v)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-stringChan:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;stringChan %s\n&quot;</span>, v)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;默认\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>python中的反射</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">num_arr</span>):</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> val <span class="keyword">in</span> num_arr:</span><br><span class="line">		res += val</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span>(<span class="params">num1,num2</span>):</span></span><br><span class="line">	<span class="keyword">return</span> num1 - num2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bridge</span>(<span class="params">func,*args</span>):</span></span><br><span class="line">	<span class="keyword">return</span> func(*args)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bridge(add,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])) <span class="comment"># 15</span></span><br><span class="line"><span class="built_in">print</span>(bridge(sub,<span class="number">50</span>,<span class="number">10</span>)) <span class="comment"># 40   </span></span><br></pre></td></tr></table></figure>



<ul>
<li>反射可以在<strong>运行时</strong>动态获取变量的各种信息，比如变量的类型（<code>type</code>），类别（<code>kind</code>）</li>
<li>如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）</li>
<li>通过反射，可以修改变量的值，可以调用关联的方法</li>
<li>使用反射，需要<code>import(&quot;reflect&quot;)</code></li>
</ul>
<blockquote>
<ul>
<li>reflect包实现了运行时反射，允许程序操作任意类型的对象，典型用法是用静态类型interface{}保存一个值，</li>
<li><code>reflect.TypeOf(变量名)</code> : 获取变量类型 , 返回reflect.Type类型</li>
<li><code>reflect.ValueOf(变量名)</code> : 获取变量的值 , 返回refulect.Value类型 (refulect.Value是一个结构体类型)</li>
<li><code>reflect.Zero(Type类型变量)</code> : 返回该类型零值的Value类型值</li>
</ul>
</blockquote>
<h3 id="reflect-Kind-和-reflect-Type的区别"><a href="#reflect-Kind-和-reflect-Type的区别" class="headerlink" title="reflect.Kind 和 reflect.Type的区别"></a>reflect.Kind 和 reflect.Type的区别</h3><ul>
<li>Type是类型，Kind是类别，</li>
<li>Type和Kind可能是相同的，也可能是不同<ul>
<li>比如：var num int = 10 , num的Type是int , Kind也是int</li>
<li>比如：var stu Student stu 的Type是pkg1.Student , Kind是 struct </li>
</ul>
</li>
</ul>
<h3 id="interface-reflect-Value-和-变量类型互转"><a href="#interface-reflect-Value-和-变量类型互转" class="headerlink" title="interface , reflect.Value 和 变量类型互转"></a>interface , reflect.Value 和 变量类型互转</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bridge</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    <span class="comment">// interface&#123;&#125; --&gt; reflect.Value</span></span><br><span class="line">    rVal := reflect.ValueOf(b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reflect.Value --&gt; interface&#123;&#125;</span></span><br><span class="line">    iVal := rVal.<span class="keyword">interface</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// interface&#123;&#125; --&gt; 原来的变量类型 , 使用类型断言即可</span></span><br><span class="line">    v := iVal.(Student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/1591607663510.png" alt="1591607663510"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// interface&#123;&#125;类型转为reflect.Value类型</span></span><br><span class="line">	rValue := reflect.ValueOf(b)</span><br><span class="line">	rType := reflect.TypeOf(b)</span><br><span class="line">	rKind := rValue.Kind()</span><br><span class="line">	fmt.Println(rValue, rType, rKind) <span class="comment">// 25.5 float64 float64</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// reflect.Value类型转为interface&#123;&#125;类型</span></span><br><span class="line">	inf := rValue.Interface()</span><br><span class="line">  <span class="comment">// interface&#123;&#125;类型转为具体变量类型</span></span><br><span class="line">	v := inf.(<span class="keyword">float64</span>)</span><br><span class="line">	fmt.Println(inf, v) <span class="comment">// 25.5 25.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := <span class="number">25.5</span></span><br><span class="line">	reflectTest(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="在反射函数中修改int值"><a href="#在反射函数中修改int值" class="headerlink" title="在反射函数中修改int值"></a>在反射函数中修改int值</h3><ul>
<li>rVal.Elem()：取元素，等效于对指针类型变量做了一个<code>*</code>操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	rVal := reflect.ValueOf(b)</span><br><span class="line">	<span class="comment">// 在反射中修改int值 , 同理有SetString,SetBool等等</span></span><br><span class="line">	rVal.Elem().SetInt(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">	<span class="comment">// 传入int的指针类型</span></span><br><span class="line">	reflectTest(&amp;num)</span><br><span class="line">	fmt.Println(num) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用反射遍历结构体的字段-调用结构体方法-获取stuct-tag值"><a href="#使用反射遍历结构体的字段-调用结构体方法-获取stuct-tag值" class="headerlink" title="使用反射遍历结构体的字段,调用结构体方法,获取stuct tag值"></a>使用反射遍历结构体的字段,调用结构体方法,获取stuct tag值</h3><ul>
<li><p><code>func (v Value) Method(i int ) Value</code> : 获取结构体第i个方法</p>
</li>
<li><p><code>func(v Value) Call(in []Value) []Value</code> : 调用结构体方法</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="keyword">int</span> <span class="string">`json:&quot;monster_age&quot;`</span></span><br><span class="line">	Score <span class="keyword">float32</span></span><br><span class="line">	Sex <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Monster)</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Monster)</span> <span class="title">GetSum</span><span class="params">(n1 ,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n1 +n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Monster)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>,age <span class="keyword">int</span>,socre <span class="keyword">float32</span>,sex <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	m.Name = name</span><br><span class="line">	m.Age = age</span><br><span class="line">	m.Score = socre</span><br><span class="line">	m.Sex = sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStruct</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	typ := reflect.TypeOf(a)</span><br><span class="line">	val := reflect.ValueOf(a)</span><br><span class="line">	kd := val.Kind()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kd != reflect.Struct&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;expect struct&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取到该结构体有几个字段</span></span><br><span class="line">	num := val.NumField()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d fields\n&quot;</span>,num) <span class="comment">// struct has 4 fields</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历结构体的所有字段</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;num;i++&#123;</span><br><span class="line">		<span class="comment">// val.Field(i): 返回结构体的第i个字段(Value封装)</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Field %d: 值为=%v\n&quot;</span>,i,val.Field(i))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取到struct标签,注意需要通过reflect.Type来获取tag标签的值</span></span><br><span class="line">		tagVal := typ.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> tagVal != <span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Field %d: tag为=%v\n&quot;</span>,i,tagVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取到该结构体有几个方法</span></span><br><span class="line">	numOfMethod := val.NumMethod()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d methods\n&quot;</span>,numOfMethod) <span class="comment">// struct has 3 methods</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先对方法按照ascii码进行排序,然后调用第2个方法(从0开始)</span></span><br><span class="line">	val.Method(<span class="number">1</span>).Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明函数参数的切片</span></span><br><span class="line">	<span class="keyword">var</span> params []reflect.Value</span><br><span class="line">	params = <span class="built_in">append</span>(params,reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params,reflect.ValueOf(<span class="number">40</span>))</span><br><span class="line">	<span class="comment">// 调用结构体的第一个方法:Method(0)</span></span><br><span class="line">	res := val.Method(<span class="number">0</span>).Call(params) <span class="comment">// 传入参数是 []reflect.Value</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>,res[<span class="number">0</span>].Int()) <span class="comment">// 返回结果,返回的结果是 []reflect.Value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m Monster = Monster&#123;</span><br><span class="line">		Name:<span class="string">&quot;heyingliang&quot;</span>,</span><br><span class="line">		Age:<span class="number">400</span>,</span><br><span class="line">		Score:<span class="number">30.8</span>,</span><br><span class="line">		Sex:<span class="string">&quot;男&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	TestStruct(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct has 4 fields</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field 0: 值为=heyingliang</span></span><br><span class="line"><span class="comment">// Field 0: tag为=name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field 1: 值为=400</span></span><br><span class="line"><span class="comment">// Field 1: tag为=monster_age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field 2: 值为=30.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field 3: 值为=男</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct has 3 methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;heyingliang 400 30.8 男&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// res= 50</span></span><br></pre></td></tr></table></figure>



<h3 id="go的适配器"><a href="#go的适配器" class="headerlink" title="go的适配器"></a>go的适配器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(num1 + num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(num1 - num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bridge</span><span class="params">(call <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 将args转为reflect.Value类型</span></span><br><span class="line">	n := <span class="built_in">len</span>(args)</span><br><span class="line">	inValue := <span class="built_in">make</span>([]reflect.Value,n)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++&#123;</span><br><span class="line">		inValue[i] = reflect.ValueOf(args[i])</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 将call转为reflect.Value类型</span></span><br><span class="line">	function := reflect.ValueOf(call)</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">	function.Call(inValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bridge(add, <span class="number">100</span>,<span class="number">200</span>) <span class="comment">// 300</span></span><br><span class="line">	bridge(sub,<span class="number">100</span>,<span class="number">200</span>)  <span class="comment">// -100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ERROR_USER_NOTEXISTS = errors.New(<span class="string">&quot;用户不存在&quot;</span>)</span><br><span class="line">	ERROR_USER_EXISTS = errors.New(<span class="string">&quot;用户已经存在&quot;</span>)</span><br><span class="line">	ERROR_USER_PWD = errors.New(<span class="string">&quot;密码不正确&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserDao <span class="keyword">struct</span> &#123;</span><br><span class="line">	pool *redis.Pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserDao</span><span class="params">(pool *redis.Pool)</span> <span class="params">(userDao *UserDao)</span></span> &#123;</span><br><span class="line">	UserDao = &amp;UserDao&#123; pool &#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UserDao)</span> <span class="title">getUserByID</span><span class="params">(conn redis.Conn, id <span class="keyword">int</span>)</span> <span class="params">(user *User, err error)</span></span> &#123;</span><br><span class="line">	res, err := redis.String(conn.Do(<span class="string">&quot;HGet&quot;</span>,<span class="string">&quot;users&quot;</span>,id))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 在users的哈希中,没有找到对应id</span></span><br><span class="line">		<span class="keyword">if</span> err == redis.ErrNil &#123;</span><br><span class="line">			err = ERROR_USER_NOTEXISTS</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	user = &amp;User&#123;&#125;</span><br><span class="line">	err = json.Umarshal([]<span class="keyword">byte</span>(res), User)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json.Umarshal err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UserDao)</span> <span class="title">Login</span><span class="params">(userId <span class="keyword">int</span>, UserPwd <span class="keyword">string</span>)</span> <span class="params">(user *User, err error)</span></span>&#123;</span><br><span class="line">	conn := this.pool.Get()</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	user, err = this.getUserByID(conn, userId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> user.UserPwd != userPwd &#123;</span><br><span class="line">		err = ERROR_USER_PWD</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><ul>
<li>端口监听到一个请求时 , 其他语言都会创建一个线程/进程/协程来处理该请求 , go就可以使用<code>goroutine</code>来解决</li>
<li><code>net包</code>包含<code>网络socket开发</code>需要所有的方法和函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">		<span class="comment">// 如果客户端没有write,那么协程就会阻塞在在这里</span></span><br><span class="line">		n,err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端已退出&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;0.0.0.0:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;listen err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;等待客户端连接&quot;</span>)</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Accept() err=&quot;</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Accept() suc con=%v\n&quot;</span>, conn)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 在此处准备协程,为客户端服务</span></span><br><span class="line">		<span class="keyword">go</span> process(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// net.Dial: 和服务器建立连接</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;192.168.20.253:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;client dial err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;conn 成功=&quot;</span>, conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 客户端发送单行数据,然后退出</span></span><br><span class="line">	reader := bufio.NewReader(os.Studin)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line,err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;readString err=&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">&quot;exit&quot;</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端退出&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		n, err := conn.Write([]<span class="keyword">byte</span>(line))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;conn.Write err=&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;客户端发送了 %d 字节的数据,并退出&quot;</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/garyburd/redigo/redis&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := redis.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;redis.Dial err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	_, err := conn.Do(<span class="string">&quot;Set&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;heyingliang&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;set err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;set succ&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// conn.Do(&quot;Get&quot;,&quot;name&quot;) 返回的r是interface&#123;&#125;,所以需要强转</span></span><br><span class="line">	r, err := redis.String(conn.Do(<span class="string">&quot;Get&quot;</span>,<span class="string">&quot;name&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;get err&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(r)</span><br><span class="line"></span><br><span class="line">	_,err = conn.Do(<span class="string">&quot;HMSet&quot;</span>,<span class="string">&quot;user&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;heyingliang&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>)</span><br><span class="line">	<span class="comment">// 注意这里是redis.Strings(复数)</span></span><br><span class="line">	r,err = redis.Strings(conn.Do(<span class="string">&quot;HMSet&quot;</span>,<span class="string">&quot;user&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i,v := <span class="keyword">range</span> r &#123;</span><br><span class="line">		fmt.Println(i,v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Redis连接池"><a href="#Redis连接池" class="headerlink" title="Redis连接池"></a>Redis连接池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/garyburd/redigo/redis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> poll *redis.Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	pool = &amp;redis.Pool&#123;</span><br><span class="line">		<span class="comment">// 最大空闲连接数</span></span><br><span class="line">		MaxIdle: <span class="number">8</span>, </span><br><span class="line">		<span class="comment">// 数据库最大连接数,0表示无限制</span></span><br><span class="line">		MaxActive: <span class="number">0</span>,</span><br><span class="line">		<span class="comment">// 最大空闲时间</span></span><br><span class="line">		IdleTimeout: <span class="number">100</span>,</span><br><span class="line">		<span class="comment">// 初始化连接代码</span></span><br><span class="line">		Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> redis.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;localhost:6379&quot;</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn := pool.Get()</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	</span><br><span class="line">	_,err := conn.Do(<span class="string">&quot;Set&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hyl&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是：</p>
<ul>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li>
</ul>
<p><img src="/images/1591848896140.png" alt="1591848896140"></p>
<blockquote>
<p>简单来说 , 就是<strong>将无用的数据扔掉 , 进而无损压缩数据</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ValNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	row <span class="keyword">int</span></span><br><span class="line">	col <span class="keyword">int</span></span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> chessMap [<span class="number">11</span>][<span class="number">11</span>]<span class="keyword">int</span></span><br><span class="line">	chessMap[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">	chessMap[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> _, v1 := <span class="keyword">range</span> chessMap &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d\t&quot;</span>,v2)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sparseArr []ValNode</span><br><span class="line">	<span class="comment">// 标准的稀疏数组需要一个 `记录二维数组的规模(行和列)`</span></span><br><span class="line">	head := ValNode&#123;</span><br><span class="line">		row:<span class="number">11</span>,</span><br><span class="line">		col:<span class="number">11</span>,</span><br><span class="line">		val:<span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	sparseArr = <span class="built_in">append</span>(sparseArr,head)</span><br><span class="line">	<span class="comment">// 储存稀疏数组</span></span><br><span class="line">	<span class="keyword">for</span> i, v1 := <span class="keyword">range</span> chessMap &#123;</span><br><span class="line">		<span class="keyword">for</span> j, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">			<span class="keyword">if</span> v2 != <span class="number">0</span> &#123;</span><br><span class="line">				valNode := ValNode&#123;</span><br><span class="line">					row:i,</span><br><span class="line">					col:j,</span><br><span class="line">					val:v2,</span><br><span class="line">				&#125;</span><br><span class="line">				sparseArr = <span class="built_in">append</span>(sparseArr,valNode)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出稀疏数组</span></span><br><span class="line">	<span class="keyword">for</span> i,valNode := <span class="keyword">range</span> sparseArr &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d:%d %d %d\n&quot;</span>,i,valNode.row,valNode.col,valNode.val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><h3 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h3><ul>
<li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下其中 maxsize是该队列的最大容量。</p>
<p><img src="/images/1591860031681.png" alt="1591860031681"></p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输岀而改变，而rear则是随着数据输入而改变，</p>
</li>
<li><p>一般约定 , 当rear距离front只有一个空位的时候为<code>对满</code> (也就是说,队尾差一位就能追上对首)</p>
<ul>
<li>所以就是判断 : <code>(rear + 1) % maxSize == head</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>总结 :</p>
<ul>
<li>初始化 : <code>rear == head == 0</code></li>
<li>对空 : <code>rear == head</code></li>
<li>对满 : <code>(rear + 1) % maxSize == head</code></li>
<li>队列的元素个数 : <code>(rear + maxSize - head) % maxSize</code> (为了保证不出现负数 , 要加一个maxSize)</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CircleQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	maxSize <span class="keyword">int</span></span><br><span class="line">	array [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">	front <span class="keyword">int</span> <span class="comment">// 队首指针</span></span><br><span class="line">	rear <span class="keyword">int</span> <span class="comment">// 队尾部指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">IsFull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (this.rear + <span class="number">1</span>) % this.maxSize == this.front</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.front == this.rear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (this.rear + this.maxSize - this.front) % this.maxSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先判断队列是否已满</span></span><br><span class="line">	<span class="keyword">if</span> this.IsFull() &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;queue full&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	this.rear++ <span class="comment">// 后移</span></span><br><span class="line">	this.array[this.rear] =val</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(val <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> , errors.New(<span class="string">&quot;queue empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	this.front = (this.front + <span class="number">1</span>) % this.maxSize</span><br><span class="line">	val = this.array[this.front]</span><br><span class="line">	<span class="keyword">return</span> val ,err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">List</span><span class="params">()</span></span> &#123;</span><br><span class="line">	size := this.Size()</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Queue Empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	dummy := this.front</span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;arr[%d]=%d\t&quot;</span>, dummy, this.array[dummy])</span><br><span class="line">		dummy = (dummy +<span class="number">1</span>) % this.maxSize</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	queue := &amp;CircleQueue&#123;</span><br><span class="line">		maxSize :<span class="number">4</span>,</span><br><span class="line">		front :<span class="number">0</span>,</span><br><span class="line">		rear :<span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err := queue.Push(<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	queue.Push(<span class="number">200</span>)</span><br><span class="line">	queue.Push(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">	queue.List() <span class="comment">// array[0]=100    array[1]=200    array[2]=300</span></span><br><span class="line"></span><br><span class="line">	res,err := queue.Pop()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(res) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="环形单向链表"><a href="#环形单向链表" class="headerlink" title="环形单向链表"></a>环形单向链表</h3><p>环形单向链表一般也拥有<code>dummyHead</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CricleNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">	next *CricleNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *CricleNode)</span> <span class="title">append</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	pre := n</span><br><span class="line">	realHead := pre.next</span><br><span class="line"></span><br><span class="line">	<span class="comment">// realHead是空</span></span><br><span class="line">	<span class="keyword">if</span> pre.next == <span class="literal">nil</span> &#123;</span><br><span class="line">		newNode := &amp;CricleNode&#123;val:val&#125;</span><br><span class="line">		pre.next = newNode</span><br><span class="line">		newNode.next = newNode</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pre = realHead</span><br><span class="line">		<span class="keyword">for</span> pre.next != realHead&#123;</span><br><span class="line">			pre = pre.next</span><br><span class="line">		&#125;</span><br><span class="line">		newNode := &amp;CricleNode&#123;</span><br><span class="line">			val:val,</span><br><span class="line">			next:realHead,</span><br><span class="line">		&#125;</span><br><span class="line">		pre.next = newNode</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *CricleNode)</span> <span class="title">List</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n.next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pre := n.next</span><br><span class="line">	realHead := pre</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(pre.val)</span><br><span class="line">		pre = pre.next</span><br><span class="line">		<span class="keyword">if</span> pre == realHead &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	DummyHead := &amp;CricleNode&#123;&#125;</span><br><span class="line">	DummyHead.<span class="built_in">append</span>(<span class="number">100</span>)</span><br><span class="line">	DummyHead.<span class="built_in">append</span>(<span class="number">200</span>)</span><br><span class="line">	DummyHead.<span class="built_in">append</span>(<span class="number">300</span>)</span><br><span class="line">	DummyHead.List()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>对比单向链表的优势 :</p>
<ul>
<li>支持向前查找</li>
<li>单向链表不支持<code>自我删除</code> , 必须依赖其他辅助节点 , 而双向链表支持<code>自我删除</code></li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	Len := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=Len <span class="number">-1</span>; i++ &#123;</span><br><span class="line">		maxIdx := i</span><br><span class="line">		<span class="keyword">for</span> j:=i; j&lt;=Len <span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &lt; arr[maxIdx] &#123;</span><br><span class="line">				maxIdx = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[i],arr[maxIdx] = arr[maxIdx],arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>&#125;</span><br><span class="line">	res := SelectSort(arr)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	Len := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;= Len<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> idx := i; idx &gt; <span class="number">0</span>;idx--&#123;</span><br><span class="line">			<span class="keyword">if</span> arr[idx] &lt; arr[idx<span class="number">-1</span>] &#123;</span><br><span class="line">				arr[idx], arr[idx<span class="number">-1</span>] = arr[idx<span class="number">-1</span>], arr[idx]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>&#125;</span><br><span class="line">	res := InsertSort(arr)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>