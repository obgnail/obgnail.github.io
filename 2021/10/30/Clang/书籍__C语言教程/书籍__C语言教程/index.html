<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;C-语言的特点&quot;&gt;&lt;a href=&quot;#C-语言的特点&quot; class=&quot;headerlink&quot; title=&quot;C 语言的特点&quot;&gt;&lt;/a&gt;C 语言的特点&lt;/h2&gt;&lt;p&gt;C 语言的哲学是“信任程序员，不要妨碍他们做事”。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>C语言教程 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Clang/" rel="tag">Clang</a></div><div class="post-time">2021-10-30</div></div></div><div class="container post-header"><h1>C语言教程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">C 语言的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB"><span class="toc-number">2.</span> <span class="toc-text">语法汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BD%86%E4%B8%8D%E8%B5%8B%E5%80%BC%E4%B8%8D%E4%BC%9A%E6%8A%A5%E9%94%99"><span class="toc-number">2.1.1.</span> <span class="toc-text">声明但不赋值不会报错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-scope"><span class="toc-number">2.1.2.</span> <span class="toc-text">变量的作用域(scope)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text">sizeof 运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">指针的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.</span> <span class="toc-text">指针运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B4%E6%95%B0%E5%80%BC%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E8%A1%A8%E7%A4%BA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E7%A7%BB%E5%8A%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">指针与整数值的加减运算表示内存地址的移动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">指针与指针的加法运算是非法的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%87%8F%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="toc-number">3.2.3.</span> <span class="toc-text">指针与指针的减法返回指针之间的距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E6%AF%94%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E6%9B%B4%E5%A4%A7"><span class="toc-number">3.2.4.</span> <span class="toc-text">指针与指针的比较运算比的是哪个内存地址更大</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%B8%8D%E5%85%81%E8%AE%B8%E5%B5%8C%E5%A5%97"><span class="toc-number">4.1.</span> <span class="toc-text">c语言函数不允许嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0return-0"><span class="toc-number">4.2.</span> <span class="toc-text">main函数return 0;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9E%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">4.3.</span> <span class="toc-text">函数不要返回内部变量的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">4.4.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit"><span class="toc-number">4.6.</span> <span class="toc-text">exit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">4.7.</span> <span class="toc-text">函数说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#extern"><span class="toc-number">4.7.1.</span> <span class="toc-text">extern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">4.7.2.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">4.7.3.</span> <span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">5.1.</span> <span class="toc-text">数组的地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">数组指针的加减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">数组的复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%80%E8%88%AC%E8%A6%81%E4%BC%A0%E9%80%92%E9%95%BF%E5%BA%A6"><span class="toc-number">5.4.</span> <span class="toc-text">数组作为函数参数一般要传递长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">6.1.</span> <span class="toc-text">字符串变量的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">使用字符数组和字符指针声明的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.</span> <span class="toc-text">字符串数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strlen"><span class="toc-number">6.4.</span> <span class="toc-text">strlen()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcpy"><span class="toc-number">6.5.</span> <span class="toc-text">strcpy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strncpy"><span class="toc-number">6.6.</span> <span class="toc-text">strncpy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcat"><span class="toc-number">6.7.</span> <span class="toc-text">strcat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strncat"><span class="toc-number">6.8.</span> <span class="toc-text">strncat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcmp"><span class="toc-number">6.9.</span> <span class="toc-text">strcmp()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strncmp"><span class="toc-number">6.10.</span> <span class="toc-text">strncmp()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88"><span class="toc-number">7.1.</span> <span class="toc-text">void 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc"><span class="toc-number">7.2.</span> <span class="toc-text">malloc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free"><span class="toc-number">7.3.</span> <span class="toc-text">free()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calloc"><span class="toc-number">7.4.</span> <span class="toc-text">calloc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#realloc"><span class="toc-number">7.5.</span> <span class="toc-text">realloc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#restrict-%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">7.6.</span> <span class="toc-text">restrict 说明符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memcpy"><span class="toc-number">7.7.</span> <span class="toc-text">memcpy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memmove"><span class="toc-number">7.8.</span> <span class="toc-text">memmove()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memcmp"><span class="toc-number">7.9.</span> <span class="toc-text">memcmp()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct"><span class="toc-number">8.</span> <span class="toc-text">struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">8.1.</span> <span class="toc-text">struct 的复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-%E6%8C%87%E9%92%88"><span class="toc-number">8.2.</span> <span class="toc-text">struct 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">8.3.</span> <span class="toc-text">struct 的嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">8.4.</span> <span class="toc-text">位字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B9%E6%80%A7%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98"><span class="toc-number">8.5.</span> <span class="toc-text">弹性数组成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef"><span class="toc-number">9.</span> <span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Union"><span class="toc-number">10.</span> <span class="toc-text">Union</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Enum-%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">Enum 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88Preprocessor%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">预处理器（Preprocessor）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#define"><span class="toc-number">12.1.</span> <span class="toc-text">#define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F"><span class="toc-number">12.2.</span> <span class="toc-text">带参数的宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">12.2.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">12.2.2.</span> <span class="toc-text">#运算符，##运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F"><span class="toc-number">12.2.3.</span> <span class="toc-text">不定参数的宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undef"><span class="toc-number">12.3.</span> <span class="toc-text">#undef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#include"><span class="toc-number">12.4.</span> <span class="toc-text">#include</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-endif"><span class="toc-number">12.5.</span> <span class="toc-text">#if...#endif</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifdef-endif"><span class="toc-number">12.6.</span> <span class="toc-text">#ifdef...#endif</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defined-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">12.7.</span> <span class="toc-text">defined 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifndef-endif"><span class="toc-number">12.8.</span> <span class="toc-text">#ifndef...#endif</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">12.9.</span> <span class="toc-text">预定义宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#line"><span class="toc-number">12.10.</span> <span class="toc-text">#line</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error"><span class="toc-number">12.11.</span> <span class="toc-text">#error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pragma"><span class="toc-number">12.12.</span> <span class="toc-text">#pragma</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">I&#x2F;O 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">13.1.</span> <span class="toc-text">缓存和字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf"><span class="toc-number">13.2.</span> <span class="toc-text">scanf()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-number">13.2.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="toc-number">13.2.2.</span> <span class="toc-text">占位符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%BF%BD%E7%95%A5%E7%AC%A6"><span class="toc-number">13.2.3.</span> <span class="toc-text">赋值忽略符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sscanf"><span class="toc-number">13.3.</span> <span class="toc-text">sscanf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getchar-%EF%BC%8Cputchar"><span class="toc-number">13.4.</span> <span class="toc-text">getchar()，putchar()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#puts"><span class="toc-number">13.5.</span> <span class="toc-text">puts()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gets"><span class="toc-number">13.6.</span> <span class="toc-text">gets()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">14.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88"><span class="toc-number">14.1.</span> <span class="toc-text">文件指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fopen"><span class="toc-number">14.2.</span> <span class="toc-text">fopen()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%B5%81"><span class="toc-number">14.3.</span> <span class="toc-text">标准流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fclose"><span class="toc-number">14.4.</span> <span class="toc-text">fclose()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EOF"><span class="toc-number">14.5.</span> <span class="toc-text">EOF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#freopen"><span class="toc-number">14.6.</span> <span class="toc-text">freopen()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fgetc-%EF%BC%8Cgetc"><span class="toc-number">14.7.</span> <span class="toc-text">fgetc()，getc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fputc-%EF%BC%8Cputc"><span class="toc-number">14.8.</span> <span class="toc-text">fputc()，putc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fprintf"><span class="toc-number">14.9.</span> <span class="toc-text">fprintf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fscanf"><span class="toc-number">14.10.</span> <span class="toc-text">fscanf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fgets"><span class="toc-number">14.11.</span> <span class="toc-text">fgets()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fputs"><span class="toc-number">14.12.</span> <span class="toc-text">fputs()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fwrite"><span class="toc-number">14.13.</span> <span class="toc-text">fwrite()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fread"><span class="toc-number">14.14.</span> <span class="toc-text">fread()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#feof"><span class="toc-number">14.15.</span> <span class="toc-text">feof()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fseek"><span class="toc-number">14.16.</span> <span class="toc-text">fseek()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ftell"><span class="toc-number">14.17.</span> <span class="toc-text">ftell()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewind"><span class="toc-number">14.18.</span> <span class="toc-text">rewind()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fgetpos-%EF%BC%8Cfsetpos"><span class="toc-number">14.19.</span> <span class="toc-text">fgetpos()，fsetpos()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ferror-%EF%BC%8Cclearerr"><span class="toc-number">14.20.</span> <span class="toc-text">ferror()，clearerr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove"><span class="toc-number">14.21.</span> <span class="toc-text">remove()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rename"><span class="toc-number">14.22.</span> <span class="toc-text">rename()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">15.</span> <span class="toc-text">变量说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const-1"><span class="toc-number">15.1.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-1"><span class="toc-number">15.2.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">15.3.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-1"><span class="toc-number">15.4.</span> <span class="toc-text">extern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register"><span class="toc-number">15.5.</span> <span class="toc-text">register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">15.6.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#restrict"><span class="toc-number">15.7.</span> <span class="toc-text">restrict</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE"><span class="toc-number">16.</span> <span class="toc-text">多文件项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%8A%A0%E8%BD%BD"><span class="toc-number">16.1.</span> <span class="toc-text">重复加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">16.2.</span> <span class="toc-text">extern 说明符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">16.3.</span> <span class="toc-text">static 说明符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%AD%96%E7%95%A5"><span class="toc-number">16.4.</span> <span class="toc-text">编译策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make-%E5%91%BD%E4%BB%A4"><span class="toc-number">16.5.</span> <span class="toc-text">make 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">17.</span> <span class="toc-text">命令行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">17.1.</span> <span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81"><span class="toc-number">17.2.</span> <span class="toc-text">退出状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">17.3.</span> <span class="toc-text">环境变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6"><span class="toc-number">18.</span> <span class="toc-text">多字节字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unicode-%E7%AE%80%E4%BB%8B"><span class="toc-number">18.1.</span> <span class="toc-text">Unicode 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">18.2.</span> <span class="toc-text">字符的表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">18.3.</span> <span class="toc-text">多字节字符的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">18.4.</span> <span class="toc-text">宽字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">18.5.</span> <span class="toc-text">多字节字符处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mblen"><span class="toc-number">18.5.1.</span> <span class="toc-text">mblen()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wctomb"><span class="toc-number">18.5.2.</span> <span class="toc-text">wctomb()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mbtowc"><span class="toc-number">18.5.3.</span> <span class="toc-text">mbtowc()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wcstombs"><span class="toc-number">18.5.4.</span> <span class="toc-text">wcstombs()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mbstowcs"><span class="toc-number">18.5.5.</span> <span class="toc-text">mbstowcs()</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h2 id="C-语言的特点"><a href="#C-语言的特点" class="headerlink" title="C 语言的特点"></a>C 语言的特点</h2><p>C 语言的哲学是“信任程序员，不要妨碍他们做事”。</p>
<ol>
<li>低级语言</li>
<li>可移植性</li>
<li>简单性</li>
<li>灵活性</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="语法汇总"><a href="#语法汇总" class="headerlink" title="语法汇总"></a>语法汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行</span></span><br><span class="line"><span class="keyword">int</span> x; x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依靠分号判断语句在哪一行结束</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x</span><br><span class="line">=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “空语句”，虽然毫无作用。</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 There are 3 apples</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There are %i apples\n&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值表达式有返回值，等于`等号右边的值`。</span></span><br><span class="line"><span class="comment">// 变量y的值就是赋值表达式（x = 2 * x）的返回值2。</span></span><br><span class="line"><span class="comment">// 由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = (x = <span class="number">2</span> * x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if语句</span></span><br><span class="line"><span class="keyword">if</span> (line_num == MAX_LINES) &#123;</span><br><span class="line">  line_num = <span class="number">0</span>;</span><br><span class="line">  page_num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// else总是跟最接近的if匹配。</span></span><br><span class="line"><span class="comment">// 下面示例中，else部分匹配最近的if（即number &lt; 12），所以如果number等于6，就不会执行else的部分。</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">6</span>)</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number is more than 6, less than 12.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;It is wrong number.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以建议使用大括号</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">6</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number is more than 6, less than 12.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;It is wrong number.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch语句</span></span><br><span class="line"><span class="comment">// 每个case语句体的结尾，都应该有一个break语句</span></span><br><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;False&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;True&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Illegal&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while语句</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i is now %d!\n&quot;</span>, i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do...while 结构</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i is %d\n&quot;</span>, i);</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for语句</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">999</span>; i &lt; <span class="number">10</span>; i++, j--) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本行会无限循环地打印。\n&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goto 语句</span></span><br><span class="line"><span class="comment">// 注意：goto 只能在同一个函数之中跳转</span></span><br><span class="line">top: ch = getchar();</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">  <span class="keyword">goto</span> top;</span><br></pre></td></tr></table></figure>



<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="声明但不赋值不会报错"><a href="#声明但不赋值不会报错" class="headerlink" title="声明但不赋值不会报错"></a>声明但不赋值不会报错</h4><p>C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%i&quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output：</span></span><br><span class="line"><span class="comment">// 195964982</span></span><br></pre></td></tr></table></figure>



<h4 id="变量的作用域-scope"><a href="#变量的作用域-scope" class="headerlink" title="变量的作用域(scope)"></a>变量的作用域(scope)</h4><p>C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）</p>
<ul>
<li><p>文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。</p>
</li>
<li><p>块作用域（block scope）指的是由大括号（<code>&#123;&#125;</code>）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。</p>
<blockquote>
<p>内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。(即：就近原则)</p>
</blockquote>
</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符<code>/</code>用来完成除法。注意，两个整数相除，得到还是一个整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x = <span class="number">6</span> / <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x); <span class="comment">// 输出 1.000000</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，尽管变量<code>x</code>的类型是<code>float</code>（浮点数），但是<code>6 / 4</code>得到的结果是<code>1.0</code>，而不是<code>1.5</code>。原因就在于 C 语言里面的整数除法是整除，只会返回整数部分，丢弃小数部分。</p>
<p>如果希望得到浮点数的结果，两个运算数必须至少有一个浮点数，这时 C 语言就会进行浮点数除法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x = <span class="number">6.0</span> / <span class="number">4</span>; <span class="comment">// 或者写成 6 / 4.0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x); <span class="comment">// 输出 1.500000</span></span><br></pre></td></tr></table></figure>



<p>负数求模的规则是，结果的正负号由第一个运算数的正负号决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> % <span class="number">-5</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">-11</span> % <span class="number">-5</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">-11</span> % <span class="number">5</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>++var</code>和<code>--var</code>是先执行自增或自减操作，再返回操作后<code>var</code>的值；</li>
<li><code>var++</code>和<code>var--</code>则是先返回操作前<code>var</code>的值，再执行自增或自减操作。</li>
</ul>
<h4 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h4><p><code>sizeof</code>运算符返回某种数据类型或某个值<strong>占用的字节数量</strong>。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为数据类型</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为变量</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">sizeof</span>(i); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为数值</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="number">3.14</span>); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面例子的执行结果，可能会出人意料。</span></span><br><span class="line"><span class="comment">// sizeof(int)是size_t类型，这是一个无符号整数。按照规则，signed int 自动转为 unsigned int，所以a会自动转成无符号整数4294967291（转换规则是-5加上无符号整数的最大值，再加1），导致比较失败</span></span><br><span class="line"><span class="comment">// 所以，最好避免无符号整数与有符号整数的混合运算。因为这时 C 语言会自动将signed int转为unsigned int，可能不会得到预期的结果。</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">-5</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>)）</span><br></pre></td></tr></table></figure>



<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/images/image-20211025190158650.png" alt="image-20211025190158650"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个字符 </span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">66</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用signed关键字，表示一个类型带有正负号，包含负值；</span></span><br><span class="line"><span class="comment">// 使用unsigned关键字，表示该类型不带有正负号，只能表示零和正整数。</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int类型也可以不带正负号，只表示非负整数。这时就必须使用关键字unsigned声明变量。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c; <span class="comment">// 范围为 -128 到 127</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c; <span class="comment">// 范围为 0 到 255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数的子类型</span></span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="comment">// C 语言允许省略int</span></span><br><span class="line"><span class="keyword">short</span> a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数的进制</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x1A2B</span>; <span class="comment">// 十六进制，相当于十进制的6699</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float</span></span><br><span class="line"><span class="keyword">float</span> c = <span class="number">10.5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> d = <span class="number">10.3</span></span><br><span class="line"><span class="keyword">double</span> x = <span class="number">123.456e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔类型</span></span><br><span class="line"><span class="comment">// C 语言原来并没有为布尔值单独设置一个类型，而是使用整数0表示伪，所有非零值表示真。</span></span><br><span class="line"><span class="comment">// C99 标准添加了类型_Bool，表示布尔值。但是，这个类型其实只是整数类型的别名，还是使用0表示伪，1表示真</span></span><br><span class="line"><span class="built_in">_Bool</span> isNormal;</span><br><span class="line">isNormal = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (isNormal)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Everything is OK.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件stdbool.h定义了另一个类型别名bool，并且定义了true代表1、false代表0。只要加载这个头文件，就可以使用这几个关键字。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般情况下，十进制整数字面量（比如123）会被编译器指定为int类型。如果一个数值比较大，超出了int能够表示的范围，编译器会将其指定为long int。如果数值超过了long int，会被指定为unsigned long。如果还不够大，就指定为long long或unsigned long long。</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量后缀</span></span><br><span class="line"><span class="comment">// 将其指定为long类型，这时可以为该字面量加上后缀l或L，</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">123L</span>;</span><br><span class="line"><span class="comment">// 指定为无符号整数unsigned int</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">123U</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> x = <span class="number">255</span>; </span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 当i等于0，再减去1的时候，并不会返回-1，而是返回 unsigned int 的类型最大值，这个值总是大于等于0，导致无限循环。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i) <span class="comment">// 错误</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 为了避免溢出，最好方法就是将运算结果与类型的极限值进行比较。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sum;</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (sum + ui &gt; UINT_MAX) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">if</span> (ui &gt; UINT_MAX - sum) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br><span class="line"><span class="comment">// 上面示例中，变量sum和ui都是 unsigned int 类型，它们相加的和还是 unsigned int 类型，这就有可能发生溢出。但是，不能通过相加的和是否超出了最大值UINT_MAX，来判断是否发生了溢出，因为sum + ui总是返回溢出后的结果，不可能大于UINT_MAX。正确的比较方法是，判断UINT_MAX - sum与ui之间的大小关系。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算</span></span><br><span class="line"><span class="comment">// 浮点数赋予整数变量时，C 语言直接丢弃小数部分，而不是四舍五入。</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// 窄类型赋值给宽类型,char或short类型赋值给int类型，会自动提升为int</span></span><br><span class="line"><span class="keyword">char</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = x + y;</span><br><span class="line"><span class="comment">// 宽类型赋值给窄类型</span></span><br><span class="line"><span class="comment">// 字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值（truncation），系统会自动截去多余的二进制位，导致难以预料的结果。</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">321</span>;</span><br><span class="line"><span class="keyword">char</span> ch = i; <span class="comment">// ch 的值是 65 （321 - 256）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="comment">// 下面示例中，参数变量m和n不管原来的类型是什么，都会转成函数dostuff()定义的参数类型。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dostuff</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> m = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> n = <span class="number">43</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c = dostuff(m, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型的显式转换</span></span><br><span class="line"><span class="comment">// (long int)将10显式转为long int类型。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> y = (<span class="keyword">long</span> <span class="keyword">int</span>) <span class="number">10</span> + <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可移植类型</span></span><br><span class="line"><span class="comment">// C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。</span></span><br><span class="line"><span class="comment">// 精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。</span></span><br><span class="line"><span class="comment">// int8_t：8位有符号整数。</span></span><br><span class="line"><span class="comment">// int16_t：16位有符号整数。</span></span><br><span class="line"><span class="comment">// int32_t：32位有符号整数。</span></span><br><span class="line"><span class="comment">// int64_t：64位有符号整数。</span></span><br><span class="line"><span class="comment">// uint8_t：8位无符号整数。</span></span><br><span class="line"><span class="comment">// uint16_t：16位无符号整数。</span></span><br><span class="line"><span class="comment">// uint32_t：32位无符号整数。</span></span><br><span class="line"><span class="comment">// uint64_t：64位无符号整数。</span></span><br><span class="line"><span class="keyword">int32_t</span> x32 = <span class="number">45933945</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x32 = %d\n&quot;</span>, x32);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小宽度类型（minimum width type），保证某个整数类型的最小长度。</span></span><br><span class="line"><span class="comment">// 可以保证占据的字节不少于指定宽度。比如，int_least8_t表示可以容纳8位有符号整数的最小宽度的类型。</span></span><br><span class="line"><span class="keyword">int_least8_t</span></span><br><span class="line"><span class="keyword">int_least16_t</span></span><br><span class="line"><span class="keyword">int_least32_t</span></span><br><span class="line"><span class="keyword">int_least64_t</span></span><br><span class="line"><span class="keyword">uint_least8_t</span></span><br><span class="line"><span class="keyword">uint_least16_t</span></span><br><span class="line"><span class="keyword">uint_least32_t</span></span><br><span class="line"><span class="keyword">uint_least64_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">int</span>* intPtr;</span><br><span class="line"><span class="comment">// 星号*可以放在变量名与类型关键字之间的任何地方，下面的写法都是有效的。</span></span><br><span class="line"><span class="keyword">int</span>   *intPtr;</span><br><span class="line"><span class="keyword">int</span> * intPtr;</span><br><span class="line"><span class="keyword">int</span>*  intPtr;</span><br><span class="line"><span class="comment">// 指针指向的可能还是指针，这时就要用两个星号**表示。</span></span><br><span class="line"><span class="keyword">int</span>** foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *号取出指针变量所指向的内存地址里面的值。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">  *p = *p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">increment(&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h3 id="指针的初始化"><a href="#指针的初始化" class="headerlink" title="指针的初始化"></a>指针的初始化</h3><p>声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，也就是说，指针变量指向的值是随机的。这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是错的，因为<code>p</code>指向的那个地址是随机的，向这个随机地址里面写入<code>1</code>，会导致意想不到的结果。</p>
<p>正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">p = &amp;i;</span><br><span class="line">*p = <span class="number">13</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>p</code>是指针变量，声明这个变量后，<code>p</code>会指向一个随机的内存地址。这时要将它指向一个已经分配好的内存地址，上例就是再声明一个整数变量<code>i</code>，编译器会为<code>i</code>分配内存地址，然后让<code>p</code>指向<code>i</code>的内存地址（<code>p = &amp;i;</code>）。完成初始化之后，就可以对<code>p</code>指向的内存地址进行赋值了（<code>*p = 13;</code>）。</p>
<p>为了防止读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为<code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><code>NULL</code>在 C 语言中是一个常量，表示地址为<code>0</code>的内存空间，这个地址是无法使用的，读写该地址会报错。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>指针本质上就是一个无符号整数，代表了内存地址。它可以进行运算，但是规则并不是整数运算的运算。</p>
<h4 id="指针与整数值的加减运算表示内存地址的移动"><a href="#指针与整数值的加减运算表示内存地址的移动" class="headerlink" title="指针与整数值的加减运算表示内存地址的移动"></a>指针与整数值的加减运算表示内存地址的移动</h4><p>指针与整数值的运算，表示指针的移动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span>* j;</span><br><span class="line">j = (<span class="keyword">short</span>*)<span class="number">0x1234</span>;</span><br><span class="line">j = j + <span class="number">1</span>; <span class="comment">// 0x1236</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j</code>是一个指针，指向内存地址<code>0x1234</code>。你可能以为<code>j + 1</code>等于<code>0x1235</code>，但正确答案是<code>0x1236</code>。</p>
<p>原因是<code>j + 1</code>表示指针向高位移动一个单位，而一个单位的<code>short</code>类型占据两个字节的宽度，所以相当于向高位移动两个字节。同样的，<code>j - 1</code>得到的结果是<code>0x1232</code>。</p>
<p><strong>指针移动的单位，与指针指向的数据类型有关</strong>。数据类型占据多少个字节，每单位就移动多少个字节。</p>
<h4 id="指针与指针的加法运算是非法的"><a href="#指针与指针的加法运算是非法的" class="headerlink" title="指针与指针的加法运算是非法的"></a>指针与指针的加法运算是非法的</h4><p>指针只能与整数值进行加减运算，两个指针进行加法是非法的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>* j;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>* k;</span><br><span class="line">x = j + k; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>



<h4 id="指针与指针的减法返回指针之间的距离"><a href="#指针与指针的减法返回指针之间的距离" class="headerlink" title="指针与指针的减法返回指针之间的距离"></a>指针与指针的减法返回指针之间的距离</h4><p>相同类型的指针允许进行减法运算，<strong>返回它们之间的距离，即相隔多少个数据单位</strong>。高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。</p>
<p>这时，减法返回的值属于<code>ptrdiff_t</code>类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。这个类型的原型定义在头文件<code>stddef.h</code>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span>* j1;</span><br><span class="line"><span class="keyword">short</span>* j2;</span><br><span class="line"></span><br><span class="line">j1 = (<span class="keyword">short</span>*)<span class="number">0x1234</span>;</span><br><span class="line">j2 = (<span class="keyword">short</span>*)<span class="number">0x1236</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ptrdiff_t</span> dist = j2 - j1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j1</code>和<code>j2</code>是两个指向 short 类型的指针，变量<code>dist</code>是它们之间的距离，类型为<code>ptrdiff_t</code>，值为<code>1</code>，因为相差2个字节正好存放一个 short 类型的值。</p>
<h4 id="指针与指针的比较运算比的是哪个内存地址更大"><a href="#指针与指针的比较运算比的是哪个内存地址更大" class="headerlink" title="指针与指针的比较运算比的是哪个内存地址更大"></a>指针与指针的比较运算比的是哪个内存地址更大</h4><p>指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数<code>1</code>（true）或<code>0</code>（false）。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="c语言函数不允许嵌套"><a href="#c语言函数不允许嵌套" class="headerlink" title="c语言函数不允许嵌套"></a>c语言函数不允许嵌套</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus_one</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="main函数return-0"><a href="#main函数return-0" class="headerlink" title="main函数return 0;"></a>main函数return 0;</h3><p><code>main()</code>的写法与其他函数一样。</p>
<p>最后的<code>return 0;</code>表示函数结束运行，返回<code>0</code>。<code>main()</code>的默认返回值为0，所以此行可以不加。但是建议还是加上。</p>
<p>C 语言约定，返回值<code>0</code>表示函数运行成功，如果返回其他非零整数，就表示运行失败，代码出了问题。系统根据<code>main()</code>的返回值，作为整个程序的返回值，确定程序是否运行成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数不要返回内部变量的指针"><a href="#函数不要返回内部变量的指针" class="headerlink" title="函数不要返回内部变量的指针"></a>函数不要返回内部变量的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数返回内部变量<code>i</code>的指针，这种写法是错的。因为当函数结束运行时，内部变量就消失了，这时指向内部变量<code>i</code>的内存地址就是无效的，再去使用这个地址是非常危险的。</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p><strong>函数名是指向函数<code>二进制块</code>开头处的指针</strong>。C 语言允许通过指针获取函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*print_ptr)(<span class="keyword">int</span>) = &amp;print;</span><br><span class="line"></span><br><span class="line">(*print_ptr)(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">print(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>print_ptr</code>是一个函数指针，它指向函数<code>print()</code>的地址。函数<code>print()</code>的地址可以用<code>&amp;print</code>获得。注意，<code>(*print_ptr)</code>一定要写在圆括号里面，否则函数参数<code>(int)</code>的优先级高于<code>*</code>，整个式子就会变成<code>void* print_ptr(int)</code>。</p>
<p>有了函数指针，通过它也可以调用函数。</p>
<p>比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，<code>print</code>和<code>&amp;print</code>是一回事。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (print == &amp;print) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，上面代码的<code>print_ptr</code>等同于<code>print</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*print_ptr)(<span class="keyword">int</span>) = &amp;print;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">void</span> (*print_ptr)(<span class="keyword">int</span>) = print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (print_ptr == print) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p>所以，对于任意函数，都有五种调用函数的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">10</span>) <span class="comment">// 写法一</span></span><br><span class="line">(*print)(<span class="number">10</span>) <span class="comment">// 写法二</span></span><br><span class="line">(&amp;print)(<span class="number">10</span>) <span class="comment">// 写法三</span></span><br><span class="line">(*print_ptr)(<span class="number">10</span>) <span class="comment">// 写法四</span></span><br><span class="line">print_ptr(<span class="number">10</span>) <span class="comment">// 写法五</span></span><br></pre></td></tr></table></figure>

<p>为了简洁易读，一般情况下，函数名前面都不加<code>*</code>和<code>&amp;</code>。</p>
<p>这种特性的一个应用是，如果一个函数的参数或返回值，也是一个函数，那么函数原型可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> (*myfunc)(<span class="keyword">int</span>), <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面示例可以清晰地表明，函数<code>compute()</code>的第一个参数也是一个函数。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>函数必须先声明，后使用。由于程序总是先运行<code>main()</code>函数，导致所有其他函数都必须在<code>main()</code>函数之前声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  func1();</span><br><span class="line">  func2();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>main()</code>函数必须在最后声明，否则编译时会产生警告，找不到<code>func1()</code>或<code>func2()</code>的声明。</p>
<p>但是，<code>main()</code>是整个程序的入口，也是主要逻辑，放在最前面比较好。另一方面，对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。</p>
<p>C 语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以先使用、后声明。</p>
<blockquote>
<p>所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> twice(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>twice()</code>的实现是放在<code>main()</code>后面，但是代码头部先给出了函数原型，所以可以正确编译。只要提前给出函数原型，函数具体的实现放在哪里，就不重要了。</p>
<p>函数原型包括参数名也可以，虽然这样对于编译器是多余的，但是阅读代码的时候，可能有助于理解函数的意图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>一般来说，每个源码文件的头部，都会给出当前脚本使用的所有函数的原型。</strong></p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><blockquote>
<p>类似于golang里的panic</p>
</blockquote>
<p><code>exit()</code>函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件<code>stdlib.h</code>里面。</p>
<p><code>exit()</code>可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数，这两个常数也是定义在<code>stdlib.h</code>里面。：</p>
<ul>
<li><code>EXIT_SUCCESS</code>（相当于 0）表示程序运行成功，</li>
<li><code>EXIT_FAILURE</code>（相当于 1）表示程序异常中止。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序运行成功</span></span><br><span class="line"><span class="comment">// 等同于 exit(0);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序异常中止</span></span><br><span class="line"><span class="comment">// 等同于 exit(1);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure>

<p>在<code>main()</code>函数里面，<code>exit()</code>等价于使用<code>return</code>语句。其他函数使用<code>exit()</code>，就是终止整个程序的运行，没有其他作用。</p>
<p>C 语言还提供了一个<code>atexit()</code>函数，用来登记**<code>exit()</code>执行时额外执行的函数**，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>atexit()</code>的参数是一个函数指针。注意，此函数不能接受参数，也不能有返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;something wrong!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">atexit(print);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>exit()</code>执行时会先自动调用<code>atexit()</code>注册的<code>print()</code>函数，然后再终止程序。</p>
<h3 id="函数说明符"><a href="#函数说明符" class="headerlink" title="函数说明符"></a>函数说明符</h3><p>函数说明符：让函数用法更加明确。</p>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p>对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并<strong>用<code>extern</code>说明此变量/函数是在别处定义的，要在此处引用</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">char</span> arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>foo()</code>定义在其他文件，<code>extern</code>告诉编译器当前文件不包含该函数的定义。</p>
<p>不过，由于函数原型默认就是<code>extern</code>，所以这里不加<code>extern</code>，效果是一样的。</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。<code>static</code>说明符可以改变这种行为。</p>
<p><strong><code>static</code>用于函数内部声明变量时，表示该变量只需要初始化一次</strong>，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;  <span class="comment">// 只初始化一次</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  counter();  <span class="comment">// 1</span></span><br><span class="line">  counter();  <span class="comment">// 2</span></span><br><span class="line">  counter();  <span class="comment">// 3</span></span><br><span class="line">  counter();  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>counter()</code>的内部变量<code>count</code>，使用<code>static</code>说明符修饰，表明这个变量只初始化一次，以后每次调用时都会使用上一次的值，造成递增的效果。</p>
<p>注意，<code>static</code>修饰的变量初始化时，<strong>只能赋值为常量，不能赋值为变量。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j = i; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j</code>属于静态变量，初始化时不能赋值为另一个变量<code>i</code>。</p>
<p>另外，在块作用域中，<code>static</code>声明的变量有默认值<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> foo;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p><code>static</code>可以用来修饰函数本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Twice</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = num * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，**<code>static</code>关键字表示该函数只能在当前文件里使用**，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）。</p>
<p><code>static</code>也可以用在参数里面，修饰参数数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">static</span> <span class="number">3</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，**<code>static</code>对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3**，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，<code>static</code>仅可用于第一维的说明。</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p><strong>函数参数里面的<code>const</code>说明符，表示函数内部不得修改该参数变量</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>的参数是一个指针<code>p</code>，函数内部可能会改掉它所指向的值<code>*p</code>，从而影响到函数外部。</p>
<p>为了避免这种情况，可以在声明函数时，在指针参数前面加上<code>const</code>说明符，告诉编译器，函数内部不能修改该参数所指向的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">  *p = <span class="number">0</span>; <span class="comment">// 该行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，声明函数时，<code>const</code>指定不能修改指针<code>p</code>指向的值，所以<code>*p = 0</code>就会报错。</p>
<p>但是上面这种写法，只限制修改<code>p</code>所指向的值，而<code>p</code>本身的地址是可以修改的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">13</span>;</span><br><span class="line">  p = &amp;x; <span class="comment">// 允许修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>p</code>本身是可以修改，<code>const</code>只限定<code>*p</code>不能修改。</p>
<p>如果想限制修改<code>p</code>，可以把<code>const</code>放在<code>p</code>前面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">const</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">13</span>;</span><br><span class="line">  p = &amp;x; <span class="comment">// 该行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想同时限制修改<code>p</code>和<code>*p</code>，需要使用两个<code>const</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号<code>...</code>表示可变数量的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>



<p>头文件<code>stdarg.h</code>定义了一些宏，可以操作可变参数。</p>
<p>（1）<code>va_list</code>：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。</p>
<p>（2）<code>va_start</code>：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。</p>
<p>（3）<code>va_arg</code>：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。</p>
<p>（4）<code>va_end</code>：一个函数，用来清理可变参数对象。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> i, ...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">    total += va_arg(ap, <span class="keyword">double</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> total / i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，</p>
<ul>
<li><code>va_list ap</code>定义<code>ap</code>为可变参数对象，</li>
<li><code>va_start(ap, i)</code>将参数<code>i</code>后面的参数统一放入<code>ap</code>，</li>
<li><code>va_arg(ap, double)</code>用来从<code>ap</code>依次取出一个参数，并且指定该参数为 double 类型，</li>
<li><code>va_end(ap)</code>用来清理可变参数对象。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">int</span> scores[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">scores[<span class="number">0</span>] = <span class="number">13</span>;</span><br><span class="line">scores[<span class="number">99</span>] = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组scores只有100个成员，因此scores[100]这个位置是不存在的。但是，引用这个位置并不会报错，会正常运行，使得紧跟在scores后面的那块内存区域被赋值，而那实际上是其他变量的区域，因此不知不觉就更改了其他变量的值。</span></span><br><span class="line">scores[<span class="number">100</span>] = <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>] = &#123;[<span class="number">2</span>] = <span class="number">29</span>, [<span class="number">9</span>] = <span class="number">7</span>, [<span class="number">14</span>] = <span class="number">48</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>] = &#123;<span class="number">1</span>, [<span class="number">5</span>] = <span class="number">10</span>, <span class="number">11</span>, [<span class="number">10</span>] = <span class="number">20</span>, <span class="number">21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。</span></span><br><span class="line"><span class="comment">// 报错的原因是，C 语言规定，数组变量一旦声明，就不得修改变量指向的地址。</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">a = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof运算符会返回整个数组的字节长度</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arrLen = <span class="keyword">sizeof</span>(a); <span class="comment">// 12</span></span><br><span class="line"><span class="comment">// 获取可以如下获取数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>])</span><br><span class="line">  </span><br><span class="line"><span class="comment">// sizeof返回值的数据类型是size_t，所以sizeof(a) / sizeof(a[0])的数据类型也是size_t。</span></span><br><span class="line"><span class="comment">// 在printf()里面的占位符，要用%zd或%zu。</span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">12</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(x));     <span class="comment">// 48</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(x) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多维数组</span></span><br><span class="line"><span class="keyword">int</span> board[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">  &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, [<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管数组有多少维度，在内存里面都是线性存储，a[0][0]的后面是a[0][1]，a[0][1]的后面是a[1][0]，以此类推。</span></span><br><span class="line"><span class="comment">// 因此，多维数组也可以使用单层大括号赋值，下面的语句是上面的赋值语句是完全等同的。</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变长数组</span></span><br><span class="line"><span class="comment">// 数组arr就是变长数组，因为它的长度取决于变量n的值，编译器没法事先确定，只有运行时才能知道n是多少。</span></span><br><span class="line"><span class="keyword">int</span> n = x + y;</span><br><span class="line"><span class="keyword">int</span> arr[n];</span><br></pre></td></tr></table></figure>



<h3 id="数组的地址"><a href="#数组的地址" class="headerlink" title="数组的地址"></a>数组的地址</h3><p>数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="comment">// &amp;a[0]就是数组a的首个成员11的内存地址，也是整个数组的起始地址。</span></span><br><span class="line"><span class="comment">// 反过来，从这个地址（*p），可以获得首个成员的值11。</span></span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);  <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>由于数组的起始地址是常用操作，<code>&amp;array[0]</code>的写法有点麻烦，C 语言提供了便利写法，<strong>数组名等同于起始地址</strong>，也就是说，数组名就是指向第一个成员（<code>array[0]</code>）的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span>* p = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 取出 a[0][0] 的值</span></span><br><span class="line">*(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">**a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以，函数接受数组作为参数，函数原型可以写成下面这样。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>; <span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>; <span class="comment">// 写法二</span></span><br></pre></td></tr></table></figure>



<p>数组名指向的地址是不能更改的。</p>
<p>声明数组时，编译器自动为数组分配了内存地址，这个地址与数组名是绑定的，不可更改，下面的代码会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ints[<span class="number">100</span>];</span><br><span class="line">ints = <span class="literal">NULL</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<p>重新为数组名赋值，改变原来的内存地址，就会报错。这也导致不能将一个数组名赋值给另外一个数组名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>] = a; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>];</span><br><span class="line">b = a; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<h3 id="数组指针的加减法"><a href="#数组指针的加减法" class="headerlink" title="数组指针的加减法"></a>数组指针的加减法</h3><p>从一个成员的内存地址移动到另一个成员的内存地址。</p>
<blockquote>
<p>比如，<code>a + 1</code>返回下一个成员的地址，<code>a - 1</code>返回上一个成员的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">arr + <span class="number">1</span>; <span class="comment">// 指针指向 arr[1]</span></span><br><span class="line">arr[<span class="number">0</span>] + <span class="number">1</span> <span class="comment">// 指针指向 arr[0][1]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，内部逻辑其实是<strong>通过指针的移动遍历数组</strong>，<code>a + i</code>的每轮循环每次都会指向下一个成员的地址，<code>*(a + i)</code>取出该地址的值，等同于<code>a[i]</code>。对于数组的第一个成员，<code>*(a + 0)</code>（即<code>*a</code>）等同于<code>a[0]</code>。</p>
<p>由于数组名与指针是等价的，所以下面的等式总是成立。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b] == *(a + b)</span><br></pre></td></tr></table></figure>



<p>还有一种遍历数组的方式：如果指针变量<code>p</code>指向数组的一个成员，那么<code>p++</code>就相当于指向下一个成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">999</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组名指向的地址是不能变的，所以上例中，不能直接对a进行自增，即a++的写法是错的，必须将a的地址赋值给指针变量p，然后对p进行自增。</span></span><br><span class="line"><span class="keyword">while</span> (*p != <span class="number">999</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">  p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同一个数组的两个成员的指针相减时，返回它们之间的距离。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = &amp;a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>* q = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p - q); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q - p); <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>



<h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><p>由于数组名是指针，所以复制数组不能简单地复制数组名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int* a;</span><br><span class="line">int b[3] = &#123;1, 2, 3&#125;;</span><br><span class="line"></span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure>

<p>上面的写法，结果不是将数组<code>b</code>复制给数组<code>a</code>，而是让<code>a</code>和<code>b</code>指向同一个数组。</p>
<p>复制数组最简单的方法，还是使用循环，将数组元素逐个进行复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  a[i] = b[i];</span><br></pre></td></tr></table></figure>

<p>上面示例中，通过将数组<code>b</code>的成员逐个复制给数组<code>a</code>，从而实现数组的赋值。</p>
<p>另一种方法是使用<code>memcpy()</code>函数（定义在头文件<code>string.h</code>），直接把数组所在的那一段内存，再复制一份。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(a, b, <span class="keyword">sizeof</span>(b));</span><br></pre></td></tr></table></figure>

<p>上面示例中，将数组<code>b</code>所在的那段内存，复制给数组<code>a</code>。这种方法要比循环复制数组成员要快。</p>
<h3 id="数组作为函数参数一般要传递长度"><a href="#数组作为函数参数一般要传递长度" class="headerlink" title="数组作为函数参数一般要传递长度"></a>数组作为函数参数一般要传递长度</h3><p>数组作为函数的参数，一般会同时传入数组名和数组长度。由于数组名就是一个指针，如果只传数组名，那么函数只知道数组开始的地址，不知道结束的地址，所以才需要把数组长度也一起传入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是数组本身，也就是数组名，第二个参数是数组长度。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sum_array(a, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>



<p>如果函数的参数是多维数组，那么每一维的长度都要当作参数传入函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">4</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sum_array(a, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<p>变长数组作为参数 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a[n])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sum_array(<span class="number">4</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变长数组的写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> a[n][m])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为函数原型可以省略参数名，所以变长数组的原型中，可以使用*代替变量名，也可以省略变量名。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span> [*])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span> [])</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>a[n]</code>是一个变长数组，它的长度取决于变量<code>n</code>的值，只有运行时才能知道。所以，变量<code>n</code>作为参数时，顺序一定<strong>要在变长数组前面，这样运行时才能确定数组<code>a[n]</code>的长度，否则就会报错</strong>。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>C 语言没有单独的字符串类型，字符串被当作字符数组，即<code>char</code>类型的数组。</li>
<li>比如，字符串“Hello”是当作数组<code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;&#125;</code>处理的。<strong>编译器会给数组分配一段连续内存，所有字符储存在相邻的内存单元之中</strong>。</li>
<li>在字符串结尾，C 语言会自动添加一个全是二进制<code>0</code>的字节，写作<code>\0</code>字符，表示字符串结束。字符<code>\0</code>不同于字符<code>0</code>。所以，字符串“Hello”实际储存的数组是<code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;</code>。</li>
<li>所有字符串的最后一个字符，都是<code>\0</code>。这样做的好处是，C 语言不需要知道字符串的长度，就可以读取内存里面的字符串，只要发现有一个字符是<code>\0</code>，那么就知道字符串结束了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于必须留一个位置给\0，所以最多只能容纳9个字符的字符串。</span></span><br><span class="line"><span class="keyword">char</span> localString[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双引号里面的字符串，不用自己添加结尾字符\0</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span> <span class="comment">// 等价于&#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使双引号里面只有一个字符，也依然被处理成字符串（存储为2个字节），而不是字符&#x27;a&#x27;（存储为1个字节）。</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 允许合并多个字符串字面量，只要这些字符串之间没有间隔，或者只有空格，C 语言会将它们自动合并。</span></span><br><span class="line"><span class="keyword">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, &quot;</span><span class="string">&quot;how are you &quot;</span><span class="string">&quot;today!&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, how are you today!&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="字符串变量的声明"><a href="#字符串变量的声明" class="headerlink" title="字符串变量的声明"></a>字符串变量的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">14</span>] = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 字符串变量声明成一个字符数组</span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 声明成一个指针，指向字符数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 编译器自动计算长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组的长度，可以大于字符串的实际长度。</span></span><br><span class="line"><span class="comment">// 后面空出来的44个位置，都会被初始化为\0。</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组的长度，不能小于字符串的实际长度。</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="使用字符数组和字符指针声明的区别"><a href="#使用字符数组和字符指针声明的区别" class="headerlink" title="使用字符数组和字符指针声明的区别"></a>使用字符数组和字符指针声明的区别</h3><p>第一个差异是，<strong>指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身</strong>。如果使用数组声明字符串变量，就没有这个问题，可以修改数组的任意成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>为什么字符串声明为指针时不能修改，声明为数组时就可以修改？原因是系统会<strong>将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的</strong>。</p>
<ul>
<li>声明为指针时，指针变量存储的只是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。</li>
<li>但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。</li>
</ul>
<p>为了提醒用户，字符串声明为指针后不得修改，可以在声明时使用<code>const</code>说明符，保证该字符串是只读的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面字符串声明为指针时，使用了<code>const</code>说明符，就保证了该字符串无法修改。一旦修改，编译器肯定会报错。</p>
<p>第二个差异是，指针变量可以指向其它字符串。但是，字符数组变量不能指向另一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组的数组名，总是指向初始化时的字符串地址，不能修改。</span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的原因，声明字符数组后，不能直接用字符串赋值。</span></span><br><span class="line"><span class="comment">// 原因是字符数组的变量名，跟所指向的数组是绑定的，不能指向另一个地址。</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>为什么数组变量不能赋值为另一个数组？原因是<strong>数组变量所在的地址无法改变</strong>，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C 语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。</p>
<p>想要重新赋值，必须使用 C 语言原生提供的<code>strcpy()</code>函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即<code>strcpy()</code>只是在原地址写入新的字符串，而不是让数组变量指向新的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>如果一个数组的每个成员都是一个字符串，需要通过二维的字符数组实现。每个字符串本身是一个字符数组，多个字符串再组成一个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> weekdays[<span class="number">7</span>][<span class="number">10</span>] = &#123;</span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例就是一个字符串数组，一共包含7个字符串，所以第一维的长度是7。其中，最长的字符串的长度是10（含结尾的终止符<code>\0</code>），所以第二维的长度统一设为10。</p>
<p>因为第一维的长度，编译器可以自动计算，所以可以省略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> weekdays[][<span class="number">10</span>] = &#123;</span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，二维数组第一维的长度，可以由编译器根据后面的赋值，自动计算，所以可以不写。</p>
<p>数组的第二维，长度统一定为10，有点浪费空间，因为大多数成员的长度都小于10。解决方法就是<strong>把数组的第二维，从字符数组改成字符指针</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* weekdays[] = &#123;</span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的字符串数组，其实是一个一维数组，成员就是7个字符指针，每个指针指向一个字符串（字符数组）。</p>
<p>遍历字符串数组的写法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, weekdays[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h3><p>strlen()<code>函数返回字符串的字节长度，不包括末尾的空字符\0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The string is %zd characters long.\n&quot;</span>, <span class="built_in">strlen</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意，字符串长度（<code>strlen()</code>）与字符串变量长度（<code>sizeof()</code>），是两个不同的概念。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(s));  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(s));  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>



<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h3><p><code>strcpy()</code>函数，用于将一个字符串的内容复制到另一个字符串，相当于字符串赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">char</span> dest[], <span class="keyword">const</span> <span class="keyword">char</span> source[])</span><br></pre></td></tr></table></figure>



<p>字符串的复制，不能使用赋值运算符，直接将一个字符串赋值给字符数组变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为数组的变量名是一个固定的地址，不能修改，使其指向另一个地址。</span></span><br><span class="line">str1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line">str2 = str1;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果是字符指针，赋值运算符（<code>=</code>）只是将一个指针的地址复制给另一个指针，而不是复制字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s1;</span><br><span class="line"><span class="keyword">char</span>* s2;</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s2 = s1;</span><br></pre></td></tr></table></figure>



<p><code>strcpy()</code>接受两个参数，第一个参数是目的字符串数组，第二个参数是源字符串数组。</p>
<p>复制字符串之前，必须要保证第一个参数的长度不小于第二个参数，否则虽然不会报错，但会溢出第一个字符串变量的边界，发生难以预料的结果。第二个参数的<code>const</code>说明符，表示这个函数不会修改第二个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span> t[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(t, s);</span><br><span class="line"></span><br><span class="line">  t[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);  <span class="comment">// &quot;Hello, world!&quot;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);  <span class="comment">// &quot;zello, world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>strcpy()</code>也可以用于字符数组的赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将字符数组变量，赋值为字符串“abcd”。</p>
<p><code>strcpy()</code>的返回值是一个字符串指针（即<code>char*</code>），指向第一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s1 = <span class="string">&quot;beast&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">40</span>] = <span class="string">&quot;Be the best that you can be.&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* ps;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从s2的第7个位置开始拷贝字符串beast，前面的位置不变。这导致s2后面的内容都被截去了，因为会连beast结尾的空字符一起拷贝。strcpy()返回的是一个指针，指向拷贝开始的位置。</span></span><br><span class="line">ps = <span class="built_in">strcpy</span>(s2 + <span class="number">7</span>, s1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(s2); <span class="comment">// Be the beast</span></span><br><span class="line"><span class="built_in">puts</span>(ps); <span class="comment">// beast</span></span><br></pre></td></tr></table></figure>



<p><code>strcpy()</code>函数有安全风险，因为它并不检查目标字符串的长度，是否足够容纳源字符串的副本，可能导致写入溢出。如果不能保证不会发生溢出，建议使用<code>strncpy()</code>函数代替。</p>
<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy()"></a>strncpy()</h3><p><code>strncpy()</code>跟<code>strcpy()</code>的用法完全一样，只是多了第3个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">char</span> *dest, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">char</span> *src, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> n</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第三个参数<code>n</code>定义了复制的最大字符数。如果达到最大字符数以后，源字符串仍然没有复制完，就会停止复制，这时目的字符串结尾将没有终止符<code>\0</code>，这一点务必注意。如果源字符串的字符数小于<code>n</code>，则<code>strncpy()</code>的行为与<code>strcpy()</code>完全一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(str1, str2, <span class="keyword">sizeof</span>(str1) - <span class="number">1</span>);</span><br><span class="line">str1[<span class="keyword">sizeof</span>(str1) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串<code>str2</code>复制给<code>str1</code>，但是复制长度最多为<code>str1</code>的长度减去1，<code>str1</code>剩下的最后一位用于写入字符串的结尾标志<code>\0</code>。这是因为<code>strncpy()</code>不会自己添加<code>\0</code>，如果复制的字符串片段不包含结尾标志，就需要手动添加。</p>
<p><code>strncpy()</code>也可以用来拷贝部分字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(s1, s2, <span class="number">5</span>);</span><br><span class="line">s1[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，指定只拷贝前5个字符。</p>
<h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h3><p><code>strcat()</code>函数用于连接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。这个函数会改变第一个字符串，但是第二个字符串不变。</p>
<p>该函数的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* s1, <span class="keyword">const</span> <span class="keyword">char</span>* s2)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>strcat()</code>的返回值是一个字符串指针，指向第一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">12</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">6</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);</span><br><span class="line"><span class="built_in">puts</span>(s1); <span class="comment">// &quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，调用<code>strcat()</code>以后，可以看到字符串<code>s1</code>的值变了。</p>
<p>注意，<code>strcat()</code>的第一个参数的长度，必须足以容纳添加第二个参数字符串。否则，拼接后的字符串会溢出第一个字符串的边界，写入相邻的内存单元，这是很危险的，建议使用下面的<code>strncat()</code>代替。</p>
<h3 id="strncat"><a href="#strncat" class="headerlink" title="strncat()"></a>strncat()</h3><p><code>strncat()</code>用于连接两个字符串，用法与<code>strncat()</code>完全一致，只是增加了第三个参数，指定最大添加的字符数。在添加过程中，一旦达到指定的字符数，或者在源字符串中遇到空字符<code>\0</code>，就不再添加了。它的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">char</span>* dest,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">char</span>* src,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> n</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>strncat()</code>返回第一个参数，即目标字符串指针。</p>
<p>为了保证连接后的字符串，不超过目标字符串的长度，<code>strncat()</code>通常会写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncat</span>(</span><br><span class="line">  str1, </span><br><span class="line">  str2, </span><br><span class="line">  <span class="keyword">sizeof</span>(str1) - <span class="built_in">strlen</span>(str1) - <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>strncat()</code>总是会在拼接结果的结尾，自动添加空字符<code>\0</code>，所以第三个参数的最大值，应该是<code>str1</code>的变量长度减去<code>str1</code>的字符串长度，再减去<code>1</code>。下面是一个用法实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">8</span>] = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncat</span>(s1, s2, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">puts</span>(s1); <span class="comment">// &quot;MondayTue&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>s1</code>的变量长度是10，字符长度是6，两者相减后再减去1，得到<code>3</code>，表明<code>s1</code>最多可以再添加三个字符，所以得到的结果是<code>MondayTue</code>。</p>
<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p>如果要比较两个字符串，无法直接比较，只能一个个字符进行比较，C 语言提供了<code>strcmp()</code>函数。</p>
<p><code>strcmp()</code>函数用于比较两个字符串的内容。该函数的原型如下，定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s1, <span class="keyword">const</span> <span class="keyword">char</span>* s2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>按照字典顺序，如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 = Happy New Year</span></span><br><span class="line"><span class="comment">// s2 = Happy New Year</span></span><br><span class="line"><span class="comment">// s3 = Happy Holidays</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s3) <span class="comment">// 大于 0</span></span><br><span class="line"><span class="built_in">strcmp</span>(s3, s1) <span class="comment">// 小于 0</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>strcmp()</code>只用来比较字符串，不用来比较字符。因为字符就是小整数，直接用相等运算符（<code>==</code>）就能比较。所以，不要把字符类型（<code>char</code>）的值，放入<code>strcmp()</code>当作参数。</p>
<h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp()"></a>strncmp()</h3><p>由于<code>strcmp()</code>比较的是整个字符串，C 语言又提供了<code>strncmp()</code>函数，只比较到指定的位置。</p>
<p>该函数增加了第三个参数，指定了比较的字符数。它的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">char</span>* s1,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">char</span>* s2, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> n</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它的返回值与<code>strcmp()</code>一样。如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">12</span>] = <span class="string">&quot;hello C&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;They all have hello.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例只比较两个字符串的前5个字符。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。</p>
<ul>
<li>系统管理的内存，主要是<strong>函数内部的变量（局部变量）</strong>。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。</li>
<li>用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（<strong>全局变量</strong>），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。</li>
</ul>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void 指针"></a>void 指针</h3><ul>
<li>指针变量必须有类型，否则编译器无法知道，如何解读内存块保存的二进制数据。</li>
<li>但是，向系统请求内存的时候，有时不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。</li>
</ul>
<p>为了满足这种需求，C 语言提供了一种不定类型的指针，叫做 void 指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。</p>
<p>另一方面，void 指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。<strong>void 指针与其他所有类型指针之间是互相转换关系，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p = &amp;x; <span class="comment">// 整数指针转为 void 指针</span></span><br><span class="line"><span class="keyword">int</span>* q = p; <span class="comment">// void 指针转为整数指针</span></span><br></pre></td></tr></table></figure>

<p>上面示例演示了整数指针和 void 指针如何互相转换。<code>&amp;x</code>是一个整数指针，<code>p</code>是 void 指针，赋值时<code>&amp;x</code>的地址会自动解释为 void 类型。同样的，<code>p</code>再赋值给整数指针<code>q</code>时，<code>p</code>的地址会自动解释为整数指针。</p>
<blockquote>
<p>注意，由于不知道 void 指针指向什么类型的值，所以不能用<code>*</code>运算符取出它指向的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span>* p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针，只给出内存块的地址信息。</p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p><code>malloc()</code>函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。</p>
<p>它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个 void 指针，指向分配好的内存块。这是非常合理的，因为`malloc()`函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// 可以使用`malloc()`为任意类型的数据分配内存，常见的做法是先使用`sizeof()`函数，算出某种数据类型所需的字节长度，然后再将这个长度传给`malloc()`。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* p </span>= <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*p = <span class="number">12</span>; <span class="comment">// 将整数`12`放入这段内存里面</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于`sizeof()`的参数可以是变量，所以上面的例子也可以写成下面这样。</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有时候为了增加代码的可读性，可以对`malloc()`返回的指针进行一次强制类型转换。</span></span><br><span class="line"><span class="comment">// 将`malloc()`返回的 void 指针，强制转换成了整数指针。</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>



<p><code>malloc()</code>分配内存有可能分配失败，这时返回常量 NULL。Null 的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括<code>stdlib.h</code>等多个头文件里面都有定义，所以只要可以使用<code>malloc()</code>，就可以使用<code>NULL</code>。由于存在分配失败的可能，所以最好在使用<code>malloc()</code>之后检查一下，是否分配成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过判断返回的指针`p`是否为`NULL`，确定`malloc()`是否分配成功。</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">// 内存分配失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>malloc()</code>最常用的场合，就是为数组和自定义数据结构分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `p`是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组。</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  p[i] = i * <span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<p><code>malloc()</code>用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `malloc()`可以根据变量`n`的不同，动态为数组分配不同的大小。</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>



<p>注意，<code>malloc()</code>不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化，比如，字符串初始化可以使用<code>strcpy()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符指针`p`指向一段4个字节的内存</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// `strcpy()`将字符串“abc”拷贝放入这段内存，完成了这段内存的初始化。</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">p = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p><code>free()</code>用于释放<code>malloc()</code>函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。</p>
<p>该函数的原型定义在头文件<code>stdlib.h</code>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `free()`的参数是`malloc()`返回的内存地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* block)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* p </span>= (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*p = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用<code>free()</code>对该地址释放第二次。</p>
</blockquote>
<p>一个很常见的错误是，在函数内部分配了内存，但是函数调用结束时，没有使用<code>free()</code>释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gobble</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span>* temp = (<span class="keyword">double</span>*) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>gobble()</code>内部分配了内存，但是没有写<code>free(temp)</code>。这会造成函数运行结束后，占用的内存块依然保留，如果多次调用<code>gobble()</code>，就会留下多个内存块。并且，由于指针<code>temp</code>已经消失了，也无法访问这些内存块，再次使用。</p>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><p><code>calloc()</code>函数的作用与<code>malloc()</code>相似，也是分配内存块。</p>
<p>两者的区别主要有两点：</p>
<ul>
<li><code>calloc()</code>接受两个参数，第一个参数是某种数据类型的值的数量，第二个是该数据类型的单位字节长度。</li>
<li><code>calloc()</code>会将所分配的内存全部初始化为<code>0</code>。<code>malloc()</code>不会对内存进行初始化，如果想要初始化为<code>0</code>，还要额外调用<code>memset()</code>函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `calloc()`的返回值也是一个 void 指针。分配失败时，返回 NULL。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `calloc()`相当于`malloc() + memset()`。</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><code>calloc()</code>分配的内存块，也要使用<code>free()</code>释放。</p>
<h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc()"></a>realloc()</h3><p><code>realloc()</code>函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回 NULL。该函数的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `block`：已经分配好的内存块指针（由`malloc()`或`calloc()`或`realloc()`产生）。</span></span><br><span class="line"><span class="comment">// `size`：该内存块的新大小，单位为字节。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* block, <span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>

<p><code>realloc()</code>可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。</p>
<ul>
<li><code>realloc()</code>优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。</li>
<li>如果新内存块小于原来的大小，则丢弃超出的部分；</li>
<li>如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自动调用<code>memset()</code>）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* b;</span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>); <span class="comment">// 指针`b`原来指向10个成员的整数数组</span></span><br><span class="line">b = <span class="built_in">realloc</span>(b, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2000</span>); <span class="comment">// 使用`realloc()`调整为2000个成员的数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `realloc()`的第一个参数可以是 NULL，这时就相当于新建一个指针。</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="built_in">realloc</span>(<span class="literal">NULL</span>, <span class="number">3490</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="built_in">malloc</span>(<span class="number">3490</span>);</span><br></pre></td></tr></table></figure>



<p>如果<code>realloc()</code>的第二个参数是<code>0</code>，就会释放掉内存块。</p>
<p>由于有分配失败的可能，所以调用<code>realloc()</code>以后，最好检查一下它的返回值是否为 NULL。<strong>分配失败时，原有内存块中的数据不会发生改变</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>* new_p = <span class="built_in">realloc</span>(p, <span class="keyword">sizeof</span>(*p * <span class="number">40</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new_p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Error reallocing\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>realloc()</code>不会对内存块进行初始化。</p>
<h3 id="restrict-说明符"><a href="#restrict-说明符" class="headerlink" title="restrict 说明符"></a>restrict 说明符</h3><p>声明指针变量时，可以使用<code>restrict</code>说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为<code>受限指针</code>（restrict pointer）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">restrict</span> p;</span><br><span class="line"><span class="comment">// 当`p`指向`malloc()`函数返回的一块内存区域，就意味着，该区域只有通过`p`来访问，不存在其他访问方式。</span></span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个指针`q`与受限指针`p`指向同一块内存，现在该内存有`p`和`q`两种访问方式。这就违反了对编译器的承诺，后面通过`*q`对该内存区域赋值，会导致未定义行为。</span></span><br><span class="line"><span class="keyword">int</span>* q = p;</span><br><span class="line">*q = <span class="number">0</span>; <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure>



<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h3><p><code>memcpy()</code>用于将一块内存拷贝到另一块内存。该函数的原型定义在头文件<code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `dest`是目标地址，`source`是源地址，第三个参数`n`是要拷贝的字节数`n`。</span></span><br><span class="line"><span class="comment">// 如果要拷贝10个 double 类型的数组成员，`n`就等于`10 * sizeof(double)`，而不是`10`。</span></span><br><span class="line"><span class="comment">// `dest`和`source`两者都有 restrict 关键字，表示这两个内存块不应该有互相重叠的区域。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">void</span>* <span class="keyword">restrict</span> dest, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">void</span>* <span class="keyword">restrict</span> source, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> n</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>因为<code>memcpy()</code>只是将一段内存的值，复制到另一段内存，所以不需要知道内存里面的数据是什么类型。</p>
<p>下面是复制字符串的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[] = <span class="string">&quot;Goats!&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span> t[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串`s`所在的内存，被拷贝到字符数组`t`所在的内存。</span></span><br><span class="line">  <span class="built_in">memcpy</span>(t, s, <span class="keyword">sizeof</span>(s));  <span class="comment">// 拷贝7个字节，包括终止符</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);  <span class="comment">// &quot;Goats!&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>memcpy()</code>可以取代<code>strcpy()</code>进行字符串拷贝，而且是更好的方法，不仅更安全，速度也更快，它不检查字符串尾部的<code>\0</code>字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(s) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> *c = <span class="built_in">malloc</span>(len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c) &#123;</span><br><span class="line">  <span class="built_in">strcpy</span>(c, s);       <span class="comment">// strcpy() 的写法</span></span><br><span class="line">  <span class="built_in">memcpy</span>(c, s, len);  <span class="comment">// memcpy() 的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 void 指针，也可以自定义一个复制内存的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">my_memcpy</span><span class="params">(<span class="keyword">void</span>* dest, <span class="keyword">void</span>* src, <span class="keyword">int</span> byte_count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不管传入的`dest`和`src`是什么类型的指针，将它们重新定义成一字节的 Char 指针，这样就可以逐字节进行复制</span></span><br><span class="line">  <span class="keyword">char</span>* s = src;</span><br><span class="line">  <span class="keyword">char</span>* d = dest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (byte_count--) &#123;</span><br><span class="line">    <span class="comment">// 相当于先执行`*d = *s`（源字节的值复制给目标字节），然后各自移动到下一个字节。</span></span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="memmove"><a href="#memmove" class="headerlink" title="memmove()"></a>memmove()</h3><p><code>memmove()</code>函数用于将一段内存数据复制到另一段内存。</p>
<p>它跟<code>memcpy()</code>的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与<code>memcpy()</code>行为相同。</p>
<p>该函数的原型定义在头文件<code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `dest`是目标地址，`source`是源地址，`n`是要移动的字节数。</span></span><br><span class="line"><span class="comment">// `dest`和`source`两个内存区域可以有重叠。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memmove</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">void</span>* dest, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">void</span>* source, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> n</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组成员`a[1]`开始的99个成员，都向前移动一个位置。</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">memmove(&amp;a[<span class="number">0</span>], &amp;a[<span class="number">1</span>], <span class="number">99</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串`x`的5号位置开始的10个字节，就是“Sweet Home”，`memmove()`将其前移到0号位置，所以`x`就变成了“Sweet Home Home”。</span></span><br><span class="line"><span class="keyword">char</span> x[] = <span class="string">&quot;Home Sweet Home&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="keyword">char</span> *) memmove(x, &amp;x[<span class="number">5</span>], <span class="number">10</span>)); <span class="comment">// 输出 Sweet Home Home</span></span><br></pre></td></tr></table></figure>



<h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp()"></a>memcmp()</h3><p><code>memcmp()</code>函数用来比较两个内存区域。它的原型定义在<code>string.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前两个参数是用来比较的指针，第三个参数指定比较的字节数。</span></span><br><span class="line"><span class="comment">// 返回值是一个整数。两块内存区域的每个字节以字符形式解读，按照字典顺序进行比较，如果两者相同，返回`0`；如果`s1`大于`s2`，返回大于0的整数；如果`s1`小于`s2`，返回小于0的整数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">void</span>* s1,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">void</span>* s2,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> n</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于`s1`小于`s2`，所以`r`是一个小于0的整数，一般为-1。</span></span><br><span class="line"><span class="keyword">char</span>* s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* s2 = <span class="string">&quot;acd&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> r = <span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>); <span class="comment">// 小于 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `memcmp()`可以比较内部带有字符串终止符`\0`的内存区域。</span></span><br><span class="line"><span class="keyword">char</span> s1[] = &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s2[] = &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">3</span>) == <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">4</span>) == <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(s1, s2, <span class="number">7</span>) == <span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>C 语言没有其他语言的对象（object）和类（class）的概念，struct 结构很大程度上提供了对象和类的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `struct`语句结尾的分号不能省略，否则很容易产生错误。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> numerator;</span><br><span class="line">  <span class="keyword">int</span> denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明了一个`struct fraction`类型的变量`f1`，这时编译器就会为`f1`分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> <span class="title">f1</span>;</span></span><br><span class="line">f1.numerator = <span class="number">22</span>;</span><br><span class="line">f1.denominator = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* name;</span><br><span class="line">  <span class="keyword">float</span> price;</span><br><span class="line">  <span class="keyword">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为`0`。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">saturn</span> =</span> &#123;<span class="string">&quot;Saturn SL/2&quot;</span>, <span class="number">16000.99</span>, <span class="number">175</span>&#125;;</span><br><span class="line"><span class="comment">// 为每个值指定属性名。剩下的那些属性都会初始化为`0`。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">saturn</span> =</span> &#123;.speed=<span class="number">172</span>, .name=<span class="string">&quot;Saturn SL/2&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 修改某个属性的值。</span></span><br><span class="line">saturn.speed = <span class="number">168</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct 的数据类型声明语句与变量的声明语句，可以合并为一个语句。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125; b1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果类型标识符`book`只用在这一个地方，后面不再用到，这里可以将类型名省略。</span></span><br><span class="line"><span class="comment">// `struct`声明了一个匿名数据类型，然后又声明了这个类型的变量`b1`。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125; b1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在声明变量的同时，对变量赋值。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125; b1 = &#123;<span class="string">&quot;Harry Potter&quot;</span>, <span class="string">&quot;J. K. Rowling&quot;</span>, <span class="number">10.0</span>&#125;,</span><br><span class="line">  b2 = &#123;<span class="string">&quot;Cancer Ward&quot;</span>, <span class="string">&quot;Aleksandr Solzhenitsyn&quot;</span>, <span class="number">7.85</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `typedef`命令可以为 struct 结构指定一个别名，这样使用起来更简洁。</span></span><br><span class="line"><span class="comment">// `phone`就是`struct cell_phone`的别名。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cell_phone</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> cell_no;</span><br><span class="line">  <span class="keyword">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br><span class="line">phone p = &#123;<span class="number">5551234</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针变量也可以指向`struct`结构。</span></span><br><span class="line"><span class="comment">// 变量`b1`是一个指针，指向的数据是`struct book`类型的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125;* b1;</span><br><span class="line"><span class="comment">// 或者写成两个语句</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>* <span class="title">b1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct 结构也可以作为数组成员。</span></span><br><span class="line"><span class="comment">// 声明了一个有1000个成员的数组`numbers`，每个成员都是自定义类型`fraction`的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> numerator;</span><br><span class="line">  <span class="keyword">int</span> denominator;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> <span class="title">numbers</span>[1000];</span></span><br><span class="line">numbers[<span class="number">0</span>].numerator = <span class="number">22</span>;</span><br><span class="line">numbers[<span class="number">0</span>].denominator = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>



<p>struct 结构占用的存储空间，不是各个属性存储空间的总和。因为为了计算效率，C 语言的内存占用空间一般来说，都必须是<code>int</code>类型存储空间的倍数。如果<code>int</code>类型的存储是4字节，那么 struct 类型的存储空间就总是4的倍数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">char</span> a; <span class="keyword">int</span> b; &#125; s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(s)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>如果按照属性占据的空间相加，变量<code>s</code>的存储空间应该是5个字节。但是，struct 结构的存储空间是<code>int</code>类型的倍数，所以最后的结果是占据8个字节，<code>a</code>属性与<code>b</code>属性之间有3个字节的“空洞”。</p>
<h3 id="struct-的复制"><a href="#struct-的复制" class="headerlink" title="struct 的复制"></a>struct 的复制</h3><p>struct 变量可以使用赋值运算符（<code>=</code>），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="keyword">char</span> name[<span class="number">30</span>]; <span class="keyword">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(a.name, <span class="string">&quot;Hula&quot;</span>);</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br><span class="line"><span class="comment">// 修改掉`b.name`不影响`a.name`。</span></span><br><span class="line">b.name[<span class="number">0</span>] = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.name); <span class="comment">// Hula</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b.name); <span class="comment">// Mula</span></span><br></pre></td></tr></table></figure>



<p>上面这个示例是有前提的，就是 struct 结构的属性必须定义成字符数组，才能复制数据。如果稍作修改，属性定义成字符指针，结果就不一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="keyword">char</span>* name; <span class="keyword">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;Hula&quot;</span>;</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>name</code>属性变成了一个字符指针，这时<code>a</code>赋值给<code>b</code>，导致<code>b.name</code>也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。因为这时，struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的。</p>
<blockquote>
<p>另外，C 语言没有提供比较两个自定义数据结构是否相等的方法，无法用比较运算符（比如<code>==</code>和<code>!=</code>）比较两个数据结构是否相等或不等。</p>
</blockquote>
<h3 id="struct-指针"><a href="#struct-指针" class="headerlink" title="struct 指针"></a>struct 指针</h3><p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">turtle</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* name;</span><br><span class="line">  <span class="keyword">char</span>* species;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">happy</span><span class="params">(struct turtle t)</span> </span>&#123;</span><br><span class="line">  t.age = t.age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">turtle</span> <span class="title">myTurtle</span> =</span> &#123;<span class="string">&quot;MyTurtle&quot;</span>, <span class="string">&quot;sea turtle&quot;</span>, <span class="number">99</span>&#125;;</span><br><span class="line">  happy(myTurtle);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Age is %i\n&quot;</span>, myTurtle.age); <span class="comment">// 输出 99。函数外部的`age`属性值根本没变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将 struct 变量的指针传入函数，通过指针来修改 struct 属性，就可以影响到函数外部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数内部必须使用`(*t).age`的写法，从指针拿到 struct 结构本身。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">happy</span><span class="params">(struct turtle* t)</span> </span>&#123;</span><br><span class="line">  (*t).age = (*t).age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">happy(&amp;myTurtle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `(*t).age`这样的写法很麻烦。C 语言就引入了一个新的箭头运算符（`-&gt;`），可以从 struct 指针上直接获取属性，大大增强了代码的可读性。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">happy</span><span class="params">(struct turtle* t)</span> </span>&#123;</span><br><span class="line">  t-&gt;age = t-&gt;age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下</p>
<ul>
<li>对于 struct 变量名，使用点运算符（<code>.</code>）获取属性；</li>
<li>对于 struct 变量指针，使用箭头运算符（<code>-&gt;</code>）获取属性。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以变量`myStruct`为例，假设`ptr`是它的指针，那么下面三种写法是同一回事。</span></span><br><span class="line"><span class="comment">// ptr == &amp;myStruct</span></span><br><span class="line">myStruct.prop == (*ptr).prop == ptr-&gt;prop</span><br></pre></td></tr></table></figure>



<h3 id="struct-的嵌套"><a href="#struct-的嵌套" class="headerlink" title="struct 的嵌套"></a>struct 的嵌套</h3><p>struct 结构的成员可以是另一个 struct 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">species</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* name;</span><br><span class="line">  <span class="keyword">int</span> kinds;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">species</span> <span class="title">breed</span>;</span> <span class="comment">// `fish`的属性`breed`是另一个 struct 结构`species`。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>赋值的时候有多种写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;<span class="string">&quot;shark&quot;</span>, <span class="number">9</span>, &#123;<span class="string">&quot;Selachimorpha&quot;</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">species</span> <span class="title">myBreed</span> =</span> &#123;<span class="string">&quot;Selachimorpha&quot;</span>, <span class="number">500</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;<span class="string">&quot;shark&quot;</span>, <span class="number">9</span>, myBreed&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;</span><br><span class="line">  .name=<span class="string">&quot;shark&quot;</span>,</span><br><span class="line">  .age=<span class="number">9</span>,</span><br><span class="line">  .breed=&#123;<span class="string">&quot;Selachimorpha&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;</span><br><span class="line">  .name=<span class="string">&quot;shark&quot;</span>,</span><br><span class="line">  .age=<span class="number">9</span>,</span><br><span class="line">  .breed.name=<span class="string">&quot;Selachimorpha&quot;</span>,</span><br><span class="line">  .breed.kinds=<span class="number">500</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Shark&#x27;s species is %s&quot;</span>, shark.breed.name);</span><br></pre></td></tr></table></figure>

<p>上面示例展示了嵌套 Struct 结构的四种赋值写法。另外，引用<code>breed</code>属性的内部属性，要使用两次点运算符（<code>shark.breed.name</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> first[<span class="number">50</span>];</span><br><span class="line">  <span class="keyword">char</span> last[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">name</span>;</span></span><br><span class="line">  <span class="keyword">short</span> age;</span><br><span class="line">  <span class="keyword">char</span> sex;</span><br><span class="line">&#125; student1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.first, <span class="string">&quot;Harry&quot;</span>); <span class="comment">// 对字符数组属性赋值，要使用`strcpy()`函数，不能直接赋值，因为直接改掉字符数组名的地址会报错。</span></span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.last, <span class="string">&quot;Potter&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">myname</span> =</span> &#123;<span class="string">&quot;Harry&quot;</span>, <span class="string">&quot;Potter&quot;</span>&#125;;</span><br><span class="line">student1.name = myname;</span><br></pre></td></tr></table></figure>



<p>struct 结构内部不仅可以引用其他结构，还可以自我引用，即结构内部引用当前结构。比如，链表结构的节点就可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个三个节点的列表 (11)-&gt;(22)-&gt;(33)</span></span><br><span class="line">head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line"></span><br><span class="line">head-&gt;data = <span class="number">11</span>;</span><br><span class="line">head-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line"></span><br><span class="line">head-&gt;next-&gt;data = <span class="number">22</span>;</span><br><span class="line">head-&gt;next-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line"></span><br><span class="line">head-&gt;next-&gt;next-&gt;data = <span class="number">33</span>;</span><br><span class="line">head-&gt;next-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历这个列表</span></span><br><span class="line"><span class="keyword">for</span> (struct node *cur = head; cur != <span class="literal">NULL</span>; cur = cur-&gt;next) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cur-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h3><p>struct 还可以用来定义二进制位组成的数据结构，称为<code>位字段</code>（bit field），这对于操作底层的二进制数据非常有用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// 每个属性后面的`:1`，表示指定这些属性只占用一个二进制位，所以这个数据结构一共是4个二进制位。</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ab:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> cd:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ef:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> gh:<span class="number">1</span>;</span><br><span class="line">&#125; synth;</span><br><span class="line"></span><br><span class="line">synth.ab = <span class="number">0</span>;</span><br><span class="line">synth.cd = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，定义二进制位时，结构内部的各个属性只能是整数类型。</p>
</blockquote>
<p>实际存储的时候，C 语言会按照<code>int</code>类型占用的字节数，存储一个位字段结构。如果有剩余的二进制位，可以使用未命名属性，填满那些位。也可以使用宽度为0的属性，表示占满当前字节剩余的二进制位，迫使下一个属性存储在下一个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> field1 : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>        : <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> field2 : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>        : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> field3 : <span class="number">1</span>;</span><br><span class="line">&#125; stuff;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>stuff.field1</code>与<code>stuff.field2</code>之间，有一个宽度为两个二进制位的未命名属性。<code>stuff.field3</code>将存储在下一个字节。</p>
<h3 id="弹性数组成员"><a href="#弹性数组成员" class="headerlink" title="弹性数组成员"></a>弹性数组成员</h3><p>很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做<code>弹性数组成员</code>（flexible array member）。</p>
<p>如果不能事先确定数组成员的数量时，可以定义一个 struct 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `len`属性用来记录数组`chars`的长度，`chars`属性是一个数组，但是没有给出成员数量。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vstring</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">char</span> chars[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>chars</code>数组到底有多少个成员，可以在为<code>vstring</code>分配内存时确定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vstring</span>* <span class="title">str</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct vstring) + n * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">str-&gt;len = n;</span><br></pre></td></tr></table></figure>

<p>上面示例中，假定<code>chars</code>数组的成员数量是<code>n</code>，只有在运行时才能知道<code>n</code>到底是多少。然后，就为<code>struct vstring</code>分配它需要的内存：它本身占用的内存长度，再加上<code>n</code>个数组成员占用的内存长度。最后，<code>len</code>属性记录一下<code>n</code>是多少。</p>
<p>这样就可以让数组<code>chars</code>有<code>n</code>个成员，不用事先确定，可以跟运行时的需要保持一致。</p>
<p>弹性数组成员有一些专门的规则。</p>
<ul>
<li>弹性成员的数组，必须是 struct 结构的最后一个属性。</li>
<li>除了弹性数组成员，struct 结构必须至少还有一个其他属性。</li>
</ul>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p><code>typedef</code>命令用来为某个类型起别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `type`代表类型名，`name`代表别名。</span></span><br><span class="line"><span class="keyword">typedef</span> type name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `typedef`命令为类型`unsign char`起别名`BYTE`</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line">BYTE c = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 可以一次指定多个别名。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> antelope, bagel, mushroom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 可以为指针起别名。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* intptr;  <span class="comment">// `intptr`是`int*`的别名。</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">intptr x = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 也可以用来为数组类型起别名。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> five_ints[<span class="number">5</span>];</span><br><span class="line">five_ints x = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 为函数起别名</span></span><br><span class="line"><span class="comment">// 类型别名`fp`是一个指针，代表函数`signed char (*)(void)`。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="title">char</span> <span class="params">(*fp)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<p><code>typedef</code>为类型起别名的好处，主要有下面几点。</p>
<ul>
<li><p>更好的代码可读性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为字符指针起别名为`STRING`，以后使用`STRING`声明变量时，就可以轻易辨别该变量是字符串。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* STRING;</span><br><span class="line">STRING name;</span><br></pre></td></tr></table></figure></li>
<li><p>为 struct、union、enum 等命令定义的复杂数据结构创建别名，从而便于引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treenode</span>* <span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef 也可以与 struct 定义数据类型的命令写在一起。</span></span><br><span class="line"><span class="comment">// 自定义数据类型时，同时使用`typedef`命令，为`struct animal`起了一个别名`animal`。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">animal</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* name;</span><br><span class="line">  <span class="keyword">int</span> leg_count, speed;</span><br><span class="line">&#125; animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为一个匿名的数据类型起了别名`animal`。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">int</span> leg_count, speed;</span><br><span class="line">&#125; animal;</span><br></pre></td></tr></table></figure></li>
<li><p>typedef 方便以后为变量改类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> app_float;</span><br><span class="line">app_float f1, f2, f3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将变量`f1`、`f2`、`f3`的类型都改为`long double`。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> app_float;</span><br></pre></td></tr></table></figure></li>
<li><p>可移植性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某一个值在不同计算机上的类型，可能是不一样的。</span></span><br><span class="line"><span class="comment">// // 在32位整数的计算机没有问题，但是在16位整数的计算机就会出错。</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// C 语言的解决办法，就是提供了类型别名，在不同计算机上会解释成不同类型，比如`int32_t`。</span></span><br><span class="line"><span class="comment">// 将变量`i`声明成`int32_t`类型，保证它在不同计算机上都是32位宽度，移植代码时就不会出错。</span></span><br><span class="line"><span class="keyword">int32_t</span> i = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一类的类型别名都是用 typedef 定义的。下面是类似的例子。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>简化类型声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有些类型声明相当复杂</span></span><br><span class="line"><span class="keyword">char</span> (*(*x(<span class="keyword">void</span>))[<span class="number">5</span>])(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*Func)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> Func Arr[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> Arr* <span class="title">x</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面代码就比较容易解读了。</p>
<ul>
<li><code>x</code>是一个函数，返回一个指向 Arr 类型的指针。</li>
<li><code>Arr</code>是一个数组，有5个成员，每个成员是<code>Func</code>类型。</li>
<li><code>Func</code>是一个函数指针，指向一个无参数、返回字符值的函数。</li>
</ul>
</li>
</ul>
<h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p><strong>共用体</strong>是一种特殊的数据类型，允许您<strong>在相同的内存位置存储不同的数据类型。</strong>您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
<p>有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示水果的“量”，这种结构就需要有时是整数（6个苹果），有时是浮点数（1.5公斤草莓）。</p>
<p>Union 结构<strong>内部可以包含各种属性，但同一时间只能有一个属性</strong>，因为所有属性都保存在同一个内存地址，后面写入的属性会覆盖前面的属性。这样做的最大好处是节省空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `union`命令定义了一个包含三个属性的数据类型`quantity`。虽然包含三个属性，但是同一时间只能取到一个属性。</span></span><br><span class="line"><span class="comment">// 最后赋值的属性，就是可以取到值的那个属性。</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> &#123;</span></span><br><span class="line">  <span class="keyword">short</span> count;</span><br><span class="line">  <span class="keyword">float</span> weight;</span><br><span class="line">  <span class="keyword">float</span> volume;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用时，声明一个该类型的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span>;</span></span><br><span class="line">q.count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span> =</span> &#123;.count=<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="comment">// 不指定属性名，就会赋值给第一个属性。</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span> =</span> &#123;<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>执行完上面的代码以后，<code>q.count</code>可以取到值，另外两个属性取不到值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count is %i\n&quot;</span>, q.count); <span class="comment">// count is 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;weight is %f\n&quot;</span>, q.weight); <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure>

<p>如果要让<code>q.weight</code>属性可以取到值，就要先为它赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.weight = <span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;weight is %f\n&quot;</span>, q.weight); <span class="comment">// weight is 0.5</span></span><br></pre></td></tr></table></figure>

<p>一旦为其他属性赋值，原先可以取到值的<code>q.count</code>属性就不再有效了。</p>
<p><strong>Union 结构的其他用法与 Struct 结构基本上是一致的</strong>。Union 结构也支持指针运算符<code>-&gt;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> &#123;</span></span><br><span class="line">  <span class="keyword">short</span> count;</span><br><span class="line">  <span class="keyword">float</span> weight;</span><br><span class="line">  <span class="keyword">float</span> volume;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span> <span class="title">q</span>;</span></span><br><span class="line">q.count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">quantity</span>* <span class="title">ptr</span>;</span></span><br><span class="line">ptr = &amp;q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptr-&gt;count); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>ptr</code>是<code>q</code>的指针，那么<code>ptr-&gt;count</code>等同于<code>q.count</code>。</p>
<p>Union 结构指针与它的属性有关，当前哪个属性能够取到值，它的指针就是对应的数据类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">float</span> b;</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* foo_int_p = (<span class="keyword">int</span> *)&amp;x;</span><br><span class="line"><span class="keyword">float</span>* foo_float_p = (<span class="keyword">float</span> *)&amp;x;</span><br><span class="line"></span><br><span class="line">x.a = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x.a);           <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *foo_int_p);    <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">x.b = <span class="number">3.141592</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x.b);           <span class="comment">// 3.141592</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, *foo_float_p);  <span class="comment">// 3.141592</span></span><br></pre></td></tr></table></figure>



<p>typedef 命令可以为 Union 数据类型起别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="keyword">short</span> count;</span><br><span class="line">  <span class="keyword">float</span> weight;</span><br><span class="line">  <span class="keyword">float</span> volume;</span><br><span class="line">&#125; quantity;</span><br></pre></td></tr></table></figure>

<p>Union 结构的好处，主要是节省空间。<strong>它将一段内存空间，重用于不同类型的数据</strong>。定义了三个属性，但同一时间只用到一个，使用 Union 结构就可以节省另外两个属性的空间。<strong>Union 结构占用的内存长度，等于它内部最长属性的长度</strong>。</p>
<h2 id="Enum-类型"><a href="#Enum-类型" class="headerlink" title="Enum 类型"></a>Enum 类型</h2><p>如果一种数据类型的取值只有少数几种可能，并且每种取值都有自己的含义，为了提高代码的可读性，可以将它们定义为 Enum 类型，中文名为枚举。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常都使用大写。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> &#123;</span>RED, GREEN, BLUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这三个名字自动成为整数常量，编译器默认将它们的值设为数字`0`、`1`、`2`。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, RED); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, GREEN);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, BLUE);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时，可以将变量声明为 Enum 类型。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> <span class="title">color</span>;</span></span><br><span class="line">color = BLUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, color); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<p>typedef 命令可以为 Enum 类型起别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  SHEEP,</span><br><span class="line">  WHEAT,</span><br><span class="line">  WOOD,</span><br><span class="line">  BRICK,</span><br><span class="line">  ORE</span><br><span class="line">&#125; RESOURCE;</span><br><span class="line"></span><br><span class="line">RESOURCE r;</span><br></pre></td></tr></table></figure>



<p>还有一种不常见的写法，就是声明 Enum 类型时，在同一行里面为变量赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `r`的值是`3`，`s`的值是`2`。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  SHEEP,</span><br><span class="line">  WHEAT,</span><br><span class="line">  WOOD,</span><br><span class="line">  BRICK,</span><br><span class="line">  ORE</span><br><span class="line">&#125; r = BRICK, s = WOOD;</span><br></pre></td></tr></table></figure>



<p>由于 Enum 的属性会自动声明为常量，所以有时候使用 Enum 的目的，不是为了自定义一种数据类型，而是为了声明一组常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最后一个常量后面的尾逗号，可以省略，也可以保留。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> ONE, TWO &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> ONE, TWO, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, ONE, TWO);  <span class="comment">// 0 1</span></span><br></pre></td></tr></table></figure>



<p>Enum 会自动从0开始递增，为常量赋值。也允许为 ENUM 常量指定值，不过只能指定为整数，不能是其他类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> ONE = <span class="number">1</span>, TWO = <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, ONE, TWO);  <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum 常量可以是不连续的值。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> X = <span class="number">2</span>, Y = <span class="number">18</span>, Z = <span class="number">-2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum 常量也可以是同一个值。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> X = <span class="number">2</span>, Y = <span class="number">2</span>, Z = <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一组常量之中，有些指定了值，有些没有指定。那么，没有指定值的常量会从上一个指定了值的常量，开始自动递增赋值。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  A,      <span class="comment">// 0</span></span><br><span class="line">  B,      <span class="comment">// 1</span></span><br><span class="line">  C = <span class="number">4</span>,  <span class="comment">// 4</span></span><br><span class="line">  D,      <span class="comment">// 5</span></span><br><span class="line">  E,      <span class="comment">// 6</span></span><br><span class="line">  F = <span class="number">3</span>   <span class="comment">// 3</span></span><br><span class="line">  G,      <span class="comment">// 4</span></span><br><span class="line">  H       <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="预处理器（Preprocessor）"><a href="#预处理器（Preprocessor）" class="headerlink" title="预处理器（Preprocessor）"></a>预处理器（Preprocessor）</h2><ul>
<li>C 语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码。</li>
<li>预处理器首先会清理代码，进行删除注释、多行的语句合成一个逻辑行等等。然后，执行<code>#</code>开头的预处理指令。本章介绍 C 语言的预处理指令。</li>
<li>预处理指令可以出现在程序的任何地方，但是习惯上，往往放在代码的开头部分。</li>
<li>每个预处理指令都以<code>#</code>开头，放在一行的行首，指令前面可以有空白字符（比如空格或制表符）。<code>#</code>和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，一般不留空格。</li>
<li>所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。</li>
</ul>
<h3 id="define"><a href="#define" class="headerlink" title="#define"></a><code>#define</code></h3><ul>
<li><code>#define</code>是最常见的预处理指令，<strong>用来将指定的词替换成另一个词</strong>。</li>
<li>它的参数分成两个部分，第一个参数就是要被替换的部分，其余参数是替换后的内容。</li>
<li>每条替换规则，称为一个宏（macro）。</li>
<li><code>#define</code>指令可以出现在源码文件的任何地方，从指令出现的地方到该文件末尾都有效。习惯上，会将<code>#define</code>放在源码文件的头部。它的主要好处是，会使得程序的可读性更好，也更容易修改。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `#define`指定将源码里面的`MAX`，全部替换成`100`。`MAX`就称为一个宏。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO <span class="meta-string">&quot;Hello, world&quot;</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, HELLO); <span class="comment">// 相当于 printf(&quot;%s&quot;, &quot;Hello, world&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `#define`指令从`#`开始，一直到换行符为止。如果整条指令过长，可以在折行处使用反斜杠，延续到下一行。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OW <span class="meta-string">&quot;C programming language is invented \</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">in 1970s.&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `#define`允许多重替换，即一个宏可以包含另一个宏。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO 2</span></span><br><span class="line"><span class="comment">// `FOUR`会被替换成`2*2`。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR TWO*TWO </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名的宏可以重复定义，只要定义是相同的，就没有问题。如果定义不同，就会报错。</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO hello</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO hello</span></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BAR hello</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BAR world</span></span><br></pre></td></tr></table></figure>



<h3 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>宏的强大之处在于，它的名称后面可以使用括号，指定接受一个或多个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏`SQUARE`可以接受一个参数`X`，替换成`X*X`。</span></span><br><span class="line"><span class="comment">// 注意，宏的名称与左边圆括号之间，不能有空格。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line">z = SQUARE(<span class="number">2</span>); <span class="comment">// 替换成 z = 2*2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种写法很像函数，但又不是函数，而是完全原样的替换，会跟函数有不一样的行为。</span></span><br><span class="line"><span class="comment">// `SQUARE(3 + 4)`如果是函数，输出的应该是49（`7*7`）；宏是原样替换，所以替换成`3 + 4*3 + 4`，最后输出19。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SQUARE(<span class="number">3</span> + <span class="number">4</span>)); <span class="comment">// 输出19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原样替换可能导致意料之外的行为。</span></span><br><span class="line"><span class="comment">// 解决办法就是在定义宏的时候，尽量多使用圆括号，这样可以避免很多意外。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) ((X) * (X))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏的参数也可以是空的。</span></span><br><span class="line"><span class="comment">// 这种情况其实可以省略圆括号，但是加上了，会让它看上去更像函数。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() getc(stdin)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x)&gt;(y)?(x):(y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_EVEN(n) ((n)%2==0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果宏的长度过长，可以使用反斜杠（`\`）折行，将宏写成多行。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_NUMS_TO_PRODUCT(a, b) &#123; \</span></span><br><span class="line"><span class="meta">  int product = (a) * (b); \</span></span><br><span class="line"><span class="meta">  for (int i = 0; i &lt; product; i++) &#123; \</span></span><br><span class="line"><span class="meta">    printf(<span class="meta-string">&quot;%d\n&quot;</span>, i); \</span></span><br><span class="line"><span class="meta">  &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的宏也可以嵌套，一个宏里面包含另一个宏。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c)</span></span><br></pre></td></tr></table></figure>

<p>什么时候使用带参数的宏，什么时候使用函数呢？</p>
<ul>
<li>一般来说，应该首先使用函数，它的功能更强、更容易理解。宏有时候会产生意想不到的替换结果，而且往往只能写成一行，除非对换行符进行转义，但是可读性就变得很差。</li>
<li>宏的优点是相对简单，<strong>本质上是字符串替换</strong>，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。</li>
<li>另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解。</li>
</ul>
<h4 id="运算符，-运算符"><a href="#运算符，-运算符" class="headerlink" title="#运算符，##运算符"></a><code>#</code>运算符，<code>##</code>运算符</h4><p>由于<strong>宏不涉及数据类型</strong>，所以替换以后可能为各种类型的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果希望替换后的值为字符串，可以在替换文本的参数前面加上`#`。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(x) #x</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, STR(<span class="number">3.14159</span>)); <span class="comment">// 等同于 printf(&quot;%s\n&quot;, &quot;3.14159&quot;);</span></span><br><span class="line"><span class="comment">// 如果`x`前面没有`#`，这会被解释成一个浮点数，有了`#`以后，就会被转换成字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) <span class="meta-string">&quot;x&quot;</span>#n</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, XNAME(<span class="number">4</span>)); <span class="comment">// 输出 x4</span></span><br><span class="line"><span class="comment">// `#n`指定参数输出为字符串，再跟前面的字符串结合，最终输出为`&quot;x4&quot;`。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个「新的标识符」，可以使用`##`运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。</span></span><br><span class="line"><span class="comment">// `n`是宏`MK_ID`的参数，这个参数需要跟标识符`i`粘合在一起，这时`i`和`n`之间就要使用`##`运算符。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MK_ID(n) i##n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MK_ID</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">MK_ID</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">MK_ID</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="keyword">int</span> i1, i2, i3;</span><br><span class="line"><span class="comment">// 替换后的文本`i1`、`i2`、`i3`是三个标识符，参数`n`是标识符的一部分。从这个例子可以看到，`##`运算符的一个主要用途是批量生成变量名和标识符。</span></span><br></pre></td></tr></table></figure>



<h4 id="不定参数的宏"><a href="#不定参数的宏" class="headerlink" title="不定参数的宏"></a>不定参数的宏</h4><p>宏的参数还可以是不定数量的（即不确定有多少个参数），<code>...</code>表示剩余的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `X(a, b, ...)`表示`X()`至少有两个参数，多余的参数使用`...`表示。</span></span><br><span class="line"><span class="comment">// 在替换文本中，`__VA_ARGS__`代表多余的参数（每个参数之间使用逗号分隔）。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__</span></span><br><span class="line">X(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3.14</span>, <span class="string">&quot;Hi!&quot;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line">(<span class="number">10</span>*(<span class="number">5</span>) + <span class="number">20</span>*(<span class="number">4</span>)), <span class="number">3.14</span>, <span class="string">&quot;Hi!&quot;</span>, <span class="number">12</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<code>...</code>只能替代宏的尾部参数，不能写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不允许使用`...`替代中间部分的参数，会报错。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRONG(X, ..., Y) #X #__CA_ARGS__ #Y <span class="comment">// 报错</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>__VA_ARGS__</code>前面加上一个<code>#</code>号，可以让输出变成一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(...) #__VA_ARGS__</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, X(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));  <span class="comment">// Prints &quot;1, 2, 3&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="undef"><a href="#undef" class="headerlink" title="#undef"></a><code>#undef</code></h3><ul>
<li><code>#undef</code>指令用来取消已经使用<code>#define</code>定义的宏。</li>
<li>有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用<code>#undef</code>取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，而<code>#undef</code>的参数如果是不存在的宏，并不会报错。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIMIT 400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LIMIT <span class="comment">// 取消已经定义的宏`LIMIT`，后面就可以重新用 LIMIT 定义一个宏。</span></span></span><br></pre></td></tr></table></figure>

<p>GCC 的<code>-U</code>选项可以在命令行取消宏的定义，相当于<code>#undef</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `-U`参数，取消了宏`LIMIT`，相当于源文件里面的`#undef LIMIT`。</span></span><br><span class="line">gcc -ULIMIT foo.c</span><br></pre></td></tr></table></figure>



<h3 id="include"><a href="#include" class="headerlink" title="#include"></a><code>#include</code></h3><p><code>#include</code>指令用于编译时将其他源码文件，加载进入当前文件。它有两种形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式一，文件名写在尖括号里面，表示该文件是系统提供的，通常是标准库的库文件。</span></span><br><span class="line"><span class="comment">// 不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;foo.h&gt;</span> <span class="comment">// 加载系统提供的文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式二，文件名写在双引号里面，表示该文件由用户提供。</span></span><br><span class="line"><span class="comment">// 具体的路径取决于编译器的设置，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo.h&quot;</span> <span class="comment">// 加载用户提供的文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/usr/local/lib/foo.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>GCC 编译器的<code>-I</code>参数，也可以用来指定<code>include</code>命令中用户文件的加载路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `-Iinclude/`指定从当前目录的`include`子目录里面，加载用户自己的文件。</span></span><br><span class="line">gcc -Iinclude/ -o code code.c</span><br></pre></td></tr></table></figure>

<p><code>#include</code>最常见的用途，就是用来加载包含函数原型的头文件（后缀名为<code>.h</code>），参见《多文件编译》一章。</p>
<p>多个<code>#include</code>指令的顺序无关紧要，多次包含同一个头文件也是合法的。</p>
<h3 id="if-endif"><a href="#if-endif" class="headerlink" title="#if...#endif"></a><code>#if...#endif</code></h3><p><code>#if...#endif</code>指令用于预处理器的条件判断，<strong>满足条件时，内部的行会被编译，否则就被编译器忽略</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `#if`后面的`0`，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。</span></span><br><span class="line"><span class="comment">// `#if 0`这种写法常用来当作注释使用，不需要的代码就放在`#if 0`里面。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415</span>; <span class="comment">// 不会执行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `#if`后面的判断条件，通常是一个表达式。如果表达式的值不等于`0`，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句。</span></span><br><span class="line"><span class="comment">// 宏`FOO`如果定义过，会被替换成`1`，从而输出`defined`，否则输出`not defined`，等同于`0`。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FOO</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;defined\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;not defined\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有多个判断条件，还可以加入`#elif`命令。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAPPY_FACTOR == 0</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m not happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> HAPPY_FACTOR == 1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m just regular\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `#if`的常见应用就是打开（或关闭）调试模式。</span></span><br><span class="line"><span class="comment">// 通过将`DEBUG`设为`1`，就打开了调试模式，可以输出调试信息。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;value of i : %d\n&quot;</span>, i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;value of j : %d\n&quot;</span>, j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>GCC 的<code>-D</code>参数可以在编译时指定宏的值，因此可以很方便地打开调试开关。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `-D`参数指定宏`DEBUG`为`1`，相当于在代码中指定`#define DEBUG 1`。</span></span><br><span class="line">gcc -DDEBUG=1 foo.c</span><br></pre></td></tr></table></figure>



<h3 id="ifdef-endif"><a href="#ifdef-endif" class="headerlink" title="#ifdef...#endif"></a><code>#ifdef...#endif</code></h3><p><code>#ifdef...#endif</code>指令用于判断某个宏是否定义过。</p>
<p>有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用<code>#define</code>定义一个空的宏。通过这个宏，判断库文件是否被加载了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `EXTRA_HAPPY`就是一个空的宏。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTRA_HAPPY</span></span><br><span class="line"><span class="comment">// 然后，源码文件使用`#ifdef...#endif`检查这个宏是否定义过。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> EXTRA_HAPPY</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m just regular\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>#ifdef</code>检查宏<code>EXTRA_HAPPY</code>是否定义过。如果已经存在，表示加载过库文件，就会打印一行提示。</p>
<p><code>#ifdef...#else...#endif</code>可以用来实现条件加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过判断宏`MAVIS`是否定义过，实现加载不同的头文件。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAVIS</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;foo.h&quot;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STABLES 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bar.h&quot;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> STABLES 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined 运算符"></a>defined 运算符</h3><p><code>#ifdef</code>指令，等同于<code>#if defined</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `defined`是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FOO</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined FOO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这种语法，可以完成多重判断。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined FOO</span></span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined BAR</span></span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同架构的系统需要定义对应的宏。代码根据不同的宏，加载对应的头文件。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined IBMPC</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ibmpc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined MAC</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;general.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="ifndef-endif"><a href="#ifndef-endif" class="headerlink" title="#ifndef...#endif"></a><code>#ifndef...#endif</code></h3><p><code>#ifndef...#endif</code>指令跟<code>#ifdef...#endif</code>正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> EXTRA_HAPPY</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m extra happy!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTRA_HAPPY</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m just regular\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p><code>#ifndef</code>常用于防止重复加载。举例来说，为了防止头文件<code>myheader.h</code>被重复加载，可以把它放在<code>#ifndef...#endif</code>里面加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏`MYHEADER_H`对应文件名`myheader.h`的大写。只要`#ifndef`发现这个宏没有被定义过，就说明该头文件没有加载过，从而加载内部的代码，并会定义宏`MYHEADER_H`，防止被再次加载。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYHEADER_H</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> MYHEADER_H</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myheader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p><code>#ifndef</code>等同于<code>#if !defined</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined FOO</span></span><br></pre></td></tr></table></figure>



<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>C 语言提供一些预定义的宏，可以直接使用。</p>
<ul>
<li><code>__DATE__</code>：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。</li>
<li><code>__TIME__</code>：编译时间，格式为“hh:mm:ss”。</li>
<li><code>__FILE__</code>：当前文件名。</li>
<li><code>__LINE__</code>：当前行号。</li>
<li><code>__func__</code>：当前正在执行的函数名。该预定义宏必须在函数作用域使用。</li>
<li><code>__STDC__</code>：如果被设为1，表示当前编译器遵循 C 标准。</li>
<li><code>__STDC_HOSTED__</code>：如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）。</li>
<li><code>__STDC_VERSION__</code>：编译所使用的 C 语言版本，是一个格式为<code>yyyymmL</code>的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This function: %s\n&quot;</span>, __func__);            <span class="comment">// This function: main</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This file: %s\n&quot;</span>, __FILE__);                <span class="comment">// This file: test.c</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This line: %d\n&quot;</span>, __LINE__);                <span class="comment">// This line: 7</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Compiled on: %s %s\n&quot;</span>, __DATE__, __TIME__); <span class="comment">// Compiled on: Mar 29 2021 19:19:37</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;C Version: %ld\n&quot;</span>, __STDC_VERSION__);       <span class="comment">// C Version: 201710</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="line"><a href="#line" class="headerlink" title="#line"></a><code>#line</code></h3><p><code>#line</code>指令用于覆盖预定义宏<code>__LINE__</code>，将其改为自定义的行号。后面的行将从<code>__LINE__</code>的新值开始计数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将下一行的行号重置为 300，紧跟在`#line 300`后面一行的行号，将被改成300，其后的行会在300的基础上递增编号。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span> 300</span></span><br></pre></td></tr></table></figure>

<p><code>#line</code>还可以改掉预定义宏<code>__FILE__</code>，将其改为自定义的文件名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下一行的行号重置为`300`，文件名重置为`newfilename`。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span> 300 <span class="meta-string">&quot;newfilename&quot;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="error"><a href="#error" class="headerlink" title="#error"></a><code>#error</code></h3><p><code>#error</code>指令用于让预处理器抛出一个错误，终止编译。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __STDC_VERSION__ != 201112L</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">error</span> Not C11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果编译器不使用 C11 标准，就中止编译。GCC 编译器会像下面这样报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -std=c99 newish.c</span><br><span class="line">newish.c:14:2: error: <span class="comment">#error Not C11</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器一旦发现`INT`类型的最大值小于`100,000`，就会停止编译。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">error</span> int type is too small</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p><code>#error</code>指令也可以用在<code>#if...#elif...#else</code>的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined WIN32</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined MAC_OS</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined LINUX</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">error</span> NOT support the operating system</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a><code>#pragma</code></h3><p><code>#pragma</code>指令用来修改编译器属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 C99 标准进行编译。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> c9x on</span></span><br></pre></td></tr></table></figure>



<h2 id="I-O-函数"><a href="#I-O-函数" class="headerlink" title="I/O 函数"></a>I/O 函数</h2><p>C 语言提供了一些函数，用于与外部设备通信，称为输入输出函数，简称 I/O 函数。</p>
<p>输入（import）指的是获取外部数据，输出（export）指的是向外部传递数据。</p>
<h3 id="缓存和字节流"><a href="#缓存和字节流" class="headerlink" title="缓存和字节流"></a>缓存和字节流</h3><ul>
<li>严格地说，输入输出函数并不是直接与外部设备通信，而是通过缓存（buffer）进行间接通信。这个小节介绍缓存是什么。</li>
<li>普通文件一般都保存在磁盘上面，跟 CPU 相比，磁盘读取或写入数据是一个很慢的操作。所以，程序直接读写磁盘是不可行的，可能每执行一行命令，都必须等半天。C 语言的解决方案，就是只要打开一个文件，就在内存里面为这个文件设置一个缓存区。</li>
<li>程序向文件写入数据时，程序先把数据放入缓存，等到缓存满了，再把里面的数据会一次性写入磁盘文件。这时，缓存区就空了，程序再把新的数据放入缓存，重复整个过程。</li>
<li>程序从文件读取数据时，文件先把一部分数据放到缓存里面，然后程序从缓存获取数据，等到缓存空了，磁盘文件再把新的数据放入缓存，重复整个过程。</li>
<li>内存的读写速度比磁盘快得多，缓存的设计减少了读写磁盘的次数，大大提高了程序的执行效率。另外，一次性移动大块数据，要比多次移动小块数据快得多。</li>
<li>这种读写模式，对于程序来说，就有点像水流（stream），不是一次性读取或写入所有数据，而是一个持续不断的过程。先操作一部分数据，等到缓存吞吐完这部分数据，再操作下一部分数据。这个过程就叫做<code>字节流操作</code>。</li>
<li>由于缓存读完就空了，所以字节流读取都是只能读一次，第二次就读不到了。这跟读取文件很不一样。</li>
<li>C 语言的输入输出函数，凡是涉及读写文件，都是属于字节流操作。输入函数从文件获取数据，操作的是输入流；输出函数向文件写入数据，操作的是输出流。</li>
</ul>
<h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>scanf()</code>函数用于读取用户的键盘输入。程序运行到这个语句时，会停下来，等待用户从键盘输入。</p>
<p><code>scanf()</code>的语法跟<code>printf()</code>类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次将键盘输入读入多个变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%f%f&quot;</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure>



<p><code>scanf()</code>处理用户输入的原理是，用户的输入先放入缓存，等到按下回车键后，按照占位符对缓存进行解读。解读用户输入时，会从上一次解读遗留的第一个字符开始，直到读完缓存，或者遇到第一个不符合条件的字符为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户输入 &quot;    -13.45e12# 0&quot;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%f&quot;</span>, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure>

<p><code>scanf()</code>读取用户输入时，<code>%d</code>占位符会忽略起首的空格，从<code>-</code>处开始获取数据，读取到<code>-13</code>停下来，因为后面的<code>.</code>不属于整数的有效字符。这就是说，占位符<code>%d</code>会读到<code>-13</code>。</p>
<p>第二次调用<code>scanf()</code>时，就会从上一次停止解读的地方，继续往下读取。这一次读取的首字符是<code>.</code>，由于对应的占位符是<code>%f</code>，会读取到<code>.45e12</code>，这是采用科学计数法的浮点数格式。后面的<code>#</code>不属于浮点数的有效字符，所以会停在这里。</p>
<p><code>scanf()</code>的返回值是一个整数，表示成功读取的变量个数。如果没有读取任何项，或者匹配失败，则返回<code>0</code>。如果读取到文件结尾，则返回常量 EOF。</p>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p><code>scanf()</code>常用的占位符如下，与<code>printf()</code>的占位符基本一致。</p>
<ul>
<li><code>%c</code>：字符。</li>
<li><code>%d</code>：整数。</li>
<li><code>%f</code>：<code>float</code>类型浮点数。</li>
<li><code>%lf</code>：<code>double</code>类型浮点数。</li>
<li><code>%Lf</code>：<code>long double</code>类型浮点数。</li>
<li><code>%s</code>：字符串。</li>
<li><code>%[]</code>：在方括号中指定一组匹配的字符（比如<code>%[0-9]</code>），遇到不在集合之中的字符，匹配将会停止。</li>
</ul>
<p>上面所有占位符之中，除了<code>%c</code>以外，都会自动忽略起首的空白字符。<code>%c</code>不忽略空白字符，总是返回当前第一个字符，无论该字符是否为空格。如果要强制跳过字符前的空白字符，可以写成<code>scanf(&quot; %c&quot;, &amp;ch)</code>，即<code>%c</code>前加上一个空格，表示跳过零个或多个空白字符。</p>
<p>要特别说一下占位符<code>%s</code>，它其实不能简单地等同于字符串。它的规则是，<strong>从当前第一个非空白字符开始读起，直到遇到空白字符（即空格、换行符、制表符等）为止</strong>。因为<code>%s</code>不会包含空白字符，所以无法用来读取多个单词，除非多个<code>%s</code>一起使用。这也意味着，**<code>scanf()</code>不适合读取可能包含空格的字符串**，比如书名或歌曲名。另外，<code>scanf()</code>遇到<code>%s</code>占位符，会在字符串变量末尾存储一个空字符<code>\0</code>。</p>
<p><code>scanf()</code>将字符串读入字符数组时，不会检测字符串是否超过了数组长度。所以，储存字符串时，很可能会超过数组的边界，导致预想不到的结果。为了防止这种情况，使用<code>%s</code>占位符时，应该指定读入字符串的最长长度，即写成<code>%[m]s</code>，其中的<code>[m]</code>是一个整数，表示读取字符串的最大长度，后面的字符将被丢弃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `name`是一个长度为11的字符数组，`scanf()`的占位符`%10s`表示最多读取用户输入的10个字符，后面的字符将被丢弃，这样就不会有数组溢出的风险了。</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%10s&quot;</span>, name);</span><br></pre></td></tr></table></figure>



<h4 id="赋值忽略符"><a href="#赋值忽略符" class="headerlink" title="赋值忽略符"></a>赋值忽略符</h4><p>有时，用户的输入可能不符合预定的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果用户输入<code>2020-01-01</code>，就会正确解读出年、月、日。问题是用户可能输入其他格式，比如<code>2020/01/01</code>，这种情况下，<code>scanf()</code>解析数据就会失败。</p>
<p>为了避免这种情况，<code>scanf()</code>提供了一个赋值忽略符（assignment suppression character）<code>*</code>。只要把<code>*</code>加在任何占位符的百分号后面，该占位符就不会返回值，解析后将被丢弃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `%*c`就是在占位符的百分号后面，加入了赋值忽略符`*`，表示这个占位符没有对应的变量，解读后不必返回。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%*c%d%*c%d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br></pre></td></tr></table></figure>



<h3 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf()"></a>sscanf()</h3><ul>
<li><code>sscanf()</code>函数与<code>scanf()</code>很类似，不同之处是<code>sscanf()</code>从字符串里面，而不是从用户输入获取数据。它的原型定义在头文件<code>stdio.h</code>里面。</li>
<li><code>sscanf()</code>的一个好处是，它的数据来源不是流数据，所以可以反复使用，不像<code>scanf()</code>的数据来源是流数据，只能读取一次。</li>
<li><code>sscanf()</code>的返回值是成功赋值的变量的数量，如果提取失败，返回常量 EOF。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是一个字符串指针，用来从其中获取数据。其他参数都与`scanf()`相同。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `sscanf()`主要用来处理其他输入函数读入的字符串，从其中提取数据。</span></span><br><span class="line"><span class="comment">// `fgets()`先从标准输入获取了一行数据，存入字符数组`str`。</span></span><br><span class="line"><span class="comment">// 然后，`sscanf()`再从字符串`str`里面提取两个整数，放入变量`i`和`j`。</span></span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>



<h3 id="getchar-，putchar"><a href="#getchar-，putchar" class="headerlink" title="getchar()，putchar()"></a>getchar()，putchar()</h3><ul>
<li><code>getchar()</code>函数返回用户从键盘输入的一个字符，使用时不带有任何参数。程序运行到这个命令就会暂停，等待用户从键盘输入，等同于使用<code>scanf()</code>方法读取一个字符。它的原型定义在头文件<code>stdio.h</code>。</li>
<li><code>getchar()</code>不会忽略起首的空白字符，总是返回当前读取的第一个字符，无论是否为空格。如果读取失败，返回常量 EOF，由于 EOF 通常是<code>-1</code>，所以返回值的类型要设为 int，而不是 char。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br></pre></td></tr></table></figure>

<p>由于<code>getchar()</code>返回读取的字符，所以可以用在循环条件之中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有读到的字符等于换行符（`\n`），才会退出循环，常用来跳过某行。</span></span><br><span class="line"><span class="comment">// `while`循环的循环体没有任何语句，表示对该行不执行任何操作。</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算某一行的字符长度。</span></span><br><span class="line"><span class="comment">// `getchar()`每读取一个字符，长度变量`len`就会加1，直到读取到换行符为止，这时`len`就是该行的字符长度。</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  len++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过空格字符。</span></span><br><span class="line"><span class="comment">// 结束循环后，变量`ch`等于第一个非空格字符。</span></span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>



<p><code>putchar()</code>函数将它的参数字符输出到屏幕，等同于使用<code>printf()</code>输出一个字符。它的原型定义在头文件<code>stdio.h</code>。操作成功时，<code>putchar()</code>返回输出的字符，否则返回常量 EOF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于<code>getchar()</code>和<code>putchar()</code>这两个函数的用法，要比<code>scanf()</code>和<code>printf()</code>更简单，而且通常是用宏来实现，所以要比<code>scanf()</code>和<code>printf()</code>更快。如果操作单个字符，建议优先使用这两个函数。</p>
</blockquote>
<h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><p><code>puts()</code>函数用于将参数字符串显示在屏幕（stdout）上，并且自动在字符串末尾添加换行符。它的原型定义在头文件<code>stdio.h</code>。写入成功时，<code>puts()</code>返回一个非负整数，否则返回常量 EOF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `puts()`在屏幕上输出两行内容。</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Here are some messages:&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p><code>gets()</code>函数以前用于从<code>stdin</code>读取整行输入，现在已经被废除了，仍然放在这里介绍一下。</p>
<p>该函数读取用户的一行输入，不会跳过起始处的空白字符，直到遇到换行符为止。这个函数会丢弃换行符，将其余字符放入参数变量，并在这些字符的末尾添加一个空字符<code>\0</code>，使其成为一个字符串。</p>
<p>它经常与<code>puts()</code>配合使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用`puts()`在屏幕上输出提示，然后使用`gets()`获取用户的输入。</span></span><br><span class="line"><span class="keyword">char</span> words[<span class="number">81</span>];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter a string, please&quot;</span>);</span><br><span class="line">gets(words);</span><br></pre></td></tr></table></figure>

<p>由于<code>gets()</code>获取的字符串，可能超过字符数组变量的最大长度，有安全风险，建议不要使用，改为使用<code>fgets()</code>。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p>C 语言提供了一个 FILE 数据结构，记录了操作一个文件所需要的信息。该结构定义在头文件<code>stdio.h</code>，所有文件操作函数都要通过这个数据结构，获取文件信息。</p>
<p>开始操作一个文件之前，就要定义一个指向该文件的 FILE 指针，相当于获取一块内存区域，用来保存文件信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指向该文件的 FILE 指针</span></span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用`fopen()`打开指定文件，返回一个 File 指针。如果出错，返回 NULL。</span></span><br><span class="line">  <span class="comment">// 后继的操作就可以使用这个指针（而不是文件名）来处理指定文件。</span></span><br><span class="line">  <span class="comment">// 同时，它还为文件建立一个缓存区。由于存在缓存区，也可以说`fopen()`函数“打开一个了流”，后继的读写文件都是流模式。</span></span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从已经打开的文件里面，读取一个字符。</span></span><br><span class="line">  c = fgetc(fp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `fclose()`关闭文件，同时清空缓存区。</span></span><br><span class="line">  fclose(fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>fgetc()</code>一调用，文件的数据块先拷贝到缓冲区。不同的计算机有不同的缓冲区大小，一般是512字节或是它的倍数，如4096或16384。随着计算机硬盘容量越来越大，缓冲区也越来越大。</li>
<li><code>fgetc()</code>从缓冲区读取数据，同时将文件指针内部的读写位置指示器，指向所读取字符的下一个字符。所有的文件读取函数都使用相同的缓冲区，后面再调用任何一个读取函数，都将从指示器指向的位置，即上一次读取函数停止的位置开始读取。</li>
<li>当读取函数发现已读完缓冲区里面的所有字符时，会请求把下一个缓冲区大小的数据块，从文件拷贝到缓冲区中。读取函数就以这种方式，读完文件的所有内容，直到文件结尾。</li>
<li>当函数在缓冲区里面，读完文件的最后一个字符时，就把 FILE 结构里面的文件结尾指示器设置为真。于是，下一次再调用读取函数时，会返回常量 EOF。EOF 是一个整数值，代表文件结尾，一般是<code>-1</code>。</li>
</ul>
</blockquote>
<h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h3><p><code>fopen()</code>函数用来打开文件。这个函数的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是文件名(可以包含路径)，第二个参数是模式字符串，指定对文件执行的操作</span></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">char</span>* mode)</span></span>;</span><br><span class="line"></span><br><span class="line">fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fopen()</code>的模式字符串有以下几种。</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“r”</td>
<td align="left">打开一个用于读取的文件。该文件必须存在。</td>
</tr>
<tr>
<td align="left">“w”</td>
<td align="left">创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。</td>
</tr>
<tr>
<td align="left">“a”</td>
<td align="left">追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。</td>
</tr>
<tr>
<td align="left">“r+”</td>
<td align="left">打开一个用于更新的文件，可读取也可写入。该文件必须存在。</td>
</tr>
<tr>
<td align="left">“w+”</td>
<td align="left">创建一个用于读写的空文件。</td>
</tr>
<tr>
<td align="left">“a+”</td>
<td align="left">打开一个用于读取和追加的文件。</td>
</tr>
</tbody></table>
<blockquote>
<p>模式字符串还有一个<code>x</code>后缀，表示独占模式（exclusive）。如果文件已经存在，则打开文件失败；如果文件不存在，则新建文件，打开后不再允许其他程序或线程访问当前文件。比如，<code>wx</code>表示以独占模式写入文件，如果文件已经存在，就会打开失败。</p>
</blockquote>
<p><code>fopen()</code>函数会为打开的文件创建一个缓冲区。C 语言通过缓存区，以流的形式，向文件读写数据。</p>
<ul>
<li>读模式下，创建的是读缓存区；</li>
<li>写模式下，创建的是写缓存区；</li>
<li>读写模式下，会同时创建两个缓冲区。</li>
</ul>
<p>数据在文件里面，都是以二进制形式存储。但是，读取的时候，有不同的解读方法：以原本的二进制形式解读，叫做“二进制流”；将二进制数据转成文本，以文本形式解读，叫做“文本流”。写入操作也是如此，分成以二进制写入和以文本写入，后者会多一个文本转二进制的步骤。</p>
<p><code>fopen()</code>的模式字符串，默认是以文本流读写。如果添加<code>b</code>后缀（表示 binary），就会以“二进制流”进行读写。比如，<code>rb</code>是读取二进制数据模式，<code>wb</code>是写入二进制数据模式。</p>
<h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>Linux 系统默认提供三个已经打开的文件，它们的文件指针如下。</p>
<ul>
<li><code>stdin</code>（标准输入）：默认来源为键盘，文件指针编号为<code>0</code>。</li>
<li><code>stdout</code>（标准输出）：默认目的地为显示器，文件指针编号为<code>1</code>。</li>
<li><code>stderr</code>（标准错误）：默认目的地为显示器，文件指针编号为<code>2</code>。</li>
</ul>
<blockquote>
<p>Linux 系统的文件，不一定是数据文件，也可以是设备文件，即文件代表一个可以读或写的设备。文件指针<code>stdin</code>默认是把键盘看作一个文件，读取这个文件，就能获取用户的键盘输入。同理，<code>stdout</code>和<code>stderr</code>默认是把显示器看作一个文件，将程序的运行结果写入这个文件，用户就能看到运行结果了。</p>
</blockquote>
<p>Linux 允许改变这三个文件指针（文件流）指向的文件，这称为<code>重定向</code>（redirection）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果标准输入不绑定键盘，而是绑定其他文件，可以在文件名前面加上小于号`&lt;`，跟在程序名后面。这叫做“输入重定向”（input redirection）。</span></span><br><span class="line"><span class="comment"># `demo`程序代码里面的`stdin`，将指向文件`in.dat`，即从`in.dat`获取数据。</span></span><br><span class="line">$ demo &lt; in.dat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果标准输出绑定其他文件，而不是显示器，可以在文件名前加上大于号`&gt;`，跟在程序名后面。这叫做“输出重定向”（output redirection）。</span></span><br><span class="line"><span class="comment"># `demo`程序代码里面的`stdout`，将指向文件`out.dat`，即向`out.dat`写入数据。</span></span><br><span class="line">$ demo &gt; out.dat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出重定向`&gt;`会先擦去`out.dat`的所有原有的内容，然后再写入。如果希望写入的信息追加在`out.dat`的结尾，可以使用`&gt;&gt;`符号。</span></span><br><span class="line"><span class="comment"># `demo`程序代码里面的`stdout`，将向文件`out.dat`写入数据。</span></span><br><span class="line"><span class="comment"># 与`&gt;`不同的是，写入的开始位置是`out.dat`的文件结尾。</span></span><br><span class="line">$ demo &gt;&gt; out.dat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准错误的重定向符号是`2&gt;`。其中的`2`代表文件指针的编号，即`2&gt;`表示将2号文件指针的写入，重定向到`err.txt`。2号文件指针就是标准错误`stderr`。</span></span><br><span class="line"><span class="comment"># `demo`程序代码里面的`stderr`，会向文件`err.txt`写入报错信息。而`stdout`向文件`out.dat`写入。</span></span><br><span class="line">$ demo &gt; out.dat 2&gt; err.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入重定向和输出重定向，也可以结合在一条命令里面。</span></span><br><span class="line">$ demo &lt; in.dat &gt; out.dat</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ demo &gt; out.dat &lt; in.dat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重定向还有另一种情况，就是将一个程序的标准输出`stdout`，指向另一个程序的标准输入`stdin`，这时要使用`|`符号。</span></span><br><span class="line"><span class="comment"># `stdout`的写入，会从`sum`程序代码里面的`stdin`被读取。</span></span><br><span class="line">$ random | sum</span><br></pre></td></tr></table></figure>



<h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a>fclose()</h3><p><code>fclose()</code>用来关闭已经使用<code>fopen()</code>打开的文件。它的原型定义在<code>stdin.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果成功关闭文件，`fclose()`函数返回整数`0`；</span></span><br><span class="line"><span class="comment">// 如果操作失败（比如磁盘已满，或者出现 I/O 错误），则返回一个特殊值 EOF。</span></span><br><span class="line"><span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something wrong.&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h3><ul>
<li>C 语言的文件操作函数的设计是，如果遇到文件结尾，就返回一个特殊值。程序接收到这个特殊值，就知道已经到达文件结尾了。</li>
<li>头文件<code>stdio.h</code>为这个特殊值定义了一个宏<code>EOF</code>（end of file 的缩写），它的值一般是<code>-1</code>。这是因为从文件读取的二进制值，不管作为无符号数字解释，还是作为 ASCII 码解释，都不可能是负值，所以可以很安全地返回<code>-1</code>，不会跟文件本身的数据相冲突。</li>
</ul>
<blockquote>
<p>需要注意的是，不像字符串结尾真的存储了<code>\0</code>这个值，<code>EOF</code>并不存储在文件结尾，文件中并不存在这个值，完全是文件操作函数发现到达了文件结尾，而返回这个值。</p>
</blockquote>
<h3 id="freopen"><a href="#freopen" class="headerlink" title="freopen()"></a>freopen()</h3><ul>
<li>把一个新的文件名 <strong>filename</strong> 与给定的打开的流 <strong>stream</strong> 关联，同时关闭流中的旧文件。</li>
<li>如果文件指针并没有指向已经打开的文件，则<code>freopen()</code>等同于<code>fopen()</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟`fopen()`相比，就是多出了第三个参数，表示要复用的文件指针。其他两个参数都一样，分别是文件名和打开模式。</span></span><br><span class="line"><span class="comment">// `freopen()`的返回值是它的第三个参数（文件指针）。如果打开失败（比如文件不存在），会返回空指针 NULL。</span></span><br><span class="line"><span class="function">FILE* <span class="title">freopen</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">char</span>* mode, FILE stream)</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将文件<code>output.txt</code>关联到<code>stdout</code>，此后向<code>stdout</code>写入的内容，都会写入<code>output.txt</code>。由于<code>printf()</code>默认就是输出到<code>stdout</code>，所以运行上面的代码以后，文件<code>output.txt</code>会被写入<code>hello</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, i2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i); </span><br><span class="line">freopen(<span class="string">&quot;someints.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i2);</span><br></pre></td></tr></table></figure>

<p>一共调用了两次<code>scanf()</code>，第一次调用是从键盘读取，然后使用<code>freopen()</code>将<code>stdin</code>指针关联到某个文件，第二次调用就会从该文件读取。</p>
<p>某些系统允许使用<code>freopen()</code>，改变文件的打开模式。这时，<code>freopen()</code>的第一个参数应该是 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将`stdout`的打开模式从`w`改成了`wb`。</span></span><br><span class="line">freopen(<span class="literal">NULL</span>, <span class="string">&quot;wb&quot;</span>, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>



<h3 id="fgetc-，getc"><a href="#fgetc-，getc" class="headerlink" title="fgetc()，getc()"></a>fgetc()，getc()</h3><ul>
<li><code>fgetc()</code>和<code>getc()</code>用于从文件读取一个字符。</li>
<li>它们的用法跟<code>getchar()</code>类似，区别是<code>getchar()</code>只用来从<code>stdin</code>读取，而这两个函数是从任意指定的文件读取。</li>
<li>它们的原型定义在头文件<code>stdio.h</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>getc()</code>一般用宏来实现，而<code>fgetc()</code>是函数实现，所以前者的性能可能更好一些。</p>
<blockquote>
<p>注意，虽然这两个函数返回的是一个字符，但是它们的返回值类型却不是<code>char</code>，而是<code>int</code>，这是因为读取失败的情况下，它们会返回 EOF，这个值一般是<code>-1</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  <span class="keyword">while</span> ((c = getc(fp)) != EOF)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="fputc-，putc"><a href="#fputc-，putc" class="headerlink" title="fputc()，putc()"></a>fputc()，putc()</h3><ul>
<li><code>fputc()</code>和<code>putc()</code>用于向文件写入一个字符。</li>
<li>它们的用法跟<code>putchar()</code>类似，区别是<code>putchar()</code>是向<code>stdout</code>写入，而这两个函数是向文件写入。</li>
<li>它们的原型定义在头文件<code>stdio.h</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> <span class="keyword">char</span>, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> <span class="keyword">char</span>, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>putc()</code>通常是使用宏来实现，而<code>fputc()</code>只作为函数来实现，所以理论上，<code>putc()</code>的性能会好一点。</p>
<p>写入成功时，它们返回写入的字符；写入失败时，返回 EOF。</p>
<h3 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf()"></a>fprintf()</h3><ul>
<li><code>fprintf()</code>用于向文件写入格式化字符串，</li>
<li>用法与<code>printf()</code>类似。区别是<code>printf()</code>总是写入<code>stdout</code>，而<code>fprintf()</code>则是写入指定的文件，它的第一个参数必须是一个文件指针。</li>
<li>它的原型定义在头文件<code>stdio.h</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE* stream, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定`fprintf()`写入`stdout`，结果就等同于调用`printf()`。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件指针`fp`写入指定格式的字符串。</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;Sum: %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向`stderr`输出错误信息</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Something number.\n&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="fscanf"><a href="#fscanf" class="headerlink" title="fscanf()"></a>fscanf()</h3><ul>
<li><code>fscanf()</code>用于按照给定的模式，从文件中读取内容，</li>
<li>用法跟<code>scanf()</code>类似。区别是<code>scanf()</code>总是从<code>stdin</code>读取数据，而<code>fscanf()</code>是从文件读入数据，</li>
<li><code>fscanf()</code>的返回值是赋值成功的变量数量，如果赋值失败会返回 EOF。它的原型定义在头文件<code>stdio.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE* stream, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `fscanf()`从文件`fp`里面，读取两个整数，放入变量`i`和`j`。</span></span><br><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>



<ul>
<li><p>使用<code>fscanf()</code>的前提是知道文件的结构，它的占位符解析规则与<code>scanf()</code>完全一致。</p>
</li>
<li><p>由于<code>fscanf()</code>可以连续读取，直到读到文件尾，或者发生错误（读取失败、匹配失败），才会停止读取，所以<code>fscanf()</code>通常放在循环里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `fscanf()`依次读取文件的每个词，将它们一行打印一个，直到文件结束。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, words) == <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">puts</span>(words);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><p><code>fgets()</code>用于从文件读取指定长度的字符串，它名字的第一个字符是<code>f</code>，就代表<code>file</code>。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数`str`是一个字符串指针，用于存放读取的内容。第二个参数`STRLEN`指定读取的长度，第三个参数是一个 FILE 指针，指向要读取的文件。</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fgets</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> STRLEN, File* fp)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>fgets()</code>读取 STRLEN - 1 个字符之后，或者遇到换行符与文件结尾，就会停止读取，然后在已经读取的内容末尾添加一个空字符<code>\0</code>，使之成为一个字符串。</p>
<blockquote>
<p>注意，<code>fgets()</code>会将换行符（<code>\n</code>）存储进字符串。</p>
</blockquote>
<p>如果<code>fgets</code>的第三个参数是<code>stdin</code>，就可以读取标准输入，等同于<code>scanf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>



<p><code>fgets()</code>可以用来读取文件的每一行，下面是读取文件所有行的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">1024</span>];  <span class="comment">// 数组必须足够大，足以放下一行</span></span><br><span class="line">  <span class="keyword">int</span> linecount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="comment">// 每读取一行，输出行号和该行的内容。</span></span><br><span class="line">  <span class="keyword">while</span> (fgets(s, <span class="keyword">sizeof</span> s, fp) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: %s&quot;</span>, ++linecount, s);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面的例子是循环读取用户的输入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> words[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter strings (q to quit):&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用户输入的字符串大于9个字符，`fgets()`会多次读取。直到遇到`q` + 回车键，才会退出循环。</span></span><br><span class="line"><span class="keyword">while</span> (fgets(words, <span class="number">10</span>, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (words[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span> &amp;&amp; words[<span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h3><ul>
<li><code>fputs()</code>函数用于向文件写入字符串，写入成功时，<code>fputs()</code>返回一个非负整数，否则返回 EOF。</li>
<li>和<code>puts()</code>函数只有一点不同，那就是它不会在字符串末尾添加换行符。这是因为<code>fgets()</code>保留了换行符，所以<code>fputs()</code>就不添加了。</li>
<li><code>fputs()</code>函数通常与<code>fgets()</code>配对使用。</li>
<li>它的原型定义在<code>stdio.h</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受两个参数，第一个参数是字符串指针，第二个参数是要写入的文件指针。</span></span><br><span class="line"><span class="comment">// 如果第二个参数为`stdout`（标准输出），就是将内容输出到计算机屏幕，等同于`printf()`。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先用`fgets()`从`stdin`读取用户输入，然后用`fputs()`输出到`stdout`。</span></span><br><span class="line"><span class="keyword">char</span> words[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter a string, please.&quot;</span>);</span><br><span class="line">fgets(words, <span class="number">14</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;This is your string:&quot;</span>);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>



<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a>fwrite()</h3><p><code>fwrite()</code>用来一次性写入较大的数据块，主要用途是将<strong>数组数据一次性写入文件，适合写入二进制数据</strong>。它的原型定在<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">void</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> nmemb,</span></span></span><br><span class="line"><span class="params"><span class="function">  FILE* fp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它接受四个参数。</p>
<ul>
<li><code>ptr</code>：数组指针。</li>
<li><code>size</code>：每个数组成员的大小，单位字节。</li>
<li><code>nmemb</code>：数组成员的数量。</li>
<li><code>fp</code>：要写入的文件指针。</li>
</ul>
<blockquote>
<p>注意，<code>fwrite()</code>原型的第一个参数类型是<code>void*</code>，这是一个无类型指针，编译器会自动将参数指针转成<code>void*</code>类型。正是由于<code>fwrite()</code>不知道数组成员的类型，所以才需要知道每个成员的大小（第二个参数）和成员数量（第三个参数）。</p>
</blockquote>
<p><code>fwrite()</code>函数的返回值是成功写入的数组成员的数量（注意不是字节数）。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现写入错误，只写入了一部分成员，返回值会比<code>nmemb</code>小。</p>
<p>要将整个数组<code>arr</code>写入文件，可以采用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `sizeof(a[0])`是每个数组成员占用的字节，`sizeof(a) / sizeof(a[0])`是整个数组的成员数量。</span></span><br><span class="line">fwrite(</span><br><span class="line">  arr,</span><br><span class="line">  <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  fp</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个大小为256字节的字符串写入文件。</span></span><br><span class="line"><span class="comment">// 数组`buffer`每个成员是1个字节，一共有256个成员。由于`fwrite()`是连续内存复制，所以写成`fwrite(buffer, 256, 1, fp)`也能达到目的。</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">fwrite(buffer, <span class="number">1</span>, <span class="number">256</span>, fp);</span><br></pre></td></tr></table></figure>



<p><strong>任何类型的数据都可以看成是1字节数据组成的数组，或者是一个成员的数组，所以<code>fwrite()</code>实际上可以写入任何类型的数据，而不仅仅是数组</strong>。</p>
<p>比如，<code>fwrite()</code>可以将一个 Struct 结构写入文件保存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `s`是一个 Struct 结构指针，可以看成是一个成员的数组。</span></span><br><span class="line">fwrite(&amp;s, <span class="keyword">sizeof</span>(s), <span class="number">1</span>, fp);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果<code>s</code>的属性包含指针，存储时需要小心，因为保存指针可能没意义，还原出来的时候，并不能保证指针指向的数据还存在。</p>
</blockquote>
<ul>
<li><code>fwrite()</code>和``fread()`，比较适合读写二进制数据，因为它们不会对写入的数据进行解读。</li>
<li>二进制数据可能包含空字符<code>\0</code>，这是 C 语言的字符串结尾标记，所以读写二进制文件，不适合使用文本读写函数（比如<code>fprintf()</code>等）。</li>
</ul>
<p>下面是一个写入二进制文件的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[] = &#123;<span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">88</span>, <span class="number">255</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入二进制文件时，`fopen()`要使用`wb`模式打开，表示二进制写入。</span></span><br><span class="line">  fp = fopen(<span class="string">&quot;output.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  <span class="comment">// `fwrite()`可以把数据解释成单字节数组，因此它的第二个参数是`sizeof(char)`，第三个参数是数组的总字节数`sizeof(bytes)`。</span></span><br><span class="line">  fwrite(bytes, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="keyword">sizeof</span>(bytes), fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h3><p><code>fread()</code>函数用于一次性从文件读取较大的数据块，主要用途是<strong>将文件内容读入一个数组，适合读取二进制数据</strong>。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">void</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> nmemb,</span></span></span><br><span class="line"><span class="params"><span class="function">  FILE* fp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它接受四个参数，与<code>fwrite()</code>完全相同。</p>
<ul>
<li><code>ptr</code>：数组地址。</li>
<li><code>size</code>：数组的成员数量。</li>
<li><code>nmemb</code>：每个数组成员的大小。</li>
<li><code>fp</code>：文件指针。</li>
</ul>
<p>要将文件内容读入数组<code>arr</code>，可以采用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fread(</span><br><span class="line">  arr,</span><br><span class="line">  <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  fp</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组长度（第二个参数）和每个成员的大小（第三个参数）的乘积，就是数组占用的内存空间的大小。<code>fread()</code>会从文件（第四个参数）里面读取相同大小的内容，然后将<code>ptr</code>（第一个参数）指向这些内容的内存地址。</p>
<p>将文件内容读入一个10个成员的双精度浮点数数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> earnings[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 每个数组成员的大小是`sizeof(double)`，一个有10个成员，就会从文件`fp`读取`sizeof(double) * 10`大小的内容。</span></span><br><span class="line">fread(earnings, <span class="keyword">sizeof</span>(<span class="keyword">double</span>), <span class="number">10</span>, fp);</span><br></pre></td></tr></table></figure>

<p><code>fread()</code>函数的返回值是成功读取的数组成员的数量。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现读取错误或读到文件结尾，该返回值就会比<code>nmemb</code>小。所以，检查<code>fread()</code>的返回值是非常重要的。</p>
<p><code>fread()</code>和<code>fwrite()</code>可以配合使用。在程序终止之前，使用<code>fwrite()</code>将数据保存进文件，下次运行时再用<code>fread()</code>将数据还原进入内存。</p>
<p>下面是读取二进制文件<code>output.bin</code>的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;output.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (fread(&amp;c, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">1</span>, fp) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="feof"><a href="#feof" class="headerlink" title="feof()"></a>feof()</h3><p><code>feof()</code>函数判断文件的内部指针是否指向文件结尾。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果已经到达文件结尾，会返回一个非零值（表示 true），否则返回`0`（表示 false）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>



<p>诸如<code>fgetc()</code>这样的文件读取函数，如果返回 EOF，有两种可能，一种可能是已读取到文件结尾，另一种可能是出现读取错误。<code>feof()</code>可以用来判断到底是那一种情况。</p>
<p>下面是通过<code>feof()</code>判断是否到达文件结尾，从而循环读取整个文件的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">FILE* cfPtr = fopen(<span class="string">&quot;clients.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!feof(cfPtr)) &#123;</span><br><span class="line">  <span class="built_in">fscanf</span>(cfPtr, <span class="string">&quot;%d%s\n&quot;</span>, &amp;num, name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, num, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(cfPtr);</span><br></pre></td></tr></table></figure>

<p>上面示例通过循环判断<code>feof()</code>是否读到文件结尾，从而实现读出整个文件内容。</p>
<p><code>feof()</code>为真时，可以通过<code>fseek()</code>、<code>rewind()</code>、<code>fsetpos()</code>函数改变文件内部读写位置的指示器，从而清除这个函数的状态。</p>
<h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h3><p>每个文件指针都有一个内部指示器（内部指针），记录当前打开的文件的读写位置（file position），即下一次读写从哪里开始。文件操作函数（比如<code>getc()</code>、<code>fgets()</code>、<code>fscanf()</code>和<code>fread()</code>等）都从这个指示器指定的位置开始按顺序读写文件。</p>
<p>如果希望改变这个指示器，将它移到文件的指定位置，可以使用<code>fseek()</code>函数。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE* stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>fseek()</code>接受3个参数。</p>
<ul>
<li><code>stream</code>：文件指针。</li>
<li><code>offset</code>：距离基准（第三个参数）的字节数。类型为 long int，可以为正值（向文件末尾移动）、负值（向文件开始处移动）或 0（保持不动）。</li>
<li><code>whence</code>：位置基准，用来确定计算起点。它的值是以下三个宏（定义在<code>stdio.h</code>）：<code>SEEK_SET</code>（文件开始处）、<code>SEEK_CUR</code>（内部指针的当前位置）、<code>SEEK_END</code>（文件末尾）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位到文件开始处</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前位置前移2个字节</span></span><br><span class="line">fseek(fp, <span class="number">2L</span>, SEEK_CUR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">10L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件倒数第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, SEEK_END);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fseek()</code>的第二个参数为 long 类型，所以移动距离必须加上后缀<code>L</code>，将其转为 long 类型。</p>
<p>下面的示例逆向输出文件的所有字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (count = <span class="number">1L</span>; count &lt;= size; count++) &#123;</span><br><span class="line">  fseek(fp, -count, SEEK_END);</span><br><span class="line">  ch = getc(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<code>fseek()</code>最好只用来操作二进制文件，不要用来读取文本文件。因为文本文件的字符有不同的编码，某个位置的准确字节位置不容易确定。</p>
</blockquote>
<p>正常情况下，<code>fseek()</code>的返回值为0。如果发生错误（如移动的距离超出文件的范围），返回值为非零值（比如<code>-1</code>)。</p>
<h3 id="ftell"><a href="#ftell" class="headerlink" title="ftell()"></a>ftell()</h3><p><code>ftell()</code>函数返回<strong>文件内部指示器的当前位置</strong>。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针作为参数。返回值是一个 long 类型的整数，表示内部指示器的当前位置，即文件开始处到当前位置的字节数，<code>0</code>表示文件开始处。如果发生错误，<code>ftell()</code>返回<code>-1L</code>。</p>
<p><code>ftell()</code>可以跟<code>fseek()</code>配合使用，先记录内部指针的位置，一系列操作过后，再用<code>fseek()</code>返回原来的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> file_pos = ftell(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一系列文件操作之后</span></span><br><span class="line">fseek(fp, file_pos, SEEK_SET);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先将指示器定位到文件结尾，然后得到文件开始处到结尾的字节数。</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">size = ftell(fp);</span><br></pre></td></tr></table></figure>



<h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h3><ul>
<li><code>rewind()</code>函数可以让<strong>文件的内部指示器回到文件开始处</strong>。它的原型定义在<code>stdio.h</code>。</li>
<li><code>rewind(fp)</code>基本等价于<code>fseek(fp, 0l, seek_set)</code>，唯一的区别是<code>rewind()</code>没有返回值，而且会清除当前文件的错误指示器。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(file* stream)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="fgetpos-，fsetpos"><a href="#fgetpos-，fsetpos" class="headerlink" title="fgetpos()，fsetpos()"></a>fgetpos()，fsetpos()</h3><ul>
<li><code>fseek()</code>和<code>ftell()</code>有一个潜在的问题，那就是它们都把文件大小限制在 long int 类型能表示的范围内。</li>
<li>这看起来相当大，但是在32位计算机上，long int 的长度为4个字节，能够表示的范围最大为 4GB。随着存储设备的容量迅猛增长，文件也越来越大，往往会超出这个范围。</li>
<li>鉴于此，C 语言新增了两个处理大文件的新定位函数：<code>fgetpos()</code>和<code>fsetpos()</code>。执行成功时，<code>fgetpos()</code>和<code>fsetpos()</code>都会返回<code>0</code>，否则返回非零值。</li>
<li>它们的原型都定义在头文件<code>stdio.h</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE* stream, <span class="keyword">fpos_t</span>* pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE* stream, <span class="keyword">const</span> <span class="keyword">fpos_t</span>* pos)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>fgetpos()</code>函数会将文件内部指示器的当前位置，存储在指针变量<code>pos</code>。该函数接受两个参数，第一个是文件指针，第二个存储指示器位置的变量。</p>
<p><code>fsetpos()</code>函数会将文件内部指示器的位置，移动到指针变量<code>pos</code>指定的地址。</p>
<blockquote>
<p>注意，变量<code>pos</code>必须是通过调用<code>fgetpos()</code>方法获得的。<code>fsetpos()</code>的两个参数与<code>fgetpos()</code>必须是一样的。</p>
</blockquote>
<p>记录文件内部指示器位置的指针变量<code>pos</code>，类型为<code>fpos_t*</code>（file position type 的缩写，意为文件定位类型）。它不一定是整数，也可能是一个 Struct 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先用`fgetpos()`获取内部指针的位置，后面再用`fsetpos()`恢复指针的位置。</span></span><br><span class="line"><span class="keyword">fpos_t</span> file_pos;</span><br><span class="line">fgetpos(fp, &amp;file_pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一系列文件操作之后</span></span><br><span class="line">fsetpos(fp, &amp;file_pos);</span><br></pre></td></tr></table></figure>



<h3 id="ferror-，clearerr"><a href="#ferror-，clearerr" class="headerlink" title="ferror()，clearerr()"></a>ferror()，clearerr()</h3><ul>
<li>所有的文件操作函数如果执行失败，都会在文件指针里面记录错误状态。后面的操作只要读取错误指示器，就知道前面的操作出错了。</li>
<li><code>ferror()</code>函数用来返回错误指示器的状态。可以通过这个函数，判断前面的文件操作是否成功。</li>
<li>它的原型定义在头文件<code>stdio.h</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果前面的操作出现错误，`ferror()`就会返回一个非零整数（表示 true），否则返回`0`。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>



<p><code>clearerr()</code>函数用来重置出错指示器。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> c = fgetc(fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ferror(fp)) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;读取文件：file.txt 时发生错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clearerr(fp);</span><br></pre></td></tr></table></figure>



<p>文件操作函数如果正常执行，<code>ferror()</code>和<code>feof()</code>都会返回零。如果执行不正常，就要判断到底是哪里出了问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;n) != <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ferror(fp)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;io error\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end of file\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clearerr(fp);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，当<code>fscanf()</code>函数报错时，通过检查<code>ferror()</code>和<code>feof()</code>，确定到底发生什么问题。这两个指示器改变状态后，会保持不变，所以要用<code>clearerr()</code>清除它们，<code>clearerr()</code>可以同时清除两个指示器。</p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove()</code>函数用于删除指定文件。如果删除成功，<code>remove()</code>返回<code>0</code>，否则返回非零值。。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除`foo.txt`文件。</span></span><br><span class="line">remove(<span class="string">&quot;foo.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，删除文件必须是在文件关闭的状态下。如果是用<code>fopen()</code>打开的文件，必须先用<code>fclose()</code>关闭后再删除。</p>
</blockquote>
<h3 id="rename"><a href="#rename" class="headerlink" title="rename()"></a>rename()</h3><p><code>rename()</code>函数用于文件改名，也用于移动文件。如果改名成功，<code>rename()</code>返回<code>0</code>，否则返回非零值。。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* old_filename, <span class="keyword">const</span> <span class="keyword">char</span>* new_filename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将`foo.txt`改名为`bar.txt`。</span></span><br><span class="line">rename(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，改名后的文件不能与现有文件同名。另外，如果要改名的文件已经打开了，必须先关闭，然后再改名，对打开的文件进行改名会失败。</p>
</blockquote>
<h2 id="变量说明符"><a href="#变量说明符" class="headerlink" title="变量说明符"></a>变量说明符</h2><p>C 语言允许声明变量的时候，加上一些特定的说明符（specifier），为编译器提供变量行为的额外信息。它的主要作用是帮助编译器优化代码，有时会对程序行为产生影响。</p>
<h3 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h3><p><code>const</code>说明符表示变量是只读的，不得被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">5</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于指针变量，`const`有两种写法，含义是不一样的。</span></span><br><span class="line"><span class="comment">// 如果`const`在`*`前面，表示指针指向的值不可修改。</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * x  <span class="comment">// 或者 const int * x</span></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* x = &amp;p;</span><br><span class="line">(*x)++; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果`const`在`*`后面，表示指针包含的地址不可修改。</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> x</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> x = &amp;p;</span><br><span class="line">x++; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两者可以结合起来。</span></span><br><span class="line"><span class="comment">// 两个`const`意味着，`x`包含的内存地址以及`x`指向的字符串，都不能修改。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> x;</span><br></pre></td></tr></table></figure>



<p><code>const</code>的一个用途，就是防止函数体内修改函数参数。如果某个参数在函数体内不会被修改，可以在函数声明时，对该参数添加<code>const</code>说明符。这样的话，使用这个函数的人看到原型里面的<code>const</code>，就知道调用函数前后，参数数组保持不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数`find`的参数数组`arr`有`const`说明符，就说明该数组在函数内部将保持不变。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* arr, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>



<p>有一种情况需要注意，如果一个指针变量指向<code>const</code>变量，那么该指针变量也不应该被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* j = &amp;i;</span><br><span class="line">*j = <span class="number">2</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j</code>是一个指针变量，指向变量<code>i</code>，即<code>j</code>和<code>i</code>指向同一个地址。<code>j</code>本身没有<code>const</code>说明符，但是<code>i</code>有。这种情况下，<code>j</code>指向的值也不能被修改。</p>
<h3 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h3><p><code>static</code>说明符对于全局变量和局部变量有不同的含义。</p>
<ul>
<li><p>用于局部变量（位于块作用域内部）。</p>
<p>表示该变量的值会<strong>在函数每次执行后得到保留，下次执行时不会进行初始化</strong>，就类似于一个只用于函数内部的全局变量。由于不必每次执行函数时，都对该变量进行初始化，这样可以提高函数的执行速度。</p>
</li>
<li><p>用于全局变量（位于块作用域外部）。</p>
<p>表示该变量只用于当前文件，其他源码文件不可以引用该变量，即该变量不会被链接（link）。</p>
</li>
</ul>
<p><code>static</code>修饰的变量，初始化时，值不能等于变量，必须是常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> m = n; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>只在当前文件里面使用的函数，也可以声明为<code>static</code>，表明该函数只在当前文件使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p><code>auto</code>说明符表示<strong>该变量的存储，由编译器自主分配内存空间，且只存在于定义时所在的作用域，退出作用域时会自动释放</strong>。</p>
<p>由于只要不是<code>extern</code>的变量（外部变量），都是由编译器自主分配内存空间的，这属于默认行为，所以该说明符没有实际作用，一般都省略不写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>



<h3 id="extern-1"><a href="#extern-1" class="headerlink" title="extern"></a>extern</h3><p><code>extern</code>说明符表示，该变量在其他文件里面声明，没有必要在当前文件里面为它分配空间。<strong>通常用来表示，该变量是多个文件共享的</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `a`是`extern`变量，表示该变量在其他文件里面定义和初始化，当前文件不必为它分配存储空间。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>

<p>但是，变量声明时，同时进行初始化，<code>extern</code>就会无效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `extern`对变量初始化的声明是无效的。这是为了防止多个`extern`对同一个变量进行多次初始化。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p>函数内部使用<code>extern</code>声明变量，就相当于该变量是静态存储，每次执行时都要从外部获取它的值。</p>
<p>函数本身默认是<code>extern</code>，即该函数可以被外部文件共享，通常省略<code>extern</code>不写。如果只希望函数在当前文件可用，那就需要在函数前面加上<code>static</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><p><code>register</code>说明符向编译器表示，<strong>该变量是经常使用的，应该提供最快的读取速度，所以应该放进寄存器</strong>。但是，编译器可以忽略这个说明符，不一定按照这个指示行事。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `register`提示编译器，变量`a`会经常用到，要为它提供最快的读取速度。</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>register</code>只对声明在代码块内部的变量有效。</p>
</blockquote>
<p>设为<code>register</code>的变量，不能获取它的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `&amp;a`会报错，因为变量`a`可能放在寄存器里面，无法获取内存地址。</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">// 编译器报错</span></span><br></pre></td></tr></table></figure>



<p>如果数组设为<code>register</code>，也不能获取整个数组或任一个数组成员的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = a;  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">int</span> a = *(a + <span class="number">2</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>历史上，CPU 内部的缓存，称为寄存器（register）。与内存相比，寄存器的访问速度快得多，所以使用它们可以提高速度。但是它们不在内存之中，所以没有内存地址，这就是为什么不能获取指向它们的指针地址。</li>
<li>现代编译器已经有巨大的进步，不管是否使用<code>register</code>关键字，都会尽可能使用寄存器，所以不保证一定会把这些变量放到寄存器。</li>
</ul>
</blockquote>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code>说明符<strong>表示所声明的变量，可能会预想不到地发生变化</strong>（即其他程序可能会更改它的值），不受当前程序控制，因此编译器不要对这类变量进行优化，每次使用时都应该查询一下它的值。硬件设备的编程中，这个说明符很常用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> foo;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span>* bar;</span><br></pre></td></tr></table></figure>

<p><code>volatile</code>的目的是阻止编译器对变量行为进行优化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> foo = x;</span><br><span class="line"><span class="comment">// 其他语句，假设没有改变 x 的值</span></span><br><span class="line"><span class="keyword">int</span> bar = x;</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于变量<code>foo</code>和<code>bar</code>都等于<code>x</code>，而且<code>x</code>的值也没有发生变化，所以编译器可能会把<code>x</code>放入缓存，直接从缓存读取值（而不是从 x 的原始内存位置读取），然后对<code>foo</code>和<code>bar</code>进行赋值。如果<code>x</code>被设定为<code>volatile</code>，编译器就不会把它放入缓存，每次都从原始位置去取<code>x</code>的值，因为在两次读取之间，其他程序可能会改变<code>x</code>。</p>
<h3 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h3><p><code>restrict</code>说明符<strong>允许编译器优化某些代码</strong>。它只能用于指针，表明该指针是访问数据的唯一方式。如果编译器知道某块内存只能用一个方式访问，可能可以更好地优化代码，因为不用担心其他地方会修改值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `restrict`表示变量`pt`是访问 malloc 所分配内存的唯一方式。</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">restrict</span> pt = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>



<p>下面例子的变量<code>foo</code>，就不能使用<code>restrict</code>修饰符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量`foo`指向的内存，可以用`foo`访问，也可以用`bar`访问，因此就不能将`foo`设为 restrict。</span></span><br><span class="line"><span class="keyword">int</span> foo[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>* bar = foo;</span><br></pre></td></tr></table></figure>



<p><code>restrict</code>用于函数参数时，表示参数的内存地址之间没有重叠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数声明里的`restrict`表示，参数`a`和参数`b`的内存地址没有重叠。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">restrict</span> a, <span class="keyword">int</span>* <span class="keyword">restrict</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  t = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="多文件项目"><a href="#多文件项目" class="headerlink" title="多文件项目"></a>多文件项目</h2><p>一个软件项目往往包含多个源码文件，编译时需要将这些文件一起编译，生成一个可执行文件。</p>
<p>假定一个项目有两个源码文件<code>foo.c</code>和<code>bar.c</code>，其中<code>foo.c</code>是主文件，<code>bar.c</code>是库文件。所谓“主文件”，就是包含了<code>main()</code>函数的项目入口文件，里面会引用库文件定义的各种函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File foo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，主文件<code>foo.c</code>调用了函数<code>add()</code>，这个函数是在库文件<code>bar.c</code>里面定义的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，将这两个文件一起编译。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o foo foo.c bar.c</span><br><span class="line"></span><br><span class="line"># 更省事的写法</span><br><span class="line">$ gcc -o foo *.c</span><br></pre></td></tr></table></figure>

<p>上面命令中，gcc 的<code>-o</code>参数指定生成的二进制可执行文件的文件名，本例是<code>foo</code>。</p>
<p>这个命令运行后，编译器会发出警告，原因是在编译<code>foo.c</code>的过程中，编译器发现一个不认识的函数<code>add()</code>，<code>foo.c</code>里面没有这个函数的原型或者定义。因此，最好修改一下<code>foo.c</code>，在文件头部加入<code>add()</code>的原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File foo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再编译就没有警告了。</p>
<p>你可能马上就会想到，如果有多个文件都使用这个函数<code>add()</code>，那么每个文件都需要加入函数原型。一旦需要修改函数<code>add()</code>（比如改变参数的数量），就会非常麻烦，需要每个文件逐一改动。所以，通常的做法是新建一个专门的头文件<code>bar.h</code>，放置所有在<code>bar.c</code>里面定义的函数的原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后使用<code>include</code>命令，在用到这个函数的源码文件里面加载这个头文件<code>bar.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File foo.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>#include &quot;bar.h&quot;</code>表示加入头文件<code>bar.h</code>。这个文件没有放在尖括号里面，表示它是用户提供的；它没有写路径，就表示与当前源码文件在同一个目录。</p>
<p>然后，最好在<code>bar.c</code>里面也加载这个头文件，这样可以让编译器验证，函数原型与函数定义是否一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在重新编译，就可以顺利得到二进制可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o foo foo.c bar.c</span><br></pre></td></tr></table></figure>



<h3 id="重复加载"><a href="#重复加载" class="headerlink" title="重复加载"></a>重复加载</h3><p>头文件里面还可以加载其他头文件，因此有可能产生重复加载。比如，<code>a.h</code>和<code>b.h</code>都加载了<code>c.h</code>，然后<code>foo.c</code>同时加载了<code>a.h</code>和<code>b.h</code>，这意味着<code>foo.c</code>会编译两次<code>c.h</code>。</p>
<p>最好避免这种重复加载，虽然多次定义同一个函数原型并不会报错，但是有些语句重复使用会报错，比如多次重复定义同一个 Struct 数据结构。解决重复加载的常见方法是，在头文件里面设置一个专门的宏，加载时一旦发现这个宏存在，就不再继续加载当前文件了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File bar.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BAR_H</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> BAR_H</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面示例中，头文件<code>bar.h</code>使用<code>#ifndef</code>和<code>#endif</code>设置了一个条件判断。每当加载这个头文件时，就会执行这个判断，查看有没有设置过宏<code>BAR_H</code>。如果设置过了，表明这个头文件已经加载过了，就不再重复加载了，反之就先设置一下这个宏，然后加载函数原型。</p>
<h3 id="extern-说明符"><a href="#extern-说明符" class="headerlink" title="extern 说明符"></a>extern 说明符</h3><p>当前文件还可以使用其他文件定义的变量，这时要使用<code>extern</code>说明符，在当前文件中声明，这个变量是其他文件定义的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> myVar;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>extern</code>说明符告诉编译器，变量<code>myvar</code>是其他脚本文件声明的，不需要在这里为它分配内存空间。</p>
<p>由于不需要分配内存空间，所以<code>extern</code>声明数组时，不需要给出数组长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a[];</span><br></pre></td></tr></table></figure>

<p>这种共享变量的声明，可以直接写在源码文件里面，也可以放在头文件中，通过<code>#include</code>指令加载。</p>
<h3 id="static-说明符"><a href="#static-说明符" class="headerlink" title="static 说明符"></a>static 说明符</h3><p>正常情况下，当前文件内部的全局变量，可以被其他文件使用。有时候，不希望发生这种情况，而是希望某个变量只局限在当前文件内部使用，不要被其他文件引用。</p>
<p>这时可以在声明变量的时候，使用<code>static</code>关键字，使得该变量变成当前文件的私有变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>foo</code>只能在当前文件里面使用，其他文件不能引用。</p>
<h3 id="编译策略"><a href="#编译策略" class="headerlink" title="编译策略"></a>编译策略</h3><p>多个源码文件的项目，编译时需要所有文件一起编译。哪怕只是修改了一行，也需要从头编译，非常耗费时间。</p>
<p>为了节省时间，通常的做法是将编译拆分成两个步骤。</p>
<ol>
<li>第一步，使用 GCC 的<code>-c</code>参数，将每个源码文件单独编译为对象文件（object file）。</li>
<li>第二步，将所有对象文件链接在一起，合并生成一个二进制可执行文件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c foo.c <span class="comment"># 生成 foo.o</span></span><br><span class="line">$ gcc -c bar.c <span class="comment"># 生成 bar.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更省事的写法</span></span><br><span class="line">$ gcc -c *.c</span><br></pre></td></tr></table></figure>

<p>对象文件不是可执行文件，只是编译过程中的一个阶段性产物，文件名与源码文件相同，但是后缀名变成了<code>.o</code>。</p>
<p>得到所有的对象文件以后，再次使用<code>gcc</code>命令，将它们通过链接，合并生成一个可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o foo foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更省事的写法</span></span><br><span class="line">$ gcc -o foo *.o</span><br></pre></td></tr></table></figure>

<p>以后，修改了哪一个源文件，就将这个文件重新编译成对象文件，其他文件不用重新编译，可以继续使用原来的对象文件，最后再将所有对象文件重新链接一次就可以了。由于链接的耗时大大短于编译，这样做就节省了大量时间。</p>
<h3 id="make-命令"><a href="#make-命令" class="headerlink" title="make 命令"></a>make 命令</h3><p>大型项目的编译，如果全部手动完成，是非常麻烦的，容易出错。一般会使用专门的自动化编译工具，比如 make。</p>
<p>make 是一个命令行工具，使用时会自动在当前目录下搜索配置文件 makefile（也可以写成 Makefile）。该文件定义了所有的编译规则，每个编译规则对应一个编译产物。为了得到这个编译产物，它需要知道两件事。</p>
<ul>
<li>依赖项（生成该编译产物，需要用到哪些文件）</li>
<li>生成命令（生成该编译产物的命令）</li>
</ul>
<p>比如，对象文件<code>foo.o</code>是一个编译产物，它的依赖项是<code>foo.c</code>，生成命令是<code>gcc -c foo.c</code>。对应的编译规则如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line">  gcc -c foo.c</span><br></pre></td></tr></table></figure>

<p>上面示例中，编译规则由两行组成。第一行首先是编译产物，冒号后面是它的依赖项，第二行则是生成命令。</p>
<blockquote>
<p>注意，第二行的缩进必须使用 Tab 键，如果使用空格键会报错。</p>
</blockquote>
<p>完整的配置文件 makefile 由多个编译规则组成，可能是下面的样子。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo: foo.o bar.o</span></span><br><span class="line">  gcc -o foo foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">foo.o: bar.h foo.c</span></span><br><span class="line">  gcc -c foo.c</span><br><span class="line"></span><br><span class="line"><span class="section">bar.o: bar.h bar.c</span></span><br><span class="line">  gcc -c bar.c</span><br></pre></td></tr></table></figure>

<p>上面是 makefile 的一个示例文件。它包含三个编译规则，对应三个编译产物（<code>foo.o</code>、<code>bar.o</code>和<code>foo</code>），每个编译规则之间使用空行分隔。</p>
<p>有了 makefile，编译时，只要在 make 命令后面指定编译目标（编译产物的名字），就会自动调用对应的编译规则。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make foo.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ make bar.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ make foo</span><br></pre></td></tr></table></figure>

<p>上面示例中，make 命令会根据不同的命令，生成不同的编译产物。</p>
<p>如果省略了编译目标，<code>make</code>命令会执行第一条编译规则，构建相应的产物。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>make</code>后面没有编译目标，所以会执行 makefile 的第一条编译规则，本例是<code>make foo</code>。由于用户期望执行<code>make</code>后得到最终的可执行文件，所以建议总是把最终可执行文件的编译规则，放在 makefile 文件的第一条。makefile 本身对编译规则没有顺序要求。</p>
<p>make 命令的强大之处在于，它不是每次执行命令，都会进行编译，而是会检查是否有必要重新编译。具体方法是，通过检查每个源码文件的时间戳，确定在上次编译之后，哪些文件发生过变动。然后，重新编译那些受到影响的编译产物（即编译产物直接或间接依赖于那些发生变动的源码文件），不受影响的编译产物，就不会重新编译。</p>
<p>举例来说，上次编译之后，修改了<code>foo.c</code>，没有修改<code>bar.c</code>和<code>bar.h</code>。于是，重新运行<code>make foo</code>命令时，Make 就会发现<code>bar.c</code>和<code>bar.h</code>没有变动过，因此不用重新编译<code>bar.o</code>，只需要重新编译<code>foo.o</code>。有了新的<code>foo.o</code>以后，再跟<code>bar.o</code>一起，重新编译成新的可执行文件<code>foo</code>。</p>
<p>Make 这样设计的最大好处，就是自动处理编译过程，只重新编译变动过的文件，因此大大节省了时间。</p>
<h2 id="命令行环境"><a href="#命令行环境" class="headerlink" title="命令行环境"></a>命令行环境</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>C 语言程序可以从命令行接收参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 程序`foo`接收了两个命令行参数`hello`和`world`。</span></span><br><span class="line">$ ./foo hello world</span><br></pre></td></tr></table></figure>



<p>程序内部怎么拿到命令行参数呢？C 语言会把命令行输入的内容，放在一个数组里面。<code>main()</code>函数的参数可以接收到这个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `main()`函数有两个参数`argc`（argument count）和`argv`（argument variable）。</span></span><br><span class="line"><span class="comment">// 这两个参数的名字可以任意取，但是一般来说，约定俗成就是使用这两个词。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数<code>argc</code>是命令行参数的数量，由于程序名也被计算在内，所以严格地说<code>argc</code>是参数数量 + 1。</li>
<li>第二个参数<code>argv</code>是一个数组，保存了所有的命令行输入，它的每个成员是一个字符串指针。</li>
</ul>
<blockquote>
<p>以<code>./foo hello world</code>为例，</p>
<ul>
<li><code>argc</code>是3，表示命令行输入有三个组成部分：<code>./foo</code>、<code>hello</code>、<code>world</code>。</li>
<li>数组<code>argv</code>用来获取这些输入，<code>argv[0]</code>是程序名<code>./foo</code>，<code>argv[1]</code>是<code>hello</code>，<code>argv[2]</code>是<code>world</code>。</li>
<li>一般来说，<code>argv[1]</code>到<code>argv[argc - 1]</code>依次是命令行的所有参数。<code>argv[argc]</code>则是一个空指针 NULL。</li>
</ul>
</blockquote>
<p>由于字符串指针可以看成是字符数组，所以下面三种写法是等价的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 写法二</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 写法三</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv[][])</span></span></span><br></pre></td></tr></table></figure>

<p>另一方面，每个命令行参数既可以写成数组形式<code>argv[i]</code>，也可以写成指针形式<code>*(argv + i)</code>。</p>
<p>利用<code>argc</code>，可以限定函数只能有多少个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;usage: mult x y\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, atoi(argv[<span class="number">1</span>]) * atoi(argv[<span class="number">2</span>]));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>argc</code>不等于<code>3</code>就会报错，这样就限定了程序必须有两个参数，才能运行。</p>
<p>另外，<code>argv</code>数组的最后一个成员是 NULL 指针（<code>argv[argc] == NULL</code>）。所以，参数的遍历也可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>** p = argv; *p != <span class="literal">NULL</span>; p++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;arg: %s\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，指针<code>p</code>依次移动，指向<code>argv</code>的每个成员，一旦移到空指针 NULL，就表示遍历结束。由于<code>argv</code>的地址是固定的，不能执行自增运算（<code>argv++</code>），所以必须通过一个中间变量<code>p</code>，完成遍历操作。</p>
<h3 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h3><p>C 语言规定，如果<code>main()</code>函数没有<code>return</code>语句，那么结束运行的时候，默认会添加一句<code>return 0</code>，即返回整数<code>0</code>。这就是为什么<code>main()</code>语句通常约定返回一个整数值，并且返回整数<code>0</code>表示程序运行成功。如果返回非零值，就表示程序运行出了问题。</p>
<p>Bash 的环境变量<code>$?</code>可以用来读取上一个命令的返回值，从而知道是否运行成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./foo hello world</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>echo $?</code>用来打印环境变量<code>$?</code>的值，该值为<code>0</code>，就表示上一条命令运行成功，否则就是运行失败。</p>
<p>注意，只有<code>main()</code>会默认添加<code>return 0</code>，其他函数都没有这个机制。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>C 语言提供了<code>getenv()</code>函数（原型在<code>stdlib.h</code>）用来读取命令行环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* val = getenv(<span class="string">&quot;HOME&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cannot find the HOME environment variable\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Value: %s\n&quot;</span>, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getenv(&quot;HOME&quot;)</code>用来获取命令行的环境变量<code>$HOME</code>，如果这个变量为空（<code>NULL</code>），则程序报错返回。</p>
<h2 id="多字节字符"><a href="#多字节字符" class="headerlink" title="多字节字符"></a>多字节字符</h2><p>本章介绍 C 语言如何处理非英语字符。</p>
<h3 id="Unicode-简介"><a href="#Unicode-简介" class="headerlink" title="Unicode 简介"></a>Unicode 简介</h3><p>C 语言诞生时，只考虑了英语字符，使用7位的 ASCII 码表示所有字符。ASCII 码的范围是0到127，也就是100多个字符，所以<code>char</code>类型只占用一个字节，但是，如果处理非英语字符，一个字节就不够了，单单是中文，就至少有几万个字符，字符集就势必使用多个字节表示。</p>
<p>最初，不同国家有自己的字符编码方式，这样不便于多种字符的混用。因此，后来就逐渐统一到 Unicode 编码，将所有字符放入一个字符集。</p>
<p>Unicode 为每个字符提供一个号码，称为码点（code point），其中0到127的部分，跟 ASCII 码是重合的。通常使用“U+十六进制码点”表示一个字符，比如<code>U+0041</code>表示字母<code>A</code>。</p>
<p>Unicode 编码目前一共包含了100多万个字符，码点范围是 U+0000 到 U+10FFFF。完整表达整个 Unicode 字符集，至少需要三个字节。但是，并不是所有文档都需要那么多字符，比如对于 ASCII 码就够用的英语文档，如果每个字符使用三个字节表示，就会比单字节表示的文件体积大出三倍。</p>
<p>为了适应不同的使用需求，Unicode 标准委员会提供了三种不同的表示方法，表示 Unicode 码点。</p>
<ul>
<li>UTF-8：使用1个到4个字节，表示一个码点。不同的字符占用的字节数不一样。</li>
<li>UTF-16：对于U+0000 到 U+FFFF 的字符（称为基本平面），使用2个字节表示一个码点。其他字符使用4个字节。</li>
<li>UTF-32：统一使用4个字节，表示一个码点。</li>
</ul>
<p>其中，UTF-8 的使用最为广泛，因为对于 ASCII 字符（U+0000 到 U+007F），它只使用一个字节表示，这就跟 ASCII 的编码方式完全一样。</p>
<p>C 语言提供了两个宏，表示当前系统支持的编码字节长度。这两个宏都定义在头文件<code>limits.h</code>。</p>
<ul>
<li><code>MB_LEN_MAX</code>：任意支持地区的最大字节长度，定义在<code>limits.h</code>。</li>
<li><code>MB_CUR_MAX</code>：当前语言的最大字节长度，总是小于或等于<code>MB_LEN_MAX</code>，定义在<code>stdlib.h</code>。</li>
</ul>
<h3 id="字符的表示方法"><a href="#字符的表示方法" class="headerlink" title="字符的表示方法"></a>字符的表示方法</h3><p>字符表示法的本质，是将每个字符映射为一个整数，然后从编码表获得该整数对应的字符。</p>
<p>C 语言提供了不同的写法，用来表示字符的整数号码。</p>
<ul>
<li><code>\123</code>：以八进制值表示一个字符，斜杠后面需要三个数字。</li>
<li><code>\x4D</code>：以十六进制表示一个字符，<code>\x</code>后面是十六进制整数。</li>
<li><code>\u2620</code>：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，<code>\u</code>后面需要4个字符。</li>
<li><code>\U0001243F</code>：以 Unicode 码点表示一个字符（不适用于 ASCII 字符），码点以十六进制表示，<code>\U</code>后面需要8个字符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ABC\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\101\102\103\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\x41\x42\x43\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面三行都会输出<code>ABC</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\u2022 Bullet 1\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\U00002022 Bullet 1\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面两行都会输出<code>• Bullet 1</code>。</p>
<h3 id="多字节字符的表示"><a href="#多字节字符的表示" class="headerlink" title="多字节字符的表示"></a>多字节字符的表示</h3><p>C 语言预设只有基本字符，才能使用字面量表示，其它字符都应该使用码点表示，并且当前系统还必须支持该码点的编码方法。</p>
<p>所谓基本字符，指的是所有可打印的 ASCII 字符，但是有三个字符除外：@、$、`。</p>
<p>因此，遇到非英语字符，应该将其写成 Unicode 码点形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;\u6625\u5929&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); <span class="comment">// 春天</span></span><br></pre></td></tr></table></figure>



<p>如果当前系统是 UTF-8 编码，可以直接用字面量表示多字节字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<code>\u + 码点</code>和<code>\U + 码点</code>的写法，不能用来表示 ASCII 码字符（码点小于<code>0xA0</code>的字符），只有三个字符除外：<code>0x24</code>（<code>$</code>），<code>0x40</code>（<code>@</code>）和<code>0x60</code>（```）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;\u0024\u0040\u0060&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);  <span class="comment">// @$`</span></span><br></pre></td></tr></table></figure>

<p>上面代码会输出三个 Unicode 字符“@$`”，但是其它 ASCII 字符都不能用这种表示法表示。</p>
</blockquote>
<p>为了保证程序执行时，字符能够正确解读，最好将程序环境切换到本地化环境。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用`set_locale()`切换到执行环境切换到系统的本地化语言。`set_locale()`的原型定义在头文件`locale.h`</span></span><br><span class="line">set_locale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定编码语言,将程序执行环境，切换到中文环境的 UTF-8 编码。</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;zh_CN.UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>C 语言允许使用<code>u8</code>前缀，对多字节字符串指定编码方式为 UTF-8。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="string">u8&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>一旦字符串里面包含多字节字符，就意味着字符串的字节数与字符数不再一一对应了。比如，字符串的长度为10字节，就不再是包含10个字符，而可能只包含7个字符、5个字符等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_locale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="comment">// 将程序执行环境，切换到中文环境的 UTF-8 编码。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(s)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>C 语言的字符串函数只针对单字节字符有效，对于多字节字符都会失效，比如<code>strtok()</code>、<code>strchr()</code>、<code>strspn()</code>、<code>toupper()</code>、<code>tolower()</code>、<code>isalpha()</code>等不会得到正确结果。</p>
</blockquote>
<h3 id="宽字符"><a href="#宽字符" class="headerlink" title="宽字符"></a>宽字符</h3><p>上一小节的多字节字符串，每个字符的字节宽度是可变的。这种编码方式虽然使用起来方便，但是很不利于字符串处理，因此必须逐一检查每个字符占用的字节数。所以除了这种方式，C 语言还提供了确定宽度的多字节字符存储方式，称为宽字符（wide character）。</p>
<p>所谓“宽字符”，就是每个字符占用的字节数是固定的，要么是2个字节，要么是4个字节。这样的话，就很容易快速处理。</p>
<p>宽字符有一个单独的数据类型 wchar_t，每个宽字符都是这个类型。它属于整数类型的别名，可能是有符号的，也可能是无符号的，由当前实现决定。该类型的长度为16位（2个字节）或32位（4个字节），足以容纳当前系统的所有字符。它定义在头文件<code>wchar.h</code>里面。</p>
<p>宽字符的字面量必须加上前缀“L”，否则 C 语言会把字面量当作窄字符类型处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_locale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wchar_t</span> c = <span class="string">L&#x27;牛&#x27;</span>；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lc\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wchar_t</span>* s = <span class="string">L&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>上面示例中，前缀“L”在单引号前面，表示宽字符，对应<code>printf()</code>的占位符为<code>%lc</code>；在双引号前面，表示宽字符串，对应<code>printf()</code>的占位符为<code>%ls</code>。</p>
<p>宽字符串的结尾也有一个空字符，不过是宽空字符，占用多个字节。</p>
<p>处理宽字符，需要使用宽字符专用的函数，绝大部分都定义在头文件<code>wchar.h</code>。</p>
<h3 id="多字节字符处理函数"><a href="#多字节字符处理函数" class="headerlink" title="多字节字符处理函数"></a>多字节字符处理函数</h3><h4 id="mblen"><a href="#mblen" class="headerlink" title="mblen()"></a>mblen()</h4><p><code>mblen()</code>函数返回一个多字节字符占用的字符数。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mblen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* mbstr, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是多字节字符串指针，一般会检查该字符串的第一个字符；第二个参数是需要检查的字节数，这个数字不能大于当前系统单个字符占用的最大字节，一般使用<code>MB_CUR_MAX</code>。</p>
<p>它的返回值是该字符占用的字节数。如果当前字符是空的宽字符，则返回<code>0</code>；如果当前字符不是有效的多字节字符，则返回<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* mbs1 = <span class="string">&quot;春天&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mblen(mbs1, MB_CUR_MAX)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* mbs2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mblen(mbs2, MB_CUR_MAX)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串“春天”的第一个字符“春”，占用3个字节；字符串“abc”的第一个字符“a”，占用1个字节。</p>
<h4 id="wctomb"><a href="#wctomb" class="headerlink" title="wctomb()"></a>wctomb()</h4><p><code>wctomb()</code>函数（wide character to multibyte）用于将宽字符转为多字节字符。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wctomb</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">wchar_t</span> wc)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>wctomb()</code>接受两个参数，第一个参数是作为目标的多字节字符数组，第二个参数是需要转换的一个宽字符。它的返回值是多字节字符存储占用的字节数量，如果无法转换，则返回<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wchar_t</span> wc = <span class="string">L&#x27;牛&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> mbStr[<span class="number">10</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = wctomb(mbStr, wc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mbStr);  <span class="comment">// 牛</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>wctomb()</code>将宽字符“牛”转为多字节字符，<code>wctomb()</code>的返回值表示转换后的多字节字符占用3个字节。</p>
<h4 id="mbtowc"><a href="#mbtowc" class="headerlink" title="mbtowc()"></a>mbtowc()</h4><p><code>mbtowc()</code>用于将多字节字符转为宽字符。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbtowc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">wchar_t</span>* wchar,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> <span class="keyword">char</span>* mbchar,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">size_t</span> count</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它接受3个参数，第一个参数是作为目标的宽字符指针，第二个参数是待转换的多字节字符指针，第三个参数是多字节字符的字节数。</p>
<p>它的返回值是多字节字符的字节数，如果转换失败，则返回<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* mbchar = <span class="string">&quot;牛&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> wc;</span><br><span class="line"><span class="keyword">wchar_t</span>* pwc = &amp;wc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = mbtowc(pwc, mbchar, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lc\n&quot;</span>, *pwc);  <span class="comment">// 牛</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>mbtowc()</code>将多字节字符“牛”转为宽字符<code>wc</code>，返回值是<code>mbchar</code>占用的字节数（占用3个字节）。</p>
<h4 id="wcstombs"><a href="#wcstombs" class="headerlink" title="wcstombs()"></a>wcstombs()</h4><p><code>wcstombs()</code>用来将宽字符串转换为多字节字符串。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">wcstombs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">char</span>* mbstr,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> <span class="keyword">wchar_t</span>* wcstr,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">size_t</span> count</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它接受三个参数，第一个参数<code>mbstr</code>是目标的多字节字符串指针，第二个参数<code>wcstr</code>是待转换的宽字符串指针，第三个参数<code>count</code>是用来存储多字节字符串的最大字节数。</p>
<p>如果转换成功，它的返回值是成功转换后的多字节字符串的字节数，不包括尾部的字符串终止符；如果转换失败，则返回<code>-1</code>。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> mbs[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">wchar_t</span>* wcs = <span class="string">L&quot;春天&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = wcstombs(mbs, wcs, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mbs); <span class="comment">// 春天</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>wcstombs()</code>将宽字符串<code>wcs</code>转为多字节字符串<code>mbs</code>，返回值<code>6</code>表示写入<code>mbs</code>的字符串占用6个字节，不包括尾部的字符串终止符。</p>
<p>如果<code>wcstombs()</code>的第一个参数是 NULL，则返回转换成功所需要的目标字符串的字节数。</p>
<h4 id="mbstowcs"><a href="#mbstowcs" class="headerlink" title="mbstowcs()"></a>mbstowcs()</h4><p><code>mbstowcs()</code>用来将多字节字符串转换为宽字符串。它的原型定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">mbstowcs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">wchar_t</span>* wcstr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">char</span>* mbstr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> count</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它接受三个参数，第一个参数<code>wcstr</code>是目标宽字符串，第二个参数<code>mbstr</code>是待转换的多字节字符串，第三个参数是待转换的多字节字符串的最大字符数。</p>
<p>转换成功时，它的返回值是成功转换的多字节字符的数量；转换失败时，返回<code>-1</code>。如果返回值与第三个参数相同，那么转换后的宽字符串不是以 NULL 结尾的。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* mbs = <span class="string">&quot;天气不错&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> wcs[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nBytes = <span class="number">0</span>;</span><br><span class="line">nBytes = mbstowcs(wcs, mbs, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, wcs); <span class="comment">// 天气不错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nBytes); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，多字节字符串<code>mbs</code>被<code>mbstowcs()</code>转为宽字符串，成功转换了4个字符，所以该函数的返回值为4。</p>
<p>如果<code>mbstowcs()</code>的第一个参数为<code>NULL</code>，则返回目标宽字符串会包含的字符数量。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>