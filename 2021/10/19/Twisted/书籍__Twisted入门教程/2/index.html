<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;Reactor模式&quot;&gt;&lt;a href=&quot;#Reactor模式&quot; class=&quot;headerlink&quot; title=&quot;Reactor模式&quot;&gt;&lt;/a&gt;Reactor模式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Reactor模式是处理并发I/O常见的一种模式，用于同步I/O，其中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程阻塞在多路复用器上，一旦有I/O事件到来或是准备就绪，多路复用器将返回并将相应&lt;code&gt;I/O&lt;/code&gt;事件分发到对应的处理器中。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>2 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Twisted/" rel="tag">Twisted</a></div><div class="post-time">2021-10-19</div></div></div><div class="container post-header"><h1>2</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">Reactor模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%9B%9E%E8%B0%83%E9%93%BE"><span class="toc-number">2.</span> <span class="toc-text">管理回调链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Deferreds"><span class="toc-number">2.1.</span> <span class="toc-text">Deferreds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transports"><span class="toc-number">2.2.</span> <span class="toc-text">Transports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protocols"><span class="toc-number">2.3.</span> <span class="toc-text">Protocols</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Applications"><span class="toc-number">2.4.</span> <span class="toc-text">Applications</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service"><span class="toc-number">2.5.</span> <span class="toc-text">Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Application"><span class="toc-number">2.6.</span> <span class="toc-text">Application</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TAC%E6%96%87%E4%BB%B6"><span class="toc-number">2.7.</span> <span class="toc-text">TAC文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#twistd"><span class="toc-number">2.8.</span> <span class="toc-text">twistd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Plugins"><span class="toc-number">2.9.</span> <span class="toc-text">Plugins</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-3-%E5%8F%8D%E6%80%9D%E4%B8%8E%E6%95%99%E8%AE%AD"><span class="toc-number"></span> <span class="toc-text">21.3 反思与教训</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Twisted%E5%BA%94%E7%94%A8%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">Twisted应用持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web2%EF%BC%9A%E9%87%8D%E6%9E%84%E7%9A%84%E6%95%99%E8%AE%AD"><span class="toc-number">2.</span> <span class="toc-text">web2：重构的教训</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A7%E8%B7%9F%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E6%B5%AA%E6%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">紧跟互联网的浪潮</span></a></li></ol></details></div><div class="container post-content"><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><blockquote>
<p>Reactor模式是处理并发I/O常见的一种模式，用于同步I/O，其中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程阻塞在多路复用器上，一旦有I/O事件到来或是准备就绪，多路复用器将返回并将相应<code>I/O</code>事件分发到对应的处理器中。</p>
<p>Reactor是一种事件驱动机制，和普通函数调用不同的是应用程序不是主动的调用某个API来完成处理，恰恰相反的是Reactor逆置了事件处理流程，应用程序需提供相应的接口并注册到Reactor上，如果有相应的事件发生，Reactor将主动调用应用程序注册的接口（回调函数）。</p>
<p><img src="/images/image-20211019192531754.png" alt="image-20211019192531754"></p>
</blockquote>
<p>Twisted实现了设计模式中的反应堆（reactor）模式，这种模式在单线程环境中调度多个事件源产生的事件到它们各自的事件处理例程中去。Twisted的核心就是reactor事件循环。Reactor可以感知网络、文件系统以及定时器事件。它等待然后处理这些事件，从特定于平台的行为中抽象出来，并提供统一的接口，使得在网络协议栈的任何位置对事件做出响应都变得简单。</p>
<p>基本上reactor完成的任务就是：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    timeout = time_until_next_timed_event()</span><br><span class="line">    events = wait_for_events(timeout)</span><br><span class="line">    events += timed_events_until(now())</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> events:</span><br><span class="line">        <span class="keyword">event</span>.process()</span><br></pre></td></tr></table></figure>

<p>Twisted目前在所有平台上的默认reactor都是基于poll API的。这些reactor包括基于FreeBSD中kqueue机制的KQueue reactor，支持epoll接口的系统中的epoll reactor，以及基于Windows下的输入输出完成端口的IOCP reactor。</p>
<p>在实现轮询的相关细节中，Twisted需要考虑的包括：</p>
<ul>
<li>网络和文件系统的限制</li>
<li>缓冲行为</li>
<li>如何检测连接丢失</li>
<li>出现错误时的返回值</li>
</ul>
<p>Twisted的reactor实现同时也考虑了正确使用底层的非阻塞式API，并正确处理各种边界情况。由于Python中没有暴露出IOCP API，因此Twisted需要维护自己的实现。</p>
<h3 id="管理回调链"><a href="#管理回调链" class="headerlink" title="管理回调链"></a>管理回调链</h3><p>回调是事件驱动编程模型中的基础，也是reactor通知应用程序事件已经处理完成的方式。随着程序规模不断扩大，基于事件驱动的程序需要同时处理事件处理成功和出错的情况，这使得程序变得越来越复杂。若没有注册一个合适的回调，程序就会阻塞，因为这个事件处理的过程绝不会发生。出现错误时需要通过应用程序的不同层次从网络栈向上传递回调链。</p>
<p>下面是两段Python伪码，分别是同步和异步模式下获取URL的玩具代码。让我们相互比较一下这两个版本，看看基于事件驱动的程序有什么缺陷：</p>
<p>以同步的方式获取URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> getPage</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processPage</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="built_in">print</span> page</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logError</span>(<span class="params">error</span>):</span></span><br><span class="line">    <span class="built_in">print</span> error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finishProcessing</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Shutting down...&quot;</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://google.com&quot;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    page = getPage(url)</span><br><span class="line">    processPage(page)</span><br><span class="line"><span class="keyword">except</span> Error, e:</span><br><span class="line">    logError(error)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    finishProcessing()</span><br></pre></td></tr></table></figure>



<p>以异步的方式获取URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line"><span class="keyword">import</span> getPage</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processPage</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="built_in">print</span> page</span><br><span class="line">    finishProcessing()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logError</span>(<span class="params">error</span>):</span></span><br><span class="line">    <span class="built_in">print</span> error</span><br><span class="line">    finishProcessing()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finishProcessing</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Shutting down...&quot;</span></span><br><span class="line">    reactor.stop()</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://google.com&quot;</span></span><br><span class="line"><span class="comment"># getPage takes: url, </span></span><br><span class="line"><span class="comment"># success callback, error callback</span></span><br><span class="line">getPage(url, processPage, logError)</span><br><span class="line"></span><br><span class="line">reactor.run()</span><br></pre></td></tr></table></figure>

<ul>
<li>在异步版的URL获取器中，reactor.run()启动reactor事件循环。</li>
<li>在同步和异步版程序中，我们假定getPage函数处理获取页面的工作。如果获取成功就调用processPage，如果尝试获取页面时出现了Exception（异常），logError就得到调用。无论哪种情况，最后都要调用finishProcessing。</li>
</ul>
<p>异步版中的logError回调正对应于同步版中的try/except块。对processPage的回调对应于else块，无条件回调的finishProcessing就对应于finally块。</p>
<p>在同步版中，代码结构直接显示出有一个try/except块，logError和processPage这两者间只会取其一调用一次，而finishProcessing总是会被调用一次。在异步版中需要由程序员自己负责正确调用成功和失败情况下的回调链。如果由于编程错误，在processPage或者logError的回调链之后没有调用finishProcessing，reactor事件循环将永远不会停止，程序就会卡住。</p>
<p>这个玩具式的例子告诉我们在开发Twisted的头几年里这种复杂性令程序员感到非常沮丧。而Twisted应对这种复杂性的方式是新增一个称为Deferred（延迟）的对象。</p>
<h4 id="Deferreds"><a href="#Deferreds" class="headerlink" title="Deferreds"></a><strong>Deferreds</strong></h4><p>Deferred对象以抽象化的方式表达了一种思想，即结果还尚不存在。它同样能够帮助管理产生这个结果所需要的回调链。当从函数中返回时，Deferred对象承诺在某个时刻函数将产生一个结果。返回的Deferred对象中包含所有注册到事件上的回调引用，因此在函数间只需要传递这一个对象即可，跟踪这个对象比单独管理所有的回调要简单的多。</p>
<p>Deferred对象包含一对回调链，一个是针对操作成功的回调，一个是针对操作失败的回调。初始状态下Deferred对象的两条链都为空。在事件处理的过程中，每个阶段都为其添加处理成功的回调和处理失败的回调。当一个异步结果到来时，Deferred对象就被“激活”，那么处理成功的回调和处理失败的回调就可以以合适的方式按照它们添加进来的顺序依次得到调用。</p>
<p>异步版URL获取器采用Deferred对象后的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line"><span class="keyword">import</span> getPage</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processPage</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="built_in">print</span> page</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logError</span>(<span class="params">error</span>):</span></span><br><span class="line">    <span class="built_in">print</span> error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finishProcessing</span>(<span class="params">value</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Shutting down...&quot;</span></span><br><span class="line">    reactor.stop()</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://google.com&quot;</span></span><br><span class="line">deferred = getPage(url) <span class="comment"># getPage returns a Deferred</span></span><br><span class="line">deferred.addCallbacks(success, failure)</span><br><span class="line">deferred.addBoth(stop)</span><br><span class="line"></span><br><span class="line">reactor.run()</span><br></pre></td></tr></table></figure>

<p>在这个版本中调用的事件处理函数与之前相同，但它们都注册到了一个单独的Deferred对象上，而不是分散在代码各处再以参数形式传递给getPage。</p>
<p>Deferred对象创建时包含两个添加回调的阶段。第一阶段，addCallbacks将 processPage和logError添加到它们各自归属的回调链中。然后addBoth再将finishProcessing同时添加到这两个回调链上。用图解的方式来看，回调链应该如图所示：</p>
<p><img src="/images/image-20211019191533892.png" alt="image-20211019191533892"></p>
<p>Deferred对象只能被激活一次，如果试图重复激活将引发一个异常。这使得Deferred对象的语义相当接近于同步版中的try/except块。从而让异步事件的处理能更容易推断，避免由于针对单个事件的回调调用多了一个或少了一个而产生微妙的bug。</p>
<p>理解Deferred对象对于理解Twisted程序的执行流是非常重要的。然而当使用Twisted为我们提供的针对网络协议的高层抽象时，通常情况下我们完全不需要直接使用Deferred对象。</p>
<p>Deferred对象所包含的抽象概念是非常强大的，这种思想已经被许多其他的事件驱动平台所借用，包括<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://lib.csdn.net/base/jquery">jQuery</a>、Dojo和Mochikit。</p>
<h4 id="Transports"><a href="#Transports" class="headerlink" title="Transports"></a><strong>Transports</strong></h4><p>Transports代表网络中两个通信结点之间的连接。Transports负责描述连接的细节，比如连接是面向流式的还是面向数据报的，流控以及可靠性。TCP、UDP和Unix套接字可作为transports的例子。它们被设计为“满足最小功能单元，同时具有最大程度的可复用性”，而且从协议实现中分离出来，这让许多协议可以采用相同类型的传输。Transports实现了ITransports接口，它包含如下的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write                   以非阻塞的方式按顺序依次将数据写到物理连接上</span><br><span class="line">writeSequence           将一个字符串列表写到物理连接上</span><br><span class="line">loseConnection          将所有挂起的数据写入，然后关闭连接</span><br><span class="line">getPeer                 取得连接中对端的地址信息</span><br><span class="line">getHost                 取得连接中本端的地址信息</span><br></pre></td></tr></table></figure>

<p>将transports从协议中分离出来也使得对这两个层次的测试变得更加简单。可以通过简单地写入一个字符串来模拟传输，用这种方式来检查。</p>
<h4 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a><strong>Protocols</strong></h4><p>Protocols描述了如何以异步的方式处理网络中的事件。HTTP、DNS以及IMAP是应用层协议中的例子。Protocols实现了IProtocol接口，它包含如下的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">makeConnection               在transport对象和服务器之间建立一条连接</span><br><span class="line">connectionMade               连接建立起来后调用</span><br><span class="line">dataReceived                 接收数据时调用</span><br><span class="line">connectionLost               关闭连接时调用</span><br></pre></td></tr></table></figure>

<p>我们最好以一个例子来说明reactor、protocols以及transports这三者之间的关系。以下是完整的echo服务器和客户端的实现，首先来看看服务器部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> protocol, reactor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Echo</span>(<span class="params">protocol.Protocol</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataReceived</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># As soon as any data is received, write it back</span></span><br><span class="line">        self.transport.write(data)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoFactory</span>(<span class="params">protocol.Factory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildProtocol</span>(<span class="params">self, addr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Echo()</span><br><span class="line"></span><br><span class="line">reactor.listenTCP(<span class="number">8000</span>, EchoFactory())</span><br><span class="line">reactor.run()</span><br></pre></td></tr></table></figure>

<p>接着是客户端部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, protocol</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span>(<span class="params">protocol.Protocol</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectionMade</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.transport.write(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataReceived</span>(<span class="params">self, data</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Server said:&quot;</span>, data</span><br><span class="line">        self.transport.loseConnection()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectionLost</span>(<span class="params">self, reason</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;connection lost&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoFactory</span>(<span class="params">protocol.ClientFactory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildProtocol</span>(<span class="params">self, addr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> EchoClient()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clientConnectionFailed</span>(<span class="params">self, connector, reason</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Connection failed - goodbye!&quot;</span></span><br><span class="line">        reactor.stop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clientConnectionLost</span>(<span class="params">self, connector, reason</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Connection lost - goodbye!&quot;</span></span><br><span class="line">        reactor.stop()</span><br><span class="line"></span><br><span class="line">reactor.connectTCP(<span class="string">&quot;localhost&quot;</span>, <span class="number">8000</span>, EchoFactory())</span><br><span class="line">reactor.run()</span><br></pre></td></tr></table></figure>

<p>运行服务器端脚本将启动一个TCP服务器，监听端口8000上的连接。服务器采用的是Echo协议，数据经TCP transport对象写出。运行客户端脚本将对服务器发起一个TCP连接，回显服务器端的回应然后终止连接并停止reactor事件循环。这里的Factory用来对连接的双方生成protocol对象实例。两端的通信是异步的，connectTCP负责注册回调函数到reactor事件循环中，当socket上有数据可读时通知回调处理。</p>
<h4 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a><strong>Applications</strong></h4><p>Twisted是用来创建具有可扩展性、跨平台的网络服务器和客户端的引擎。在生产环境中，以标准化的方式简化部署这些应用的过程对于Twisted这种被广泛采用的平台来说是非常重要的一环。为此，Twisted开发了一套应用程序基础组件，采用可重用、可配置的方式来部署Twisted应用。这种方式使程序员避免堆砌千篇一律的代码来将应用程序同已有的工具整合在一起，这包括精灵化进程（daemonization）、日志处理、使用自定义的reactor循环、对代码做性能剖析等。</p>
<p>应用程序基础组件包含4个主要部分：服务（Service）、应用（Application）、配置管理（通过TAC文件和插件）以及twistd命令行程序。为了说明这个基础组件，我们将上一节的Echo服务器转变成一个应用。</p>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a><strong>Service</strong></h4><p>Service就是IService接口下实现的可以启动和停止的组件。Twisted自带有TCP、FTP、HTTP、SSH、DNS等服务以及其他协议的实现。其中许多Service都可以注册到单独的应用中。IService接口的核心是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startService    启动服务。可能包含加载配置数据，设定数据库连接或者监听某个端口</span><br><span class="line">stopService     关闭服务。可能包含将状态保存到磁盘，关闭数据库连接或者停止监听端口</span><br></pre></td></tr></table></figure>

<p>我们的Echo服务使用TCP协议，因此我们可以使用Twisted中IService接口下默认的TCPServer实现。</p>
<h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a><strong>Application</strong></h4><p>Application是处于最顶层的Service，代表了整个Twisted应用程序。Service需要将其自身同Application注册，然后就可以用下面我们将介绍的部署工具twistd搜索并运行应用程序。我们将创建一个可以同Echo Service注册的Echo应用。</p>
<h4 id="TAC文件"><a href="#TAC文件" class="headerlink" title="TAC文件"></a><strong>TAC文件</strong></h4><p>当在一个普通的Python文件中管理Twisted应用程序时，需要由开发者负责编写启动和停止reactor事件循环以及配置应用程序的代码。在Twisted的基础组件中，协议的实现都是在一个模块中完成的，需要使用到这些协议的Service可以注册到一个Twisted应用程序配置文件中（TAC文件）去，这样reactor事件循环和程序配置就可以由外部组件来进行管理。</p>
<p>要将我们的Echo服务器转变成一个Echo应用，我们可以按照以下几个简单的步骤来完成：</p>
<ol>
<li>将Echo服务器的Protocol部分移到它们自己所归属的模块中去。</li>
<li>在TAC文件中：<ol>
<li>创建一个Echo应用。</li>
<li>创建一个TCPServer的Service实例，它将使用我们的EchoFactory，然后同前面创建的应用完成注册。</li>
</ol>
</li>
</ol>
<p>管理reactor事件循环的代码将由twistd来负责，我们下面会对此进行讨论。这样，应用程序的代码就变成这样了：</p>
<p>echo.py文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> protocol, reactor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Echo</span>(<span class="params">protocol.Protocol</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataReceived</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.transport.write(data)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoFactory</span>(<span class="params">protocol.Factory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildProtocol</span>(<span class="params">self, addr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Echo()</span><br></pre></td></tr></table></figure>

<h4 id="twistd"><a href="#twistd" class="headerlink" title="twistd"></a><strong>twistd</strong></h4><p>twistd（读作“twist-dee”）是一个跨平台的用来部署Twisted应用程序的工具。它执行TAC文件并负责处理启动和停止应用程序。作为Twisted在网络编程中具有“内置电池”能力的一部分，twistd自带有一些非常有用的配置标志，包括将应用程序转变为守护进程、定义日志文件的路径、设定特权级别、在chroot下运行、使用非默认的reactor，甚至是在profiler下运行应用程序。</p>
<p>我们可以像这样运行这个Echo服务应用：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>twistd –y echo_server.tac</span><br></pre></td></tr></table></figure>

<p>在这个简单的例子里，twistd将这个应用程序作为守护进程来启动，日志记录在twistd.log文件中。启动和停止应用后，日志文件内容如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">07</span>-<span class="number">0500</span> [-] Log opened.</span><br><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">07</span>-<span class="number">0500</span> [-] twistd <span class="number">11.0</span><span class="number">.0</span> (/usr/bin/python <span class="number">2.7</span><span class="number">.1</span>) starting up.</span><br><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">07</span>-<span class="number">0500</span> [-] reactor <span class="class"><span class="keyword">class</span>: <span class="type">twisted.internet.selectreactor.SelectReactor.</span></span></span><br><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">07</span>-<span class="number">0500</span> [-] echo.EchoFactory starting on <span class="number">8000</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">07</span>-<span class="number">0500</span> [-] Starting factory &lt;echo.EchoFactory instance at <span class="number">0x12d8670</span>&gt;</span><br><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">20</span>-<span class="number">0500</span> [-] Received SIGTERM, shutting down.</span><br><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">20</span>-<span class="number">0500</span> [-] (TCP Port <span class="number">8000</span> Closed)</span><br><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">20</span>-<span class="number">0500</span> [-] Stopping factory &lt;echo.EchoFactory instance at <span class="number">0x12d8670</span>&gt;</span><br><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">20</span>-<span class="number">0500</span> [-] Main loop terminated.</span><br><span class="line"><span class="number">2011</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">20</span>-<span class="number">0500</span> [-] Server Shut Down.</span><br></pre></td></tr></table></figure>

<p>通过使用Twisted框架中的基础组件来运行服务，这么做使得开发人员能够不用再编写类似守护进程和记录日志这样的冗余代码了。这同样也为部署应用程序建立了一个标准的命令行接口。</p>
<h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a><strong>Plugins</strong></h4><p>对于运行Twisted应用程序的方法，除了基于TAC文件外还有一种可选的方法，这就是插件系统。TAC系统可以很方便的将Twisted预定义的服务同应用程序配置文件注册，而插件系统能够方便的将用户自定义的服务注册为twistd工具的子命令，然后扩展应用程序的命令行接口。</p>
<p>在使用插件系统时：</p>
<ol>
<li>由于只有plugin API需要保持稳定，这使得第三方开发者能很容易地扩展软件。</li>
<li>插件发现能力已经集成到系统中了。插件可以在程序首次运行时加载并保存，每次程序启动时会重新触发插件发现过程，或者也可以在程序运行期间反复轮询新插件，这使得在程序已经启动后我们还可以判断是否有新的插件安装上了。</li>
</ol>
<p>当使用Twisted插件系统来扩展软件时，我们要做的就是创建IPlugin接口下实现的对象并将它们放到一个特定的位置中，这里插件系统知道该如何去找到它们。</p>
<p>我们已经将Echo服务转换为一个Twisted应用程序了，而将其转换为一个Twisted插件也是非常简单直接的。在我们之前的Echo模块中，除了包含有Echo协议和EchoFactory的定义之外，现在我们还要添加一个名为twistd的目录，其中还包含着一个名为plugins的子目录，这里正是我们需要定义echo插件的地方。通过这个插件，我们可以启动一个echo服务，并将需要使用的端口号作为参数指定给twistd工具。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> zope.interface <span class="keyword">import</span> implements</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> twisted.python <span class="keyword">import</span> usage</span><br><span class="line"><span class="keyword">from</span> twisted.plugin <span class="keyword">import</span> IPlugin</span><br><span class="line"><span class="keyword">from</span> twisted.application.service <span class="keyword">import</span> IServiceMaker</span><br><span class="line"><span class="keyword">from</span> twisted.application <span class="keyword">import</span> internet</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> echo <span class="keyword">import</span> EchoFactory</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Options</span>(<span class="params">usage.Options</span>):</span></span><br><span class="line">    optParameters = [[<span class="string">&quot;port&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="number">8000</span>, <span class="string">&quot;The port number to listen on.&quot;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServiceMaker</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    implements(IServiceMaker, IPlugin)</span><br><span class="line">    tapname = <span class="string">&quot;echo&quot;</span></span><br><span class="line">    description = <span class="string">&quot;A TCP-based echo server.&quot;</span></span><br><span class="line">    options = Options</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeService</span>(<span class="params">self, options</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Construct a TCPServer from a factory defined in myproject.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> internet.TCPServer(<span class="built_in">int</span>(options[<span class="string">&quot;port&quot;</span>]), EchoFactory())</span><br><span class="line"></span><br><span class="line">serviceMaker = EchoServiceMaker()</span><br></pre></td></tr></table></figure>

<p>现在，我们的Echo服务器将作为一个服务选项出现在twistd –help的输出中。运行twistd echo –port=1235将在端口1235上启动一个Echo服务器。</p>
<p>Twisted还带有一个可拔插的针对服务器端认证的模块twisted.cred，插件系统常见的用途就是为应用程序添加一个认证模式。我们可以使用twisted.cred中现成的AuthOptionMixin类来添加针对各种认证的命令行支持，或者是添加新的认证类型。比如，我们可以使用插件系统来添加基于本地Unix密码<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://lib.csdn.net/base/mysql">数据库</a>或者是基于LDAP服务器的认证方式。</p>
<p>twistd工具中附带有许多Twisted所支持的协议插件，只用一条单独的命令就可以完成启动服务器的工作了。这里有一些通过twistd启动服务器的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twistd web –port 8080 –path .</span><br></pre></td></tr></table></figure>

<p>这条命令将在8080端口启动一个HTTP服务器，在当前目录中负责处理静态和动态页面请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twistd dns –p 5553 –hosts-file=hosts</span><br></pre></td></tr></table></figure>

<p>这条命令在端口5553上启动一个DNS服务器，解析指定的文件hosts中的域名，这个文件的内容格式同/etc/hosts一样。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo twistd conch –<span class="selector-tag">p</span> tcp:<span class="number">2222</span></span><br></pre></td></tr></table></figure>

<p>这条命令在端口2222上启动一个SSH服务器。ssh的密钥必须独立设定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twistd mail –E –H localhost –d localhost=emails</span><br></pre></td></tr></table></figure>

<p>这条命令启动一个ESMTP POP3服务器，为本地主机接收邮件并保存到指定的emails目录下。</p>
<p>我们可以方便的通过twistd来搭建一个用于测试客户端功能的服务器，但它同样是可装载的、产品级的服务器实现。</p>
<p>在部署应用程序的方式上，Twisted通过TAC文件、插件以及命令行工具twistd的部署方式已经获得了成功。但是有趣的是，对于大多数大型Twisted应用程序来说，部署它们仍然需要重写一些这类管理和监控组件；Twisted的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://lib.csdn.net/base/architecture">架构</a>并没有对系统管理员的需求呈现出太多的友好性。这也反映了一个事实，那就是对于系统管理员来说Twisted历来就没有太多架构可言，而这些系统管理员才是部署和维护应用程序的专家。在这方面，Twisted在未来架构设计的决策上需要更积极的征求这类专家级用户的反馈意见。</p>
<h2 id="21-3-反思与教训"><a href="#21-3-反思与教训" class="headerlink" title="21.3 反思与教训"></a>21.3 反思与教训</h2><p>Twisted最近刚刚渡过了其10周年的诞辰。自项目成立以来，由于受2000年早期的网络游戏启发，目前的Twisted已经在很大程度上实现了作为一个可扩展、跨平台、事件驱动的网络引擎的目标。Twisted广泛使用于生产环境中，从Google、卢卡斯电影到Justin.TV以及Launchpad软件协作平台都有在使用。Twisted中的服务器端实现是多个开源软件的核心，包括BuildBot、BitTorrent以及TahoeLAFS。</p>
<p>Twisted从最初开发到现在，其架构已经经历了几次大的变动。Deferred对象作为一个关键部分被增加了进来。如前文所述，这是用来管理延后的结果以及相应的回调链。</p>
<p>还有一个重要的部分被移除掉了，在目前的实现中已经几乎看不到任何影子了，这就是Twisted应用持久化（Twisted Application Persistence）。</p>
<h3 id="Twisted应用持久化"><a href="#Twisted应用持久化" class="headerlink" title="Twisted应用持久化"></a><strong>Twisted应用持久化</strong></h3><p>Twisted应用持久化（TAP）是指将应用程序的配置和状态保存在一个pickle中。要运行采用了这种方案的应用需要两个步骤：</p>
<ol>
<li>使用mktap工具创建一个代表该应用的pickle（该工具现已废弃不用）。</li>
<li>使用twistd命令行工具进行unpickle操作，然后运行该应用。</li>
</ol>
<p>这个过程是受Smalltalk images的启发，因为我们讨厌那种临时性的且难以使用的专用配置语言，不希望它们在项目中不断扩散。我们更希望在Python中表示配置的细节。</p>
<p>很快，TAP文件就引入了不必要的复杂性。修改Twisted中的类并不会使pickle中这些类的实例得到改变。在pickle对象上使用新版本的类方法或属性时可能会使整个应用崩溃。因此“升级版”的概念得以引入，即将pickle对象升级到新的API版本。但这就会出现升级版本的矩阵化现象，出现各种不同版本的pickle对象，因此单元测试时需要维护涵盖所有可能的升级路径。想全面地跟踪所有的接口变化依然很难，而且容易出错。</p>
<p>TAP以及相关的组件全部被废除了，最终从Twisted中完全剔除掉。取而代之的是TAC文件和插件系统。TAP这个缩写被重新定义为Twisted Application Plugin（Twisted应用插件），如今已经很难在Twisted中找到pickle系统的踪迹了。</p>
<p>我们从TAP的惨败中得到的教训是：如果可维护性要达到合理化的程度，则持久性数据就需要有一个明确的模式。更一般的是，我们学到了如何为项目增加复杂度：为了解决某个问题而需要引入一个新系统时，我们要正确理解这个方案的复杂性，并经过测试。新系统所带来的价值应该明显大于其复杂性。确保了这一点之后我们才能将方案付诸于项目中。</p>
<h3 id="web2：重构的教训"><a href="#web2：重构的教训" class="headerlink" title="web2：重构的教训"></a><strong>web2：重构的教训</strong></h3><p>虽然这基本上不属于架构设计上的决策，但从项目管理的角度来看，重写Twisted的Web实现对于Twisted的外在形象以及维护者对代码库中其他部分做架构改善的能力却有着长远的影响，因此这里值得我们简单讨论一下。</p>
<p>在2000年中期，Twisted的开发者决定完全重写twisted.web API，在Twisted代码库中将其作为一个单独的项目实现，这就是web2。web2将包含许多针对原有twisted.web的改善和提升，包括完全支持HTTP1.1，以及对流式数据的API支持。</p>
<p>web2最初只是试验性的项目，但最终被大型项目所采用，甚至意外的得以在Debian系统上打包发布。twisted.web和web2的开发一直并行持续了多年，新用户常常被这两个并行的项目搞混，关于究竟应该使用哪种实现缺乏明确的提示，这使得新用户很沮丧。转换到web2的情况从未出现，终于在2011年开发者将其从代码库中移除，官方主页上再也看不到它了。web2中做出的一些改进也被慢慢地移植回twisted.web中。</p>
<p>Twisted获得了难以导航且结构混乱，容易使新开发者感到困惑的“恶名”，这个印象部分归功于web2。以至于数年之后，Twisted社区仍然在同这种不和谐的名声做斗争。</p>
<p>我们从web2中汲取的教训是：从头开始重构一个项目通常都是糟糕的主意。但如果必须这么做，请确保开发者社区能够懂得这么做的长远意义，而且在用户社群中要有明确的选择该使用哪种实现。</p>
<p>如果Twisted能够倒退回web2的时代，开发者们应该会对twisted.web做一系列向后兼容型的修改而不是去重构。</p>
<h3 id="紧跟互联网的浪潮"><a href="#紧跟互联网的浪潮" class="headerlink" title="紧跟互联网的浪潮"></a><strong>紧跟互联网的浪潮</strong></h3><p>我们使用互联网的方式还在持续演进中。把多种协议的实现作为软件核心的一部分，这个技术决策使得Twisted背负了维护这些协议的沉重负担。随着标准的改变以及对新协议的采纳，原有的实现必须跟着演进，同时需要严格的保证向后兼容性。</p>
<p>Twisted基本上是一个志愿者驱动型的项目，项目发展的限制因素不是技术社区的热情，而在于志愿者的时间。比如说，1999年的RFC 2616中定义了HTTP 1.1规范，而在Twisted的HTTP协议实现中增加对HTTP 1.1的支持却在2005年才开始，等到完成时已经是2009年了。1998年RFC 2460中定义了对IPv6的支持，而Twisted对其的支持还在进行中，但是直到2011年都未能合并进去。</p>
<p>随着所支持的操作系统的接口改变，实现也要跟着演进。比如，epoll事件通知机制是在2002年加入到<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://lib.csdn.net/base/linux">linux</a> 2.5.44版中的，Twisted随之也发展出基于epoll的reactor事件循环来利用这个新的系统接口。2007年时，苹果公司发布的OS 10.5 Leopard系统中，系统调用poll的实现居然不支持外设，对于苹果公司来说这个问题足以让他们在系统自带的Python中屏蔽掉select.poll接口。Twisted不得不自行解决这个问题，并从那时起就对用户提供文档说明。</p>
<p>有时候，Twisted的开发并没有紧跟网络世界的变化，有一些改进被移到核心层之外的程序库中去了。比如Wokkel project，这是对Twisted的Jabber/XMPP支持的改进合集，已经作为“待合入”的独立项目有几年之久了，但还没有看到合入的希望。在2009年也曾经尝试过增加WebSocket到Twisted中，因为浏览器已经开始采纳对新协议的支持了。但开发计划最终却转到其他外部项目中去了，因为开发者们决定暂不包含新的协议，直到IETF把它从草案转变成标准以后再说。</p>
<p>所有这一切都在说明，库和附加组件的扩散有力的证明了Twisted的灵活性和可扩展性。通过采用严格的测试驱动开发策略以及文档化和编码规范标准，这样做能够帮助项目避免出现需要“回炉”的情况。在维护大量所支持的协议和平台的同时保持向后兼容性。Twisted是一个成熟、稳定的项目，并继续保持有非常活跃的开发状态。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>