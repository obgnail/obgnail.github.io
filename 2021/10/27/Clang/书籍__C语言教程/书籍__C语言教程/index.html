<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;C-语言的特点&quot;&gt;&lt;a href=&quot;#C-语言的特点&quot; class=&quot;headerlink&quot; title=&quot;C 语言的特点&quot;&gt;&lt;/a&gt;C 语言的特点&lt;/h2&gt;&lt;p&gt;C 语言的哲学是“信任程序员，不要妨碍他们做事”。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>C语言教程 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Clang/" rel="tag">Clang</a></div><div class="post-time">2021-10-27</div></div></div><div class="container post-header"><h1>C语言教程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">C 语言的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB"><span class="toc-number">2.</span> <span class="toc-text">语法汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BD%86%E4%B8%8D%E8%B5%8B%E5%80%BC%E4%B8%8D%E4%BC%9A%E6%8A%A5%E9%94%99"><span class="toc-number">2.1.1.</span> <span class="toc-text">声明但不赋值不会报错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-scope"><span class="toc-number">2.1.2.</span> <span class="toc-text">变量的作用域(scope)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text">sizeof 运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">指针的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.</span> <span class="toc-text">指针运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B4%E6%95%B0%E5%80%BC%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E8%A1%A8%E7%A4%BA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E7%A7%BB%E5%8A%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">指针与整数值的加减运算表示内存地址的移动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E6%98%AF%E9%9D%9E%E6%B3%95%E7%9A%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">指针与指针的加法运算是非法的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%87%8F%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="toc-number">3.2.3.</span> <span class="toc-text">指针与指针的减法返回指针之间的距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E6%AF%94%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E6%9B%B4%E5%A4%A7"><span class="toc-number">3.2.4.</span> <span class="toc-text">指针与指针的比较运算比的是哪个内存地址更大</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%B8%8D%E5%85%81%E8%AE%B8%E5%B5%8C%E5%A5%97"><span class="toc-number">4.1.</span> <span class="toc-text">c语言函数不允许嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0return-0"><span class="toc-number">4.2.</span> <span class="toc-text">main函数return 0;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9E%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">4.3.</span> <span class="toc-text">函数不要返回内部变量的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">4.4.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit"><span class="toc-number">4.6.</span> <span class="toc-text">exit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">4.7.</span> <span class="toc-text">函数说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#extern"><span class="toc-number">4.7.1.</span> <span class="toc-text">extern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">4.7.2.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">4.7.3.</span> <span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">5.1.</span> <span class="toc-text">数组的地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">数组指针的加减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">数组的复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%80%E8%88%AC%E8%A6%81%E4%BC%A0%E9%80%92%E9%95%BF%E5%BA%A6"><span class="toc-number">5.4.</span> <span class="toc-text">数组作为函数参数一般要传递长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">6.1.</span> <span class="toc-text">字符串变量的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">使用字符数组和字符指针声明的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.</span> <span class="toc-text">字符串数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strlen"><span class="toc-number">6.4.</span> <span class="toc-text">strlen()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcpy"><span class="toc-number">6.5.</span> <span class="toc-text">strcpy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strncpy"><span class="toc-number">6.6.</span> <span class="toc-text">strncpy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcat"><span class="toc-number">6.7.</span> <span class="toc-text">strcat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strncat"><span class="toc-number">6.8.</span> <span class="toc-text">strncat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcmp"><span class="toc-number">6.9.</span> <span class="toc-text">strcmp()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strncmp"><span class="toc-number">6.10.</span> <span class="toc-text">strncmp()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">内存管理</span></a></li></ol></details></div><div class="container post-content"><h2 id="C-语言的特点"><a href="#C-语言的特点" class="headerlink" title="C 语言的特点"></a>C 语言的特点</h2><p>C 语言的哲学是“信任程序员，不要妨碍他们做事”。</p>
<ol>
<li>低级语言</li>
<li>可移植性</li>
<li>简单性</li>
<li>灵活性</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="语法汇总"><a href="#语法汇总" class="headerlink" title="语法汇总"></a>语法汇总</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行</span></span><br><span class="line"><span class="keyword">int</span> x; x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依靠分号判断语句在哪一行结束</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x</span><br><span class="line">=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “空语句”，虽然毫无作用。</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 There are 3 apples</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There are %i apples\n&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值表达式有返回值，等于`等号右边的值`。</span></span><br><span class="line"><span class="comment">// 变量y的值就是赋值表达式（x = 2 * x）的返回值2。</span></span><br><span class="line"><span class="comment">// 由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = (x = <span class="number">2</span> * x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if语句</span></span><br><span class="line"><span class="keyword">if</span> (line_num == MAX_LINES) &#123;</span><br><span class="line">  line_num = <span class="number">0</span>;</span><br><span class="line">  page_num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// else总是跟最接近的if匹配。</span></span><br><span class="line"><span class="comment">// 下面示例中，else部分匹配最近的if（即number &lt; 12），所以如果number等于6，就不会执行else的部分。</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">6</span>)</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number is more than 6, less than 12.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;It is wrong number.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以建议使用大括号</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">6</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number is more than 6, less than 12.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;It is wrong number.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch语句</span></span><br><span class="line"><span class="comment">// 每个case语句体的结尾，都应该有一个break语句</span></span><br><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;False&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;True&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Illegal&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while语句</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i is now %d!\n&quot;</span>, i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do...while 结构</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;i is %d\n&quot;</span>, i);</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for语句</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">999</span>; i &lt; <span class="number">10</span>; i++, j--) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, i, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;本行会无限循环地打印。\n&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goto 语句</span></span><br><span class="line"><span class="comment">// 注意：goto 只能在同一个函数之中跳转</span></span><br><span class="line">top: ch = getchar();</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">  <span class="keyword">goto</span> top;</span><br></pre></td></tr></table></figure>



<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="声明但不赋值不会报错"><a href="#声明但不赋值不会报错" class="headerlink" title="声明但不赋值不会报错"></a>声明但不赋值不会报错</h4><p>C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%i&quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output：</span></span><br><span class="line"><span class="comment">// 195964982</span></span><br></pre></td></tr></table></figure>



<h4 id="变量的作用域-scope"><a href="#变量的作用域-scope" class="headerlink" title="变量的作用域(scope)"></a>变量的作用域(scope)</h4><p>C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）</p>
<ul>
<li><p>文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。</p>
</li>
<li><p>块作用域（block scope）指的是由大括号（<code>&#123;&#125;</code>）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。</p>
<blockquote>
<p>内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。(即：就近原则)</p>
</blockquote>
</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符<code>/</code>用来完成除法。注意，两个整数相除，得到还是一个整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x = <span class="number">6</span> / <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x); <span class="comment">// 输出 1.000000</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，尽管变量<code>x</code>的类型是<code>float</code>（浮点数），但是<code>6 / 4</code>得到的结果是<code>1.0</code>，而不是<code>1.5</code>。原因就在于 C 语言里面的整数除法是整除，只会返回整数部分，丢弃小数部分。</p>
<p>如果希望得到浮点数的结果，两个运算数必须至少有一个浮点数，这时 C 语言就会进行浮点数除法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x = <span class="number">6.0</span> / <span class="number">4</span>; <span class="comment">// 或者写成 6 / 4.0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, x); <span class="comment">// 输出 1.500000</span></span><br></pre></td></tr></table></figure>



<p>负数求模的规则是，结果的正负号由第一个运算数的正负号决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> % <span class="number">-5</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">-11</span> % <span class="number">-5</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">-11</span> % <span class="number">5</span> <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>



<ul>
<li><code>++var</code>和<code>--var</code>是先执行自增或自减操作，再返回操作后<code>var</code>的值；</li>
<li><code>var++</code>和<code>var--</code>则是先返回操作前<code>var</code>的值，再执行自增或自减操作。</li>
</ul>
<h4 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h4><p><code>sizeof</code>运算符返回某种数据类型或某个值<strong>占用的字节数量</strong>。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为数据类型</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为变量</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">sizeof</span>(i); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为数值</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="number">3.14</span>); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面例子的执行结果，可能会出人意料。</span></span><br><span class="line"><span class="comment">// sizeof(int)是size_t类型，这是一个无符号整数。按照规则，signed int 自动转为 unsigned int，所以a会自动转成无符号整数4294967291（转换规则是-5加上无符号整数的最大值，再加1），导致比较失败</span></span><br><span class="line"><span class="comment">// 所以，最好避免无符号整数与有符号整数的混合运算。因为这时 C 语言会自动将signed int转为unsigned int，可能不会得到预期的结果。</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">-5</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>)）</span><br></pre></td></tr></table></figure>



<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/images/image-20211025190158650.png" alt="image-20211025190158650"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个字符 </span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">66</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用signed关键字，表示一个类型带有正负号，包含负值；</span></span><br><span class="line"><span class="comment">// 使用unsigned关键字，表示该类型不带有正负号，只能表示零和正整数。</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int类型也可以不带正负号，只表示非负整数。这时就必须使用关键字unsigned声明变量。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c; <span class="comment">// 范围为 -128 到 127</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c; <span class="comment">// 范围为 0 到 255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数的子类型</span></span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="comment">// C 语言允许省略int</span></span><br><span class="line"><span class="keyword">short</span> a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数的进制</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x1A2B</span>; <span class="comment">// 十六进制，相当于十进制的6699</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float</span></span><br><span class="line"><span class="keyword">float</span> c = <span class="number">10.5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> d = <span class="number">10.3</span></span><br><span class="line"><span class="keyword">double</span> x = <span class="number">123.456e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔类型</span></span><br><span class="line"><span class="comment">// C 语言原来并没有为布尔值单独设置一个类型，而是使用整数0表示伪，所有非零值表示真。</span></span><br><span class="line"><span class="comment">// C99 标准添加了类型_Bool，表示布尔值。但是，这个类型其实只是整数类型的别名，还是使用0表示伪，1表示真</span></span><br><span class="line"><span class="built_in">_Bool</span> isNormal;</span><br><span class="line">isNormal = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (isNormal)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Everything is OK.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件stdbool.h定义了另一个类型别名bool，并且定义了true代表1、false代表0。只要加载这个头文件，就可以使用这几个关键字。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般情况下，十进制整数字面量（比如123）会被编译器指定为int类型。如果一个数值比较大，超出了int能够表示的范围，编译器会将其指定为long int。如果数值超过了long int，会被指定为unsigned long。如果还不够大，就指定为long long或unsigned long long。</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量后缀</span></span><br><span class="line"><span class="comment">// 将其指定为long类型，这时可以为该字面量加上后缀l或L，</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">123L</span>;</span><br><span class="line"><span class="comment">// 指定为无符号整数unsigned int</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">123U</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> x = <span class="number">255</span>; </span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 当i等于0，再减去1的时候，并不会返回-1，而是返回 unsigned int 的类型最大值，这个值总是大于等于0，导致无限循环。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i) <span class="comment">// 错误</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 为了避免溢出，最好方法就是将运算结果与类型的极限值进行比较。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sum;</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (sum + ui &gt; UINT_MAX) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">if</span> (ui &gt; UINT_MAX - sum) too_big();</span><br><span class="line"><span class="keyword">else</span> sum = sum + ui;</span><br><span class="line"><span class="comment">// 上面示例中，变量sum和ui都是 unsigned int 类型，它们相加的和还是 unsigned int 类型，这就有可能发生溢出。但是，不能通过相加的和是否超出了最大值UINT_MAX，来判断是否发生了溢出，因为sum + ui总是返回溢出后的结果，不可能大于UINT_MAX。正确的比较方法是，判断UINT_MAX - sum与ui之间的大小关系。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算</span></span><br><span class="line"><span class="comment">// 浮点数赋予整数变量时，C 语言直接丢弃小数部分，而不是四舍五入。</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// 窄类型赋值给宽类型,char或short类型赋值给int类型，会自动提升为int</span></span><br><span class="line"><span class="keyword">char</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = x + y;</span><br><span class="line"><span class="comment">// 宽类型赋值给窄类型</span></span><br><span class="line"><span class="comment">// 字节宽度较大的类型，赋值给字节宽度较小的变量时，会发生类型降级，自动转为后者的类型。这时可能会发生截值（truncation），系统会自动截去多余的二进制位，导致难以预料的结果。</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">321</span>;</span><br><span class="line"><span class="keyword">char</span> ch = i; <span class="comment">// ch 的值是 65 （321 - 256）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="comment">// 下面示例中，参数变量m和n不管原来的类型是什么，都会转成函数dostuff()定义的参数类型。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dostuff</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> m = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> n = <span class="number">43</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c = dostuff(m, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型的显式转换</span></span><br><span class="line"><span class="comment">// (long int)将10显式转为long int类型。</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> y = (<span class="keyword">long</span> <span class="keyword">int</span>) <span class="number">10</span> + <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可移植类型</span></span><br><span class="line"><span class="comment">// C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。</span></span><br><span class="line"><span class="comment">// 精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。</span></span><br><span class="line"><span class="comment">// int8_t：8位有符号整数。</span></span><br><span class="line"><span class="comment">// int16_t：16位有符号整数。</span></span><br><span class="line"><span class="comment">// int32_t：32位有符号整数。</span></span><br><span class="line"><span class="comment">// int64_t：64位有符号整数。</span></span><br><span class="line"><span class="comment">// uint8_t：8位无符号整数。</span></span><br><span class="line"><span class="comment">// uint16_t：16位无符号整数。</span></span><br><span class="line"><span class="comment">// uint32_t：32位无符号整数。</span></span><br><span class="line"><span class="comment">// uint64_t：64位无符号整数。</span></span><br><span class="line"><span class="keyword">int32_t</span> x32 = <span class="number">45933945</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x32 = %d\n&quot;</span>, x32);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小宽度类型（minimum width type），保证某个整数类型的最小长度。</span></span><br><span class="line"><span class="comment">// 可以保证占据的字节不少于指定宽度。比如，int_least8_t表示可以容纳8位有符号整数的最小宽度的类型。</span></span><br><span class="line"><span class="keyword">int_least8_t</span></span><br><span class="line"><span class="keyword">int_least16_t</span></span><br><span class="line"><span class="keyword">int_least32_t</span></span><br><span class="line"><span class="keyword">int_least64_t</span></span><br><span class="line"><span class="keyword">uint_least8_t</span></span><br><span class="line"><span class="keyword">uint_least16_t</span></span><br><span class="line"><span class="keyword">uint_least32_t</span></span><br><span class="line"><span class="keyword">uint_least64_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">int</span>* intPtr;</span><br><span class="line"><span class="comment">// 星号*可以放在变量名与类型关键字之间的任何地方，下面的写法都是有效的。</span></span><br><span class="line"><span class="keyword">int</span>   *intPtr;</span><br><span class="line"><span class="keyword">int</span> * intPtr;</span><br><span class="line"><span class="keyword">int</span>*  intPtr;</span><br><span class="line"><span class="comment">// 指针指向的可能还是指针，这时就要用两个星号**表示。</span></span><br><span class="line"><span class="keyword">int</span>** foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *号取出指针变量所指向的内存地址里面的值。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">  *p = *p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">increment(&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h3 id="指针的初始化"><a href="#指针的初始化" class="headerlink" title="指针的初始化"></a>指针的初始化</h3><p>声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，也就是说，指针变量指向的值是随机的。这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是错的，因为<code>p</code>指向的那个地址是随机的，向这个随机地址里面写入<code>1</code>，会导致意想不到的结果。</p>
<p>正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">p = &amp;i;</span><br><span class="line">*p = <span class="number">13</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>p</code>是指针变量，声明这个变量后，<code>p</code>会指向一个随机的内存地址。这时要将它指向一个已经分配好的内存地址，上例就是再声明一个整数变量<code>i</code>，编译器会为<code>i</code>分配内存地址，然后让<code>p</code>指向<code>i</code>的内存地址（<code>p = &amp;i;</code>）。完成初始化之后，就可以对<code>p</code>指向的内存地址进行赋值了（<code>*p = 13;</code>）。</p>
<p>为了防止读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为<code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><code>NULL</code>在 C 语言中是一个常量，表示地址为<code>0</code>的内存空间，这个地址是无法使用的，读写该地址会报错。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>指针本质上就是一个无符号整数，代表了内存地址。它可以进行运算，但是规则并不是整数运算的运算。</p>
<h4 id="指针与整数值的加减运算表示内存地址的移动"><a href="#指针与整数值的加减运算表示内存地址的移动" class="headerlink" title="指针与整数值的加减运算表示内存地址的移动"></a>指针与整数值的加减运算表示内存地址的移动</h4><p>指针与整数值的运算，表示指针的移动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span>* j;</span><br><span class="line">j = (<span class="keyword">short</span>*)<span class="number">0x1234</span>;</span><br><span class="line">j = j + <span class="number">1</span>; <span class="comment">// 0x1236</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j</code>是一个指针，指向内存地址<code>0x1234</code>。你可能以为<code>j + 1</code>等于<code>0x1235</code>，但正确答案是<code>0x1236</code>。</p>
<p>原因是<code>j + 1</code>表示指针向高位移动一个单位，而一个单位的<code>short</code>类型占据两个字节的宽度，所以相当于向高位移动两个字节。同样的，<code>j - 1</code>得到的结果是<code>0x1232</code>。</p>
<p><strong>指针移动的单位，与指针指向的数据类型有关</strong>。数据类型占据多少个字节，每单位就移动多少个字节。</p>
<h4 id="指针与指针的加法运算是非法的"><a href="#指针与指针的加法运算是非法的" class="headerlink" title="指针与指针的加法运算是非法的"></a>指针与指针的加法运算是非法的</h4><p>指针只能与整数值进行加减运算，两个指针进行加法是非法的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>* j;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>* k;</span><br><span class="line">x = j + k; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>



<h4 id="指针与指针的减法返回指针之间的距离"><a href="#指针与指针的减法返回指针之间的距离" class="headerlink" title="指针与指针的减法返回指针之间的距离"></a>指针与指针的减法返回指针之间的距离</h4><p>相同类型的指针允许进行减法运算，<strong>返回它们之间的距离，即相隔多少个数据单位</strong>。高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。</p>
<p>这时，减法返回的值属于<code>ptrdiff_t</code>类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。这个类型的原型定义在头文件<code>stddef.h</code>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span>* j1;</span><br><span class="line"><span class="keyword">short</span>* j2;</span><br><span class="line"></span><br><span class="line">j1 = (<span class="keyword">short</span>*)<span class="number">0x1234</span>;</span><br><span class="line">j2 = (<span class="keyword">short</span>*)<span class="number">0x1236</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ptrdiff_t</span> dist = j2 - j1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j1</code>和<code>j2</code>是两个指向 short 类型的指针，变量<code>dist</code>是它们之间的距离，类型为<code>ptrdiff_t</code>，值为<code>1</code>，因为相差2个字节正好存放一个 short 类型的值。</p>
<h4 id="指针与指针的比较运算比的是哪个内存地址更大"><a href="#指针与指针的比较运算比的是哪个内存地址更大" class="headerlink" title="指针与指针的比较运算比的是哪个内存地址更大"></a>指针与指针的比较运算比的是哪个内存地址更大</h4><p>指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数<code>1</code>（true）或<code>0</code>（false）。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="c语言函数不允许嵌套"><a href="#c语言函数不允许嵌套" class="headerlink" title="c语言函数不允许嵌套"></a>c语言函数不允许嵌套</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">plus_one</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="main函数return-0"><a href="#main函数return-0" class="headerlink" title="main函数return 0;"></a>main函数return 0;</h3><p><code>main()</code>的写法与其他函数一样。</p>
<p>最后的<code>return 0;</code>表示函数结束运行，返回<code>0</code>。<code>main()</code>的默认返回值为0，所以此行可以不加。但是建议还是加上。</p>
<p>C 语言约定，返回值<code>0</code>表示函数运行成功，如果返回其他非零整数，就表示运行失败，代码出了问题。系统根据<code>main()</code>的返回值，作为整个程序的返回值，确定程序是否运行成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数不要返回内部变量的指针"><a href="#函数不要返回内部变量的指针" class="headerlink" title="函数不要返回内部变量的指针"></a>函数不要返回内部变量的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数返回内部变量<code>i</code>的指针，这种写法是错的。因为当函数结束运行时，内部变量就消失了，这时指向内部变量<code>i</code>的内存地址就是无效的，再去使用这个地址是非常危险的。</p>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p><strong>函数名是指向函数<code>二进制块</code>开头处的指针</strong>。C 语言允许通过指针获取函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*print_ptr)(<span class="keyword">int</span>) = &amp;print;</span><br><span class="line"></span><br><span class="line">(*print_ptr)(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">print(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>print_ptr</code>是一个函数指针，它指向函数<code>print()</code>的地址。函数<code>print()</code>的地址可以用<code>&amp;print</code>获得。注意，<code>(*print_ptr)</code>一定要写在圆括号里面，否则函数参数<code>(int)</code>的优先级高于<code>*</code>，整个式子就会变成<code>void* print_ptr(int)</code>。</p>
<p>有了函数指针，通过它也可以调用函数。</p>
<p>比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，<code>print</code>和<code>&amp;print</code>是一回事。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (print == &amp;print) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，上面代码的<code>print_ptr</code>等同于<code>print</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*print_ptr)(<span class="keyword">int</span>) = &amp;print;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">void</span> (*print_ptr)(<span class="keyword">int</span>) = print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (print_ptr == print) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p>所以，对于任意函数，都有五种调用函数的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">10</span>) <span class="comment">// 写法一</span></span><br><span class="line">(*print)(<span class="number">10</span>) <span class="comment">// 写法二</span></span><br><span class="line">(&amp;print)(<span class="number">10</span>) <span class="comment">// 写法三</span></span><br><span class="line">(*print_ptr)(<span class="number">10</span>) <span class="comment">// 写法四</span></span><br><span class="line">print_ptr(<span class="number">10</span>) <span class="comment">// 写法五</span></span><br></pre></td></tr></table></figure>

<p>为了简洁易读，一般情况下，函数名前面都不加<code>*</code>和<code>&amp;</code>。</p>
<p>这种特性的一个应用是，如果一个函数的参数或返回值，也是一个函数，那么函数原型可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> (*myfunc)(<span class="keyword">int</span>), <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面示例可以清晰地表明，函数<code>compute()</code>的第一个参数也是一个函数。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>函数必须先声明，后使用。由于程序总是先运行<code>main()</code>函数，导致所有其他函数都必须在<code>main()</code>函数之前声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  func1();</span><br><span class="line">  func2();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>main()</code>函数必须在最后声明，否则编译时会产生警告，找不到<code>func1()</code>或<code>func2()</code>的声明。</p>
<p>但是，<code>main()</code>是整个程序的入口，也是主要逻辑，放在最前面比较好。另一方面，对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。</p>
<p>C 语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以先使用、后声明。</p>
<blockquote>
<p>所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。其他信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> twice(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>twice()</code>的实现是放在<code>main()</code>后面，但是代码头部先给出了函数原型，所以可以正确编译。只要提前给出函数原型，函数具体的实现放在哪里，就不重要了。</p>
<p>函数原型包括参数名也可以，虽然这样对于编译器是多余的，但是阅读代码的时候，可能有助于理解函数的意图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>一般来说，每个源码文件的头部，都会给出当前脚本使用的所有函数的原型。</strong></p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><blockquote>
<p>类似于golang里的panic</p>
</blockquote>
<p><code>exit()</code>函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件<code>stdlib.h</code>里面。</p>
<p><code>exit()</code>可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数，这两个常数也是定义在<code>stdlib.h</code>里面。：</p>
<ul>
<li><code>EXIT_SUCCESS</code>（相当于 0）表示程序运行成功，</li>
<li><code>EXIT_FAILURE</code>（相当于 1）表示程序异常中止。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序运行成功</span></span><br><span class="line"><span class="comment">// 等同于 exit(0);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序异常中止</span></span><br><span class="line"><span class="comment">// 等同于 exit(1);</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure>

<p>在<code>main()</code>函数里面，<code>exit()</code>等价于使用<code>return</code>语句。其他函数使用<code>exit()</code>，就是终止整个程序的运行，没有其他作用。</p>
<p>C 语言还提供了一个<code>atexit()</code>函数，用来登记**<code>exit()</code>执行时额外执行的函数**，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件<code>stdlib.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>atexit()</code>的参数是一个函数指针。注意，此函数不能接受参数，也不能有返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;something wrong!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">atexit(print);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>exit()</code>执行时会先自动调用<code>atexit()</code>注册的<code>print()</code>函数，然后再终止程序。</p>
<h3 id="函数说明符"><a href="#函数说明符" class="headerlink" title="函数说明符"></a>函数说明符</h3><p>函数说明符：让函数用法更加明确。</p>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p>对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并<strong>用<code>extern</code>说明此变量/函数是在别处定义的，要在此处引用</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">char</span> arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>foo()</code>定义在其他文件，<code>extern</code>告诉编译器当前文件不包含该函数的定义。</p>
<p>不过，由于函数原型默认就是<code>extern</code>，所以这里不加<code>extern</code>，效果是一样的。</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。<code>static</code>说明符可以改变这种行为。</p>
<p><strong><code>static</code>用于函数内部声明变量时，表示该变量只需要初始化一次</strong>，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counter</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;  <span class="comment">// 只初始化一次</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  counter();  <span class="comment">// 1</span></span><br><span class="line">  counter();  <span class="comment">// 2</span></span><br><span class="line">  counter();  <span class="comment">// 3</span></span><br><span class="line">  counter();  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>counter()</code>的内部变量<code>count</code>，使用<code>static</code>说明符修饰，表明这个变量只初始化一次，以后每次调用时都会使用上一次的值，造成递增的效果。</p>
<p>注意，<code>static</code>修饰的变量初始化时，<strong>只能赋值为常量，不能赋值为变量。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j = i; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>j</code>属于静态变量，初始化时不能赋值为另一个变量<code>i</code>。</p>
<p>另外，在块作用域中，<code>static</code>声明的变量有默认值<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> foo;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<p><code>static</code>可以用来修饰函数本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Twice</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = num * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，**<code>static</code>关键字表示该函数只能在当前文件里使用**，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）。</p>
<p><code>static</code>也可以用在参数里面，修饰参数数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">static</span> <span class="number">3</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，**<code>static</code>对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3**，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，<code>static</code>仅可用于第一维的说明。</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p><strong>函数参数里面的<code>const</code>说明符，表示函数内部不得修改该参数变量</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f()</code>的参数是一个指针<code>p</code>，函数内部可能会改掉它所指向的值<code>*p</code>，从而影响到函数外部。</p>
<p>为了避免这种情况，可以在声明函数时，在指针参数前面加上<code>const</code>说明符，告诉编译器，函数内部不能修改该参数所指向的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">  *p = <span class="number">0</span>; <span class="comment">// 该行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，声明函数时，<code>const</code>指定不能修改指针<code>p</code>指向的值，所以<code>*p = 0</code>就会报错。</p>
<p>但是上面这种写法，只限制修改<code>p</code>所指向的值，而<code>p</code>本身的地址是可以修改的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">13</span>;</span><br><span class="line">  p = &amp;x; <span class="comment">// 允许修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>p</code>本身是可以修改，<code>const</code>只限定<code>*p</code>不能修改。</p>
<p>如果想限制修改<code>p</code>，可以把<code>const</code>放在<code>p</code>前面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">const</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">13</span>;</span><br><span class="line">  p = &amp;x; <span class="comment">// 该行报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想同时限制修改<code>p</code>和<code>*p</code>，需要使用两个<code>const</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号<code>...</code>表示可变数量的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>



<p>头文件<code>stdarg.h</code>定义了一些宏，可以操作可变参数。</p>
<p>（1）<code>va_list</code>：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。</p>
<p>（2）<code>va_start</code>：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。</p>
<p>（3）<code>va_arg</code>：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。</p>
<p>（4）<code>va_end</code>：一个函数，用来清理可变参数对象。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> i, ...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">    total += va_arg(ap, <span class="keyword">double</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> total / i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，</p>
<ul>
<li><code>va_list ap</code>定义<code>ap</code>为可变参数对象，</li>
<li><code>va_start(ap, i)</code>将参数<code>i</code>后面的参数统一放入<code>ap</code>，</li>
<li><code>va_arg(ap, double)</code>用来从<code>ap</code>依次取出一个参数，并且指定该参数为 double 类型，</li>
<li><code>va_end(ap)</code>用来清理可变参数对象。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">int</span> scores[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">scores[<span class="number">0</span>] = <span class="number">13</span>;</span><br><span class="line">scores[<span class="number">99</span>] = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组scores只有100个成员，因此scores[100]这个位置是不存在的。但是，引用这个位置并不会报错，会正常运行，使得紧跟在scores后面的那块内存区域被赋值，而那实际上是其他变量的区域，因此不知不觉就更改了其他变量的值。</span></span><br><span class="line">scores[<span class="number">100</span>] = <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>] = &#123;[<span class="number">2</span>] = <span class="number">29</span>, [<span class="number">9</span>] = <span class="number">7</span>, [<span class="number">14</span>] = <span class="number">48</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>] = &#123;<span class="number">1</span>, [<span class="number">5</span>] = <span class="number">10</span>, <span class="number">11</span>, [<span class="number">10</span>] = <span class="number">20</span>, <span class="number">21</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。</span></span><br><span class="line"><span class="comment">// 报错的原因是，C 语言规定，数组变量一旦声明，就不得修改变量指向的地址。</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">a = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>, <span class="number">18</span>, <span class="number">95</span>&#125;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof运算符会返回整个数组的字节长度</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">22</span>, <span class="number">37</span>, <span class="number">3490</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arrLen = <span class="keyword">sizeof</span>(a); <span class="comment">// 12</span></span><br><span class="line"><span class="comment">// 获取可以如下获取数组长度</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>])</span><br><span class="line">  </span><br><span class="line"><span class="comment">// sizeof返回值的数据类型是size_t，所以sizeof(a) / sizeof(a[0])的数据类型也是size_t。</span></span><br><span class="line"><span class="comment">// 在printf()里面的占位符，要用%zd或%zu。</span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">12</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(x));     <span class="comment">// 48</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(x) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多维数组</span></span><br><span class="line"><span class="keyword">int</span> board[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">  &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, [<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管数组有多少维度，在内存里面都是线性存储，a[0][0]的后面是a[0][1]，a[0][1]的后面是a[1][0]，以此类推。</span></span><br><span class="line"><span class="comment">// 因此，多维数组也可以使用单层大括号赋值，下面的语句是上面的赋值语句是完全等同的。</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变长数组</span></span><br><span class="line"><span class="comment">// 数组arr就是变长数组，因为它的长度取决于变量n的值，编译器没法事先确定，只有运行时才能知道n是多少。</span></span><br><span class="line"><span class="keyword">int</span> n = x + y;</span><br><span class="line"><span class="keyword">int</span> arr[n];</span><br></pre></td></tr></table></figure>



<h3 id="数组的地址"><a href="#数组的地址" class="headerlink" title="数组的地址"></a>数组的地址</h3><p>数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="comment">// &amp;a[0]就是数组a的首个成员11的内存地址，也是整个数组的起始地址。</span></span><br><span class="line"><span class="comment">// 反过来，从这个地址（*p），可以获得首个成员的值11。</span></span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);  <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>由于数组的起始地址是常用操作，<code>&amp;array[0]</code>的写法有点麻烦，C 语言提供了便利写法，<strong>数组名等同于起始地址</strong>，也就是说，数组名就是指向第一个成员（<code>array[0]</code>）的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span>* p = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 取出 a[0][0] 的值</span></span><br><span class="line">*(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">**a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以，函数接受数组作为参数，函数原型可以写成下面这样。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>; <span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>; <span class="comment">// 写法二</span></span><br></pre></td></tr></table></figure>



<p>数组名指向的地址是不能更改的。</p>
<p>声明数组时，编译器自动为数组分配了内存地址，这个地址与数组名是绑定的，不可更改，下面的代码会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ints[<span class="number">100</span>];</span><br><span class="line">ints = <span class="literal">NULL</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<p>重新为数组名赋值，改变原来的内存地址，就会报错。这也导致不能将一个数组名赋值给另外一个数组名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>] = a; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>];</span><br><span class="line">b = a; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<h3 id="数组指针的加减法"><a href="#数组指针的加减法" class="headerlink" title="数组指针的加减法"></a>数组指针的加减法</h3><p>从一个成员的内存地址移动到另一个成员的内存地址。</p>
<blockquote>
<p>比如，<code>a + 1</code>返回下一个成员的地址，<code>a - 1</code>返回上一个成员的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">arr + <span class="number">1</span>; <span class="comment">// 指针指向 arr[1]</span></span><br><span class="line">arr[<span class="number">0</span>] + <span class="number">1</span> <span class="comment">// 指针指向 arr[0][1]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，内部逻辑其实是<strong>通过指针的移动遍历数组</strong>，<code>a + i</code>的每轮循环每次都会指向下一个成员的地址，<code>*(a + i)</code>取出该地址的值，等同于<code>a[i]</code>。对于数组的第一个成员，<code>*(a + 0)</code>（即<code>*a</code>）等同于<code>a[0]</code>。</p>
<p>由于数组名与指针是等价的，所以下面的等式总是成立。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b] == *(a + b)</span><br></pre></td></tr></table></figure>



<p>还有一种遍历数组的方式：如果指针变量<code>p</code>指向数组的一个成员，那么<code>p++</code>就相当于指向下一个成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">999</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组名指向的地址是不能变的，所以上例中，不能直接对a进行自增，即a++的写法是错的，必须将a的地址赋值给指针变量p，然后对p进行自增。</span></span><br><span class="line"><span class="keyword">while</span> (*p != <span class="number">999</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">  p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同一个数组的两个成员的指针相减时，返回它们之间的距离。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = &amp;a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>* q = &amp;a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p - q); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q - p); <span class="comment">// -4</span></span><br></pre></td></tr></table></figure>



<h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><p>由于数组名是指针，所以复制数组不能简单地复制数组名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int* a;</span><br><span class="line">int b[3] = &#123;1, 2, 3&#125;;</span><br><span class="line"></span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure>

<p>上面的写法，结果不是将数组<code>b</code>复制给数组<code>a</code>，而是让<code>a</code>和<code>b</code>指向同一个数组。</p>
<p>复制数组最简单的方法，还是使用循环，将数组元素逐个进行复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">  a[i] = b[i];</span><br></pre></td></tr></table></figure>

<p>上面示例中，通过将数组<code>b</code>的成员逐个复制给数组<code>a</code>，从而实现数组的赋值。</p>
<p>另一种方法是使用<code>memcpy()</code>函数（定义在头文件<code>string.h</code>），直接把数组所在的那一段内存，再复制一份。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(a, b, <span class="keyword">sizeof</span>(b));</span><br></pre></td></tr></table></figure>

<p>上面示例中，将数组<code>b</code>所在的那段内存，复制给数组<code>a</code>。这种方法要比循环复制数组成员要快。</p>
<h3 id="数组作为函数参数一般要传递长度"><a href="#数组作为函数参数一般要传递长度" class="headerlink" title="数组作为函数参数一般要传递长度"></a>数组作为函数参数一般要传递长度</h3><p>数组作为函数的参数，一般会同时传入数组名和数组长度。由于数组名就是一个指针，如果只传数组名，那么函数只知道数组开始的地址，不知道结束的地址，所以才需要把数组长度也一起传入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是数组本身，也就是数组名，第二个参数是数组长度。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sum_array(a, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>



<p>如果函数的参数是多维数组，那么每一维的长度都要当作参数传入函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">4</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sum_array(a, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<p>变长数组作为参数 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a[n])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sum_array(<span class="number">4</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变长数组的写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> a[n][m])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为函数原型可以省略参数名，所以变长数组的原型中，可以使用*代替变量名，也可以省略变量名。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span> [*])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span> [])</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>a[n]</code>是一个变长数组，它的长度取决于变量<code>n</code>的值，只有运行时才能知道。所以，变量<code>n</code>作为参数时，顺序一定<strong>要在变长数组前面，这样运行时才能确定数组<code>a[n]</code>的长度，否则就会报错</strong>。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>C 语言没有单独的字符串类型，字符串被当作字符数组，即<code>char</code>类型的数组。</li>
<li>比如，字符串“Hello”是当作数组<code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;&#125;</code>处理的。<strong>编译器会给数组分配一段连续内存，所有字符储存在相邻的内存单元之中</strong>。</li>
<li>在字符串结尾，C 语言会自动添加一个全是二进制<code>0</code>的字节，写作<code>\0</code>字符，表示字符串结束。字符<code>\0</code>不同于字符<code>0</code>。所以，字符串“Hello”实际储存的数组是<code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;</code>。</li>
<li>所有字符串的最后一个字符，都是<code>\0</code>。这样做的好处是，C 语言不需要知道字符串的长度，就可以读取内存里面的字符串，只要发现有一个字符是<code>\0</code>，那么就知道字符串结束了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于必须留一个位置给\0，所以最多只能容纳9个字符的字符串。</span></span><br><span class="line"><span class="keyword">char</span> localString[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双引号里面的字符串，不用自己添加结尾字符\0</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span> <span class="comment">// 等价于&#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使双引号里面只有一个字符，也依然被处理成字符串（存储为2个字节），而不是字符&#x27;a&#x27;（存储为1个字节）。</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 允许合并多个字符串字面量，只要这些字符串之间没有间隔，或者只有空格，C 语言会将它们自动合并。</span></span><br><span class="line"><span class="keyword">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, &quot;</span><span class="string">&quot;how are you &quot;</span><span class="string">&quot;today!&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, how are you today!&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="字符串变量的声明"><a href="#字符串变量的声明" class="headerlink" title="字符串变量的声明"></a>字符串变量的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">14</span>] = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 字符串变量声明成一个字符数组</span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 声明成一个指针，指向字符数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 编译器自动计算长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组的长度，可以大于字符串的实际长度。</span></span><br><span class="line"><span class="comment">// 后面空出来的44个位置，都会被初始化为\0。</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组的长度，不能小于字符串的实际长度。</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">5</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="使用字符数组和字符指针声明的区别"><a href="#使用字符数组和字符指针声明的区别" class="headerlink" title="使用字符数组和字符指针声明的区别"></a>使用字符数组和字符指针声明的区别</h3><p>第一个差异是，<strong>指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身</strong>。如果使用数组声明字符串变量，就没有这个问题，可以修改数组的任意成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>为什么字符串声明为指针时不能修改，声明为数组时就可以修改？原因是系统会<strong>将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的</strong>。</p>
<ul>
<li>声明为指针时，指针变量存储的只是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。</li>
<li>但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。</li>
</ul>
<p>为了提醒用户，字符串声明为指针后不得修改，可以在声明时使用<code>const</code>说明符，保证该字符串是只读的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面字符串声明为指针时，使用了<code>const</code>说明符，就保证了该字符串无法修改。一旦修改，编译器肯定会报错。</p>
<p>第二个差异是，指针变量可以指向其它字符串。但是，字符数组变量不能指向另一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组的数组名，总是指向初始化时的字符串地址，不能修改。</span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;world&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的原因，声明字符数组后，不能直接用字符串赋值。</span></span><br><span class="line"><span class="comment">// 原因是字符数组的变量名，跟所指向的数组是绑定的，不能指向另一个地址。</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">s = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>为什么数组变量不能赋值为另一个数组？原因是<strong>数组变量所在的地址无法改变</strong>，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C 语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。</p>
<p>想要重新赋值，必须使用 C 语言原生提供的<code>strcpy()</code>函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即<code>strcpy()</code>只是在原地址写入新的字符串，而不是让数组变量指向新的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>如果一个数组的每个成员都是一个字符串，需要通过二维的字符数组实现。每个字符串本身是一个字符数组，多个字符串再组成一个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> weekdays[<span class="number">7</span>][<span class="number">10</span>] = &#123;</span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例就是一个字符串数组，一共包含7个字符串，所以第一维的长度是7。其中，最长的字符串的长度是10（含结尾的终止符<code>\0</code>），所以第二维的长度统一设为10。</p>
<p>因为第一维的长度，编译器可以自动计算，所以可以省略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> weekdays[][<span class="number">10</span>] = &#123;</span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，二维数组第一维的长度，可以由编译器根据后面的赋值，自动计算，所以可以不写。</p>
<p>数组的第二维，长度统一定为10，有点浪费空间，因为大多数成员的长度都小于10。解决方法就是<strong>把数组的第二维，从字符数组改成字符指针</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* weekdays[] = &#123;</span><br><span class="line">  <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的字符串数组，其实是一个一维数组，成员就是7个字符指针，每个指针指向一个字符串（字符数组）。</p>
<p>遍历字符串数组的写法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, weekdays[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h3><p>strlen()<code>函数返回字符串的字节长度，不包括末尾的空字符\0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The string is %zd characters long.\n&quot;</span>, <span class="built_in">strlen</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意，字符串长度（<code>strlen()</code>）与字符串变量长度（<code>sizeof()</code>），是两个不同的概念。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(s));  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(s));  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>



<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h3><p><code>strcpy()</code>函数，用于将一个字符串的内容复制到另一个字符串，相当于字符串赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">char</span> dest[], <span class="keyword">const</span> <span class="keyword">char</span> source[])</span><br></pre></td></tr></table></figure>



<p>字符串的复制，不能使用赋值运算符，直接将一个字符串赋值给字符数组变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为数组的变量名是一个固定的地址，不能修改，使其指向另一个地址。</span></span><br><span class="line">str1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line">str2 = str1;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果是字符指针，赋值运算符（<code>=</code>）只是将一个指针的地址复制给另一个指针，而不是复制字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s1;</span><br><span class="line"><span class="keyword">char</span>* s2;</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s2 = s1;</span><br></pre></td></tr></table></figure>



<p><code>strcpy()</code>接受两个参数，第一个参数是目的字符串数组，第二个参数是源字符串数组。</p>
<p>复制字符串之前，必须要保证第一个参数的长度不小于第二个参数，否则虽然不会报错，但会溢出第一个字符串变量的边界，发生难以预料的结果。第二个参数的<code>const</code>说明符，表示这个函数不会修改第二个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">  <span class="keyword">char</span> t[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(t, s);</span><br><span class="line"></span><br><span class="line">  t[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);  <span class="comment">// &quot;Hello, world!&quot;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);  <span class="comment">// &quot;zello, world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>strcpy()</code>也可以用于字符数组的赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将字符数组变量，赋值为字符串“abcd”。</p>
<p><code>strcpy()</code>的返回值是一个字符串指针（即<code>char*</code>），指向第一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* s1 = <span class="string">&quot;beast&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">40</span>] = <span class="string">&quot;Be the best that you can be.&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* ps;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从s2的第7个位置开始拷贝字符串beast，前面的位置不变。这导致s2后面的内容都被截去了，因为会连beast结尾的空字符一起拷贝。strcpy()返回的是一个指针，指向拷贝开始的位置。</span></span><br><span class="line">ps = <span class="built_in">strcpy</span>(s2 + <span class="number">7</span>, s1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(s2); <span class="comment">// Be the beast</span></span><br><span class="line"><span class="built_in">puts</span>(ps); <span class="comment">// beast</span></span><br></pre></td></tr></table></figure>



<p><code>strcpy()</code>函数有安全风险，因为它并不检查目标字符串的长度，是否足够容纳源字符串的副本，可能导致写入溢出。如果不能保证不会发生溢出，建议使用<code>strncpy()</code>函数代替。</p>
<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy()"></a>strncpy()</h3><p><code>strncpy()</code>跟<code>strcpy()</code>的用法完全一样，只是多了第3个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">char</span> *dest, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">char</span> *src, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> n</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第三个参数<code>n</code>定义了复制的最大字符数。如果达到最大字符数以后，源字符串仍然没有复制完，就会停止复制，这时目的字符串结尾将没有终止符<code>\0</code>，这一点务必注意。如果源字符串的字符数小于<code>n</code>，则<code>strncpy()</code>的行为与<code>strcpy()</code>完全一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(str1, str2, <span class="keyword">sizeof</span>(str1) - <span class="number">1</span>);</span><br><span class="line">str1[<span class="keyword">sizeof</span>(str1) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，字符串<code>str2</code>复制给<code>str1</code>，但是复制长度最多为<code>str1</code>的长度减去1，<code>str1</code>剩下的最后一位用于写入字符串的结尾标志<code>\0</code>。这是因为<code>strncpy()</code>不会自己添加<code>\0</code>，如果复制的字符串片段不包含结尾标志，就需要手动添加。</p>
<p><code>strncpy()</code>也可以用来拷贝部分字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(s1, s2, <span class="number">5</span>);</span><br><span class="line">s1[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，指定只拷贝前5个字符。</p>
<h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h3><p><code>strcat()</code>函数用于连接字符串。它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。这个函数会改变第一个字符串，但是第二个字符串不变。</p>
<p>该函数的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* s1, <span class="keyword">const</span> <span class="keyword">char</span>* s2)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>strcat()</code>的返回值是一个字符串指针，指向第一个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">12</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">6</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);</span><br><span class="line"><span class="built_in">puts</span>(s1); <span class="comment">// &quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，调用<code>strcat()</code>以后，可以看到字符串<code>s1</code>的值变了。</p>
<p>注意，<code>strcat()</code>的第一个参数的长度，必须足以容纳添加第二个参数字符串。否则，拼接后的字符串会溢出第一个字符串的边界，写入相邻的内存单元，这是很危险的，建议使用下面的<code>strncat()</code>代替。</p>
<h3 id="strncat"><a href="#strncat" class="headerlink" title="strncat()"></a>strncat()</h3><p><code>strncat()</code>用于连接两个字符串，用法与<code>strncat()</code>完全一致，只是增加了第三个参数，指定最大添加的字符数。在添加过程中，一旦达到指定的字符数，或者在源字符串中遇到空字符<code>\0</code>，就不再添加了。它的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">char</span>* dest,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">char</span>* src,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> n</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>strncat()</code>返回第一个参数，即目标字符串指针。</p>
<p>为了保证连接后的字符串，不超过目标字符串的长度，<code>strncat()</code>通常会写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncat</span>(</span><br><span class="line">  str1, </span><br><span class="line">  str2, </span><br><span class="line">  <span class="keyword">sizeof</span>(str1) - <span class="built_in">strlen</span>(str1) - <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>strncat()</code>总是会在拼接结果的结尾，自动添加空字符<code>\0</code>，所以第三个参数的最大值，应该是<code>str1</code>的变量长度减去<code>str1</code>的字符串长度，再减去<code>1</code>。下面是一个用法实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>] = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">8</span>] = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncat</span>(s1, s2, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">puts</span>(s1); <span class="comment">// &quot;MondayTue&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>s1</code>的变量长度是10，字符长度是6，两者相减后再减去1，得到<code>3</code>，表明<code>s1</code>最多可以再添加三个字符，所以得到的结果是<code>MondayTue</code>。</p>
<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p>如果要比较两个字符串，无法直接比较，只能一个个字符进行比较，C 语言提供了<code>strcmp()</code>函数。</p>
<p><code>strcmp()</code>函数用于比较两个字符串的内容。该函数的原型如下，定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s1, <span class="keyword">const</span> <span class="keyword">char</span>* s2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>按照字典顺序，如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 = Happy New Year</span></span><br><span class="line"><span class="comment">// s2 = Happy New Year</span></span><br><span class="line"><span class="comment">// s3 = Happy Holidays</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s3) <span class="comment">// 大于 0</span></span><br><span class="line"><span class="built_in">strcmp</span>(s3, s1) <span class="comment">// 小于 0</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>strcmp()</code>只用来比较字符串，不用来比较字符。因为字符就是小整数，直接用相等运算符（<code>==</code>）就能比较。所以，不要把字符类型（<code>char</code>）的值，放入<code>strcmp()</code>当作参数。</p>
<h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp()"></a>strncmp()</h3><p>由于<code>strcmp()</code>比较的是整个字符串，C 语言又提供了<code>strncmp()</code>函数，只比较到指定的位置。</p>
<p>该函数增加了第三个参数，指定了比较的字符数。它的原型定义在<code>string.h</code>头文件里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">char</span>* s1,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">char</span>* s2, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">size_t</span> n</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它的返回值与<code>strcmp()</code>一样。如果两个字符串相同，返回值为<code>0</code>；如果<code>s1</code>小于<code>s2</code>，<code>strcmp()</code>返回值小于0；如果<code>s1</code>大于<code>s2</code>，返回值大于0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">12</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">12</span>] = <span class="string">&quot;hello C&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(s1, s2, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;They all have hello.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例只比较两个字符串的前5个字符。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>C 语言的内存管理，分成两部分。一部分是系统管理的，另一部分是用户手动管理的。</p>
<p>系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。</p>
<p>用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>