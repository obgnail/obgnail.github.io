<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;sync-Mutex&quot;&gt;&lt;a href=&quot;#sync-Mutex&quot; class=&quot;headerlink&quot; title=&quot;sync.Mutex&quot;&gt;&lt;/a&gt;sync.Mutex&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Mutex 为互斥锁，Lock() 加锁，Unlock() 解锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁&lt;/li&gt;
&lt;li&gt;在 Lock() 之前使用 Unlock() 会导致 panic 异常&lt;/li&gt;
&lt;li&gt;已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁&lt;/li&gt;
&lt;li&gt;在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁&lt;/li&gt;
&lt;li&gt;适用于读写不确定，并且只有一个读或者写的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;总结：对于同一个mutex"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Golang同步原语的简单使用 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-05-31</div></div></div><div class="container post-header"><h1>Golang同步原语的简单使用</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Mutex"><span class="toc-number">1.</span> <span class="toc-text">sync.Mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-RWMutex"><span class="toc-number">2.</span> <span class="toc-text">sync.RWMutex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock-%E5%92%8C-Unlock"><span class="toc-number">2.1.</span> <span class="toc-text">Lock() 和 Unlock()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RLock-%E5%92%8C-RUnlock"><span class="toc-number">2.2.</span> <span class="toc-text">RLock() 和 RUnlock()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock-%E5%92%8C-RLock"><span class="toc-number">2.2.1.</span> <span class="toc-text">Lock() 和 RLock()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unlock-%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%89%8D%E4%B8%8D%E5%AD%98%E5%9C%A8-Lock"><span class="toc-number">2.2.2.</span> <span class="toc-text">Unlock() 使用之前不存在 Lock()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RWMutex-%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">RWMutex 使用不当导致的死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RUnlock-%E4%B9%8B%E5%89%8D%E4%B8%8D%E5%AD%98%E5%9C%A8-RLock"><span class="toc-number">2.2.4.</span> <span class="toc-text">RUnlock() 之前不存在 RLock()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RUnlock-%E4%B8%AA%E6%95%B0%E5%A4%9A%E4%BA%8E-RLock"><span class="toc-number">2.2.5.</span> <span class="toc-text">RUnlock() 个数多于 RLock()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-WaitGroup"><span class="toc-number">3.</span> <span class="toc-text">sync.WaitGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%A0%87%E5%87%86%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">最标准的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitGroup%E5%AF%B9%E8%B1%A1%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">WaitGroup对象不是一个引用类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Once"><span class="toc-number">4.</span> <span class="toc-text">sync.Once</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Cond"><span class="toc-number">5.</span> <span class="toc-text">sync.Cond</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-Cond-%E7%9A%84%E6%83%AF%E7%94%A8%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.1.</span> <span class="toc-text">sync.Cond 的惯用法及使用注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-ErrGroup"><span class="toc-number">6.</span> <span class="toc-text">sync.ErrGroup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-semaphore-WaitGroup"><span class="toc-number">7.</span> <span class="toc-text">sync.semaphore.WaitGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-semaphore%E7%94%A8%E9%80%94"><span class="toc-number">7.1.</span> <span class="toc-text">sync.semaphore用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-singleflight-Group"><span class="toc-number">8.</span> <span class="toc-text">sync.singleflight.Group</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#singleflight-Group%E7%94%A8%E9%80%94"><span class="toc-number">8.1.</span> <span class="toc-text">singleflight.Group用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">使用流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%BD%91%E7%AB%99%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%9C"><span class="toc-number">8.3.</span> <span class="toc-text">缓存网站并发访问结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">8.4.</span> <span class="toc-text">源码</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><ul>
<li>Mutex 为互斥锁，Lock() 加锁，Unlock() 解锁</li>
<li><strong>在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex</strong></li>
<li>使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁</li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁</li>
<li>在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁</li>
<li>适用于读写不确定，并且只有一个读或者写的场景</li>
</ul>
<blockquote>
<p>总结：对于同一个mutex</p>
<ul>
<li>同一个goroutine不能重复执行<code>mutex.Lock()</code>，否则产生deadlock</li>
<li>在goroutineA执行<code>mutex.Lock()</code>之后，其他goroutine如果执行到<code>mutex.Lock()</code>就只能阻塞，直到goroutineA执行<code>mutex.Unlock()</code></li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">   fmt.Println(<span class="string">&quot;Lock the lock&quot;</span>)</span><br><span class="line">   mutex.Lock()</span><br><span class="line">   fmt.Println(<span class="string">&quot;The lock is locked&quot;</span>)</span><br><span class="line">   channels := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">      channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;Not lock: &quot;</span>, i)</span><br><span class="line">         mutex.Lock()</span><br><span class="line">         fmt.Println(<span class="string">&quot;Locked: &quot;</span>, i)</span><br><span class="line">         time.Sleep(time.Second)</span><br><span class="line">         fmt.Println(<span class="string">&quot;Unlock the lock: &quot;</span>, i)</span><br><span class="line">         mutex.Unlock()</span><br><span class="line">         c &lt;- i</span><br><span class="line">      &#125;(i, channels[i])</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Waiting&quot;</span>)</span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line">   fmt.Println(<span class="string">&quot;Unlock the lock&quot;</span>)</span><br><span class="line">   mutex.Unlock()</span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels &#123;</span><br><span class="line">      &lt;-c</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">output：</span><br><span class="line"></span><br><span class="line">Lock the lock</span><br><span class="line">The lock is locked</span><br><span class="line">Waiting</span><br><span class="line">Not lock:  3</span><br><span class="line">Not lock:  1</span><br><span class="line">Not lock:  2</span><br><span class="line">Not lock:  0</span><br><span class="line">Unlock the lock</span><br><span class="line">Locked:  3</span><br><span class="line">Unlock the lock:  3</span><br><span class="line">Locked:  1</span><br><span class="line">Unlock the lock:  1</span><br><span class="line">Locked:  2</span><br><span class="line">Unlock the lock:  2</span><br><span class="line">Locked:  0</span><br><span class="line">Unlock the lock:  0</span><br></pre></td></tr></table></figure>



<p>在解锁之前加锁会导致死锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">   mutex.Lock()</span><br><span class="line">   fmt.Println(<span class="string">&quot;Locked&quot;</span>)</span><br><span class="line">   mutex.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Locked</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>



<h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><ul>
<li>RWMutex 是<strong>单写多读锁</strong>，该锁可以<strong>加多个读锁或者一个写锁</strong></li>
<li>读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁</li>
<li>写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占</li>
<li>适用于读多写少的场景</li>
</ul>
<h3 id="Lock-和-Unlock"><a href="#Lock-和-Unlock" class="headerlink" title="Lock() 和 Unlock()"></a>Lock() 和 Unlock()</h3><ul>
<li>Lock() 加<strong>写锁</strong>，Unlock() 解写锁</li>
<li>如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定</li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
</ul>
<h3 id="RLock-和-RUnlock"><a href="#RLock-和-RUnlock" class="headerlink" title="RLock() 和 RUnlock()"></a>RLock() 和 RUnlock()</h3><ul>
<li>RLock() 加读锁，RUnlock() 解读锁</li>
<li>RLock() 加读锁时，如果存在写锁，则无法加读锁；当只有读锁或者没有锁时，可以加读锁，读锁可以加载多个</li>
<li>RUnlock() 解读锁，RUnlock() 撤销单次 RLock() 调用，对于其他同时存在的读锁则没有效果</li>
<li>在没有读锁的情况下调用 RUnlock() 会导致 panic 错误</li>
<li>RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mutex *sync.RWMutex</span><br><span class="line">    mutex = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Lock the lock&quot;</span>)</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The lock is locked&quot;</span>)</span><br><span class="line"></span><br><span class="line">    channels := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Not lock: &quot;</span>, i)</span><br><span class="line">            mutex.Lock()</span><br><span class="line">            fmt.Println(<span class="string">&quot;Locked: &quot;</span>, i)</span><br><span class="line">            fmt.Println(<span class="string">&quot;Unlock the lock: &quot;</span>, i)</span><br><span class="line">            mutex.Unlock()</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;(i, channels[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;waiting&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Unlock the lock&quot;</span>)</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels &#123;</span><br><span class="line">        &lt;-c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// output：</span><br><span class="line"></span><br><span class="line">Lock the lock</span><br><span class="line">The lock is locked</span><br><span class="line">waiting</span><br><span class="line">Not lock:  0</span><br><span class="line">Not lock:  3</span><br><span class="line">Not lock:  1</span><br><span class="line">Not lock:  2</span><br><span class="line">Unlock the lock</span><br><span class="line">Locked:  0</span><br><span class="line">Unlock the lock:  0</span><br><span class="line">Locked:  3</span><br><span class="line">Unlock the lock:  3</span><br><span class="line">Locked:  1</span><br><span class="line">Unlock the lock:  1</span><br><span class="line">Locked:  2</span><br><span class="line">Unlock the lock:  2</span><br></pre></td></tr></table></figure>



<h4 id="Lock-和-RLock"><a href="#Lock-和-RLock" class="headerlink" title="Lock() 和 RLock()"></a>Lock() 和 RLock()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> mutex *sync.RWMutex</span><br><span class="line">   mutex = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">   fmt.Println(<span class="string">&quot;Lock the lock&quot;</span>)</span><br><span class="line">   mutex.Lock()</span><br><span class="line">   fmt.Println(<span class="string">&quot;The lock is locked&quot;</span>)</span><br><span class="line"></span><br><span class="line">   channels := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">      channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;Not read lock: &quot;</span>, i)</span><br><span class="line">         mutex.RLock()</span><br><span class="line">         fmt.Println(<span class="string">&quot;Read Locked: &quot;</span>, i)</span><br><span class="line"></span><br><span class="line">         time.Sleep(time.Second)</span><br><span class="line">         fmt.Println(<span class="string">&quot;Unlock the read lock: &quot;</span>, i)</span><br><span class="line">         mutex.RUnlock()</span><br><span class="line">         c &lt;- i</span><br><span class="line">      &#125;(i, channels[i])</span><br><span class="line">   &#125;</span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line">   fmt.Println(<span class="string">&quot;Unlock the lock&quot;</span>)</span><br><span class="line">   mutex.Unlock()</span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels &#123;</span><br><span class="line">      &lt;-c</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Lock the lock</span><br><span class="line">The lock is locked</span><br><span class="line">Not read lock:  0</span><br><span class="line">Not read lock:  3</span><br><span class="line">Not read lock:  1</span><br><span class="line">Not read lock:  2</span><br><span class="line">Unlock the lock</span><br><span class="line">Read Locked:  2</span><br><span class="line">Read Locked:  0</span><br><span class="line">Read Locked:  3</span><br><span class="line">Read Locked:  1</span><br><span class="line">Unlock the read lock:  1</span><br><span class="line">Unlock the read lock:  3</span><br><span class="line">Unlock the read lock:  2</span><br><span class="line">Unlock the read lock:  0</span><br></pre></td></tr></table></figure>



<h4 id="Unlock-使用之前不存在-Lock"><a href="#Unlock-使用之前不存在-Lock" class="headerlink" title="Unlock() 使用之前不存在 Lock()"></a>Unlock() 使用之前不存在 Lock()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> rwmutex *sync.RWMutex</span><br><span class="line">   rwmutex = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">   rwmutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: sync: Unlock of unlocked RWMutex</span><br></pre></td></tr></table></figure>



<h4 id="RWMutex-使用不当导致的死锁"><a href="#RWMutex-使用不当导致的死锁" class="headerlink" title="RWMutex 使用不当导致的死锁"></a>RWMutex 使用不当导致的死锁</h4><p>示例1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> rwmutex *sync.RWMutex</span><br><span class="line">   rwmutex = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">   rwmutex.Lock()</span><br><span class="line">   rwmutex.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> rwmutex *sync.RWMutex</span><br><span class="line">   rwmutex = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">   rwmutex.Lock()</span><br><span class="line">   rwmutex.RLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>



<h4 id="RUnlock-之前不存在-RLock"><a href="#RUnlock-之前不存在-RLock" class="headerlink" title="RUnlock() 之前不存在 RLock()"></a>RUnlock() 之前不存在 RLock()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> rwmutex *sync.RWMutex</span><br><span class="line">   rwmutex = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">   rwmutex.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: sync: RUnlock of unlocked RWMutex</span><br></pre></td></tr></table></figure>



<h4 id="RUnlock-个数多于-RLock"><a href="#RUnlock-个数多于-RLock" class="headerlink" title="RUnlock() 个数多于 RLock()"></a>RUnlock() 个数多于 RLock()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> rwmutex *sync.RWMutex</span><br><span class="line">   rwmutex = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">   rwmutex.RLock()</span><br><span class="line">   rwmutex.RLock()</span><br><span class="line">   rwmutex.RUnlock()</span><br><span class="line">   rwmutex.RUnlock()</span><br><span class="line">   rwmutex.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: sync: RUnlock of unlocked RWMutex</span><br></pre></td></tr></table></figure>



<h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>官方文档对 WaitGroup 的描述是：<code>一个 WaitGroup 对象可以等待一组协程结束</code>。使用方法是：</p>
<ol>
<li>main协程通过调用 <code>wg.Add(delta int)</code> 设置worker协程的个数，然后创建worker协程；</li>
<li>worker协程执行结束以后，都要调用 <code>wg.Done()</code>；</li>
<li>main协程调用 <code>wg.Wait()</code> 且被block，直到所有worker协程全部执行结束后返回。</li>
</ol>
<p>sync.WaitGroup只有3个方法:</p>
<ol>
<li>Add()</li>
<li>Done()</li>
<li>Wait()</li>
</ol>
<p>其中Done()是Add(-1)的别名。简单的来说，使用Add()添加计数，Done()减掉一个计数，<strong>计数不为0, 阻塞Wait()的运行</strong>。</p>
<h3 id="最标准的用法"><a href="#最标准的用法" class="headerlink" title="最标准的用法"></a>最标准的用法</h3><p><strong>主goroutine调用Add来设置要等待的goroutine的数量。然后每个goroutine运行并在完成时调用Done。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码 ...</span></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  <span class="keyword">for</span> _, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    task := task</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      task()</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">  <span class="comment">// 省略部分代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WaitGroup</code> 正确使用的要素：</p>
<ol>
<li><code>wg.Done</code> 必须在<code>wg.Add</code> 之后执行，所以要保证两个函数都在main协程中调用；</li>
<li><code>wg.Done</code> 在 worker协程里调用，尤其要保证调用一次，不能因为 panic 或任何原因导致没有执行（建议使用 <code>defer wg.Done()</code>）；</li>
<li><code>wg.Done</code> 和 <code>wg.Wait</code> 在时序上是没有先后。</li>
</ol>
<blockquote>
<p>细心的朋友可能会发现一行非常诡异的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task := task</span><br></pre></td></tr></table></figure>

<p>Go 对 array/slice 进行遍历时，runtime 会把 <code>task[i]</code> 拷贝到 <code>task</code> 的内存地址，下标 <code>i</code> 会变，而 <code>task</code> 的内存地址不会变。如果不进行这次赋值操作，所有 goroutine 可能读到的都是最后一个task。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  tasks := []<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;1. &quot;</span>) &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;2. &quot;</span>) &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> idx, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">    task()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;遍历 = %v, &quot;</span>, unsafe.Pointer(&amp;task))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;下标 = %v, &quot;</span>, unsafe.Pointer(&amp;tasks[idx]))</span><br><span class="line">    task  := task</span><br><span class="line">    fmt.Printf(<span class="string">&quot;局部变量 = %v\\n&quot;</span>, unsafe.Pointer(&amp;task))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1. 遍历 = 0x40c140, 下标 = 0x40c138, 局部变量 = 0x40c150</span></span><br><span class="line"><span class="comment">// 2. 遍历 = 0x40c140, 下标 = 0x40c13c, 局部变量 = 0x40c158</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="WaitGroup对象不是一个引用类型"><a href="#WaitGroup对象不是一个引用类型" class="headerlink" title="WaitGroup对象不是一个引用类型"></a>WaitGroup对象不是一个引用类型</h3><p>WaitGroup对象不是一个引用类型，在通过函数传值的时候需要使用地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> f(i, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要通过指针传值，不然进程会进入死锁状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123; </span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p><strong>sync.Once</strong> 是 Golang package 中使方法只执行一次的对象实现，作用与 <strong>init</strong> 函数类似。但也有所不同。</p>
<ul>
<li><strong>init</strong> 函数是在文件包首次被加载的时候执行，且只执行一次</li>
<li><strong>sync.Once</strong> 是在代码运行中<strong>需要的时候执行</strong>，且只执行一次</li>
</ul>
<blockquote>
<p>当一个函数不希望程序在一开始的时候就被执行的时候，我们可以使用 <strong>sync.Once</strong> 。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> once sync.Once</span><br><span class="line">	onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			once.Do(onceBody)</span><br><span class="line">			done &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		&lt;-done</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Only once</span></span><br></pre></td></tr></table></figure>



<h2 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h2><p>与互斥量不同，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在<strong>对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程</strong>。</p>
<p>条件变量总是与互斥量组合使用。</p>
<ul>
<li>互斥量为共享数据的访问提供互斥支持，</li>
<li>条件变量可以就共享数据的状态的变化向相关线程发出通知。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">cond := sync.NewCond(lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以写成一行</span></span><br><span class="line">cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line">cond.L.Unlock()</span><br><span class="line">cond.Wait()</span><br><span class="line">cond.Signal()</span><br><span class="line">cond.Broadcast()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sync.NewCond(l Locker)</code>: 新建一个 sync.Cond 变量。注意该函数需要一个 Locker 作为必填参数，这是因为在 <code>cond.Wait()</code> 中底层会涉及到 Locker 的锁操作。</li>
<li><code>cond.L.Lock()</code>和<code>cond.L.Unlock()</code>：也可以使用<code>lock.Lock()</code>和<code>lock.Unlock()</code>，完全一样，因为是指针转递</li>
<li><code>cond.Wait()</code>：等待被唤醒。唤醒期间会解锁并切走 goroutine。</li>
<li><code>cond.Signal()</code>：只唤醒一个最先 Wait 的 goroutine。若没有Wait()，也不会报错。<strong>Signal()通知的顺序是根据原来加入通知列表(Wait())的先入先出</strong></li>
<li><code>cond.Broadcast()</code>: 将全部 Wait 的 goroutine 都唤醒。若没有Wait()，也不会报错</li>
</ul>
<blockquote>
<p>一句话总结：<code>sync.Cond</code> 条件变量用来协调想要访问共享资源的那些 goroutine，当共享资源的状态发生变化的时候，它可以用来通知被互斥锁阻塞的 goroutine。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sharedRsc = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	m := sync.Mutex&#123;&#125;</span><br><span class="line">	c := sync.NewCond(&amp;m)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// this go routine wait for changes to the sharedRsc</span></span><br><span class="line">		c.L.Lock()</span><br><span class="line">		<span class="keyword">for</span> sharedRsc == <span class="literal">false</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;goroutine1 wait&quot;</span>)</span><br><span class="line">			c.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;goroutine1&quot;</span>, sharedRsc)</span><br><span class="line">		c.L.Unlock()</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// this go routine wait for changes to the sharedRsc</span></span><br><span class="line">		c.L.Lock()</span><br><span class="line">		<span class="keyword">for</span> sharedRsc == <span class="literal">false</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;goroutine2 wait&quot;</span>)</span><br><span class="line">			c.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;goroutine2&quot;</span>, sharedRsc)</span><br><span class="line">		c.L.Unlock()</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;waiting&quot;</span>)</span><br><span class="line">	<span class="comment">// this one writes changes to sharedRsc</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine ready&quot;</span>)</span><br><span class="line">	sharedRsc = <span class="literal">true</span></span><br><span class="line">	c.Broadcast()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main goroutine broadcast&quot;</span>)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// waiting</span></span><br><span class="line"><span class="comment">// goroutine 2</span></span><br><span class="line"><span class="comment">// goroutine2 wait</span></span><br><span class="line"><span class="comment">// goroutine 1</span></span><br><span class="line"><span class="comment">// goroutine1 wait</span></span><br><span class="line"><span class="comment">// main goroutine ready</span></span><br><span class="line"><span class="comment">// main goroutine broadcast</span></span><br><span class="line"><span class="comment">// goroutine1 true</span></span><br><span class="line"><span class="comment">// goroutine2 true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>sync.Cond 的 Wait 过程，可以简单用下图表示:</p>
<p><img src="/images/cond-wait.png" alt="sync.Cond wait 过程"></p>
</blockquote>
<h3 id="sync-Cond-的惯用法及使用注意事项"><a href="#sync-Cond-的惯用法及使用注意事项" class="headerlink" title="sync.Cond 的惯用法及使用注意事项"></a>sync.Cond 的惯用法及使用注意事项</h3><ol>
<li><p>sync.Cond不能拷贝，否则将会造成<code>panic(&quot;sync.Cond is copied&quot;)</code>错误</p>
</li>
<li><p>Wait 的调用一定要放在 Lock 和 UnLock 中间，否则将会造成<code>panic(&quot;sync: unlock of unlocked mutex&quot;)</code>错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition() &#123;</span><br><span class="line">       c.Wait()</span><br><span class="line">&#125;</span><br><span class="line">... <span class="built_in">make</span> use of condition ...</span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因很简单，因为Wait源码内部执行了Unlock：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	<span class="comment">// 这里不要误解了，c.notify 并不是 notifyList 里面的 notify 属性，而是 notifyList 本身</span></span><br><span class="line">	t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">	<span class="comment">// 注意这里，必须先解锁，因为 runtime_notifyListWait 要切走 goroutine</span></span><br><span class="line">	<span class="comment">// 所以这里要解锁，要不然其他 goroutine 没法获取到锁了</span></span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">	<span class="comment">// 这里已经唤醒了，因此需要再度锁上</span></span><br><span class="line">	c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>Wait 调用的条件检查一定要放在 for 循环中</strong>。这是因为当 Boardcast 唤醒时，有可能其他 goroutine 先于当前 goroutine 唤醒并抢到锁，导致轮到当前 goroutine 抢到锁的时候，条件又不再满足了。因此，需要将条件检查放在 for 循环中。</p>
</li>
<li><p>Signal 和 Boardcast 两个唤醒操作不需要加锁。</p>
</li>
</ol>
<h2 id="sync-ErrGroup"><a href="#sync-ErrGroup" class="headerlink" title="sync.ErrGroup"></a>sync.ErrGroup</h2><p>Go 团队发布的第一个 goroutines 的管理工具是 sync.WaitGroup，这个工具允许你创建 WaitGroup 去等待一定数量的 goroutines 执行完成。这里有个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.somestupidname.com/&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        <span class="comment">// Increment the WaitGroup counter.</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// Launch a goroutine to fetch the URL.</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// Decrement the counter when the goroutine completes.</span></span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                <span class="comment">// Fetch the URL.</span></span><br><span class="line">                http.Get(url)</span><br><span class="line">        &#125;(url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait for all HTTP fetches to complete.</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>

<p>WaitGroup 使你在处理并发任务时对 goroutines 的创建和停止的数量控制都变的更加简单。每次你创建 goroutine 的时候只要调用 Add() 就可以了。当这个任务结束调用 wg.Done()。等待所有的任务完成，调用 wg.Wait()。但是用 WatiGroup 唯一的问题就是当你的 goroutines 出错时，你不能捕获到错误的原因。</p>
<p>sync.ErrGroup 相当于为 sync.WaitGroup 增加了错误返回的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;errorURL1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;errorURL2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;errorURL3&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    url := url</span><br><span class="line">    g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        resp, err := http.Get(url)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            resp.Body.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Successfully fetched all URLs.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>g.Go() 这个方法不仅允许你传一个匿名的函数，而且还能捕获错误信息，你只要像这样返回一个错误 return err。这对使用 goroutines 的开发者来说在功能上是一个很大的提升。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	group := <span class="built_in">new</span>(errgroup.Group)</span><br><span class="line">	nums := []<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		tempNum := num <span class="comment">// 子协程中若直接访问num，则可能是同一个变量，所以要用临时变量</span></span><br><span class="line">		<span class="comment">// 子协程</span></span><br><span class="line">		group.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> tempNum &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span>  errors.New(<span class="string">&quot;tempNum &lt; 0 !!!&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;tempNum:&quot;</span>,tempNum)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 捕获err</span></span><br><span class="line">	<span class="keyword">if</span> err := group.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Get errors: &quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Get all num successfully!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sync-semaphore-WaitGroup"><a href="#sync-semaphore-WaitGroup" class="headerlink" title="sync.semaphore.WaitGroup"></a>sync.semaphore.WaitGroup</h2><h3 id="sync-semaphore用途"><a href="#sync-semaphore用途" class="headerlink" title="sync.semaphore用途"></a>sync.semaphore用途</h3><ul>
<li>需求：要限制服务的并发次数，但是每个API要求的算力还不一样，</li>
<li>怎么做，如果用上sync/semaphore就行。</li>
</ul>
<h2 id="sync-singleflight-Group"><a href="#sync-singleflight-Group" class="headerlink" title="sync.singleflight.Group"></a>sync.singleflight.Group</h2><h3 id="singleflight-Group用途"><a href="#singleflight-Group用途" class="headerlink" title="singleflight.Group用途"></a>singleflight.Group用途</h3><ul>
<li><code>singleflight.Group</code>是大并发下面的一把利器。一个请求如果访问1s，同样的请求来了500路，如果你的机器只能支持100路，处理完请求要5s。如果用上这个库，同样的机器，只要1s</li>
<li><strong>原因</strong>: singleflight.Group会缓存那一瞬间的并发请求(相同key值)</li>
</ul>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ul>
<li>声明总权重数: <code>s := semaphore.NewWeighted(10)</code>，申请的总权重数是10</li>
<li>申请你的权重，不同的业务使用不同的权重，比如这里的mysql使用了2，cached使用了1.:  <code>b := c.TryAcquire(c.weighted)</code>，从总权重数减去你申请的</li>
<li>运行一些业务，这里使用sleep模拟真实业务运行时间: <code>time.Sleep(time.Second)</code></li>
<li>释放你的权重，有借有还，再借不难: <code>c.Release(c.weighted)</code>，恢复权重数至你申请之前</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/semaphore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(u <span class="keyword">string</span>)</span></span> &#123;<span class="comment">// 模拟抓取任务的执行</span></span><br><span class="line">    fmt.Println(u)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Limit  = <span class="number">3</span> <span class="comment">// 同時并行运行的goroutine上限</span></span><br><span class="line">    Weight = <span class="number">1</span> <span class="comment">// 每个goroutine获取信号量资源的权重</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    urls := []<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.example.net&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.example.net/foo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.example.net/bar&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.example.net/baz&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    s := semaphore.NewWeighted(Limit)</span><br><span class="line">    <span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        w.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            s.Acquire(context.Background(), Weight)</span><br><span class="line">            doSomething(u)</span><br><span class="line">            s.Release(Weight)</span><br><span class="line">            w.Done()</span><br><span class="line">        &#125;(u)</span><br><span class="line">    &#125;</span><br><span class="line">    w.Wait()</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;All Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="缓存网站并发访问结果"><a href="#缓存网站并发访问结果" class="headerlink" title="缓存网站并发访问结果"></a>缓存网站并发访问结果</h3><ul>
<li>使用<code>var group singleflight.Group</code>　缓存<code>https://http2.golang.org/reqinfo</code>网站并发访问结果。 </li>
<li>第一个go程成功访问<code>https://http2.golang.org/reqinfo</code>网站内容，后面排队中的并发goroutine不会真的访问，都是从缓存里面拿结果。</li>
<li><strong>注意</strong>: 要体会singleflight.Group和普通缓存的区别，可以把下面的<code>go func(id int)&#123;&#125;</code>，使用goroutine起回调函数和去除goroutine起有什么区别，你会发现<strong>goroutine起的函数会缓存，不用goroutine起的函数没有缓存</strong>，请仔细体会这点。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/guonaihong/gout&quot;</span></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/singleflight&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> group singleflight.Group</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">defer</span> wg.Wait()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">            res, err, _ := group.Do(<span class="string">&quot;reqinfo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">                s := <span class="string">&quot;&quot;</span></span><br><span class="line">                err := gout.GET(<span class="string">&quot;https://http2.golang.org/reqinfo&quot;</span>).Debug(<span class="literal">true</span>).BindBody(&amp;s).Do()</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span>, err </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> s, <span class="literal">nil</span> </span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;fail:%s\n&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fmt.Printf(<span class="string">&quot;id(%d) ------&gt;%s\n&quot;</span>, id, res.(<span class="keyword">string</span>))</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singlefilght</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]*Call <span class="comment">// 对于每一个需要获取的key有一个对应的call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call代表需要被执行的函数</span></span><br><span class="line"><span class="keyword">type</span> Call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg sync.WaitGroup <span class="comment">// 用于阻塞这个调用call的其他请求</span></span><br><span class="line">    val <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 函数执行后的结果</span></span><br><span class="line">    err error         <span class="comment">// 函数执行后的error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Call)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果获取当前key的函数正在被执行，则阻塞等待执行中的，等待其执行完毕后获取它的执行结果</span></span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        c.wg.Wait()</span><br><span class="line">        <span class="keyword">return</span> c.val, c.err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个call，往map中写后就解</span></span><br><span class="line">    c := <span class="built_in">new</span>(Call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行获取key的函数，并将结果赋值给这个Call</span></span><br><span class="line">    c.val, c.err = fn()</span><br><span class="line">    c.wg.Done()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新上锁删除key</span></span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(g.m, key)</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>