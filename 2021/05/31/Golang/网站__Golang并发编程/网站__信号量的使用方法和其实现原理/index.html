<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;什么是信号量&quot;&gt;&lt;a href=&quot;#什么是信号量&quot; class=&quot;headerlink&quot; title=&quot;什么是信号量&quot;&gt;&lt;/a&gt;什么是信号量&lt;/h2&gt;&lt;p&gt;信号量的概念是计算机科学家 &lt;strong&gt;Dijkstra&lt;/strong&gt; （Dijkstra算法的发明者）提出来的，广泛应用在不同的操作系统中。系统中，会给每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>信号量的使用方法和其实现原理 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-05-31</div></div></div><div class="container post-header"><h1>信号量的使用方法和其实现原理</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">什么是信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">Go语言中的信号量表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Go%E7%BC%96%E7%A8%8B%E9%87%8C%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">在Go编程里使用信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">Go语言信号量的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">信号量的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Acquire%E8%AF%B7%E6%B1%82%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%B5%84%E6%BA%90"><span class="toc-number">4.2.</span> <span class="toc-text">Acquire请求信号量资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NotifyWaiters-%E9%80%9A%E7%9F%A5%E7%AD%89%E5%BE%85%E8%80%85"><span class="toc-number">4.3.</span> <span class="toc-text">NotifyWaiters 通知等待者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Release%E5%BD%92%E8%BF%98%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%B5%84%E6%BA%90"><span class="toc-number">4.4.</span> <span class="toc-text">Release归还信号量资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></details></div><div class="container post-content"><h2 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h2><p>信号量的概念是计算机科学家 <strong>Dijkstra</strong> （Dijkstra算法的发明者）提出来的，广泛应用在不同的操作系统中。系统中，会给每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。</p>
<p>如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a>（Mutex）</p>
<p>计数信号量具备两种操作动作，称为V（<code>signal()</code>）与P（<code>wait()</code>）（即部分参考书常称的“PV操作”）。V操作会增加信号量S的数值，P操作会减少它。</p>
<p>运行方式：</p>
<ol>
<li>初始化信号量，给与它一个非负数的整数值。</li>
<li>运行P（<code>wait()</code>），信号量S的值将被减少。企图进入<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5">临界区</a>的进程，需要先运行P（<code>wait()</code>）。当信号量S减为负值时，进程会被阻塞住，不能继续；当信号量S不为负值时，进程可以获准进入临界区。</li>
<li>运行V（<code>signal()</code>），信号量S的值会被增加。结束离开<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5">临界区段</a>的进程，将会运行V（<code>signal()</code>）。当信号量S不为负值时，先前被阻塞住的其他进程，将可获准进入<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5">临界区</a>。</li>
</ol>
<p>我们一般用信号量保护一组资源，比如数据库连接池、一组客户端的连接等等。<strong>每次获取资源时都会将信号量中的计数器减去对应的数值，在释放资源时重新加回来</strong>。当信号量没资源时尝试获取信号量的线程就会进入休眠，等待其他线程释放信号量。如果信号量是只有0和1的二进位信号量，那么，它的 P/V 就和互斥锁的 Lock/Unlock 就一样了。</p>
<h2 id="Go语言中的信号量表示"><a href="#Go语言中的信号量表示" class="headerlink" title="Go语言中的信号量表示"></a>Go语言中的信号量表示</h2><p><code>Go</code> 内部使用信号量来控制<code>goroutine</code>的阻塞和唤醒，比如互斥锁<code>sync.Mutex</code>结构体定义的第二个字段就是一个信号量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span></span><br><span class="line">    sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量的PV操作在<code>Go</code>内部是通过下面这几个底层函数实现的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_Semacquire</span><span class="params">(s *<span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_SemacquireMutex</span><span class="params">(s *<span class="keyword">uint32</span>, lifo <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_Semrelease</span><span class="params">(s *<span class="keyword">uint32</span>, handoff <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>上面几个函数都是<code>Go</code>语言内部使用的，我们不能在编程时直接使用。不过<code>Go</code> 语言的扩展并发原语包中提供了带权重的信号量 <code>semaphore.Weighted</code></p>
<p>我们可以按照不同的权重对资源的访问进行管理，这个结构体对外提供了四个方法：</p>
<ul>
<li><strong>semaphore.NewWeighted</strong> 用于创建新的信号量，通过参数(n int64) 指定信号量的初始值。</li>
<li><strong>semaphore.Weighted.Acquire</strong> 阻塞地获取指定权重的资源，如果当前没有空闲资源，就会陷入休眠等待；相当于 P 操作，你可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。它的第一个参数是 Context，这就意味着，你可以通过 Context 增加超时或者 cancel 的机制。如果是正常获取了资源，就返回 <code>nil</code>；否则，就返回<code> ctx.Err()</code>，信号量不改变。</li>
<li><strong>semaphore.Weighted.Release</strong> 用于释放指定权重的资源；相当于 V 操作，可以将 n 个资源释放，返还给信号量。</li>
<li><strong>semaphore.Weighted.TryAcquire</strong> 非阻塞地获取指定权重的资源，如果当前没有空闲资源，就会直接返回 <code>false</code>；</li>
</ul>
<h2 id="在Go编程里使用信号量"><a href="#在Go编程里使用信号量" class="headerlink" title="在Go编程里使用信号量"></a>在Go编程里使用信号量</h2><p>在实际应用<code>Go</code>语言开发程序时，有哪些场景适合使用信号量呢？<strong>在需要控制访问资源的线程数量时就会需要信号量</strong>。</p>
<p>假设我们有一组要抓取的页面，资源有限最多允许我们同时执行三个抓取任务，当同时有三个抓取任务在执行时，在执行完一个抓取任务后才能执行下一个排队等待的任务。当然这个问题用Channel也能解决，不过这次我们使用Go提供的信号量原语来解决这个问题，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/sync/semaphore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(u <span class="keyword">string</span>)</span></span> &#123;<span class="comment">// 模拟抓取任务的执行</span></span><br><span class="line">    fmt.Println(u)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Limit  = <span class="number">3</span> <span class="comment">// 同時并行运行的goroutine上限</span></span><br><span class="line">    Weight = <span class="number">1</span> <span class="comment">// 每个goroutine获取信号量资源的权重</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    urls := []<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;http://www.example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.example.net&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.example.net/foo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.example.net/bar&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.example.net/baz&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    s := semaphore.NewWeighted(Limit)</span><br><span class="line">    <span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        w.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            s.Acquire(context.Background(), Weight)</span><br><span class="line">            doSomething(u)</span><br><span class="line">            s.Release(Weight)</span><br><span class="line">            w.Done()</span><br><span class="line">        &#125;(u)</span><br><span class="line">    &#125;</span><br><span class="line">    w.Wait()</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;All Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Go语言信号量的实现原理"><a href="#Go语言信号量的实现原理" class="headerlink" title="Go语言信号量的实现原理"></a>Go语言信号量的实现原理</h2><p><code>Go</code>语言 扩展库中的信号量是使用互斥锁和 List 实现的。互斥锁实现其它字段的保护，而 List 实现了一个等待队列，等待者的通知是通过 <code>Channel</code> 的通知机制实现的。</p>
<h3 id="信号量的数据结构"><a href="#信号量的数据结构" class="headerlink" title="信号量的数据结构"></a>信号量的数据结构</h3><p>我们来看一下信号量<code>semaphore.Weighted</code>的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">    size    <span class="keyword">int64</span>         <span class="comment">// 最大资源数</span></span><br><span class="line">    cur     <span class="keyword">int64</span>         <span class="comment">// 当前已被使用的资源</span></span><br><span class="line">    mu      sync.Mutex    <span class="comment">// 互斥锁，对字段的保护</span></span><br><span class="line">    waiters list.List     <span class="comment">// 等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code>字段用来记录信号量拥有的最大资源数。</li>
<li><code>cur</code>标识当前已被使用的资源数。</li>
<li><code>mu</code>是一个互斥锁用来提供对其他字段的临界区保护。</li>
<li><code>waiters</code>表示申请资源时由于可使用资源不够而陷入阻塞等待的调用者列表。</li>
</ul>
<h3 id="Acquire请求信号量资源"><a href="#Acquire请求信号量资源" class="headerlink" title="Acquire请求信号量资源"></a>Acquire请求信号量资源</h3><p><code>Acquire</code>方法会监控资源是否可用，而且还要检测传递进来的<code>context.Context</code>对象是否发送了超时过期或者取消的信号，我们来看一下它的代码实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Acquire</span><span class="params">(ctx context.Context, n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="comment">// 如果恰好有足够的资源，也没有排队等待获取资源的goroutine，</span></span><br><span class="line">    <span class="comment">// 将cur加上n后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span> &#123;</span><br><span class="line">      s.cur += n</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 请求的资源数大于能提供的最大的资源数</span></span><br><span class="line">    <span class="comment">// 这个任务处理不了，走错误处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; s.size &#123;</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">      <span class="comment">// 依赖ctx的状态返回，否则一直等待</span></span><br><span class="line">      &lt;-ctx.Done()</span><br><span class="line">      <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现存资源不够, 需要把调用者加入到等待队列中</span></span><br><span class="line">    <span class="comment">// 创建了一个ready chan,以便被通知唤醒</span></span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    w := waiter&#123;n: n, ready: ready&#125;</span><br><span class="line">    elem := s.waiters.PushBack(w)</span><br><span class="line">    s.mu.Unlock()</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 等待</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// context的Done被关闭</span></span><br><span class="line">      err := ctx.Err()</span><br><span class="line">      s.mu.Lock()</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-ready: <span class="comment">// 如果被唤醒了，忽略ctx的状态</span></span><br><span class="line">        err = <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="comment">// 通知waiter</span></span><br><span class="line">        isFront := s.waiters.Front() == elem</span><br><span class="line">        s.waiters.Remove(elem)</span><br><span class="line">        <span class="comment">// 通知其它的waiters,检查是否有足够的资源</span></span><br><span class="line">        <span class="keyword">if</span> isFront &amp;&amp; s.size &gt; s.cur &#123;</span><br><span class="line">          s.notifyWaiters()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    <span class="keyword">case</span> &lt;-ready: <span class="comment">// 等待者被唤醒了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果调用者请求不到信号量的资源就会被加入等待者列表里，这里等待者列表的结构体定义是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	n     <span class="keyword">int64</span></span><br><span class="line">	ready <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 当调用者可以获取到信号量资源时, close调这个chan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包含了两个字段，调用者请求的资源数，以及一个ready 通道。ready通道会在调用者可以被重新唤醒的时候被<code>close</code>调，从而起到通知正在阻塞读取ready通道的等待者的作用。</p>
<h3 id="NotifyWaiters-通知等待者"><a href="#NotifyWaiters-通知等待者" class="headerlink" title="NotifyWaiters 通知等待者"></a>NotifyWaiters 通知等待者</h3><p><code>notifyWaiters</code>方法会逐个检查队列里等待的调用者，如果现存资源够等待者请求的数量n，或者是没有等待者了，就返回：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">notifyWaiters</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      next := s.waiters.Front()</span><br><span class="line">      <span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 没有等待者了，直接返回</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      w := next.Value.(waiter)</span><br><span class="line">      <span class="keyword">if</span> s.size-s.cur &lt; w.n &#123;</span><br><span class="line">        <span class="comment">// 如果现有资源不够队列头调用者请求的资源数，就退出所有等待者会继续等待</span></span><br><span class="line">        <span class="comment">// 这里还是按照先入先出的方式处理是为了避免饥饿</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      s.cur += w.n</span><br><span class="line">      s.waiters.Remove(next)</span><br><span class="line">      <span class="built_in">close</span>(w.ready)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>notifyWaiters</code>方法是按照先入先出的方式唤醒调用者。当释放 100 个资源的时候，如果第一个等待者需要 101 个资源，那么，队列中的所有等待者都会继续等待，即使队列后面有的等待者只需要 1 个资源。这样做的目的是避免饥饿，否则的话，资源可能总是被那些请求资源数小的调用者获取，这样一来，请求资源数巨大的调用者，就没有机会获得资源了。</p>
<h3 id="Release归还信号量资源"><a href="#Release归还信号量资源" class="headerlink" title="Release归还信号量资源"></a>Release归还信号量资源</h3><p><code>Release</code>方法就很简单了，它将当前计数值减去释放的资源数 n，并调用<code>notifyWaiters</code>方法，尝试唤醒等待队列中的调用者，看是否有足够的资源被获取。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Release</span><span class="params">(n <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    s.cur -= n</span><br><span class="line">    <span class="keyword">if</span> s.cur &lt; <span class="number">0</span> &#123;</span><br><span class="line">      s.mu.Unlock()</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;semaphore: released more than held&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    s.notifyWaiters()</span><br><span class="line">    s.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在<code>Go</code>语言中信号量有时候也会被<code>Channel</code>类型所取代，因为一个 buffered chan 也可以代表 n 个资源。不过既然<code>Go</code>语言通过<code>golang.orgx/sync</code>扩展库对外提供了<code>semaphore.Weight</code>这一种信号量实现，遇到使用信号量的场景时还是尽量使用官方提供的实现。在使用的过程中我们需要注意以下的几个问题：</p>
<ul>
<li><code>Acquire</code>和 <code>TryAcquire</code>方法都可以用于获取资源，前者会阻塞地获取信号量。后者会非阻塞地获取信号量，如果获取不到就返回<code>false</code>。</li>
<li><code>Release</code>归还信号量后，会以先进先出的顺序唤醒等待队列中的调用者。如果现有资源不够处于等待队列前面的调用者请求的资源数，所有等待者会继续等待。</li>
<li>如果一个<code>goroutine</code>申请较多的资源，由于上面说的归还后唤醒等待者的策略，它可能会等待比较长的时间。</li>
</ul>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>