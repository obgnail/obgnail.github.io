<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后&lt;strong&gt;给每个类型上的每个字段提供解析函数&lt;/strong&gt;。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>GraphQL中文文档 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/GraphQL/" rel="tag">GraphQL</a></div><div class="post-time">2021-05-11</div></div></div><div class="container post-header"><h1>GraphQL中文文档</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%8F%98%E6%9B%B4"><span class="toc-number">2.</span> <span class="toc-text">查询和变更</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%EF%BC%88field%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">字段（field）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%EF%BC%88Arguments%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">参数（Arguments）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%AB%E5%90%8D%EF%BC%88Aliases%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">别名（Aliases）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%87%E6%AE%B5%EF%BC%88Fragments%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">片段（Fragments）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%89%87%E6%AE%B5%E5%86%85%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">在片段内使用变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%90%8D%E7%A7%B0%EF%BC%88Operation-name%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">操作名称（Operation name）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%EF%BC%88Variables%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">变量（Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%EF%BC%88Variable-definitions%EF%BC%89"><span class="toc-number">2.6.1.</span> <span class="toc-text">变量定义（Variable definitions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%98%E9%87%8F%EF%BC%88Default-variables%EF%BC%89"><span class="toc-number">2.6.2.</span> <span class="toc-text">默认变量（Default variables）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%EF%BC%88Directives%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">指令（Directives）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E6%9B%B4%EF%BC%88Mutations%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">变更（Mutations）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E6%9B%B4%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%88Multiple-fields-in-mutations%EF%BC%89"><span class="toc-number">2.8.1.</span> <span class="toc-text">变更中的多个字段（Multiple fields in mutations）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E7%89%87%E6%AE%B5%EF%BC%88Inline-Fragments%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">内联片段（Inline Fragments）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E6%AE%B5%EF%BC%88Meta-fields%EF%BC%89"><span class="toc-number">2.9.1.</span> <span class="toc-text">元字段（Meta fields）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Schema-%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Schema 和类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%88Type-System%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">类型系统（Type System）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%88Type-Language%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">类型语言（Type Language）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E6%AE%B5%EF%BC%88Object-Types-and-Fields%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">对象类型和字段（Object Types and Fields）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%EF%BC%88Arguments%EF%BC%89-1"><span class="toc-number">3.4.</span> <span class="toc-text">参数（Arguments）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%8F%98%E6%9B%B4%E7%B1%BB%E5%9E%8B%EF%BC%88The-Query-and-Mutation-Types%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">查询和变更类型（The Query and Mutation Types）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%88Scalar-Types%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">标量类型（Scalar Types）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%EF%BC%88Enumeration-Types%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">枚举类型（Enumeration Types）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%92%8C%E9%9D%9E%E7%A9%BA%EF%BC%88Lists-and-Non-Null%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">列表和非空（Lists and Non-Null）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88Interfaces%EF%BC%89"><span class="toc-number">3.9.</span> <span class="toc-text">接口（Interfaces）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88Union-Types%EF%BC%89"><span class="toc-number">3.10.</span> <span class="toc-text">联合类型（Union Types）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%88Input-Types%EF%BC%89"><span class="toc-number">3.11.</span> <span class="toc-text">输入类型（Input Types）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">4.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-number">5.</span> <span class="toc-text">执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E5%AD%97%E6%AE%B5-amp-%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">根字段 &amp; 解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">异步解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%87%8D%E8%A6%81%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">不重要的解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%BC%BA%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">标量强制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">列表解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C"><span class="toc-number">5.6.</span> <span class="toc-text">产生结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%9C%81"><span class="toc-number">6.</span> <span class="toc-text">内省</span></a></li></ol></details></div><div class="container post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后<strong>给每个类型上的每个字段提供解析函数</strong>。</p>
<p>例如，一个 GraphQL 服务告诉我们当前登录用户是 <code>me</code>，这个用户的名称可能像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  me: User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一并的还有每个类型上字段的解析函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Query_me</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request.auth.user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User_name</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦一个 GraphQL 服务运行起来（通常在 web 服务的一个 URL 上），它就能接收 GraphQL 查询，并验证和执行。接收到的查询首先会被检查确保它只引用了已定义的类型和字段，然后运行指定的解析函数来生成结果。</p>
<p>例如这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  me &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会产生这样的JSON结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;me&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查询和变更"><a href="#查询和变更" class="headerlink" title="查询和变更"></a>查询和变更</h2><h3 id="字段（field）"><a href="#字段（field）" class="headerlink" title="字段（field）"></a>字段（field）</h3><p>GraphQL 查询能够<strong>遍历相关对象</strong>及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    # 查询可以有备注！</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个例子中，<code>friends</code> 返回了一个数组的项目，GraphQL 查询会同等看待单个项目或者一个列表的项目，然而我们可以通过 schema 所指示的内容来预测将会得到哪一种。</p>
<h3 id="参数（Arguments）"><a href="#参数（Arguments）" class="headerlink" title="参数（Arguments）"></a>参数（Arguments）</h3><p>即使我们能做的仅仅是遍历对象及其字段，GraphQL 就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  human(id: &quot;1000&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    height</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;human&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;height&quot;: 1.72</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 GraphQL 中，<strong>每一个字段和嵌套对象都能有自己的一组参数</strong>，从而使得 GraphQL 可以完美替代多次 API 获取请求。甚至你也可以给 标量（scalar）字段传递参数，用于实现服务端的一次转换，而不用每个客户端分别转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  human(id: &quot;1000&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    height(unit: FOOT)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;human&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;height&quot;: 5.6430448</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数可以是多种不同的类型。上面例子中，我们使用了一个枚举类型，其代表了一个有限选项集合（本例中为长度单位，即是 <code>METER</code> 或者 <code>FOOT</code>）。<strong>GraphQL 自带一套默认类型</strong>，但是 GraphQL 服务器可以声明一套自己的定制类型，只要能序列化成你的传输格式即可。</p>
<h3 id="别名（Aliases）"><a href="#别名（Aliases）" class="headerlink" title="别名（Aliases）"></a>别名（Aliases）</h3><p>即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要<strong>别名</strong> —— 这可以让你重命名结果中的字段为任意你想到的名字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  empireHero: hero(episode: EMPIRE) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  jediHero: hero(episode: JEDI) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;empireHero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;jediHero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，两个 <code>hero</code> 字段将会存在冲突，但是因为我们可以将其另取一个别名，我们也就可以在一次请求中得到两个结果。</p>
<h3 id="片段（Fragments）"><a href="#片段（Fragments）" class="headerlink" title="片段（Fragments）"></a>片段（Fragments）</h3><p>假设我们的 app 有比较复杂的页面，将正反派主角及其友军分为两拨。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次 —— 两方各一次以作比较。</p>
<p>这就是为何 GraphQL 包含了称作<strong>片段</strong>的可复用单元。片段使你能够组织<code>一组字段</code>，然后在需要它们的地方引入。下面例子展示了如何使用片段解决上述场景：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  leftComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">  rightComparison: hero(episode: JEDI) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment comparisonFields on Character &#123;</span><br><span class="line">  name</span><br><span class="line">  appearsIn</span><br><span class="line">  friends &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;leftComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rightComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看到上面的查询如何漂亮地重复了字段。片段的概念经常用于将复杂的应用数据需求分割成小块，特别是你要将大量不同片段的 UI 组件组合成一个初始数据获取的时候。</p>
<h4 id="在片段内使用变量"><a href="#在片段内使用变量" class="headerlink" title="在片段内使用变量"></a>在片段内使用变量</h4><p>片段可以访问查询或变更中声明的变量。详见 <a target="_blank" rel="noopener" href="https://graphql.cn/learn/queries/#variables">变量</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">query HeroComparison($first: Int = 3) &#123;</span><br><span class="line">  leftComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">  rightComparison: hero(episode: JEDI) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment comparisonFields on Character &#123;</span><br><span class="line">  name</span><br><span class="line">  friendsConnection(first: $first) &#123;</span><br><span class="line">    totalCount</span><br><span class="line">    edges &#123;</span><br><span class="line">      node &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;leftComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;friendsConnection&quot;: &#123;</span><br><span class="line">        &quot;totalCount&quot;: 4,</span><br><span class="line">        &quot;edges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rightComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;friendsConnection&quot;: &#123;</span><br><span class="line">        &quot;totalCount&quot;: 3,</span><br><span class="line">        &quot;edges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="操作名称（Operation-name）"><a href="#操作名称（Operation-name）" class="headerlink" title="操作名称（Operation name）"></a>操作名称（Operation name）</h3><p>这之前，我们都使用了简写句法，省略了 <code>query</code> 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。</p>
<p>下面的示例包含了作为<strong>操作类型</strong>的关键字 <code>query</code> 以及<strong>操作名称</strong> <code>HeroNameAndFriends</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">query HeroNameAndFriends &#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>操作类型</strong>可以是 quer、mutation 或 subscription，描述你打算做什么类型的操作。</p>
<blockquote>
<p><strong>操作类型是必需的，除非你使用查询简写语法</strong>，在这种情况下，你无法为操作提供名称或变量定义。</p>
</blockquote>
</li>
<li><p><strong>操作名称</strong>是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络或是 GraphQL 服务器的日志中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。</p>
</li>
</ul>
<h3 id="变量（Variables）"><a href="#变量（Variables）" class="headerlink" title="变量（Variables）"></a>变量（Variables）</h3><p>目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的：例如，可能是一个”下拉菜单”让你选择感兴趣的《星球大战》续集，或者是一个搜索区，或者是一组过滤器。</p>
<p>将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL 拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为<strong>变量</strong>。</p>
<p>使用变量之前，我们得做三件事：</p>
<ol>
<li>使用 <code>$variableName</code> 替代查询中的静态值。</li>
<li>声明 <code>$variableName</code> 为查询接受的变量之一。</li>
<li>将 <code>variableName: value</code> 通过传输专用（通常是 JSON）的分离的变量字典中。</li>
</ol>
<p>全部做完之后就像这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ($name: String!)：声明一个变量使用$符号开头，冒号后面紧跟着变量的传入类型。如果要使用变量，直接引用即可，例如下面的 movie 就可以改写成 movie(name: $name)。</span><br><span class="line">// (name: “Manchester”)：参数名为name 值为Manchester</span><br><span class="line"></span><br><span class="line">query myQry ($name: String!) &#123;</span><br><span class="line">  movie(name: “Manchester”) &#123;</span><br><span class="line">    name</span><br><span class="line">    desc</span><br><span class="line">    ratings</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ouput</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;movie&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Manchester By the Sea&quot;,</span><br><span class="line">      &quot;desc&quot;: &quot;this is desc&quot;,</span><br><span class="line">      &quot;ratings&quot;: &quot;R&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># &#123; &quot;graphiql&quot;: true, &quot;variables&quot;: &#123; &quot;episode&quot;: JEDI &#125; &#125;</span><br><span class="line">query HeroNameAndFriends($episode: Episode) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们的客户端代码就只需要传入不同的变量，而不用构建一个全新的查询了。这事实上也是一个良好实践，意味着查询的参数将是动态的 —— 我们决不能使用用户提供的值来字符串插值以构建查询。</p>
<h4 id="变量定义（Variable-definitions）"><a href="#变量定义（Variable-definitions）" class="headerlink" title="变量定义（Variable definitions）"></a>变量定义（Variable definitions）</h4><p>变量定义看上去像是上述查询中的 <code>($episode: Episode)</code>。其工作方式跟类型语言中函数的参数定义一样。它以列出所有变量，变量前缀必须为 <code>$</code>，后跟其类型，本例中为 <code>Episode</code>。</p>
<p>所有声明的变量都必须是<strong>标量、枚举型或者输入对象类型</strong>。所以如果想要传递一个复杂对象到一个字段上，你必须知道服务器上其匹配的类型。可以从Schema页面了解更多关于输入对象类型的信息。</p>
<p>变量定义可以是<code>可选的</code>或者<code>必要的</code>。上例中，<code>Episode</code> 后并没有 <code>!</code>，因此其是可选的。但是如果你传递变量的字段要求非空参数，那变量一定是必要的。</p>
<h4 id="默认变量（Default-variables）"><a href="#默认变量（Default-variables）" class="headerlink" title="默认变量（Default variables）"></a>默认变量（Default variables）</h4><p>可以通过在查询中的类型定义后面附带默认值的方式，将默认值赋给变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query HeroNameAndFriends($episode: Episode = &quot;JEDI&quot;) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当所有变量都有默认值的时候，你可以不传变量直接调用查询。如果任何变量作为变量字典的部分传递了，它将覆盖其默认值。</p>
<h3 id="指令（Directives）"><a href="#指令（Directives）" class="headerlink" title="指令（Directives）"></a>指令（Directives）</h3><p>我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。<strong>譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。</strong></p>
<p>我们来构建一个这种组件的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">query Hero($episode: Episode, $withFriends: Boolean!) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends @include(if: $withFriends) &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;episode&quot;: &quot;JEDI&quot;,</span><br><span class="line">  &quot;withFriends&quot;: false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试修改上面的变量，传递 <code>true</code> 给 <code>withFriends</code>，看看结果的变化。</p>
<p>我们用了 GraphQL 中一种称作<strong>指令</strong>的新特性。一个指令可以附着在字段或者片段包含的字段上，然后以任何服务端期待的方式来改变查询的执行。GraphQL 的核心规范包含两个指令，其必须被任何规范兼容的 GraphQL 服务器实现所支持：</p>
<ul>
<li><code>@include(if: Boolean)</code> 仅在参数为 <code>true</code> 时，包含此字段。</li>
<li><code>@skip(if: Boolean)</code> 如果参数为 <code>true</code>，跳过此字段。</li>
</ul>
<p>指令在你不得不通过字符串操作来增减查询的字段时解救你。服务端实现也可以定义新的指令来添加新的特性。</p>
<h3 id="变更（Mutations）"><a href="#变更（Mutations）" class="headerlink" title="变更（Mutations）"></a>变更（Mutations）</h3><p>GraphQL 的大部分讨论集中在数据获取，但是任何完整的数据平台也都需要一个改变服务端数据的方法。</p>
<p>REST 中，任何请求都可能最后导致一些服务端副作用，但是约定上建议不要使用 <code>GET</code> 请求来修改数据。GraphQL 也是类似 —— 技术上而言，任何查询都可以被实现为导致数据写入。然而，建一个约定来规范任何导致写入的操作都应该显式通过变更（mutation）来发送。</p>
<p>就如同查询一样，<strong>如果任何变更字段返回一个对象类型，你也能请求其嵌套字段</strong>。</p>
<p>获取一个对象变更后的新状态也是十分有用的。我们来看看一个变更例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</span><br><span class="line">  createReview(episode: $ep, review: $review) &#123;</span><br><span class="line">    stars</span><br><span class="line">    commentary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;,</span><br><span class="line">  &quot;review&quot;: &#123;</span><br><span class="line">    &quot;stars&quot;: 5,</span><br><span class="line">    &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;createReview&quot;: &#123;</span><br><span class="line">      &quot;stars&quot;: 5,</span><br><span class="line">      &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>createReview</code> 字段如何返回了新建的 review 的 <code>stars</code> 和 <code>commentary</code> 字段。这在变更已有数据时特别有用，例如，当一个字段自增的时候，我们可以在一个请求中变更并查询这个字段的新值。</p>
<p>你也可能注意到，这个例子中，我们传递的 <code>review</code> 变量并非标量。它是一个<strong>输入对象类型</strong>，一种特殊的对象类型，可以作为参数传递。你可以在 Schema 页面上了解到更多关于输入类型的信息。</p>
<h4 id="变更中的多个字段（Multiple-fields-in-mutations）"><a href="#变更中的多个字段（Multiple-fields-in-mutations）" class="headerlink" title="变更中的多个字段（Multiple fields in mutations）"></a>变更中的多个字段（Multiple fields in mutations）</h4><p>一个变更也能包含多个字段，一如查询。查询和变更之间名称之外的一个重要区别是：</p>
<p><strong>查询字段时，是并行执行，而变更字段时，是线性执行，一个接着一个。</strong></p>
<p>这意味着如果我们一个请求中发送了两个 <code>incrementCredits</code> 变更，第一个保证在第二个之前执行，以确保我们不会出现竞态。</p>
<h3 id="内联片段（Inline-Fragments）"><a href="#内联片段（Inline-Fragments）" class="headerlink" title="内联片段（Inline Fragments）"></a>内联片段（Inline Fragments）</h3><p>跟许多类型系统一样，GraphQL schema 也具备定义<code>接口</code>和<code>联合类型</code>的能力。<a target="_blank" rel="noopener" href="https://graphql.cn/learn/schema/#interfaces">在 schema 指南中可了解更多。</a></p>
<p>如果你查询的字段返回的是接口或者联合类型，那么你可能需要使用<strong>内联片段</strong>来取出下层具体类型的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;primaryFunction&quot;: &quot;Astromech&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个查询中，<code>hero</code> 字段返回 <code>Character</code> 类型，取决于 <code>episode</code> 参数，其可能是 <code>Human</code> 或者 <code>Droid</code> 类型。在直接选择的情况下，你只能请求 <code>Character</code> 上存在的字段，譬如 <code>name</code>。</p>
<p>如果要请求具体类型上的字段，你需要使用一个类型条件<strong>内联片段</strong>。因为第一个片段标注为 <code>... on Droid</code>，<code>primaryFunction</code> 仅在 <code>hero</code> 返回的 <code>Character</code> 为 <code>Droid</code> 类型时才会执行。同理适用于 <code>Human</code> 类型的 <code>height</code> 字段。</p>
<p>具名片段也可以用于同样的情况，因为具名片段总是附带了一个类型。</p>
<h4 id="元字段（Meta-fields）"><a href="#元字段（Meta-fields）" class="headerlink" title="元字段（Meta fields）"></a>元字段（Meta fields）</h4><p>某些情况下，你并不知道你将从 GraphQL 服务获得什么类型，这时候你就需要一些方法在客户端来决定如何处理这些数据。GraphQL 允许你在查询的任何位置请求 <code>__typename</code>，一个元字段，以获得那个位置的对象类型名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output </span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;search&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Starship&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;TIE Advanced x1&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的查询中，<code>search</code> 返回了一个联合类型，其可能是三种选项之一。没有 <code>__typename</code> 字段的情况下，几乎不可能在客户端分辨开这三个不同的类型。</p>
<p>GraphQL 服务提供了不少元字段，剩下的部分用于描述 <a target="_blank" rel="noopener" href="https://graphql.cn/learn/introspection/">内省</a> 系统。</p>
<h2 id="Schema-和类型"><a href="#Schema-和类型" class="headerlink" title="Schema 和类型"></a>Schema 和类型</h2><h3 id="类型系统（Type-System）"><a href="#类型系统（Type-System）" class="headerlink" title="类型系统（Type System）"></a>类型系统（Type System）</h3><p>如果你之前见到过 GraphQL 查询，你就知道 GraphQL 查询语言基本上就是关于选择对象上的字段。因此，例如在下列查询中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>我们以一个特殊的对象 “root” 开始</li>
<li>选择其上的 <code>hero</code> 字段</li>
<li>对于 <code>hero</code> 返回的对象，我们选择 <code>name</code> 和 <code>appearsIn</code> 字段</li>
</ol>
<p>因为一个 GraphQL 查询的结构和结果非常相似，因此即便不知道服务器的情况，你也能预测查询会返回什么结果。</p>
<p>但是一个关于我们所需要的数据的确切描述依然很有意义，我们能选择什么字段？服务器会返回哪种对象？这些对象下有哪些字段可用？这便是引入 schema 的原因。</p>
<p>每一个 GraphQL 服务都会定义一套类型，用以描述你可能从那个服务查询到的数据。每当查询到来，服务器就会根据 schema 验证并执行查询。</p>
<h3 id="类型语言（Type-Language）"><a href="#类型语言（Type-Language）" class="headerlink" title="类型语言（Type Language）"></a>类型语言（Type Language）</h3><p>GraphQL 服务可以用任何语言编写，因为我们并不依赖于任何特定语言的句法句式（譬如 JavaScript）来与 GraphQL schema 沟通，我们定义了自己的简单语言，称之为 “GraphQL schema language” —— 它和 GraphQL 的查询语言很相似，让我们能够和 GraphQL schema 之间可以无语言差异地沟通。</p>
<h3 id="对象类型和字段（Object-Types-and-Fields）"><a href="#对象类型和字段（Object-Types-and-Fields）" class="headerlink" title="对象类型和字段（Object Types and Fields）"></a>对象类型和字段（Object Types and Fields）</h3><p>一个 GraphQL schema 中的最基本的组件是对象类型，它就<strong>表示你可以从服务上获取到什么类型的对象</strong>，以及这个对象有什么字段。使用 GraphQL schema language，我们可以这样表示它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  appearsIn: [Episode!]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这语言可读性相当好，但我们还是一起看看其用语，以便我们可以有些共通的词汇：</p>
<ul>
<li><code>Character</code> 是一个 <strong>GraphQL 对象类型</strong>，表示其是一个拥有一些字段的类型。你的 schema 中的大多数类型都会是对象类型。</li>
<li><code>name</code> 和 <code>appearsIn</code> 是 <code>Character</code> 类型上的<strong>字段</strong>。这意味着在一个操作 <code>Character</code> 类型的 GraphQL 查询中的任何部分，都只能出现 <code>name</code> 和 <code>appearsIn</code> 字段。</li>
<li><code>String</code> 是内置的<strong>标量</strong>类型之一 —— 标量类型是解析到单个标量对象的类型，无法在查询中对它进行次级选择。后面我们将细述标量类型。</li>
<li><code>String!</code> 表示这个字段是<strong>非空的</strong>，GraphQL 服务保证当你查询这个字段后总会给你返回一个值。在类型语言里面，我们用一个感叹号来表示这个特性。</li>
<li><code>[Episode!]!</code> 表示一个 <code>Episode</code> <strong>数组</strong>。因为它也是<strong>非空的</strong>，所以当你查询 <code>appearsIn</code> 字段的时候，你也总能得到一个数组（零个或者多个元素）。且由于 <code>Episode!</code> 也是<strong>非空的</strong>，你总是可以预期到数组中的每个项目都是一个 <code>Episode</code> 对象。</li>
</ul>
<p>现在你知道一个 GraphQL 对象类型看上去是怎样，也知道如何阅读基础的 GraphQL 类型语言了。</p>
<h3 id="参数（Arguments）-1"><a href="#参数（Arguments）-1" class="headerlink" title="参数（Arguments）"></a>参数（Arguments）</h3><p>GraphQL 对象类型上的每一个字段都可能有零个或者多个参数，例如下面的 <code>length</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Starship &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  length(unit: LengthUnit = METER): Float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有参数都是具名的，不像 JavaScript 或者 Python 之类的语言，函数接受一个有序参数列表，而在 GraphQL 中，<strong>所有参数必须具名传递</strong>。本例中，<code>length</code> 字段定义了一个参数，<code>unit</code>。</p>
<p>参数可能是必选或者可选的，当一个参数是可选的，我们可以定义一个<strong>默认值</strong> —— 如果 <code>unit</code> 参数没有传递，那么它将会被默认设置为 <code>METER</code>。</p>
<h3 id="查询和变更类型（The-Query-and-Mutation-Types）"><a href="#查询和变更类型（The-Query-and-Mutation-Types）" class="headerlink" title="查询和变更类型（The Query and Mutation Types）"></a>查询和变更类型（The Query and Mutation Types）</h3><p>你的 schema 中大部分的类型都是普通对象类型，但是一个 schema 内有两个特殊类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">  query: Query</span><br><span class="line">  mutation: Mutation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个 GraphQL 服务都有一个 <code>query</code> 类型，可能有一个 <code>mutation</code> 类型。这两个类型和常规对象类型无差，但是它们之所以特殊，是因为它们定义了每一个 GraphQL 查询的<strong>入口</strong>。因此如果你看到一个像这样的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  droid(id: &quot;2000&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;droid&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那表示这个 GraphQL 服务需要一个 <code>Query</code> 类型，且其上有 <code>hero</code> 和 <code>droid</code> 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  hero(episode: Episode): Character</span><br><span class="line">  droid(id: ID!): Droid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变更也是类似的工作方式 —— 你在 <code>Mutation</code> 类型上定义一些字段，然后这些字段将作为 mutation 根字段使用，接着你就能在你的查询中调用。</p>
<p>有必要记住的是，除了作为 schema 的入口，<code>Query</code> 和 <code>Mutation</code> 类型与其它 GraphQL 对象类型别无二致，它们的字段也是一样的工作方式。</p>
<h3 id="标量类型（Scalar-Types）"><a href="#标量类型（Scalar-Types）" class="headerlink" title="标量类型（Scalar Types）"></a>标量类型（Scalar Types）</h3><p>一个对象类型有自己的名字和字段，而某些时候，这些字段必然会解析到具体数据。这就是标量类型的来源：它们表示对应 GraphQL 查询的叶子节点。</p>
<p>下列查询中，<code>name</code> 和 <code>appearsIn</code> 字段将解析到标量类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道这些字段没有任何次级字段 —— 因为让它们是查询的叶子节点。</p>
<p>GraphQL 自带一组默认标量类型：</p>
<ul>
<li><code>Int</code>：有符号 32 位整数。</li>
<li><code>Float</code>：有符号双精度浮点值。</li>
<li><code>String</code>：UTF‐8 字符序列。</li>
<li><code>Boolean</code>：<code>true</code> 或者 <code>false</code>。</li>
<li><code>ID</code>：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。</li>
</ul>
<p>大部分的 GraphQL 服务实现中，都有自定义标量类型的方式。例如，我们可以定义一个 <code>Date</code> 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scalar Date</span><br></pre></td></tr></table></figure>

<p>然后就取决于我们的实现中如何定义将其序列化、反序列化和验证。例如，你可以指定 <code>Date</code> 类型应该总是被序列化成整型时间戳，而客户端应该知道去要求任何 date 字段都是这个格式。</p>
<h3 id="枚举类型（Enumeration-Types）"><a href="#枚举类型（Enumeration-Types）" class="headerlink" title="枚举类型（Enumeration Types）"></a>枚举类型（Enumeration Types）</h3><p>也称作<strong>枚举（enum）</strong>，枚举类型是一种特殊的标量，它限制在一个特殊的可选值集合内。这让你能够：</p>
<ol>
<li>验证这个类型的任何参数是可选值的的某一个</li>
<li>与类型系统沟通，一个字段总是一个有限值集合的其中一个值。</li>
</ol>
<p>下面是一个用 GraphQL schema 语言表示的 enum 定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Episode &#123;</span><br><span class="line">  NEWHOPE</span><br><span class="line">  EMPIRE</span><br><span class="line">  JEDI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这表示无论我们在 schema 的哪处使用了 <code>Episode</code>，都可以肯定它返回的是 <code>NEWHOPE</code>、<code>EMPIRE</code> 和 <code>JEDI</code> 之一。</p>
<p>注意，各种语言实现的 GraphQL 服务会有其独特的枚举处理方式。对于将枚举作为一等公民的语言，它的实现就可以利用这个特性；而对于像 JavaScript 这样没有枚举支持的语言，这些枚举值可能就被内部映射成整数值。当然，这些细节都不会泄漏到客户端，客户端会根据字符串名称来操作枚举值。</p>
<h3 id="列表和非空（Lists-and-Non-Null）"><a href="#列表和非空（Lists-and-Non-Null）" class="headerlink" title="列表和非空（Lists and Non-Null）"></a>列表和非空（Lists and Non-Null）</h3><p>对象类型、标量以及枚举是 GraphQL 中你唯一可以定义的类型种类。但是当你在 schema 的其他部分使用这些类型时，或者在你的查询变量声明处使用时，你可以给它们应用额外的<strong>类型修饰符</strong>来影响这些值的验证。我们先来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处我们使用了一个 <code>String</code> 类型，并通过在类型名后面添加一个感叹号<code>!</code>将其标注为<strong>非空</strong>。这表示我们的服务器对于这个字段，总是会返回一个非空值，如果它结果得到了一个空值，那么事实上将会触发一个 GraphQL 执行错误，以让客户端知道发生了错误。</p>
<p>非空类型修饰符也可以用于定义字段上的参数，如果这个参数上传递了一个空值（不管通过 GraphQL 字符串还是变量），那么会导致服务器返回一个验证错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">query DroidById($id: ID!) &#123;</span><br><span class="line">  droid(id: $id) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Variables</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Variable \&quot;$id\&quot; of required type \&quot;ID!\&quot; was not provided.&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 1,</span><br><span class="line">          &quot;column&quot;: 17</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>列表的运作方式也类似：我们也可以使用一个类型修饰符来标记一个类型为 <code>List</code>，表示这个字段会返回这个类型的数组。在 GraphQL schema 语言中，我们通过将类型包在方括号（<code>[</code> 和 <code>]</code>）中的方式来标记列表。列表对于参数也是一样的运作方式，验证的步骤会要求对应值为数组。</p>
<p>非空和列表修饰符可以组合使用。例如你可以要求一个非空字符串的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myField: [String!]</span><br></pre></td></tr></table></figure>

<p>这表示<strong>数组本身</strong>可以为空，但是其不能有任何空值成员。用 JSON 举例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: <span class="literal">null</span> <span class="comment">// 有效</span></span><br><span class="line"><span class="attr">myField</span>: [] <span class="comment">// 有效</span></span><br><span class="line"><span class="attr">myField</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>] <span class="comment">// 有效</span></span><br><span class="line"><span class="attr">myField</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>] <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>然后，我们来定义一个不可为空的字符串数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myField: [String]!</span><br></pre></td></tr></table></figure>

<p>这表示数组本身不能为空，但是其可以包含空值成员：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: <span class="literal">null</span> <span class="comment">// 错误</span></span><br><span class="line"><span class="attr">myField</span>: [] <span class="comment">// 有效</span></span><br><span class="line"><span class="attr">myField</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>] <span class="comment">// 有效</span></span><br><span class="line"><span class="attr">myField</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>] <span class="comment">// 有效</span></span><br></pre></td></tr></table></figure>

<p>你可以根据需求嵌套任意层非空和列表修饰符。</p>
<h3 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h3><p>跟许多类型系统一样，GraphQL 支持接口。一个<strong>接口</strong>是一个抽象类型，它包含某些字段，而对象类型必须包含这些字段，才能算实现了这个接口。</p>
<p>例如，你可以用一个 <code>Character</code> 接口用以表示《星球大战》三部曲中的任何角色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着任何<strong>实现</strong> <code>Character</code> 的类型都要具有这些字段，并有对应参数和返回类型。</p>
<p>例如，这里有一些可能实现了 <code>Character</code> 的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Human implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  starships: [Starship]</span><br><span class="line">  totalCredits: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  primaryFunction: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见这两个类型都具备 <code>Character</code> 接口的所有字段，但也引入了其他的字段 <code>totalCredits</code>、<code>starships</code> 和 <code>primaryFunction</code>，这都属于特定的类型的角色。</p>
<p>当你要返回一个对象或者一组对象，特别是一组不同的类型时，接口就显得特别有用。</p>
<p>注意下面例子的查询会产生错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    primaryFunction</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Variable</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Cannot query field \&quot;primaryFunction\&quot; on type \&quot;Character\&quot;. Did you mean to use an inline fragment on \&quot;Droid\&quot;?&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 4,</span><br><span class="line">          &quot;column&quot;: 5</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hero</code> 字段返回 <code>Character</code> 类型，取决于 <code>episode</code> 参数，它可能是 <code>Human</code> 或者 <code>Droid</code> 类型。上面的查询中，你只能查询 <code>Character</code> 接口中存在的字段，而其中并不包含 <code>primaryFunction</code>。</p>
<p>如果要查询一个只存在于特定对象类型上的字段，你需要使用内联片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Variable</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;primaryFunction&quot;: &quot;Astromech&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在查询指南的 <a target="_blank" rel="noopener" href="https://graphql.cn/learn/queries/#inline-fragments">内联片段</a> 章节了解更多相关信息。</p>
<h3 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h3><p>有时候在一个查询的结果里返回的类型可能是两种不同的对象，在指定返回字段时应根据实际的类型来指定返回哪些字段，这时可以使用联合类型。</p>
<p>联合类型和接口十分相似，但是它并不指定类型之间的任何共同字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union SearchResult = Human | Droid | Starship</span><br></pre></td></tr></table></figure>

<p>在我们的schema中，任何返回一个 <code>SearchResult</code> 类型的地方，都可能得到一个 <code>Human</code>、<code>Droid</code> 或者 <code>Starship</code>。注意，联合类型的成员需要是具体对象类型；<strong>你不能使用接口或者其他联合类型来创造一个联合类型</strong>。</p>
<p>这时候，如果你需要查询一个返回 <code>SearchResult</code> 联合类型的字段，那么你得使用条件片段才能查询任意字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      name</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      name</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;search&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Han Solo&quot;,</span><br><span class="line">        &quot;height&quot;: 1.8</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Leia Organa&quot;,</span><br><span class="line">        &quot;height&quot;: 1.5</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Starship&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;TIE Advanced x1&quot;,</span><br><span class="line">        &quot;length&quot;: 9.2</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_typename</code> 字段解析为 <code>String</code>，它允许你在客户端区分不同的数据类型。</p>
<p>此外，在这种情况下，由于 <code>Human</code> 和 <code>Droid</code> 共享一个公共接口（<code>Character</code>），你可以在一个地方查询它们的公共字段，而不必在多个类型中重复相同的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Character &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>name</code> 仍然需要指定在 <code>Starship</code> 上，否则它不会出现在结果中，因为 <code>Starship</code> 并不是一个 <code>Character</code>！</p>
<h3 id="输入类型（Input-Types）"><a href="#输入类型（Input-Types）" class="headerlink" title="输入类型（Input Types）"></a>输入类型（Input Types）</h3><p>目前为止，我们只讨论过将例如枚举和字符串等标量值作为参数传递给字段，但是你也能很容易地传递复杂对象。这在变更（mutation）中特别有用，因为有时候你需要传递一整个对象作为新建对象。在 GraphQL schema language 中，输入对象看上去和常规对象一模一样，除了关键字是 <code>input</code> 而不是 <code>type</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input ReviewInput &#123;</span><br><span class="line">  stars: Int!</span><br><span class="line">  commentary: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以像这样在变更（mutation）中使用输入对象类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</span><br><span class="line">  createReview(episode: $ep, review: $review) &#123;</span><br><span class="line">    stars</span><br><span class="line">    commentary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Variable：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;,</span><br><span class="line">  &quot;review&quot;: &#123;</span><br><span class="line">    &quot;stars&quot;: 5,</span><br><span class="line">    &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;createReview&quot;: &#123;</span><br><span class="line">      &quot;stars&quot;: 5,</span><br><span class="line">      &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入对象类型上的字段本身也可以指代输入对象类型，但是你不能在你的 schema 混淆输入和输出类型。输入对象类型的字段当然也不能拥有参数。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>通过使用类型系统，你可以预判一个查询是否有效。这让服务器和客户端可以在无效查询创建时就有效地通知开发者，而不用依赖运行时检查。</p>
<p>对于我们的《星球大战》的案例，<a target="_blank" rel="noopener" href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsValidation-test.js">starWarsValidation-test.js</a> 这个文件包含了若干对于各种无效查询的演示，它也是一个测试文件，用于检测参考实现的验证器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    ...NameAndAppearances</span><br><span class="line">    friends &#123;</span><br><span class="line">      ...NameAndAppearances</span><br><span class="line">      friends &#123;</span><br><span class="line">        ...NameAndAppearances</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment NameAndAppearances on Character &#123;</span><br><span class="line">  name</span><br><span class="line">  appearsIn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">          &quot;appearsIn&quot;: [</span><br><span class="line">            &quot;NEWHOPE&quot;,</span><br><span class="line">            &quot;EMPIRE&quot;,</span><br><span class="line">            &quot;JEDI&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;friends&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Han Solo&quot;,</span><br><span class="line">              &quot;appearsIn&quot;: [</span><br><span class="line">                &quot;NEWHOPE&quot;,</span><br><span class="line">                &quot;EMPIRE&quot;,</span><br><span class="line">                &quot;JEDI&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Leia Organa&quot;,</span><br><span class="line">              &quot;appearsIn&quot;: [</span><br><span class="line">                &quot;NEWHOPE&quot;,</span><br><span class="line">                &quot;EMPIRE&quot;,</span><br><span class="line">                &quot;JEDI&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;C-3PO&quot;,</span><br><span class="line">              &quot;appearsIn&quot;: [</span><br><span class="line">                &quot;NEWHOPE&quot;,</span><br><span class="line">                &quot;EMPIRE&quot;,</span><br><span class="line">                &quot;JEDI&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">              &quot;appearsIn&quot;: [</span><br><span class="line">                &quot;NEWHOPE&quot;,</span><br><span class="line">                &quot;EMPIRE&quot;,</span><br><span class="line">                &quot;JEDI&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;,</span><br><span class="line">          &quot;appearsIn&quot;: [</span><br><span class="line">            &quot;NEWHOPE&quot;,</span><br><span class="line">            &quot;EMPIRE&quot;,</span><br><span class="line">            &quot;JEDI&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;friends&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">              &quot;appearsIn&quot;: [</span><br><span class="line">                &quot;NEWHOPE&quot;,</span><br><span class="line">                &quot;EMPIRE&quot;,</span><br><span class="line">                &quot;JEDI&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">              &quot;appearsIn&quot;: [</span><br><span class="line">                &quot;NEWHOPE&quot;,</span><br><span class="line">                &quot;EMPIRE&quot;,</span><br><span class="line">                &quot;JEDI&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;,</span><br><span class="line">          &quot;appearsIn&quot;: [</span><br><span class="line">            &quot;NEWHOPE&quot;,</span><br><span class="line">            &quot;EMPIRE&quot;,</span><br><span class="line">            &quot;JEDI&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;friends&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">              &quot;appearsIn&quot;: [</span><br><span class="line">                &quot;NEWHOPE&quot;,</span><br><span class="line">                &quot;EMPIRE&quot;,</span><br><span class="line">                &quot;JEDI&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;C-3PO&quot;,</span><br><span class="line">              &quot;appearsIn&quot;: [</span><br><span class="line">                &quot;NEWHOPE&quot;,</span><br><span class="line">                &quot;EMPIRE&quot;,</span><br><span class="line">                &quot;JEDI&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">              &quot;appearsIn&quot;: [</span><br><span class="line">                &quot;NEWHOPE&quot;,</span><br><span class="line">                &quot;EMPIRE&quot;,</span><br><span class="line">                &quot;JEDI&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个查询是有效的。我们来看看一些无效查询……</p>
<p>片段不能引用其自身或者创造回环，因为这会导致结果无边界。下面是一个相同的查询，但是没有显式的三层嵌套：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    ...NameAndAppearancesAndFriends</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment NameAndAppearancesAndFriends on Character &#123;</span><br><span class="line">  name</span><br><span class="line">  appearsIn</span><br><span class="line">  friends &#123;</span><br><span class="line">    ...NameAndAppearancesAndFriends</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Cannot spread fragment \&quot;NameAndAppearancesAndFriends\&quot; within itself.&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 11,</span><br><span class="line">          &quot;column&quot;: 5</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>查询字段的时候，我们只能查询给定类型上的字段。因此由于 <code>hero</code> 返回 <code>Character</code> 类型，我们只能查询 <code>Character</code> 上的字段。因为这个类型上没有 <code>favoriteSpaceship</code> 字段，所以这个查询是无效的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 无效：favoriteSpaceship 不存在于 Character 之上</span><br><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    favoriteSpaceship</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Cannot query field \&quot;favoriteSpaceship\&quot; on type \&quot;Character\&quot;.&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 4,</span><br><span class="line">          &quot;column&quot;: 5</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当我们查询一个字段时，如果其返回值不是标量或者枚举型，那我们就需要指明想要从这个字段中获取的数据。<code>hero</code> 返回 <code>Character</code> 类型，我们也请求了其中像是 <code>name</code> 和<code>appearsIn</code> 的字段；但如果将其省略，这个查询就变成无效的了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 无效：hero 不是标量，需要指明下级字段</span><br><span class="line">&#123;</span><br><span class="line">  hero</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// outout:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Field \&quot;hero\&quot; of type \&quot;Character\&quot; must have a selection of subfields. Did you mean \&quot;hero &#123; ... &#125;\&quot;?&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 3,</span><br><span class="line">          &quot;column&quot;: 3</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类似地，如果一个字段是标量，进一步查询它上面的字段也没有意义，这样做也会导致查询无效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 无效：name 是标量，因此不允许下级字段查询</span><br><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name &#123;</span><br><span class="line">      firstCharacterOfName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Field \&quot;name\&quot; must not have a selection since type \&quot;String!\&quot; has no subfields.&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 4,</span><br><span class="line">          &quot;column&quot;: 10</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们之前提到过，只有目标类型上的字段才可查询；当我们查询 <code>hero</code> 时，它会返回 <code>Character</code>，因此只有 <code>Character</code> 上的字段是可查询的。但如果我们要查的是 R2-D2 的 primary function 呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 无效：primaryFunction 不存在于 Character 之上</span><br><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    primaryFunction</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Cannot query field \&quot;primaryFunction\&quot; on type \&quot;Character\&quot;. Did you mean to use an inline fragment on \&quot;Droid\&quot;?&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 5,</span><br><span class="line">          &quot;column&quot;: 5</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个查询是无效的，因为 <code>primaryFunction</code> 并不是 <code>Character</code> 的字段。我们需要某种方法来表示：如果对应的 <code>Character</code> 是 <code>Droid</code>，我们希望获取 <code>primaryFunction</code> 字段，而在其他情况下，则忽略此字段。我们可以使用之前引入的“片段”来解决这个问题。先在 <code>Droid</code> 上定义一个片段，然后在查询中引入它，这样我们就能在定义了 <code>primaryFunction</code> 的地方查询它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    ...DroidFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment DroidFields on Droid &#123;</span><br><span class="line">  primaryFunction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;primaryFunction&quot;: &quot;Astromech&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个查询是有效的，但是有点琐碎；具名片段在我们需要多次使用的时候更有价值，如果只使用一次，那么我们应该使用内联片段而不是具名片段；这同样能表示我们想要查询的类型，而不用单独命名一个片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;primaryFunction&quot;: &quot;Astromech&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这只是验证系统的冰山一角；事实上需要一大套验证规则才能保证 GraphQL 查询的语义意义。规范中的“验证”章节有关于本话题更详细的内容，GraphQL.js 的 <a target="_blank" rel="noopener" href="https://github.com/graphql/graphql-js/blob/master/src/validation">validation</a> 目录包含了规范兼容的 GraphQL 验证器实现代码。</p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>一个 GraphQL 查询在被验证后，GraphQL 服务器会将之执行，并返回与请求的结构相对应的结果，该结果通常会是 JSON 的格式。</p>
<p>GraphQL 不能脱离类型系统处理查询，让我们用一个类型系统的例子来说明一个查询的执行过程，在这一系列的文章中我们重复使用了这些类型，下文是其中的一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  human(id: ID!): Human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Human &#123;</span><br><span class="line">  name: String</span><br><span class="line">  appearsIn: [Episode]</span><br><span class="line">  starships: [Starship]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Episode &#123;</span><br><span class="line">  NEWHOPE</span><br><span class="line">  EMPIRE</span><br><span class="line">  JEDI</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Starship &#123;</span><br><span class="line">  name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们用一个例子来描述当一个查询请求被执行的全过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  human(id: 1002) &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">    starships &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;human&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Han Solo&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;starships&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Millenium Falcon&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Imperial shuttle&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以将 GraphQL 查询中的每个字段视为返回子类型的父类型函数或方法。事实上，这正是 GraphQL 的工作原理。每个类型的每个字段都由一个 <em>resolver</em> 函数支持，该函数由 GraphQL 服务器开发人员提供。当一个字段被执行时，相应的 <em>resolver</em> 被调用以产生下一个值。</p>
<p>如果字段产生标量值，例如字符串或数字，则执行完成。如果一个字段产生一个对象，则该查询将继续执行该对象对应字段的解析器，直到生成标量值。GraphQL 查询始终以标量值结束。</p>
<h3 id="根字段-amp-解析器"><a href="#根字段-amp-解析器" class="headerlink" title="根字段 &amp; 解析器"></a>根字段 &amp; 解析器</h3><p>每一个 GraphQL 服务端应用的顶层，必有一个类型代表着所有进入 GraphQL API 可能的入口点，我们将它称之为 <em>Root</em> 类型或 <em>Query</em> 类型。</p>
<p>在这个例子中查询类型提供了一个字段 <code>human</code>，并且接受一个参数 <code>id</code>。这个字段的解析器可能请求了数据库之后通过构造函数返回一个 <code>Human</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Query: &#123;</span><br><span class="line">  <span class="function"><span class="title">human</span>(<span class="params">obj, args, context, info</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> context.db.loadHumanByID(args.id).then(</span><br><span class="line">      <span class="function"><span class="params">userData</span> =&gt;</span> <span class="keyword">new</span> Human(userData)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子使用了 JavaScript 语言，但 GraphQL 服务端应用可以被 <a target="_blank" rel="noopener" href="https://graphql.cn/code/">多种语言实现</a>。解析器函数接收 4 个参数：</p>
<ul>
<li><code>obj</code> 上一级对象，如果字段属于根节点查询类型通常不会被使用。</li>
<li><code>args</code> 可以提供在 GraphQL 查询中传入的参数。</li>
<li><code>context</code> 会被提供给所有解析器，并且持有重要的上下文信息比如当前登入的用户或者数据库访问对象。</li>
<li><code>info</code> 一个保存与当前查询相关的字段特定信息以及 schema 详细信息的值，<a target="_blank" rel="noopener" href="https://graphql.cn/graphql-js/type/#graphqlobjecttype">更多详情请参考类型 GraphQLResolveInfo</a>.</li>
</ul>
<h3 id="异步解析器"><a href="#异步解析器" class="headerlink" title="异步解析器"></a>异步解析器</h3><p>让我们来分析一下在这个解析器函数中发生了什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">human</span>(<span class="params">obj, args, context, info</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> context.db.loadHumanByID(args.id).then(</span><br><span class="line">    <span class="function"><span class="params">userData</span> =&gt;</span> <span class="keyword">new</span> Human(userData)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code> 提供了一个数据库访问对象，用来通过查询中传递的参数 <code>id</code> 来查询数据，因为从数据库拉取数据的过程是一个异步操作，该方法返回了一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 对象，在 JavaScript 语言中 Promise 对象用来处理异步操作，但在许多语言中存在相同的概念，通常称作 <em>Futures</em>、<em>Tasks</em> 或者 <em>Defferred</em>。当数据库返回查询结果，我们就能构造并返回一个新的 <code>Human</code> 对象。</p>
<p>这里要注意的是，只有解析器能感知到 Promise 的进度，GraphQL 查询只关注一个包含着 <code>name</code> 属性的 <code>human</code> 字段是否返回，在执行期间如果异步操作没有完成，则 GraphQL 会一直等待下去，因此在这个环节需要关注异步处理上的优化。</p>
<h3 id="不重要的解析器"><a href="#不重要的解析器" class="headerlink" title="不重要的解析器"></a>不重要的解析器</h3><p>现在 <code>Human</code> 对象已经生成了，但 GraphQL 还是会继续递归执行下去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Human: &#123;</span><br><span class="line">  <span class="function"><span class="title">name</span>(<span class="params">obj, args, context, info</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GraphQL 服务端应用的业务取决于类型系统的结构。在 <code>human</code> 对象返回值之前，由于类型系统确定了 <code>human</code> 字段将返回一个 <code>Human</code> 对象，GraphQL 会根据类型系统预设好的 <code>Human</code> 类型决定如何解析字段。</p>
<p>在这个例子中，对 name 字段的处理非常的清晰，name 字段对应的解析器被调用的时候，解析器回调函数的 obj 参数是由上层回调函数生成的 <code>new Human</code> 对象。在这个案例中，我们希望 Human 对象会拥有一个 <code>name</code> 属性可以让我们直接读取。</p>
<p>事实上，许多 GraphQL 库可以让你省略这些简单的解析器，假定一个字段没有提供解析器时，那么应该从上层返回对象中读取和返回和这个字段同名的属性。</p>
<h3 id="标量强制"><a href="#标量强制" class="headerlink" title="标量强制"></a>标量强制</h3><p>当 <code>name</code> 字段被处理后，<code>appearsIn</code> 和 <code>starships</code> 字段可以被同步执行， <code>appearsIn</code> 字段也可以有一个简单的解析器，但是让我们仔细看看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Human: &#123;</span><br><span class="line">  <span class="function"><span class="title">appearsIn</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.appearsIn <span class="comment">// returns [ 4, 5, 6 ]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，我们的类型系统声明 <code>appearsIn</code> 字段将返回具有已知值的枚举值，但是此函数返回数字！实际上，如果我们查看结果，我们将看到正在返回适当的枚举值。这是怎么回事？</p>
<p>这是一个强制标量的例子。因为类型系统已经被设定，所以解析器函数的返回值必须符合与类型系统对应的 API 规则的约束。在这个案例中，我们可能在服务器上定义了一个枚举类型，它在内部使用像是 4、5 和 6 这样的数字，但在 GraphQL 类型系统中将它们表示为枚举值。</p>
<h3 id="列表解析器"><a href="#列表解析器" class="headerlink" title="列表解析器"></a>列表解析器</h3><p>我们已经看到一个字段返回上面的 <code>appearsIn</code> 字段的事物列表时会发生什么。它返回了枚举值的<strong>列表</strong>，因为这是系统期望的类型，列表中的每个项目被强制为适当的枚举值。让我们看下 <code>startships</code> 被解析的时候会发生什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Human: &#123;</span><br><span class="line">  <span class="function"><span class="title">starships</span>(<span class="params">obj, args, context, info</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.starshipIDs.map(</span><br><span class="line">      <span class="function"><span class="params">id</span> =&gt;</span> context.db.loadStarshipByID(id).then(</span><br><span class="line">        <span class="function"><span class="params">shipData</span> =&gt;</span> <span class="keyword">new</span> Starship(shipData)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析器在这个字段中不仅仅是返回了一个 Promise 对象，它返回一个 Promises <strong>列表</strong>。<code>Human</code> 对象具有他们正在驾驶的 <code>Starships</code> 的 ids 列表，但是我们需要通过这些 id 来获得真正的 Starship 对象。</p>
<p>GraphQL 将并发执行这些 Promise，当执行结束返回一个对象列表后，它将继续并发加载列表中每个对象的 <code>name</code> 字段。</p>
<h3 id="产生结果"><a href="#产生结果" class="headerlink" title="产生结果"></a>产生结果</h3><p>当每个字段被解析时，结果被放置到键值映射中，字段名称（或别名）作为键值映射的键，解析器的值作为键值映射的值，这个过程<strong>从查询字段的底部叶子节点开始返回</strong>，直到根 Query 类型的起始节点。最后合并成为能够镜像到原始查询结构的结果，然后可以将其发送（通常为 JSON 格式）到请求的客户端。</p>
<p>让我们最后一眼看看原来的查询，看看这些解析函数如何产生一个结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  human(id: 1002) &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">    starships &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;human&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Han Solo&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;starships&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Millenium Falcon&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Imperial shuttle&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><p>我们有时候会需要去问 GraphQL Schema 它支持哪些查询。GraphQL 通过内省系统让我们可以做到这点！</p>
<p>在我们的星战例子里，文件 <a target="_blank" rel="noopener" href="https://github.com/graphql/graphql-js/blob/master/src/__tests__/starWarsIntrospection-test.js">starWarsIntrospection-test.js</a> 包含了一系列展示了内省系统的查询，它也是一个测试文件，用来检验参考实现的内省系统。</p>
<p>如果是我们亲自设计了类型，那我们自然知道哪些类型是可用的。但如果类型不是我们设计的，我们也可以通过查询 <code>__schema</code> 字段来向 GraphQL 询问哪些类型是可用的。一个查询的根类型总是有 <code>__schema</code> 这个字段。现在来试试，查询一下有哪些可用的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __schema &#123;</span><br><span class="line">    types &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__schema&quot;: &#123;</span><br><span class="line">      &quot;types&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Query&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Episode&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Character&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;ID&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;String&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Int&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;FriendsConnection&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;FriendsEdge&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;PageInfo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Boolean&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Review&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;SearchResult&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Human&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;LengthUnit&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Float&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Starship&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Droid&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Mutation&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;ReviewInput&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__Schema&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__Type&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__TypeKind&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__Field&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__InputValue&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__EnumValue&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__Directive&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;__DirectiveLocation&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哇，有好多类型！它们都是什么？我们来总结一下：</p>
<ul>
<li><strong>Query, Character, Human, Episode, Droid</strong> - 这些是我们在类型系统中定义的类型。</li>
<li><strong>String, Boolean</strong> - 这些是内建的标量，由类型系统提供。</li>
<li><strong><code>__Schema</code>, <code>__Type</code>, <code>__TypeKind</code>,<code> __Field</code>, <code>__InputValue</code>, <code>__EnumValue</code>, <code>__Directive</code></strong> - 这些有着两个下划线的类型是内省系统的一部分。</li>
</ul>
<p>现在，来试试找到一个可以探索出有哪些可用查询的地方。当我们设计类型系统的时候，我们确定了一个所有查询开始的地方，来问问内省系统它是什么！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __schema &#123;</span><br><span class="line">    queryType &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__schema&quot;: &#123;</span><br><span class="line">      &quot;queryType&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Query&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这和我们在类型系统那章里说的一样，<code>Query</code> 类型是我们开始的地方！注意这里的命名只是一个惯例，我们也可以把 <code>Query</code> 取成别的名字，只要我们把它定义为所有查询出发的地方，它也依然会在这里被返回。尽管如此，还是把它命名为 <code>Query</code> 吧，这是一个有用的惯例。</p>
<p>有时候也需要检验一个特定的类型。来看看 <code>Droid</code> 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __type(name: &quot;Droid&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__type&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Droid&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要更了解 <code>Droid</code> 呢？例如，它是一个接口还是一个对象？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __type(name: &quot;Droid&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    kind</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__type&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Droid&quot;,</span><br><span class="line">      &quot;kind&quot;: &quot;OBJECT&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kind</code> 返回一个枚举类型 <code>__TypeKind</code>，其中一个值是 <code>OBJECT</code>。如果我们改问 <code>Character</code>，我们会发现它是一个接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __type(name: &quot;Character&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    kind</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__type&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Character&quot;,</span><br><span class="line">      &quot;kind&quot;: &quot;INTERFACE&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于一个对象来说，知道它有哪些字段是很有用的，所以来问问内省系统 <code>Droid</code> 有哪些字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __type(name: &quot;Droid&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    fields &#123;</span><br><span class="line">      name</span><br><span class="line">      type &#123;</span><br><span class="line">        name</span><br><span class="line">        kind</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__type&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Droid&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;friends&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;LIST&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;friendsConnection&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;appearsIn&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;primaryFunction&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;String&quot;,</span><br><span class="line">            &quot;kind&quot;: &quot;SCALAR&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些正是我们为 <code>Droid</code> 定义的字段！</p>
<p><code>id</code> 看起来有点儿奇怪，这个类型没有名字。这是因为它是一个 <code>NON_NULL</code> 类型的“包装” 。如果我们请求它的 <code>ofType</code> 字段，我们会发现它是 <code>ID</code> ，告诉我们这是一个非空的 ID。</p>
<p>相似地，<code>friends</code> 和 <code>appearsIn</code> 都没有名字，因为它们都是 <code>LIST</code> 包装类型。我们可以看看它们的 <code>ofType</code>，就能知道它们是装什么东西的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __type(name: &quot;Droid&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    fields &#123;</span><br><span class="line">      name</span><br><span class="line">      type &#123;</span><br><span class="line">        name</span><br><span class="line">        kind</span><br><span class="line">        ofType &#123;</span><br><span class="line">          name</span><br><span class="line">          kind</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__type&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Droid&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;,</span><br><span class="line">            &quot;ofType&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;ID&quot;,</span><br><span class="line">              &quot;kind&quot;: &quot;SCALAR&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;,</span><br><span class="line">            &quot;ofType&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;String&quot;,</span><br><span class="line">              &quot;kind&quot;: &quot;SCALAR&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;friends&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;LIST&quot;,</span><br><span class="line">            &quot;ofType&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Character&quot;,</span><br><span class="line">              &quot;kind&quot;: &quot;INTERFACE&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;friendsConnection&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;,</span><br><span class="line">            &quot;ofType&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;FriendsConnection&quot;,</span><br><span class="line">              &quot;kind&quot;: &quot;OBJECT&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;appearsIn&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;kind&quot;: &quot;NON_NULL&quot;,</span><br><span class="line">            &quot;ofType&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: null,</span><br><span class="line">              &quot;kind&quot;: &quot;LIST&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;primaryFunction&quot;,</span><br><span class="line">          &quot;type&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;String&quot;,</span><br><span class="line">            &quot;kind&quot;: &quot;SCALAR&quot;,</span><br><span class="line">            &quot;ofType&quot;: null</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来看看内省系统特别适合用来开发工具的特性，我们来向内省系统请求文档！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __type(name: &quot;Droid&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;__type&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Droid&quot;,</span><br><span class="line">      &quot;description&quot;: &quot;An autonomous mechanical character in the Star Wars universe&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们可以通过内省系统接触到类型系统的文档，并做出文档浏览器，或是提供丰富的 IDE 体验。</p>
<p>这些只是内省系统的浅浅一层。我们还可以查询枚举值、某个类型实现了什么接口等等，我们甚至可以对内省系统内省。关于这个主题的详细说明可以看规范的“Introspection”部分，以及 GraphQL.js 中的 <a target="_blank" rel="noopener" href="https://github.com/graphql/graphql-js/blob/master/src/type/introspection.js">introspection</a> 文件，它包含了符合规范的一个内省系统的实现。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>