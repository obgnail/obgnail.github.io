<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="地址："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>深入Python中的ThreadLocal变量 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2021-05-18</div></div></div><div class="container post-header"><h1>深入Python中的ThreadLocal变量</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">几种线程变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-VS-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">全局 VS 局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-local-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">Thread-local 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">ThreadLocal的实现机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E6%BA%90%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">ThreadLocal源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%BA%90%E7%A0%81%E7%A7%81%E6%9C%89%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">将源码私有化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8E%BB%E7%90%86%E8%A7%A3%E6%BA%90%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">如何去理解源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#python-%E9%BB%91%E9%AD%94%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">python 黑魔法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">6.2.</span> <span class="toc-text">源码剖析</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://selfboot.cn/2016/08/22/threadlocal_overview/">https://selfboot.cn/2016/08/22/threadlocal_overview/</a></li>
</ul>
<h2 id="几种线程变量"><a href="#几种线程变量" class="headerlink" title="几种线程变量"></a>几种线程变量</h2><p>多线程环境下，每一个线程均可以使用所属进程的全局变量。如果一个线程对全局变量进行了修改，将会影响到其他所有的线程。为了避免多个线程同时对变量进行修改，引入了线程同步机制，通过互斥锁，条件变量或者读写锁来控制对全局变量的访问。</p>
<p>只用全局变量并不能满足多线程环境的需求，很多时候线程还需要拥有自己的私有数据，这些数据对于其他线程来说不可见。因此线程中也可以使用局部变量，局部变量只有线程自身可以访问，同一个进程下的其他线程不可访问。</p>
<p>有时候使用局部变量不太方便，因此 python 还提供了 <strong>ThreadLocal 变量，它本身是一个全局变量，但是每个线程却可以利用它来保存属于自己的私有数据，这些私有数据对其他线程也是不可见的</strong>。</p>
<p>下图给出了线程中这几种线程变量的存在情况：</p>
<p><img src="/images/image-20210518193051403.png" alt="image-20210518193051403"></p>
<h2 id="全局-VS-局部变量"><a href="#全局-VS-局部变量" class="headerlink" title="全局 VS 局部变量"></a>全局 VS 局部变量</h2><p>首先借助一个小程序来看看多线程环境下全局变量的同步问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">global_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_cal</span>():</span></span><br><span class="line">    <span class="keyword">global</span> global_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get 10 threads, run them and wait them all finished.</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threads.append(threading.Thread(target=thread_cal))</span><br><span class="line">    threads[i].start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threads[i].join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Value of global variable can be confused.</span></span><br><span class="line"><span class="built_in">print</span> global_num</span><br></pre></td></tr></table></figure>

<p>这里我们创建了10个线程，每个线程均对全局变量 global_num 进行1000次的加1操作（循环1000次加1是为了延长单个线程执行时间，使线程执行时被中断切换），当10个线程执行完毕时，全局变量的值是多少呢？答案是不确定。简单来说是因为 <code>global_num += 1</code> 并不是一个原子操作，因此执行过程可能被其他线程中断，导致其他线程读到一个脏值。以两个线程执行 +1 为例，其中一个可能的执行序列如下（此情况下最后结果为1）：</p>
<p>多线程全局变量同步：</p>
<p><img src="/images/image-20210518193325102.png" alt="image-20210518193325102"></p>
<p>多线程中使用全局变量时普遍存在这个问题，解决办法也很简单，可以使用互斥锁、条件变量或者是读写锁。下面考虑用互斥锁来解决上面代码的问题，只需要在进行 +1 运算前加锁，运算完毕释放锁即可，这样就可以保证运算的原子性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = threading.Lock()</span><br><span class="line">...</span><br><span class="line">    l.acquire()</span><br><span class="line">    global_num += <span class="number">1</span></span><br><span class="line">    l.release()</span><br></pre></td></tr></table></figure>



<p>在线程中使用局部变量则不存在这个问题，因为每个线程的局部变量不能被其他线程访问。下面我们用10个线程分别对各自的局部变量进行1000次加1操作，每个线程结束时打印一共执行的操作次数（每个线程均为1000）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="built_in">print</span> threading.current_thread().getName(), num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_cal</span>():</span></span><br><span class="line">    local_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        local_num += <span class="number">1</span></span><br><span class="line">    show(local_num)</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threads.append(threading.Thread(target=thread_cal))</span><br><span class="line">    threads[i].start()</span><br></pre></td></tr></table></figure>

<p>可以看出这里每个线程都有自己的 local_num，各个线程之间互不干涉。</p>
<h2 id="Thread-local-对象"><a href="#Thread-local-对象" class="headerlink" title="Thread-local 对象"></a>Thread-local 对象</h2><p>上面程序中我们需要给 show 函数传递 local_num 局部变量，并没有什么不妥。不过考虑在实际生产环境中，我们可能会调用很多函数，每个函数都需要很多局部变量，这时候用传递参数的方法会很不友好。</p>
<p>为了解决这个问题，一个直观的的方法就是建立一个<strong>全局字典，保存进程 ID 到该进程局部变量的映射关系</strong>，运行中的线程可以根据自己的 ID 来获取本身拥有的数据。这样，就可以避免在函数调用中传递参数，如下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">global_data = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    cur_thread = threading.current_thread()</span><br><span class="line">    <span class="built_in">print</span> cur_thread.getName(), global_data[cur_thread]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_cal</span>():</span></span><br><span class="line">    cur_thread = threading.current_thread()</span><br><span class="line">    global_data[cur_thread] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_data[cur_thread] += <span class="number">1</span></span><br><span class="line">    show()  <span class="comment"># Need no local variable.  Looks good.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>保存一个全局字典，然后将线程标识符作为key，相应线程的局部数据作为 value。</p>
<p>这种做法并不完美。</p>
<ol>
<li>首先，每个函数在需要线程局部数据时，都需要先取得自己的线程ID，略显繁琐。</li>
<li>更糟糕的是，这里并没有真正做到线程之间数据的隔离，因为每个线程都可以读取到全局的字典，<strong>每个线程都可以对字典内容进行更改</strong>。</li>
</ol>
<p>为了更好解决这个问题，python 线程库实现了 ThreadLocal 变量（很多语言都有类似的实现，比如Java）。ThreadLocal 真正做到了线程之间的数据隔离，并且使用时不需要手动获取自己的线程 ID，如下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">global_data = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    <span class="built_in">print</span> threading.current_thread().getName(), global_data.num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_cal</span>():</span></span><br><span class="line">    global_data.num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_data.num += <span class="number">1</span></span><br><span class="line">    show()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Main thread: &quot;</span>, global_data.__dict__ <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中每个线程都可以通过 global_data.num 获得自己独有的数据，并且每个线程读取到的 global_data 都不同，真正做到线程之间的隔离。</p>
<p>Python通过 local 类来实现 ThreadLocal 变量，代码量不多（只有100多行），但是比较难理解，涉及很多 Python 黑魔法。那么 ThreadLocal 很完美了？不！Python 的 WSGI 工具库 werkzeug 中有一个更好的 <a target="_blank" rel="noopener" href="https://github.com/pallets/werkzeug/blob/8a84b62b3dd89fe7d720d7948954e20ada690c40/werkzeug/local.py">ThreadLocal 实现</a>，甚至支持协程之间的私有数据，实现更加复杂，有机会再分析。</p>
<h2 id="ThreadLocal的实现机制"><a href="#ThreadLocal的实现机制" class="headerlink" title="ThreadLocal的实现机制"></a>ThreadLocal的实现机制</h2><p>ThreadLocal 的引入，使得可以很方便地在多线程环境中使用局部变量。如此美妙的功能到底是怎样实现的？</p>
<p>简单来说，Python 中 ThreadLocal 就是通过下图中的方法，将全局变量伪装成线程局部变量。</p>
<p><img src="/images/image-20210518193435486.png" alt="image-20210518193435486"></p>
<h2 id="ThreadLocal源码"><a href="#ThreadLocal源码" class="headerlink" title="ThreadLocal源码"></a>ThreadLocal源码</h2><p><code>from threading import local</code>从这里只能看出它是在 threading 模块实现的。接着我们就会发现 local 是这样子的（这里以 python 2.7 为例）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get thread-local implementation, either from the thread</span></span><br><span class="line"><span class="comment"># module, or from the python fallback</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> thread <span class="keyword">import</span> _local <span class="keyword">as</span> local</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> _threading_local <span class="keyword">import</span> local</span><br></pre></td></tr></table></figure>

<p>嗯，自带解释，非常好。我们要做的是继续往下深挖具体实现，找 _local 的实现，好像不太妙，没有找到纯 python 实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_local</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Thread-local data &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, name</span>):</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; x.__delattr__(&#x27;name&#x27;) &lt;==&gt; del x.name &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>没关系，继续来看下_threading_local吧，这下子终于找到了local的纯 python 实现。开始就是很长的一段注释文档，告诉我们这个模块是什么，如何用。这个文档的质量非常高，值得我们去学习。</p>
<h3 id="将源码私有化"><a href="#将源码私有化" class="headerlink" title="将源码私有化"></a>将源码私有化</h3><p>在具体动手分析这个模块之前，我们先把它拷出来放在一个单独的文件 <code>thread_local.py</code> 中，这样可以方便我们随意肢解它（比如在适当的地方加上log），并用修改后的实现验证我们的一些想法。此外，如果你真的理解了<code>_threading_local.py</code>最开始的一段，你就会发现这样做是多么的有必要。因为python的threading.local不一定是用的<code>_threading_local</code>（还记得<code>class _local(object)</code> 吗？）。</p>
<p>所以如果你用 threading.local 来验证自己对_threading_local.py的理解，你很可能会一头雾水的。不幸的是，我开始就这样干的，所以被下面的代码坑了好久：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> local, current_thread</span><br><span class="line">data = local()</span><br><span class="line">key = <span class="built_in">object</span>.__getattribute__(data, <span class="string">&#x27;_local__key&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> current_thread().__dict__.get(key)</span><br><span class="line"><span class="comment"># AttributeError: &#x27;thread._local&#x27; object has no attribute &#x27;_local__key&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当然，你可能不理解这里是什么意思，没关系，我只是想强调在 threading.local 没有用到_threading_local.py，你必须要创建一个模块（我将它命名为 thread_local.py）来保存_threading_local里面的内容，然后像下面这样验证自己的想法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"><span class="keyword">from</span> thread_local <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line">data = local()</span><br><span class="line">key = <span class="built_in">object</span>.__getattribute__(data, <span class="string">&#x27;_local__key&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> current_thread().__dict__.get(key)</span><br></pre></td></tr></table></figure>



<h2 id="如何去理解源码"><a href="#如何去理解源码" class="headerlink" title="如何去理解源码"></a>如何去理解源码</h2><p>现在可以静下心来读读这不到两百行的代码了，不过，等等，好像有许多奇怪的内容（黑魔法）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/2/reference/datamodel.html#slots"><strong>slots</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/2.7/reference/datamodel.html#basic-customization"><strong>new</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/2.7/reference/datamodel.html#customizing-attribute-access"><strong>getattribute__／__setattr__／__delattr</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/2/library/threading.html#rlock-objects">Rlock</a></li>
</ul>
<h3 id="python-黑魔法"><a href="#python-黑魔法" class="headerlink" title="python 黑魔法"></a>python 黑魔法</h3><p>下面是我对上面提到的内容的一点总结，如果觉得读的明白，那么可以继续往下分析源码了。如果还有不理解的，再读几遍文档。</p>
<ul>
<li>简单来说，python 中创建一个<strong>新式类</strong>的实例时，首先会调用<code>__new__(cls[, ...])</code>创建实例，如果它成功返回cls类型的对象，然后才会调用<code>__init__</code>来对对象进行初始化。</li>
<li>新式类中我们可以用<code>__slots__</code>指定该类可以拥有的属性名称，这样每个对象就不会再创建<code>__dict__</code>，从而节省对象占用的空间。特别需要注意的是，基类的<code>__slots__</code>并不会屏蔽派生类中<code>__dict__</code>的创建。</li>
<li>可以通过重载<code>__setattr__，__delattr__和__getattribute__</code>这些方法，来控制自定义类的属性访问（x.name），它们分别对应属性的赋值，删除，读取。</li>
<li>锁是操作系统中为了保证操作原子性而引入的概念，<strong>python 中 RLock是一种可重入锁（reentrant lock，也可以叫作递归锁）</strong>，Rlock.acquire()可以不被阻塞地多次进入同一个线程。</li>
<li><code>__dict__</code>用来保存对象的（可写）属性，可以是一个字典，或者其他映射对象。</li>
</ul>
<h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><p>对这些相关的知识有了大概的了解后，再读源码就亲切了很多。为了彻底理解，我们首先回想下<strong>平时是如何使用local对象的，然后分析源码在背后的调用流程</strong>。这里从定义一个最简单的thread-local对象开始，也就是说当我们写下下面这句时，发生了什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = local()</span><br></pre></td></tr></table></figure>

<p>上面这句会调用 <code>_localbase.__new__</code> 来为data对象设置一些属性（还不知道有些属性是做什么的，不要怕，后面遇见再说），然后将data的属性字典(<code>__dict__</code>)作为当前线程的一个属性值（这个属性的 key 是根据 id(data) 生成的身份识别码）。</p>
<p>这里很值得玩味：在创建ThreadLocal对象时，同时在线程（也是一个对象，没错万物皆对象）的属性字典<code>__dict__</code>里面保存了ThreadLocal对象的属性字典。还记得文章开始的<a target="_blank" rel="noopener" href="https://selfboot.cn/2016/08/26/threadlocal_implement/#img_1">图片</a>吗，红色虚线就表示这个操作。</p>
<p>接着我们考虑在线程 Thread-1 中对ThreadLocal变量进行一些常用的操作，比如下面的一个操作序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data.name = <span class="string">&quot;Thread 1(main)&quot;</span> <span class="comment"># 调用 __setattr__</span></span><br><span class="line"><span class="built_in">print</span> data.name     <span class="comment"># 调用 __getattribute__</span></span><br><span class="line"><span class="keyword">del</span> data.name       <span class="comment"># 调用 __delattr__</span></span><br><span class="line"><span class="built_in">print</span> data.__dict__</span><br><span class="line"><span class="comment"># Thread 1(main)</span></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>那么背后又是如何操作的呢？上面的操作包括了给属性赋值，读属性值，删除属性。这里我们以<code>__getattribute__</code>的实现为例（读取值）进行分析，属性的<code>__setattr__</code>和<code>__delattr__</code>和前者差不多，区别在于禁止了对<code>__dict__</code>属性的更改以及删除操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">    lock = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;_local__lock&#x27;</span>)</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        _patch(self)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, name)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        lock.release()</span><br></pre></td></tr></table></figure>

<p>函数中首先获得了ThreadLocal变量的<code>_local__lock</code>属性值（知道这个变量从哪里来的吗，回顾下_localbase吧），然后用它来保证 <code>_patch(self)</code> 操作的原子性，还用 <strong>try-finally 保证即使抛出了异常也会释放锁资源，避免了线程意外情况下永久持有锁而导致死锁</strong>。现在问题是_patch究竟做了什么？答案还是在源码中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_patch</span>(<span class="params">self</span>):</span></span><br><span class="line">    key = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;_local__key&#x27;</span>)  <span class="comment"># ThreadLocal变量 的标识符</span></span><br><span class="line">    d = current_thread().__dict__.get(key)  <span class="comment"># ThreadLocal变量在该线程下的数据</span></span><br><span class="line">    <span class="keyword">if</span> d <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        current_thread().__dict__[key] = d</span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__dict__&#x27;</span>, d)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># we have a new instance dict, so call out __init__ if we have one</span></span><br><span class="line">        cls = <span class="built_in">type</span>(self)</span><br><span class="line">        <span class="keyword">if</span> cls.__init__ <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">object</span>.__init__:</span><br><span class="line">            args, kw = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;_local__args&#x27;</span>)</span><br><span class="line">            cls.__init__(self, *args, **kw)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__dict__&#x27;</span>, d)</span><br></pre></td></tr></table></figure>

<p>_patch做的正是整个ThreadLocal实现中最核心的部分，<strong>从当前正在执行的线程对象那里拿到该线程的私有数据，然后将其交给ThreadLocal变量</strong>，就是本文开始<a target="_blank" rel="noopener" href="https://selfboot.cn/2016/08/26/threadlocal_implement/#img_1">图片</a>中的虚线2。这里需要补充说明以下几点：</p>
<ul>
<li>这里说的线程的私有数据，其实就是指通过x.name可以拿到的数据（其中 x 为ThreadLocal变量）</li>
<li>主线程中在创建ThreadLocal对象后，就有了对应的数据（还记得红色虚线的意义吗？）</li>
<li>对于那些第一次访问ThreadLocal变量的线程来说，需要创建一个空的字典来保存私有数据，然后还要调用该变量的初始化函数。</li>
<li>还记得_localbase基类里<code>__new__</code>函数设置的属性 _local__args 吗？在这里被用来进行初始化。</li>
</ul>
<p>到此，整个源码核心部分已经理解的差不多了，只剩下<code>local.__del__</code>用来执行清除工作。因为每次创建一个ThreadLocal 变量，都会在进程对象的<code>__dict__</code>中添加相应的数据，当该变量被回收时，我们需要在相应的线程中删除保存的对应数据。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>