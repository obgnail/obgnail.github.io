<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;Crash-Course-Computer-Science&quot;&gt;&lt;a href=&quot;#Crash-Course-Computer-Science&quot; class=&quot;headerlink&quot; title=&quot;Crash Course Computer Science&quot;&gt;&lt;/a&gt;Crash Course Computer Science&lt;/h1&gt;&lt;p&gt;地址："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>视频_Crash_Course_Computer_Science | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Computer-Organization/" rel="tag">Computer Organization</a></div><div class="post-time">2021-12-08</div></div></div><div class="container post-header"><h1>视频_Crash_Course_Computer_Science</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Crash-Course-Computer-Science"><span class="toc-number">1.</span> <span class="toc-text">Crash Course Computer Science</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E9%97%A8%E7%94%B5%E8%B7%AF-XOR"><span class="toc-number">1.1.</span> <span class="toc-text">异或门电路(XOR)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83-ALU"><span class="toc-number">1.3.</span> <span class="toc-text">算术逻辑单元(ALU)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%8D%95%E5%85%83"><span class="toc-number">1.3.1.</span> <span class="toc-text">算术单元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98"><span class="toc-number">1.4.</span> <span class="toc-text">寄存器和内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AND-OR-%E9%94%81%E5%AD%98%E5%99%A8-%E5%AD%981%E4%BD%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text">AND-OR 锁存器(存1位)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU"><span class="toc-number">1.5.</span> <span class="toc-text">CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">CPU 的阶段</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h1 id="Crash-Course-Computer-Science"><a href="#Crash-Course-Computer-Science" class="headerlink" title="Crash Course Computer Science"></a>Crash Course Computer Science</h1><p>地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av21376839">bilibli - Crash Course Computer Science</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/1c7/Crash-Course-Computer-Science-Chinese">github - Crash-Course-Computer-Science-Chinese</a></li>
</ul>
<h2 id="异或门电路-XOR"><a href="#异或门电路-XOR" class="headerlink" title="异或门电路(XOR)"></a>异或门电路(XOR)</h2><p><img src="/images/1580873233986.png" alt="1580873233986"></p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数<code>floating point numbers</code> : 因为小数点可以在数字间浮动</p>
<p>类似科学计数法的方法，来存十进制值</p>
<blockquote>
<p>625.9 可以写成 0.6259×10 ^ 3</p>
<ul>
<li>.6259 叫 “有效位数” , 3 是指数</li>
<li>在 32 位浮点数中 , 第 1 位表示数字的正负 , 接下来 8 位存指数 , 剩下 23 位存有效位数</li>
</ul>
</blockquote>
<h2 id="算术逻辑单元-ALU"><a href="#算术逻辑单元-ALU" class="headerlink" title="算术逻辑单元(ALU)"></a>算术逻辑单元(ALU)</h2><p>数字的计算是由<code>算术逻辑单元</code>(Arithmetic and Logic Unit , ALU)处理</p>
<ul>
<li>ALU 就是 计算机里负责运算的组件 , 基本其他所有部件都用到了它</li>
<li>ALU 就是 由<code>布尔逻辑门</code>组成的</li>
<li>ALU 有 2 个单元，1 个算术单元和 1 个逻辑单元 .<ul>
<li> <code>算术单元</code>，它负责计算机里的所有数字操作</li>
<li><code>逻辑单元</code> ，它负责执行逻辑操作 , 比如AND，OR 和 NOT 操作</li>
</ul>
</li>
</ul>
<h3 id="算术单元"><a href="#算术单元" class="headerlink" title="算术单元"></a>算术单元</h3><p>1+1=0 , 0+0=0 , 1+0=1 , 0+1=1 , 这刚好就是<code>异或</code>的算法 ,  XOR 用作 1 位加法器</p>
<p><img src="/images/1580874965947.png" alt="1580874965947"></p>
<p><img src="/images/1580875017163.png" alt="1580875017163"></p>
<p>上面的逻辑图其实很好理解 , <strong>XOR解决<code>总和</code>问题 , AND解决<code>进位</code>问题</strong>(只有A和B都为1的时候 , carry才为1)</p>
<p>将其抽象为：</p>
<p><img src="/images/1580875211035.png" alt="1580875211035"></p>
<p>上面的为什么叫<code>半加器</code> ? 因为他只是计算了<code>总和</code>和<code>进位</code> , 半加器 输出了进位 , 意味着，我们算下一列的时候 , 还有之后的每一列，我们得加 3 个位在一起，并不是 2 个</p>
<p><img src="/images/1580875381019.png" alt="1580875381019"></p>
<p>如此得出<code>全加器</code>：</p>
<p><img src="/images/1580875472222.png" alt="1580875472222"></p>
<p>进而得出<code>八位加法器</code></p>
<p><img src="/images/1580875821774.png" alt="1580875821774"></p>
<p><strong>如果第 9 位有进位，代表着 2 个数字的和太大了，超过了 8 位</strong> , 这就是<code>溢出</code></p>
<ul>
<li><p> 同理 , 也可以作出<code>8位减法器</code> . </p>
</li>
<li><p>简单的 ALU 没有乘法和除法 , 而是把乘法用多次加法来实现 . 笔记本和手机有专门做乘法的算术单元</p>
</li>
<li><p>最后我们将ALU 抽象层一个<code>V</code>符号 </p>
<ul>
<li>flag标志 : 是否溢出 , 是否相等 , 是否小于</li>
</ul>
<p><img src="/images/a23edc63-1580877210170.png" alt="1580877210170"></p>
</li>
</ul>
<h2 id="寄存器和内存"><a href="#寄存器和内存" class="headerlink" title="寄存器和内存"></a>寄存器和内存</h2><p>计算机必须给内存中每一个位置，做一个 “标记” , 这个标记叫 “位址”, 目的是为了方便存取数据</p>
<h3 id="AND-OR-锁存器-存1位"><a href="#AND-OR-锁存器-存1位" class="headerlink" title="AND-OR 锁存器(存1位)"></a>AND-OR 锁存器(存1位)</h3><p><img src="/images/1580877640585.png" alt="1580877640585"></p>
<p>当A是1的时候 , 就会导致整条电路都是1 :</p>
<p><img src="/images/1580877672138.png" alt="1580877672138"></p>
<p>最后断开A电路 :</p>
<p><img src="/images/1580877702107.png" alt="1580877702107"></p>
<p>此时 , 不管A是0还是1 , 上面的电路都是1</p>
<p>同理 , 不管A是0还是1 , 下面的电路都是0</p>
<p><img src="/images/1580877888555.png" alt="1580877888555"></p>
<p>所以我们得到能存储0和1的电路了</p>
<p><img src="/images/1580878006476.png" alt="1580878006476"></p>
<p>进而得到<code>AND-OR 锁存器</code></p>
<p><img src="/images/1580878148934.png" alt="1580878148934"></p>
<ul>
<li><code>设置</code>输入1, 输出就会变成1 , 对应<code>设置1操作</code></li>
<li><code>复位</code>输入0, 输出就会变成0 , 对应<code>设置0操作</code></li>
<li>如果<code>设置</code>和<code>复位</code>都是 0，电路会输出最后放入的内容 , 对应<code>读取操作</code></li>
</ul>
<blockquote>
<p>也就是说，它存住了 1 bit 的信息</p>
</blockquote>
<p>为了更容易用，我们希望只有一条输入线 , 将它设为 0 或 1 来存储值</p>
<p>需要一根线来”启用”内存 , 启用时允许写入，没启用时就 “锁定” ,不允许写入 , 这条线叫 <code>允许写入线</code></p>
<p><img src="/images/1580879453956.png" alt="1580879453956"></p>
<p>所以我们抽象得到</p>
<p><img src="/images/1580879604122.png" alt="1580879604122"></p>
<ul>
<li>当<code>允许写入线</code> 是关闭的，不管数据输入是什么 , 内容都不会变化</li>
<li><code>允许写入线</code> 输入 1, “打开” 门 , 往 “数据线” 放 1，1 就能存起来了</li>
<li>然后关掉  “允许写入线” ，输出会保持 1 , 现在不管给 “数据线” 什么值 , 输出都不会变 ,值就存起来了</li>
</ul>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>一组AND-OR 锁存器叫 <code>寄存器</code> , <strong>寄存器能存一个数字，这个数字有多少位，叫<code>位宽</code></strong> , </p>
<p>我们所说的64位处理器指的就是<code>64 位宽的寄存器</code></p>
<p>存储8位的值 :</p>
<ol>
<li>写入寄存器前，要先启用里面所有锁存器 , 我们可以用一根线连接所有 “允许输入线”, 把它设为 1 , </li>
<li>然后用 8 条数据线发数据，</li>
<li>然后将 “允许写入线” 设回 0</li>
</ol>
<p>现在问题就是<strong>电线太多了</strong>。64 位寄存器要 64 根数据线，64 根连到输出端 . 1 根线启用所有锁存器 , 加起来 129 条线。</p>
<p>解决方法是<code>矩阵</code></p>
<p><img src="/images/1580880314332.png" alt="1580880314332"></p>
<p>对于 <code>256 位</code>(32字节)的存储 , 只要 35 条线</p>
<ul>
<li>1条”数据线”, </li>
<li>1条”允许写入线”, </li>
<li>1条”允许读取线”</li>
<li>16行16列的线用于选择锁存器</li>
</ul>
<p>为了能定位每个锁存器 , 我们用8位地址来索引 , 4位行 , 4位列</p>
<blockquote>
<p>多路复用器 : 解码8位地址 , 定位到单个锁存器</p>
</blockquote>
<p><img src="/images/1580882391559.png" alt="1580882391559"></p>
<p>组合256为内存+多路复用器 , 最后得到更高一级的抽象</p>
<p><img src="/images/1580880669347.png" alt="1580880669347"></p>
<p>输入一个 8 位地址：4 位代表列，4 位代表行</p>
<p>“允许写入线” 和 “允许读取线”</p>
<p>还需要一条数据线，用于读/写数据</p>
<p>把它们并排放置 , 一行8个</p>
<p><img src="/images/1580881321616.png" alt="1580881321616"></p>
<p>为了存一个 8 位数字，我们同时给 8 个 256 位内存一样的地址 , 每个地址存 1 位 , 意味着这里总共能存 <strong>256 个字节</strong></p>
<p>所以最后抽象为<strong>256个地址</strong> , 每个地址能读写8位值</p>
<p><img src="/images/1580882235943.png" alt="1580882235943"></p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>程序由一个个操作组成 , 这些操作叫<code>指令</code>(<code>Instruction</code>) , 因为它们”指示”计算机要做什么</p>
<ul>
<li>数学指令，比如加/减 , CPU 会让 ALU 进行数学运算</li>
<li>内存指令，CPU 会和内存通信，然后读/写值</li>
</ul>
<p>数据是以二进制值存在内存里 , 程序也可以存在内存里</p>
<p>我们可以给 CPU 支持的所有指令，分配一个 ID</p>
<p><img src="/images/1580883640648.png" alt="1580883640648"></p>
<p>CPU有六个八位寄存器 :</p>
<ul>
<li>四个<code>临时寄存器</code> : 存储临时数据和操作数据</li>
<li><code>指令地址寄存器</code> : 追踪程序运行到哪里了 , 顾名思义，存当前指令的内存地址</li>
<li><code>指令寄存器</code> : </li>
</ul>
<h3 id="CPU-的阶段"><a href="#CPU-的阶段" class="headerlink" title="CPU 的阶段"></a>CPU 的阶段</h3><ol>
<li>取指令阶段 : 负责拿到指令    </li>
<li>解码阶段 : </li>
<li>执行阶段</li>
</ol>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>