<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第一章-基础知识&quot;&gt;&lt;a href=&quot;#第一章-基础知识&quot; class=&quot;headerlink&quot; title=&quot;第一章 基础知识&quot;&gt;&lt;/a&gt;第一章 基础知识&lt;/h1&gt;&lt;h2 id=&quot;机器语言&quot;&gt;&lt;a href=&quot;#机器语言&quot; class=&quot;headerlink&quot; title=&quot;机器语言&quot;&gt;&lt;/a&gt;机器语言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;机器语言是&lt;code&gt;机器指令&lt;/code&gt;的集合。&lt;/li&gt;
&lt;li&gt;机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将其转变成一列高低电平，以使计算机的电子器件受到驱动，进行运算。&lt;/li&gt;
&lt;li&gt;每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使他工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;早期的程序设计均使用机器语言。程序员们将用0、1数字编成的程序代码打在纸带或卡片上。1打孔，0不打孔。再将程序通过纸带机或卡片机输入计算机进行运算。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>汇编语言（第四版） | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Assembly-Language/" rel="tag">Assembly Language</a></div><div class="post-time">2021-12-01</div></div></div><div class="container post-header"><h1>汇编语言（第四版）</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">第一章 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">机器语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">汇编语言的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">指令和数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%AF%B9%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">1.1.3.</span> <span class="toc-text">CPU对存储器的读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">1.1.4.</span> <span class="toc-text">总线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">地址总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">数据总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">控制总线</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.5.</span> <span class="toc-text">内存地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PC%E6%9C%BA%E4%B8%AD%E5%90%84%E7%B1%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">PC机中各类存储器的逻辑连接</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">第二章 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mov%E3%80%81add"><span class="toc-number">2.2.</span> <span class="toc-text">mov、add</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF16%E4%BD%8D%E7%9A%84CPU"><span class="toc-number">2.3.</span> <span class="toc-text">什么是16位的CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8086CPU%E7%BB%99%E5%87%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">8086CPU给出物理地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E6%AE%B5%E5%9C%B0%E5%9D%80x16-%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">物理地址 &#x3D; 段地址x16 + 偏移地址的本质含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E6%AE%B5%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">段地址为什么叫段地址？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">段寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CS%E3%80%81IP%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">CS、IP段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E8%AF%BB%E5%8F%96%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">CPU读取执行一条指令的全流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%A0%B9%E6%8D%AE%E4%BB%80%E4%B9%88%E5%B0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E7%9C%8B%E4%BD%9C%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="toc-number">2.5.3.</span> <span class="toc-text">CPU根据什么将内存中的信息看作指令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmp%EF%BC%9A%E4%BF%AE%E6%94%B9CS%E3%80%81IP%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.4.</span> <span class="toc-text">jmp：修改CS、IP的指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">2.6.</span> <span class="toc-text">代码段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">第三章 寄存器（内存访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%8D%95%E5%85%83"><span class="toc-number">3.1.</span> <span class="toc-text">字单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DS%E5%92%8C-address"><span class="toc-number">3.2.</span> <span class="toc-text">DS和[address]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DS%E7%A4%BA%E4%BE%8B%E4%B8%80"><span class="toc-number">3.2.1.</span> <span class="toc-text">DS示例一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DS%E7%A4%BA%E4%BE%8B%E4%BA%8C"><span class="toc-number">3.2.2.</span> <span class="toc-text">DS示例二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">3.2.3.</span> <span class="toc-text">累加数据段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">CPU提供的栈机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%A9%BA%E7%8A%B6%E6%80%81SP%E4%B8%BA%E5%A4%9A%E5%B0%91"><span class="toc-number">3.3.1.</span> <span class="toc-text">栈空状态SP为多少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">栈顶越界问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push%E3%80%81pop%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.3.</span> <span class="toc-text">push、pop指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%AE%B5"><span class="toc-number">3.3.4.</span> <span class="toc-text">栈段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E7%BB%BC%E8%BF%B0"><span class="toc-number">3.4.</span> <span class="toc-text">段的综述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BC%A9%E5%86%99%E5%AF%B9%E5%BA%94%E5%85%A8%E7%A7%B0"><span class="toc-number">3.5.</span> <span class="toc-text">寄存器缩写对应全称</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">第四章 第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">伪指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#segment%E2%80%A6ends"><span class="toc-number">4.1.1.</span> <span class="toc-text">segment…ends</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#end"><span class="toc-number">4.1.2.</span> <span class="toc-text">end</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assume"><span class="toc-number">4.1.3.</span> <span class="toc-text">assume</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%8F%B7"><span class="toc-number">4.2.</span> <span class="toc-text">标号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E"><span class="toc-number">4.3.</span> <span class="toc-text">程序返回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E7%BB%93%E6%9D%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text">与结束相关的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">4.4.</span> <span class="toc-text">编译与链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E4%BB%B6%E5%A5%97"><span class="toc-number">4.4.1.</span> <span class="toc-text">四件套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.4.3.</span> <span class="toc-text">链接的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5"><span class="toc-number">4.4.4.</span> <span class="toc-text">简化编译链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%86%99%E5%87%BA%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.5.</span> <span class="toc-text">汇编程序从写出到执行的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%B7%9F%E8%B8%AA"><span class="toc-number">4.5.</span> <span class="toc-text">程序执行过程中的跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EXE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.1.</span> <span class="toc-text">EXE文件中程序的加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8debug%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95"><span class="toc-number">4.5.2.</span> <span class="toc-text">使用debug进行调试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">第五章 [BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BX"><span class="toc-number">5.1.</span> <span class="toc-text">[BX]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loop%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">Loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Debug%E4%B8%AD%E8%B7%9F%E8%B8%AA%E7%94%A8loop%E6%8C%87%E4%BB%A4"><span class="toc-number">5.3.</span> <span class="toc-text">在Debug中跟踪用loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug%E5%92%8C%E6%B1%87%E7%BC%96%E7%BC%96%E8%AF%91%E5%99%A8masm%E5%AF%B9-idata-%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">Debug和汇编编译器masm对[idata]的不同处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">第六章 包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">6.1.</span> <span class="toc-text">在代码段中使用数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="toc-number">6.2.</span> <span class="toc-text">在代码段中使用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5"><span class="toc-number">6.3.</span> <span class="toc-text">将数据、代码、栈放入不同的段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">第七章 更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#and%E5%92%8Cor%E6%8C%87%E4%BB%A4"><span class="toc-number">7.1.</span> <span class="toc-text">and和or指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F%E7%BB%99%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">7.2.</span> <span class="toc-text">以字符形式给出的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.3.</span> <span class="toc-text">如何进行大小写转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-idata"><span class="toc-number">7.4.</span> <span class="toc-text">[bx+idata]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SI%E5%92%8CDI"><span class="toc-number">7.5.</span> <span class="toc-text">SI和DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-si-%E5%92%8C-bx-di"><span class="toc-number">7.6.</span> <span class="toc-text">[bx+si]和[bx+di]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">7.7.</span> <span class="toc-text">不同的寻址方式的灵活应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">第八章 数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bx%E3%80%81si%E3%80%81di%E3%80%81bp"><span class="toc-number">8.1.</span> <span class="toc-text">bx、si、di、bp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="toc-number">8.2.</span> <span class="toc-text">机器指令处理的数据在什么地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-number">8.3.</span> <span class="toc-text">汇编语言中数据位置的表达</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">8.4.</span> <span class="toc-text">寻址方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%89%E5%A4%9A%E9%95%BF"><span class="toc-number">8.5.</span> <span class="toc-text">指令要处理的数据有多长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.6.</span> <span class="toc-text">汇编和C语言的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#div%E6%8C%87%E4%BB%A4"><span class="toc-number">8.7.</span> <span class="toc-text">div指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4dd"><span class="toc-number">8.8.</span> <span class="toc-text">伪指令dd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dup"><span class="toc-number">8.9.</span> <span class="toc-text">dup</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">第九章 转移指令的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6offset"><span class="toc-number">9.1.</span> <span class="toc-text">操作符offset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">9.2.</span> <span class="toc-text">依据位移进行转移的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">9.3.</span> <span class="toc-text">转移的目的地址在指令中的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">9.4.</span> <span class="toc-text">转移地址在寄存器中的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84-jmp-%E6%8C%87%E4%BB%A4"><span class="toc-number">9.5.</span> <span class="toc-text">转移地址在内存中的 jmp 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jcxz%E6%8C%87%E4%BB%A4"><span class="toc-number">9.6.</span> <span class="toc-text">jcxz指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop%E6%8C%87%E4%BB%A4"><span class="toc-number">9.7.</span> <span class="toc-text">loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">9.8.</span> <span class="toc-text">根据位移进行转移的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E8%BD%AC%E7%A7%BB%E4%BD%8D%E7%A7%BB%E8%B6%85%E7%95%8C%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">9.9.</span> <span class="toc-text">编译器对转移位移超界的检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.10.</span> <span class="toc-text">一个奇怪的程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4"><span class="toc-number">10.</span> <span class="toc-text">第十章 CALL和RET指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ret%E5%92%8Cretf"><span class="toc-number">10.1.</span> <span class="toc-text">ret和retf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-number">10.2.</span> <span class="toc-text">依据位移进行转移的call指令</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><ul>
<li>机器语言是<code>机器指令</code>的集合。</li>
<li>机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将其转变成一列高低电平，以使计算机的电子器件受到驱动，进行运算。</li>
<li>每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使他工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。</li>
</ul>
<p>早期的程序设计均使用机器语言。程序员们将用0、1数字编成的程序代码打在纸带或卡片上。1打孔，0不打孔。再将程序通过纸带机或卡片机输入计算机进行运算。</p>
<p>应用8086CPU完成运算s=768+12288-1280，机器码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">101110000000000000000011</span><br><span class="line">000001010000000000110000</span><br><span class="line">001011010000000000000101</span><br></pre></td></tr></table></figure>



<p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。<strong>汇编指令是机器指令便于记忆的书写格式</strong>。</p>
<p>例如：机器指令1000100111011000表示把寄存器BX的内容送到AX中。汇编指令则写成<code>mov ax bx</code>。这样的写法与人类语言接近，便于阅读和记忆。</p>
<p>此后，程序员们就用汇编指令编写源程序。可是，计算机能读懂的只有机器指令，那如何让计算机执行程序员用汇编指令编写的程序呢？这时，就需要有一个能够将汇编指令转换成机器指令的翻译程序，这样的程序我们称其为<code>编译器</code>。</p>
<p>程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器码，由计算机最终执行。</p>
<p><img src="/images/image-20211112161024210.png" alt="image-20211112161024210"></p>
<h3 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h3><p>汇编语言由以下3类指令组成。</p>
<ul>
<li><code>汇编指令</code>：机器码的助记符，有对应的机器码。</li>
<li><code>伪指令</code>：没有对应的机器码，由编译器执行，计算机并不执行。</li>
<li><code>其他符号</code>：如+、-、*、/等，由编译器识别，没有对应的机器码。</li>
</ul>
<p>汇编语言的核心是汇编指令，它决定了汇编语言的特性。</p>
<h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><p>指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，<strong>都是二进制信息</strong>。CPU在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。就像围棋的棋子，在棋盒里的时候没有任何区别，在对弈的时候就有了不同的意义。</p>
<p>例如，内存中的二进制信息1000100111011000，计算机可以把它看作大小为89D8H的数据来处理，也可以将其看作指令 <code>mov ax bx</code>来执行。</p>
<h3 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h3><p>存储器分成<code>内存储器</code>(内存)和<code>外存储器</code>(外存，硬盘)。</p>
<ul>
<li>CPU要从内存中读数据，首先要指定存储单元的地址。也就是说它要先确定它要读取哪一个存储单元中的数据。</li>
<li>在一台微机中，不只有存储器这一种器件。CPU在读写数据时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读岀数据，还是向里面写入数据。</li>
</ul>
<p>可见，CPU要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行下面3类信息的交互。</p>
<ul>
<li>地址信息：存储单元的地址</li>
<li>控制信息：器件的选择，读或写的命令</li>
<li>数据信息：读或写的数据</li>
</ul>
<p>那么CPU是通过什么将地址、数据和控制信息传到存储器芯片中的呢？</p>
<p>电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送。在计算机中专门有连接CPU和其他芯片的导线，通常称为<code>总线</code>。</p>
<blockquote>
<p>总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3类：</p>
<ul>
<li><code>地址总线</code></li>
<li><code>控制总线</code></li>
<li><code>数据总线</code></li>
</ul>
</blockquote>
<p>CPU从3号单元中读取数据的过程：</p>
<ol>
<li>CPU通过地址线将地址信息3发出。</li>
<li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。</li>
<li>储存器将3号单元中的数据数据8通过数据线送入CPU。</li>
</ol>
<p>写操作 与 读操作 类似。如向3号单元写入数据26：</p>
<ol>
<li>CPU通过地址线将地址信息3发出。</li>
<li>CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。</li>
<li>CPU通过数据线将数据26送入内存的3号单元中。</li>
</ol>
<p><img src="/images/image-20211112185327032.png" alt="image-20211112185327032"></p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个CPU可以引出3种总线的宽度标志了这个CPU的不同方面的性能：</p>
<ul>
<li>地址总线的宽度决定了CPU的寻址能力；</li>
<li>数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量：</li>
<li>控制总线的宽度决定了CPU对系统中其他器件的控制能力。</li>
</ul>
<h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><p><strong>CPU是通过地址总线来指定存储器单元的</strong>。所以，地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。</p>
<p>下图为一个具有10根地址线的CPU向内存发出地址信息11的时候，10根地址线上传送的二进制信息(<code>1101</code>)。</p>
<p><img src="/images/image-20211114092629490.png" alt="image-20211114092629490"></p>
<blockquote>
<p>也就是说：</p>
<ul>
<li>一条地址线一次传递一个二进制位。</li>
<li>一个CPU有N条地址线，那么这个CPU一次能发送/读取N bit数据。</li>
<li>一个CPU有N条地址线，那么这个CPU最多可以寻找2^N个内存单元。</li>
</ul>
</blockquote>
<h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。</p>
<p>数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次可传送两个字节。</p>
<p>下图为8086CPU写入数据89D8H时，数据总线上的数据传送情况</p>
<p><img src="/images/image-20211114094647096.png" alt="image-20211114094647096"></p>
<h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>CPU对外部器件的控制是通过控制总线来进行的。</p>
<p>在这里控制总线是个总称，控制总线是一些不同控制线的集合。<strong>有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制</strong>。所以，控制总线的宽度决定了CPU对外部器件的控制能力。</p>
<blockquote>
<p>前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根称为“读信号输出”的控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据：有一根称为“写信号输出”的控制线则负责传送写信号。</p>
</blockquote>
<h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>一个CPU的地址总线宽度为10，那么可以寻址2的10次方共计1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。</p>
<h4 id="PC机中各类存储器的逻辑连接"><a href="#PC机中各类存储器的逻辑连接" class="headerlink" title="PC机中各类存储器的逻辑连接"></a>PC机中各类存储器的逻辑连接</h4><p><img src="/images/image-20211114100358072.png" alt="image-20211114100358072"></p>
<p>存储器在物理上是独立的器件，但是有两点相同：</p>
<ul>
<li>都和CPU的总线相连。</li>
<li>CPU对它们进行读或写的时候都通过控制线发出内存读写命令</li>
</ul>
<p>这也就是说，<strong>CPU在操控它们的时候，将各类存储器看作是一个逻辑存储器，把它们都当作内存来对待</strong>，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。</p>
<p><img src="/images/image-20211115110615698.png" alt="image-20211115110615698"></p>
<p>不同的计算机系统的内存地址空间的分配情况是不同的。下图展示了8086PC机内存地址空间分配的基本情况。</p>
<p><img src="/images/image-20211115111718699.png" alt="image-20211115111718699"></p>
<h1 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h1><ul>
<li>一个典型的CPU由运算器、控制器、寄存器等器件构成。<ul>
<li><code>运算器</code>进行信息处理。</li>
<li><code>寄存器</code>进行信息存储。</li>
<li><code>控制器</code>控制各种器件进行工作。</li>
</ul>
</li>
<li>这些器件靠内部总线相连。前一章所说的总线，是外部总线。</li>
<li>内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系。</li>
</ul>
<ul>
<li><strong>寄存器是CPU中程序员可以用指令读写的部件</strong>。程序员通过改变各种寄存器中的内容来实现对CPU的控制。</li>
<li>不同的CPU，寄存器的个数、结构是不相同的。8086CPU有14个寄存器，每个寄存器有一个名称。这些寄存器是:AX、BX、CX、DX、SIDI、SP、BP、IP、CS、SS、DS、ES、PSW。</li>
</ul>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>8086CPU的所有寄存器都是16位的。可以存放两个字节。AX，BX，CX，DX这4个寄存器通常用来存放一般性的数据，被称为<code>通用寄存器</code>。</p>
<p><img src="/images/image-20211115112705320.png" alt="image-20211115112705320"></p>
<p>8086CPU的上一代CPU的寄存器都是8位的，为了保证兼容，4个通用寄存器都可以分成可独立使用分的8位寄存器来用。</p>
<p>出于对兼容性的考虑，8086PU可以一次性处理以下两种尺寸的数据。</p>
<ul>
<li><code>字节</code>：记为 byte，一个字节由8个bt组成，可以存在8位寄存器中。</li>
<li><code>字</code>：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节</li>
</ul>
<p><img src="/images/image-20211115113125290.png" alt="image-20211115113125290"></p>
<h2 id="mov、add"><a href="#mov、add" class="headerlink" title="mov、add"></a>mov、add</h2><ul>
<li>mov被称为<code>传送指令</code></li>
</ul>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax，18</td>
<td>将18送入寄存器AX</td>
<td>AX=18</td>
</tr>
<tr>
<td>add ax，8</td>
<td>将寄存器AX中的数值加上8</td>
<td>AX=AX+8</td>
</tr>
<tr>
<td>mov ax，bx</td>
<td>将寄存器BX中的数据送入寄存器AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax，bx</td>
<td>将AX和BX中的数值相加，结果存于AX中</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<h2 id="什么是16位的CPU"><a href="#什么是16位的CPU" class="headerlink" title="什么是16位的CPU"></a>什么是16位的CPU</h2><p>16位结构，16位机，字长位16位，表示相同的意思。16位CPU具有下面的结构特性：</p>
<ul>
<li>运算器一次最多处理16位的数据</li>
<li>寄存器的最大宽度为16位</li>
<li>寄存器和运算器之间的通路为16位。</li>
</ul>
<blockquote>
<p>内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，</p>
<p>这也就是说，16位CPU，<strong>能一次性处理、传输、暂时存储16位的地址</strong>。</p>
</blockquote>
<h2 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h2><ul>
<li>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。</li>
<li>从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。</li>
<li>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</li>
</ul>
<p><img src="/images/image-20211115121612793.png" alt="image-20211115121612793"></p>
<p>如图所示，当8086CPU要读写内存时：</p>
<ol>
<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</li>
<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li>
<li>地址加法器将两个16位地址合成为一个20位的物理地址</li>
<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</li>
<li>输入输出控制电路将20位物理地址送上地址总线;</li>
<li>20位物理地址被地址总线传送到存储器</li>
</ol>
<p>地址加法器采用<code>物理地址 = 段地址x16 + 偏移地址</code>的方法合成物理地址。</p>
<p>例如，8086CPU要访问地址为123C8H的内存单元，此时，地址加法器的工作过程</p>
<p><img src="/images/image-20211115122043995.png" alt="image-20211115122043995"></p>
<h3 id="物理地址-段地址x16-偏移地址的本质含义"><a href="#物理地址-段地址x16-偏移地址的本质含义" class="headerlink" title="物理地址 = 段地址x16 + 偏移地址的本质含义"></a><code>物理地址 = 段地址x16 + 偏移地址</code>的本质含义</h3><p><code>段地址×16+偏移地址=物理地址</code>的本质含义是：</p>
<ul>
<li>CPU在访问内存时，用一个基础地址(段地址×16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</li>
<li>更一般地说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。8086CPU中，段地址×16可看作是基础地址。</li>
</ul>
<blockquote>
<p>使用比喻说明“基础地址+偏移地址=物理地址”的思想。</p>
<p><img src="/images/image-20211115141224487.png" alt="image-20211115141224487"></p>
<p>你要去图书馆，问我那里的地址，我可以用两种方式告诉你图书馆的地址</p>
<ul>
<li>从学校走2826m到图书馆。这2826m可以认为是图书馆的物理地址。这种方法是直接给出物理地址2826m</li>
<li>从学校走2000m到体育馆，从体育馆再走826m到图书馆。第一个距离200m是相对于起点的基础地址，第二个距离826m是相对于基础地址的偏移地址(以基础地址为起点的地址)。这种方式是用基础地址和偏移地址相加来得到物理地址的。</li>
</ul>
<p>现在再加一些限制条件，比如只能通过纸条进行通信。你问我图书馆的地址，我只能将它写在纸上告诉你。显然必须有一张容纳4位数的纸条才能写下2826这个数据。</p>
<p><img src="/images/image-20211115142201297.png" alt="image-20211115142201297"></p>
<p>但是现在没有能容纳4位数的纸条，仅有两张可以容纳3位数的纸条。这样我们就需要使用下面的方式来传递数据：</p>
<p><img src="/images/image-20211115142320650.png" alt="image-20211115142320650"></p>
<p>在第一张纸上写上200（段地址），在第二张纸上写上826（偏移地址）。然后我们约定，当你得到这两张纸后，做这样的运算：<code>200 * 10 + 826 = 2826</code>。</p>
<p>8086CPU就是这样一个只能提供两张3位数纸条的CPU。</p>
</blockquote>
<h3 id="段地址为什么叫段地址？"><a href="#段地址为什么叫段地址？" class="headerlink" title="段地址为什么叫段地址？"></a>段地址为什么叫段地址？</h3><p>因为8086CPU使用<code>基础地址(段地址x16) + 偏移地址 = 物理地址</code>的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。</p>
<p>段地址和偏移地址都为16位。所以可以得出下面的公式：(x表示段地址，y表示偏移地址)</p>
<ul>
<li>16x + y = 2^20</li>
<li>0 &lt;= y &lt;= 2^16</li>
</ul>
<p>也就是说，<strong>如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可以定位2^16个内存单元</strong>。我们就可以把这2^16的范围称之为<code>一段</code>。</p>
<p>例如：地址10000H～100FFH的内存单元组成一个段。该段的起始地址位10000H，段地址为10000H/16=1000H，大小为100H。</p>
<p>我们也可以认为地址10000H～1007FH、10080H～100FFH的内存单元组成两个段，他们的起始地址为10000H和10080H，段地址为100H和1008H，大小都为80H。</p>
<p><img src="/images/image-20211115153550604.png" alt="image-20211115153550604"></p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><ul>
<li>段地址在8086CPU的段寄存器中存放。</li>
<li>8086CPU有4个段寄存器：CS，DS，SS，ES。</li>
</ul>
<h3 id="CS、IP段寄存器"><a href="#CS、IP段寄存器" class="headerlink" title="CS、IP段寄存器"></a>CS、IP段寄存器</h3><ul>
<li>CS和IP提供了CPU当前要读取和执行指令的地址。CS为代码段寄存器，IP为指令指针寄存器。</li>
<li>假设CS中的内容为M，IP的内容为N。CPU就可以从内存<code>M * 16 + N</code>单元开始，读取一条指令并执行。</li>
</ul>
<h3 id="CPU读取执行一条指令的全流程"><a href="#CPU读取执行一条指令的全流程" class="headerlink" title="CPU读取执行一条指令的全流程"></a>CPU读取执行一条指令的全流程</h3><p><img src="/images/image-20211115180957601.png" alt="image-20211115180957601"></p>
<p>情况说明如下：</p>
<ul>
<li>当前CS中的内容为2000H，IP中的内容为0000H</li>
<li>内存20000H-20002H单元存放着可执行的机器码，长度为3Byte，对应的汇编指令为<code>mov ax,0123H</code></li>
</ul>
<p>CPU读取执行一条指令的流程如下：</p>
<ol>
<li>CS和IP中的内容送入地址加法器。</li>
<li>地址加法器完成计算，得出物理地址20000H。</li>
<li>地址加法器见物理地址送入输入输出控制电路。</li>
<li>输入输出电路见物理地址20000H送上地址总线。</li>
<li>从内存20000H单元开始存放的机器指令B8 23 01 通过数据总线被送入CPU。</li>
<li>输入输出控制电路见机器指令B8 23 01 送入指令缓冲器。</li>
<li>IP中的值自动增加。（读取一条指令后，IP中的值会自动增加，以使CPU可以读取下一条指令。因为当前读入的指令B82301长度为3个字节，所以IP中的值加3，此时CS:IP指向内存单元2000:0003）</li>
<li>执行控制器执行指令B82301（即 mov ax,0123H）</li>
<li>指令B82301被执行后，AX中的内容为0123H。</li>
<li>接下来，CPU将从过年内存单元2000:0003处读取指令，重复上述的流程。</li>
</ol>
<blockquote>
<p>8086CPU的工作过程可以简要总结如下：</p>
<ol>
<li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>IP=IP+所读取指令的长度，从而指向下一条指令；</li>
<li>执行指令。赚到步骤1，重复这个过程。</li>
</ol>
</blockquote>
<p>在8086CPU刚开启工作时，CS和IP被设置为CS=FFFFH，IP=0000H。即8086CPU机刚启动时，CPU从内存FFFF0H单元中读取指令执行。FFFF0H单元中的指令时8086机开机后执行的第一条指令。</p>
<h3 id="CPU根据什么将内存中的信息看作指令？"><a href="#CPU根据什么将内存中的信息看作指令？" class="headerlink" title="CPU根据什么将内存中的信息看作指令？"></a>CPU根据什么将内存中的信息看作指令？</h3><p>在内存中，指令和数据没有任何区别，都是二进制信息。CPU时怎么区分二者的？</p>
<ul>
<li><strong>CPU将CS：IP指向的内存单元中的内容看作指令。</strong></li>
<li>在任何时候，CPU都会将CS当作指令的段地址，把IP当作指令的偏移地址，用他们合成指令的物理地址，到内存中读取指令码，执行。</li>
<li>也就是说，如果内存中的一段信息曾经被CPU执行过的话，那么，它所在的内存单元必然被CS：IP指向过。</li>
</ul>
<h3 id="jmp：修改CS、IP的指令"><a href="#jmp：修改CS、IP的指令" class="headerlink" title="jmp：修改CS、IP的指令"></a>jmp：修改CS、IP的指令</h3><ul>
<li>在CPU中，程序员能用指令读写的部件只有寄存器。因为CPU执行的指令是由CS、IP中的内容决定的，所以可以通过修改寄存器的内容对CPU实现控制。</li>
<li>mov可以修改AX，BX，CX，DX寄存器，但是不能修改CS、IP寄存器。能修改CS、IP的指令被称为<code>转移指令</code>。<code>jmp</code>是其中一种转移指令。</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JMP 1000H</td>
<td>CS不变，IP变成1000H</td>
</tr>
<tr>
<td>JMP CX</td>
<td>CS不变，IP变成CX（含义类似于 mov IP,CX）</td>
</tr>
<tr>
<td>JMP 1000H:2000H</td>
<td>修改CS、IP（含义类似于mov CS,1000H; mov IP,2000H）</td>
</tr>
<tr>
<td>JMP DWORD PTR [SI]</td>
<td>段间间接转移转移地址在SI所指地址开始的4个单元中</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 模版:</span><br><span class="line">jmp 段地址:偏移地址</span><br><span class="line"></span><br><span class="line"># 执行后，CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令。</span><br><span class="line">jmp 2AE3:3</span><br><span class="line"></span><br><span class="line"># 执行后，CS=0003H，IP=0B16H，CPU将从00B46H处读取指令。</span><br><span class="line">jmp 3:0B16</span><br></pre></td></tr></table></figure>



<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>对于8086PC机，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N（N &lt;= 64KB）的一组代码，存于一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个<code>代码段</code>。</p>
<p>比如，将：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0000  ; (B8 00 01)</span><br><span class="line">add ax,0123H ; (05 23 01)</span><br><span class="line">mov bx,ax.   ; (8B D8)</span><br><span class="line">jmp bx       ; (FF E3)</span><br></pre></td></tr></table></figure>

<p>这段长度为10个字节的指令，存放在123B0H<del>123B9H的一组内存单元中，我们就可以认为，123B0H</del>123B9H这段内存是用来存放代码的，是一个代码段，它的段地址为 123BH， 长度为10个字节。如果要让这段代码得到执行，可设CS=123BH、IP=0000H。</p>
<h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="字单元"><a href="#字单元" class="headerlink" title="字单元"></a>字单元</h2><ul>
<li><p>8086CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。所以<strong>一个字要用两个地址连续的内存单元来存放</strong>，这个字的<strong>低位字节存放在低地址单元中，高位字节存放在高地址单元中</strong>。这两个字节，就被称为<code>字单元</code>。</p>
</li>
<li><p>比如我们从0地址开始存放20000(4E20H)，如图所示</p>
<p><img src="/images/image-20211116113503481.png" alt="image-20211116113503481"></p>
</li>
</ul>
<h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><ul>
<li><p>8086CPU中有一个DS寄存器，通常<strong>用来存放要访问数据的段地址</strong>。</p>
</li>
<li><p><code>[…]</code>：表示一个内存单元。</p>
</li>
<li><p><code>mov al,[0]</code>：将DS寄存器中的内容作为段地址，[]的内存单元的内容作为偏移地址。读取内存中的数据，将其写入al中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx  ; ds是段寄存器，mov ds,1000H是非法的。只能使用一个通用寄存器作为中转</span><br><span class="line"></span><br><span class="line">; 读取10000H:0单元的内容，写入al</span><br><span class="line">mov al,[0] ; 将DS寄存器中的内容作为段地址，[]的内存单元的内容作为偏移地址，传入al</span><br><span class="line"></span><br><span class="line">; 将al的数据传输到10000H:0的内存中。</span><br><span class="line">mov [0],al</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DS示例一"><a href="#DS示例一" class="headerlink" title="DS示例一"></a>DS示例一</h3><p><img src="/images/image-20211116142555443.png" alt="image-20211116142555443"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[0]</span><br><span class="line">mov bx,[2]</span><br><span class="line">mov cx,[1]</span><br><span class="line">add bx,[1]</span><br><span class="line">add cx,[2]</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211116142624357.png" alt="image-20211116142624357"></p>
<h3 id="DS示例二"><a href="#DS示例二" class="headerlink" title="DS示例二"></a>DS示例二</h3><p><img src="/images/image-20211116144349072.png" alt="image-20211116144349072"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,11316</span><br><span class="line">mov [0],ax</span><br><span class="line">mov bx,[0]</span><br><span class="line">sub bx,[2]</span><br><span class="line">mov [2],bx</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211116144537772.png" alt="image-20211116144537772"></p>
<h3 id="累加数据段"><a href="#累加数据段" class="headerlink" title="累加数据段"></a>累加数据段</h3><p>累加数据段中前3个字的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,123BH </span><br><span class="line">mov ds, ax   ; 将123BH送入ds中，作为数据段的段地址</span><br><span class="line">mov ax,O     ; 用ax存放累加结果</span><br><span class="line">add ax, [0]  ; 将数据段第一个字（偏移地址为0）加到ax中</span><br><span class="line">add ax, [2]  ; 将数据段第二个字（偏移地址为2）加到ax中</span><br><span class="line">add ax, [4]  ; 将数据段第三个字（偏移地址为4）加到ax中</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，一个字型数据占两个单元，所以偏移地址是 0、2、4。</p>
</blockquote>
<h2 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h2><ul>
<li>8086CPU提供相关的指令来以栈的方式访问内存空间。这意味着，在基于8086CPU编程的时候，<strong>可以将一段内存当作栈来使用</strong>。</li>
<li>8086CPU提供入栈和出栈指令，最基本的两个是PUSH（入栈）和POP（出栈）。</li>
<li><strong><code>push ax</code>表示将寄存器ax中的数据送入栈中，<code>pop ax</code>表示从栈顶取出数据送入ax。</strong></li>
<li>8086CPU的入栈和出栈操作都是<strong>以字为单位进行的</strong>。</li>
</ul>
<ul>
<li>8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，<strong>栈顶的段地址存放在<code>SS</code>中，偏移地址存放在<code>SP</code>中</strong>。</li>
<li><strong>任意时刻，<code>SS：SP</code>指向栈顶元素。</strong></li>
<li>push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</li>
</ul>
<p>举例说明，我们可以将10000H~1000FH这段内存当作栈来使用。</p>
<p><img src="/images/image-20211116161344067.png" alt="image-20211116161344067"></p>
<p>push ax的执行，由以下两步完成：</p>
<ol>
<li>SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶； </li>
<li>将ax中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶。</li>
</ol>
<p><img src="/images/image-20211116162217296.png" alt="image-20211116162217296"></p>
<blockquote>
<p>入栈时，栈顶从高地址向低地址方向增长。</p>
</blockquote>
<p>pop ax的执行过程和push ax刚好相反，由以下两步完成。</p>
<ul>
<li>将SS：SP指向的内存单元处的数据送入ax中；</li>
<li>SP=SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ul>
<p><img src="/images/image-20211116163323998.png" alt="image-20211116163323998"></p>
<blockquote>
<p>出栈后，SS：SP指向新的栈顶1000EH，pop操作前的栈顶元素，<strong>1000CH处的2266H依然存在</strong>，但是，它已不在栈中。当再次执行push等入栈指令后，SS：SP移至1000CH，并在里面写入新的数据，它将被覆盖。</p>
</blockquote>
<p>总结：</p>
<ul>
<li>push指令的执行步骤： <ol>
<li>SP=SP-2；</li>
<li>向SS：SP指向的字单元中送入数据。 </li>
</ol>
</li>
<li>pop指令的执行步骤： <ol>
<li>从SS：SP指向的字单元中读取数据； </li>
<li>SP=SP+2。</li>
</ol>
</li>
</ul>
<h3 id="栈空状态SP为多少"><a href="#栈空状态SP为多少" class="headerlink" title="栈空状态SP为多少"></a>栈空状态SP为多少</h3><ul>
<li>将10000H~1000FH这段空间当作栈段，初始状态栈是空的，SS=1000H，栈空间大小为16字节，栈最底部的字单元地址为1000:000E。</li>
<li>任意时刻，SS：SP指向栈顶，当栈中只有一个元素的时候，SS=1000H，SP=000EH。</li>
<li>栈为空，就相当于栈中唯一的元素出栈，出栈后，SP=SP+2，SP原来为000EH，加2后SP=10H，所以，当栈为空的时候，SS=1000H，SP=10H。</li>
</ul>
<p><img src="/images/image-20211116162650612.png" alt="image-20211116162650612"></p>
<h3 id="栈顶越界问题"><a href="#栈顶越界问题" class="headerlink" title="栈顶越界问题"></a>栈顶越界问题</h3><ul>
<li>当栈满的时候再使用push指令入栈，或栈空的时候再使用pop指令出栈，都将发生栈顶超界问题。</li>
<li>8086CPU<strong>不保证我们对栈的操作不会超界</strong>。</li>
<li>这也就是说，<strong>8086CPU只知道栈顶在何处（由SS：SP指示），而不知道我们安排的栈空间有多大</strong>。这点就好像CPU只知道当前要执行的指令在何处（由CS：IP指示），而不知道要执行的指令有多少。</li>
</ul>
<h3 id="push、pop指令"><a href="#push、pop指令" class="headerlink" title="push、pop指令"></a>push、pop指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push 寄存器   ; 将一个寄存器中的数据入栈(将寄存器中的数据push进内存)</span><br><span class="line">pop 寄存器    ; 出栈，用一个寄存器接收出栈的数据(将内存中的数据pop到寄存器中)</span><br><span class="line">push 内存单元 ; 将一个内存字单元处的字入栈（注意：栈操作都是以字为单位） </span><br><span class="line">pop 内存单元  ; 出栈，用一个内存字单元接收出栈的数据</span><br><span class="line"></span><br><span class="line">; eg:</span><br><span class="line">mov ax,1000H </span><br><span class="line">mov ds,ax     ; 内存单元的段地址要放在ds中</span><br><span class="line">push [0]      ; 将1000：0处的字压入栈中</span><br><span class="line">pop [2]       ; 出栈，出栈的数据送入1000：2处</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H </span><br><span class="line">mov ss,ax      ; 设置栈的段地址，SS=1000H，不能直接向段寄存器SS中送入数据，所以用ax中转。</span><br><span class="line">mov sp,0010H   ; 设置栈顶的偏移地址，因栈为空，所以sp=0010H。</span><br><span class="line"></span><br><span class="line">push ax </span><br><span class="line">push bx </span><br><span class="line">push ds</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，</li>
<li>与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS：SP指出的。</li>
<li>同时，push和pop指令还要改变SP中的内容。</li>
</ul>
</blockquote>
<h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><ul>
<li>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N（N &lt;= 64KB）的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个<code>栈段</code>。</li>
<li>比如，我们将10010H~1001FH这段长度为16字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为个栈段，段地址为1001H，大小为16字节。</li>
<li>从栈操作指令所完成的功能的角度上来看，push、pop等指令在执行的时候只修改SP，所以栈顶的变化范围是0~FFFFH，从栈空时候的SP=0，一直压栈，直到栈满时SP=0；<strong>如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容</strong>。所以一个栈段的容量最大为64KB。</li>
</ul>
<h2 id="段的综述"><a href="#段的综述" class="headerlink" title="段的综述"></a>段的综述</h2><ul>
<li>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。<ul>
<li>我们可以用一个段存放数据，将它定义为“数据段”；</li>
<li>我们可以用一个段存放代码，将它定义为“代码段”；</li>
<li>我们可以用一个段当作栈，将它定义为“栈段”。</li>
</ul>
</li>
<li>我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：<ul>
<li>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问；</li>
<li>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；</li>
<li>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。</li>
</ul>
</li>
<li>可见，不管我们如何安排，<ul>
<li>CPU将内存中的某段内容当作代码，是因为CS：IP指向了那里；</li>
<li>CPU将内存中的某段内存当作栈，是因为SS：SP指向了那里。</li>
</ul>
</li>
</ul>
<p> 比如我们将10000H~1001FH安排为代码段，并在里面存储如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0020H  ; 初始化栈顶</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax    ; 设置数据段段地址</span><br><span class="line">mov ax, [0]</span><br><span class="line">add ax, [2] </span><br><span class="line">mov bx, [4] </span><br><span class="line">add bx, [6] </span><br><span class="line">push ax </span><br><span class="line">push bx </span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br></pre></td></tr></table></figure>

<ul>
<li>设置CS=1000H，IP=0，这段代码将得到执行。可以看到，在这段代码中，我们又将10000H<del>1001FH安排为栈段和数据段。10000H</del>1001FH这段内存，既是代码段，又是栈段和数据段。</li>
<li>一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即CS、IP，SS、SP，DS的指向。</li>
</ul>
<blockquote>
<p>window10使用debug：</p>
<ol>
<li><p>首先下载debug和DOSbox。</p>
</li>
<li><p>debug.exe 文件所在的磁盘（如 D 盘，完整的路径为 D:\masm\debug）做一次 mount（挂载）操作，比如我们将其挂载到 DOSbox 的 C 盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z:\&gt; mount c d:\</span><br><span class="line">Z:\&gt; c:\</span><br><span class="line">C:\&gt; <span class="built_in">cd</span> masm\debug</span><br><span class="line">C:\MASM\DEBUG&gt; </span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h2 id="寄存器缩写对应全称"><a href="#寄存器缩写对应全称" class="headerlink" title="寄存器缩写对应全称"></a>寄存器缩写对应全称</h2><ul>
<li>AX（accumulator）：累加寄存器</li>
<li>BX（base）：基址寄存器</li>
<li>CX（count）：计数寄存器</li>
<li>DX（data）：数据寄存器</li>
<li>SP（Stack Pointer）：堆栈指针寄存器</li>
<li>BP（Base Pointer）：基址指针寄存器</li>
<li>SI（Source Index）：源变址寄存器</li>
<li>DI（Destination Index）：目的变址寄存器</li>
<li>IP（Instruction Pointer）：指令指针寄存器</li>
<li>CS（Code Segment）代码段寄存器</li>
<li>DS（Data Segment）：数据段寄存器</li>
<li>SS（Stack Segment）：堆栈段寄存器</li>
<li>ES（Extra Segment）：附加段寄存</li>
</ul>
<h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>在汇编语言源程序中，包含两种指令，一种是<code>汇编指令</code>，一种是<code>伪指令</code>。</p>
<ul>
<li><code>汇编指令</code>有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。</li>
<li><code>伪指令</code>没有对应的机器码的指令，最终不被CPU所执行，用于指导编译器进行编译工作。</li>
</ul>
<p><img src="/images/image-20211118140712671.png" alt="image-20211118140712671"></p>
<h3 id="segment…ends"><a href="#segment…ends" class="headerlink" title="segment…ends"></a>segment…ends</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; segment和ends的功能是定义一个段，</span><br><span class="line">; segment说明一个段开始，ends说明一个段结束。</span><br><span class="line">; 一个段必须有一个名称来标识</span><br><span class="line">XXX segment</span><br><span class="line">XXX ends</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>segment和ends的功能是定义一个段</strong>。</li>
<li>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。</li>
<li>我们在前面的课程中所讲解的段的概念，在汇编源程序中得到了应用与体现，一个源程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到了不同的段中。</li>
<li>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。</li>
</ul>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中如果碰到了伪指令end，就结束对源程序的编译。</p>
<h3 id="assume"><a href="#assume" class="headerlink" title="assume"></a>assume</h3><ul>
<li>这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。</li>
<li>通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</li>
<li>assume并不是一条非要深入理解不可的伪指令，以后我们编程时，记着<strong>用assume将有特定用途的段和相关的段寄存器关联起来</strong>即可。</li>
</ul>
<blockquote>
<p>简单来说：assume的作用是<strong>关联段名与段寄存器</strong>，让编译器知道在代码段中使用的变量来自于哪个段，从而可以利用段寄存器寻址。而将段地址装入段寄存器的任务仍然是由用户手动完成的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; 用codesg segment... codesg ends定义了一个名为codseg的段，在这个段中存放代码，所以这个段是一个代码段。</span><br><span class="line">; 在程序的开头，用assumecs：codesg将用作代码段的段codesg和CPU中的段寄存器cs联系起来。</span><br><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">	mov ax,0123H</span><br><span class="line">	mov bx,0456H</span><br><span class="line">	add ax,bx</span><br><span class="line">	add ax,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00H</span><br><span class="line">	int 21H</span><br><span class="line">	</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><ul>
<li>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如“codesg”。</li>
<li>一个标号指代了一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序<strong>处理为一个段的段地址</strong>。</li>
</ul>
<h2 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h2><ul>
<li>一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为：<code>程序返回</code>。</li>
<li>那么，如何返回呢？应该在程序的末尾添加返回的程序段。</li>
</ul>
<p>上面代码中的就是用于程序返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>



<h3 id="与结束相关的概念"><a href="#与结束相关的概念" class="headerlink" title="与结束相关的概念"></a>与结束相关的概念</h3><table>
<thead>
<tr>
<th>指令</th>
<th>目 的</th>
<th>指令性质</th>
<th>指令执行者</th>
</tr>
</thead>
<tbody><tr>
<td>段名 ends</td>
<td>通知编译器一个<strong>段结束</strong></td>
<td>伪指令</td>
<td>编译时,由编译器执行</td>
</tr>
<tr>
<td>end</td>
<td>通知编译器<strong>程序结束</strong></td>
<td>伪指令</td>
<td>编译时,由编译器执行</td>
</tr>
<tr>
<td>mov ax,4c00H int21H</td>
<td><strong>程序返回</strong></td>
<td>汇编指令</td>
<td>执行时,由CPU执行</td>
</tr>
</tbody></table>
<h2 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h2><h3 id="四件套"><a href="#四件套" class="headerlink" title="四件套"></a>四件套</h3><ul>
<li><code>EDIT.COM</code>：编辑器</li>
<li><code>LINK.EXE</code>：链接器</li>
<li><code>MASM.EXE</code>：编译器</li>
<li><code>DEBUG.EXE</code>：调试工具</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p><img src="/images/image-20211124145334420.png" alt="image-20211124145334420"></p>
<ul>
<li><code>.asm</code>：待编译的文件。</li>
<li><code>1.obj</code>：因为我们已经输入了源程序文件名为1.asm，则编译程序默认要输出的目标文件名为1.obj。</li>
<li><code>nul.lst</code>：列表文件的名称，这个文件是编译器将源程序编译为目标文件的过程中产生的中间结果。如果要让编译器不生成这个文件，直接按Enter键即可。</li>
<li><code>nul.crf</code>：交叉引用文件的名称，这个文件同列表文件一样，是编译器将源程序编译为目标文件过程中产生的中间结果。如果让编译器不生成这个文件，直接按Enter键即可。</li>
</ul>
<blockquote>
<ul>
<li>在编译的过程中，我们提供了一个输入，即源程序文件。</li>
<li>最多可以得到3个输出：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf），</li>
<li>这3个输出文件中，目标文件是我们最终要得到的结果，而另外两个只是中间结果，可以让编译器忽略对它们的生成。</li>
</ul>
</blockquote>
<ul>
<li>在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。</li>
<li>我们已经对<code>c:\l.asm</code>进行编译得到<code>c:\masm\l.obj</code>，现在再将<code>c:\masm\1.obj</code>连接为<code>c:\masm\l.exe</code>。</li>
</ul>
<p><img src="/images/image-20211124150212608.png" alt="image-20211124150212608"></p>
<ul>
<li><code>.obj</code>：待链接的目标文件名。</li>
<li><code>1.exe</code>：生成的可执行文件的名称，可执行文件是我们对一个程序进行连接要得到的最终结果。</li>
<li><code>nul.map</code>：映像文件的名称，这个文件是连接程序将目标文件连接为可执行文件过程中产生的中间结果，如果希望连接程序不生成这个文件，直接按Enter键即可。</li>
<li><code>.lib</code>：库文件的名称。库文件里面包含了一些可以调用的子程序，如果程序中调用了某一个库文件中的子程序，就需要在连接的时候，将这个库文件和目标文件连接到一起，生成可执行文件。但是现在程序中没有调用任何子程序，所以这里忽略库文件名的输入，直接按Enter键即可。</li>
</ul>
<h3 id="链接的作用"><a href="#链接的作用" class="headerlink" title="链接的作用"></a>链接的作用</h3><ul>
<li>当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；</li>
<li>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；</li>
<li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li>
</ul>
<h3 id="简化编译链接"><a href="#简化编译链接" class="headerlink" title="简化编译链接"></a>简化编译链接</h3><p>通过在最后添加分号，自动忽略生成中间文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masm c:\hello;</span><br><span class="line">link hello;</span><br></pre></td></tr></table></figure>



<h3 id="汇编程序从写出到执行的过程"><a href="#汇编程序从写出到执行的过程" class="headerlink" title="汇编程序从写出到执行的过程"></a>汇编程序从写出到执行的过程</h3><blockquote>
<p>操作系统的外壳：</p>
<p>如果用户要执行一个程序，则输入该程序的可执行文件的名称，CMD首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS：IP指向程序的入口。此后，CMD暂停运行，CPU运行程序。程序运行结束后，返回到CMD中，CMD再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。</p>
</blockquote>
<ol>
<li>编程（Edit）</li>
<li>hello.asm</li>
<li>编译（masm）</li>
<li>hello.obj</li>
<li>链接（link）</li>
<li>hello.exe</li>
<li>加载（command）</li>
<li>内存中的程序</li>
<li>运行（CPU）</li>
</ol>
<h2 id="程序执行过程中的跟踪"><a href="#程序执行过程中的跟踪" class="headerlink" title="程序执行过程中的跟踪"></a>程序执行过程中的跟踪</h2><h3 id="EXE文件中程序的加载过程"><a href="#EXE文件中程序的加载过程" class="headerlink" title="EXE文件中程序的加载过程"></a>EXE文件中程序的加载过程</h3><p><img src="/images/image-20211124180636387.png" alt="image-20211124180636387"></p>
<p>从图中我们知道以下的信息。</p>
<ul>
<li>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds：0；</li>
<li>这个内存区的前256个字节中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。</li>
</ul>
<blockquote>
<p>从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SAx16+0。</p>
<p>因为PSP占256（100H）字节，所以程序的物理地址是：SAx16+0+256=SAx16+16x16+0=(SA+16)x16+0 </p>
<p>可用段地址和偏移地址表示为：SA+10H：0。</p>
</blockquote>
<h3 id="使用debug进行调试"><a href="#使用debug进行调试" class="headerlink" title="使用debug进行调试"></a>使用debug进行调试</h3><p>Debug可以将程序加载入内存，设置 CS：IP指向程序的入口，但Debug并不放弃对 CPU的控制，这样我们就可以使用Debug的相关命令来单步执行程序，查看每一条指令的执行结果。</p>
<p><img src="/images/image-20211124160425865.png" alt="image-20211124160425865"></p>
<p>Debug将程序从可执行文件加载入内存后，cx中存放的是程序的长度。1.exe中程序的机器码共有15个字节。则1.exe加载后，cx中的内容为000FH。</p>
<p>CS=12AE，IP0000，CS：IP指向程序的第一条指令。可以看到，从12AE：0000~12AE：000E都是程序的机器码。</p>
<p><img src="/images/image-20211124181512289.png" alt="image-20211124181512289"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; 1.asm</span><br><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">  mov ax,0123h</span><br><span class="line">  mov bx,0456h</span><br><span class="line">  add ax,bx</span><br><span class="line">  add ax,ax</span><br><span class="line"></span><br><span class="line">  mov ax,4c00h</span><br><span class="line">  int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>现在，我们可以开始跟踪了，<strong>用T命令单步执行程序中的每一条指令，并观察每条指令的执行结果</strong>。等走到最后一条指令<code>int 21h</code>，需要执行P命令。</p>
<p><img src="/images/image-20211124181758904.png" alt="image-20211124181758904"></p>
<h1 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h1><h2 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h2><p>要完整地描述一个内存单元，需要两种信息：</p>
<ul>
<li>内存单元的地址；</li>
<li>内存单元的长度（类型）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为0，段地址在ds中。</span><br><span class="line">mov ax,[0]</span><br><span class="line">; 将一个内存单元的内容送入al，这个内存单元的长度为1字节（字节单元），存放一个字节，偏移地址为0，段地址在ds中。</span><br><span class="line">mov al,[0]</span><br></pre></td></tr></table></figure>

<p>用<code>[0]</code>表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; [bx]同样也表示一个内存单元，它的偏移地址在bx中</span><br><span class="line">; 将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址在bx中，段地址在ds中。</span><br><span class="line">mov ax, [bx]</span><br><span class="line"></span><br><span class="line">; 将一个内存单元的内容送入al，这个内存单元的长度为1字节（字节单元），存放一个字节，偏移地址在bx中，段地址在ds中。</span><br><span class="line">mov al,[bx]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单来讲就是：将ds整个值作为段地址，将bx整个值作为偏移地址。</p>
</blockquote>
<h2 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h2><p>loop指令的格式是：loop标号，CPU执行loop指令的时候，要进行两步操作 </p>
<ul>
<li>(cx)=(cx)-l;</li>
<li>判断 cX中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li>
</ul>
<blockquote>
<p>简单来说，通常我们用loop指令来实现循环功能，cx中存放循环次数。</p>
</blockquote>
<p>计算2^5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	mov ax,2</span><br><span class="line">	mov ax,ax</span><br><span class="line">	mov ax,ax</span><br><span class="line">	mov ax,ax</span><br><span class="line">	mov ax,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>使用loop：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	 mov ax,2</span><br><span class="line">	 </span><br><span class="line">	 mov cx,4</span><br><span class="line">s: add ax,ax</span><br><span class="line">   loop s</span><br><span class="line">	</span><br><span class="line">	 mov ax,4c00h</span><br><span class="line">	 int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>所以，计算123*236。其实就是123加236次，或者236加123次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	 mov ax,0</span><br><span class="line">	 </span><br><span class="line">	 mov cx,236</span><br><span class="line">s: add ax,123</span><br><span class="line">   loop s</span><br><span class="line">	</span><br><span class="line">	 mov ax,4c00h</span><br><span class="line">	 int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="在Debug中跟踪用loop指令"><a href="#在Debug中跟踪用loop指令" class="headerlink" title="在Debug中跟踪用loop指令"></a>在Debug中跟踪用loop指令</h2><p>计算<code>ffff:0006</code>单元中的数乘以3，结果存储在dx中。</p>
<p>难点在于：<code>ffff:0006</code>单元是一个字节单元，8位，ax是一个16位寄存器，数据的长度不一样，如何赋值？</p>
<p>解决方法：用一个16位寄存器来做中介。将内存单元中的 8位数据赋值到一个16位寄存器ax中，再将ax中的数据加到dx上，从而使两个运算对象的类型匹配并且结果不会超界。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">		; 在汇编源程序中，数据不能以字母开头，所以要在前面加0。</span><br><span class="line">    mov ax,0ffffh</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,6        ; 以上，设置ds:bx指向ffff:6</span><br><span class="line"></span><br><span class="line">    mov al,[bx]</span><br><span class="line">    mov ah,0        ; 以上，设置(al)=((ds*16)+(bx)),(ah)=0 </span><br><span class="line"></span><br><span class="line">    mov dx,0        ; 累加寄存器清0</span><br><span class="line">    mov cx,3        ; 循环3次</span><br><span class="line">  s:add dx,ax</span><br><span class="line">    loop s          ; 以上累加计算(ax)*3</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h         ; 程序返回</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>使用debug：</p>
<p><img src="/images/image-20211125112501949.png" alt="image-20211125112501949"></p>
<p><img src="/images/image-20211125112515772.png" alt="image-20211125112515772"></p>
<p>可以看到，从0B3D:0000~0B3D:001A是我们的程序，0B3D:0014处是源程序中的指令loops，只是此处<strong>loops中的标号s已经变为一个地址0012h。如果在执行“loop 0012”时，cx减1后不为0，“loop 0012”就把IP设置为0012h，从而使CS：IP指向0B3D：0012处的add dx，ax，实现转跳</strong>。</p>
<p>断点：</p>
<ul>
<li>如果想从CS：0012处开始跟踪，可以使用g命令，<code>g 0012</code>表示执行程序到当前代码段（段地址在CS中）的0012h处。也就是说“g0012”将使Debug从当前的CS:IP指向的指令执行，一直到(IP)=0012h为止。</li>
<li>如果想直接跳过loop，还可以使用<code>p命令</code>，<strong>Debug就会自动重复执行循环中的指令，直到(cx)=0为止</strong>。</li>
</ul>
<p><img src="/images/image-20211125113358546.png" alt="image-20211125113358546"></p>
<p><img src="/images/image-20211125113410435.png" alt="image-20211125113410435"></p>
<h2 id="Debug和汇编编译器masm对-idata-的不同处理"><a href="#Debug和汇编编译器masm对-idata-的不同处理" class="headerlink" title="Debug和汇编编译器masm对[idata]的不同处理"></a>Debug和汇编编译器masm对<code>[idata]</code>的不同处理</h2><p>我们在Debug中写过类似的指令：<code>mov ax, [0]</code>，表示将ds：0处的数据送入ax中。但是在汇编源程序中，指令<code>mov ax, [0]</code>被编译器当作指令<code>mov ax，0</code>处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">  mov ax,2000h</span><br><span class="line">  mov ds,ax</span><br><span class="line">  mov al,[0]</span><br><span class="line">  mov bl,[1]</span><br><span class="line">  mov cl,[2]</span><br><span class="line">  mov dl,[3]</span><br><span class="line"></span><br><span class="line">  mov ax,4c00h</span><br><span class="line">  int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211125115358012.png" alt="image-20211125115358012"></p>
<p><img src="/images/image-20211125115409997.png" alt="image-20211125115409997"></p>
<p>从图中我们可以明显地看出，Debug和编译器masm对形如<code>mov ax，[0]</code>这类指令在解释上的不同。我们在Debug中和源程序中写入同样形式的指令，但Debug和编译器对这些指令中的<code>[idata]</code>却有不同的解释。</p>
<ul>
<li>Debug将它解释为<code>[idata]</code>是一个内存单元，<code>[idata]</code>是内存单元的偏移地址；</li>
<li>而编译器将<code>[idata]</code>解释为idata。</li>
</ul>
<p>那么我们如何在源程序中实现将内存2000:0、2000:1、2000:2、2000:3单元中的数据送入al、bl、cl、dl中呢？</p>
<p>方法一：可将偏移地址送入bx寄存器中，用[bx]的方式来访问内存单元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000h</span><br><span class="line">mov ds,ax     ; 段地址2000h送入ds</span><br><span class="line">mov bx,0      ; 偏移地址0送入bx</span><br><span class="line">mov al,[bx]   ; ds:bx单元中的数据送入al</span><br></pre></td></tr></table></figure>

<p>方法二：显式地给出段地址所在的段寄存器。这被称为<code>段前缀</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov al,ds:[0]</span><br></pre></td></tr></table></figure>



<p>练习：计算<code>ffff:0 ~ ffff:b</code>单元中的数据的和，结果存储在dx中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov dx,0</span><br><span class="line">	</span><br><span class="line">	mov cx,12</span><br><span class="line">s:mov al,[bx]</span><br><span class="line">	mov ah,0</span><br><span class="line">	add dx,ax</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><p>如果程序需要用其他空间来存放数据，使用哪里呢？程序取得所需空间的方法有两种，</p>
<ul>
<li>在加载程序的时候为程序分配，</li>
<li>程序在执行的过程中向系统申请。</li>
</ul>
<p>现在讨论第一种，加载程序的时候为程序分配空间。</p>
<h2 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h2><p>考虑这样一个问题，编程计算以下8个数据的和，结果存在ax寄存器中<br>0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h</p>
<ul>
<li>首先要将这些数据存储在一组地址连续的内存单元中。如何将这些数据存储在一组地址连续的内存单元中呢？我们可以用指令一个一个地将它们送入地址连续的内存单元中，可是这样又有一个问题，到哪里去找这段内存空间呢？</li>
<li>从规范的角度来讲，我们是不能自己随便决定哪段空间可以使用的，应该让系统来为我们分配。我们<strong>可以在程序中，定义我们希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写到可执行文件中</strong>。当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。与此同时，我们要处理的数据也就自然而然地获得了存储空间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dw</code>：即“define word”。含义是<strong>定义字型数据</strong>。在这里，使用dw定义了8个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为16个字节。</li>
<li>程序中的指令就要对这8个数据进行累加，可这8个数据在哪里呢？由于它们在代码段中，程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。它们的偏移地址是多少呢？<strong>因为因为IP默认为0，且用dw定义的数据处于代码段的最开始，所以偏移地址为0</strong>，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是CS:0、CS:2、CS:4、CS:6、CS:8、CS:A、CS:C、CS:E</li>
</ul>
<blockquote>
<p>简单来说：程序加载到内存中后，所占内存空间的<strong>前16个单元存放在源程序中用“dw”定义的数据</strong>，后面的单元存放源程序中汇编指令所对应的机器指令。</p>
</blockquote>
<p>因为程序的入口处不是我们所希望执行的指令。如何让这个程序在编译、连接后可以在系统中直接运行呢？怎样执行程序中的指令呢？用Debug加载后，可以将IP设置为10h，从而使CS:IP指向程序中的第一条指令。然后再用t命令、p命令，或者是g命令执行。</p>
<p>为了解决上述这么麻烦的操作，我们可以在源程序中指明程序的入口所在，具体做法如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">	</span><br><span class="line">	start:	mov bx,0</span><br><span class="line">					mov ax,0</span><br><span class="line">					mov cx,8</span><br><span class="line">	s:			add ax,cs:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s</span><br><span class="line">	</span><br><span class="line">					mov ax,4c00h</span><br><span class="line">					int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单来说，<strong>若要CPU从何处开始执行程序，只要在源程序中用“end标号”指明就可以了</strong>。</p>
<p>有了这种方法，就可以这样来安排程序的框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	数据...</span><br><span class="line">start:</span><br><span class="line">	代码...</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h2><p>完成下面的程序，利用栈，将程序中定义的数据逆序存放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; 将这段空间当作栈使用</span><br><span class="line">	</span><br><span class="line">	start:	mov ax,cs</span><br><span class="line">					mov ss,ax</span><br><span class="line">					mov sp,30h ; 将设置栈顶ss:sp指向cs：30</span><br><span class="line"></span><br><span class="line">					mov bx,0</span><br><span class="line">					mov cx,8</span><br><span class="line">	s:			push cs:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s</span><br><span class="line"></span><br><span class="line">					mov bx,0</span><br><span class="line">					mov cx,8</span><br><span class="line">	s0:			pop cs:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s0</span><br><span class="line">	</span><br><span class="line">					mov ax,4c00h</span><br><span class="line">					int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; 将这段空间当作栈使用</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">	start:	mov ax,stacksg</span><br><span class="line">					mov ss,ax</span><br><span class="line">					mov sp,20h ; 将设置栈顶ss:sp指向stack: 20h</span><br><span class="line"></span><br><span class="line">					mov ax,datasg</span><br><span class="line">					mov ds,ax  ; ds指向datasg段</span><br><span class="line"></span><br><span class="line">					mov bx,0   ; ds：bx指向data段中的第一个单元</span><br><span class="line">					mov cx,8</span><br><span class="line">	s:			push ds:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s</span><br><span class="line"></span><br><span class="line">					mov bx,0</span><br><span class="line">					mov cx,8</span><br><span class="line">	s0:			pop ds:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s0</span><br><span class="line">	</span><br><span class="line">					mov ax,4c00h</span><br><span class="line">					int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li><p>现在，程序中有多个段了，如何访问段中的数据呢？当然要通过地址，而地址是分为两部分的，即段地址和偏移地址。如何指明要访问的数据的段地址呢？在程序中，<strong>段名就相当于一个标号，它代表了段地址</strong>。所以指令<code>mov ax,datasg</code>的含义就是将名称为“datasg”的段的段地址送入ax。</p>
</li>
<li><p>一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。程序中“datasg”段中的数据“0abch”的地址就是：datasg:6。要将它送入bx中，就要用如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure>

<p>不能用下面的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 8086CPU不允许将一个数值直接送入段寄存器中</span><br><span class="line">mov ds,datasg</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure></li>
<li><p>注意，所谓的“代码段”、“数据段”、“栈段”完全是我们的安排。</p>
</li>
</ul>
<p>CPU执行流程：</p>
<p>若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是CPU要执行的内容。CPU如何知道去执行它们？</p>
<ol>
<li><p>我们在源程序的最后用“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，</p>
</li>
<li><p>可执行文件中的程序被加载入内存后，CPU的CS：IP被设置指向这个入口，从而开始执行程序中的第一条指令。标号“start”在“code”段中，这样CPU就将code段中的内容当作指令来执行了。</p>
</li>
<li><p>我们在code段中，使用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">moy sp，20h</span><br></pre></td></tr></table></figure>

<p>设置ss指向stacksg，设置ss:sp指向stack:20，<strong>CPU执行这些指令后，将把stacksg段当做栈空间来用</strong>。</p>
</li>
</ol>
<blockquote>
<p>总之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。</p>
</blockquote>
<p>练习示例</p>
<p>写code段中的代码，将a段和b段中的数据依次相加，将结果存到c段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">    db 1, 2, 3, 4, 5, 6, 7, 8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">    db 1, 2, 3, 4, 5, 6, 7, 8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">    db 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line">  s:</span><br><span class="line">    mov ax,0</span><br><span class="line">  </span><br><span class="line">    mov dx,a</span><br><span class="line">    mov ds,dx</span><br><span class="line">    add ax,[bx]</span><br><span class="line">  </span><br><span class="line">    mov dx,b</span><br><span class="line">    mov ds,dx</span><br><span class="line">    add ax,[bx]</span><br><span class="line">  </span><br><span class="line">    mov dx,c</span><br><span class="line">    mov ds,dx</span><br><span class="line">    mov [bx],ax</span><br><span class="line">  </span><br><span class="line">    add bx,2</span><br><span class="line">  loop s</span><br><span class="line">  </span><br><span class="line">  mov ax, 4c00h</span><br><span class="line">  int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>编写code段中的代码，用push指令将a段中的前8个字型数据，逆序存储到b段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">    dw 1, 2, 3, 4, 5, 6, 7, 8, 9, 0ah, 0bh, 0ch, 0dh, 0eh, 0fh, 0ffh</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">    dw 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  </span><br><span class="line">  mov ax,b</span><br><span class="line">  mov ss,ax</span><br><span class="line">  mov sp,10h</span><br><span class="line"></span><br><span class="line">  mov ax,a</span><br><span class="line">  mov ds,ax</span><br><span class="line"></span><br><span class="line">  mov bx,0</span><br><span class="line">  mov cx,8</span><br><span class="line">  s:</span><br><span class="line">    push [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">  loop s</span><br><span class="line"></span><br><span class="line">  mov ax, 4c00h</span><br><span class="line">  int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h1 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h1><h2 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></table></figure>

<p>执行后al=00100011B。</p>
<p>通过该指令可将操作对象的相应位设为0，其他位不变：</p>
<ul>
<li>将al的第6位设为0的指令是：and al 10111111B</li>
<li>将al的第7位设为0的指令是：and al 01111111B</li>
<li>将al的第0位设为0的指令是：and al 11111110B</li>
</ul>
<p>在文本编辑过程中，我们按一下键盘的a键，就会在屏幕上看到“a”。这是怎样一个过程呢？</p>
<ol>
<li>我们按下键盘的a键，这个按键的信息被送入计算机，计算机用ASCII码的规则对其进行编码，将其转化为61H存储在内存的指定空间中；</li>
<li>文本编辑软件从内存中取出61H，将其送到显卡上的显存中；</li>
<li>工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，61H被当作字符“a”，显卡驱动显示器，将字符“a”的图像画在屏幕上。</li>
</ol>
<blockquote>
<p>可以看到，显卡在处理文本信息的时候，是按照ASCII码的规则进行的。这也就是说，如果我们要想在显示器上看到“a”，就要给显卡提供“a”的ASCII码，61H。如何提供？当然是写入显存中。</p>
</blockquote>
<h2 id="以字符形式给出的数据"><a href="#以字符形式给出的数据" class="headerlink" title="以字符形式给出的数据"></a>以字符形式给出的数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;unIX&#x27;</span><br><span class="line">    db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: 	mov al,&#x27;a&#x27;</span><br><span class="line">				mov bl,&#x27;b&#x27;</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li><code>db</code>即<code>define byte</code>。</li>
<li><code>db &#39;unIX&#39;</code>相当于<code>db 75H,6EH,49H,58H</code>。</li>
<li><code>mov al &#39;a&#39;</code>相当于<code>mov al,61H</code>。</li>
</ul>
<p>使用Debug就可以看到data段的内容头部就是unIXfoRK</p>
<p><img src="/images/image-20211128094047600.png" alt="image-20211128094047600"></p>
<blockquote>
<p>先用r命令分析一下data段的地址，因“ds=0B2D”，去除10H的PSP，所以程序从0B3DH段开始，data段又是程序中的第一个段，它就在程序的起始处，所以它的段地址为OB3DH</p>
</blockquote>
<h2 id="如何进行大小写转换"><a href="#如何进行大小写转换" class="headerlink" title="如何进行大小写转换"></a>如何进行大小写转换</h2><p>众所周知，<code>小写字母ASCII值 = 大写字母ASCII值 + 20H</code>。</p>
<blockquote>
<p>一个字母，不管它原来是大写还是小写，将它的第5位设置为0，它就必将变为大写字母；将它的第5位设置为1，它就必将变为小写字母。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &#x27;BaSiC&#x27;</span><br><span class="line">    db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0 ; 设置（bx）=0，ds：bx指向&#x27;BaSic&#x27;的第一个字母</span><br><span class="line">        mov cx,5</span><br><span class="line">s:      mov al,[bx]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx],al</span><br><span class="line">        inc bx</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov bx,5 ; 设置（bx）=5，ds:bx指向’iNfOrMaTiOn&#x27;的第一个字母</span><br><span class="line">        mov cx,11</span><br><span class="line">s0:     mov al,[bx]</span><br><span class="line">        or al,000100000B</span><br><span class="line">        mov [bx],al</span><br><span class="line">        inc bx</span><br><span class="line">        loop s0</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h2><p>在前面，我们用<code>[bx]</code>的方式来指明一个内存单元，还可以用一种更为灵活的方式来指明内存单元：<code>[bx+idata]</code>表示一个内存单元，它的偏移地址为<code>(bx) + idata(bx中的数值加上idata)</code>。</p>
<ul>
<li><p><code>mov ax,[bx+200]</code>：将一个内存单元的内存送入ax，这个内存单元大的长度为2个字节(字单元)，存放一个字，偏移地址为bx中的数据加上200，段地址在ds。</p>
<p>数学化的描述为<code>(ax)=((ds)*16+(bx)+200)</code></p>
</li>
<li><p>该指令也可以写成如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[200+bx]</span><br><span class="line">mov ax,200[bx]</span><br><span class="line">mov ax,[bx].200</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以上述字母大小写转换的代码可以改成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &#x27;BaSiC&#x27;</span><br><span class="line">    db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: 	mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,5</span><br><span class="line">s:      mov al,[bx]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx],al</span><br><span class="line">        mov al,[5+bx]</span><br><span class="line">        or al,000100000B</span><br><span class="line">        mov [5+bx],al</span><br><span class="line"></span><br><span class="line">        inc bx</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，上面的代码和原始代码不是等价的，他只能修改<code>iNfOrMaTiOn</code>的前五位。</p>
</blockquote>
<h2 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h2><p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。</p>
<p>用si和di实现将字符串<code>welcome to masm!</code>复制到它后面的数据区中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;welcome to masm!&#x27;</span><br><span class="line">	db &#x27;................&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: 	mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        mov di,16</span><br><span class="line"></span><br><span class="line">        mov cx,8</span><br><span class="line">s:      mov ax,[si]</span><br><span class="line">        mov [di],ax</span><br><span class="line">        add si,2</span><br><span class="line">        add di,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="bx-si-和-bx-di"><a href="#bx-si-和-bx-di" class="headerlink" title="[bx+si]和[bx+di]"></a>[bx+si]和[bx+di]</h2><ul>
<li><code>[bx+si]</code>表示一个内存单元，他的偏移地址为(bx)+(si)，即bx中的数字加上si中的数值。</li>
<li><code>mov ax，[bx+si]</code>数学化的描述为<code>(ax) = ((ds)*16 + (bx)+(si))</code></li>
<li>该指令可以写成如下：<code>mov ax, [bx][si]</code></li>
</ul>
<p>同理还有[bx+si+idata]：</p>
<ul>
<li><p><code>[bx+si+idata]</code>表示一个内存单元，他的偏移地址为(bx)+(si)+idata。</p>
</li>
<li><p><code>mov ax，[bx+si+idata]</code>数学化的描述为<code>(ax) = ((ds)*16 + (bx)+(si)+idata)</code></p>
</li>
<li><p>该指令可以写成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200+si]</span><br><span class="line">mov ax,[200+bx+si]</span><br><span class="line">mov ax,200[bx][si]</span><br><span class="line">mov ax,[bx].200[si]</span><br><span class="line">mov ax,[bx][si].200</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="不同的寻址方式的灵活应用"><a href="#不同的寻址方式的灵活应用" class="headerlink" title="不同的寻址方式的灵活应用"></a>不同的寻址方式的灵活应用</h2><p>定位内存地址的方法，称为<code>寻址方式</code>。</p>
<p>五种寻址方式：</p>
<ul>
<li>[idata]用一个常量来表示地址，可用于直接定位一个内存单元；</li>
<li>[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元</li>
<li>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；</li>
<li>[bx+si]用两个变量表示地址。</li>
<li>[bx+si+idata]用两个变量和一个常量表示地址。</li>
</ul>
<p>编程，将datasg段中每个单词的头一个字母改为大写字母。</p>
<p><img src="/images/image-20211128111720117.png" alt="image-20211128111720117"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assme cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;1. file         &#x27;</span><br><span class="line">	db &#x27;2. edit         &#x27;</span><br><span class="line">	db &#x27;3. search       &#x27;</span><br><span class="line">	db &#x27;4. view         &#x27;</span><br><span class="line">	db &#x27;5. options      &#x27;</span><br><span class="line">	db &#x27;6. help         &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,6</span><br><span class="line">s:      mov al,[bx+3]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+3],al</span><br><span class="line">        add bx,16</span><br><span class="line">        loop s</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>双层循环：</p>
<p>编程，将datasg段中每个单词改为大写字母。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assme cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;ibm         &#x27;</span><br><span class="line">	db &#x27;dec         &#x27;</span><br><span class="line">	db &#x27;doc         &#x27;</span><br><span class="line">	db &#x27;vax         &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,4</span><br><span class="line">        </span><br><span class="line">s0:			mov si,0</span><br><span class="line">				mov cx,3</span><br><span class="line">				</span><br><span class="line">s:			mov al,[bx+3]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">				loop s        </span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        loop s0</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>上面代码，有一个问题。在于cx的使用，我们进行二重循环，却只用了一个循环计数器，造成在进行内<br>层循环的时候，覆盖了外层循环的循环计数值。多用一个计数器又不可能，因为1oop指令默认cx为循环计数器。怎么办呢？</p>
<p>我们想到的办法就是在每次开始内层循环的时候，<strong>用寄存器dx将外层循环的cx中的数值临时保存起来</strong>，在执行外层循环的loop指令前，再恢复外层循环的cx数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,4</span><br><span class="line">        </span><br><span class="line">s0:			mov dx,cx  ; 将外层循环的cx值保存在dx中</span><br><span class="line">				mov si,0</span><br><span class="line">				mov cx,3   ; cx设置内层循环的次数</span><br><span class="line">				</span><br><span class="line">s:			mov al,[bx+si]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">				loop s        </span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        mov cx,dx  ; 用dx中存放的外层循环的计数值恢复cx</span><br><span class="line">        loop s0</span><br><span class="line">codesg ends</span><br></pre></td></tr></table></figure>



<p>但是问题又来了，寄存器的数量是有限的，对于复杂循环，可能面临没有寄存器可用的情况。这时就可以将其存储在内存中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assme cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;ibm         &#x27;</span><br><span class="line">	db &#x27;dec         &#x27;</span><br><span class="line">	db &#x27;doc         &#x27;</span><br><span class="line">	db &#x27;vax         &#x27;</span><br><span class="line">	dw 0     ; 定义一个字，用来暂存cx</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,4</span><br><span class="line">s0:			mov ds:[40H],cx  ; 将外层循环的cx值保存在datasg:40H单元中</span><br><span class="line">				mov si,0</span><br><span class="line">				mov cx,3         ; cx设置为内层循环的次数</span><br><span class="line">				</span><br><span class="line">s:			mov al,[bx+si]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">				loop s        </span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        mov cx,ds:[40H]  ; 用datasg:40H单元中的值回复cx</span><br><span class="line">        loop s0</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00H</span><br><span class="line">        int 21H</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>但是问题又来了，如果需要保存多个数据的时候，你必须要记住数据放到了哪个单元中，这样程序容易混乱。这时，我们就可以使用栈来保存数据。</p>
<blockquote>
<p>一般来说，在需要暂存数据的时候，我们都应该使用栈。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">assme cs:codesg,ds:datasg,ss:stasksg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;ibm         &#x27;</span><br><span class="line">	db &#x27;dec         &#x27;</span><br><span class="line">	db &#x27;doc         &#x27;</span><br><span class="line">	db &#x27;vax         &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment   ; 定义一个段，用来做栈段，容量为16个字节</span><br><span class="line">	dw 0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,stacksg</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line">        </span><br><span class="line">        mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,4</span><br><span class="line">s0:			push cx          ; 将外层循环的cx值压栈</span><br><span class="line">				mov si,0</span><br><span class="line">				mov cx,3         ; cx设置为内层循环的次数</span><br><span class="line">				</span><br><span class="line">s:			mov al,[bx+si]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">				loop s        </span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        pop cx            ; 从栈顶弹出原cx的值，恢复cx</span><br><span class="line">        loop s0</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00H</span><br><span class="line">        int 21H</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><p>计算机是进行数据处理、运算的机器，那么其中包含两个基本的问题：</p>
<ul>
<li>处理的数据在什么地方</li>
<li>要处理的数据有多长</li>
</ul>
<p>这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。本章我们就针对8086CPU对这两个基本问题进行讨论。</p>
<p>使用描述性的符号<code>reg</code>来表示一个寄存器，用<code>sreg</code>表示一个段寄存器。</p>
<ul>
<li>reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；</li>
<li>sreg的集合包括：ds、ss、cs、es</li>
</ul>
<h2 id="bx、si、di、bp"><a href="#bx、si、di、bp" class="headerlink" title="bx、si、di、bp"></a>bx、si、di、bp</h2><ul>
<li>在8086CPU中，只有这4个寄存器可以用在<code>[...]</code>中来进行内存单元的寻址。</li>
<li>这4个寄存器可以单个出现，或只能以4种组合出现：<ul>
<li>bx和si</li>
<li>bx和di</li>
<li>bp和si</li>
<li>bp和di</li>
</ul>
</li>
<li>只要在<code>[...]</code>中使用寄存器bp，且指令中没有显性地给出段地址，段地址就默认在ss中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">mov ax,[bx+si+idata]</span><br><span class="line">mov ax,[bx+di+idata]</span><br><span class="line">mov ax,[bp+si+idata]</span><br><span class="line">mov ax,[bp+di+idata]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [bp]           ; 含义：（ax）=（（ss）*16 +（bp））</span><br><span class="line">mov ax, [bp+idata]     ; 含义：（ax）=（（ss）*16 +（bp) + idata）</span><br><span class="line">mov ax, [bp+si]        ; 含义：（ax）=（（ss）*16 +（bp) +（si））</span><br><span class="line">mov ax, [bp+si+idata]  ; 含义：（ax）=（（ss）*16 +（bp）+（si）+idata）</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>BP</code>(base pointer): </p>
<ul>
<li>基数指针寄存器，它的用途有点特殊，是和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到。</li>
<li>比如说，堆栈中压入了很多数据或者地址，你肯定想通过SP来访问这些数据或者地址，但SP是要指向栈顶的，是不能随便乱改的，这时候你就需要使用BP，把SP的值传递给BP，通过BP来寻找堆栈里数据或者地址。</li>
<li>简单来说，SP和BP一般与段寄存器SS联用，以确定栈寄存器中某一单元的地址，SP用以指示栈顶的偏移地址，而BP可作为堆栈区中的一个基地址，用以确定在堆栈中的操作数地址。</li>
<li>一般除了保存数据外，可以作为指针寄存器用于存储器寻址，此时它默认搭配的段寄存器是SS-堆栈段寄存器。</li>
<li>BP是16位的，再扩充16位就是EBP，用于32位编程环境的。一般高级语言的参数传递等等，转换为汇编后经常由BP/EBP来负责寻址处理。</li>
</ul>
</blockquote>
<h2 id="机器指令处理的数据在什么地方"><a href="#机器指令处理的数据在什么地方" class="headerlink" title="机器指令处理的数据在什么地方"></a>机器指令处理的数据在什么地方</h2><p>绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：<code>读取</code>、<code>写入</code>、<code>运算</code>。</p>
<p>在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：<code>CPU内部</code>、<code>内存</code>、<code>端口</code>。</p>
<table>
<thead>
<tr>
<th>机器码</th>
<th>汇编指令</th>
<th>指令执行前数据的位置</th>
</tr>
</thead>
<tbody><tr>
<td>8E1E0000</td>
<td>mov bx,[0]</td>
<td>内存，ds:0单元</td>
</tr>
<tr>
<td>89C3</td>
<td>mov bx,ax</td>
<td>CPU内部，ax寄存器</td>
</tr>
<tr>
<td>BB0100</td>
<td>mov bx,1</td>
<td>CPU内部，指令缓冲器</td>
</tr>
</tbody></table>
<h2 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h2><p>在汇编语言中如何表达数据的位置？汇编语言中用3个概念来表达数据的位置。</p>
<ul>
<li><p><code>立即数(idata)</code>：对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称为：立即数（idata），在汇编指令中直接给出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add bx,2000h</span><br><span class="line">or bx,0001000b</span><br><span class="line">mov al,&#x27;a&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><code>寄存器</code>：指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx</span><br><span class="line">mov ds,ax</span><br><span class="line">push bx</span><br><span class="line">mov ds:[0],bx</span><br><span class="line">push ds</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,ax</span><br></pre></td></tr></table></figure></li>
<li><p><code>段地址(SA)和偏移地址(EA)</code>：指令要处理的数据在内存中，在汇编指令中可用<code>[X]</code>的格式给出EA，SA在某个段寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bx+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+si+8]</span><br><span class="line"></span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bp+si+8]</span><br><span class="line"></span><br><span class="line">mov ax,ds:[bp]</span><br><span class="line">mov ax,es:[bx]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为<code>寻址方式</code>。</p>
<p><img src="/images/image-20211128144024797.png" alt="image-20211128144024797"></p>
<h2 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h2><p>8086CPU的指令，可以处理两种尺寸的数据，<code>byte</code>和<code>word</code>。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。</p>
<ul>
<li><p>通过寄存器名指明要处理的数据的尺寸。(通过寄存器宽度来丈量)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; 字操作</span><br><span class="line">mov ax,1</span><br><span class="line">mov bx,ds:[0]</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">inc ax</span><br><span class="line">add ax,1000</span><br><span class="line"></span><br><span class="line">; 字节操作</span><br><span class="line">mov al,1</span><br><span class="line">mov al,bl</span><br><span class="line">mov al,as:[0]</span><br><span class="line">mov ds:[0],al</span><br><span class="line">inc al</span><br><span class="line">add al,100</span><br></pre></td></tr></table></figure></li>
<li><p>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元</span><br><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line">add word ptr [bx],2</span><br><span class="line"></span><br><span class="line">; 下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元</span><br><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr [bx]</span><br><span class="line">inc byte ptr ds:[0]</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure></li>
<li><p>其他方法：有些指令默认了访问的是字单元还是字节单元，比如，<code>push[1000H]</code>就不用指明访问的是字单元还是字节单元，因为push指令只进行字操作。</p>
</li>
</ul>
<h2 id="汇编和C语言的转换"><a href="#汇编和C语言的转换" class="headerlink" title="汇编和C语言的转换"></a>汇编和C语言的转换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> cn[<span class="number">3</span>];    <span class="comment">// 公司名称</span></span><br><span class="line">  <span class="keyword">char</span> hn[<span class="number">9</span>];    <span class="comment">// 总裁姓名</span></span><br><span class="line">  <span class="keyword">int</span> pm;        <span class="comment">// 排名</span></span><br><span class="line">  <span class="keyword">int</span> sr;        <span class="comment">// 收入</span></span><br><span class="line">  <span class="keyword">char</span> cp[<span class="number">3</span>];    <span class="comment">// 著名产品</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span> <span class="title">desc</span> =</span> &#123;<span class="string">&quot;DEC&quot;</span>, <span class="string">&quot;Ken Olsen&quot;</span>, <span class="number">137</span>, <span class="number">40</span>, <span class="string">&quot;PDP&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码在内存结构如下：这些数据被存放在seg段中从偏移地址60H起始的位置。</p>
<p><img src="/images/image-20211128150510309.png" alt="image-20211128150510309"></p>
<p>将其编译成成汇编语言，得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60h</span><br><span class="line"></span><br><span class="line">mov word ptr [bx+0ch],38</span><br><span class="line">mov word ptr [bx+0eh],70</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov byte ptr [bx+10h+si],&#x27;V&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10h+si],&#x27;A&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10h+si],&#x27;X&#x27;</span><br><span class="line">inc si</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="number">1</span>;</span><br><span class="line">  dec.pm = <span class="number">38</span>;</span><br><span class="line">  dec.sr = dec.sr+<span class="number">70</span>;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  dec.cp[i]=<span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">  i++;</span><br><span class="line">  dec.cp[i]=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  i++;</span><br><span class="line">  dec.cp[i]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码转成汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60h     ; 记录首地址，送入bx</span><br><span class="line"></span><br><span class="line">mov word ptr [bx].0ch,38        ; C: dec.pm=38;</span><br><span class="line">mov word ptr [bx].0eh,70        ; C: dec.sr=dec.sr+70;</span><br><span class="line"></span><br><span class="line">mov si,0                        ; C: i=0;</span><br><span class="line">mov byte ptr [bx].10h[si],&#x27;V&#x27;   ; C: dec.cp[i]=&#x27;V&#x27;;</span><br><span class="line">inc si                          ; C: i++;</span><br><span class="line">mov byte ptr [bx],10h[si],&#x27;A&#x27;   ; C: dec.cp[i]=&#x27;A&#x27;;</span><br><span class="line">inc si                          ; C: i++;</span><br><span class="line">mov byte ptr [bx],10h[si],&#x27;X&#x27;   ; C: dec.cp[i]=&#x27;X&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>8086CPU提供的如<code>[bx+si+idata]</code>的寻址方式为结构化数据的处理提供了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。</p>
<ul>
<li>从上面可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字型数<br>据，有的是字节型数据，有的是数组（字符串）。</li>
<li>一般来说，我们可以用<code>[bx+idata+si]</code>的方式来访问结构体中的数据。<strong>用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素</strong>。为此，汇编语言提供了更为贴切的书写方式，如：<code>[bx].idata</code>、<code>[bx].idata[si]</code></li>
<li>在C语言程序中我们看到，如：<code>dec.cp[i]</code>，dec是一个变量名，指明了结构体变量的地址，cp是一个名称，指明了数据项cp的地址，而i用来定位cp中的每一个字符。汇编语言中的做法是：<code>bx.10h[si]</code>。看一下，是不是很相似？</li>
</ul>
</blockquote>
<h2 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h2><p>div是除法指令，使用div做除法的时候应注意以下问题。</p>
<ul>
<li>除数：有8位和16位两种，在一个reg或内存单元中。</li>
<li>被除数：默认放在<code>AX</code>或<code>DX和AX</code>中，<ul>
<li>如果除数为8位，被除数则为16位，默认在AX中存放。</li>
<li>如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</li>
</ul>
</li>
<li>结果：<ul>
<li>如果除数为8位，则AL存储商，AH存储余数；</li>
<li>如果除数为16位，则AX存储商，DX存储余数。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; 格式如下：</span><br><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line">; 示例：</span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">; (al) = (ax) / ((ds)*16+0) 的商</span><br><span class="line">; (ah) = (ax) / ((ds)*16+0) 的余数</span><br><span class="line"></span><br><span class="line">div word ptr es:[0]</span><br><span class="line">; （ax）=[（dx）*10000H+（ax）]/（（es）*16+0）的商</span><br><span class="line">; （dx）=[（dx）*10000H+（ax）]/（（es）*16+0）的余数</span><br><span class="line"></span><br><span class="line">div byte ptr [bx+si+8]</span><br><span class="line">; （al）=（ax）/（（ds）*16+（bx）+（si）+8）的商</span><br><span class="line">; （ah）=（ax）/（（ds）*16+（bx）+（si）+8）的余数</span><br><span class="line"></span><br><span class="line">div word ptr [bx+si+8]</span><br><span class="line">; （ax）=[（dx）*10000H+（ax）]/（（ds）*16+（bx）+（si）+8）的商</span><br><span class="line">; （dx）=[（dx）*10000H+（ax）]/（（ds）*16+（bx）+（si）+8）的余数</span><br></pre></td></tr></table></figure>

<p>利用除法指令计算100001/100。</p>
<p>首先分析一下，被除数100001大于65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位寄存器中存放，但是，因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。因为要分别为dx和ax赋100001的高16位值和低16位值，所以应先将100001表示为16进制形式：186A1H。程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H ; (dx)*10000H+(ax)=100001</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>



<p>编程，利用除法指令计算1001/100。<br>首先分析一下，被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，也就是说，要进行8位的除法。程序如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1001</span><br><span class="line">mov bl,100</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure>



<h2 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h2><p>db和dw定义字节型数据和字型数据。dd是用来定义dword(double word，双字）型数据的。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db 1</span><br><span class="line">	dw 1</span><br><span class="line">	dd 1</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个数据为01H，在data:0处，占1个字节</li>
<li>第二个数据为0001H，在data:1处，占1个字；</li>
<li>第三个数据为00000001H，在data:3处，占2个字。</li>
</ul>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p><code>dup</code>：duplicate，是和db、dw、dd等数据定义伪指令配合使用的，用来进行<strong>数据的重复</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 重复的次数 dup (重复的字节型数据)</span><br><span class="line">dw 重复的次数 dup (重复的字型数据)</span><br><span class="line">dd 重复的次数 dup (重复的双字型数据)</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<ul>
<li><code>db 3 dup(0)</code>：定义了3个字节，它们的值都是0，相当于<code>db 0,0,0</code>。</li>
<li><code>db 3 dup(0,1,2)</code>：定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于<code>db 0,1,2,0,1,2,0,1,2</code>。</li>
<li><code>db 3 dup (&#39;abc&#39;，ABC&#39;)</code>：定义了18个字节，它们是abcABCabcABCabcABC，相当于<code>db &#39;abcABCabcABCabcABC&#39;</code></li>
</ul>
<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><p><strong>可以修改IP，或同时修改CS和IP的指令统称为转移指令</strong>。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
<p>8086CPU的转移行为有以下几类。</p>
<ul>
<li>只修改IP时，称为<code>段内转移</code>，比如：jmp ax。</li>
<li>同时修改CS和IP时，称为<code>段间转移</code>，比如：jmp1000：0。</li>
</ul>
<p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p>
<ul>
<li>短转移IP的修改范围为-128~127。</li>
<li>近转移IP的修改范围为-32768~32767.</li>
</ul>
<p>8086CPU的转移指令分为以下几类。</p>
<ul>
<li>无条件转移指令（如：jmp）</li>
<li>条件转移指令</li>
<li>循环指令（如：loop）</li>
<li>过程</li>
<li>中断</li>
</ul>
<h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><p>操作符offset在汇编语言中是由编译器处理的符号，它的<strong>功能是取得标号的偏移地址</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	start:mov ax,offset start ; 找到start标记的指令的偏移地址，相当于mov ax,0</span><br><span class="line">	s:		mov ax,offset s     ; 找到s标记的指令的偏移地址，第一条指令长度为3个字节，相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>使该程序在运行中将s处的一条指令复制到s0处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"> codesg segment</span><br><span class="line">   s: mov ax,bx         ;（mov ax,bx 的机器码占两个字节）</span><br><span class="line">      mov si,offset s</span><br><span class="line">      mov di,offset s0</span><br><span class="line">      mov ax,cs:[si]</span><br><span class="line">      mov cs:[di],ax</span><br><span class="line"> s0: 	nop               ;（nop的机器码占一个字节）</span><br><span class="line">      nop</span><br><span class="line"> codesg ends</span><br><span class="line"> ends</span><br></pre></td></tr></table></figure>



<h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><p>jmp为无条件转移指令，可以只修改IP也可以同时修改CS和IP。</p>
<p>jmp指令要给出两种信息：</p>
<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号（转到标号处执行指令）</span><br></pre></td></tr></table></figure>

<p>这种格式的jmp指令实现的是<code>段内短转移</code>，它对IP的修改范围为-128~127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。</p>
<p>jmp指令中的“short”符号，说明指令进行的是短转移。jmp指令中的“标号”是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS：IP应该指向标号处的指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">	start: mov ax,0</span><br><span class="line">				 mov bx,0</span><br><span class="line">				 jmp short s</span><br><span class="line">				 add ax,1  ; 跳过此条指令</span><br><span class="line">			s: inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>查看内存：</p>
<p><img src="/images/image-20211129150132868.png" alt="image-20211129150132868"></p>
<p>可以看到，<code>jmp short s</code>被翻译成了<code>jmp 0008</code>，对应的机器码为<code>EB03</code>。</p>
<p>注意，这个机器码中竟不包含转移的目的地址。这意味着，CPU在执行 EB03的时，并不知道转移的目的地址。</p>
<blockquote>
<p><strong>CPU在执行jmp指令的时候并不需要转移的目的地址</strong>。机器指令中不包含目的地址的地址，那么也就是说，CPU不需要这个目的地址就可以实现对IP的修改。</p>
</blockquote>
<p>CPU在执行EB03的时候是根据什么修改的IP，使其指向目标指令呢？<strong>就是根据指令码中的03</strong>。注意，要转移的目的地址是CS：000B，而CPU执行EB03时，当前的（IP）=0008H，将当前的IP值加3，使（IP）=000BH，CS：IP就可指向目标指令。</p>
<blockquote>
<p>在转移指令EB03中并没有告诉CPU要转移的目的地址，却告诉了CPU要转移的位移，即将当前的IP向后移动3个字节。</p>
</blockquote>
<p>在“jmp short 标号”指令所对应的机器码中，并不包含转移的目的地址，而<strong>包含的是转移的位移</strong>。这个位移，是编译器根据汇编指令中的“标号”计算出来的：</p>
<p><img src="/images/image-20211129151303118.png" alt="image-20211129151303118"></p>
<p>实际上，“jmp short 标号”的功能为：<code>(IP)=(IP)+8位位移</code>。</p>
<ol>
<li>8位位移=标号处的地址 - jmp指令后的第一个字节的地址；</li>
<li>short指明此处的位移为8位位移；</li>
<li>8位位移的范围为-128~127，用补码表示；</li>
<li>8位位移由编译程序在编译时算出。</li>
</ol>
<p>还有一种和“ jmp short 标号”功能相近的指令格式，<code>jmp near ptr 标号</code>，它实现的是<strong>段内近转移</strong>。</p>
<ol>
<li>“jmp near ptr 标号”的功能为：(IP)=(IP)+16位位移。</li>
<li>16位位移=标号处的地址 - jmp指令后的第一个字节的地址； near ptr指明此处的位移为16位位移，进行的是段内近转移； 16位位</li>
<li>移的范围为-32768~ 32767，用补码表示；</li>
<li>16位位移由编译程序在编译时算出。</li>
</ol>
<h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p>“jmp far ptr 标号”实现的是段间转移，又称为<strong>远转移</strong>。功能如下：</p>
<ul>
<li>（CS）= 标号所在段的段地址； </li>
<li>（IP）= 标号在段中的偏移地址。 </li>
</ul>
<p>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	start: mov ax,0</span><br><span class="line">				 mov bx,0</span><br><span class="line">				 jmp far ptr s</span><br><span class="line">				 db 256 dup(0)</span><br><span class="line">	s:		 add ax,1</span><br><span class="line">				 inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211129153937410.png" alt="image-20211129153937410"></p>
<p>源程序中的<code>db 256 dup(0)</code>，被Debug解释为相应的若干条汇编指令。这不是关键，关键是我们要注意一下jmp far ptrs所对应的机器码：<code>EA0B01BD0B</code>，其中包含转移的目的地址。“0B01BD0B”是目的地址在指令中的存储顺序，高地址的“BDB”是转移的段地址：0BBDH，低地址的“0B01”是偏移地址：010BH。</p>
<h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><ul>
<li>指令格式：<code>jmp 16位reg</code></li>
<li>功能：（IP）=（16位reg）</li>
</ul>
<h2 id="转移地址在内存中的-jmp-指令"><a href="#转移地址在内存中的-jmp-指令" class="headerlink" title="转移地址在内存中的 jmp 指令"></a>转移地址在内存中的 jmp 指令</h2><p>转移地址在内存中的jmp指令有两种格式： </p>
<ul>
<li><p>jmp word ptr 内存单元地址（段内转移）：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0] ; 执行后(IP)=0123H</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">jmp word ptr [bx] ; 执行后(IP)=0123H</span><br></pre></td></tr></table></figure></li>
<li><p>jmp dword ptr 内存单元地址（段间转移）：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0] ; 执行后，(CS)=0,(IP)=0123H</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]   ; 执行后，(CS)=0,(IP)=0123H</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2><p>jcxz：<code>jump when CX is zero</code></p>
<p>功能：<strong>如果(cx)=0，则转移到标号处执行。当(cx)≠0时，什么也不做（程序向下执行）</strong></p>
<ul>
<li>当(cx)=0时，(IP)=(IP)+8位位移</li>
<li>8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址；</li>
<li>8位位移的范围为-128~127，用补码表示；</li>
<li>8位位移由编译程序在编译时算出。</li>
</ul>
<blockquote>
<p><code>jcxz 标号</code>的功能类似于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cx == <span class="number">0</span>) &#123;</span><br><span class="line">	jmp <span class="keyword">short</span> 标号;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>jcxz是有条件转移指令</p>
<ul>
<li>所有的有条件转移指令都是短转移</li>
<li>对IP的修改范围都为-128~127</li>
<li>在对应的机器码中包含转移的位移，而不是目的地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; 在内存2000H段中查找第一个值为0的字节，找到后，将它的偏移地址存储在dx中。</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start: mov ax,2000H</span><br><span class="line">       mov ds,ax</span><br><span class="line">       mov bx,0</span><br><span class="line"></span><br><span class="line">    s: mov cl,[bx]</span><br><span class="line">       mov ch,0</span><br><span class="line">       jcxz ok</span><br><span class="line">       inc bx</span><br><span class="line">       jmp short s</span><br><span class="line"></span><br><span class="line">   ok: mov dx,bx</span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">   </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127。</p>
<p>“loop 标号”的功能相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line"><span class="keyword">if</span> (cx!=<span class="number">0</span>) &#123;</span><br><span class="line">  jmp <span class="keyword">short</span> 标号;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start: mov ax,2000H</span><br><span class="line">       mov ds,ax</span><br><span class="line">       mov bx,0</span><br><span class="line">      </span><br><span class="line">    s: mov cl,[bx]</span><br><span class="line">       mov ch,0</span><br><span class="line">       inc cx</span><br><span class="line">       inc bx</span><br><span class="line">       loop s</span><br><span class="line"></span><br><span class="line">   ok: dec bx</span><br><span class="line">       mov dx,bx</span><br><span class="line"></span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h2><ul>
<li>jmp short标号</li>
<li>jmp near ptr标号</li>
<li>jcxz标号</li>
<li>loop标号</li>
</ul>
<p>等几种汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。这种设计，<strong>方便了程序段在内存中的浮动装配</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   mov cx,6        ; B9 06 00</span><br><span class="line">   mov ax,10h      ; B8 10 00</span><br><span class="line">s: add ax,ax       ; 01 C0</span><br><span class="line">	 loop s          ; E2 FC</span><br></pre></td></tr></table></figure>

<ul>
<li>这段程序装在内存中的不同位置都可正确执行，因为loops在执行时只涉及s的位移（-4，前移4个字节，补码表示为FCH），而不是s的地址。</li>
<li>如果loops的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制，因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。</li>
</ul>
<h2 id="编译器对转移位移超界的检测"><a href="#编译器对转移位移超界的检测" class="headerlink" title="编译器对转移位移超界的检测"></a>编译器对转移位移超界的检测</h2><p>根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	start: jmp short s   ; ERROR: jmp short s的转移范围是-128~127，IP最多向后移动127个字节</span><br><span class="line">				 db 128 dup(0)</span><br><span class="line">			s: mov ax,0ffffh</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="一个奇怪的程序"><a href="#一个奇怪的程序" class="headerlink" title="一个奇怪的程序"></a>一个奇怪的程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">        mov ax, 4c00H</span><br><span class="line">        int 21H</span><br><span class="line"></span><br><span class="line">start:  mov ax, 0</span><br><span class="line">    s:  nop    ; 分配一个字节的空间</span><br><span class="line">        nop</span><br><span class="line"></span><br><span class="line">        mov di, offset s</span><br><span class="line">        mov si, offset s2</span><br><span class="line">        mov ax, cs:[si]</span><br><span class="line">        mov cs:[di], ax ; 将jmp short s1这个指令的机器码赋值给了s标号后面2个字节</span><br><span class="line"></span><br><span class="line">    s0: jmp short s ; 对应的机器码为EBF6，执行它会向前偏移10个字节</span><br><span class="line">    </span><br><span class="line">    s1: mov ax, 0   ; 标号s1及以后的汇编代码，程序就没有执行了。</span><br><span class="line">        int 21H</span><br><span class="line">        mov ax, 0</span><br><span class="line">        </span><br><span class="line">    s2: jmp short s1</span><br><span class="line">        nop</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h1 id="第十章-CALL和RET指令"><a href="#第十章-CALL和RET指令" class="headerlink" title="第十章 CALL和RET指令"></a>第十章 CALL和RET指令</h1><h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><ul>
<li>ret（return）指令用栈中的数据，修改IP的内容，从而实现近转移；</li>
<li>retf（return far）指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</li>
</ul>
<p>CPU执行ret指令时，进行下面两步操作：</p>
<ul>
<li>(IP)=(ss)*16+(sp)</li>
<li>(sp)=(sp)+2</li>
</ul>
<p>CPU执行retf指令时，进行下面4步操作：</p>
<ul>
<li>(IP)=(ss)*16+(sp)</li>
<li>(sp)=(sp)+2</li>
<li>(CS)=(ss)*16+(sp)</li>
<li>(sp)=(sp)+2</li>
</ul>
<p>可以看出，如果我们用汇编语法来解释ret和retf指令，则：</p>
<p>CPU执行ret指令时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br></pre></td></tr></table></figure>

<p>CPU执行retf指令时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">	db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">			mov ax,4c00h</span><br><span class="line">			int 21h</span><br><span class="line">start:mov ax,stack</span><br><span class="line">			mov ss,ax</span><br><span class="line">			mov sp,16</span><br><span class="line">			mov ax,0</span><br><span class="line">			push ax</span><br><span class="line">			mov bx,0</span><br><span class="line">			ret   ; ret指令执行后，（IP）=O，CS：IP指向代码段的第一条指令。</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h2><p>CPU执行call指令时，进行两步操作：</p>
<ol>
<li>将当前的IP或CS和IP压入栈中；</li>
<li>转移。</li>
</ol>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p>
<p><code>call 标号(将当前的IP压栈后，转到标号处执行指令)</code>，CPU执行此种格式的call指令时，进行如下的操作：</p>
<ul>
<li>(sp)=(sp)-2</li>
<li>(ss)*16+(sp)=(IP)</li>
<li>(IP)=(IP)+16位位移。</li>
</ul>
<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>

































</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>