<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第12章-内中断&quot;&gt;&lt;a href=&quot;#第12章-内中断&quot; class=&quot;headerlink&quot; title=&quot;第12章 内中断&quot;&gt;&lt;/a&gt;第12章 内中断&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;任何一个通用的CPU都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。&lt;/li&gt;
&lt;li&gt;这种特殊的信息，我们可以称其为：&lt;code&gt;中断信息&lt;/code&gt;。中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;内中断的产生&quot;&gt;&lt;a href=&quot;#内中断的产生&quot; class=&quot;headerlink&quot; title=&quot;内中断的产生&quot;&gt;&lt;/a&gt;内中断的产生&lt;/h2&gt;&lt;p&gt;内中断主要有四种："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>2 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Assembly-Language/" rel="tag">Assembly Language</a></div><div class="post-time">2021-12-15</div></div></div><div class="container post-header"><h1>2</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%86%85%E4%B8%AD%E6%96%AD"><span class="toc-number">1.</span> <span class="toc-text">第12章 内中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">1.1.</span> <span class="toc-text">内中断的产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">中断类型码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">中断处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">中断向量表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">中断过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%92%8Ciret%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.</span> <span class="toc-text">中断处理程序和iret指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%A4%84%E7%90%860%E5%8F%B7%E4%B8%AD%E6%96%AD"><span class="toc-number">1.7.</span> <span class="toc-text">编程处理0号中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.8.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do0"><span class="toc-number">1.9.</span> <span class="toc-text">do0</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="第12章-内中断"><a href="#第12章-内中断" class="headerlink" title="第12章 内中断"></a>第12章 内中断</h1><ul>
<li>任何一个通用的CPU都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。</li>
<li>这种特殊的信息，我们可以称其为：<code>中断信息</code>。中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。</li>
</ul>
<h2 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h2><p>内中断主要有四种：</p>
<ul>
<li>除法错误，比如，执行div指令产生的除法溢出</li>
<li>单步执行</li>
<li>执行into 指令</li>
<li>执行int 指令</li>
</ul>
<h2 id="中断类型码"><a href="#中断类型码" class="headerlink" title="中断类型码"></a>中断类型码</h2><ul>
<li>对于不同的中断需要进行不同处理。要进行不同的处理，CPU首先要知道，所接收到的中断信息的来源（简称为<code>中断源</code>）。所以中断信息中必须包含识别来源的编码。8086CPU用称为<code>中断类型码</code>的数据来标识中断信息的来源。</li>
<li>中断类型码识别为<strong>一个字节</strong>型数据，可以表示256种中断信息的来源。</li>
<li>中断类型如下：<ul>
<li>除法错误：0</li>
<li>单步执行：1</li>
<li>执行into指令：4</li>
<li>执行int指令，该指令的格式为 int n，指令中的n位字节型立即数，是提供给CPU的中断类型码</li>
</ul>
</li>
</ul>
<h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><ul>
<li>CPU收到中断信息后，需要对中断信息进行处理。而如何对中断信息进行处理，可以由我们编程决定。我们编写的，用来处理中断信息的程序被称为<code>中断处理程序</code>。</li>
<li>CPU在收到中断信息后，应该转去执行该中断信息的处理程序。若要8086CPU执行某处的程序，就要将CS：IP指向它的入口（即程序第一条指令的地址）。CPU在接收到中断信息后，如何根据中断信息确定其处理程序的入口。</li>
<li>所以必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。</li>
<li><strong>中断类型码的作用就是用来定位中断处理程序</strong>。比如CPU根据中断类型码4，就可以找到4号中断的处理程序。</li>
<li>可随之而来的问题是：若要定位中断处理程序，需要知道它的段地址和偏移地址，而如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢，这时需要使用到<code>中断向量表</code></li>
</ul>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><ul>
<li>中断向量：就是<strong>中断处理程序的入口地址</strong>。</li>
<li>中断向量表：就是中断处理程序入口地址的列表。</li>
<li>CPU用中断类型码，通过查找中断向量表，就可以得到中断处理程序的入口地址。</li>
<li>中断向量表在内存中存放，对于8086PC机，中断向量表指定<strong>放在内存地址0处</strong>。从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。</li>
<li>在中断向量表中，一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU，这个入口地址<strong>包括段地址和偏移地址</strong>，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</li>
</ul>
<p><img src="/images/image-20211215132012759.png" alt="image-20211215132012759"></p>
<p>用debug查看内存，情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000:0000 68 10 A7 00 8B 01 70 00-16 00 9D 03 8B 01 70 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0号：00A7：1068</span><br><span class="line">1号：0070：108B</span><br><span class="line">2号：039D：0016</span><br><span class="line">3号：0070：108B</span><br></pre></td></tr></table></figure>



<h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><ul>
<li>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为<code>中断过程</code>。</li>
<li>8086CPU在收到中断信息后，所引发的中断过程：<ol>
<li>(从中断信息中)取得中断类型码；</li>
<li>标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)；</li>
<li>设置标志寄存器的第8位TF和第9位IF的值为0；</li>
<li>CS的内容入栈；</li>
<li>IP的内容入栈；</li>
<li>从内存地址为 <code>中断类型码×4</code> 和 <code>中断类型码×4+2</code> 的两个字单元中读取中断处理程序的入口地址设置IP和CS。</li>
</ol>
</li>
<li>我们更简洁地描述中断过程，如下：<ol>
<li>取得中断类型码N；</li>
<li>pushf</li>
<li>TF=0，IF=0</li>
<li>push CS</li>
<li>push IP</li>
<li><code>(IP)=(N*4)，(CS)=(N*4+2)</code></li>
</ol>
</li>
</ul>
<blockquote>
<p>CPU现场：某一时刻，CPU中各个寄存器的值。</p>
</blockquote>
<h2 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h2><p>由于CPU随时都可能检测到中断信息，也就是说CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p>
<p>中断处理程序的编写方法<strong>和子程序的相似</strong>，下面是常规的步骤：</p>
<ol>
<li>保存用到的寄存器；</li>
<li>处理中断；</li>
<li>恢复用到的寄存器；</li>
<li>用iret指令返回。</li>
</ol>
<p>iret（<code>interrupt return</code>）指令的功能用汇编语法描述为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>

<ul>
<li>iret通常和硬件自动完成的中断过程配合使用。</li>
<li>在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其相对应。</li>
</ul>
<h2 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h2><ul>
<li>0号中断，即除法错误中断的处理。</li>
<li>当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。</li>
<li>现在希望重新编写一个0号中断处理程序，它的功能是在屏幕中间显示“overflow!”，然后返回到操作系统</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000h</span><br><span class="line">mov bh,1</span><br><span class="line">div bh</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211215191044028.png" alt="image-20211215191044028"></p>
<p>当发生除法溢出的时候，产生0号中断信息，从而引发中断过程。</p>
<p>此时，CPU将进行以下工作。</p>
<ol>
<li>取得中断类型码0</li>
<li>标志寄存器入栈，TF、圧设置为0</li>
<li>CS、IP入栈</li>
<li>(IP)=(0x4)，(CS)=(0x4+2)</li>
</ol>
<p>当中断0发生时，CPU将转去执行中断处理程序。</p>
<ol>
<li>相关处理</li>
<li>向显示缓冲区送字符串“overflow!”</li>
<li>返回DOS</li>
</ol>
<p>我们暂时将这段程序称为：do0，我们可以将do0的代码放在内存0000:0200处。若要使得除法溢岀发生的时候，CPU转去执行do0，则必须将do0的入口地址，即0000:0200登记在中断向量表的对应表项中。</p>
<p>所以，我们要做以下几件事情：</p>
<ol>
<li>编写可以显示“overflow!”的中断处理程序：do0；</li>
<li>将do0送入内存0000:0200处；</li>
<li>将do0的入口地址0000:0200存储在中断向量表0号表项中。</li>
</ol>
<p>所以，程序的框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  do0安装程序</span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">        </span><br><span class="line"> do0:   显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面代码执行时，do0的代码是不执行的，它只是作为do0安装程序所要传送的数据。程序执行时：</p>
<ol>
<li>首先执行do0安装程序：<strong>将do0的代码复制到内存0:200处，</strong></li>
<li>然后设置中断向量表：<strong>将do0的入口地址，即偏移地址200H和段地址0，保存在0号表项中。</strong></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以使用movsb指令，将do0的代码送入0:200处。</p>
<p>框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  设置es:di指向目的地址</span><br><span class="line">        设置ds:si指向源地址</span><br><span class="line">        设置cx为传输长度</span><br><span class="line">        设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    do0:显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0       ;设置ds:si指向源地址</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h     ;设置es :di指向目的地址</span><br><span class="line"></span><br><span class="line">        mov cx,offset do0end-offset do0     ;设置cx为传输长度</span><br><span class="line"></span><br><span class="line">        cld     ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">   do0 :显示字符串&quot;overflow!”</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0end:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-</code> 是编译器识别的运算符号，编译器可以用它来进行两个常数的减法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8-4 ; 等同于 mov ax,4</span><br><span class="line">mov ax,(5+3)x5/10 ; 等同于 mov ax,4</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h2><p>do0程序的主要任务是显示字符串，程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">do0:   设置ds:si指向字符串</span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,12*160+36*2      ;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">        mov cx,9        ;设置cx为字符串长度</span><br><span class="line"></span><br><span class="line">s:      mov al,[si]</span><br><span class="line">        mov es:[di],al</span><br><span class="line">        inc si</span><br><span class="line">        add di,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0end:	nop</span><br></pre></td></tr></table></figure>



<p>所以，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0  ;设置ds:si指向源地址</span><br><span class="line">        </span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h     ;设置es:di指向目的地址</span><br><span class="line">        </span><br><span class="line">        mov cx,offset do0end-offset do0    ;设置cx为传输长度 </span><br><span class="line">        cld             ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line">        </span><br><span class="line">        设置中断向量表</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0:    jmp short do0start</span><br><span class="line">        db &quot;overflow!&quot;  ;将“overflow!”放到do0程序中</span><br><span class="line"></span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,202h     ;设置ds:si指向字符串</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,12*160+36*2      ;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">        mov cx,9        ;设置cx为字符串长度</span><br><span class="line"></span><br><span class="line">    s:  mov al,[si]</span><br><span class="line">        mov es:[di],al</span><br><span class="line">        inc si</span><br><span class="line">        add di,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，因为在<strong>do0程序开始处的“overflow!”不是可以执行的代码</strong>，所以在“overflow!”之前加上一条jmp指令，转移到正式的do0程序。当除法溢出发生时，CPU执行0:200处的jmp指令，跳过后面的字符串，转到正式的do0程序执行。</p>
<p>do0程序执行过程中必须要找到“overflow!”，那么它在哪里呢？</p>
<p>首先来看段地址，“overflow!”和do0的代码处于同一个段中，而除法溢出发生时，CS中必然存放do0的段地址，也就是”overflow!”的段地址；再来看偏移地址，0:200处的指令为jmp short do0start，这条指令占两个字节，所以”overflow!”的偏移地址为202h。</p>
</blockquote>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>