<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Python中的select模块专注于I/O多路复用，提供了select，poll，epoll三个方法(其中后两个在Linux中可用，windows仅支持select)，另外也提供了kqueue方法(freeBSD系统)"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>select | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2021-06-08</div></div></div><div class="container post-header"><h1>select</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">select方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">epoll方法</span></a></li></ol></details></div><div class="container post-content"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Python中的select模块专注于I/O多路复用，提供了select，poll，epoll三个方法(其中后两个在Linux中可用，windows仅支持select)，另外也提供了kqueue方法(freeBSD系统)</p>
<h2 id="select方法"><a href="#select方法" class="headerlink" title="select方法"></a>select方法</h2><p>进程指定内核监听哪些文件描述符(最多监听1024个fd)的哪些事件，当没有文件描述符事件发生时，进程被阻塞；当一个或者多个文件描述符事件发生时，进程被唤醒。</p>
<blockquote>
<p>fd：file descriptor 文件描述符</p>
</blockquote>
<p>当我们调用select()时：</p>
<ol>
<li>上下文切换转换为内核态</li>
<li>将fd从<code>用户空间</code>复制到<code>内核空间</code></li>
<li>内核遍历所有fd，查看其对应事件是否发生</li>
<li>如果没发生，将进程阻塞，当设备驱动产生中断或者timeout时间后，将进程唤醒，再次进行遍历</li>
<li>返回遍历后的fd</li>
<li>将fd从内核空间复制到用户空间</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd_r_list, fd_w_list, fd_e_list = select.select(rlist, wlist, xlist, [timeout])</span><br></pre></td></tr></table></figure>

<p>参数： 可接受四个参数（前三个必须）</p>
<ul>
<li>rlist: wait until ready for reading</li>
<li>wlist: wait until ready for writing</li>
<li>xlist: wait for an “exceptional condition”</li>
<li>timeout: 超时时间</li>
</ul>
<p>返回值：三个列表：</p>
<p>select方法用来监视文件描述符(当文件描述符条件不满足时，select会阻塞)，当某个文件描述符状态改变后，会返回三个列表</p>
<ul>
<li>当参数1序列中的fd满足“可读”条件时，则获取发生变化的fd并添加到fd_r_list中</li>
<li>当参数2序列中含有fd时，则将该序列中所有的fd添加到 fd_w_list中</li>
<li>当参数3序列中的fd发生错误时，则将该发生错误的fd添加到 fd_e_list中</li>
<li>当超时时间为空，则select会一直阻塞，直到监听的句柄发生变化。当超时时间 ＝ n(正整数)时，那么如果监听的句柄均无任何变化，则select会阻塞n秒，之后返回三个空列表，如果监听的句柄有变化，则直接执行。</li>
</ul>
<p>实例：利用select实现一个可并发的服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">s = socket.socket()</span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8888</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">r_list = [s,]</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rl, wl, error = select.select(r_list,[],[],<span class="number">10</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;counts is %s&#x27;</span> %num)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;rl&#x27;s length is %s&quot;</span> %<span class="built_in">len</span>(rl))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> fd <span class="keyword">in</span> rl:</span><br><span class="line">        <span class="keyword">if</span> fd == s:</span><br><span class="line">            conn, addr = fd.accept()</span><br><span class="line">            r_list.append(conn)</span><br><span class="line">            msg = conn.recv(<span class="number">200</span>)</span><br><span class="line">            conn.sendall((<span class="string">&#x27;first----%s&#x27;</span>%conn.fileno()).encode())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                msg = fd.recv(<span class="number">200</span>)</span><br><span class="line">                fd.sendall(<span class="string">&#x27;second&#x27;</span>.encode())</span><br><span class="line">            <span class="keyword">except</span> ConnectionAbortedError:</span><br><span class="line">                r_list.remove(fd)</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line">s = socket.socket()</span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    input_msg = <span class="built_in">input</span>(<span class="string">&#x27;input&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> input_msg == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    s.sendall(input_msg.encode())</span><br><span class="line">    msg = s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(msg.decode())</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>在服务端我们可以看到，我们不停的调用select， 这就意味着：</p>
<ol>
<li>当文件描述符过多时，文件描述符在用户空间与内核空间进行copy会很费时</li>
<li>当文件描述符过多时，内核对文件描述符的遍历也很浪费时间</li>
<li>select最大仅仅支持1024个文件描述符</li>
</ol>
<p>poll与select相差不大，本文不作介绍</p>
<h2 id="epoll方法"><a href="#epoll方法" class="headerlink" title="epoll方法"></a>epoll方法</h2><p>epoll很好的改进了select：</p>
<ol>
<li>epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时，会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</li>
<li>epoll会在epoll_ctl时把指定的fd遍历一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd</li>
<li>epoll对文件描述符没有额外限制</li>
</ol>
<p>select.epoll(sizehint=-1, flags=0) 创建epoll对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">epoll.close()</span><br><span class="line">Close the control file descriptor of the epoll object.关闭epoll对象的文件描述符</span><br><span class="line"></span><br><span class="line">epoll.closed</span><br><span class="line">True if the epoll object is closed.检测epoll对象是否关闭</span><br><span class="line"></span><br><span class="line">epoll.fileno()</span><br><span class="line">Return the file descriptor number of the control fd.返回epoll对象的文件描述符</span><br><span class="line"></span><br><span class="line">epoll.fromfd(fd)</span><br><span class="line">Create an epoll object from a given file descriptor.根据指定的fd创建epoll对象</span><br><span class="line"></span><br><span class="line">epoll.register(fd[, eventmask])</span><br><span class="line">Register a fd descriptor with the epoll object.向epoll对象中注册fd和对应的事件</span><br><span class="line"></span><br><span class="line">epoll.modify(fd, eventmask)</span><br><span class="line">Modify a registered file descriptor.修改fd的事件</span><br><span class="line"></span><br><span class="line">epoll.unregister(fd)</span><br><span class="line">Remove a registered file descriptor from the epoll object.取消注册</span><br><span class="line"></span><br><span class="line">epoll.poll(timeout=-1, maxevents=-1)</span><br><span class="line">Wait for events. timeout in seconds (float)阻塞，直到注册的fd事件发生,会返回一个dict，格式为：&#123;(fd1,event1),(fd2,event2),……(fdn,eventn)&#125;</span><br></pre></td></tr></table></figure>

<p>事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN    Available for read 可读   状态符为1</span><br><span class="line">EPOLLOUT    Available for write 可写  状态符为4</span><br><span class="line">EPOLLPRI    Urgent data for read</span><br><span class="line">EPOLLERR    Error condition happened on the assoc. fd 发生错误 状态符为8</span><br><span class="line">EPOLLHUP    Hang up happened on the assoc. fd 挂起状态</span><br><span class="line">EPOLLET    Set Edge Trigger behavior, the default is Level Trigger behavior 默认为水平触发，设置该事件后则边缘触发</span><br><span class="line">EPOLLONESHOT    Set one-shot behavior. After one event is pulled out, the fd is internally disabled</span><br><span class="line">EPOLLRDNORM    Equivalent to EPOLLIN</span><br><span class="line">EPOLLRDBAND    Priority data band can be read.</span><br><span class="line">EPOLLWRNORM    Equivalent to EPOLLOUT</span><br><span class="line">EPOLLWRBAND    Priority data may be written.</span><br><span class="line">EPOLLMSG    Ignored.</span><br></pre></td></tr></table></figure>

<p>水平触发和边缘触发：</p>
<p>Level_triggered(水平触发，有时也称条件触发)：当被监控的文件描述符上有可读写事件发生时，epoll.poll()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll.poll()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！ 优点很明显：稳定可靠</p>
<p>Edge_triggered(边缘触发，有时也称状态触发)：当被监控的文件描述符上有可读写事件发生时，epoll.poll()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll.poll()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！缺点：某些条件下不可靠</p>
<p>epoll实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">s = socket.socket()</span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8888</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line">epoll_obj = select.epoll()</span><br><span class="line">epoll_obj.register(s,select.EPOLLIN)</span><br><span class="line">connections = &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events = epoll_obj.poll()</span><br><span class="line">    <span class="keyword">for</span> fd, event <span class="keyword">in</span> events:</span><br><span class="line">        <span class="built_in">print</span>(fd,event)</span><br><span class="line">        <span class="keyword">if</span> fd == s.fileno():</span><br><span class="line">            conn, addr = s.accept()</span><br><span class="line">            connections[conn.fileno()] = conn</span><br><span class="line">            epoll_obj.register(conn,select.EPOLLIN)</span><br><span class="line">            msg = conn.recv(<span class="number">200</span>)</span><br><span class="line">            conn.sendall(<span class="string">&#x27;ok&#x27;</span>.encode())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                fd_obj = connections[fd]</span><br><span class="line">                msg = fd_obj.recv(<span class="number">200</span>)</span><br><span class="line">                fd_obj.sendall(<span class="string">&#x27;ok&#x27;</span>.encode())</span><br><span class="line">            <span class="keyword">except</span> BrokenPipeError:</span><br><span class="line">                epoll_obj.unregister(fd)</span><br><span class="line">                connections[fd].close()</span><br><span class="line">                <span class="keyword">del</span> connections[fd]</span><br><span class="line"></span><br><span class="line">s.close()</span><br><span class="line">epoll_obj.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line">s = socket.socket()</span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8888</span>))</span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    input_msg = <span class="built_in">input</span>(<span class="string">&#x27;input&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> input_msg == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    s.sendall(input_msg.encode())</span><br><span class="line">    msg = s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(msg.decode())</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>