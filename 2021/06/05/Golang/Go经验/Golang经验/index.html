<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;go中填充定长arr&quot;&gt;&lt;a href=&quot;#go中填充定长arr&quot; class=&quot;headerlink&quot; title=&quot;go中填充定长arr&quot;&gt;&lt;/a&gt;go中填充定长arr&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;result := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([][]UserDomain, &lt;span class=&quot;built_in&quot;&gt;len&lt;/span&gt;(args))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i, _ := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; args &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   result[i] = uds&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&quot;gorp的update语句&quot;&gt;&lt;a href=&quot;#gorp的update语句&quot; class=&quot;headerlink&quot; title=&quot;gorp的update语句&quot;&gt;&lt;/a&gt;gorp的update语句&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UpdateWebhook&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(src gorp.SqlExecutor, item *WebHook)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; item == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; build strings.Builder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; args []&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	build.WriteString(&lt;span class=&quot;string&quot;&gt;&amp;quot;UPDATE webhook SET &amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !utils.IsEmptyString(item.Name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		build.WriteString(&lt;span class=&quot;string&quot;&gt;&amp;quot;`name`=?, &amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		args = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(args, item.Name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !utils.IsEmptyString(item.URL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		build.WriteString(&lt;span class=&quot;string&quot;&gt;&amp;quot;`url`=?, &amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		args = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(args, item.URL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; item.IsBatch != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		build.WriteString(&lt;span class=&quot;string&quot;&gt;&amp;quot;`is_batch`=?, &amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		args = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(args, item.IsBatch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; item.BatchCount != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		build.WriteString(&lt;span class=&quot;string&quot;&gt;&amp;quot;`batch_count`=?, &amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		args = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(args, item.BatchCount)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; item.Status != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		build.WriteString(&lt;span class=&quot;string&quot;&gt;&amp;quot;`status`=?, &amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		args = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(args, item.Status)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	build.WriteString(fmt.Sprintf(&lt;span class=&quot;string&quot;&gt;&amp;quot;`update_time`=? WHERE uuid=&amp;#x27;%s&amp;#x27;;&amp;quot;&lt;/span&gt;, item.UUID))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	args = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(args, time.Now().Unix())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_, err := src.Exec(build.String(), args...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;gorp的事务"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Golang经验 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-06-05</div></div></div><div class="container post-header"><h1>Golang经验</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E4%B8%AD%E5%A1%AB%E5%85%85%E5%AE%9A%E9%95%BFarr"><span class="toc-number">1.</span> <span class="toc-text">go中填充定长arr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gorp%E7%9A%84update%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">gorp的update语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">3.</span> <span class="toc-text">go的相对路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E4%B8%8D%E8%83%BD%E8%B7%A8%E5%8C%85%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">Go不能跨包写方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">new和make的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.</span> <span class="toc-text">变量生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%BB%E6%84%8F%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">刻意区分类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%98%AF%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E8%BF%9B%E8%A1%8C%E7%9A%84"><span class="toc-number">8.</span> <span class="toc-text">包的初始化是自下而上进行的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E4%B8%8D%E9%81%B5%E5%AE%88python%E7%9A%84LEGB%E5%8E%9F%E5%88%99"><span class="toc-number">9.</span> <span class="toc-text">go不遵守python的LEGB原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-mod"><span class="toc-number">10.</span> <span class="toc-text">go mod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Mutex-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">sync.Mutex 互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#time-format"><span class="toc-number">12.</span> <span class="toc-text">time.format</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#limit-offset%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">limit,offset的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BuildSqlArgs"><span class="toc-number">14.</span> <span class="toc-text">BuildSqlArgs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#golang%E7%9A%84%E7%BB%A7%E6%89%BF%E5%A4%8D%E7%94%A8"><span class="toc-number">15.</span> <span class="toc-text">golang的继承复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slice-append%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8var"><span class="toc-number">16.</span> <span class="toc-text">slice append避免使用var</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6-struct-pointer"><span class="toc-number">17.</span> <span class="toc-text">复制 struct pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87reflect%E8%8E%B7%E5%8F%96structName%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD"><span class="toc-number">18.</span> <span class="toc-text">通过reflect获取structName来进行判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%8A%BD%E5%87%BA%E4%B8%80%E5%B1%82%E6%9D%A5%E8%A7%A3%E5%86%B3%E6%89%80%E5%B1%9E%E4%B8%8D%E6%B8%85%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">19.</span> <span class="toc-text">通过抽出一层来解决所属不清的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E4%BC%BC%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">20.</span> <span class="toc-text">使用类似继承的机制来实现接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A5%E9%94%99exit-status-1"><span class="toc-number">21.</span> <span class="toc-text">报错exit status 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84-channel-%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8F%AA%E8%A6%81-receiver-%E5%87%86%E5%A4%87%E5%A5%BD%E4%BA%86%E5%B0%B1%E4%BC%9A%E7%AB%8B%E5%88%BB%E8%BF%94%E5%9B%9E"><span class="toc-number">22.</span> <span class="toc-text">向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-range-%E8%BF%AD%E4%BB%A3-slice%E3%80%81array%E3%80%81map-%E6%97%B6%E9%80%9A%E8%BF%87%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8%E6%9D%A5%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0"><span class="toc-number">23.</span> <span class="toc-text">在 range 迭代 slice、array、map 时通过更新引用来更新元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="toc-number">24.</span> <span class="toc-text">defer 函数的执行时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E5%BF%AB%E7%85%A7%E9%97%AE%E9%A2%98"><span class="toc-number">25.</span> <span class="toc-text">匿名函数中的循环变量快照问题</span></a></li></ol></details></div><div class="container post-content"><h2 id="go中填充定长arr"><a href="#go中填充定长arr" class="headerlink" title="go中填充定长arr"></a>go中填充定长arr</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result := <span class="built_in">make</span>([][]UserDomain, <span class="built_in">len</span>(args))</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> args &#123;</span><br><span class="line">   result[i] = uds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="gorp的update语句"><a href="#gorp的update语句" class="headerlink" title="gorp的update语句"></a>gorp的update语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateWebhook</span><span class="params">(src gorp.SqlExecutor, item *WebHook)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> build strings.Builder</span><br><span class="line">	<span class="keyword">var</span> args []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	build.WriteString(<span class="string">&quot;UPDATE webhook SET &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> !utils.IsEmptyString(item.Name) &#123;</span><br><span class="line">		build.WriteString(<span class="string">&quot;`name`=?, &quot;</span>)</span><br><span class="line">		args = <span class="built_in">append</span>(args, item.Name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !utils.IsEmptyString(item.URL) &#123;</span><br><span class="line">		build.WriteString(<span class="string">&quot;`url`=?, &quot;</span>)</span><br><span class="line">		args = <span class="built_in">append</span>(args, item.URL)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> item.IsBatch != <span class="number">0</span> &#123;</span><br><span class="line">		build.WriteString(<span class="string">&quot;`is_batch`=?, &quot;</span>)</span><br><span class="line">		args = <span class="built_in">append</span>(args, item.IsBatch)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> item.BatchCount != <span class="number">0</span> &#123;</span><br><span class="line">		build.WriteString(<span class="string">&quot;`batch_count`=?, &quot;</span>)</span><br><span class="line">		args = <span class="built_in">append</span>(args, item.BatchCount)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> item.Status != <span class="number">0</span> &#123;</span><br><span class="line">		build.WriteString(<span class="string">&quot;`status`=?, &quot;</span>)</span><br><span class="line">		args = <span class="built_in">append</span>(args, item.Status)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	build.WriteString(fmt.Sprintf(<span class="string">&quot;`update_time`=? WHERE uuid=&#x27;%s&#x27;;&quot;</span>, item.UUID))</span><br><span class="line">	args = <span class="built_in">append</span>(args, time.Now().Unix())</span><br><span class="line">	_, err := src.Exec(build.String(), args...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>gorp的事务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DBMTransact</span><span class="params">(src *gorp.DbMap, txFunc <span class="keyword">func</span>(*gorp.Transaction)</span> <span class="title">error</span>) <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	tx, err := src.Begin()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = errors.Sql(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">&quot;%s: %s&quot;</span>, p, debug.Stack())</span><br><span class="line">			<span class="keyword">switch</span> p := p.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> error:</span><br><span class="line">				err = p</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				err = fmt.Errorf(<span class="string">&quot;%s&quot;</span>, p)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			tx.Rollback()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		err = errors.Sql(tx.Commit())</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> txFunc(tx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="go的相对路径"><a href="#go的相对路径" class="headerlink" title="go的相对路径"></a>go的相对路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go_test</span><br><span class="line">	|-- mymod</span><br><span class="line">	|     |-- qweqe.txt</span><br><span class="line">	|--aaa.go</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := <span class="string">&quot;/Users/heyingliang/go/src/go_test/mymod/qweqe.txt&quot;</span></span><br><span class="line">	p2 := <span class="string">&quot;./mymod/qweqe.txt&quot;</span></span><br><span class="line">	p3 := <span class="string">&quot;mymod/qweqe.txt&quot;</span></span><br><span class="line">	f1, err := os.Open(p1)</span><br><span class="line">	f2, err := os.Open(p2)</span><br><span class="line">	f3, err := os.Open(p3)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>,  err)</span><br><span class="line">	&#125;</span><br><span class="line">	Print(f1) <span class="comment">// *os.File -&gt; &amp;&#123;0xc000044180&#125;</span></span><br><span class="line">	Print(f2) <span class="comment">// *os.File -&gt; &amp;&#123;0xc000044180&#125;</span></span><br><span class="line">	Print(f3) <span class="comment">// *os.File -&gt; &amp;&#123;0xc000044180&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>./ 是你当前的project目录(即go_test)</li>
<li><code>mymod/qweqe.txt</code>就是<code>./mymod/qweqe.txt</code></li>
</ul>
<h2 id="Go不能跨包写方法"><a href="#Go不能跨包写方法" class="headerlink" title="Go不能跨包写方法"></a>Go不能跨包写方法</h2><p>新建a和b两个文件夹.再分别新建2个文件a.go , b.go</p>
<p>a/a.go</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package a</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Student</span></span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Name <span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b/b.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> b </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s a.Student)</span> <span class="title">Show</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(s.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.go</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    student := <span class="built_in">new</span>(a.Student)</span><br><span class="line">    student.Name = <span class="string">&quot;百里&quot;</span></span><br><span class="line">    student.<span class="built_in">Show</span>() // (<span class="number">1</span>) 会报错的.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>new(T) 返回的是 T 的指针：</p>
<p>new(T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T，该指针指向 T 的新分配的零值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p1 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;p1 --&gt; %#v \n &quot;</span>, p1) <span class="comment">//(*int)(0xc42000e250) </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p1 point to --&gt; %#v \n &quot;</span>, *p1) <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 *<span class="keyword">int</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">p2 = &amp;i</span><br><span class="line">fmt.Printf(<span class="string">&quot;p2 --&gt; %#v \n &quot;</span>, p2) <span class="comment">//(*int)(0xc42000e278) </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2 point to --&gt; %#v \n &quot;</span>, *p2) <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是说：下面两者等价</span></span><br><span class="line">p1 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> p2 *<span class="keyword">int</span></span><br></pre></td></tr></table></figure></li>
<li><p>make 只能用于 slice,map,channel：</p>
<p>**make(T, args) 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用**。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> s1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s1 is nil --&gt; %#v \n &quot;</span>, s1) <span class="comment">// []int(nil)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> s2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s2 is nil --&gt; %#v \n &quot;</span>, s2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s2 is not nill --&gt; %#v \n &quot;</span>, s2)<span class="comment">// []int&#123;0, 0, 0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slice 的零值是 nil，使用 make 之后 slice 是一个初始化的 slice，即 slice 的长度、容量、底层指向的 array 都被 make 完成初始化，此时 slice 内容被类型 int 的零值填充，形式是 [0 0 0]，map 和 channel 也是类似的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> m1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;m1 is nil --&gt; %#v \n &quot;</span>, m1) <span class="comment">//map[int]string(nil)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> m2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;m2 is nil --&gt; %#v \n &quot;</span>, m2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;m2 is not nill --&gt; %#v \n &quot;</span>, m2) <span class="comment">//map[int]string&#123;&#125; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> c1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;c1 is nil --&gt; %#v \n &quot;</span>, c1) <span class="comment">//(chan string)(nil)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> c2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;c2 is nil --&gt; %#v \n &quot;</span>, c2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;c2 is not nill --&gt; %#v \n &quot;</span>, c2)<span class="comment">//(chan string)(0xc420016120)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h2><p>对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。</p>
<h2 id="刻意区分类型"><a href="#刻意区分类型" class="headerlink" title="刻意区分类型"></a>刻意区分类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AbsoluteZeroC Celsius = <span class="number">-273.15</span></span><br><span class="line">	FreezingC     Celsius = <span class="number">0</span></span><br><span class="line">	BoilingC      Celsius = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span> <span class="title">Fahrenheit</span></span> &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span> <span class="title">Celsius</span></span> &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>) &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似**Celsius(t)<strong>或</strong>Fahrenheit(t)**形式的显式转型操作才能将float64转为对应的类型。</li>
<li>Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。<strong>类型转换不会改变值本身，但是会使它们的语义发生变化</strong>。</li>
</ul>
<h2 id="包的初始化是自下而上进行的"><a href="#包的初始化是自下而上进行的" class="headerlink" title="包的初始化是自下而上进行的"></a>包的初始化是自下而上进行的</h2><p>GO的<code>包的初始化</code>工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之<br>前，所有依然的包都已经完成初始化工作了。</p>
<h2 id="go不遵守python的LEGB原则"><a href="#go不遵守python的LEGB原则" class="headerlink" title="go不遵守python的LEGB原则"></a>go不遵守python的LEGB原则</h2><ul>
<li>python的LEGB是：内层变量只能读取，不能改变外层变量</li>
<li>但是go允许内层变量修改外穿变量的值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> char = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	char = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(char) <span class="comment">// 1</span></span><br><span class="line">	myfunc()</span><br><span class="line">	fmt.Println(char) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><p>如果出现<code>go mod download</code>失败，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.io</span><br></pre></td></tr></table></figure>

<p>之后再执行<code>go mod download</code></p>
<h2 id="sync-Mutex-互斥锁"><a href="#sync-Mutex-互斥锁" class="headerlink" title="sync.Mutex 互斥锁"></a>sync.Mutex 互斥锁</h2><ul>
<li>Mutex 类型的锁和线程无关，可以由不同的线程加锁和解锁。</li>
<li>在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex</li>
<li>使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁</li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁</li>
<li>在<strong>同一个 goroutine 中</strong>的 Mutex 解锁之前再次进行加锁，会导致死锁</li>
<li>适用于读写不确定，并且只有一个读或者写的场景</li>
</ul>
<h2 id="time-format"><a href="#time-format" class="headerlink" title="time.format"></a>time.format</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parserTimeStr</span><span class="params">(stringTime <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line">	loc, _ := time.LoadLocation(<span class="string">&quot;Local&quot;</span>)</span><br><span class="line">	formats := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;2006-01-02&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006-01-02 15:04&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006-01-02 15:04:05&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006-1-2&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006-1-02&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006-01-2&quot;</span>,</span><br><span class="line"></span><br><span class="line">		<span class="string">&quot;01/02/2006&quot;</span>,</span><br><span class="line">		<span class="string">&quot;1/02/2006&quot;</span>,</span><br><span class="line">		<span class="string">&quot;01/2/2006&quot;</span>,</span><br><span class="line">		<span class="string">&quot;1/2/2006&quot;</span>,</span><br><span class="line">		<span class="string">&quot;01/02/2006 15:04&quot;</span>,</span><br><span class="line">		<span class="string">&quot;1/02/2006 15:04&quot;</span>,</span><br><span class="line">		<span class="string">&quot;01/2/2006 15:04&quot;</span>,</span><br><span class="line">		<span class="string">&quot;1/2/2006 15:04&quot;</span>,</span><br><span class="line">		<span class="string">&quot;01/02/2006 15:04:05&quot;</span>,</span><br><span class="line">		<span class="string">&quot;1/02/2006 15:04:05&quot;</span>,</span><br><span class="line">		<span class="string">&quot;01/2/2006 15:04:05&quot;</span>,</span><br><span class="line">		<span class="string">&quot;1/2/2006 15:04:05&quot;</span>,</span><br><span class="line"></span><br><span class="line">		<span class="string">&quot;2006/01/02&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/1/02&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/01/2&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/1/2&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/01/02 15:04&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/1/02 15:04&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/01/2 15:04&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/1/2 15:04&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/01/02 15:04:05&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/1/02 15:04:05&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/01/2 15:04:05&quot;</span>,</span><br><span class="line">		<span class="string">&quot;2006/1/2 15:04:05&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, format := <span class="keyword">range</span> formats &#123;</span><br><span class="line">		t, err := time.ParseInLocation(format, stringTime, loc)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> t.Unix(), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;parse time error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="limit-offset的常用方法"><a href="#limit-offset的常用方法" class="headerlink" title="limit,offset的常用方法"></a>limit,offset的常用方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	Since <span class="keyword">int</span></span><br><span class="line">	End   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultBlockSize = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlocks</span><span class="params">(length <span class="keyword">int</span>, blockSize <span class="keyword">int</span>)</span> <span class="title">Blocks</span></span> &#123;</span><br><span class="line">	blocks := []*Block&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> blockSize &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> blocks</span><br><span class="line">	&#125;</span><br><span class="line">	since := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; &#123;</span><br><span class="line">		i += blockSize</span><br><span class="line">		<span class="keyword">if</span> i &gt; length &#123;</span><br><span class="line">			i = length</span><br><span class="line">		&#125;</span><br><span class="line">		blocks = <span class="built_in">append</span>(blocks, &amp;Block&#123;Since: since, End: i&#125;)</span><br><span class="line">		since = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> blocks</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">Range</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.End - b.Since</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultBlocks</span><span class="params">(length <span class="keyword">int</span>)</span> []*<span class="title">Block</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewBlocks(length, DefaultBlockSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blocks []*Block</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Blocks)</span> <span class="title">Each</span><span class="params">(f <span class="keyword">func</span>(block *Block)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">		err := f(b[i])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sqlSample := <span class="string">&quot;SELECT %s FROM activity WHERE team_uuid=? AND related_ppm_task_uuid IN (%s) AND status=?;&quot;</span></span><br><span class="line">blocks := utilsModel.NewBlocks(length, defaultBlockSize)</span><br><span class="line"><span class="keyword">for</span> _, block := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">	subPPMTaskUUIDs := ppmTaskUUIDs[block.Since:block.End]</span><br><span class="line">	sql := fmt.Sprintf(sqlSample, activityColumnsStr, utilsModel.SqlPlaceholds(<span class="built_in">len</span>(subPPMTaskUUIDs)))</span><br><span class="line">	activities := <span class="built_in">make</span>([]*Activity, <span class="number">0</span>)</span><br><span class="line">	args, _ := utilsModel.BuildSqlArgs(teamUUID, subPPMTaskUUIDs, ActivityNormal)</span><br><span class="line">	_, err := src.Select(&amp;activities, sql, args...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Sql(err)</span><br><span class="line">	&#125;</span><br><span class="line">	results = <span class="built_in">append</span>(results, activities...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BuildSqlArgs"><a href="#BuildSqlArgs" class="headerlink" title="BuildSqlArgs"></a>BuildSqlArgs</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildSqlArgs</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	newArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">	addEleFun := <span class="function"><span class="keyword">func</span><span class="params">(ele <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		newArgs = <span class="built_in">append</span>(newArgs, ele)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">		<span class="keyword">switch</span> v := arg.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">string</span>, <span class="keyword">int</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>, <span class="keyword">bool</span>, *<span class="keyword">string</span>, *<span class="keyword">int</span>, *<span class="keyword">int32</span>, *<span class="keyword">int64</span>, time.Time:</span><br><span class="line">			addEleFun(v)</span><br><span class="line">		<span class="keyword">case</span> []<span class="keyword">string</span>:</span><br><span class="line">			<span class="keyword">for</span> _, e := <span class="keyword">range</span> v &#123;</span><br><span class="line">				addEleFun(e)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> []<span class="keyword">int</span>:</span><br><span class="line">			<span class="keyword">for</span> _, e := <span class="keyword">range</span> v &#123;</span><br><span class="line">				addEleFun(e)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> []<span class="keyword">int32</span>:</span><br><span class="line">			<span class="keyword">for</span> _, e := <span class="keyword">range</span> v &#123;</span><br><span class="line">				addEleFun(e)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> []<span class="keyword">int64</span>:</span><br><span class="line">			<span class="keyword">for</span> _, e := <span class="keyword">range</span> v &#123;</span><br><span class="line">				addEleFun(e)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> []*<span class="keyword">string</span>:</span><br><span class="line">			<span class="keyword">for</span> _, e := <span class="keyword">range</span> v &#123;</span><br><span class="line">				addEleFun(e)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			addEleFun(v)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.TypeMismatchError(arg,</span><br><span class="line">				<span class="string">&quot;string&quot;</span>,</span><br><span class="line">				<span class="string">&quot;int&quot;</span>,</span><br><span class="line">				<span class="string">&quot;int32&quot;</span>,</span><br><span class="line">				<span class="string">&quot;int64&quot;</span>,</span><br><span class="line">				<span class="string">&quot;bool&quot;</span>,</span><br><span class="line">				<span class="string">&quot;*string&quot;</span>,</span><br><span class="line">				<span class="string">&quot;*int&quot;</span>,</span><br><span class="line">				<span class="string">&quot;*int32&quot;</span>,</span><br><span class="line">				<span class="string">&quot;*int64&quot;</span>,</span><br><span class="line">				<span class="string">&quot;[]string&quot;</span>,</span><br><span class="line">				<span class="string">&quot;[]int&quot;</span>,</span><br><span class="line">				<span class="string">&quot;[]int32&quot;</span>,</span><br><span class="line">				<span class="string">&quot;[]int64&quot;</span>,</span><br><span class="line">				<span class="string">&quot;[]string&quot;</span>,</span><br><span class="line">				<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newArgs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql := <span class="string">&quot;SELECT user_uuid FROM sync_user WHERE corp_uuid=? AND sync_id IN(%s) AND status!=?;&quot;</span></span><br><span class="line">sql = fmt.Sprintf(sql, utilsModel.SqlPlaceholds(length))</span><br><span class="line">args, _ := utilsModel.BuildSqlArgs(corpUUID, syncIDs[block.Since:block.End], utilsModel.SyncUserStatusDelete)</span><br><span class="line">_, err := src.Select(&amp;data, sql, args...)</span><br></pre></td></tr></table></figure>



<h2 id="golang的继承复用"><a href="#golang的继承复用" class="headerlink" title="golang的继承复用"></a>golang的继承复用</h2><p>BaseExector只实现了GetUpdateKeys()，其他ValidateAndPrepare，Commit，SuccessCallback，AsyncSuccessCallback，GetUserUUID交由子类实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base</span></span><br><span class="line"><span class="keyword">type</span> Executer <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetUpdateKeys() *UpdateKeys</span><br><span class="line">	ValidateAndPrepare(src gorp.SqlExecutor) error</span><br><span class="line">	Commit(*gorp.Transaction) (<span class="keyword">interface</span>&#123;&#125;, error)</span><br><span class="line">	SuccessCallback()</span><br><span class="line">	AsyncSuccessCallback()</span><br><span class="line">	GetUserUUID() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BaseExecutor <span class="keyword">struct</span> &#123;</span><br><span class="line">	UpdateKeys</span><br><span class="line">	Task       *taskModel.Task</span><br><span class="line">	Transition *workflow.Transition</span><br><span class="line">	TeamUUID   <span class="keyword">string</span></span><br><span class="line">	UserUUID   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e BaseExecutor)</span> <span class="title">GetUpdateKeys</span><span class="params">()</span> *<span class="title">UpdateKeys</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;e.UpdateKeys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类继承executors.BaseExecutor</span></span><br><span class="line"><span class="keyword">type</span> DiscussionExecutor <span class="keyword">struct</span> &#123;</span><br><span class="line">	executors.BaseExecutor</span><br><span class="line">	Discussion    *SendMessageRequest</span><br><span class="line">	message       *messageModel.Message</span><br><span class="line">	resource      *resourceModel.FileResource</span><br><span class="line">	mentions      []<span class="keyword">string</span></span><br><span class="line">	projectUsers  []<span class="keyword">string</span></span><br><span class="line">	isPushMessage <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后具体实现ValidateAndPrepare，Commit，SuccessCallback，AsyncSuccessCallback，GetUserUUID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DiscussionExecutor)</span> <span class="title">ValidateAndPrepare</span><span class="params">(src gorp.SqlExecutor)</span> <span class="params">(result error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DiscussionExecutor)</span> <span class="title">GetUserUUID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.UserUUID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FieldValueExecutor <span class="keyword">struct</span> &#123;</span><br><span class="line">	executors.BaseExecutor</span><br><span class="line">	FieldValues   []*field.FieldRawValue</span><br><span class="line">	messages      []*push.PendingMessage</span><br><span class="line">	asyncMessages []*message.AsyncMessagePayload</span><br><span class="line">	helper        *TaskHelper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *FieldValueExecutor)</span> <span class="title">GetUserUUID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.UserUUID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用流程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arg := <span class="string">&quot;a&quot;</span></span><br><span class="line">  <span class="comment">// 1. 输入参数,生成不同的exectuor</span></span><br><span class="line">  Executor := BuildExecutors(arg)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 将Executor作为参数传入其他函数</span></span><br><span class="line">  otherArg := <span class="string">&quot;b&quot;</span></span><br><span class="line">  DoService(otherArg, Executor)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildExecutors</span><span class="params">(arg <span class="keyword">string</span>)</span> <span class="title">Executer</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> e Executer</span><br><span class="line">  <span class="keyword">switch</span> arg &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">    e = NewResourceExecutor(arg)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">    e = NewDiscussionExecutor(arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoService</span><span class="params">(arg <span class="keyword">string</span>, e Executor)</span></span> &#123;</span><br><span class="line">  RunSuccessCallback(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunSuccessCallback</span><span class="params">(e Executer)</span></span> &#123;</span><br><span class="line">	e.SuccessCallback()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;%s\n%s\n&quot;</span>, err, debug.Stack())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		e.AsyncSuccessCallback()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="slice-append避免使用var"><a href="#slice-append避免使用var" class="headerlink" title="slice append避免使用var"></a>slice append避免使用var</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果arr为空，那么s为null</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">  arr := []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> _, ele := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果arr为空，那么s为[]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义长度为0， cap为1</span></span><br><span class="line">  s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  arr := []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> _, ele := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="复制-struct-pointer"><a href="#复制-struct-pointer" class="headerlink" title="复制 struct pointer"></a>复制 struct pointer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start *Point</span><br><span class="line">a := start</span><br><span class="line">c := start</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20210402184723949.png" alt="image-20210402184723949"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start *Point</span><br><span class="line">a := start</span><br><span class="line">c := *start</span><br><span class="line">d := &amp;c</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20210402184741609.png" alt="image-20210402184741609"></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FieldTypeEnumConverter <span class="keyword">struct</span> &#123;</span><br><span class="line">	byLabel <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">	byEnum  <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultFieldTypeEnumConverter</span><span class="params">()</span> *<span class="title">FieldTypeEnumConverter</span></span> &#123;</span><br><span class="line">	c := NewFieldTypeEnumConverter()</span><br><span class="line"></span><br><span class="line">	c.Set(FieldTypeOption, <span class="number">1</span>)</span><br><span class="line">	c.Set(FieldTypeText, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *FieldTypeEnumConverter)</span> <span class="title">Set</span><span class="params">(label <span class="keyword">string</span>, enum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	c.byLabel[label] = enum</span><br><span class="line">	c.byEnum[enum] = label</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *FieldTypeEnumConverter)</span> <span class="title">Enum</span><span class="params">(label <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> enum, ok := c.byLabel[label]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> enum, <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;invalid filed type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *FieldTypeEnumConverter)</span> <span class="title">Label</span><span class="params">(enum <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> label, ok := c.byEnum[enum]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> label, <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;invalid filed type&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="通过reflect获取structName来进行判断"><a href="#通过reflect获取structName来进行判断" class="headerlink" title="通过reflect获取structName来进行判断"></a>通过reflect获取structName来进行判断</h2><p>在scrapy中，spider的parse()方法可以yield Item/yield Request，这一点在Golang中如何实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">interface</span> &#123;</span><br><span class="line">	Url() <span class="keyword">string</span></span><br><span class="line">	Body() []<span class="keyword">byte</span></span><br><span class="line">	Meta() <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Copy()</span><br><span class="line">	Replace()</span><br><span class="line">	UrlJoin(url <span class="keyword">string</span>)</span><br><span class="line">	Text() <span class="keyword">string</span></span><br><span class="line">	CSS() <span class="keyword">string</span></span><br><span class="line">	XPath(args []<span class="keyword">string</span>, kwargs []<span class="keyword">string</span>) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Follow() *request.Request</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ee *ExecutionEngine)</span> <span class="title">handleDownloaderOutput</span><span class="params">(resp response.Response)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  <span class="comment">// 通过reflect判断</span></span><br><span class="line">	<span class="keyword">if</span> reflect.TypeOf(resp).Name() == <span class="string">&quot;Request&quot;</span> &#123;</span><br><span class="line">		ee.Crawl(req, spider)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ee.scraper.EnqueueScrape(resp, req, spider)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="通过抽出一层来解决所属不清的问题"><a href="#通过抽出一层来解决所属不清的问题" class="headerlink" title="通过抽出一层来解决所属不清的问题"></a>通过抽出一层来解决所属不清的问题</h2><p>现有一个围棋游戏，point有：</p>
<ul>
<li>isValid()方法用于判断是否超出棋盘，</li>
<li>left()方法用于获取该点左边的点</li>
</ul>
<p>这两个方法都需要用到Table,但是给isValid传入table变量又是一件很奇怪的事。</p>
<p><strong>此时就可以将Table提升为全局变量，通过抽出一层来解决</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GameTable <span class="keyword">struct</span> &#123;</span><br><span class="line">  xLen <span class="keyword">int</span></span><br><span class="line">  yLen <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">  x <span class="keyword">int</span></span><br><span class="line">  y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span><span class="title">IsVaild</span><span class="params">(table Table)</span> <span class="title">bool</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Table提升为全局变量</span></span><br><span class="line"><span class="keyword">var</span> Table = NewGameTable(...)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span><span class="title">IsVaild</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> Table[p.x][p.y] == ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用类似继承的机制来实现接口"><a href="#使用类似继承的机制来实现接口" class="headerlink" title="使用类似继承的机制来实现接口"></a>使用类似继承的机制来实现接口</h2><ol>
<li>定义一个Handler接口</li>
<li>首先由BaseHandler实现大部分的Handler接口</li>
<li>子类CollectLocalPictureHandler实现需要灵活变动的Adjust()和Extra()方法</li>
<li>这样，CollectLocalPictureHandler就实现了全部的Handler接口方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	Collect() error</span><br><span class="line">	BaseAdjust()</span><br><span class="line">	Adjust()</span><br><span class="line">	Extra() error</span><br><span class="line">	Rewrite() error</span><br><span class="line">	Report()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BaseHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	Files    []*MarkdownFile</span><br><span class="line">	TrashBin []*MarkdownFile</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BaseHandler实现了除了Adjust()和Extra()的所有的Handler方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *BaseHandler)</span> <span class="title">Collect</span><span class="params">()</span> <span class="title">error</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *BaseHandler)</span> <span class="title">BaseAdjust</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CollectLocalPictureHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	*BaseHandler</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CollectLocalPictureHandler)</span> <span class="title">Adjust</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CollectLocalPictureHandler)</span> <span class="title">Extra</span><span class="params">()</span> <span class="title">error</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>详见<code>策略模式</code></p>
</blockquote>
<h2 id="报错exit-status-1"><a href="#报错exit-status-1" class="headerlink" title="报错exit status 1"></a>报错exit status 1</h2><ul>
<li>log.Fatal()会导致程序（调用os.Exit(1)）退出-&gt;退出返回值为1</li>
<li>log.Panic()会导致挂掉（且会打印出panic时的信息）并退出-&gt;退出返回值为2</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18159704/how-to-debug-exit-status-1-error-when-running-exec-command-in-golang/18159705">https://stackoverflow.com/questions/18159704/how-to-debug-exit-status-1-error-when-running-exec-command-in-golang/18159705</a></p>
<h2 id="向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h2><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Processed:&quot;</span>, m)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)    <span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output：</span></span><br><span class="line"><span class="comment">// Processed:cmd.1</span></span><br></pre></td></tr></table></figure>



<h2 id="在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>在 range 迭代 slice、array、map 时通过更新引用来更新元素</h2><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v *= <span class="number">10</span>        <span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要修改原有元素的值，应该使用索引直接访问：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        data[i] = v * <span class="number">10</span>    </span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123; num <span class="keyword">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span>    <span class="comment">// 直接使用指针更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])    <span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="defer-函数的执行时机"><a href="#defer-函数的执行时机" class="headerlink" title="defer 函数的执行时机"></a>defer 函数的执行时机</h2><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题。</p>
<p>解决办法：defer 延迟执行的函数写入匿名函数中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span>    <span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close()    <span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用 f 资源</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="匿名函数中的循环变量快照问题"><a href="#匿名函数中的循环变量快照问题" class="headerlink" title="匿名函数中的循环变量快照问题"></a>匿名函数中的循环变量快照问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails3</span><span class="params">(filenames []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    <span class="comment">// 显式传入变量</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      thumbnail.ImageFile(f) </span><br><span class="line">      ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;(f)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    &lt;-ch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们将f的值作为一个显式的变量传给了函数，而不是在循环的闭包中声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  thumbnail.ImageFile(f)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个单独的变量f是被所有的匿名函数值所共享，且会<strong>被连续的循环迭代所更新</strong>的。当新的goroutine开始执行字面函数时，for循环可能已经更新了f并且开始了另一轮的迭代或者(更有可能的)已经结束了整个循环，所以当这些goroutine开始读取f的值时，它们所看到的值已经是slice的最后一个元素了。 显式地添加这个参数，我们能够确保使用的f是当go语句执行时的“当前”那个f。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>