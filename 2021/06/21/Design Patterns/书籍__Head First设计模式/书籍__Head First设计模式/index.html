<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;面向对象设计的原则&quot;&gt;&lt;a href=&quot;#面向对象设计的原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象设计的原则&quot;&gt;&lt;/a&gt;面向对象设计的原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;封装变化: &lt;strong&gt;把会变化的部分取出并且封装起来&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;多用组合,少用继承&lt;/li&gt;
&lt;li&gt;针对接口编程,不针对实现编程&lt;/li&gt;
&lt;li&gt;交互对象之间尽量松耦合&lt;/li&gt;
&lt;li&gt;类应该对修改封闭,对扩展开放&lt;/li&gt;
&lt;li&gt;要依赖抽象,不要依赖具体类&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;th&gt;包括&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;创建型模式&lt;/td&gt;
&lt;td&gt;这些设计模式提供一种 在创建对象同时隐藏逻 辑的方式。而不是使用 new运算符直接实例化 对象。&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/01_FactoryPattern&quot;&gt;工厂模式 (Factory Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/02_AbstractFactoryPattern&quot;&gt;抽象工厂模式 (Abstract Factory Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/03_SingletonPattern&quot;&gt;单例模式 (Singleton Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/04_BuilderPattern&quot;&gt;建造者模式 (Builder Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/05_PrototypePattern&quot;&gt;原型模式 (Prototype Pattern)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;结构型模式&lt;/td&gt;
&lt;td&gt;这些设计模式关注类和 对象的组合。继承的概念 被用来组合接口和定义 组合对象获取得新功能 的方式&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/06_AdapterPattern&quot;&gt;适配器模式 (Adapter Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/07_BridgePattern&quot;&gt;桥接模式 (Bridge Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/08_FilterPattern&quot;&gt;过滤器模式 (Filter Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/09_CompositePattern&quot;&gt;组合模式 (Composite Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/10_DecoratorPattern&quot;&gt;装饰器模式Decorator Pattern&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/11_FacadePattern&quot;&gt;外观模式 (Facade Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/12_FlyweightPattern&quot;&gt;享元模式 (Flyweight Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/13_ProxyPattern&quot;&gt;代理模式 (Proxy Pattern)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;行为模式&lt;/td&gt;
&lt;td&gt;这些设计模式特别&lt;strong&gt;关注 对象之间的通信&lt;/strong&gt;。&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/14_ChainOfResponsibilityPattern&quot;&gt;责任链模式 (Chain of Responsibility Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/15_CommandPattern&quot;&gt;命令模式 (Command Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/16_InterpreterPattern&quot;&gt;解释器模式 (Interpreter Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/17_IteratorPattern&quot;&gt;迭代器模式 (Iterator Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/18_MediatorPattern&quot;&gt;中介者模式 (Mediator Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/19_MementoPattern&quot;&gt;备忘录模式 (Memento Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/20_ObserverPattern&quot;&gt;观察者模式 (Observer Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/21_StatePattern&quot;&gt;状态模式 (State Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/24_NullObjectPattern&quot;&gt;空对象模式 (Null Object Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/22_StrategyPattern&quot;&gt;策略模式 (Strategy Pattern)&lt;/a&gt; &lt;a href=&quot;https://github.com/lee820/design-pattern-go/tree/master/23_TemplatePattern&quot;&gt;模板模式 (Template Pattern)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;策略模式: 定义了算法族,分别封装起来,让他们之间可以互相替换,此模式让算法的变化独立于使用算法的客户."><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Head First设计模式 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Design-Patterns/" rel="tag">Design Patterns</a></div><div class="post-time">2021-06-21</div></div></div><div class="container post-header"><h1>Head First设计模式</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">面向对象设计的原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98-delegate"><span class="toc-number">3.1.</span> <span class="toc-text">委托(delegate)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AE%BE%E5%AE%9A%E6%96%B9%E6%B3%95%E6%9D%A5%E9%9A%8F%E6%97%B6%E6%94%B9%E5%8F%98Handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.</span> <span class="toc-text">通过设定方法来随时改变Handler的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#has-a-VS-is-a"><span class="toc-number">3.3.</span> <span class="toc-text">has-a VS is-a</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.4.</span> <span class="toc-text">使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E5%AE%9A%E4%B9%89"><span class="toc-number">3.5.</span> <span class="toc-text">回顾定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%BE%E8%80%A6%E5%90%88"><span class="toc-number">4.1.</span> <span class="toc-text">松耦合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-%E6%8E%A8"><span class="toc-number">4.2.</span> <span class="toc-text">步骤(推)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-%E6%8E%A8%E6%8B%89%E5%B9%B6%E8%93%84"><span class="toc-number">4.3.</span> <span class="toc-text">步骤(推拉并蓄)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E5%93%AA%E9%87%8C%E8%83%BD%E9%81%87%E5%88%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">还有哪里能遇到观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-VS-%E7%BB%84%E5%90%88"><span class="toc-number">5.1.</span> <span class="toc-text">继承 VS 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">工厂模式分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">1. 简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">6.3.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">6.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">2. 工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">6.4.1.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">6.4.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">3. 抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.1.</span> <span class="toc-text">抽象工厂解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">6.5.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">6.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">6.6.</span> <span class="toc-text">三个模式有何关系与区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E4%B8%8E%E6%80%9D%E7%BB%B4%E5%80%92%E7%BD%AE"><span class="toc-number">6.7.</span> <span class="toc-text">依赖倒置与思维倒置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AF%BC%E6%96%B9%E9%92%88"><span class="toc-number">6.8.</span> <span class="toc-text">指导方针</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="面向对象设计的原则"><a href="#面向对象设计的原则" class="headerlink" title="面向对象设计的原则"></a>面向对象设计的原则</h2><ul>
<li>封装变化: <strong>把会变化的部分取出并且封装起来</strong></li>
<li>多用组合,少用继承</li>
<li>针对接口编程,不针对实现编程</li>
<li>交互对象之间尽量松耦合</li>
<li>类应该对修改封闭,对扩展开放</li>
<li>要依赖抽象,不要依赖具体类</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><table>
<thead>
<tr>
<th>模式</th>
<th>简介</th>
<th>包括</th>
</tr>
</thead>
<tbody><tr>
<td>创建型模式</td>
<td>这些设计模式提供一种 在创建对象同时隐藏逻 辑的方式。而不是使用 new运算符直接实例化 对象。</td>
<td><a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/01_FactoryPattern">工厂模式 (Factory Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/02_AbstractFactoryPattern">抽象工厂模式 (Abstract Factory Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/03_SingletonPattern">单例模式 (Singleton Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/04_BuilderPattern">建造者模式 (Builder Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/05_PrototypePattern">原型模式 (Prototype Pattern)</a></td>
</tr>
<tr>
<td>结构型模式</td>
<td>这些设计模式关注类和 对象的组合。继承的概念 被用来组合接口和定义 组合对象获取得新功能 的方式</td>
<td><a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/06_AdapterPattern">适配器模式 (Adapter Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/07_BridgePattern">桥接模式 (Bridge Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/08_FilterPattern">过滤器模式 (Filter Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/09_CompositePattern">组合模式 (Composite Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/10_DecoratorPattern">装饰器模式Decorator Pattern</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/11_FacadePattern">外观模式 (Facade Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/12_FlyweightPattern">享元模式 (Flyweight Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/13_ProxyPattern">代理模式 (Proxy Pattern)</a></td>
</tr>
<tr>
<td>行为模式</td>
<td>这些设计模式特别<strong>关注 对象之间的通信</strong>。</td>
<td><a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/14_ChainOfResponsibilityPattern">责任链模式 (Chain of Responsibility Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/15_CommandPattern">命令模式 (Command Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/16_InterpreterPattern">解释器模式 (Interpreter Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/17_IteratorPattern">迭代器模式 (Iterator Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/18_MediatorPattern">中介者模式 (Mediator Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/19_MementoPattern">备忘录模式 (Memento Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/20_ObserverPattern">观察者模式 (Observer Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/21_StatePattern">状态模式 (State Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/24_NullObjectPattern">空对象模式 (Null Object Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/22_StrategyPattern">策略模式 (Strategy Pattern)</a> <a target="_blank" rel="noopener" href="https://github.com/lee820/design-pattern-go/tree/master/23_TemplatePattern">模板模式 (Template Pattern)</a></td>
</tr>
</tbody></table>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p>策略模式: 定义了算法族,分别封装起来,让他们之间可以互相替换,此模式让算法的变化独立于使用算法的客户.</p>
<p>所谓的<code>策略模式</code>: 当我们遇到不同的情况时,需要及时<code>选择不同的策略</code>.</p>
</blockquote>
<p>我们将创建一个定义活动的 <em>Strategy</em> 接口和实现了 <em>Strategy</em> 接口的实体策略类。<em>Context</em> 是一个使用了某种策略的类。</p>
<p><em>StrategyPatternDemo</em>，我们的演示类使用 <em>Context</em> 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</p>
<p><img src="/images/strategy_pattern_uml_diagram.jpg" alt="策略模式的 UML 图"></p>
<h3 id="委托-delegate"><a href="#委托-delegate" class="headerlink" title="委托(delegate)"></a>委托(delegate)</h3><p><code>委托</code>: 将本来应该在这个类方法里实现逻辑,委托给另一个类实现.</p>
<p>当我们执行一长串逻辑,但是中间的部分逻辑是会变的,这时我们就可以将中间的抽离成一个interface,然后直接使用这个interface的方法</p>
<blockquote>
<p>注意:只能将<code>变</code>的部分抽出成委托</p>
</blockquote>
<ul>
<li><p>现在有一个duck类，需要实现walk(),swimming()。但是现在有一个Duck需要实现fly()方法。该怎么做。</p>
</li>
<li><p>为了分开<strong>会变化的部分</strong>和<strong>不会变化的部分</strong>，我们可以将walk，swimming，fly各自实现一个类,或者是一个接口。</p>
<blockquote>
<ul>
<li>duck类不会负责实现Flying和Swimming接口，反而是由一组其他类专门实现FlyBehavior和WalkBehavior。这就称为“行为”类。</li>
<li>这样，把具体的实现不在duck里实现，而是还给其他专门处理的类，实现了<code>按层抽离</code>.所以实际的实现不会绑死在Deck的子类中</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>其实这样也是有奇怪的地方:</p>
<p>class一般是一个东西,但是这里的FlyBehavior却是一个行为.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  <span class="function">flyBehavior FlyBehavior</span></span><br><span class="line"><span class="function">  walkBehavior WalkBehavior</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将本来应该由perfomFly实现的逻辑,交给flyBehavior类来实现</span></span><br><span class="line">    <span class="comment">// 又因为flyBehavior是外部传过来的参数,所以:通过传递不同的flybehavior来控制perfomFly的行为</span></span><br><span class="line">    flyBehavior.fly()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performWalk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    walkBehavior.walk()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg2</span></span><br><span class="line"><span class="keyword">type</span> Spider <span class="keyword">struct</span> &#123;</span><br><span class="line">  requester Requester</span><br><span class="line">  parser Parser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Spider)</span> <span class="title">crawl</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  content,_ := requester.request()</span><br><span class="line">  res,_ := parser.parse(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Requester <span class="keyword">interface</span> &#123;</span><br><span class="line">  request() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Parser <span class="keyword">interface</span> &#123;</span><br><span class="line">  parse() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HomePageRequester <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(s *HomePageRequester)</span> <span class="title">request</span><span class="params">()</span> <span class="title">error</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>现在有很多的handler,但是这些handler都有很多个共同的逻辑,唯一不同的就是adjust方法和extra方法.</p>
<p>所以我们可以将这两个方法委托给Adjuster和ExtraOperater接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// baseHandler用于抽离出所有的公共逻辑</span></span><br><span class="line"><span class="keyword">type</span> BaseHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	Files    []*MarkdownFile</span><br><span class="line">	TrashBin []*MarkdownFile</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BaseHandler还有很多公共方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *BaseHandler)</span> <span class="title">Collect</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *BaseHandler)</span> <span class="title">Rewrite</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">	*BaseHandler</span><br><span class="line">	adjuster Adjuster</span><br><span class="line">	extra ExtraOperater</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := h.Collect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 委托给ajuster</span></span><br><span class="line">		h.adjuster.Adjust()</span><br><span class="line">    <span class="comment">// 委托给extra</span></span><br><span class="line">		<span class="keyword">if</span> err := h.extra.Extra(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">if</span> err := h.Rewrite(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    h.Report()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adjuster <span class="keyword">interface</span> &#123;</span><br><span class="line">	adjust()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExtraOperater <span class="keyword">interface</span> &#123;</span><br><span class="line">	Extra() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的adjuster</span></span><br><span class="line"><span class="keyword">type</span> myAdjuster <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *myAdjuster)</span> <span class="title">adjust</span> <span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的ExtraOperater</span></span><br><span class="line"><span class="keyword">type</span> myExtraOperater <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *myExtraOperater)</span> <span class="title">Extra</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的Handler</span></span><br><span class="line"><span class="keyword">var</span> myHandler = &amp;Handler&#123;</span><br><span class="line">  *BaseHandler,</span><br><span class="line">  <span class="built_in">new</span>(myAdjuster),</span><br><span class="line">  <span class="built_in">new</span>(myExtraOperater),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(hs []Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> hs &#123;</span><br><span class="line">    h.run()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过设定方法来随时改变Handler的行为"><a href="#通过设定方法来随时改变Handler的行为" class="headerlink" title="通过设定方法来随时改变Handler的行为"></a>通过设定方法来随时改变Handler的行为</h3><p>上面的Handler,我们还可以给两个设定方法.这样,我们就可以随时改变Handler的行为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">	*BaseHandler</span><br><span class="line">	adjuster Adjuster</span><br><span class="line">	extra ExtraOperater</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">setAdjuster</span><span class="params">(adjuster Adjuster)</span></span> &#123;</span><br><span class="line">  h.adjuster=adjuster</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">setExtraOperater</span><span class="params">(extra ExtraOperater)</span></span> &#123;</span><br><span class="line">  h.extra=extra</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  h := &amp;Handler&#123;</span><br><span class="line">    *BaseHandler,</span><br><span class="line">    <span class="built_in">new</span>(myAdjuster),</span><br><span class="line">    <span class="built_in">new</span>(myExtraOperater),</span><br><span class="line">  &#125;</span><br><span class="line">  h.extra.Extra()</span><br><span class="line">  <span class="comment">// 改变行为</span></span><br><span class="line">  h.setExtraOperater(...)</span><br><span class="line">  h.extra.Extra()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="has-a-VS-is-a"><a href="#has-a-VS-is-a" class="headerlink" title="has-a VS is-a"></a>has-a VS is-a</h3><p>策略模式其实是<code>有一个(has-a)</code>的思想的体现.</p>
<p>每一个Handler都有一个Adjuster,好将调整的逻辑委托给他代为处理</p>
<p>使用组合建立系统具有很大的弹性,不仅可以将算法族封装成类,更可以<code>在运行时动态的改变行为</code>,只要组合的行为对象符合正确的接口标准即可.</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>定义策略执行者</li>
<li>定位设置不同策略的方法</li>
<li>调用策略中的方法,执行策略</li>
<li>定义不同的策略</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现此接口，则为一个策略</span></span><br><span class="line"><span class="keyword">type</span> IStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    do(<span class="keyword">int</span>, <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="keyword">type</span> add <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*add)</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line"><span class="keyword">type</span> reduce <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*reduce)</span> <span class="title">do</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略的执行者</span></span><br><span class="line"><span class="keyword">type</span> Operator <span class="keyword">struct</span> &#123;</span><br><span class="line">    strategy IStrategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置策略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(operator *Operator)</span> <span class="title">setStrategy</span><span class="params">(strategy IStrategy)</span></span> &#123;</span><br><span class="line">    operator.strategy = strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用策略中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(operator *Operator)</span> <span class="title">calculate</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> operator.strategy.do(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   operator := Operator&#123;&#125;</span><br><span class="line"></span><br><span class="line">   operator.setStrategy(&amp;add&#123;&#125;)</span><br><span class="line">   result := operator.calculate(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;add:&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">   operator.setStrategy(&amp;reduce&#123;&#125;)</span><br><span class="line">   result = operator.calculate(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;reduce:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回顾定义"><a href="#回顾定义" class="headerlink" title="回顾定义"></a>回顾定义</h3><blockquote>
<p>策略模式: 定义了算法族,分别封装起来,让他们之间可以互相替换,此模式让算法的变化独立于使用算法的客户</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">	*BaseHandler</span><br><span class="line">	adjuster Adjuster</span><br><span class="line">	extra ExtraOperater</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := h.Collect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 委托给ajuster</span></span><br><span class="line">		h.adjuster.Adjust()</span><br><span class="line">    <span class="comment">// 委托给extra</span></span><br><span class="line">		<span class="keyword">if</span> err := h.extra.Extra(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">if</span> err := h.Rewrite(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    h.Report()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myAdjuster <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *myAdjuster)</span> <span class="title">adjust</span> <span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myAdjuster2 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *myAdjuster)</span> <span class="title">adjust</span> <span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myAdjuster3 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *myAdjuster)</span> <span class="title">adjust</span> <span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在run方法中,我们把调整的逻辑委托给了<code>Adjuster</code>接口.因此每种不同的调整行为,就需要一个Adjuster接口的实现.(也就是struct) .我们把这些struct,成为<code>算法族</code></li>
<li>因为我们把<code>变化</code>的逻辑委托给了算法族,所以我们的run方法是静态的,也就是说:模式让算法的变化独立于使用算法的客户</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
</li>
<li><p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
</li>
<li><p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
</li>
<li><p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p>
</li>
<li><p><strong>关键代码：实现同一个接口。</strong></p>
</li>
<li><p>应用实例：</p>
<ul>
<li>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 </li>
<li>旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 </li>
<li>JAVA AWT 中的 LayoutManager。</li>
</ul>
</li>
<li><p>优点： </p>
<ul>
<li>算法可以自由切换。 </li>
<li>避免使用多重条件判断。 </li>
<li>扩展性良好。</li>
</ul>
</li>
<li><p>缺点： </p>
<ul>
<li>策略类会增多。 </li>
<li>所有策略类都需要对外暴露。</li>
</ul>
</li>
<li><p>使用场景： </p>
<ul>
<li><strong>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</strong> </li>
<li>一个系统需要动态地在几种算法中选择一种。 </li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
</ul>
</li>
<li><p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>观察者模式: 定义了对象之间的一对多依赖,这样一来,当一个对象改变状态的时候,他的所有依赖者都会收到通知并自动更新.</p>
</blockquote>
<p><code>观察者模式</code>: 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p>
<p>其实观察者模式就是订阅模式.比如很多人的微信订阅了某个公众号.当这个公众号更新的时候,就要通知所有的订阅者.其中这个公众号称为<code>主题(Subject)</code>,订阅者称为<code>观察者(Observer)</code></p>
<blockquote>
<ul>
<li>在观察者模式中,会改变的是主题的状态,以及观察者的数目和类型</li>
<li>主题与观察者都是用接口:<ul>
<li>观察者利用主题的接口向主题注册.</li>
<li>主题利用观察者的接口通知观察者.</li>
</ul>
</li>
</ul>
</blockquote>
<p>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 <em>Subject</em> 类、<em>Observer</em> 抽象类和扩展了抽象类 <em>Observer</em> 的实体类。</p>
<p><em>ObserverPatternDemo</em>，我们的演示类使用 <em>Subject</em> 和实体类对象来演示观察者模式。</p>
<p><img src="/images/observer_pattern_uml_diagram.jpg" alt="观察者模式的 UML 图"></p>
<h3 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h3><ul>
<li>当两个对象之间松耦合,<strong>他们依然可以交互,但是不太清楚彼此的细节.</strong></li>
<li>观察者模式提供了一种对象设计,让主题和观察者之间松耦合.</li>
</ul>
<p>关于观察者的一切,主题只知道观察者实现了某个接口(也就是Observer接口).主题不需要知道观察者的具体类是谁,做了些什么或是其他的细节.</p>
<p>任何时候我们都可以增加新的观察者,因为主题唯一依赖的就是一个实现Observer接口的对象列表.</p>
<h3 id="步骤-推"><a href="#步骤-推" class="headerlink" title="步骤(推)"></a>步骤(推)</h3><ol>
<li>创建 Subject 类。</li>
<li>创建 Observer 类。</li>
<li>创建实体观察者类。</li>
<li>使用 <em>Subject</em> 和实体观察者对象。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户</span></span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 其实update最好设计成</span></span><br><span class="line">    <span class="comment">// update(o *Object, arg int)</span></span><br><span class="line">    <span class="comment">// 第一个参数为object本身,这样观察者就知道是哪个主题下发的通知.</span></span><br><span class="line">    update()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomerA <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomerA)</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我是客户A, 我收到报纸了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomerB <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomerB)</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我是客户B, 我收到报纸了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报社 （被观察者)</span></span><br><span class="line"><span class="keyword">type</span> NewsOffice <span class="keyword">struct</span> &#123;</span><br><span class="line">    customers []Customer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">addCustomer</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line">    n.customers = <span class="built_in">append</span>(n.customers, customer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">newspaperCome</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通知所有客户</span></span><br><span class="line">    n.notifyAllCustomer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">notifyAllCustomer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, customer := <span class="keyword">range</span> n.customers &#123;</span><br><span class="line">        customer.update()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestObserver</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    customerA := &amp;CustomerA&#123;&#125;</span><br><span class="line">    customerB := &amp;CustomerB&#123;&#125;</span><br><span class="line"></span><br><span class="line">    office := &amp;NewsOffice&#123;&#125;</span><br><span class="line">    <span class="comment">// 模拟客户订阅</span></span><br><span class="line">    office.addCustomer(customerA)</span><br><span class="line">    office.addCustomer(customerB)</span><br><span class="line">    <span class="comment">// 新的报纸</span></span><br><span class="line">    office.newspaperCome()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤-推拉并蓄"><a href="#步骤-推拉并蓄" class="headerlink" title="步骤(推拉并蓄)"></a>步骤(推拉并蓄)</h3><p>observer能自己拉取subject的<code>状态</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	StateNormal = <span class="number">1</span></span><br><span class="line">	StateError  = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户</span></span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">interface</span> &#123;</span><br><span class="line">	update()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomerA <span class="keyword">struct</span> &#123;</span><br><span class="line">	office *NewsOffice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomerA)</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是客户A, 我收到报纸了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomerB <span class="keyword">struct</span> &#123;</span><br><span class="line">	office *NewsOffice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomerB)</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;我是客户B, 我收到报纸了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报社 （被观察者)</span></span><br><span class="line"><span class="keyword">type</span> NewsOffice <span class="keyword">struct</span> &#123;</span><br><span class="line">	state     State</span><br><span class="line">	customers []Customer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">addCustomer</span><span class="params">(customer Customer)</span></span> &#123;</span><br><span class="line">	n.customers = <span class="built_in">append</span>(n.customers, customer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">newspaperCome</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n.state = StateNormal</span><br><span class="line">	<span class="comment">// 通知所有客户</span></span><br><span class="line">	n.notifyAllCustomer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">notifyAllCustomer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, customer := <span class="keyword">range</span> n.customers &#123;</span><br><span class="line">		customer.update()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">getState</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NewsOffice)</span> <span class="title">setState</span><span class="params">(state State)</span></span>  &#123;</span><br><span class="line">	n.state = state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	office := &amp;NewsOffice&#123;&#125;</span><br><span class="line"></span><br><span class="line">	customerA := &amp;CustomerA&#123;office&#125;</span><br><span class="line">	customerB := &amp;CustomerB&#123;office&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟客户订阅</span></span><br><span class="line">	office.addCustomer(customerA)</span><br><span class="line">	office.addCustomer(customerB)</span><br><span class="line">	<span class="comment">// 新的报纸</span></span><br><span class="line">	office.newspaperCome()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> customerA.office.state == StateNormal &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;observer主动获取subject状态&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="还有哪里能遇到观察者模式"><a href="#还有哪里能遇到观察者模式" class="headerlink" title="还有哪里能遇到观察者模式"></a>还有哪里能遇到观察者模式</h3><p>js中的<code>addLister()</code>就是观察者模式.</p>
<p>实际上,这种<code>监听者</code>都是观察者模式.</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</li>
<li><p>主要解决：<strong>一个对象状态改变给其他对象通知的问题</strong>，而且要考虑到易用和低耦合，保证高度的协作。</p>
</li>
<li><p>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
</li>
<li><p>如何解决：使用面向对象技术，可以将这种依赖关系弱化。</p>
</li>
<li><p>关键代码：<strong>被观察者持有了集合存放观察者</strong> (在抽象类里有一个 ArrayList 存放观察者们).</p>
</li>
<li><p>应用实例： </p>
<ul>
<li>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 </li>
<li>MVC 模式，当 model 改变时，View 视图会自动改变，model 为被观察者，View 为观察者</li>
<li>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</li>
</ul>
</li>
<li><p>优点： </p>
<ul>
<li>观察者和被观察者是抽象耦合的。 </li>
<li>建立一套触发机制。</li>
</ul>
</li>
<li><p>缺点： </p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 </li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 </li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
</li>
<li><p>注意事项： </p>
<ul>
<li>JAVA 中已经有了对观察者模式的支持类。 </li>
<li>避免循环引用。 </li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</li>
</ul>
</li>
</ul>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote>
<p><code>装饰者模式</code>: 动态地将责任附加到对象上.若要扩展功能,装饰者提供了比继承更有弹性的替代方案.</p>
</blockquote>
<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，<strong>它是作为现有的类的一个包装</strong>。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<blockquote>
<p>注意:装饰者和被装饰者必须要有一样的类型.</p>
</blockquote>
<p>装饰者模式适合“零件组合”的情况. 比如奶茶分成加糖,加冰,加奶,加珍珠,加奶昔,加果粒等等.我们就可以<strong>把每类选择都做成一个装饰器</strong>.然后自由组合.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sugger</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ice</span>:</span> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fruit</span>:</span> ...</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 加糖加冰</span></span><br><span class="line"><span class="meta">@Ice</span></span><br><span class="line"><span class="meta">@Sugger</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">naicha</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加糖加果粒</span></span><br><span class="line"><span class="meta">@fruit</span></span><br><span class="line"><span class="meta">@Sugger</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">naicha</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<p>我们将创建一个 <em>Shape</em> 接口和实现了 <em>Shape</em> 接口的实体类。然后我们创建一个实现了 <em>Shape</em> 接口的抽象装饰类 <em>ShapeDecorator</em>，并把 <em>Shape</em> 对象作为它的实例变量。</p>
<p><em>RedShapeDecorator</em> 是实现了 <em>ShapeDecorator</em> 的实体类。</p>
<p><em>DecoratorPatternDemo</em> 类使用 <em>RedShapeDecorator</em> 来装饰 <em>Shape</em> 对象。</p>
<p><img src="/images/image-20210427021402615.png" alt="image-20210427021402615"></p>
<h3 id="继承-VS-组合"><a href="#继承-VS-组合" class="headerlink" title="继承 VS 组合"></a>继承 VS 组合</h3><ul>
<li>利用继承来设计子类的行为,是在编译时静态决定的,而且所有的子类都会继承到相同的行为.</li>
<li>如果能利用组合的做法扩展对象的行为,就可以在运行时动态的进行扩展.</li>
</ul>
<p>这样,我们就可以把多个新的职责,甚至是设计超类时还没有想到的职责加在对象上.而且可以不用修改原来的代码.</p>
<p>这就是所谓的<code>对修改封闭,对扩展开放</code></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>声明一个<code>Beverage</code>接口，作为后续实现的标准(后续的所有类都需要继承这个接口)</li>
<li>声明一个基础结构体<code>Beverage</code>,同时实现getDescription, cost方法即实现了接口</li>
<li>声明一个装饰结构体叫<code>Mocha</code>,将<code>Beverage</code>接口内嵌入此结构体,并实现<code>getDescription()</code>方法和<code>cost()</code>方法, 在里面调用接口<code>Beverage</code>里的<code>getDescription()</code>方法和<code>cost()</code>方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  饮料接口</span></span><br><span class="line"><span class="keyword">type</span> Beverage <span class="keyword">interface</span> &#123;</span><br><span class="line">    getDescription() <span class="keyword">string</span></span><br><span class="line">    cost() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现咖啡的过程</span></span><br><span class="line"><span class="keyword">type</span> Coffee <span class="keyword">struct</span> &#123;</span><br><span class="line">    description <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Coffee)</span> <span class="title">getDescription</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.description</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Coffee)</span> <span class="title">cost</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mocha 实现</span></span><br><span class="line"><span class="keyword">type</span> Mocha <span class="keyword">struct</span> &#123;</span><br><span class="line">    beverage Beverage</span><br><span class="line">    description <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Mocha)</span> <span class="title">getDescription</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用了委托</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, %s&quot;</span>, this.beverage.getDescription(), this.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Mocha)</span> <span class="title">cost</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.beverage.cost() + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whip 实现</span></span><br><span class="line"><span class="keyword">type</span> Whip <span class="keyword">struct</span> &#123;</span><br><span class="line">    beverage Beverage</span><br><span class="line">    description <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Whip)</span> <span class="title">getDescription</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, %s&quot;</span>, this.beverage.getDescription(), this.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this Whip)</span> <span class="title">cost</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.beverage.cost() + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> beverage Beverage</span><br><span class="line">    <span class="comment">// 买了一杯咖啡</span></span><br><span class="line">    beverage = Coffee&#123;description:<span class="string">&quot;houseBlend&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 给咖啡加上 Mocha</span></span><br><span class="line">    beverage = Mocha&#123;beverage:beverage, description:<span class="string">&quot;Mocha&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 给咖啡加上 Whip</span></span><br><span class="line">    beverage = Whip&#123;beverage:beverage, description:<span class="string">&quot;whip&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 最后计算 Coffee 的价格</span></span><br><span class="line">    fmt.Println(beverage.getDescription(), <span class="string">&quot;, cost is &quot;</span>, beverage.cost())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</li>
<li>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，<strong>由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</strong></li>
<li><strong>何时使用：在不想增加很多子类的情况下扩展类。</strong></li>
<li>如何解决：将具体功能职责划分，同时继承装饰者模式。</li>
<li>关键代码： <ul>
<li>Component 类充当抽象角色，不应该具体实现。 </li>
<li>修饰类引用和继承 Component 类，具体扩展类重写父类方法。</li>
</ul>
</li>
<li>应用实例： <ul>
<li>孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 </li>
<li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</li>
</ul>
</li>
<li>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li>
<li>缺点：多层装饰比较复杂。</li>
<li>使用场景： <ul>
<li>扩展一个类的功能。 </li>
<li>动态增加功能，动态撤销。</li>
</ul>
</li>
<li>注意事项：可代替继承。</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p><code>工厂模式</code>: 定义了一个创建对象方法的接口,但是由子类决定要实例化的类是哪一个.工厂方法让类把实例化推迟到子类.</p>
</blockquote>
<p>在下述情况下可以考虑使用工厂模式：</p>
<ol>
<li>在编码时不能预见需要创建哪种类的实例。</li>
<li>系统不应依赖于产品类实例如何被创建、组合和表达的细节。</li>
</ol>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>意图：<strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</strong></li>
<li>主要解决：主要解决接口选择的问题。</li>
<li>何时使用：我们明确地计划不同条件下创建不同实例时。</li>
<li>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</li>
<li>关键代码：创建过程在其子类执行，返回的实例都实现同一接口。</li>
<li>应用实例： <ul>
<li>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</li>
<li>Hibernate 换数据库只需换方言和驱动就可以。</li>
</ul>
</li>
<li>优点： <ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。 </li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 </li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
</li>
<li>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li>
<li>使用场景：<ul>
<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </li>
<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </li>
<li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li>
</ul>
</li>
<li>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</li>
</ul>
<h3 id="工厂模式分类"><a href="#工厂模式分类" class="headerlink" title="工厂模式分类"></a>工厂模式分类</h3><p>有的人把工厂模式分成三类：简单工厂模式，工厂方法模式，抽象工厂模式</p>
<p>有的人把工厂模式分成两类，剔除简单工厂模式，将工厂方法模式更名为工厂模式，所以就是：工厂模式，抽象工厂模式</p>
<p><img src="/images/v2-70766d571df02a647149475c5eb207c9_1440w.jpg" alt="img"></p>
<ul>
<li>简单工厂 ： 用来生产同一等级结构中的任意产品。（新增产品就要修改工厂类。符合单一职责原则。不符合开放-封闭原则）</li>
<li>工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品，新增产品时不需要更改已有的工厂，需要增加该产品对应的工厂。符合单一职责原则、符合开放-封闭原则。但是引入了复杂性。）</li>
<li>抽象工厂 ：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开放-封闭原则，降低了复杂性）</li>
</ul>
<blockquote>
<ul>
<li>简单工厂：唯一工厂类，一个产品抽象类，工厂类的创建方法依据入参判断并创建具体产品对象。</li>
<li>工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。</li>
<li>抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。</li>
</ul>
</blockquote>
<h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><ul>
<li>简单工厂模式又叫<code>静态方法模式</code>（因为工厂类定义了一个静态方法）</li>
<li>现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。</li>
</ul>
<p><img src="/images/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg" alt="工厂模式的 UML 图"></p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p><img src="/images/image-20210427184034341.png" alt="image-20210427184034341"></p>
<ol>
<li>创建一个Phone接口</li>
<li>创建实现接口的实体类XiaomiPhone，HuaweiPhone</li>
<li>创建一个工厂Factory，生成基于给定信息的实体类的对象(<code>&amp;XiaomiPhone&#123;&#125;</code>/<code>&amp;HuaweiPhone&#123;&#125;</code>)。</li>
<li>使用该工厂，通过传递类型信息来获取实体类的对象。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂模式</span></span><br><span class="line"><span class="keyword">package</span> pattern</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">	Call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiPhone <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xm *XiaomiPhone)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi phone call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiPhone <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *HuaweiPhone)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei phone call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory)</span> <span class="title">GetPhone</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Phone</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;xiaomi&quot;</span> &#123;</span><br><span class="line">		p = &amp;XiaomiPhone&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;huawei&quot;</span> &#123;</span><br><span class="line">		p = &amp;HuaweiPhone&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSimpleFactory</span><span class="params">(*testing.T)</span></span> &#123;</span><br><span class="line">	f := &amp;Factory&#123;&#125;</span><br><span class="line">	xiaomiPhone := f.GetPhone(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">	xiaomiPhone.Call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>优点</p>
<ul>
<li>可以对创建的对象进行一些 “加工” ，而且客户端并不知道，因为工厂隐藏了这些细节。如果，没有工厂的话，那我们是不是就得自己在客户端上写这些代码，这就好比本来可以在工厂里生产的东西，拿来自己手工制作，不仅麻烦以后还不好维护。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>每次增加子类或者删除子类对象的创建都需要打开这简单工厂类来进行修改。这会导致这个简单工厂类很庞大臃肿、耦合性高，而且增加、删除某个子类对象的创建都需要打开简单工厂类来进行修改代码也违反了开-闭原则。</li>
</ul>
</li>
</ul>
<h3 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a>2. 工厂方法模式</h3><p><strong>工厂方法是为了解决简单工厂增加新的子类就必须增加新的if-else的情况</strong>,所以干脆给FactoryStore类添加一个Factory属性,通过传递不同的Factory来创建不同的Product.</p>
<p><img src="/images/aaa.png" alt="UML类图"></p>
<p>和简单工厂模式的区别：</p>
<ul>
<li>简单工厂模式是：Factory -&gt; xiaomiPhone</li>
<li>抽象工厂模式是：FactoryStore -&gt; xiaomiFactory -&gt; xiaomiPhone</li>
</ul>
<p>因为Factory和Product都有多个struct，因此Factory和Product都有对应的Interface</p>
<h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><p><img src="/images/image-20210427184104583.png" alt="image-20210427184104583"></p>
<ol>
<li>创建<strong>抽象产品类</strong>(Phone)，定义具体产品的公共接口；</li>
<li>创建<strong>抽象工厂类</strong>(Factory)，定义具体工厂的公共接口(XiaomiFactory,HuaweiFactory)；</li>
<li>创建<strong>具体产品类</strong>（继承抽象产品类） &amp; 定义生产的具体产品(XiaomiPhone6,XiaomiPhone7,HuaweiPhone10,HuaweiPhone11)；</li>
<li>创建<strong>具体工厂类</strong>（继承抽象工厂类）(FactoryStore)，定义创建对应具体产品实例的方法(GetPhone)；</li>
<li>外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法模式</span></span><br><span class="line"><span class="keyword">package</span> pattern_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">	Call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiPhone6 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xm *XiaomiPhone6)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi phone6 call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiPhone7 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xm *XiaomiPhone7)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi phone7 call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiPhone10 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *HuaweiPhone10)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei phone10 call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiPhone11 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *HuaweiPhone11)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei phone11 call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Factory <span class="keyword">interface</span> &#123;</span><br><span class="line">	CreatePhone(name <span class="keyword">string</span>) Phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xmf *XiaomiFactory)</span> <span class="title">CreatePhone</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Phone</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;xiaomi6&quot;</span> &#123;</span><br><span class="line">		p = &amp;XiaomiPhone6&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;xiaomi7&quot;</span> &#123;</span><br><span class="line">		p = &amp;XiaomiPhone7&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hwf *HuaweiFactory)</span> <span class="title">CreatePhone</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p Phone</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;huawei10&quot;</span> &#123;</span><br><span class="line">		p = &amp;HuaweiPhone10&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;huawei11&quot;</span> &#123;</span><br><span class="line">		p = &amp;HuaweiPhone11&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FactoryStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory Factory</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *FactoryStore)</span> <span class="title">GetPhone</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fs.factory.CreatePhone(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFactoryMethod</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fs := &amp;FactoryStore&#123;&amp;HuaweiFactory&#123;&#125;&#125;</span><br><span class="line">	phone := fs.GetPhone(<span class="string">&quot;huawei10&quot;</span>)</span><br><span class="line">	phone.Call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>优点</p>
<ul>
<li><strong>更符合开-闭原则</strong>：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可（简单工厂模式需要修改工厂类的判断逻辑）</li>
<li><strong>符合单一职责原则</strong>：每个具体工厂类只负责创建对应的产品（简单工厂中的工厂类存在复杂的switch逻辑判断）</li>
<li><strong>不使用静态工厂方法，可以形成基于继承的等级结构</strong>：简单工厂模式的工厂类使用静态工厂方法</li>
</ul>
<blockquote>
<p>工厂方法模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p>
</blockquote>
</li>
<li><p>缺点</p>
<ul>
<li>添加新产品时，<strong>除了增加新产品类外，还要提供与之对应的具体工厂类</strong>，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。<br>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li>
<li>一个具体工厂只能创建一种具体产品</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>当一个类不知道它所需要的对象的类时</li>
<li>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；<br>当一个类希望通过其子类来指定创建对象时</li>
<li>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
</li>
</ul>
<h3 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h3><p>抽象工厂模式: 提供一个接口,用于创建相关或依赖对象的家族,而不需要明确指定具体类.</p>
<p>抽象工厂模式(Abstra Factory Pattern)是<strong>围绕一个超级工厂，创建其他的工厂</strong>。</p>
<blockquote>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
</blockquote>
<p>为了缩减工厂实现子类的数量，不必给每一个产品分配一个工厂类，可以<strong>将产品进行分组，每组中的不同产品由同一个工厂类的不同方法来创建</strong>。</p>
<p>例如，键盘、主机这2种产品可以分到同一个分组——电脑，而不同品牌的电脑由不同的制造商工厂来创建。</p>
<p><img src="/images/v2-26c774778cddec1ae164116df8c1a86e_1440w.jpg" alt="img"></p>
<p>类似这种把产品类分组，组内不同产品由同一工厂类的不同方法实现的设计模式，就是抽象工厂模式。</p>
<p>抽象工厂适用于以下情况：</p>
<ol>
<li>一个系统要独立于它的产品的创建、组合和表示时；</li>
<li>一个系统要由多个产品系列中的一个来配置时；</li>
<li>要强调一系列相关的产品对象的设计以便进行联合使用时；</li>
<li>当你提供一个产品类库，而只想显示它们的接口而不是实现时；</li>
</ol>
<p><img src="/images/image-20210427120638766.png" alt="image-20210427120638766"></p>
<p><img src="/images/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg" alt="抽象工厂模式的 UML 图"></p>
<h4 id="抽象工厂解决的问题"><a href="#抽象工厂解决的问题" class="headerlink" title="抽象工厂解决的问题"></a>抽象工厂解决的问题</h4><p>在工厂模式中，<strong>一个具体的工厂对应一种具体的产品</strong>。但是，有时候我们需要工厂可以提供多个产品对象，而不是单一产品对象。我们首先要理解两个概念</p>
<ul>
<li><strong>产品等级结构</strong> 产品的等级结构就是产品的继承结构，如一个模型工厂，可以画出圆形，长方形和正方形的模型。这里抽象的模型工厂和具体的模型构成了产品等级结构。</li>
<li><strong>产品族</strong> 在抽象工厂模式中，产品族指的是同一个工厂生产的，位于不同产品等级结构的一组产品。如模具厂生产的红色圆形模具，圆形模型属于模型产品等级结构中，红色属于颜料产品等级结构中。</li>
</ul>
<p>例如我们的衣服，上衣由一个工厂生产，有卫衣，有衬衫，有西服。裤子由一个工厂生产，有短裤，有休闲裤，有西裤。这样，不同的上衣和不同的裤子组合起来，就是成了一套衣服，<br>就像QQ秀一样，当你在商城买了一套衣服裤子的时候，就是由这个抽象工厂所生产的。抽象工厂从几个具体的工厂中获取衣服，裤子，帽子等。组合成一套进行成套的售卖。</p>
<p><img src="/images/v2-981e27a93befe8436c8d98eca8e44911_r.jpg" alt="preview"></p>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><p><img src="/images/image-20210427184137080.png" alt="image-20210427184137080"></p>
<ol>
<li>为Phone创建一个接口。</li>
<li>为Phone创建实现接口的实体类(XiaomiPhone,HuaweiPhone)。</li>
<li>为Computer创建一个接口。</li>
<li>为Computer创建实现接口的实体类(XiaomiComputer,HuaweiComputer)。</li>
<li>创建抽象类AbstractFactory来获取 Phone 和 Computer 对象。</li>
<li>创建扩展了 AbstractFactory 的工厂类(XiaomiFactory,HuaweiFactory)，基于给定的信息生成实体类的对象(XiaomiPhone,HuaweiPhone,XiaomiComputer,HuaweiComputer)。</li>
<li>创建一个工厂创造器/生成器类(FactoryProducer)，其GetFactory方法通过传递手机或电脑信息来获取工厂(XiaomiFactory,HuaweiFactory)。</li>
<li>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test_pattern</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">	Call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MiaomiPhone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MiaomiPhone)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiPhone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HuaweiPhone)</span> <span class="title">Call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei call you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Play()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MiaomiComputer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MiaomiComputer)</span> <span class="title">Play</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is xiao mi play you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiComputer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HuaweiComputer)</span> <span class="title">Play</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this is hua wei play you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">	CreatePhone() Phone</span><br><span class="line">	CreateComputer() Computer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XiaomiFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xf *XiaomiFactory)</span> <span class="title">CreatePhone</span><span class="params">()</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MiaomiPhone&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xf *XiaomiFactory)</span> <span class="title">CreateComputer</span><span class="params">()</span> <span class="title">Computer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MiaomiComputer&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hf *HuaweiFactory)</span> <span class="title">CreatePhone</span><span class="params">()</span> <span class="title">Phone</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;HuaweiPhone&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hf *HuaweiFactory)</span> <span class="title">CreateComputer</span><span class="params">()</span> <span class="title">Computer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;HuaweiComputer&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FactoryProvider <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fp *FactoryProvider)</span> <span class="title">GetFactory</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">AbstractFactory</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f AbstractFactory</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;xiaomi&quot;</span> &#123;</span><br><span class="line">		f = &amp;XiaomiFactory&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;huawei&quot;</span> &#123;</span><br><span class="line">		f = &amp;HuaweiFactory&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAbstractFactory</span><span class="params">(*testing.T)</span></span> &#123;</span><br><span class="line">	fp := &amp;FactoryProvider&#123;&#125;</span><br><span class="line">	xiaomiFactory := fp.GetFactory(<span class="string">&quot;xiaomi&quot;</span>)</span><br><span class="line">	xiaomiPhone := xiaomiFactory.CreatePhone()</span><br><span class="line">	xiaomiPhone.Call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>抽象工厂模式说到底就是<strong>多了一层抽象，减少了工厂的数量</strong>。</p>
</li>
<li><p>意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</li>
<li><p>主要解决：主要解决接口选择的问题。</p>
</li>
<li><p>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
</li>
<li><p>如何解决：在一个产品族里面，定义多个产品。</p>
</li>
<li><p>关键代码：在一个工厂里聚合多个同类产品。</p>
</li>
<li><p>应用实例：</p>
<ol>
<li>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。</li>
<li><strong>假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。</strong></li>
<li>用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</li>
</ol>
</li>
<li><p>优点：<strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</strong></p>
</li>
<li><p>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
</li>
<li><p>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
</li>
<li><p>注意事项：产品族难扩展，产品等级易扩展。</p>
</li>
</ul>
<h3 id="三个模式有何关系与区别"><a href="#三个模式有何关系与区别" class="headerlink" title="三个模式有何关系与区别"></a>三个模式有何关系与区别</h3><ol>
<li><p>简单工厂模式屏蔽了创建对象的细节</p>
</li>
<li><p>简单工厂的缺点是:每次增加新的子类就必须增加新的if-else的情况.</p>
<p>工厂方法就是为了解决此问题,所以干脆给FactoryStore类添加一个Factory属性,通过传递不同的Factory来创建不同的Product.</p>
</li>
<li><p>工厂方法的缺点是:<strong>每一种品牌都需要有一个工厂</strong>，如果业务涉及的子类越来越多，会使得系统中类的个数成倍增加，增加了代码的复杂度。抽象工厂就是为了解决此问题. </p>
</li>
</ol>
<blockquote>
<p>简单工厂模式：生产<strong>一个产品</strong>（能生产小米手机和华为手机）</p>
<p>工厂方法模式：生产<strong>一个产品，多个系列</strong>（能生产小米手机和华为手机，且支持小米1，小米2，华为1，华为2）</p>
<p>抽象工厂模式：生产<strong>多个产品，多个系列</strong>（能生产小米手机，小米电脑和华为手机，华为电脑，且支持小米手机1，小米手机2，华为手机1，华为手机2，小米电脑1，小米电脑2，华为电脑1，华为电脑2）</p>
</blockquote>
<p>从最终使用上看</p>
<ol>
<li>简单工厂: 直接调用struct自己的Create方法</li>
<li>工厂方法: 通过委托给factory属性,让factory调用Create方法</li>
<li>抽象工厂: 根据不同种类创建不同的Factory,最后由一个超级工厂进行汇总</li>
</ol>
<p>因为<code>工厂方法</code>比<code>简单工厂</code>多了一个组合,于是就可以通过传入不同的factory属性来创建不同的工厂</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="keyword">type</span> SimpleFactory <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SimpleFactory)</span> <span class="title">CreateGirl</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Girl</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g Girl</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;thin&quot;</span> &#123;</span><br><span class="line">		g = &amp;ThinGirl&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;fat&quot;</span> &#123;</span><br><span class="line">		g = &amp;ThinGirl&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line"><span class="keyword">type</span> FactoryStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory Factory</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *FactoryStore)</span> <span class="title">CreateProduct</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Product</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fs.factory.CreateProduct(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">	CreatePhone(name <span class="keyword">string</span>) Phone</span><br><span class="line">	CreateComputer(name <span class="keyword">string</span>) Computer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> FactoryProducer <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fp *FactoryProducer)</span> <span class="title">GetFactory</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">AbstractFactory</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f AbstractFactory</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;phone&quot;</span> &#123;</span><br><span class="line">		f = &amp;PhoneFactory&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;computer&quot;</span> &#123;</span><br><span class="line">		f = &amp;ComputerFactory&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="依赖倒置与思维倒置"><a href="#依赖倒置与思维倒置" class="headerlink" title="依赖倒置与思维倒置"></a>依赖倒置与思维倒置</h3><p>回顾一下工厂方法模式:</p>
<ol>
<li>我们最终的需求是设计PhoneFactory,他支持传入一个name,然后生成一个Phone</li>
<li>既然都是Phone,那么他们应该共享一个Phone接口</li>
<li>既然已经有一个Phon抽象了,当我们设计PhoneFactory的时候就可以直接使用Phone接口,不必使用具体的Phone类了</li>
</ol>
<ul>
<li>正常我们的逻辑是,先设计出PhoneFactory,然后设计他的CreatePhone方法.但是现在,我们先考虑最终设计的Phone是怎么样的,再考虑怎么设计一个Factory去实现Phone.</li>
<li>整个流程是<code>倒置思维</code>的,这里的倒置指的就是和一般的OO设计的思考方向完全相反</li>
</ul>
<h3 id="指导方针"><a href="#指导方针" class="headerlink" title="指导方针"></a>指导方针</h3><p>下面的指导方针能避免违反依赖倒置原则:</p>
<ul>
<li><p>变量不可以持有具体类的引用</p>
<p>如果使用new,就会持有具体类的引用.你可以改用工厂类避开这样的做法.</p>
</li>
<li><p>不要让类派生自具体类<br>如果派生自具体类,你就会依赖具体类.请派生自一个抽象(接口或者重现```抽象类)</p>
</li>
<li><p>不要覆盖基类中已经实现的方法</p>
<p>如果覆盖基类已经实现的方法,那么你的基类就不是一个真正适合被继承的抽象.<strong>基类中已经实现的方法应该由所有的子类共享.</strong></p>
</li>
</ul>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>