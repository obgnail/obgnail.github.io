<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一般我们在C语言中通过指针，在知道变量在内存中占用的字节数情况下，就可以通过指针加偏移量的操作，直接在地址中，修改，访问变量的值。在 Go 语言中不支持指针运算，那怎么办呢？其实通过unsafe包，我们可以完成类似的操作。&lt;/li&gt;
&lt;li&gt;golang是一种静态的强类型的语言，所有的类型都是不能随意转换的，&lt;strong&gt;Go语言是不允许两个指针类型进行转换的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;go官方是不推荐使用unsafe的操作因为它是不安全的，它绕过了golang的内存安全原则，容易使你的程序出现莫名其妙的问题，不利于程序的扩展与维护。但是在很多地方却是很实用。在一些go底层的包中unsafe包被很频繁的使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;unsafe-定义&quot;&gt;&lt;a href=&quot;#unsafe-定义&quot; class=&quot;headerlink&quot; title=&quot;unsafe 定义&quot;&gt;&lt;/a&gt;unsafe 定义&lt;/h2&gt;&lt;p&gt;在unsafe包中，只提供了3个函数，两个类型。就这么少的量，却有着超级强悍的功能。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>unsafe | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-06-04</div></div></div><div class="container post-header"><h1>unsafe</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">unsafe 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-Sizeof%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">unsafe.Sizeof函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alignof-%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">Alignof 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offsetof-%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">Offsetof 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">unsafe的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.1.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%8E%B7%E5%8F%96%E3%80%81%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">6.2.</span> <span class="toc-text">根据位移获取、修改对象的字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-number">6.3.</span> <span class="toc-text">获取私有变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEsizeof%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E3%80%81%E4%BF%AE%E6%94%B9"><span class="toc-number">6.4.</span> <span class="toc-text">根据sizeof函数获取、修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">内存对齐详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-%E5%AD%97%E6%AE%B5%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%EF%BC%8C%E6%9C%80%E7%BB%88%E5%A4%A7%E5%B0%8F%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%90%8C"><span class="toc-number">7.1.</span> <span class="toc-text">struct 字段顺序不同，最终大小可能不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">7.2.</span> <span class="toc-text">内存对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%B3%E5%BF%83%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">为什么要关心对齐？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E5%AF%B9%E9%BD%90"><span class="toc-number">7.4.</span> <span class="toc-text">为什么要做对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AF%B9%E9%BD%90%E7%B3%BB%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">默认对齐系数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E9%BD%90"><span class="toc-number">7.6.</span> <span class="toc-text">成员对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E5%AF%B9%E9%BD%90-%EF%BC%88%E7%BB%93%E6%9E%84%E4%BD%93%E6%9C%AC%E8%BA%AB%E4%B9%9F%E8%A6%81%E5%AF%B9%E9%BD%90%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">整体对齐 （结构体本身也要对齐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="toc-number">7.8.</span> <span class="toc-text">对齐规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">7.9.</span> <span class="toc-text">分析流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%AE%BA%E5%AD%97%E6%AE%B5%E9%A1%BA%E5%BA%8F%E5%8F%AF%E6%94%B9%E5%8F%98%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F"><span class="toc-number">8.</span> <span class="toc-text">推论字段顺序可改变结构体大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BF%AE%E6%94%B9struct%E6%88%90%E5%91%98"><span class="toc-number">9.</span> <span class="toc-text">示例：修改struct成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BF%AE%E6%94%B9struct%E6%88%90%E5%91%982"><span class="toc-number">10.</span> <span class="toc-text">示例：修改struct成员2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9Astruct%E5%AF%B9%E9%BD%90%E5%80%BC"><span class="toc-number">11.</span> <span class="toc-text">示例：struct对齐值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%85%8D%E5%90%88reflect"><span class="toc-number">12.</span> <span class="toc-text">示例：配合reflect</span></a></li></ol></details></div><div class="container post-content"><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>一般我们在C语言中通过指针，在知道变量在内存中占用的字节数情况下，就可以通过指针加偏移量的操作，直接在地址中，修改，访问变量的值。在 Go 语言中不支持指针运算，那怎么办呢？其实通过unsafe包，我们可以完成类似的操作。</li>
<li>golang是一种静态的强类型的语言，所有的类型都是不能随意转换的，<strong>Go语言是不允许两个指针类型进行转换的</strong>。</li>
<li>go官方是不推荐使用unsafe的操作因为它是不安全的，它绕过了golang的内存安全原则，容易使你的程序出现莫名其妙的问题，不利于程序的扩展与维护。但是在很多地方却是很实用。在一些go底层的包中unsafe包被很频繁的使用。</li>
</ul>
<h2 id="unsafe-定义"><a href="#unsafe-定义" class="headerlink" title="unsafe 定义"></a>unsafe 定义</h2><p>在unsafe包中，只提供了3个函数，两个类型。就这么少的量，却有着超级强悍的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArbitraryType仅用于文档目的，实际上并不是unsafe包的一部分,它表示任意Go表达式的类型。</span></span><br><span class="line"><span class="comment">// ArbitraryType 是以int为基础定义的一个新类型，但是 Go 语言unsafe包中，对ArbitraryType赋予了特殊的意义，</span></span><br><span class="line"><span class="comment">// 通常，我们把interface&#123;&#125;看作是任意类型，那么ArbitraryType这个类型，在 Go 语言系统中，比interface&#123;&#125;还要随意。</span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意类型的指针，类似于C的*void</span></span><br><span class="line"><span class="comment">// Pointer 是ArbitraryType指针类型为基础的新类型，可以把Pointer类型理解成任何指针的亲爹。</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定结构在内存中占用的确切大小</span></span><br><span class="line"><span class="comment">// 返回变量在内存中占用的字节数，</span></span><br><span class="line"><span class="comment">// 切记，如果是slice，则不会返回这个slice在内存中的实际占用长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结构体中某个field的偏移量</span></span><br><span class="line"><span class="comment">// 返回变量指定属性的偏移量，</span></span><br><span class="line"><span class="comment">// 所以如果变量是一个struct类型，不能直接将这个struct类型的变量当作参数，只能将这个struct类型变量的属性当作参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结构体中某个field的对其值（字节对齐的原因）</span></span><br><span class="line"><span class="comment">// 返回变量对齐字节数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其它的<code>unsafe</code>包的go代码去哪里了？答案很简单：当你import到你程序里的时候，Go编译器实现了这个unsafe库。</p>
<p><em>许多系统库，例如<code>runtime</code>,<code>syscall</code>和<code>os</code>会经常使用到<code>usafe</code>库</em></p>
</blockquote>
<p>官方中定义了四个描述：</p>
<ol>
<li>任何类型的指针都可以被转化为Pointer</li>
<li>Pointer可以被转化为任何类型的指针</li>
<li>uintptr可以被转化为Pointer</li>
<li>Pointer可以被转化为uintptr</li>
</ol>
<blockquote>
<p>unsafe中，通过ArbitraryType 、Pointer 这两个类型，可以将其他类型都转换过来，然后通过这三个函数，分别能取长度，偏移量，对齐字节数，就可以在内存地址映射中，来回游走。</p>
</blockquote>
<p>事实上，一般在GO里使用的指针的完整称呼应该为<code>类型安全指针</code>。 虽然类型安全指针有助于我们轻松写出安全的代码，但是有时候施加在类型安全指针上的限制也确实导致我们不能写出最高效的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Pointer *ArbitraryType</span><br></pre></td></tr></table></figure>

<p>这里的<code>ArbitraryType</code>仅仅是暗示**<code>unsafe.Pointer</code>类型值可以被转换为任意类型安全指针（反之亦然）**。</p>
<p>换句话说，<code>unsafe.Pointer</code>类似于C语言中的<code>void*</code>。</p>
<p>非类型安全指针是指底层类型为<code>unsafe.Pointer</code>的类型。非类型安全指针的零值也使用预声明的<code>nil</code>标识符来表示。</p>
<h2 id="unsafe-Sizeof函数"><a href="#unsafe-Sizeof函数" class="headerlink" title="unsafe.Sizeof函数"></a>unsafe.Sizeof函数</h2><p>Sizeof函数返回操作数在内存中的字节大小（返回该类型所占用的内存大小），参数可以是任意类型的表达式，但是它并不会对表达式进行求值。</p>
<p>一个 Sizeof 函数调用是一个对应 uintptr 类型的常量表达式，因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量。</p>
<p>Sizeof函数可以返回一个类型所占用的内存大小，这个大小只有类型有关，和类型对应的变量存储的内容大小无关，比如bool型占用一个字节、int8也占用一个字节。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(unsafe.Sizeof(<span class="string">&quot;true&quot;</span>))                <span class="comment">// 16</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(<span class="literal">true</span>))                  <span class="comment">// 1</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(<span class="keyword">int8</span>(<span class="number">0</span>)))               <span class="comment">// 1</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(<span class="keyword">int16</span>(<span class="number">10</span>)))             <span class="comment">// 2</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(<span class="keyword">int32</span>(<span class="number">10000000</span>)))       <span class="comment">// 4</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(<span class="keyword">int64</span>(<span class="number">10000000000000</span>))) <span class="comment">// 8</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(<span class="keyword">int</span>(<span class="number">1</span>)))                <span class="comment">// 8</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(<span class="keyword">float64</span>(<span class="number">0</span>)))            <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于整型来说，占用的字节数意味着这个类型存储数字范围的大小，比如int8占用一个字节，也就是8bit，所以它可以存储的大小范围是-128~~127,也就是−2^(n-1)到2^(n-1)−1，n表示bit，int8表示8bit，int16表示16bit，其他以此类推。</p>
<p>对于和平台有关的int类型，这个要看平台是32位还是64位，会取最大的。比如我自己测试，以上输出，会发现int和int64的大小是一样的，因为我的是64位平台的电脑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Sizeof(x ArbitraryType) uintptr</span><br></pre></td></tr></table></figure>

<p>以上是Sizeof的函数定义，它接收一个ArbitraryType类型的参数，返回一个uintptr类型的值。这里的ArbitraryType不用关心，他只是一个占位符，为了文档的考虑导出了该类型，但是一般不会使用它，我们只需要知道它表示任何类型，也就是我们这个函数可以接收任意类型的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ArbitraryType is here for the purposes of documentation only and is not actually</span></span><br><span class="line"><span class="comment">// part of the unsafe package. It represents the type of an arbitrary Go expression.</span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br></pre></td></tr></table></figure>



<h2 id="Alignof-函数"><a href="#Alignof-函数" class="headerlink" title="Alignof 函数"></a>Alignof 函数</h2><p>Alignof返回一个类型的对齐值，也可以叫做对齐系数或者<strong>对齐倍数</strong>。对齐值是一个和内存对齐有关的值，合理的内存对齐可以提高内存读写的性能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> i8 <span class="keyword">int8</span></span><br><span class="line">	<span class="keyword">var</span> i16 <span class="keyword">int16</span></span><br><span class="line">	<span class="keyword">var</span> i64 <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> f32 <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> p *<span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(unsafe.Alignof(b))   <span class="comment">// 1</span></span><br><span class="line">	fmt.Println(unsafe.Alignof(i8))  <span class="comment">// 1</span></span><br><span class="line">	fmt.Println(unsafe.Alignof(i16)) <span class="comment">// 2</span></span><br><span class="line">	fmt.Println(unsafe.Alignof(i64)) <span class="comment">// 8</span></span><br><span class="line">	fmt.Println(unsafe.Alignof(f32)) <span class="comment">// 4</span></span><br><span class="line">	fmt.Println(unsafe.Alignof(s))   <span class="comment">// 8</span></span><br><span class="line">	fmt.Println(unsafe.Alignof(m))   <span class="comment">// 8</span></span><br><span class="line">	fmt.Println(unsafe.Alignof(p))   <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上例子的输出，可以看到，对齐值一般是2^n,最大不会超过8（原因见下面的内存对齐规则）。Alignof的函数定义和Sizeof基本上一样。这里需要注意的是每个人的电脑运行的结果可能不一样，大同小异。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Alignof(x ArbitraryType) uintptr</span><br></pre></td></tr></table></figure>

<p>获取对齐值还可以使用反射包的函数，也就是说：unsafe.Alignof(x)等价于reflect.TypeOf(x).Align()。</p>
<h2 id="Offsetof-函数"><a href="#Offsetof-函数" class="headerlink" title="Offsetof 函数"></a>Offsetof 函数</h2><p>Offsetof函数只适用于struct结构体中的字段相对于结构体的内存位置偏移量。结构体的第一个字段的偏移量都是0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> u1 user1</span><br><span class="line"></span><br><span class="line">	fmt.Println(unsafe.Offsetof(u1.b)) <span class="comment">// 0</span></span><br><span class="line">	fmt.Println(unsafe.Offsetof(u1.i)) <span class="comment">// 4</span></span><br><span class="line">	fmt.Println(unsafe.Offsetof(u1.j)) <span class="comment">// 8</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(u1))     <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	b <span class="keyword">byte</span></span><br><span class="line">	i <span class="keyword">int32</span></span><br><span class="line">	j <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段的偏移量，就是该字段在struct结构体内存布局中的起始位置(内存位置索引从0开始)。</p>
<p>根据字段的偏移量，我们可以定位结构体的字段，进而可以读写该结构体的字段，哪怕他们是私有的。这里可以直接用汇编获取对应偏移量的字段值。</p>
<p>同样也可以用反射表示：</p>
<p>unsafe.Offsetof(u1.i) 等价于 reflect.TypeOf(u1).Field(i).Offset</p>
<h2 id="unsafe的使用"><a href="#unsafe的使用" class="headerlink" title="unsafe的使用"></a>unsafe的使用</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>使用unsafe可以实现类型的转换，下面的例子可以看到i是一个int类型，使用unsafe.Pointer转换成float64并且还修改了指针对应的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">10</span></span><br><span class="line">    ip := &amp;i</span><br><span class="line"></span><br><span class="line">    fp := (*<span class="keyword">float64</span>)(unsafe.Pointer(ip))</span><br><span class="line">    *fp = *fp * <span class="number">3</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： 30</span></span><br></pre></td></tr></table></figure>

<p>但是使用起来要十分的小心，如果使用不当会引发错误。可以举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">10</span></span><br><span class="line">    ip := &amp;i</span><br><span class="line"></span><br><span class="line">    fp := (*<span class="keyword">string</span>)(unsafe.Pointer(ip))</span><br><span class="line">    *fp = <span class="string">&quot;a&quot;</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    <span class="comment">// 结果：19678090</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的误操作就是把int类型转成了string，并且修改了值导致结果出现了错误，并且这种错误</p>
<h3 id="根据位移获取、修改对象的字段"><a href="#根据位移获取、修改对象的字段" class="headerlink" title="根据位移获取、修改对象的字段"></a>根据位移获取、修改对象的字段</h3><p>利用unsafe的Pointer和Offsetof函数，可以获取对象的属性，并且可以修改对象的属性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Student&#123;&#125;</span><br><span class="line">    s.Name = <span class="string">&quot;Peter&quot;</span></span><br><span class="line">    s.Age = <span class="number">33</span></span><br><span class="line"></span><br><span class="line">    pStudent := unsafe.Pointer(&amp;s)</span><br><span class="line">    <span class="comment">// 整个对象转换成指针，默认是获取第一个属性</span></span><br><span class="line">    name := (*<span class="keyword">string</span>)(unsafe.Pointer(pStudent))</span><br><span class="line">    fmt.Println(<span class="string">&quot;name:&quot;</span>, *name) <span class="comment">// name: Peter</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 利用Offsetof获取age属性的偏移量获取属性</span></span><br><span class="line">    age := (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(pStudent) + unsafe.Offsetof(s.Age)))</span><br><span class="line">    fmt.Println(<span class="string">&quot;age:&quot;</span>, *age) <span class="comment">// age: 33</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改指针的值</span></span><br><span class="line">    *name = <span class="string">&quot;Mary&quot;</span></span><br><span class="line">    *age = <span class="number">20</span></span><br><span class="line">    fmt.Println(s) <span class="comment">// &#123;Mary 20&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取私有变量"><a href="#获取私有变量" class="headerlink" title="获取私有变量"></a>获取私有变量</h3><p>可以通过unsafe获取私有变量的值，也可以修改值。这个操作跟上面的获取值是一样的简单的例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Teacher&#123;<span class="string">&quot;ttt&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">    pt := unsafe.Pointer(&amp;t)</span><br><span class="line">    name := (*<span class="keyword">string</span>)(unsafe.Pointer(pt))</span><br><span class="line">    fmt.Println(<span class="string">&quot;name:&quot;</span>, *name) <span class="comment">// name: ttt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="根据sizeof函数获取、修改"><a href="#根据sizeof函数获取、修改" class="headerlink" title="根据sizeof函数获取、修改"></a>根据sizeof函数获取、修改</h3><p>利用unsafe中的sizeof函数获取数组的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    pointer := &amp;array[<span class="number">0</span>]</span><br><span class="line">    fmt.Print(*pointer, <span class="string">&quot; &quot;</span>) <span class="comment">// 0</span></span><br><span class="line">    memoryAddress := <span class="keyword">uintptr</span>(unsafe.Pointer(pointer)) + unsafe.Sizeof(array[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(array)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        pointer = (*<span class="keyword">int</span>)(unsafe.Pointer(memoryAddress))</span><br><span class="line">        fmt.Print(*pointer, <span class="string">&quot; &quot;</span>) <span class="comment">// 1 -2 3 4 </span></span><br><span class="line">        memoryAddress = <span class="keyword">uintptr</span>(unsafe.Pointer(pointer)) + unsafe.Sizeof(array[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，<code>pointer</code>变量指向<code>array[0]</code>的地址，<code>array[0]</code>是整型数组的第一个元素。</li>
<li>接下来指向整数值的<code>pointer</code>变量会传入<code>unsafe.Pointer()</code>方法，然后传入<code>uintptr</code>。最后结果存到了<code>memoryAddress</code>里。</li>
<li><code>unsafe.Sizeof(array[0])</code>是为了去访问下一个数组元素，<strong>这个值是每个元素占的内存大小</strong>。每次for循环遍历，都会把这个值加到<code>memoryAddress</code>上，这样就能获取到下一个数组元素的地址。<code>*pointer</code>的*符号对指针进行解引用，然后返回了所存的整数值。</li>
</ol>
<h2 id="内存对齐详解"><a href="#内存对齐详解" class="headerlink" title="内存对齐详解"></a>内存对齐详解</h2><h3 id="struct-字段顺序不同，最终大小可能不同"><a href="#struct-字段顺序不同，最终大小可能不同" class="headerlink" title="struct 字段顺序不同，最终大小可能不同"></a>struct 字段顺序不同，最终大小可能不同</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Part1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">bool</span></span><br><span class="line">    b <span class="keyword">int32</span></span><br><span class="line">    c <span class="keyword">int8</span></span><br><span class="line">    d <span class="keyword">int64</span></span><br><span class="line">    e <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下 Part1 共占用的大小是多少呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;bool size: %d\n&quot;</span>, unsafe.Sizeof(<span class="keyword">bool</span>(<span class="literal">true</span>))) <span class="comment">// bool size: 1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;int32 size: %d\n&quot;</span>, unsafe.Sizeof(<span class="keyword">int32</span>(<span class="number">0</span>))) <span class="comment">// int32 size: 4</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;int8 size: %d\n&quot;</span>, unsafe.Sizeof(<span class="keyword">int8</span>(<span class="number">0</span>))) <span class="comment">// int8 size: 1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;int64 size: %d\n&quot;</span>, unsafe.Sizeof(<span class="keyword">int64</span>(<span class="number">0</span>))) <span class="comment">// int64 size: 8</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;byte size: %d\n&quot;</span>, unsafe.Sizeof(<span class="keyword">byte</span>(<span class="number">0</span>))) <span class="comment">// byte size: 1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;string size: %d\n&quot;</span>, unsafe.Sizeof(<span class="string">&quot;EDDYCJY&quot;</span>)) <span class="comment">// string size: 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你也许就会得出这个结果：</p>
<p>Part1 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p>
<p>但是实际答案却是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Part1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">bool</span></span><br><span class="line">    b <span class="keyword">int32</span></span><br><span class="line">    c <span class="keyword">int8</span></span><br><span class="line">    d <span class="keyword">int64</span></span><br><span class="line">    e <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    part1 := Part1&#123;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;part1 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(part1), unsafe.Alignof(part1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part1 size: 32, align: 8</span><br></pre></td></tr></table></figure>

<p>最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。这充分地说明了先前的计算方式是错误的。为什么呢？</p>
<p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算，接下来我们详细的讲讲它是什么</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放</p>
<p><img src="/images/68747470733a2f2f692e696d6775722e636f6d2f535a48514a4b372e706e67.png" alt="image"></p>
<p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。</p>
<p>相反 CPU 读取内存是一块一块读取的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为<strong>内存访问粒度</strong>。如下图：</p>
<p><img src="/images/68747470733a2f2f692e696d6775722e636f6d2f6d43465a5765382e706e67.png" alt="image"></p>
<p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p>
<h3 id="为什么要关心对齐？"><a href="#为什么要关心对齐？" class="headerlink" title="为什么要关心对齐？"></a>为什么要关心对齐？</h3><ul>
<li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li>
<li>你正在处理向量方面的指令</li>
<li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li>
</ul>
<h3 id="为什么要做对齐"><a href="#为什么要做对齐" class="headerlink" title="为什么要做对齐"></a>为什么要做对齐</h3><ul>
<li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</li>
<li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</li>
</ul>
<p><img src="/images/68747470733a2f2f692e696d6775722e636f6d2f6731527855547a2e706e67.png" alt="image"></p>
<p>在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：</p>
<ul>
<li>CPU 首次读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li>
<li>CPU 再次读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li>
<li>合并 1-4 字节的数据</li>
<li>合并后放入寄存器</li>
</ul>
<p>从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作</p>
<p>而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的<strong>空间换时间做法</strong>。</p>
<blockquote>
<p>CPU看待内存是以block为单位的，就像是linux下文件大小的单位IO block为4096一样，是一种牺牲空间换取时间的做法.</p>
</blockquote>
<p><img src="/images/image-20210604170227503.png" alt="image-20210604170227503"></p>
<h3 id="默认对齐系数"><a href="#默认对齐系数" class="headerlink" title="默认对齐系数"></a>默认对齐系数</h3><p>在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 #pragma pack(n) 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：</p>
<ul>
<li>32 位：4</li>
<li>64 位：8</li>
</ul>
<p>另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p>
<h3 id="成员对齐"><a href="#成员对齐" class="headerlink" title="成员对齐"></a>成员对齐</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;bool align: %d\n&quot;</span>, unsafe.Alignof(<span class="keyword">bool</span>(<span class="literal">true</span>))) <span class="comment">// bool align: 1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;int32 align: %d\n&quot;</span>, unsafe.Alignof(<span class="keyword">int32</span>(<span class="number">0</span>))) <span class="comment">// int32 align: 4</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;int8 align: %d\n&quot;</span>, unsafe.Alignof(<span class="keyword">int8</span>(<span class="number">0</span>))) <span class="comment">// int8 align: 1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;int64 align: %d\n&quot;</span>, unsafe.Alignof(<span class="keyword">int64</span>(<span class="number">0</span>))) <span class="comment">// int64 align: 8</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;byte align: %d\n&quot;</span>, unsafe.Alignof(<span class="keyword">byte</span>(<span class="number">0</span>))) <span class="comment">// byte align: 1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;string align: %d\n&quot;</span>, unsafe.Alignof(<span class="string">&quot;EDDYCJY&quot;</span>)) <span class="comment">// string align: 8</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;map align: %d\n&quot;</span>, unsafe.Alignof(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;)) <span class="comment">// map align: 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 unsafe.Alignof 是用来来返回相应类型的对齐系数，上面已经说了。</p>
<p>通过观察输出结果，可得知基本都是 2^n，最大也不会超过 8。这是因为我本机（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p>
<h3 id="整体对齐-（结构体本身也要对齐）"><a href="#整体对齐-（结构体本身也要对齐）" class="headerlink" title="整体对齐 （结构体本身也要对齐）"></a>整体对齐 （结构体本身也要对齐）</h3><p>上面提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的。</p>
<h3 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h3><ul>
<li>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（#pragma pack(n)）或当前成员变量类型的长度（unsafe.Sizeof），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍</li>
<li>结构体本身，对齐值必须为编译器默认对齐长度（#pragma pack(n)）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值</li>
<li>结合以上两点，可得知若编译器默认对齐长度（#pragma pack(n)）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li>
</ul>
<p>换个说法就是：</p>
<ul>
<li>对于具体类型来说，对齐值=<code>min(编译器默认对齐值，类型大小Sizeof长度)</code>。也就是在默认设置的对齐值和类型的内存占用大小之间，取最小值为该类型的对齐值。我的电脑默认是8，所以最大值不会超过8.</li>
<li>struct在每个字段都内存对齐之后，其本身也要进行对齐，对齐值=<code>min(默认对齐值，字段最大类型长度)</code>。这条也很好理解，struct的所有字段中，最大的那个类型的长度以及默认对齐值之间，取最小的那个。</li>
</ul>
<h3 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Part1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">bool</span></span><br><span class="line">    b <span class="keyword">int32</span></span><br><span class="line">    c <span class="keyword">int8</span></span><br><span class="line">    d <span class="keyword">int64</span></span><br><span class="line">    e <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">成员变量</th>
<th align="left">类型</th>
<th align="left">偏移量</th>
<th align="left">自身占用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="left">bool</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">字节对齐</td>
<td align="left">无</td>
<td align="left">1</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">int32</td>
<td align="left">4</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">int8</td>
<td align="left">8</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">字节对齐</td>
<td align="left">无</td>
<td align="left">9</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">int64</td>
<td align="left">16</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">byte</td>
<td align="left">24</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">字节对齐</td>
<td align="left">无</td>
<td align="left">25</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">总占用大小</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">32</td>
</tr>
</tbody></table>
<ul>
<li>第一个成员 a<ul>
<li>类型为 bool</li>
<li>对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 b<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb</li>
</ul>
</li>
<li>第三个成员 c<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c…</li>
</ul>
</li>
<li>第四个成员 d<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd</li>
</ul>
</li>
<li>第五个成员 e<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e…</li>
</ul>
</li>
</ul>
<p>整体对齐：</p>
<p>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 2^n，不是偶数倍。显然不符合对齐的规则</p>
<p>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</p>
<p>结果：</p>
<p>Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p>
<blockquote>
<p>其中xxx表示为 “内存空洞”。</p>
<p><strong>内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响</strong></p>
</blockquote>
<h2 id="推论字段顺序可改变结构体大小"><a href="#推论字段顺序可改变结构体大小" class="headerlink" title="推论字段顺序可改变结构体大小"></a>推论字段顺序可改变结构体大小</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Part1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">bool</span></span><br><span class="line">    b <span class="keyword">int32</span></span><br><span class="line">    c <span class="keyword">int8</span></span><br><span class="line">    d <span class="keyword">int64</span></span><br><span class="line">    e <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Part2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    e <span class="keyword">byte</span></span><br><span class="line">    c <span class="keyword">int8</span></span><br><span class="line">    a <span class="keyword">bool</span></span><br><span class="line">    b <span class="keyword">int32</span></span><br><span class="line">    d <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    part1 := Part1&#123;&#125;</span><br><span class="line">    part2 := Part2&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;part1 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(part1), unsafe.Alignof(part1))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;part2 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(part2), unsafe.Alignof(part2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// part1 size: 32, align: 8</span></span><br><span class="line"><span class="comment">// part2 size: 16, align: 8</span></span><br></pre></td></tr></table></figure>

<p>分析过程和上面完全一样。</p>
<p><img src="/images/image-20210604170848857.png" alt="image-20210604170848857"></p>
<p>根据上图，我们就明白了，在结构体编写中存在内存对齐的概念，而且我们应该小心，尽可能的避免因内存对齐导致结构体大小增大，在书写过程中应该让小字节的变量挨着。</p>
<h2 id="示例：修改struct成员"><a href="#示例：修改struct成员" class="headerlink" title="示例：修改struct成员"></a>示例：修改struct成员</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> V <span class="keyword">struct</span> &#123;</span><br><span class="line">	i <span class="keyword">int32</span></span><br><span class="line">	j <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v V)</span> <span class="title">GetI</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;i=%d\n&quot;</span>, v.i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v V)</span> <span class="title">GetJ</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;j=%d\n&quot;</span>, v.j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUnsafe2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义指针类型变量</span></span><br><span class="line">	<span class="keyword">var</span> v *V = &amp;V&#123;<span class="number">199</span>, <span class="number">299</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取得v的指针并转为*int32的值，对应结构体的i。</span></span><br><span class="line">	<span class="keyword">var</span> i *<span class="keyword">int32</span> = (*<span class="keyword">int32</span>)(unsafe.Pointer(v))</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;指针地址：&quot;</span>, i) <span class="comment">// 指针地址： 0xc00000c180</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;指针uintptr值:&quot;</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(i))) <span class="comment">// 指针uintptr值: 824633770368</span></span><br><span class="line">	*i = <span class="keyword">int32</span>(<span class="number">98</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据v的基准地址加上偏移量进行指针运算，运算后的值为j的地址，使用unsafe.Pointer转为指针</span></span><br><span class="line">	<span class="keyword">var</span> j *<span class="keyword">int64</span> = (*<span class="keyword">int64</span>)(</span><br><span class="line">		unsafe.Pointer(</span><br><span class="line">			<span class="keyword">uintptr</span>(unsafe.Pointer(v)) + <span class="keyword">uintptr</span>(unsafe.Sizeof(<span class="keyword">int64</span>(<span class="number">0</span>))),</span><br><span class="line">		),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	*j = <span class="keyword">int64</span>(<span class="number">763</span>)</span><br><span class="line"></span><br><span class="line">	v.GetI() <span class="comment">// i=98</span></span><br><span class="line">	v.GetJ() <span class="comment">// j=763</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>要修改struct字段的值，需要提前知道结构体V的成员布局，然后<strong>根据字段计算偏移量，以及考虑对齐值</strong>，最后通过指针运算得到成员指针，利用指针达到修改成员值得目的。</li>
<li>由于<strong>结构体的成员在内存中的分配是一段连续的内存</strong>，因此结构体中第一个成员的地址就是这个结构体的地址，我们也可以认为是相对于这个结构体偏移了0。相同的，这个结构体中的任一成员都可以相对于这个结构体的偏移来计算出它在内存中的绝对地址。</li>
</ul>
<p>具体来讲解下main方法的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v *V = &amp;V&#123;<span class="number">199</span>, <span class="number">299</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过&amp;来分配一段内存</strong>(并按类型初始化)，返回一个指针。所以v就是类型为V的一个指针。和new函数的作用类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i *<span class="keyword">int32</span> = (*<span class="keyword">int32</span>)(unsafe.Pointer(v))</span><br></pre></td></tr></table></figure>

<p>将指针v转成通用指针，再转成int32指针类型。这里就看到了unsafe.Pointer的作用了，<strong>您不能直接将v转成int32类型的指针，那样将会panic，但是unsafe.Pointer是可以转为任何指针</strong>。</p>
<p>刚才说了v的地址其实就是它的第一个成员的地址，所以这个i就很显然指向了v的成员i，通过给i赋值就相当于给v.i赋值了，但是别忘了i只是个指针，要赋值得解引用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*i = <span class="keyword">int32</span>(<span class="number">98</span>)</span><br></pre></td></tr></table></figure>

<p>现在已经成功的改变了v的私有成员i的值。</p>
<p>但是对于v.j来说，怎么来得到它在内存中的地址呢？其实<strong>我们可以获取它相对于v的偏移量</strong>(unsafe.Sizeof可以为我们做这个事)，但上面的代码并没有这样去实现。各位别急，一步步来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j *<span class="keyword">int64</span> = (*<span class="keyword">int64</span>)(</span><br><span class="line">  unsafe.Pointer(</span><br><span class="line">    <span class="keyword">uintptr</span>(unsafe.Pointer(v)) + <span class="keyword">uintptr</span>(unsafe.Sizeof(<span class="keyword">int64</span>(<span class="number">0</span>))),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其实我们已经知道v是有两个成员的，包括i和j，并且在定义中，i位于j的前面，而i是int32类型，也就是说i占4个字节。所以<strong>j是相对于v偏移了4个字节</strong>。您可以用uintptr(4)或uintptr(unsafe.Sizeof(int64(0)))来做这个事。<strong>unsafe.Sizeof方法用来得到一个值应该占用多少个字节空间</strong>。注意这里跟C的用法不一样，C是直接传入类型，而Go 语言是传入值。</p>
<p>之所以转成uintptr类型是因为需要做指针运算。v的地址加上<code>j相对于v的偏移地址</code>，也就得到了v.j在内存中的绝对地址，然后通过unsafe.Pointer转为指针，别忘了j的类型是int64，所以现在的j就是一个指向v.j的指针，接下来给它赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*j = <span class="keyword">int64</span>(<span class="number">763</span>)</span><br></pre></td></tr></table></figure>

<p>另外，我们可以看到两种地址表示上的差异：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指针地址： <span class="number">0xc00000c180</span></span><br><span class="line">指针<span class="keyword">uintptr</span>值: <span class="number">824633770368</span></span><br></pre></td></tr></table></figure>



<h2 id="示例：修改struct成员2"><a href="#示例：修改struct成员2" class="headerlink" title="示例：修改struct成员2"></a>示例：修改struct成员2</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="keyword">struct</span> &#123;</span><br><span class="line">        a <span class="keyword">byte</span></span><br><span class="line">        b <span class="keyword">byte</span></span><br><span class="line">        c <span class="keyword">byte</span></span><br><span class="line">        d <span class="keyword">int64</span></span><br><span class="line">    &#125;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结构体指针转换为通用指针</span></span><br><span class="line">    p := unsafe.Pointer(&amp;s)</span><br><span class="line">    <span class="comment">// 保存结构体的地址备用（偏移量为 0）</span></span><br><span class="line">    up0 := <span class="keyword">uintptr</span>(p)</span><br><span class="line">    <span class="comment">// 将通用指针转换为 byte 型指针</span></span><br><span class="line">    pb := (*<span class="keyword">byte</span>)(p)</span><br><span class="line">    <span class="comment">// 给转换后的指针赋值</span></span><br><span class="line">    *pb = <span class="number">10</span></span><br><span class="line">    <span class="comment">// 结构体内容跟着改变</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偏移到第 2 个字段</span></span><br><span class="line">    up := up0 + unsafe.Offsetof(s.b)</span><br><span class="line">    <span class="comment">// 将偏移后的地址转换为通用指针</span></span><br><span class="line">    p = unsafe.Pointer(up)</span><br><span class="line">    <span class="comment">// 将通用指针转换为 byte 型指针</span></span><br><span class="line">    pb = (*<span class="keyword">byte</span>)(p)</span><br><span class="line">    <span class="comment">// 给转换后的指针赋值</span></span><br><span class="line">    *pb = <span class="number">20</span></span><br><span class="line">    <span class="comment">// 结构体内容跟着改变</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偏移到第 3 个字段</span></span><br><span class="line">    up = up0 + unsafe.Offsetof(s.c)</span><br><span class="line">    <span class="comment">// 将偏移后的地址转换为通用指针</span></span><br><span class="line">    p = unsafe.Pointer(up)</span><br><span class="line">    <span class="comment">// 将通用指针转换为 byte 型指针</span></span><br><span class="line">    pb = (*<span class="keyword">byte</span>)(p)</span><br><span class="line">    <span class="comment">// 给转换后的指针赋值</span></span><br><span class="line">    *pb = <span class="number">30</span></span><br><span class="line">    <span class="comment">// 结构体内容跟着改变</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偏移到第 4 个字段</span></span><br><span class="line">    up = up0 + unsafe.Offsetof(s.d)</span><br><span class="line">    <span class="comment">// 将偏移后的地址转换为通用指针</span></span><br><span class="line">    p = unsafe.Pointer(up)</span><br><span class="line">    <span class="comment">// 将通用指针转换为 int64 型指针</span></span><br><span class="line">    pi := (*<span class="keyword">int64</span>)(p)</span><br><span class="line">    <span class="comment">// 给转换后的指针赋值</span></span><br><span class="line">    *pi = <span class="number">40</span></span><br><span class="line">    <span class="comment">// 结构体内容跟着改变</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="示例：struct对齐值"><a href="#示例：struct对齐值" class="headerlink" title="示例：struct对齐值"></a>示例：struct对齐值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> V <span class="keyword">struct</span> &#123;</span><br><span class="line">    b <span class="keyword">byte</span></span><br><span class="line">    i <span class="keyword">int32</span></span><br><span class="line">    j <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v V)</span> <span class="title">GetI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;i=%d\n&quot;</span>, v.i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v V)</span> <span class="title">GetJ</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;j=%d\n&quot;</span>, v.j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义指针类型变量</span></span><br><span class="line">    <span class="keyword">var</span> v *V = <span class="built_in">new</span>(V)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v的长度</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;size=%d\n&quot;</span>, unsafe.Sizeof(*v)) <span class="comment">// size=16</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 取得v的指针考虑对齐值计算偏移量，然后转为*int32的值，对应结构体的i。</span></span><br><span class="line">    <span class="keyword">var</span> i *<span class="keyword">int32</span> = (*<span class="keyword">int32</span>)(</span><br><span class="line">    	unsafe.Pointer(</span><br><span class="line">      	<span class="keyword">uintptr</span>(unsafe.Pointer(v)) + <span class="keyword">uintptr</span>(<span class="number">4</span>*unsafe.Sizeof(<span class="keyword">byte</span>(<span class="number">0</span>)))</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;指针地址：&quot;</span>, i) <span class="comment">// 指针地址： 0xc000050084</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;指针uintptr值:&quot;</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(i))) <span class="comment">// 指针uintptr值: 824634048644</span></span><br><span class="line">    *i = <span class="keyword">int32</span>(<span class="number">98</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据v的基准地址加上偏移量进行指针运算，运算后的值为j的地址，使用unsafe.Pointer转为指针</span></span><br><span class="line">    <span class="keyword">var</span> j *<span class="keyword">int64</span> = (*<span class="keyword">int64</span>)(</span><br><span class="line">    	unsafe.Pointer(</span><br><span class="line">      	<span class="keyword">uintptr</span>(unsafe.Pointer(v)) + <span class="keyword">uintptr</span>(unsafe.Sizeof(<span class="keyword">int64</span>(<span class="number">0</span>)))</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    *j = <span class="keyword">int64</span>(<span class="number">763</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;指针uintptr值:&quot;</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v.b))) <span class="comment">// 指针uintptr值: 824634048640</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;指针uintptr值:&quot;</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v.i))) <span class="comment">// 指针uintptr值: 824634048644</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;指针uintptr值:&quot;</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v.j))) <span class="comment">// 指针uintptr值: 824634048648</span></span><br><span class="line">    v.GetI() <span class="comment">// i=98</span></span><br><span class="line">    v.GetJ() <span class="comment">// j=763</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新结构体的长度为size=16，好像跟我们想像的不一致。我们计算一下：b是byte类型，占1个字节；i是int32类型，占4个字节；j是int64类型，占8个字节，1+4+8=13。这是怎么回事呢？</p>
<p>这是因为发生了对齐。<strong>在struct中，它的对齐值是它的成员中的最大对齐值。</strong></p>
<p>每个成员类型都有它的对齐值，可以用unsafe.Alignof方法来计算，比如unsafe.Alignof(v.b)就可以得到b的对齐值为1 。但这个对齐值是其值类型的长度或引用的地址长度（32位或者64位），和其在结构体中的size不是简单相加的问题。经过在64位机器上测试，发现地址（uintptr）如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsafe.Pointer(b): %s <span class="number">824634048640</span></span><br><span class="line">unsafe.Pointer(i): %s <span class="number">824634048644</span></span><br><span class="line">unsafe.Pointer(j): %s <span class="number">824634048648</span></span><br></pre></td></tr></table></figure>

<p>可以初步推断，也经过测试验证，取i值使用uintptr(4*unsafe.Sizeof(byte(0)))是准确的。至于size其实也和对齐值有关，也不是简单相加每个字段的长度。</p>
<p>unsafe.Offsetof 可以在实际中使用，如果改变私有的字段，需要程序员认真考虑后，按照上面的方法仔细确认好对齐值再进行操作。</p>
<h2 id="示例：配合reflect"><a href="#示例：配合reflect" class="headerlink" title="示例：配合reflect"></a>示例：配合reflect</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 strings 包中的 Reader 对象</span></span><br><span class="line">    <span class="comment">// 它有三个私有字段：s string、i int64、prevRune int</span></span><br><span class="line">    sr := strings.NewReader(<span class="string">&quot;abcdef&quot;</span>)</span><br><span class="line">    <span class="comment">// 此时 sr 中的成员是无法修改的</span></span><br><span class="line">    fmt.Println(sr)</span><br><span class="line">    <span class="comment">// 但是我们可以通过 unsafe 来进行修改</span></span><br><span class="line">    <span class="comment">// 先将其转换为通用指针</span></span><br><span class="line">    p := unsafe.Pointer(sr)</span><br><span class="line">    <span class="comment">// 获取结构体地址</span></span><br><span class="line">    up0 := <span class="keyword">uintptr</span>(p)</span><br><span class="line">    <span class="comment">// 确定要修改的字段（这里不能用 unsafe.Offsetof 获取偏移量，因为是私有字段）</span></span><br><span class="line">    <span class="keyword">if</span> sf, ok := reflect.TypeOf(*sr).FieldByName(<span class="string">&quot;i&quot;</span>); ok &#123;</span><br><span class="line">        <span class="comment">// 偏移到指定字段的地址</span></span><br><span class="line">        up := up0 + sf.Offset</span><br><span class="line">        <span class="comment">// 转换为通用指针</span></span><br><span class="line">        p = unsafe.Pointer(up)</span><br><span class="line">        <span class="comment">// 转换为相应类型的指针</span></span><br><span class="line">        pi := (*<span class="keyword">int64</span>)(p)</span><br><span class="line">        <span class="comment">// 对指针所指向的内容进行修改</span></span><br><span class="line">        *pi = <span class="number">3</span> <span class="comment">// 修改索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看看修改结果</span></span><br><span class="line">    fmt.Println(sr)</span><br><span class="line">    <span class="comment">// 看看读出的是什么</span></span><br><span class="line">    b, err := sr.ReadByte()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c, %v\n&quot;</span>, b, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>