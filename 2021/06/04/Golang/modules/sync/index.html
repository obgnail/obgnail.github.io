<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="尽管 Golang 推荐通过 channel 进行通信和同步，但在实际开发中 sync 包用得也非常的多。另外 sync 下还有一个 atomic 包，提供了一些底层的原子操作"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>sync | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-06-04</div></div></div><div class="container post-header"><h1>sync</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#sync"><span class="toc-number">1.</span> <span class="toc-text">sync</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-Mutex"><span class="toc-number">1.1.</span> <span class="toc-text">互斥锁 Mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-RWMutex"><span class="toc-number">1.2.</span> <span class="toc-text">读写锁 RWMutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine%E7%AD%89%E5%BE%85%E7%BB%84-WaitGroup"><span class="toc-number">1.3.</span> <span class="toc-text">goroutine等待组 WaitGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-Cond"><span class="toc-number">1.4.</span> <span class="toc-text">条件变量 Cond</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1-Once"><span class="toc-number">1.5.</span> <span class="toc-text">执行一次 Once</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%B1%A0-Pool"><span class="toc-number">1.6.</span> <span class="toc-text">临时对象池 Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%98%A0%E5%B0%84-sync-Map"><span class="toc-number">1.7.</span> <span class="toc-text">安全映射 sync.Map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-atomic"><span class="toc-number">2.</span> <span class="toc-text">sync.atomic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E6%94%AF%E6%8C%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">Go支持的原子操作概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">整数原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%80%BC%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">指针值的原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.</span> <span class="toc-text">任何类型值的原子操作</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>尽管 Golang 推荐通过 channel 进行通信和同步，但在实际开发中 sync 包用得也非常的多。另外 sync 下还有一个 atomic 包，提供了一些底层的原子操作</p>
<p>整个包都围绕这 Locker 进行，这是一个 interface：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">  Lock()</span><br><span class="line">  Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><h3 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h3><p>互斥锁是锁的一种具体实现，有两个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>在首次使用后不要复制该互斥锁。对一个未锁定的互斥锁解锁将会产生运行时错误。</p>
<p><strong>一个互斥锁只能同时被一个 goroutine 锁定，其它 goroutine 将阻塞直到互斥锁被解锁</strong>（重新争抢对互斥锁的锁定）。如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> l sync.Mutex</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        l.Lock()</span><br><span class="line">        <span class="keyword">defer</span> l.Unlock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine1: 我会锁定大概 2s&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine1: 我解锁了，你们去抢吧&quot;</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;groutine2: 等待解锁&quot;</span>)</span><br><span class="line">        l.Lock()</span><br><span class="line">        <span class="keyword">defer</span> l.Unlock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine2: 哈哈，我锁定了&quot;</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 goroutine 执行结束</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，平时所说的<strong>锁定，其实就是去锁定互斥锁，而不是说去锁定一段代码</strong>。</p>
<p>也就是说，当代码执行到有锁的地方时，它获取不到互斥锁的锁定，会阻塞在那里，从而达到控制同步的目的。</p>
</blockquote>
<h3 id="读写锁-RWMutex"><a href="#读写锁-RWMutex" class="headerlink" title="读写锁 RWMutex"></a>读写锁 RWMutex</h3><p>读写锁是针对读写操作的互斥锁，读写锁与互斥锁最大的不同就是可以分别对 <code>读</code>、<code>写</code> 进行锁定。一般用在大量读操作、少量写操作的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>由于这里需要区分读写锁定，我们这样定义：</p>
<ul>
<li>读锁定（RLock），对读操作进行锁定</li>
<li>读解锁（RUnlock），对读锁定进行解锁</li>
<li>写锁定（Lock），对写操作进行锁定</li>
<li>写解锁（Unlock），对写锁定进行解锁</li>
</ul>
<p>在首次使用之后，不要复制该读写锁。不要混用锁定和解锁，如：Lock 和 RUnlock、RLock 和 Unlock。因为对未读锁定的读写锁进行读解锁或对未写锁定的读写锁进行写解锁将会引起运行时错误。</p>
<p>如何理解读写锁呢？</p>
<ol>
<li>同时只能有一个 goroutine 能够获得写锁定。</li>
<li>同时可以有任意多个 gorouinte 获得读锁定。</li>
<li>同时只能存在写锁定或读锁定（读和写互斥）。</li>
</ol>
<blockquote>
<p>也就是说:</p>
<ul>
<li>当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；</li>
<li>当有一个 goroutine 获得读锁定，其它读锁定任然可以继续；</li>
<li>当有一个或任意多个读锁定，写锁定将等待<strong>所有</strong>读锁定解锁之后才能够进行写锁定。</li>
</ul>
<p>所以说这里的读锁定（RLock）目的其实是告诉写锁定：有很多人正在读取数据，你给我站一边去，等它们读（读解锁）完你再来写（写锁定）。</p>
</blockquote>
<p>使用例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> rw sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> read(i, ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> write(i, ch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(n <span class="keyword">int</span>, ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    rw.RLock()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine %d 进入读操作...\n&quot;</span>, n)</span><br><span class="line">    v := count</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine %d 读取结束，值为：%d\n&quot;</span>, n, v)</span><br><span class="line">    rw.RUnlock()</span><br><span class="line">    ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(n <span class="keyword">int</span>, ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    rw.Lock()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine %d 进入写操作...\n&quot;</span>, n)</span><br><span class="line">    v := rand.Intn(<span class="number">1000</span>)</span><br><span class="line">    count = v</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine %d 写入结束，新值为：%d\n&quot;</span>, n, v)</span><br><span class="line">    rw.Unlock()</span><br><span class="line">    ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="goroutine等待组-WaitGroup"><a href="#goroutine等待组-WaitGroup" class="headerlink" title="goroutine等待组 WaitGroup"></a>goroutine等待组 WaitGroup</h3><p>WaitGroup 用于等待一组 goroutine 结束，用法很简单。它有三个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>Add 用来添加 goroutine 的个数。Done 执行一次数量减 1。Wait 用来等待结束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 计数加 1</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 计数减 1</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            time.Sleep(time.Second * time.Duration(i))</span><br><span class="line">            fmt.Printf(<span class="string">&quot;goroutine%d 结束\n&quot;</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待执行结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;所有 goroutine 执行结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>wg.Add()</code> 方法一定要在 goroutine 开始前执行哦。</p>
<h3 id="条件变量-Cond"><a href="#条件变量-Cond" class="headerlink" title="条件变量 Cond"></a>条件变量 Cond</h3><p>Cond 实现一个条件变量，即等待或宣布事件发生的 goroutines 的会合点，它会保存一个通知列表。基本思想是当某中状态达成，goroutine 将会等待（Wait）在那里，当某个时刻状态改变时通过通知的方式（Broadcast，Signal）的方式通知等待的 goroutine。这样，不满足条件的 goroutine 唤醒继续向下执行，满足条件的重新进入等待序列。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line">  </span><br><span class="line">    notify  notifyList <span class="comment">// 通知列表</span></span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>Wait 方法、Signal 方法和 Broadcast 方法。它们分别代表了等待通知、单发通知和广播通知的操作。</p>
<p>我们来看一下 Wait 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的操作为：加入到通知列表 -&gt; 解锁 L -&gt; 等待通知 -&gt; 锁定 L。其使用方法是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition() &#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">&#125;</span><br><span class="line">... <span class="built_in">make</span> use of condition ...</span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure>



<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建 cond</span></span><br><span class="line">    <span class="keyword">var</span> l sync.Mutex</span><br><span class="line">    cond := sync.NewCond(&amp;l)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 争抢互斥锁的锁定</span></span><br><span class="line">            cond.L.Lock()</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            &#125;()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 条件是否达成</span></span><br><span class="line">            <span class="keyword">for</span> count &gt; i &#123;</span><br><span class="line">                cond.Wait()</span><br><span class="line">                fmt.Printf(<span class="string">&quot;收到一个通知 goroutine%d\n&quot;</span>, i)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fmt.Printf(<span class="string">&quot;goroutine%d 执行结束\n&quot;</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保所有 goroutine 启动完成</span></span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 锁定一下</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;broadcast...&quot;</span>)</span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    count -= <span class="number">1</span></span><br><span class="line">    cond.Broadcast()</span><br><span class="line">    cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;signal...&quot;</span>)</span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    count -= <span class="number">2</span></span><br><span class="line">    cond.Signal()</span><br><span class="line">    cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;broadcast...&quot;</span>)</span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    count -= <span class="number">1</span></span><br><span class="line">    cond.Broadcast()</span><br><span class="line">    cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="执行一次-Once"><a href="#执行一次-Once" class="headerlink" title="执行一次 Once"></a>执行一次 Once</h3><p>使用 <code>sync.Once</code> 对象可以使得函数多次调用只执行一次。其结构为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    m    Mutex</span><br><span class="line">    done <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>

<p>用 done 来记录执行次数，用 m 来保证保证仅被执行一次。只有一个 Do 方法，调用执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            once.Do(onceBody)</span><br><span class="line">            done &lt;- <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 打印结果</span><br><span class="line">Only once</span><br></pre></td></tr></table></figure>





<h3 id="临时对象池-Pool"><a href="#临时对象池-Pool" class="headerlink" title="临时对象池 Pool"></a>临时对象池 Pool</h3><p><code>sync.Pool</code> 可以作为<strong>临时对象的保存和复用</strong>的集合。</p>
<blockquote>
<p>个人觉得它的名字有一定的误导性，因为 Pool 里装的<strong>对象可以被无通知地被回收</strong>，可能 <code>sync.Cache</code> 是一个更合适的名字。</p>
</blockquote>
<p>作用：</p>
<ul>
<li>对于很多需要重复分配、回收内存的地方，<code>sync.Pool</code> 是一个很好的选择。</li>
<li>频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，</li>
<li>而 <code>sync.Pool</code> 可以<strong>将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存</strong>，减轻 GC 的压力，提升系统的性能。</li>
</ul>
<p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。<strong>使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</strong>因此关键思想就是对象的复用，避免重复创建、销毁。</p>
<blockquote>
<p>适用场景：</p>
<p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。</p>
<p>在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p>
</blockquote>
<p>其结构为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal</span></span><br><span class="line">    localSize <span class="keyword">uintptr</span>        <span class="comment">// size of the local array</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// New optionally specifies a function to generate</span></span><br><span class="line">    <span class="comment">// a value when Get would otherwise return nil.</span></span><br><span class="line">    <span class="comment">// It may not be changed concurrently with calls to Get.</span></span><br><span class="line">    New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>新建 Pool 需要提供一个 New 方法，目的是当获取不到临时对象时自动创建一个（不会主动加入到 Pool 中），Get 和 Put 方法都很好理解。</strong></p>
<blockquote>
<p>深入了解过 Go 的同学应该知道，Go 的重要组成结构为 M、P、G。</p>
<p>Pool 实际上会为每一个操作它的 goroutine 相关联的 P 都生成一个本地池。如果从本地池 Get 对象的时候，本地池没有，则会从其它的 P 本地池获取。因此，Pool 的一个特点就是：可以把由其中的对象值产生的存储压力进行分摊。</p>
</blockquote>
<p>它有着以下特点：</p>
<ul>
<li>Pool 中的对象在仅有 Pool 有着唯一索引的情况下可能会被自动删除（取决于下一次 GC 执行的时间）。</li>
<li><strong>goroutines 协程安全，可以同时被多个协程使用</strong>。</li>
</ul>
<blockquote>
<p>GC 的执行一般会使 Pool 中的对象全部移除。</p>
</blockquote>
<p>那么 Pool 都适用于什么场景呢？从它的特点来说，适用与无状态的对象的复用，而不适用与如连接池之类的。在 fmt 包中有一个很好的使用池的例子，它维护一个动态大小的临时输出缓冲区。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool *sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initPool</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pool = &amp;sync.Pool &#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Creating a new Person&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">new</span>(Person)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	initPool()</span><br><span class="line"></span><br><span class="line">	p := pool.Get().(*Person)</span><br><span class="line">	fmt.Println(<span class="string">&quot;首次从 pool 里获取：&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">	p.Name = <span class="string">&quot;first&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;设置 p.Name = %s\n&quot;</span>, p.Name)</span><br><span class="line"></span><br><span class="line">	pool.Put(p)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Pool 里已有一个对象：&amp;&#123;first&#125;，调用 Get: &quot;</span>, pool.Get().(*Person))</span><br><span class="line">	fmt.Println(<span class="string">&quot;Pool 没有对象了，调用 Get: &quot;</span>, pool.Get().(*Person))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output：</span></span><br><span class="line"><span class="comment">// Creating a new Person</span></span><br><span class="line"><span class="comment">// 首次从 pool 里获取： &amp;&#123;&#125;</span></span><br><span class="line"><span class="comment">// 设置 p.Name = first</span></span><br><span class="line"><span class="comment">// Pool 里已有一个对象：&amp;&#123;first&#125;，Get:  &amp;&#123;first&#125;</span></span><br><span class="line"><span class="comment">// Creating a new Person</span></span><br><span class="line"><span class="comment">// Pool 没有对象了，Get:  &amp;&#123;&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="安全映射-sync-Map"><a href="#安全映射-sync-Map" class="headerlink" title="安全映射 sync.Map"></a>安全映射 sync.Map</h3><p>在Go 1.6之前， 内置的map类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会报错，这在一些知名的开源库中都存在这个问题，所以go 1.9之前的解决方案是额外绑定一个锁，封装成一个新的struct或者单独使用锁都可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">      sync.RWMutex</span><br><span class="line">      m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">  &#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line"></span><br><span class="line">  counter.RLock()</span><br><span class="line">  n := counter.m[<span class="string">&quot;some_key&quot;</span>]</span><br><span class="line">  counter.RUnlock()</span><br><span class="line">  fmt.Println(<span class="string">&quot;some_key:&quot;</span>, n)</span><br><span class="line"></span><br><span class="line">  counter.Lock()</span><br><span class="line">  counter.m[<span class="string">&quot;some_key&quot;</span>]++</span><br><span class="line">  counter.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync.Map</p>
<ul>
<li>Store</li>
<li>LoadOrStore</li>
<li>Load</li>
<li>Delete</li>
<li>Range</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m sync.Map</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Store</span></span><br><span class="line">    m.Store(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    m.Store(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//LoadOrStore</span></span><br><span class="line">    <span class="comment">//若key不存在，则存入key和value，返回false和输入的value</span></span><br><span class="line">    v,ok := m.LoadOrStore(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    fmt.Println(ok,v) <span class="comment">//false aaa</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//若key已存在，则返回true和key对应的value，不会修改原来的value</span></span><br><span class="line">    v,ok = m.LoadOrStore(<span class="number">1</span>,<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    fmt.Println(ok,v) <span class="comment">//false aaa</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Load</span></span><br><span class="line">    v,ok = m.Load(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> ok&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;it&#x27;s an existing key,value is &quot;</span>,v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;it&#x27;s an unknown key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Range</span></span><br><span class="line">    <span class="comment">//遍历sync.Map, 要求输入一个func作为参数</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">          <span class="comment">//这个函数的入参、出参的类型都已经固定，不能修改</span></span><br><span class="line">          <span class="comment">//可以在函数体内编写自己的代码，调用map中的k,v</span></span><br><span class="line">            fmt.Println(k,v)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    m.Range(f)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Delete</span></span><br><span class="line">    m.Delete(<span class="number">1</span>)</span><br><span class="line">    fmt.Println(m.Load(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sync-atomic"><a href="#sync-atomic" class="headerlink" title="sync.atomic"></a>sync.atomic</h2><p>功能：提供的原子操作</p>
<blockquote>
<p>原子操作是比其它同步技术更基础的操作。<strong>原子操作是无锁的，常常直接通过CPU指令直接实现</strong>。 事实上，其它同步技术的实现常常依赖于原子操作。</p>
</blockquote>
<h3 id="Go支持的原子操作概述"><a href="#Go支持的原子操作概述" class="headerlink" title="Go支持的原子操作概述"></a>Go支持的原子操作概述</h3><p>对于一个整数类型<code>T</code>，<code>sync/atomic</code>标准库包提供了下列原子操作函数。 其中<code>T</code>可以是内置<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>和<code>uintptr</code>类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddT</span><span class="params">(addr *T, delta T)</span><span class="params">(<span class="built_in">new</span> T)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadT</span><span class="params">(addr *T)</span> <span class="params">(val T)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreT</span><span class="params">(addr *T, val T)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapT</span><span class="params">(addr *T, <span class="built_in">new</span> T)</span> <span class="params">(old T)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapT</span><span class="params">(addr *T, old, <span class="built_in">new</span> T)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>比如，下列五个原子操作函数提供给了内置<code>int32</code>类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="keyword">int32</span>, delta <span class="keyword">int32</span>)</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="keyword">int32</span>)</span> <span class="params">(val <span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="keyword">int32</span>, val <span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(old <span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>



<p>下列四个原子操作函数提供给了（安全）指针类型。因为Go目前（1.16）并不支持自定义泛型，所以这些函数是通过<a target="_blank" rel="noopener" href="https://gfw.go101.org/article/unsafe.html">非类型安全指针</a><code>unsafe.Pointer</code>来实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span> <span class="params">(val unsafe.Pointer)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span> <span class="params">(old unsafe.Pointer)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>因为Go指针不支持算术运算，所以相对于整数类型，指针类型的原子操作少了一个<code>AddPointer</code>函数。</p>
<p><code>sync/atomic</code>标准库包也提供了一个<code>Value</code>类型。以它为基的指针类型<code>*Value</code>拥有两个方法：<code>Load</code>和<code>Store</code>。 <code>Value</code>值用来原子读取和修改任何类型的Go值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span> <span class="title">Load</span><span class="params">()</span> <span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span> <span class="title">Store</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>

<p>下面部分将通过一些示例来展示如何使用这些原子操作函数。</p>
<h3 id="整数原子操作"><a href="#整数原子操作" class="headerlink" title="整数原子操作"></a>整数原子操作</h3><p>下面这个例子展示了如何使用<code>add</code>原子操作来并发地递增一个<code>int32</code>值。 </p>
<p>在此例子中，主协程中创建了1000个新协程。每个新协程将整数<code>n</code>的值增加<code>1</code>。 原子操作保证这1000个新协程之间不会发生数据竞争。此程序肯定打印出<code>1000</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int32</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			atomic.AddInt32(&amp;n, <span class="number">1</span>)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(atomic.LoadInt32(&amp;n)) <span class="comment">// 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们将新协程中的语句<code>atomic.AddInt32(&amp;n, 1)</code>替换为<code>n++</code>，则最后的输出结果很可能不是<code>1000</code>。</p>
<p><code>StoreT</code>和<code>LoadT</code>原子操作函数经常被用来需要并发运行的实现setter和getter方法。下面是一个这样的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Page <span class="keyword">struct</span> &#123;</span><br><span class="line">	views <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(page *Page)</span> <span class="title">SetViews</span><span class="params">(n <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	atomic.StoreUint32(&amp;page.views, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(page *Page)</span> <span class="title">Views</span><span class="params">()</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.LoadUint32(&amp;page.views)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>T</code>是一个有符号整数类型，比如<code>int32</code>或<code>int64</code>，则<code>AddT</code>函数调用的第二个实参可以是一个负数，用来实现原子减法操作。 </li>
<li>但是如果<code>T</code>是一个无符号整数类型，比如<code>uint32</code>、<code>uint64</code>或者<code>uintptr</code>，则<code>AddT</code>函数调用的第二个实参需要为一个非负数，那么如何实现无符号整数类型<code>T</code>值的原子减法操作呢？ 毕竟<code>sync/atomic</code>标准库包没有提供<code>SubstractT</code>函数。 根据欲传递的第二个实参的特点，我们可以把<code>T</code>为一个无符号整数类型的情况细分为两类：<ol>
<li>第二个实参为类型为<code>T</code>的一个变量值<code>v</code>。 因为<code>-v</code>在Go中是合法的，所以<code>-v</code>可以直接被用做<code>AddT</code>调用的第二个实参。</li>
<li>第二个实参为一个正整数常量<code>c</code>，这时<code>-c</code>在Go中是编译不通过的，所以它不能被用做<code>AddT</code>调用的第二个实参。 这时我们可以使用<code>^T(c-1)</code>（仍为一个正数）做为<code>AddT</code>调用的第二个实参。</li>
</ol>
</li>
</ul>
<p>此<code>^T(v-1)</code>小技巧对于无符号类型的变量<code>v</code>也是适用的，但是<code>^T(v-1)</code>比<code>T(-v)</code>的效率要低。</p>
<p>对于这个<code>^T(c-1)</code>小技巧，如果<code>c</code>是一个类型确定值并且它的类型确实就是<code>T</code>，则它的表示形式可以简化为<code>^(c-1)</code>。</p>
<p>一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		n <span class="keyword">uint64</span> = <span class="number">97</span></span><br><span class="line">		m <span class="keyword">uint64</span> = <span class="number">1</span></span><br><span class="line">		k <span class="keyword">int</span>    = <span class="number">2</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		a        = <span class="number">3</span></span><br><span class="line">		b <span class="keyword">uint64</span> = <span class="number">4</span></span><br><span class="line">		c <span class="keyword">uint32</span> = <span class="number">5</span></span><br><span class="line">		d <span class="keyword">int</span>    = <span class="number">6</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	show := fmt.Println</span><br><span class="line">	atomic.AddUint64(&amp;n, -m)</span><br><span class="line">	show(n) <span class="comment">// 96 (97 - 1)</span></span><br><span class="line">	atomic.AddUint64(&amp;n, -<span class="keyword">uint64</span>(k))</span><br><span class="line">	show(n) <span class="comment">// 94 (95 - 2)</span></span><br><span class="line">	atomic.AddUint64(&amp;n, ^<span class="keyword">uint64</span>(a - <span class="number">1</span>))</span><br><span class="line">	show(n) <span class="comment">// 91 (94 - 3)</span></span><br><span class="line">	atomic.AddUint64(&amp;n, ^(b - <span class="number">1</span>))</span><br><span class="line">	show(n) <span class="comment">// 87 (91 - 4)</span></span><br><span class="line">	atomic.AddUint64(&amp;n, ^<span class="keyword">uint64</span>(c - <span class="number">1</span>))</span><br><span class="line">	show(n) <span class="comment">// 82 (87 - 5)</span></span><br><span class="line">	atomic.AddUint64(&amp;n, ^<span class="keyword">uint64</span>(d - <span class="number">1</span>))</span><br><span class="line">	show(n) <span class="comment">// 76 (82 - 6)</span></span><br><span class="line">	x := b; atomic.AddUint64(&amp;n, -x)</span><br><span class="line">	show(n) <span class="comment">// 72 (76 - 4)</span></span><br><span class="line">	atomic.AddUint64(&amp;n, ^(m - <span class="number">1</span>))</span><br><span class="line">	show(n) <span class="comment">// 71 (72 - 1)</span></span><br><span class="line">	atomic.AddUint64(&amp;n, ^<span class="keyword">uint64</span>(k - <span class="number">1</span>))</span><br><span class="line">	show(n) <span class="comment">// 69 (71 - 2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>SwapT</code>函数调用和<code>StoreT</code>函数调用类似，但是返回修改之前的旧值（因此称为置换操作）。</p>
<p>一个<code>CompareAndSwapT</code>函数调用仅在新值和旧值不相等的情况下才会执行修改操作，并返回<code>true</code>；否则立即返回<code>false</code>。</p>
<p>一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int64</span> = <span class="number">123</span></span><br><span class="line">	<span class="keyword">var</span> old = atomic.SwapInt64(&amp;n, <span class="number">789</span>)</span><br><span class="line">	fmt.Println(n, old) <span class="comment">// 789 123</span></span><br><span class="line">	swapped := atomic.CompareAndSwapInt64(&amp;n, <span class="number">123</span>, <span class="number">456</span>)</span><br><span class="line">	fmt.Println(swapped) <span class="comment">// false</span></span><br><span class="line">	fmt.Println(n)       <span class="comment">// 789</span></span><br><span class="line">	swapped = atomic.CompareAndSwapInt64(&amp;n, <span class="number">789</span>, <span class="number">456</span>)</span><br><span class="line">	fmt.Println(swapped) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(n)       <span class="comment">// 456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指针值的原子操作"><a href="#指针值的原子操作" class="headerlink" title="指针值的原子操作"></a>指针值的原子操作</h3><p>上面已经提到了<code>sync/atomic</code>标准库包为指针值的原子操作提供了四个函数，并且指针值的原子操作是通过非类型安全指针来实现的。</p>
<p>从<a target="_blank" rel="noopener" href="https://gfw.go101.org/article/unsafe.html">非类型安全指针</a>一文，我们得知，在Go中， 任何指针类型的值可以被显式转换为非类型安全指针类型<code>unsafe.Pointer</code>，反之亦然。 所以指针类型<code>*unsafe.Pointer</code>的值也可以被显式转换为类型<code>unsafe.Pointer</code>，反之亦然。</p>
<p>下面这个程序不是一个并发程序。它仅仅展示了如何使用指针原子操作。在这个例子中，类型<code>T</code>可以为任何类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;x <span class="keyword">int</span>&#125;</span><br><span class="line"><span class="keyword">var</span> pT *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> unsafePPT = (*unsafe.Pointer)(unsafe.Pointer(&amp;pT))</span><br><span class="line">	<span class="keyword">var</span> ta, tb = T&#123;<span class="number">1</span>&#125;, T&#123;<span class="number">2</span>&#125;</span><br><span class="line">	<span class="comment">// 修改</span></span><br><span class="line">	atomic.StorePointer(unsafePPT, unsafe.Pointer(&amp;ta))</span><br><span class="line">	fmt.Println(pT) <span class="comment">// &amp;&#123;1&#125;</span></span><br><span class="line">	<span class="comment">// 读取</span></span><br><span class="line">	pa1 := (*T)(atomic.LoadPointer(unsafePPT))</span><br><span class="line">	fmt.Println(pa1 == &amp;ta) <span class="comment">// true</span></span><br><span class="line">	<span class="comment">// 置换</span></span><br><span class="line">	pa2 := atomic.SwapPointer(unsafePPT, unsafe.Pointer(&amp;tb))</span><br><span class="line">	fmt.Println((*T)(pa2) == &amp;ta) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(pT) <span class="comment">// &amp;&#123;2&#125;</span></span><br><span class="line">	<span class="comment">// 比较置换</span></span><br><span class="line">	b := atomic.CompareAndSwapPointer(unsafePPT, pa2, unsafe.Pointer(&amp;tb))</span><br><span class="line">	fmt.Println(b) <span class="comment">// false</span></span><br><span class="line">	b = atomic.CompareAndSwapPointer(unsafePPT, unsafe.Pointer(&amp;tb), pa2)</span><br><span class="line">	fmt.Println(b) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是的，目前指针的原子操作使用起来是相当的啰嗦。 事实上，啰嗦还是次要的，更主要的是，因为指针的原子操作需要引入<code>unsafe</code>标准库包，所以这些操作函数不在<a target="_blank" rel="noopener" href="https://golang.google.cn/doc/go1compat">Go 1兼容性保证</a>之列。</p>
<p>如果你确实担忧这些指针原子操作在未来的合法性，你可以使用下一节将要介绍的原子操作。 但是下一节将要介绍的原子操作对于指针值来说比本节介绍的指针原子操作效率要低得多。</p>
<h3 id="任何类型值的原子操作"><a href="#任何类型值的原子操作" class="headerlink" title="任何类型值的原子操作"></a>任何类型值的原子操作</h3><p><code>sync/atomic</code>标准库包中提供的<code>Value</code>类型可以用来读取和修改任何类型的值。</p>
<p>类型<code>*Value</code>有几个方法：<code>Load</code>、<code>Store</code>、<code>Swap</code>和<code>CompareAndSwap</code>（其中后两个方法实在Go 1.17中引入的）。 这些方法均以<code>interface&#123;&#125;</code>做为参数类型，所以传递给它们的实参可以是任何类型的值。 但是对于一个可寻址的<code>Value</code>类型的值<code>v</code>，一旦<code>v.Store</code>方法（<code>(&amp;v).Store</code>的简写形式）被曾经调用一次，则传递给值<code>v</code>的后续方法调用的实参的具体类型必须和传递给它的第一次调用的实参的具体类型一致； 否则，将产生一个恐慌。<code>nil</code>接口类型实参也将导致<code>v.Store()</code>方法调用产生恐慌。</p>
<p>一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> T <span class="keyword">struct</span> &#123;a, b, c <span class="keyword">int</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> ta = T&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> v atomic.Value</span><br><span class="line">	v.Store(ta)</span><br><span class="line">	<span class="keyword">var</span> tb = v.Load().(T)</span><br><span class="line">	fmt.Println(tb)       <span class="comment">// &#123;1 2 3&#125;</span></span><br><span class="line">	fmt.Println(ta == tb) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	v.Store(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 将导致一个恐慌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子（针对Go 1.17+）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> T <span class="keyword">struct</span> &#123;a, b, c <span class="keyword">int</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> x = T&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> y = T&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> z = T&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> v atomic.Value</span><br><span class="line">	v.Store(x)</span><br><span class="line">	fmt.Println(v) <span class="comment">// &#123;&#123;1 2 3&#125;&#125;</span></span><br><span class="line">	old := v.Swap(y)</span><br><span class="line">	fmt.Println(v)       <span class="comment">// &#123;&#123;4 5 6&#125;&#125;</span></span><br><span class="line">	fmt.Println(old.(T)) <span class="comment">// &#123;1 2 3&#125;</span></span><br><span class="line">	swapped := v.CompareAndSwap(x, z)</span><br><span class="line">	fmt.Println(swapped, v) <span class="comment">// false &#123;&#123;4 5 6&#125;&#125;</span></span><br><span class="line">	swapped = v.CompareAndSwap(y, z)</span><br><span class="line">	fmt.Println(swapped, v) <span class="comment">// true &#123;&#123;7 8 9&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，我们也可以使用上一节介绍的指针原子操作来对任何类型的值进行原子读取和修改，不过需要多一级指针的间接引用。 两种方法有各自的好处和缺点。在实践中需要根据具体需要选择合适的方法。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>