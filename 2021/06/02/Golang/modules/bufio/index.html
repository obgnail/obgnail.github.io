<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;bufio-—-缓存IO&quot;&gt;&lt;a href=&quot;#bufio-—-缓存IO&quot; class=&quot;headerlink&quot; title=&quot;bufio — 缓存IO&quot;&gt;&lt;/a&gt;bufio — 缓存IO&lt;/h1&gt;&lt;p&gt;bufio 包实现了缓存IO。使用这个包&lt;strong&gt;可以大幅提高文件读写的效率&lt;/strong&gt;。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>bufio | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-06-02</div></div></div><div class="container post-header"><h1>bufio</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#bufio-%E2%80%94-%E7%BC%93%E5%AD%98IO"><span class="toc-number">1.</span> <span class="toc-text">bufio — 缓存IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bufio%E5%8C%85%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">bufio包原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reader-%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">Reader 类型和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bufio-Reader-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">bufio.Reader 实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadSlice%E3%80%81ReadBytes%E3%80%81ReadString-%E5%92%8C-ReadLine-%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">ReadSlice、ReadBytes、ReadString 和 ReadLine 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Peek-%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">Peek 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">其他方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanner-%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">Scanner 类型和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SplitFunc-%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">SplitFunc 类型和实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scanner-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">Scanner 的实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scanner-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">Scanner 的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Writer-%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">Writer 类型和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bufio-Writer-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.1.</span> <span class="toc-text">bufio.Writer 实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Available-%E5%92%8C-Buffered-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">Available 和 Buffered 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flush-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">Flush 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.4.5.</span> <span class="toc-text">其他方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.4.6.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReadWriter-%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">ReadWriter 类型和实例化</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="bufio-—-缓存IO"><a href="#bufio-—-缓存IO" class="headerlink" title="bufio — 缓存IO"></a>bufio — 缓存IO</h1><p>bufio 包实现了缓存IO。使用这个包<strong>可以大幅提高文件读写的效率</strong>。</p>
<p>它包装了 io.Reader 和 io.Writer 对象，创建了另外的Reader和Writer对象，它们也实现了 io.Reader 和 io.Writer 接口，不过它们是有缓存的。该包同时为文本I/O提供了一些便利操作。</p>
<h2 id="bufio包原理"><a href="#bufio包原理" class="headerlink" title="bufio包原理"></a>bufio包原理</h2><ul>
<li>bufio 是通过缓冲来提高效率。</li>
<li>io操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以bufio就提供了缓冲区(分配一块内存)，读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。</li>
<li>简单的说就是：<strong>把文件读取进缓冲（内存），之后再读取的时候就可以避免文件系统的io从而提高速度</strong>。同理，在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。</li>
<li>看完以上解释有人可能会表示困惑了，直接把 <code>内容-&gt;文件</code> 和 <code>内容-&gt;缓冲-&gt;文件</code>相比， 缓冲区好像没有起到作用嘛。其实缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。</li>
</ul>
<h2 id="Reader-类型和方法"><a href="#Reader-类型和方法" class="headerlink" title="Reader 类型和方法"></a>Reader 类型和方法</h2><p>bufio.Reader 结构包装了一个 io.Reader 对象，提供缓存功能，同时实现了 io.Reader 接口。</p>
<p>Reader 结构没有任何导出的字段，结构定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    buf          []<span class="keyword">byte</span>        <span class="comment">// 缓存</span></span><br><span class="line">    rd           io.Reader    <span class="comment">// 底层的io.Reader</span></span><br><span class="line">    <span class="comment">// r:从buf中读走的字节（偏移）；</span></span><br><span class="line">    <span class="comment">// w:buf中填充内容的偏移；</span></span><br><span class="line">    <span class="comment">// w - r 是buf中可被读的长度（缓存数据的大小），也是Buffered()方法的返回值</span></span><br><span class="line">    r, w         <span class="keyword">int</span></span><br><span class="line">    err          error        <span class="comment">// 读过程中遇到的错误</span></span><br><span class="line">    lastByte     <span class="keyword">int</span>        <span class="comment">// 最后一次读到的字节（ReadByte/UnreadByte)</span></span><br><span class="line">    lastRuneSize <span class="keyword">int</span>        <span class="comment">// 最后一次读到的Rune的大小 (ReadRune/UnreadRune)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bufio.Read(p []byte) 相当于读取大小len(p)的内容，思路如下：</p>
<ol>
<li>当缓存区有内容的时，将缓存区内容全部填入p并清空缓存区</li>
<li>当缓存区没有内容的时候且len(p)&gt;len(buf)，即<strong>要读取的内容比缓存区还要大，直接去文件读取即可</strong></li>
<li>当缓存区没有内容的时候且len(p)&lt;len(buf)，即要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将p填满（此时缓存区有剩余内容）</li>
<li>以后再次读取时缓存区有内容，将缓存区内容全部填入p并清空缓存区（此时和情况1一样）</li>
</ol>
<p><img src="/images/image-20210602145056071.png" alt="image-20210602145056071"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read reads data into p.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes read into p.</span></span><br><span class="line"><span class="comment">// The bytes are taken from at most one Read on the underlying Reader,</span></span><br><span class="line"><span class="comment">// hence n may be less than len(p).</span></span><br><span class="line"><span class="comment">// To read exactly len(p) bytes, use io.ReadFull(b, p).</span></span><br><span class="line"><span class="comment">// At EOF, the count will be zero and err will be io.EOF.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    n = <span class="built_in">len</span>(p)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> b.r == b.w &#123;</span><br><span class="line">        <span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line">            <span class="comment">// Large read, empty buffer.</span></span><br><span class="line">            <span class="comment">// Read directly into p to avoid copy.</span></span><br><span class="line">            n, b.err = b.rd.Read(p)</span><br><span class="line">            <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(errNegativeRead)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">                b.lastByte = <span class="keyword">int</span>(p[n<span class="number">-1</span>])</span><br><span class="line">                b.lastRuneSize = <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n, b.readErr()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// One read.</span></span><br><span class="line">        <span class="comment">// Do not use b.fill, which will loop.</span></span><br><span class="line">        b.r = <span class="number">0</span></span><br><span class="line">        b.w = <span class="number">0</span></span><br><span class="line">        n, b.err = b.rd.Read(b.buf)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(errNegativeRead)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">        &#125;</span><br><span class="line">        b.w += n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy as much as we can</span></span><br><span class="line">    n = <span class="built_in">copy</span>(p, b.buf[b.r:b.w])</span><br><span class="line">    b.r += n</span><br><span class="line">    b.lastByte = <span class="keyword">int</span>(b.buf[b.r<span class="number">-1</span>])</span><br><span class="line">    b.lastRuneSize = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reader内部通过维护一个r, w 即读入和写入的位置索引来判断是否缓存区内容被全部读出。</p>
<h3 id="bufio-Reader-实现接口"><a href="#bufio-Reader-实现接口" class="headerlink" title="bufio.Reader 实现接口"></a>bufio.Reader 实现接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReaderSize 将 rd 封装成一个带缓存的 bufio.Reader 对象，</span></span><br><span class="line"><span class="comment">// 缓存大小由 size 指定（如果小于 16 则会被设置为 16）。</span></span><br><span class="line"><span class="comment">// 如果 rd 的基类型就是有足够缓存的 bufio.Reader 类型，则直接将</span></span><br><span class="line"><span class="comment">// rd 转换为基类型返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewReader 相当于 NewReaderSize(rd, 4096)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Peek 返回缓存的一个切片，该切片引用缓存中前 n 个字节的数据，</span></span><br><span class="line"><span class="comment">// 该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之</span></span><br><span class="line"><span class="comment">// 前是有效的。如果切片长度小于 n，则返回一个错误信息说明原因。</span></span><br><span class="line"><span class="comment">// 如果 n 大于缓存的总大小，则返回 ErrBufferFull。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 从 b 中读出数据到 p 中，返回读出的字节数和遇到的错误。</span></span><br><span class="line"><span class="comment">// 如果缓存不为空，则只能读出缓存中的数据，不会从底层 io.Reader</span></span><br><span class="line"><span class="comment">// 中提取数据，如果缓存为空，则：</span></span><br><span class="line"><span class="comment">// 1、len(p) &gt;= 缓存大小，则跳过缓存，直接从底层 io.Reader 中读</span></span><br><span class="line"><span class="comment">// 出到 p 中。</span></span><br><span class="line"><span class="comment">// 2、len(p) &lt; 缓存大小，则先将数据从底层 io.Reader 中读取到缓存</span></span><br><span class="line"><span class="comment">// 中，再从缓存读取到 p 中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffered 返回缓存中未读取的数据的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadBytes 功能同 ReadSlice，只不过返回的是缓存的拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadString 功能同 ReadBytes，只不过返回的是字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>



<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>bufio 包提供了两个实例化 bufio.Reader 对象的函数：NewReader 和 NewReaderSize。其中，NewReader 函数是调用 NewReaderSize 函数实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="comment">// 默认缓存大小：defaultBufSize=4096</span></span><br><span class="line">    <span class="keyword">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下NewReaderSize的源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="comment">// 已经是bufio.Reader类型，且缓存大小不小于 size，则直接返回</span></span><br><span class="line">    b, ok := rd.(*Reader)</span><br><span class="line">    <span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存大小不会小于 minReadBufferSize （16字节）</span></span><br><span class="line">    <span class="keyword">if</span> size &lt; minReadBufferSize &#123;</span><br><span class="line">        size = minReadBufferSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造一个bufio.Reader实例</span></span><br><span class="line">    <span class="keyword">return</span> &amp;Reader&#123;</span><br><span class="line">        buf:          <span class="built_in">make</span>([]<span class="keyword">byte</span>, size),</span><br><span class="line">        rd:           rd,</span><br><span class="line">        lastByte:     <span class="number">-1</span>,</span><br><span class="line">        lastRuneSize: <span class="number">-1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ReadSlice、ReadBytes、ReadString-和-ReadLine-方法"><a href="#ReadSlice、ReadBytes、ReadString-和-ReadLine-方法" class="headerlink" title="ReadSlice、ReadBytes、ReadString 和 ReadLine 方法"></a>ReadSlice、ReadBytes、ReadString 和 ReadLine 方法</h3><p>之所以将这几个方法放在一起，是因为他们有着类似的行为。事实上，后三个方法最终都是调用ReadSlice来实现的。所以，我们先来看看ReadSlice方法。(感觉这一段直接看源码较好)</p>
<p><strong>ReadSlice方法签名</strong>如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadSlice</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ReadSlice 从输入中读取，<strong>直到遇到第一个界定符（delim）为止</strong>，返回一个指向缓存中字节的 slice，在下次调用读操作（read）时，这些字节会无效。举例说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(strings.NewReader(<span class="string">&quot;http://studygolang.com. \nIt is the home of gophers&quot;</span>))</span><br><span class="line">line, _ := reader.ReadSlice(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;the line:%s\n&quot;</span>, line)</span><br><span class="line"><span class="comment">// 这里可以换上任意的 bufio 的 Read/Write 操作</span></span><br><span class="line">n, _ := reader.ReadSlice(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;the line:%s\n&quot;</span>, line)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(n))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the line:http://studygolang.com. </span><br><span class="line"></span><br><span class="line">the line:It is the home of gophers</span><br><span class="line">It is the home of gophers</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，第一次ReadSlice的结果（line），在第二次调用读操作后，内容发生了变化。也就是说，<strong>ReadSlice 返回的 []byte 是指向 Reader 中的 buffer</strong> ，而不是 copy 一份返回。正因为ReadSlice 返回的数据会被下次的 I/O 操作重写，因此许多的客户端会选择使用 ReadBytes 或者 ReadString 来代替。读者可以将上面代码中的 ReadSlice 改为 ReadBytes 或 ReadString ，看看结果有什么不同。</p>
<blockquote>
<p>注意，这里的界定符可以是任意的字符，可以将上面代码中的’\n’改为’m’试试。同时，返回的结果是包含界定符本身的，上例中，输出结果有一空行就是’\n’本身(line携带一个’\n’,printf又追加了一个’\n’)。</p>
</blockquote>
<p>如果 ReadSlice 在找到界定符之前遇到了 error ，它就会返回缓存中所有的数据和错误本身（经常是 io.EOF）。<strong>如果在找到界定符之前缓存已经满了，ReadSlice 会返回 bufio.ErrBufferFull 错误</strong>。当且仅当返回的结果（line）没有以界定符结束的时候，ReadSlice 返回err != nil，也就是说，如果ReadSlice 返回的结果 line 不是以界定符 delim 结尾，那么返回的 er r也一定不等于 nil（可能是bufio.ErrBufferFull或io.EOF）。 例子代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;http://studygolang.com&quot;</span>),<span class="number">16</span>)</span><br><span class="line">line, err := reader.ReadSlice(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;line:%s\terror:%s\n&quot;</span>, line, err)</span><br><span class="line">line, err = reader.ReadSlice(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;line:%s\terror:%s\n&quot;</span>, line, err)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line:http://studygola    error:bufio: buffer full</span><br><span class="line">line:ng.com    error:EOF</span><br></pre></td></tr></table></figure>



<p><strong>ReadBytes方法签名</strong>如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>该方法的参数和返回值类型与 ReadSlice 都一样。 ReadBytes 从输入中读取直到遇到界定符（delim）为止，返回的 slice 包含了从当前到界定符的内容 <strong>（包括界定符）</strong>。如果 ReadBytes 在遇到界定符之前就捕获到一个错误，它会返回遇到错误之前已经读取的数据，和这个捕获到的错误（经常是 io.EOF）。跟 ReadSlice 一样，如果 ReadBytes 返回的结果 line 不是以界定符 delim 结尾，那么返回的 err 也一定不等于 nil（可能是bufio.ErrBufferFull 或 io.EOF）。</p>
<p>从这个说明可以看出，ReadBytes和ReadSlice功能和用法都很像，那他们有什么不同呢？</p>
<p>在讲解ReadSlice时说到，它返回的 []byte 是指向 Reader 中的 buffer，而不是 copy 一份返回，也正因为如此，通常我们会使用 ReadBytes 或 ReadString。很显然，<strong>ReadBytes 返回的 []byte 不会是指向 Reader 中的 buffer</strong>，通过<a target="_blank" rel="noopener" href="http://docscn.studygolang.com/src/bufio/bufio.go?s=10277:10340#L338">查看源码</a>可以证实这一点。</p>
<p>还是上面的例子，我们将 ReadSlice 改为 ReadBytes：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(strings.NewReader(<span class="string">&quot;http://studygolang.com. \nIt is the home of gophers&quot;</span>))</span><br><span class="line">line, _ := reader.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;the line:%s\n&quot;</span>, line)</span><br><span class="line"><span class="comment">// 这里可以换上任意的 bufio 的 Read/Write 操作</span></span><br><span class="line">n, _ := reader.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;the line:%s\n&quot;</span>, line)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(n))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">the line:http://studygolang.com. </span><br><span class="line"></span><br><span class="line">the line:http://studygolang.com. </span><br><span class="line"></span><br><span class="line">It is the home of gophers</span><br></pre></td></tr></table></figure>



<p><strong>ReadString方法</strong></p>
<p>看一下该方法的源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    bytes, err := b.ReadBytes(delim)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bytes), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了 ReadBytes 方法，并将结果的 []byte 转为 string 类型。</p>
<p><strong>ReadLine方法签名</strong>如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadLine</span><span class="params">()</span> <span class="params">(line []<span class="keyword">byte</span>, isPrefix <span class="keyword">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ReadLine 是一个底层的原始行读取命令。许多调用者或许会使用 ReadBytes(‘\n’) 或者 ReadString(‘\n’) 来代替这个方法。</p>
<p>ReadLine 尝试返回单独的行，不包括行尾的换行符。</p>
<ul>
<li>如果一行大于缓存，isPrefix 会被设置为 true，同时返回该行的开始部分（等于缓存大小的部分）。该行剩余的部分就会在下次调用的时候返回。</li>
<li>当下次调用返回该行剩余部分时，isPrefix 将会是 false 。跟 ReadSlice 一样，返回的 line 只是 buffer 的引用，在下次执行IO操作时，line 会无效。可以将 ReadSlice 中的例子该为 ReadLine 试试。</li>
</ul>
<p>注意，返回值中，要么 line 不是 nil，要么 err 非 nil，两者不会同时非 nil。</p>
<p>ReadLine 返回的文本不会包含行结尾（”\r\n”或者”\n”）。如果输入中没有行尾标识符，不会返回任何指示或者错误。</p>
<p>从上面的讲解中，我们知道，读取一行，通常会选择 ReadBytes 或 ReadString。不过，正常人的思维，应该用 ReadLine，只是不明白为啥 ReadLine 的实现不是通过 ReadBytes，然后清除掉行尾的\n（或\r\n），它现在的实现，用不好会出现意想不到的问题，比如丢数据。个人建议可以这么实现读取一行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line, err := reader.ReadBytes(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">line = bytes.TrimRight(line, <span class="string">&quot;\r\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样既读取了一行，也去掉了行尾结束符（当然，如果你希望留下行尾结束符，只用ReadBytes即可）。</p>
<h3 id="Peek-方法"><a href="#Peek-方法" class="headerlink" title="Peek 方法"></a>Peek 方法</h3><p>从方法的名称可以猜到，该方法只是“窥探”一下 Reader 中没有读取的 n 个字节。好比栈数据结构中的取栈顶元素，但不出栈。</p>
<p>方法的签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>同上面介绍的 ReadSlice一样，返回的 []byte 只是 buffer 中的引用，在下次IO操作后会无效，可见该方法（以及ReadSlice这样的，返回buffer引用的方法）<strong>对多 goroutine 是不安全的</strong>，也就是在多并发环境下，不能依赖其结果。</p>
<p>我们通过例子来证明一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;strings&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;http://studygolang.com.\t It is the home of gophers&quot;</span>), <span class="number">14</span>)</span><br><span class="line">  <span class="keyword">go</span> Peek(reader)</span><br><span class="line">  <span class="keyword">go</span> reader.ReadBytes(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">  time.Sleep(<span class="number">1e8</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Peek</span><span class="params">(reader *bufio.Reader)</span></span> &#123;</span><br><span class="line">  line, _ := reader.Peek(<span class="number">14</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, line)</span><br><span class="line">  <span class="comment">// time.Sleep(1)</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://studygo</span><br><span class="line">http://studygo</span><br></pre></td></tr></table></figure>

<p>输出结果和预期的一致。然而，这是由于目前的 goroutine 调度方式导致的结果。如果我们将例子中注释掉的 time.Sleep(1) 取消注释（这样调度其他 goroutine 执行），再次运行，得到的结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://studygo</span><br><span class="line">ng.com.     It is</span><br></pre></td></tr></table></figure>

<p>另外，Reader 的 Peek 方法如果返回的 []byte 长度小于 n，这时返回的 <code>err != nil</code> ，用于解释为啥会小于 n。如果 n 大于 reader 的 buffer 长度，err 会是 ErrBufferFull。</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>Reader 的其他方法都是实现了 io 包中的接口，它们的使用方法在io包中都有介绍，在此不赘述。</p>
<p>这些方法包括：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(c <span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadRune</span><span class="params">()</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">UnreadByte</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>你应该知道它们都是哪个接口的方法吧。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     fileName:=<span class="string">&quot;/Users/ruby/Documents/pro/a/english.txt&quot;</span></span><br><span class="line">     file,err := os.Open(fileName)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    b2 := bufio.NewReader(os.Stdin)</span><br><span class="line">    s2, _ := b2.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Scanner-类型和方法"><a href="#Scanner-类型和方法" class="headerlink" title="Scanner 类型和方法"></a>Scanner 类型和方法</h2><p>对于简单的读取一行，在 Reader 类型中，感觉没有让人特别满意的方法。于是，Go1.1增加了一个类型：Scanner。官方关于<strong>Go1.1</strong>增加该类型的说明如下：</p>
<blockquote>
<p>在 bufio 包中有多种方式获取文本输入，ReadBytes、ReadString 和独特的 ReadLine，对于简单的目的这些都有些过于复杂了。在 Go 1.1 中，添加了一个新类型，Scanner，以便更容易的处理如<strong>按行读取输入序列或空格分隔单词</strong>等，这类简单的任务。</p>
<p>它终结了如输入一个很长的有问题的行这样的输入错误，并且提供了简单的默认行为：<strong>基于行的输入，每行都剔除分隔标识。</strong>这里的代码展示一次输入一行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">    fmt.Println(scanner.Text()) <span class="comment">// Println will add back the final &#x27;\n&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, <span class="string">&quot;reading standard input:&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入的行为可以通过一个函数控制，来控制输入的每个部分（参阅 SplitFunc 的文档），但是对于复杂的问题或持续传递错误的，可能还是需要原有接口。</p>
</blockquote>
<p>Scanner 类型和 Reader 类型一样，没有任何导出的字段，同时它也包装了一个 io.Reader 对象，但它没有实现 io.Reader 接口。</p>
<p>Scanner 的结构定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scanner <span class="keyword">struct</span> &#123;</span><br><span class="line">    r            io.Reader <span class="comment">// The reader provided by the client.</span></span><br><span class="line">    split        SplitFunc <span class="comment">// The function to split the tokens.</span></span><br><span class="line">    maxTokenSize <span class="keyword">int</span>       <span class="comment">// Maximum size of a token; modified by tests.</span></span><br><span class="line">    token        []<span class="keyword">byte</span>    <span class="comment">// Last token returned by split.</span></span><br><span class="line">    buf          []<span class="keyword">byte</span>    <span class="comment">// Buffer used as argument to split.</span></span><br><span class="line">    start        <span class="keyword">int</span>       <span class="comment">// First non-processed byte in buf.</span></span><br><span class="line">    end          <span class="keyword">int</span>       <span class="comment">// End of data in buf.</span></span><br><span class="line">    err          error     <span class="comment">// Sticky error.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 split、maxTokenSize 和 token 需要讲解一下。</p>
<p>然而，在讲解之前，需要先讲解 split 字段的类型 SplitFunc。</p>
<h3 id="SplitFunc-类型和实例"><a href="#SplitFunc-类型和实例" class="headerlink" title="SplitFunc 类型和实例"></a>SplitFunc 类型和实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SplitFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>SplitFunc 定义了 用于<strong>对输入进行分词</strong>的 split 函数的签名。参数 data 是还未处理的数据，atEOF 标识 Reader 是否还有更多数据（是否到了EOF）。返回值 advance 表示从输入中读取的字节数，token 表示下一个结果数据，err 则代表可能的错误。</p>
<p>举例说明一下这里的 token 代表的意思：</p>
<ul>
<li>有数据 “studygolang\tpolaris\tgolangchina”，通过”\t”进行分词，那么会得到三个token，它们的内容分别是：studygolang、polaris 和 golangchina。</li>
<li>而 SplitFunc 的功能是：进行分词，并返回未处理的数据中第一个 token。对于这个数据，就是返回 studygolang。</li>
</ul>
<p>如果 data 中没有一个完整的 token，例如，在扫描行（scanning lines）时没有换行符，<strong>SplitFunc 会返回(0,nil,nil)通知 Scanner 读取更多数据到 slice 中，然后在这个更大的 slice 中同样的读取点处，从输入中重试读取</strong>。如下面要讲解的 split 函数的源码中有这样的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request more data.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>err != nil</code>，扫描停止，同时该错误会返回。</p>
<p>如果参数 data 为空的 slice，除非 atEOF 为 true，否则该函数永远不会被调用。如果 atEOF 为 true，这时 data 可以非空，这时的数据是没有处理的。</p>
<blockquote>
<p>当返回的值分别是 <code>0, nil, nil</code> 的时候，扫描器会尝试读取更多的数据，如果缓冲区已满，那么缓冲区会在任何读取操作前自动扩容为原来的两倍</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    input := <span class="string">&quot;abcdefghijkl&quot;</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    split := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%t\t%d\t%s\n&quot;</span>, atEOF, <span class="built_in">len</span>(data), data)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    scanner.Split(split)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">    scanner.Buffer(buf, bufio.MaxScanTokenSize)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">false	2	ab</span><br><span class="line">false	4	abcd</span><br><span class="line">false	8	abcdefgh</span><br><span class="line">false	12	abcdefghijkl</span><br><span class="line">true	12	abcdefghijkl</span><br></pre></td></tr></table></figure>

<p>上例中的 <code>split</code> 函数可以说是简单且极其贪婪的 – 总是请求更多的数据， <code>Scanner</code> 尝试读取更多的数据的同时会保证缓冲区拥有足够的空间来存放这些数据。在上面的例子中，我们将缓冲区的大小设置为 2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf := make([]byte, 2)</span><br><span class="line">scanner.Buffer(buf, bufio.MaxScanTokenSize)</span><br></pre></td></tr></table></figure>

<p>在 <code>split</code> 函数第一次被调用后，<code>scanner</code> 会倍增缓冲区的容量，读取更多的数据，然后再次调用 <code>split</code> 函数。在第二次调用之后增长倍数仍然保持不变，通过观察输出结果可以发现第一次调用 <code>split</code> 得到大小为 2 的切片，然后是 4、8，最后到 12，因为没有更多的数据了。</p>
</blockquote>
<p><code>atEOF</code> 这个参数，通过这个参数我们能够在 <code>split</code> 函数中判断是否还有数据可供使用，它能够在达到数据末尾 （EOF） 或者是读取出错的时候触发为真，一旦任何上述情况发生， <code>scanner</code> 将拒绝读取任何东西，</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    input := <span class="string">&quot;abcdefghijkl&quot;</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    split := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%t\t%d\t%s\n&quot;</span>, atEOF, <span class="built_in">len</span>(data), data)</span><br><span class="line">        <span class="keyword">if</span> atEOF &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;bad luck&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    scanner.Split(split)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">12</span>)</span><br><span class="line">    scanner.Buffer(buf, bufio.MaxScanTokenSize)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> scanner.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;error: %s\n&quot;</span>, scanner.Err())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false	12	abcdefghijkl</span><br><span class="line">true	12	abcdefghijkl</span><br><span class="line">error: bad luck</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>bufio 包定义的 split 函数，即 SplitFunc 的实例</strong></p>
<p>在 bufio 包中预定义了一些 split 函数，也就是说，在 Scanner 结构中的 split 字段，可以通过这些预定义的 split 赋值，同时 Scanner 类型的 Split 方法也可以接收这些预定义函数作为参数。所以，我们可以说，这些预定义 split 函数都是 SplitFunc 类型的实例。这些函数包括：ScanBytes、ScanRunes、ScanWords 和 ScanLines。（由于都是 SplitFunc 的实例，自然这些函数的签名都和 SplitFunc 一样）</p>
<ul>
<li><strong>ScanBytes</strong> 返回单个字节作为一个 token。</li>
<li><strong>ScanRunes</strong> 返回单个 UTF-8 编码的 rune 作为一个 token。返回的 rune 序列（token）和 range string类型 返回的序列是等价的，也就是说，对于无效的 UTF-8 编码会解释为 U+FFFD = “\xef\xbf\xbd”。</li>
<li><strong>ScanWords</strong> 返回通过“空格”分词的单词。如：study golang，调用会返回study。注意，这里的“空格”是 <code>unicode.IsSpace()</code>，即包括：’\t’, ‘\n’, ‘\v’, ‘\f’, ‘\r’, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP)。</li>
<li><strong>ScanLines</strong> 返回一行文本，不包括行尾的换行符。这里的换行包括了Windows下的”\r\n”和Unix下的”\n”。</li>
</ul>
<p>一般地，我们不会单独使用这些函数，而是提供给 Scanner 实例使用。</p>
<p>现在我们回到 Scanner 的 split、maxTokenSize 和 token 字段上来。</p>
<ul>
<li><strong>split 字段</strong>（SplitFunc 类型实例），很显然，代表了当前 Scanner 使用的分词策略，可以使用上面介绍的预定义 SplitFunc 实例赋值，也可以自定义 SplitFunc 实例。（当然，要给 split 字段赋值，必须调用 Scanner 的 Split 方法）</li>
<li><strong>maxTokenSize 字段</strong> 表示通过 split 分词后的一个 token 允许的最大长度。在该包中定义了一个常量 MaxScanTokenSize = 64 * 1024，这是允许的最大 token 长度（64k）。</li>
<li><strong>token 字段</strong> 上文已经解释了这个是什么意思。</li>
</ul>
<h3 id="Scanner-的实例化"><a href="#Scanner-的实例化" class="headerlink" title="Scanner 的实例化"></a>Scanner 的实例化</h3><p>Scanner 没有导出任何字段，而它需要有外部的 io.Reader 对象，因此，我们不能直接实例化 Scanner 对象，必须通过 bufio 包提供的实例化函数来实例化。实例化函数签名以及内部实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScanner</span><span class="params">(r io.Reader)</span> *<span class="title">Scanner</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Scanner&#123;</span><br><span class="line">    r:            r,</span><br><span class="line">    split:        ScanLines,</span><br><span class="line">    maxTokenSize: MaxScanTokenSize,</span><br><span class="line">    buf:          <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>), <span class="comment">// Plausible starting size; needn&#x27;t be large.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，返回的 Scanner 实例默认的 split 函数是 ScanLines。</p>
<h3 id="Scanner-的方法"><a href="#Scanner-的方法" class="headerlink" title="Scanner 的方法"></a>Scanner 的方法</h3><p><strong>Split 方法</strong> 前面我们提到过可以通过 Split 方法为 Scanner 实例设置分词行为。由于 Scanner 实例的默认 split 总是 ScanLines，如果我们想要用其他的 split，可以通过 Split 方法做到。</p>
<p>比如，我们想要统计一段英文有多少个单词（不排除重复），我们可以这么做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">&quot;This is The Golang Standard Library.\nWelcome you!&quot;</span></span><br><span class="line">scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">scanner.Split(bufio.ScanWords)</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">  count++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Fprintln(os.Stderr, <span class="string">&quot;reading input:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(count)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output：8</span></span><br></pre></td></tr></table></figure>

<p>我们实例化 Scanner 后，通过调用 scanner.Split(bufio.ScanWords) 来更改 split 函数。注意，我们应该在调用 Scan 方法之前调用 Split 方法。</p>
<p><strong>Scan 方法</strong> 该方法<strong>好比 iterator 中的 Next 方法</strong>，它用于将 Scanner 获取下一个 token，以便 Bytes 和 Text 方法可用。当扫描停止时，它返回false，这时候，要么是到了输入的末尾要么是遇到了一个错误。注意，当 Scan 返回 false 时，通过 Err 方法可以获取第一个遇到的错误（<strong>但如果错误是 io.EOF，Err 方法会返回 nil</strong>）。</p>
<p><strong>Bytes 和 Text 方法</strong> 这两个方法的行为一致，都是返回最近的 token，无非 Bytes 返回的是 []byte，Text 返回的是 string。该方法应该在 Scan 调用后调用，而且，下次调用 Scan 会覆盖这次的 token。比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scanner := bufio.NewScanner(strings.NewReader(<span class="string">&quot;http://studygolang.com. \nIt is the home of gophers&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> scanner.Scan() &#123;</span><br><span class="line">  scanner.Scan()</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s&quot;</span>, scanner.Text())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的是：<code>It is the home of gophers</code> 而不是 <code>http://studygolang.com.</code></p>
<p><strong>Err 方法</strong> 前面已经提到，通过 Err 方法可以获取第一个遇到的错误（但如果错误是 io.EOF，Err 方法会返回 nil）。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>我们经常会有这样的需求：读取文件中的数据，一次读取一行。在学习了 Reader 类型，我们可以使用它的 ReadBytes 或 ReadString来实现，甚至使用 ReadLine 来实现。然而，在 Go1.1 中，我们可以使用 Scanner 来做这件事，而且更简单好用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Create(<span class="string">&quot;scanner.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">file.WriteString(<span class="string">&quot;http://studygolang.com.\nIt is the home of gophers.\nIf you are studying golang, welcome you!&quot;</span>)</span><br><span class="line"><span class="comment">// 将文件 offset 设置到文件开头</span></span><br><span class="line">file.Seek(<span class="number">0</span>, os.SEEK_SET)</span><br><span class="line">scanner := bufio.NewScanner(file)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">  fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://studygolang.com.</span><br><span class="line">It is the home of gophers.</span><br><span class="line">If you are studying golang, welcome you!</span><br></pre></td></tr></table></figure>



<h2 id="Writer-类型和方法"><a href="#Writer-类型和方法" class="headerlink" title="Writer 类型和方法"></a>Writer 类型和方法</h2><p>bufio.Writer 结构包装了一个 io.Writer 对象，提供缓存功能，同时实现了 io.Writer 接口。</p>
<p>Writer 结构没有任何导出的字段，结构定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">  err error        <span class="comment">// 写过程中遇到的错误</span></span><br><span class="line">  buf []<span class="keyword">byte</span>        <span class="comment">// 缓存</span></span><br><span class="line">  n   <span class="keyword">int</span>            <span class="comment">// 当前缓存中的字节数</span></span><br><span class="line">  wr  io.Writer    <span class="comment">// 底层的 io.Writer 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比 bufio.Reader, bufio.Writer 结构定义简单很多。</p>
<p>注意：如果在写数据到 Writer 的时候出现了一个错误，不会再允许有数据被写进来了，并且所有随后的写操作都会返回该错误。</p>
<p>bufio.Write(p []byte) 的思路如下</p>
<ol>
<li>判断buf中可用容量是否可以放下 p</li>
<li>如果能放下，直接把p拼接到buf后面，即把内容放到缓冲区</li>
<li>如果缓冲区的可用容量不足以放下，且此时缓冲区是空的，<strong>直接把p写入文件</strong>即可</li>
<li>如果缓冲区的可用容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区。判断p的剩余内容大小能否放到缓冲区，如果能放下（此时和步骤1情况一样）则把内容放到缓冲区，如果p的剩余内容依旧大于缓冲区，（注意此时缓冲区是空的，情况和步骤3一样）则把p的剩余内容直接写入文件。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write writes the contents of p into the buffer.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written.</span></span><br><span class="line"><span class="comment">// If nn &lt; len(p), it also returns an error explaining</span></span><br><span class="line"><span class="comment">// why the write is short.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(p) &gt; b.Available() &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> b.Buffered() == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Large write, empty buffer.</span></span><br><span class="line">            <span class="comment">// Write directly from p to avoid copy.</span></span><br><span class="line">            n, b.err = b.wr.Write(p)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n = <span class="built_in">copy</span>(b.buf[b.n:], p)</span><br><span class="line">            b.n += n</span><br><span class="line">            b.Flush()</span><br><span class="line">        &#125;</span><br><span class="line">        nn += n</span><br><span class="line">        p = p[n:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nn, b.err</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">copy</span>(b.buf[b.n:], p)</span><br><span class="line">    b.n += n</span><br><span class="line">    nn += n</span><br><span class="line">    <span class="keyword">return</span> nn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>b.wr 存储的是一个io.writer对象，实现了Write()的接口，所以可以使用b.wr.Write(p) 将p的内容写入文件。</li>
<li>b.flush() 会将缓存区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush()到文件。</li>
<li>b.Available() 为buf可用容量，等于len(buf) - n。</li>
</ul>
<h3 id="bufio-Writer-实现接口"><a href="#bufio-Writer-实现接口" class="headerlink" title="bufio.Writer 实现接口"></a>bufio.Writer 实现接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewWriterSize 将 wr 封装成一个带缓存的 bufio.Writer 对象，</span></span><br><span class="line"><span class="comment">// 缓存大小由 size 指定（如果小于 4096 则会被设置为 4096）。</span></span><br><span class="line"><span class="comment">// 如果 wr 的基类型就是有足够缓存的 bufio.Writer 类型，则直接将</span></span><br><span class="line"><span class="comment">// wr 转换为基类型返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(wr io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewWriter 相当于 NewWriterSize(wr, 4096)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(wr io.Writer)</span> *<span class="title">Writer</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteString 功能同 Write，只不过写入的是字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteRune 向 b 写入 r 的 UTF-8 编码，返回 r 的编码长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(size <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush 将缓存中的数据提交到底层的 io.Writer 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Flush</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Available 返回缓存中未使用的空间的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Available</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Buffered 返回缓存中未提交的数据的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 将 b 的底层 Writer 重新指定为 w，同时丢弃缓存中的所有数据，复位</span></span><br><span class="line"><span class="comment">// 所有标记和错误信息。相当于创建了一个新的 bufio.Writer。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Reset</span><span class="params">(w io.Writer)</span></span></span><br></pre></td></tr></table></figure>



<h3 id="实例化-1"><a href="#实例化-1" class="headerlink" title="实例化"></a>实例化</h3><p>和 Reader 类型一样，bufio 包提供了两个实例化 bufio.Writer 对象的函数：NewWriter 和 NewWriterSize。其中，NewWriter 函数是调用 NewWriterSize 函数实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(wr io.Writer)</span> *<span class="title">Writer</span></span> &#123;</span><br><span class="line">  <span class="comment">// 默认缓存大小：defaultBufSize=4096</span></span><br><span class="line">  <span class="keyword">return</span> NewWriterSize(wr, defaultBufSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下 NewWriterSize 的源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(wr io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span> &#123;</span><br><span class="line">  <span class="comment">// 已经是 bufio.Writer 类型，且缓存大小不小于 size，则直接返回</span></span><br><span class="line">  b, ok := wr.(*Writer)</span><br><span class="line">  <span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    size = defaultBufSize</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;Writer&#123;</span><br><span class="line">    buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, size),</span><br><span class="line">    wr:  w,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Available-和-Buffered-方法"><a href="#Available-和-Buffered-方法" class="headerlink" title="Available 和 Buffered 方法"></a>Available 和 Buffered 方法</h3><p>Available 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）；Buffered 方法获取写入当前缓存中的字节数（字段 n 的值）</p>
<h3 id="Flush-方法"><a href="#Flush-方法" class="headerlink" title="Flush 方法"></a>Flush 方法</h3><p>该方法将缓存中的所有数据写入底层的 io.Writer 对象中。使用 bufio.Writer 时，在所有的 Write 操作完成之后，应该调用 Flush 方法使得缓存都写入 io.Writer 对象中。</p>
<h3 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h3><p>Writer 类型其他方法是一些实际的写方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了 io.ReaderFrom 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 io.Writer 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现了 io.ByteWriter 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// io 中没有该方法的接口，它用于写入单个 Unicode 码点，返回写入的字节数（码点占用的字节），内部实现会根据当前 rune 的范围调用 WriteByte 或 WriteString</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(size <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入字符串，如果返回写入的字节数比 len(s) 小，返回的error会解释原因</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>这些写方法在缓存满了时会调用 Flush 方法。另外，这些写方法源码开始处，有这样的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> b.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，只要写的过程中遇到了错误，再次调用写操作会直接返回该错误。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     fileName := <span class="string">&quot;/Users/ruby/Documents/pro/a/cc.txt&quot;</span></span><br><span class="line">     file,err := os.OpenFile(fileName,os.O_CREATE|os.O_WRONLY,os.ModePerm)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">     w1 := bufio.NewWriter(file)</span><br><span class="line">     <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++&#123;</span><br><span class="line">        w1.WriteString(fmt.Sprintf(<span class="string">&quot;%d:hello&quot;</span>,i))</span><br><span class="line">     &#125;</span><br><span class="line">     w1.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ReadWriter-类型和实例化"><a href="#ReadWriter-类型和实例化" class="headerlink" title="ReadWriter 类型和实例化"></a>ReadWriter 类型和实例化</h2><p>ReadWriter 结构存储了 bufio.Reader 和 bufio.Writer 类型的指针（内嵌），它实现了 io.ReadWriter 结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">  *Reader</span><br><span class="line">  *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReadWriter 的实例化可以跟普通结构类型一样，也可以通过调用 bufio.NewReadWriter 函数来实现：只是简单的实例化 ReadWriter</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReadWriter</span><span class="params">(r *Reader, w *Writer)</span> *<span class="title">ReadWriter</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;ReadWriter&#123;r, w&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>