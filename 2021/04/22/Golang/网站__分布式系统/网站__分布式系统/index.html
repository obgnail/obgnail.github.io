<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="地址："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>分布式系统 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-04-22</div></div></div><div class="container post-header"><h1>分布式系统</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">分布式id生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-worker-id%E5%88%86%E9%85%8D"><span class="toc-number">1.1.</span> <span class="toc-text">6.1.1 worker_id分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%BC%80%E6%BA%90%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.</span> <span class="toc-text">6.1.2 开源实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-1-%E6%A0%87%E5%87%86snowflake%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">6.1.2.1 标准snowflake实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-2-sonyflake"><span class="toc-number">1.2.2.</span> <span class="toc-text">6.1.2.2 sonyflake</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E8%BF%9B%E7%A8%8B%E5%86%85%E5%8A%A0%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">6.2.1 进程内加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-trylock"><span class="toc-number">2.2.</span> <span class="toc-text">6.2.2 trylock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E5%9F%BA%E4%BA%8ERedis%E7%9A%84setnx"><span class="toc-number">2.3.</span> <span class="toc-text">6.2.3 基于Redis的setnx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-%E5%9F%BA%E4%BA%8EZooKeeper"><span class="toc-number">2.4.</span> <span class="toc-text">6.2.4 基于ZooKeeper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5-%E5%9F%BA%E4%BA%8Eetcd"><span class="toc-number">2.5.</span> <span class="toc-text">6.2.5 基于etcd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-7-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E9%94%81"><span class="toc-number">2.6.</span> <span class="toc-text">6.2.7 如何选择合适的锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">延时任务系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">6.3.1 定时器的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-1-%E6%97%B6%E9%97%B4%E5%A0%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">6.3.1.1 时间堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-2-%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="toc-number">3.1.2.</span> <span class="toc-text">6.3.1.2 时间轮</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E4%BB%BB%E5%8A%A1%E5%88%86%E5%8F%91"><span class="toc-number">3.2.</span> <span class="toc-text">6.3.2 任务分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-%E6%95%B0%E6%8D%AE%E5%86%8D%E5%B9%B3%E8%A1%A1%E5%92%8C%E5%B9%82%E7%AD%89%E8%80%83%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">6.3.3 数据再平衡和幂等考量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span class="toc-number">4.</span> <span class="toc-text">分布式搜索引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E"><span class="toc-number">4.1.</span> <span class="toc-text">搜索引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">倒排列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-DSL"><span class="toc-number">4.1.2.</span> <span class="toc-text">查询 DSL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eclient-SDK%E5%81%9A%E5%BC%80%E5%8F%91"><span class="toc-number">4.1.3.</span> <span class="toc-text">基于client SDK做开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86-sql-%E8%BD%AC%E6%8D%A2%E4%B8%BA-DSL"><span class="toc-number">4.1.4.</span> <span class="toc-text">将 sql 转换为 DSL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.</span> <span class="toc-text">异构数据同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%97%B6%E9%97%B4%E6%88%B3%E8%BF%9B%E8%A1%8C%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.1.</span> <span class="toc-text">通过时间戳进行增量数据同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-binlog-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">通过 binlog 进行数据同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">5.</span> <span class="toc-text">负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">5.1.</span> <span class="toc-text">6.5.1 常见的负载均衡思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2-%E5%9F%BA%E4%BA%8E%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">6.5.2 基于洗牌算法的负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-1-%E9%94%99%E8%AF%AF%E7%9A%84%E6%B4%97%E7%89%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B4%9F%E8%BD%BD%E4%B8%8D%E5%9D%87%E8%A1%A1"><span class="toc-number">5.2.1.</span> <span class="toc-text">6.5.2.1 错误的洗牌导致的负载不均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-2-%E4%BF%AE%E6%AD%A3%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">6.5.2.2 修正洗牌算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-3-ZooKeeper-%E9%9B%86%E7%BE%A4%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9%E6%8C%91%E9%80%89%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">6.5.3 ZooKeeper 集群的随机节点挑选问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-4-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%95%88%E6%9E%9C%E9%AA%8C%E8%AF%81"><span class="toc-number">5.4.</span> <span class="toc-text">6.5.4 负载均衡算法效果验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">分布式配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B"><span class="toc-number">6.1.</span> <span class="toc-text">6.6.1 场景举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-1-%E6%8A%A5%E8%A1%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.6.1.1 报表系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-2-%E4%B8%9A%E5%8A%A1%E9%85%8D%E7%BD%AE"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.6.1.2 业务配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2-%E4%BD%BF%E7%94%A8etcd%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%96%B0"><span class="toc-number">6.2.</span> <span class="toc-text">6.6.2 使用etcd实现配置更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-1-%E9%85%8D%E7%BD%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.6.2.1 配置定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-2-%E6%96%B0%E5%BB%BA-etcd-client"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.6.2.2 新建 etcd client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-3-%E9%85%8D%E7%BD%AE%E8%8E%B7%E5%8F%96"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.6.2.3 配置获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-4-%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%96%B0%E8%AE%A2%E9%98%85"><span class="toc-number">6.2.4.</span> <span class="toc-text">6.6.2.4 配置更新订阅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-5-%E6%95%B4%E5%90%88%E8%B5%B7%E6%9D%A5"><span class="toc-number">6.2.5.</span> <span class="toc-text">6.6.2.5 整合起来</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3-%E9%85%8D%E7%BD%AE%E8%86%A8%E8%83%80"><span class="toc-number">6.3.</span> <span class="toc-text">6.6.3 配置膨胀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-4-%E9%85%8D%E7%BD%AE%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">6.6.4 配置版本管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%B9%E9%94%99"><span class="toc-number">6.5.</span> <span class="toc-text">6.6.5 客户端容错</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB"><span class="toc-number">7.</span> <span class="toc-text">分布式爬虫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-1-%E5%9F%BA%E4%BA%8Ecolly%E7%9A%84%E5%8D%95%E6%9C%BA%E7%88%AC%E8%99%AB"><span class="toc-number">7.1.</span> <span class="toc-text">6.7.1 基于colly的单机爬虫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-2-%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB"><span class="toc-number">7.2.</span> <span class="toc-text">6.7.2 分布式爬虫</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-1-nats%E7%AE%80%E4%BB%8B"><span class="toc-number">7.2.1.</span> <span class="toc-text">6.7.2.1 nats简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">基本消息生产</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">基本消息消费</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-3-%E7%BB%93%E5%90%88nats%E5%92%8Ccolly%E7%9A%84%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7"><span class="toc-number">7.3.</span> <span class="toc-text">6.7.3 结合nats和colly的消息生产</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-4-%E7%BB%93%E5%90%88colly%E7%9A%84%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9"><span class="toc-number">7.4.</span> <span class="toc-text">6.7.4 结合colly的消息消费</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://chai2010.cn/advanced-go-programming-book/ch6-cloud/readme.html">分布式系统</a></li>
</ul>
<h2 id="分布式id生成器"><a href="#分布式id生成器" class="headerlink" title="分布式id生成器"></a>分布式id生成器</h2><p>有时我们需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复的id。以支持业务中的高并发场景。比较典型的，电商促销时，短时间内会有大量的订单涌入到系统，比如每秒10w+。</p>
<p>在插入数据库之前，我们需要给这些消息、订单先打上一个ID，然后再插入到我们的数据库。对这个id的要求是希望其中能<strong>带有一些时间信息</strong>，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进行排序。</p>
<p>Twitter的snowflake算法是这种场景下的一个典型解法。</p>
<p><img src="/images/ch6-snowflake.png" alt="snowflake"></p>
<p><em>图 6-1 snowflake中的比特位分布</em></p>
<p>首先确定我们的数值是64位，int64类型，被划分为四部分，</p>
<ul>
<li>不含开头的第一个bit，因为这个bit是符号位。</li>
<li>用41位来表示收到请求时的时间戳，单位为毫秒，</li>
<li>然后五位来表示数据中心的id，然后再五位来表示机器的实例id，</li>
<li>最后是12位的循环自增id（到达1111,1111,1111后会归0）。</li>
</ul>
<p>这样的机制可以支持我们在同一台机器上，同一毫秒内产生<code>2 ^ 12 = 4096</code>条消息。一秒共409.6万条消息。从值域上来讲完全够用了。</p>
<p>数据中心加上实例id共有10位，可以支持我们每数据中心部署32台机器，所有数据中心共1024台实例。</p>
<p>表示<code>timestamp</code>的41位，可以支持我们使用69年。当然，我们的时间毫秒计数不会真的从1970年开始记，那样我们的系统跑到<code>2039/9/7 23:47:35</code>就不能用了，所以这里的<code>timestamp</code>只是相对于某个时间的增量，比如我们的系统上线是2018-08-01，那么我们可以把这个timestamp当作是从<code>2018-08-01 00:00:00.000</code>的偏移量。</p>
<h3 id="6-1-1-worker-id分配"><a href="#6-1-1-worker-id分配" class="headerlink" title="6.1.1 worker_id分配"></a>6.1.1 worker_id分配</h3><p><code>timestamp</code>，<code>datacenter_id</code>，<code>worker_id</code>和<code>sequence_id</code>这四个字段中，<code>timestamp</code>和<code>sequence_id</code>是由程序在运行期生成的。但<code>datacenter_id</code>和<code>worker_id</code>需要我们在部署阶段就能够获取得到，并且一旦程序启动之后，就是不可更改的了（想想，如果可以随意更改，可能被不慎修改，造成最终生成的id有冲突）。</p>
<p>一般不同数据中心的机器，会提供对应的获取数据中心id的API，所以<code>datacenter_id</code>我们可以在部署阶段轻松地获取到。而worker_id是我们逻辑上给机器分配的一个id，这个要怎么办呢？比较简单的想法是由能够提供这种自增id功能的工具来支持，比如MySQL:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> insert into a (ip) values(<span class="string">&quot;10.1.2.101&quot;</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select last_insert_id();</span></span><br><span class="line">+------------------+</span><br><span class="line">| last_insert_id() |</span><br><span class="line">+------------------+</span><br><span class="line">|                2 |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从MySQL中获取到<code>worker_id</code>之后，就把这个<code>worker_id</code>直接持久化到本地，以避免每次上线时都需要获取新的<code>worker_id</code>。让单实例的<code>worker_id</code>可以始终保持不变。</p>
<p>当然，使用MySQL相当于给我们简单的id生成服务增加了一个外部依赖。依赖越多，我们的服务的可运维性就越差。</p>
<p>考虑到集群中即使有单个id生成服务的实例挂了，也就是损失一段时间的一部分id，所以我们也可以更简单暴力一些，把<code>worker_id</code>直接写在worker的配置中，上线时，由部署脚本完成<code>worker_id</code>字段替换。</p>
<h3 id="6-1-2-开源实例"><a href="#6-1-2-开源实例" class="headerlink" title="6.1.2 开源实例"></a>6.1.2 开源实例</h3><h4 id="6-1-2-1-标准snowflake实现"><a href="#6-1-2-1-标准snowflake实现" class="headerlink" title="6.1.2.1 标准snowflake实现"></a>6.1.2.1 标准snowflake实现</h4><p><code>github.com/bwmarrin/snowflake</code> 是一个相当轻量化的snowflake的Go实现。其文档对各位使用的定义见<em>图 6-2</em>所示。</p>
<p><img src="/images/ch6-snowflake-easy.png" alt="ch6-snowflake-easy"></p>
<p><em>图 6-2 snowflake库</em></p>
<p>和标准的snowflake完全一致。使用上比较简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/bwmarrin/snowflake&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n, err := snowflake.NewNode(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        id := n.Generate()</span><br><span class="line">        fmt.Println(<span class="string">&quot;id&quot;</span>, id)</span><br><span class="line">        fmt.Println(</span><br><span class="line">            <span class="string">&quot;node: &quot;</span>, id.Node(),</span><br><span class="line">            <span class="string">&quot;step: &quot;</span>, id.Step(),</span><br><span class="line">            <span class="string">&quot;time: &quot;</span>, id.Time(),</span><br><span class="line">            <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个库也给我们留好了定制的后路，其中预留了一些可定制字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epoch is set to the twitter snowflake epoch of Nov 04 2010 01:42:54 UTC</span></span><br><span class="line"><span class="comment">// You may customize this to set a different epoch for your application.</span></span><br><span class="line">Epoch <span class="keyword">int64</span> = <span class="number">1288834974657</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of bits to use for Node</span></span><br><span class="line"><span class="comment">// Remember, you have a total 22 bits to share between Node/Step</span></span><br><span class="line">NodeBits <span class="keyword">uint8</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of bits to use for Step</span></span><br><span class="line"><span class="comment">// Remember, you have a total 22 bits to share between Node/Step</span></span><br><span class="line">StepBits <span class="keyword">uint8</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><code>Epoch</code>就是本节开头讲的起始时间，<code>NodeBits</code>指的是机器编号的位长，<code>StepBits</code>指的是自增序列的位长。</p>
<h4 id="6-1-2-2-sonyflake"><a href="#6-1-2-2-sonyflake" class="headerlink" title="6.1.2.2 sonyflake"></a>6.1.2.2 sonyflake</h4><p>sonyflake是Sony公司的一个开源项目，基本思路和snowflake差不多，不过位分配上稍有不同，见<em>图 6-3</em>：</p>
<p><img src="/images/ch6-snoyflake.png" alt="sonyflake"></p>
<p><em>图 6-3 sonyflake</em></p>
<p>这里的时间只用了39个bit，但时间的单位变成了10ms，所以理论上比41位表示的时间还要久(174年)。</p>
<p><code>Sequence ID</code>和之前的定义一致，<code>Machine ID</code>其实就是节点id。<code>sonyflake</code>与众不同的地方在于其在启动阶段的配置参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSonyflake</span><span class="params">(st Settings)</span> *<span class="title">Sonyflake</span></span></span><br></pre></td></tr></table></figure>

<p><code>Settings</code>数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Settings <span class="keyword">struct</span> &#123;</span><br><span class="line">    StartTime      time.Time</span><br><span class="line">    MachineID      <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">uint16</span>, error)</span></span></span><br><span class="line">    CheckMachineID <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">uint16</span>)</span> <span class="title">bool</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StartTime</code>选项和我们之前的<code>Epoch</code>差不多，如果不设置的话，默认是从<code>2014-09-01 00:00:00 +0000 UTC</code>开始。</p>
<p><code>MachineID</code>可以由用户自定义的函数，如果用户不定义的话，会默认将本机IP的低16位作为<code>machine id</code>。</p>
<p><code>CheckMachineID</code>是由用户提供的检查<code>MachineID</code>是否冲突的函数。这里的设计还是比较巧妙的，如果有另外的中心化存储并支持检查重复的存储，那我们就可以按照自己的想法随意定制这个检查<code>MachineID</code>是否冲突的逻辑。如果公司有现成的Redis集群，那么我们可以很轻松地用Redis的集合类型来检查冲突。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>使用起来也比较简单，有一些逻辑简单的函数就略去实现了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/sony/sonyflake&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMachineID</span><span class="params">()</span> <span class="params">(<span class="keyword">uint16</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> machineID <span class="keyword">uint16</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    machineID = readMachineIDFromLocalFile()</span><br><span class="line">    <span class="keyword">if</span> machineID == <span class="number">0</span> &#123;</span><br><span class="line">        machineID, err = generateMachineID()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> machineID, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkMachineID</span><span class="params">(machineID <span class="keyword">uint16</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    saddResult, err := saddMachineIDToRedisSet()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || saddResult == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := saveMachineIDToLocalFile(machineID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t, _ := time.Parse(<span class="string">&quot;2006-01-02&quot;</span>, <span class="string">&quot;2018-01-01&quot;</span>)</span><br><span class="line">    settings := sonyflake.Settings&#123;</span><br><span class="line">        StartTime:      t,</span><br><span class="line">        MachineID:      getMachineID,</span><br><span class="line">        CheckMachineID: checkMachineID,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sf := sonyflake.NewSonyflake(settings)</span><br><span class="line">    id, err := sf.NextID()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>在单机程序并发或并行修改全局变量时，需要对修改行为加锁以创造临界区。为什么需要加锁呢？我们看看在不加锁的情况下并发计数会发生什么情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            counter++</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">println</span>(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次运行会得到不同的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯❯❯ go run local_lock.go</span><br><span class="line">945</span><br><span class="line">❯❯❯ go run local_lock.go</span><br><span class="line">937</span><br><span class="line">❯❯❯ go run local_lock.go</span><br><span class="line">959</span><br></pre></td></tr></table></figure>



<h3 id="6-2-1-进程内加锁"><a href="#6-2-1-进程内加锁" class="headerlink" title="6.2.1 进程内加锁"></a>6.2.1 进程内加锁</h3><p>想要得到正确的结果的话，要把对计数器（counter）的操作代码部分加上锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 省略之前部分</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        l.Lock()</span><br><span class="line">        counter++</span><br><span class="line">        l.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">println</span>(counter)</span><br><span class="line"><span class="comment">// ... 省略之后部分</span></span><br></pre></td></tr></table></figure>

<p>这样就可以稳定地得到计算结果了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯❯❯ go run local_lock.go</span><br><span class="line">1000</span><br></pre></td></tr></table></figure>



<h3 id="6-2-2-trylock"><a href="#6-2-2-trylock" class="headerlink" title="6.2.2 trylock"></a>6.2.2 trylock</h3><p>在某些场景，我们只是希望一个任务有单一的执行者。而不像计数器场景一样，所有goroutine都执行成功。后来的goroutine在抢锁失败后，需要放弃其流程。这时候就需要trylock了。</p>
<p>trylock顾名思义，尝试加锁，加锁成功执行后续流程，如果加锁失败的话也不会阻塞，而会直接返回加锁的结果。在Go语言中我们可以用大小为1的Channel来模拟trylock：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock try lock</span></span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">struct</span> &#123;</span><br><span class="line">    c <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLock generate a try lock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLock</span><span class="params">()</span> <span class="title">Lock</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l Lock</span><br><span class="line">    l.c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    l.c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock try lock, return lock result</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lock)</span> <span class="title">Lock</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    lockResult := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-l.c:</span><br><span class="line">        lockResult = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lockResult</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock , Unlock the try lock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Lock)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l.c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l = NewLock()</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">if</span> !l.Lock() &#123;</span><br><span class="line">                <span class="comment">// log error</span></span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;lock failed&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            counter++</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;current counter&quot;</span>, counter)</span><br><span class="line">            l.Unlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们的逻辑限定每个goroutine只有成功执行了<code>Lock</code>才会继续执行后续逻辑，因此在<code>Unlock</code>时可以保证Lock结构体中的channel一定是空，从而不会阻塞，也不会失败。上面的代码使用了大小为1的channel来模拟trylock，理论上还可以使用标准库中的CAS来实现相同的功能且成本更低，读者可以自行尝试。</p>
<p>在单机系统中，trylock并不是一个好选择。因为大量的goroutine抢锁可能会导致CPU无意义的资源浪费。有一个专有名词用来描述这种抢锁的场景：活锁。</p>
<p>活锁指的是程序看起来在正常执行，但CPU周期被浪费在抢锁，而非执行任务上，从而程序整体的执行效率低下。活锁的问题定位起来要麻烦很多。所以在单机场景下，不建议使用这种锁。</p>
<h3 id="6-2-3-基于Redis的setnx"><a href="#6-2-3-基于Redis的setnx" class="headerlink" title="6.2.3 基于Redis的setnx"></a>6.2.3 基于Redis的setnx</h3><p>在分布式场景下，我们也需要这种“抢占”的逻辑，这时候怎么办呢？我们可以使用Redis提供的<code>setnx</code>命令：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/go-redis/redis&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">        Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">        DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lockKey = <span class="string">&quot;counter_lock&quot;</span></span><br><span class="line">    <span class="keyword">var</span> counterKey = <span class="string">&quot;counter&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock</span></span><br><span class="line">    resp := client.SetNX(lockKey, <span class="number">1</span>, time.Second*<span class="number">5</span>)</span><br><span class="line">    lockSuccess, err := resp.Result()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !lockSuccess &#123;</span><br><span class="line">        fmt.Println(err, <span class="string">&quot;lock result: &quot;</span>, lockSuccess)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// counter ++</span></span><br><span class="line">    getResp := client.Get(counterKey)</span><br><span class="line">    cntValue, err := getResp.Int64()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> || err == redis.Nil &#123;</span><br><span class="line">        cntValue++</span><br><span class="line">        resp := client.Set(counterKey, cntValue, <span class="number">0</span>)</span><br><span class="line">        _, err := resp.Result()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// log err</span></span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;set value error!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;current counter is &quot;</span>, cntValue)</span><br><span class="line"></span><br><span class="line">    delResp := client.Del(lockKey)</span><br><span class="line">    unlockSuccess, err := delResp.Result()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; unlockSuccess &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;unlock success!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;unlock failed&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            incr()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">❯❯❯ go run redis_setnx.go</span><br><span class="line">&lt;nil&gt; lock result:  false</span><br><span class="line">&lt;nil&gt; lock result:  false</span><br><span class="line">&lt;nil&gt; lock result:  false</span><br><span class="line">&lt;nil&gt; lock result:  false</span><br><span class="line">&lt;nil&gt; lock result:  false</span><br><span class="line">&lt;nil&gt; lock result:  false</span><br><span class="line">&lt;nil&gt; lock result:  false</span><br><span class="line">&lt;nil&gt; lock result:  false</span><br><span class="line">&lt;nil&gt; lock result:  false</span><br><span class="line">current counter is  2028</span><br><span class="line">unlock success!</span><br></pre></td></tr></table></figure>

<p>通过代码和执行结果可以看到，我们远程调用<code>setnx</code>运行流程上和单机的trylock非常相似，如果获取锁失败，那么相关的任务逻辑就不应该继续向前执行。</p>
<p><code>setnx</code>很适合在高并发场景下，用来争抢一些“唯一”的资源。比如交易撮合系统中卖家发起订单，而多个买家会对其进行并发争抢。这种场景我们没有办法依赖具体的时间来判断先后，因为不管是用户设备的时间，还是分布式场景下的各台机器的时间，都是没有办法在合并后保证正确的时序的。哪怕是我们同一个机房的集群，不同的机器的系统时间可能也会有细微的差别。</p>
<p>所以，我们需要依赖于这些请求到达Redis节点的顺序来做正确的抢锁操作。如果用户的网络环境比较差，那也只能自求多福了。</p>
<h3 id="6-2-4-基于ZooKeeper"><a href="#6-2-4-基于ZooKeeper" class="headerlink" title="6.2.4 基于ZooKeeper"></a>6.2.4 基于ZooKeeper</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/samuel/go-zookeeper/zk&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c, _, err := zk.Connect([]<span class="keyword">string</span>&#123;<span class="string">&quot;127.0.0.1&quot;</span>&#125;, time.Second) <span class="comment">//*10)</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    l := zk.NewLock(c, <span class="string">&quot;/lock&quot;</span>, zk.WorldACL(zk.PermAll))</span><br><span class="line">    err = l.Lock()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;lock succ, do your business logic&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do some thing</span></span><br><span class="line">    l.Unlock()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;unlock succ, finish business logic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于ZooKeeper的锁与基于Redis的锁的不同之处在于Lock成功之前会一直阻塞，这与我们单机场景中的<code>mutex.Lock</code>很相似。</p>
<p>其原理也是基于临时Sequence节点和watch API，例如我们这里使用的是<code>/lock</code>节点。Lock会在该节点下的节点列表中插入自己的值，只要节点下的子节点发生变化，就会通知所有watch该节点的程序。这时候程序会检查当前节点下最小的子节点的id是否与自己的一致。如果一致，说明加锁成功了。</p>
<p>这种分布式的阻塞锁比较适合分布式任务调度场景，但不适合高频次持锁时间短的抢锁场景。按照Google的Chubby论文里的阐述，基于强一致协议的锁适用于<code>粗粒度</code>的加锁操作。这里的粗粒度指锁占用时间较长。我们在使用时也应思考在自己的业务场景中使用是否合适。</p>
<h3 id="6-2-5-基于etcd"><a href="#6-2-5-基于etcd" class="headerlink" title="6.2.5 基于etcd"></a>6.2.5 基于etcd</h3><p>etcd是分布式系统中，功能上与ZooKeeper类似的组件，这两年越来越火了。上面基于ZooKeeper我们实现了分布式阻塞锁，基于etcd，也可以实现类似的功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/zieckey/etcdsync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m, err := etcdsync.New(<span class="string">&quot;/lock&quot;</span>, <span class="number">10</span>, []<span class="keyword">string</span>&#123;<span class="string">&quot;http://127.0.0.1:2379&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="literal">nil</span> || err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;etcdsync.New failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = m.Lock()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;etcdsync.Lock failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;etcdsync.Lock OK&quot;</span>)</span><br><span class="line">    log.Printf(<span class="string">&quot;Get the lock. Do something here.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    err = m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;etcdsync.Unlock failed&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;etcdsync.Unlock OK&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>etcd中没有像ZooKeeper那样的Sequence节点。所以其锁实现和基于ZooKeeper实现的有所不同。在上述示例代码中使用的etcdsync的Lock流程是：</p>
<ol>
<li>先检查<code>/lock</code>路径下是否有值，如果有值，说明锁已经被别人抢了</li>
<li>如果没有值，那么写入自己的值。写入成功返回，说明加锁成功。写入时如果节点被其它节点写入过了，那么会导致加锁失败，这时候到 3</li>
<li>watch <code>/lock</code>下的事件，此时陷入阻塞</li>
<li>当<code>/lock</code>路径下发生事件时，当前进程被唤醒。检查发生的事件是否是删除事件（说明锁被持有者主动unlock），或者过期事件（说明锁过期失效）。如果是的话，那么回到 1，走抢锁流程。</li>
</ol>
<p>值得一提的是，在etcdv3的API中官方已经提供了可以直接使用的锁API，读者可以查阅etcd的文档做进一步的学习。</p>
<h3 id="6-2-7-如何选择合适的锁"><a href="#6-2-7-如何选择合适的锁" class="headerlink" title="6.2.7 如何选择合适的锁"></a>6.2.7 如何选择合适的锁</h3><p>业务还在单机就可以搞定的量级时，那么按照需求使用任意的单机锁方案就可以。</p>
<p>如果发展到了分布式服务阶段，但业务规模不大，qps很小的情况下，使用哪种锁方案都差不多。如果公司内已有可以使用的ZooKeeper、etcd或者Redis集群，那么就尽量在不引入新的技术栈的情况下满足业务需求。</p>
<p>业务发展到一定量级的话，就需要从多方面来考虑了。首先是你的锁是否在任何恶劣的条件下都不允许数据丢失，如果不允许，那么就不要使用Redis的<code>setnx</code>的简单锁。</p>
<p>对锁数据的可靠性要求极高的话，那只能使用etcd或者ZooKeeper这种通过一致性协议保证数据可靠性的锁方案。但可靠的背面往往都是较低的吞吐量和较高的延迟。需要根据业务的量级对其进行压力测试，以确保分布式锁所使用的etcd或ZooKeeper集群可以承受得住实际的业务请求压力。需要注意的是，etcd和Zookeeper集群是没有办法通过增加节点来提高其性能的。要对其进行横向扩展，只能增加搭建多个集群来支持更多的请求。这会进一步提高对运维和监控的要求。多个集群可能需要引入proxy，没有proxy那就需要业务去根据某个业务id来做分片。如果业务已经上线的情况下做扩展，还要考虑数据的动态迁移。这些都不是容易的事情。</p>
<p>在选择具体的方案时，还是需要多加思考，对风险早做预估。</p>
<h2 id="延时任务系统"><a href="#延时任务系统" class="headerlink" title="延时任务系统"></a>延时任务系统</h2><p>我们在做系统时，很多时候是处理实时的任务，请求来了马上就处理，然后立刻给用户以反馈。但有时也会遇到非实时的任务，比如确定的时间点发布重要公告。或者需要在用户做了一件事情的X分钟/Y小时后，对其特定动作，比如通知、发券等等。</p>
<p>如果业务规模比较小，有时我们也可以通过数据库配合轮询来对这种任务进行简单处理，但上了规模的公司，自然会寻找更为普适的解决方案来解决这一类问题。</p>
<p>一般有两种思路来解决这个问题：</p>
<ol>
<li>实现一套类似crontab的分布式定时任务管理系统。</li>
<li>实现一个支持定时发送消息的消息队列。</li>
</ol>
<p>两种思路进而衍生出了一些不同的系统，但其本质是差不多的。都是需要实现一个定时器（timer）。</p>
<blockquote>
<p>在单机的场景下定时器其实并不少见，例如我们在和网络库打交道的时候经常会调用<code>SetReadDeadline()</code>函数，就是在本地创建了一个定时器，在到达指定的时间后，我们会收到定时器的通知，告诉我们时间已到。这时候如果读取还没有完成的话，就可以认为发生了网络问题，从而中断读取。</p>
</blockquote>
<p>下面我们从定时器开始，探究延时任务系统的实现。</p>
<h3 id="6-3-1-定时器的实现"><a href="#6-3-1-定时器的实现" class="headerlink" title="6.3.1 定时器的实现"></a>6.3.1 定时器的实现</h3><p>定时器（timer）的实现在工业界已经是有解的问题了。常见的就是时间堆和时间轮。</p>
<h4 id="6-3-1-1-时间堆"><a href="#6-3-1-1-时间堆" class="headerlink" title="6.3.1.1 时间堆"></a>6.3.1.1 时间堆</h4><p>最常见的时间堆一般用小顶堆实现，小顶堆其实就是一种特殊的二叉树，见<em>图6-4</em></p>
<p><img src="/images/ch6-binary_tree.png" alt="二叉堆"></p>
<p><em>图 6-4 二叉堆结构</em></p>
<p>小顶堆的好处是什么呢？对于定时器来说，如果堆顶元素比当前的时间还要大，那么说明堆内所有元素都比当前时间大。进而说明这个时刻我们还没有必要对时间堆进行任何处理。定时检查的时间复杂度是<code>O(1)</code>。</p>
<p>当我们发现堆顶的元素小于当前时间时，那么说明可能已经有一批事件已经开始过期了，这时进行正常的弹出和堆调整操作就好。每一次堆调整的时间复杂度都是<code>O(LgN)</code>。</p>
<p>Go自身的内置定时器就是用时间堆来实现的，不过并没有使用二叉堆，而是使用了扁平一些的四叉堆。在最近的版本中，还加了一些优化，我们先不说优化，先来看看四叉的小顶堆长什么样：</p>
<p><img src="/images/ch6-four-branch-tree.png" alt="四叉堆"></p>
<p><em>图 6-5 四叉堆结构</em></p>
<p>小顶堆的性质，父节点比其4个子节点都小，子节点之间没有特别的大小关系要求。</p>
<p>四叉堆中元素超时和堆调整与二叉堆没有什么本质区别。</p>
<h4 id="6-3-1-2-时间轮"><a href="#6-3-1-2-时间轮" class="headerlink" title="6.3.1.2 时间轮"></a>6.3.1.2 时间轮</h4><p><img src="/images/ch6-timewheel.png" alt="timewheel"></p>
<p><em>图 6-6 时间轮</em></p>
<p>用时间轮来实现定时器时，我们需要定义每一个格子的“刻度”，可以将时间轮想像成一个时钟，中心有秒针顺时针转动。每次转动到一个刻度时，我们就需要去查看该刻度挂载的任务列表是否有已经到期的任务。</p>
<p>从结构上来讲，时间轮和哈希表很相似，如果我们把哈希算法定义为：触发时间%时间轮元素大小。那么这就是一个简单的哈希表。在哈希冲突时，采用链表挂载哈希冲突的定时器。</p>
<p>除了这种单层时间轮，业界也有一些时间轮采用多层实现，这里就不再赘述了。</p>
<h3 id="6-3-2-任务分发"><a href="#6-3-2-任务分发" class="headerlink" title="6.3.2 任务分发"></a>6.3.2 任务分发</h3><p>有了基本的定时器实现方案，如果我们开发的是单机系统，那么就可以撸起袖子开干了，不过本章我们讨论的是分布式，距离“分布式”还稍微有一些距离。</p>
<p>我们还需要把这些“定时”或是“延时”（本质也是定时）任务分发出去。下面是一种思路：</p>
<p><img src="/images/ch6-task-sched.png" alt="task-dist"></p>
<p><em>图 6-7 分布式任务分发</em></p>
<p>每一个实例每隔一小时，会去数据库里把下一个小时需要处理的定时任务捞出来，捞取的时候只要取那些<code>task_id % shard_count = shard_id</code>的那些任务即可。</p>
<p>当这些定时任务被触发之后需要通知用户侧，有两种思路：</p>
<ol>
<li>将任务被触发的信息封装为一条消息，发往消息队列，由用户侧对消息队列进行监听。</li>
<li>对用户预先配置的回调函数进行调用。</li>
</ol>
<p>两种方案各有优缺点，</p>
<ul>
<li>如果采用1，那么如果消息队列出故障会导致整个系统不可用，当然，现在的消息队列一般也会有自身的高可用方案，大多数时候我们不用担心这个问题。其次一般业务流程中间走消息队列的话会导致延时增加，定时任务若必须在触发后的几十毫秒到几百毫秒内完成，那么采用消息队列就会有一定的风险。</li>
<li>如果采用2，会加重定时任务系统的负担。我们知道，单机的定时器执行时最害怕的就是回调函数执行时间过长，这样会阻塞后续的任务执行。在分布式场景下，这种忧虑依然是适用的。一个不负责任的业务回调可能就会直接拖垮整个定时任务系统。所以我们还要考虑在回调的基础上增加经过测试的超时时间设置，并且对由用户填入的超时时间做慎重的审核。</li>
</ul>
<h3 id="6-3-3-数据再平衡和幂等考量"><a href="#6-3-3-数据再平衡和幂等考量" class="headerlink" title="6.3.3 数据再平衡和幂等考量"></a>6.3.3 数据再平衡和幂等考量</h3><p>当我们的任务执行集群有机器故障时，需要对任务进行重新分配。按照之前的求模策略，对这台机器还没有处理的任务进行重新分配就比较麻烦了。如果是实际运行的线上系统，还要在故障时的任务平衡方面花更多的心思。</p>
<p>下面给出一种思路：</p>
<p>我们可以参考Elasticsearch的数据分布设计，每份任务数据都有多个副本，这里假设两副本，如<em>图 6-8</em>所示：</p>
<p><img src="/images/ch6-data-dist1.png" alt="数据分布"></p>
<p><em>图 6-8 任务数据分布</em></p>
<p>一份数据虽然有两个持有者，但持有者持有的副本会进行区分，比如持有的是主副本还是非主副本，主副本在图中为摸黑部分，非主副本为正常线条。</p>
<p>一个任务只会在持有主副本的节点上被执行。</p>
<p>当有机器故障时，任务数据需要进行数据再平衡的工作，比如节点1挂了，见<em>图 6-9</em>。</p>
<p><img src="/images/ch6-data-dist2.png" alt="数据分布2"></p>
<p><em>图 6-9 故障时数据分布</em></p>
<p>节点1的数据会被迁移到节点2和节点3上。</p>
<p>当然，也可以用稍微复杂一些的思路，比如对集群中的节点进行角色划分，由协调节点来做这种故障时的任务重新分配工作，考虑到高可用，协调节点可能也需要有1至2个备用节点以防不测。</p>
<p>之前提到我们会用消息队列触发对用户的通知，在使用消息队列时，很多队列是不支持<code>exactly once</code>的语义的，这种情况下我们需要让用户自己来负责消息的去重或者消费的幂等处理。</p>
<h2 id="分布式搜索引擎"><a href="#分布式搜索引擎" class="headerlink" title="分布式搜索引擎"></a>分布式搜索引擎</h2><p>在Web一章中，我们提到MySQL很脆弱。数据库系统本身要保证实时和强一致性，所以其功能设计上都是为了满足这种一致性需求。比如write ahead log的设计，基于B+树实现的索引和数据组织，以及基于MVCC实现的事务等等。</p>
<p>关系型数据库一般被用于实现OLTP系统，所谓OLTP，援引wikipedia:</p>
<blockquote>
<p>在线交易处理（OLTP, Online transaction processing）是指透过信息系统、电脑网络及数据库，以线上交易的方式处理一般即时性的作业数据，和更早期传统数据库系统大量批量的作业方式并不相同。OLTP通常被运用于自动化的数据处理工作，如订单输入、金融业务…等反复性的日常性交易活动。和其相对的是属于决策分析层次的联机分析处理（OLAP）。</p>
</blockquote>
<p>在互联网的业务场景中，也有一些实时性要求不高(可以接受多秒的延迟)，但是查询复杂性却很高的场景。举个例子，在电商的WMS系统中，或者在大多数业务场景丰富的CRM或者客服系统中，可能需要提供几十个字段的随意组合查询功能。这种系统的数据维度天生众多，比如一个电商的WMS中对一件货物的描述，可能有下面这些字段：</p>
<blockquote>
<p>仓库id，入库时间，库位分区id，储存货架id，入库操作员id，出库操作员id，库存数量，过期时间，SKU类型，产品品牌，产品分类，内件数量</p>
</blockquote>
<p>除了上述信息，如果商品在仓库内有流转。可能还有有关联的流程 id，当前的流转状态等等。</p>
<p>想像一下，如果我们所经营的是一个大型电商，每天有千万级别的订单，那么在这个数据库中查询和建立合适的索引都是一件非常难的事情。</p>
<p>在CRM或客服类系统中，常常有根据关键字进行搜索的需求，大型互联网公司每天会接收数以万计的用户投诉。而考虑到事件溯源，用户的投诉至少要存2~3年。又是千万级甚至上亿的数据。根据关键字进行一次like查询，可能整个MySQL就直接挂掉了。</p>
<p>这时候我们就需要搜索引擎来救场了。</p>
<h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>Elasticsearch是开源分布式搜索引擎的霸主，其依赖于Lucene实现，在部署和运维方面做了很多优化。当今搭建一个分布式搜索引擎比起Sphinx的时代已经是容易很多很多了。只要简单配置客户端IP和端口就可以了。</p>
<h4 id="倒排列表"><a href="#倒排列表" class="headerlink" title="倒排列表"></a>倒排列表</h4><p>虽然es是针对搜索场景来定制的，但如前文所言，实际应用中常常用es来作为database来使用，就是因为倒排列表的特性。可以用比较朴素的观点来理解倒排索引：</p>
<p><img src="/images/ch6-posting_list.png" alt="posting-list"></p>
<p><em>图 6-10 倒排列表</em></p>
<p>对Elasticsearch中的数据进行查询时，本质就是求多个排好序的序列求交集。非数值类型字段涉及到分词问题，大多数内部使用场景下，我们可以直接使用默认的bi-gram分词。什么是bi-gram分词呢：</p>
<p>即将所有<code>Ti</code>和<code>T(i+1)</code>组成一个词（在Elasticsearch中叫term），然后再编排其倒排列表，这样我们的倒排列表大概就是这样的：</p>
<p><img src="/images/ch6-terms.png" alt="terms"></p>
<p><em>图 6-11 “今天天气很好”的分词结果</em></p>
<p>当用户搜索’天气很好’时，其实就是求：天气、气很、很好三组倒排列表的交集，但这里的相等判断逻辑有些特殊，用伪代码表示一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> postEntry.docID of <span class="string">&#x27;天气&#x27;</span> == postEntry.docID of <span class="string">&#x27;气很&#x27;</span> &amp;&amp;</span><br><span class="line">        postEntry.offset + <span class="number">1</span> of <span class="string">&#x27;天气&#x27;</span> == postEntry.offset of <span class="string">&#x27;气很&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> postEntry.docID of <span class="string">&#x27;气很&#x27;</span> == postEntry.docID of <span class="string">&#x27;很好&#x27;</span> &amp;&amp;</span><br><span class="line">        postEntry.offset + <span class="number">1</span> of <span class="string">&#x27;气很&#x27;</span> == postEntry.offset of <span class="string">&#x27;很好&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> postEntry.docID of <span class="string">&#x27;天气&#x27;</span> == postEntry.docID of <span class="string">&#x27;很好&#x27;</span> &amp;&amp;</span><br><span class="line">        postEntry.offset + <span class="number">2</span> of <span class="string">&#x27;天气&#x27;</span> == postEntry.offset of <span class="string">&#x27;很好&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个有序列表求交集的时间复杂度是：<code>O(N * M)</code>，N为给定列表当中元素数最小的集合，M为给定列表的个数。</p>
<p>在整个算法中起决定作用的一是最短的倒排列表的长度，其次是词数总和，一般词数不会很大（想像一下，你会在搜索引擎里输入几百字来搜索么？），所以起决定性作用的，一般是所有倒排列表中，最短的那一个的长度。</p>
<p>因此，文档总数很多的情况下，搜索词的倒排列表最短的那一个不长时，搜索速度也是很快的。如果用关系型数据库，那就需要按照索引（如果有的话）来慢慢扫描了。</p>
<h4 id="查询-DSL"><a href="#查询-DSL" class="headerlink" title="查询 DSL"></a>查询 DSL</h4><p>es定义了一套查询DSL，当我们把es当数据库使用时，需要用到其bool查询。举个例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field_1&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field_2&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field_3&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field_4&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来比较麻烦，但表达的意思很简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> field_1 == <span class="number">1</span> &amp;&amp; field_2 == <span class="number">2</span> &amp;&amp; field_3 == <span class="number">3</span> &amp;&amp; field_4 == <span class="number">4</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用bool should query可以表示or的逻辑：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field_1&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field_2&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里表示的是类似：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> field_1 == <span class="number">1</span> || field_2 == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些Go代码里<code>if</code>后面跟着的表达式在编程语言中有专有名词来表达<code>Boolean Expression</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> &gt; <span class="number">1</span></span><br><span class="line"><span class="number">5</span> == <span class="number">2</span></span><br><span class="line"><span class="number">3</span> &lt; i &amp;&amp; x &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>es的<code>Bool Query</code>方案，就是用json来表达了这种程序语言中的Boolean Expression，为什么可以这么做呢？因为json本身是可以表达树形结构的，我们的程序代码在被编译器parse之后，也会变成AST，而AST抽象语法树，顾名思义，就是树形结构。理论上json能够完备地表达一段程序代码被parse之后的结果。这里的Boolean Expression被编译器Parse之后也会生成差不多的树形结构，而且只是整个编译器实现的一个很小的子集。</p>
<h4 id="基于client-SDK做开发"><a href="#基于client-SDK做开发" class="headerlink" title="基于client SDK做开发"></a>基于client SDK做开发</h4><p>初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选用 elastic 版本时</span></span><br><span class="line"><span class="comment">// 注意与自己使用的 elasticsearch 要对应</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    elastic <span class="string">&quot;gopkg.in/olivere/elastic.v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> esClient *elastic.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initElasticsearchClient</span><span class="params">(host <span class="keyword">string</span>, port <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    esClient, err = elastic.NewClient(</span><br><span class="line">        elastic.SetURL(fmt.Sprintf(<span class="string">&quot;http://%s:%s&quot;</span>, host, port)),</span><br><span class="line">        elastic.SetMaxRetries(<span class="number">3</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// log error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertDocument</span><span class="params">(db <span class="keyword">string</span>, table <span class="keyword">string</span>, obj <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    id := obj[<span class="string">&quot;id&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> indexName, typeName <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 数据库中的 database/table 概念，可以简单映射到 es 的 index 和 type</span></span><br><span class="line">    <span class="comment">// 不过需要注意，因为 es 中的 _type 本质上只是 document 的一个字段</span></span><br><span class="line">    <span class="comment">// 所以单个 index 内容过多会导致性能问题</span></span><br><span class="line">    <span class="comment">// 在新版本中 type 已经废弃</span></span><br><span class="line">    <span class="comment">// 为了让不同表的数据落入不同的 index，这里我们用 table+name 作为 index 的名字</span></span><br><span class="line">    indexName = fmt.Sprintf(<span class="string">&quot;%v_%v&quot;</span>, db, table)</span><br><span class="line">    typeName = table</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况</span></span><br><span class="line">    res, err := esClient.Index().Index(indexName).Type(typeName).Id(id).BodyJson(obj).Do()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// insert success</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(indexName <span class="keyword">string</span>, typeName <span class="keyword">string</span>)</span> <span class="params">(*elastic.SearchResult, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过 bool must 和 bool should 添加 bool 查询条件</span></span><br><span class="line">    q := elastic.NewBoolQuery().Must(elastic.NewMatchPhraseQuery(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>),</span><br><span class="line">    elastic.NewBoolQuery().Must(elastic.NewMatchPhraseQuery(<span class="string">&quot;male&quot;</span>, <span class="string">&quot;m&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    q = q.Should(</span><br><span class="line">        elastic.NewMatchPhraseQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;alex&quot;</span>),</span><br><span class="line">        elastic.NewMatchPhraseQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xargin&quot;</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    searchService := esClient.Search(indexName).Type(typeName)</span><br><span class="line">    res, err := searchService.Query(q).Do()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// log error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDocument</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    indexName <span class="keyword">string</span>, typeName <span class="keyword">string</span>, obj <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    id := obj[<span class="string">&quot;id&quot;</span>]</span><br><span class="line"></span><br><span class="line">    res, err := esClient.Delete().Index(indexName).Type(typeName).Id(id).Do()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// delete success</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Lucene的性质，本质上搜索引擎内的数据是不可变的，所以如果要对文档进行更新，Lucene内部是按照id进行完全覆盖(本质是取同一 id 最新的segment中的数据)的操作，所以与插入的情况是一样的。</p>
<p>使用es作为数据库使用时，需要注意，因为es有索引合并的操作，所以数据插入到es中到可以查询的到需要一段时间（由es的refresh_interval决定）。所以千万不要把es当成强一致的关系型数据库来使用。</p>
<h4 id="将-sql-转换为-DSL"><a href="#将-sql-转换为-DSL" class="headerlink" title="将 sql 转换为 DSL"></a>将 sql 转换为 DSL</h4><p>比如我们有一段bool表达式，<code>user_id = 1 and (product_id = 1 and (star_num = 4 or star_num = 5) and banned = 1)</code>，写成SQL是如下形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> (</span><br><span class="line">    product_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> (star_num <span class="operator">=</span> <span class="number">4</span> <span class="keyword">or</span> star_num <span class="operator">=</span> <span class="number">5</span>) <span class="keyword">and</span> banned <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>写成es的DSL是如下形式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;user_id&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;product_id&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;star_num&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">                  <span class="attr">&quot;star_num&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;5&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;banned&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;phrase&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es的DSL虽然很好理解，但是手写起来非常费劲。前面提供了基于SDK的方式来写，但也不足够灵活。</p>
<p>SQL的where部分就是boolean expression。我们之前提到过，这种bool表达式在被解析之后，和es的DSL的结构长得差不多，我们能不能直接通过这种“差不多”的猜测来直接帮我们把SQL转换成DSL呢？</p>
<p>当然可以，我们把SQL的where被Parse之后的结构和es的DSL的结构做个对比：</p>
<p><img src="/images/ch6-ast-dsl.png" alt="ast"></p>
<p><em>图 6-12 AST和DSL之间的对应关系</em></p>
<p>既然结构上完全一致，逻辑上我们就可以相互转换。我们以广度优先对AST树进行遍历，然后将二元表达式转换成json字符串，再拼装起来就可以了，限于篇幅，本文中就不给出示例了，读者朋友可以查看：</p>
<blockquote>
<p>github.com/cch123/elasticsql</p>
</blockquote>
<p>来学习具体的实现。</p>
<h3 id="异构数据同步"><a href="#异构数据同步" class="headerlink" title="异构数据同步"></a>异构数据同步</h3><p>在实际应用中，我们很少直接向搜索引擎中写入数据。更为常见的方式是，<strong>将MySQL或其它关系型数据中的数据同步到搜索引擎中。</strong>而搜索引擎的使用方只能对数据进行查询，无法进行修改和删除。</p>
<p>常见的同步方案有两种：</p>
<h4 id="通过时间戳进行增量数据同步"><a href="#通过时间戳进行增量数据同步" class="headerlink" title="通过时间戳进行增量数据同步"></a>通过时间戳进行增量数据同步</h4><p><img src="/images/ch6-sync.png" alt="sync to es"></p>
<p><em>图 6-13 基于时间戳的数据同步</em></p>
<p>这种同步方式与业务强绑定，例如WMS系统中的出库单，我们并不需要非常实时，稍微有延迟也可以接受，那么我们可以每分钟从MySQL的出库单表中，把最近十分钟创建的所有出库单取出，批量存入es中，取数据的操作需要执行的逻辑可以表达为下面的SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> wms_orders <span class="keyword">where</span> update_time <span class="operator">&gt;=</span> date_sub(now(), <span class="type">interval</span> <span class="number">10</span> <span class="keyword">minute</span>);</span><br></pre></td></tr></table></figure>

<p>当然，考虑到边界情况，我们可以让这个时间段的数据与前一次的有一些重叠：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> wms_orders <span class="keyword">where</span> update_time <span class="operator">&gt;=</span> date_sub(</span><br><span class="line">    now(), <span class="type">interval</span> <span class="number">11</span> <span class="keyword">minute</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>取最近11分钟有变动的数据覆盖更新到es中。这种方案的缺点显而易见，我们必须要求业务数据严格遵守一定的规范。比如这里的，必须要有update_time字段，并且每次创建和更新都要保证该字段有正确的时间值。否则我们的同步逻辑就会丢失数据。</p>
<h4 id="通过-binlog-进行数据同步"><a href="#通过-binlog-进行数据同步" class="headerlink" title="通过 binlog 进行数据同步"></a>通过 binlog 进行数据同步</h4><p><img src="/images/ch6-binlog-sync.png" alt="binlog-sync"></p>
<p><em>图 6-13 基于binlog的数据同步</em></p>
<p>业界使用较多的是阿里开源的Canal，来进行binlog解析与同步。canal会伪装成MySQL的从库，然后解析好行格式的binlog，再以更容易解析的格式（例如json）发送到消息队列。</p>
<p>由下游的Kafka消费者负责把上游数据表的自增主键作为es的文档的id进行写入，这样可以保证每次接收到binlog时，对应id的数据都被覆盖更新为最新。MySQL的Row格式的binlog会将每条记录的所有字段都提供给下游，所以在向异构数据目标同步数据时，不需要考虑数据是插入还是更新，只要一律按id进行覆盖即可。</p>
<p>这种模式同样需要业务遵守一条数据表规范，即表中必须有唯一主键id来保证我们进入es的数据不会发生重复。一旦不遵守该规范，那么就会在同步时导致数据重复。当然，你也可以为每一张需要的表去定制消费者的逻辑，这就不是通用系统讨论的范畴了。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>本节将会讨论常见的分布式系统负载均衡手段。</p>
<h3 id="6-5-1-常见的负载均衡思路"><a href="#6-5-1-常见的负载均衡思路" class="headerlink" title="6.5.1 常见的负载均衡思路"></a>6.5.1 常见的负载均衡思路</h3><p>如果我们不考虑均衡的话，现在有n个服务节点，我们完成业务流程只需要从这n个中挑出其中的一个。有几种思路:</p>
<ol>
<li>按顺序挑: 例如上次选了第一台，那么这次就选第二台，下次第三台，如果已经到了最后一台，那么下一次从第一台开始。这种情况下我们可以把服务节点信息都存储在数组中，每次请求完成下游之后，将一个索引后移即可。在移到尽头时再移回数组开头处。</li>
<li>随机挑一个: 每次都随机挑，真随机伪随机均可。假设选择第 x 台机器，那么x可描述为<code>rand.Intn()%n</code>。</li>
<li>根据某种权重，对下游节点进行排序，选择权重最大/小的那一个。</li>
</ol>
<p>当然了，实际场景我们不可能无脑轮询或者无脑随机，如果对下游请求失败了，我们还需要某种机制来进行重试，如果纯粹的随机算法，存在一定的可能性使你在下一次仍然随机到这次的问题节点。</p>
<p>我们来看一个生产环境的负载均衡案例。</p>
<h3 id="6-5-2-基于洗牌算法的负载均衡"><a href="#6-5-2-基于洗牌算法的负载均衡" class="headerlink" title="6.5.2 基于洗牌算法的负载均衡"></a>6.5.2 基于洗牌算法的负载均衡</h3><p>考虑到我们需要随机选取每次发送请求的节点，同时在遇到下游返回错误时换其它节点重试。所以我们设计一个大小和节点数组大小一致的索引数组，每次来新的请求，我们对索引数组做洗牌，然后取第一个元素作为选中的服务节点，如果请求失败，那么选择下一个节点重试，以此类推:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> endpoints = []<span class="keyword">string</span> &#123;</span><br><span class="line">    <span class="string">&quot;100.69.62.1:3232&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100.69.62.32:3232&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100.69.62.42:3232&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100.69.62.81:3232&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100.69.62.11:3232&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100.69.62.113:3232&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100.69.62.101:3232&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点在这个 shuffle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffle</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">        a := rand.Intn(<span class="built_in">len</span>(slice))</span><br><span class="line">        b := rand.Intn(<span class="built_in">len</span>(slice))</span><br><span class="line">        slice[a], slice[b] = slice[b], slice[a]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(params <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> indexes = []<span class="keyword">int</span> &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    shuffle(indexes)</span><br><span class="line">    maxRetryTimes := <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxRetryTimes; i++ &#123;</span><br><span class="line">        err = apiRequest(params, indexes[idx])</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        idx++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// logging</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们循环一遍slice，两两交换，这个和我们平常打牌时常用的洗牌方法类似。看起来没有什么问题。</p>
<h4 id="6-5-2-1-错误的洗牌导致的负载不均衡"><a href="#6-5-2-1-错误的洗牌导致的负载不均衡" class="headerlink" title="6.5.2.1 错误的洗牌导致的负载不均衡"></a>6.5.2.1 错误的洗牌导致的负载不均衡</h4><p>真的没有问题么？还是有问题的。这段简短的程序里有两个隐藏的隐患:</p>
<ol>
<li>没有随机种子。在没有随机种子的情况下，<code>rand.Intn()</code>返回的伪随机数序列是固定的。</li>
<li>洗牌不均匀，会导致整个数组第一个节点有大概率被选中，并且多个节点的负载分布不均衡。</li>
</ol>
<p>第一点比较简单，应该不用在这里给出证明了。关于第二点，我们可以用概率知识来简单证明一下。假设每次挑选都是真随机，我们假设第一个位置的节点在<code>len(slice)</code>次交换中都不被选中的概率是<code>((6/7)*(6/7))^7 ≈ 0.34</code>。而分布均匀的情况下，我们肯定希望被第一个元素在任意位置上分布的概率均等，所以其被随机选到的概率应该约等于<code>1/7≈0.14</code>。</p>
<p>显然，这里给出的洗牌算法对于任意位置的元素来说，有30%的概率不对其进行交换操作。所以所有元素都倾向于留在原来的位置。因为我们每次对<code>shuffle</code>数组输入的都是同一个序列，所以第一个元素有更大的概率会被选中。在负载均衡的场景下，也就意味着节点数组中的第一台机器负载会比其它机器高不少(这里至少是3倍以上)。</p>
<h4 id="6-5-2-2-修正洗牌算法"><a href="#6-5-2-2-修正洗牌算法" class="headerlink" title="6.5.2.2 修正洗牌算法"></a>6.5.2.2 修正洗牌算法</h4><p>从数学上得到过证明的还是经典的fisher-yates算法，主要思路为每次随机挑选一个值，放在数组末尾。然后在n-1个元素的数组中再随机挑选一个值，放在数组末尾，以此类推。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffle</span><span class="params">(indexes []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(indexes); i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">        lastIdx := i - <span class="number">1</span></span><br><span class="line">        idx := rand.Int(i)</span><br><span class="line">        indexes[lastIdx], indexes[idx] = indexes[idx], indexes[lastIdx]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go的标准库中已经为我们内置了该算法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffle</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    b := rand.Perm(n)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前的场景下，我们只要用<code>rand.Perm</code>就可以得到我们想要的索引数组了。</p>
<h3 id="6-5-3-ZooKeeper-集群的随机节点挑选问题"><a href="#6-5-3-ZooKeeper-集群的随机节点挑选问题" class="headerlink" title="6.5.3 ZooKeeper 集群的随机节点挑选问题"></a>6.5.3 ZooKeeper 集群的随机节点挑选问题</h3><p>本节中的场景是从N个节点中选择一个节点发送请求，初始请求结束之后，后续的请求会重新对数组洗牌，所以每两个请求之间没有什么关联关系。因此我们上面的洗牌算法，理论上不初始化随机库的种子也是不会出什么问题的。</p>
<p>但在一些特殊的场景下，例如使用ZooKeeper时，客户端初始化从多个服务节点中挑选一个节点后，是会向该节点建立长连接的。之后客户端请求都会发往该节点去。直到该节点不可用，才会在节点列表中挑选下一个节点。在这种场景下，我们的初始连接节点选择就要求必须是“真”随机了。否则，所有客户端启动时，都会去连接同一个ZooKeeper的实例，根本无法起到负载均衡的目的。如果在日常开发中，你的业务也是类似的场景，也务必考虑一下是否会发生类似的情况。为rand库设置种子的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand.Seed(time.Now().UnixNano())</span><br></pre></td></tr></table></figure>

<p>之所以会有上面这些结论，是因为某个使用较广泛的开源ZooKeeper库的早期版本就犯了上述错误，直到2016年早些时候，这个问题才被修正。</p>
<h3 id="6-5-4-负载均衡算法效果验证"><a href="#6-5-4-负载均衡算法效果验证" class="headerlink" title="6.5.4 负载均衡算法效果验证"></a>6.5.4 负载均衡算法效果验证</h3><p>我们这里不考虑加权负载均衡的情况，既然名字是负载“均衡”。那么最重要的就是均衡。我们把开篇中的shuffle算法，和之后的fisher yates算法的结果进行简单地对比：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffle1</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">        a := rand.Intn(<span class="built_in">len</span>(slice))</span><br><span class="line">        b := rand.Intn(<span class="built_in">len</span>(slice))</span><br><span class="line">        slice[a], slice[b] = slice[b], slice[a]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shuffle2</span><span class="params">(indexes []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(indexes); i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        lastIdx := i - <span class="number">1</span></span><br><span class="line">        idx := rand.Intn(i)</span><br><span class="line">        indexes[lastIdx], indexes[idx] = indexes[idx], indexes[lastIdx]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cnt1 = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> sl = []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">        shuffle1(sl)</span><br><span class="line">        cnt1[sl[<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cnt2 = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> sl = []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">        shuffle2(sl)</span><br><span class="line">        cnt2[sl[<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(cnt1, <span class="string">&quot;\n&quot;</span>, cnt2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[0:224436 1:128780 5:129310 6:129194 2:129643 3:129384 4:129253]</span><br><span class="line">map[6:143275 5:143054 3:143584 2:143031 1:141898 0:142631 4:142527]</span><br></pre></td></tr></table></figure>

<p>分布结果和我们推导出的结论是一致的。</p>
<h2 id="分布式配置管理"><a href="#分布式配置管理" class="headerlink" title="分布式配置管理"></a>分布式配置管理</h2><p>在分布式系统中，常困扰我们的还有上线问题。虽然目前有一些优雅重启方案，但实际应用中可能受限于我们系统内部的运行情况而没有办法做到真正的“优雅”。</p>
<blockquote>
<p>比如我们为了对去下游的流量进行限制，在内存中堆积一些数据，并对堆积设定时间或总量的阈值。在任意阈值达到之后将数据统一发送给下游，以避免频繁的请求超出下游的承载能力而将下游打垮。这种情况下重启要做到优雅就比较难了。</p>
</blockquote>
<p>所以我们的目标还是尽量避免采用或者绕过上线的方式，对线上程序做一些修改。比较典型的修改内容就是程序的配置项。</p>
<h3 id="6-6-1-场景举例"><a href="#6-6-1-场景举例" class="headerlink" title="6.6.1 场景举例"></a>6.6.1 场景举例</h3><h4 id="6-6-1-1-报表系统"><a href="#6-6-1-1-报表系统" class="headerlink" title="6.6.1.1 报表系统"></a>6.6.1.1 报表系统</h4><p>在一些偏OLAP或者离线的数据平台中，经过长期的叠代开发，整个系统的功能模块已经渐渐稳定。可变动的项只出现在数据层，而数据层的变动大多可以认为是SQL的变动，架构师们自然而然地会想着把这些变动项抽离到系统外部。比如本节所述的配置管理系统。</p>
<p>当业务提出了新的需求时，我们的需求是将新的SQL录入到系统内部，或者简单修改一下老的SQL。不对系统进行上线，就可以直接完成这些修改。</p>
<h4 id="6-6-1-2-业务配置"><a href="#6-6-1-2-业务配置" class="headerlink" title="6.6.1.2 业务配置"></a>6.6.1.2 业务配置</h4><p>大公司的平台部门服务众多业务线，在平台内为各业务线分配唯一id。平台本身也由多个模块构成，这些模块需要共享相同的业务线定义（要不然就乱套了）。当公司新开产品线时，需要能够在短时间内打通所有平台系统的流程。这时候每个系统都走上线流程肯定是来不及的。另外需要对这种公共配置进行统一管理，同时对其增减逻辑也做统一管理。这些信息变更时，需要自动通知到业务方的系统，而不需要人力介入（或者只需要很简单的介入，比如点击审核通过）。</p>
<p>除业务线管理之外，很多互联网公司会按照城市来铺展自己的业务。在某个城市未开城之前，理论上所有模块都应该认为带有该城市id的数据是脏数据并自动过滤掉。而如果业务开城，在系统中就应该自己把这个新的城市id自动加入到白名单中。这样业务流程便可以自动运转。</p>
<p>再举个例子，互联网公司的运营系统中会有各种类型的运营活动，有些运营活动推出后可能出现了超出预期的事件（比如公关危机），需要紧急将系统下线。这时候会用到一些开关来快速关闭相应的功能。或者快速将想要剔除的活动id从白名单中剔除。在Web章节中的AB测试一节中，我们也提到，有时需要有这样的系统来告诉我们当前需要放多少流量到相应的功能代码上。我们可以像那一节中，使用远程RPC来获知这些信息，但同时，也可以结合分布式配置系统，主动地拉取到这些信息。</p>
<h3 id="6-6-2-使用etcd实现配置更新"><a href="#6-6-2-使用etcd实现配置更新" class="headerlink" title="6.6.2 使用etcd实现配置更新"></a>6.6.2 使用etcd实现配置更新</h3><p>我们使用etcd实现一个简单的配置读取和动态更新流程，以此来了解线上的配置更新流程。</p>
<h4 id="6-6-2-1-配置定义"><a href="#6-6-2-1-配置定义" class="headerlink" title="6.6.2.1 配置定义"></a>6.6.2.1 配置定义</h4><p>简单的配置，可以将内容完全存储在etcd中。比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">etcdctl get /configs/remote_config.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;addr&quot; : &quot;127.0.0.1:1080&quot;,</span><br><span class="line">    &quot;aes_key&quot; : &quot;01B345B7A9ABC00F0123456789ABCDAF&quot;,</span><br><span class="line">    &quot;https&quot; : false,</span><br><span class="line">    &quot;secret&quot; : &quot;&quot;,</span><br><span class="line">    &quot;private_key_path&quot; : &quot;&quot;,</span><br><span class="line">    &quot;cert_file_path&quot; : &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-6-2-2-新建-etcd-client"><a href="#6-6-2-2-新建-etcd-client" class="headerlink" title="6.6.2.2 新建 etcd client"></a>6.6.2.2 新建 etcd client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cfg := client.Config&#123;</span><br><span class="line">    Endpoints:               []<span class="keyword">string</span>&#123;<span class="string">&quot;http://127.0.0.1:2379&quot;</span>&#125;,</span><br><span class="line">    Transport:               client.DefaultTransport,</span><br><span class="line">    HeaderTimeoutPerRequest: time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接用etcd client包中的结构体初始化，没什么可说的。</p>
<h4 id="6-6-2-3-配置获取"><a href="#6-6-2-3-配置获取" class="headerlink" title="6.6.2.3 配置获取"></a>6.6.2.3 配置获取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err = kapi.Get(context.Background(), <span class="string">&quot;/path/to/your/config&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Get is done. Metadata is %q\n&quot;</span>, resp)</span><br><span class="line">    log.Printf(<span class="string">&quot;%q key has %q value\n&quot;</span>, resp.Node.Key, resp.Node.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取配置使用etcd KeysAPI的<code>Get()</code>方法，比较简单。</p>
<h4 id="6-6-2-4-配置更新订阅"><a href="#6-6-2-4-配置更新订阅" class="headerlink" title="6.6.2.4 配置更新订阅"></a>6.6.2.4 配置更新订阅</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kapi := client.NewKeysAPI(c)</span><br><span class="line">w := kapi.Watcher(<span class="string">&quot;/path/to/your/config&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        resp, err := w.Next(context.Background())</span><br><span class="line">        log.Println(resp, err)</span><br><span class="line">        log.Println(<span class="string">&quot;new values is &quot;</span>, resp.Node.Value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>通过订阅config路径的变动事件，在该路径下内容发生变化时，客户端侧可以收到变动通知，并收到变动后的字符串值。</p>
<h4 id="6-6-2-5-整合起来"><a href="#6-6-2-5-整合起来" class="headerlink" title="6.6.2.5 整合起来"></a>6.6.2.5 整合起来</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/coreos/etcd/client&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> configPath =  <span class="string">`/configs/remote_config.json`</span></span><br><span class="line"><span class="keyword">var</span> kapi client.KeysAPI</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConfigStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr           <span class="keyword">string</span> <span class="string">`json:&quot;addr&quot;`</span></span><br><span class="line">    AesKey         <span class="keyword">string</span> <span class="string">`json:&quot;aes_key&quot;`</span></span><br><span class="line">    HTTPS          <span class="keyword">bool</span>   <span class="string">`json:&quot;https&quot;`</span></span><br><span class="line">    Secret         <span class="keyword">string</span> <span class="string">`json:&quot;secret&quot;`</span></span><br><span class="line">    PrivateKeyPath <span class="keyword">string</span> <span class="string">`json:&quot;private_key_path&quot;`</span></span><br><span class="line">    CertFilePath   <span class="keyword">string</span> <span class="string">`json:&quot;cert_file_path&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appConfig ConfigStruct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cfg := client.Config&#123;</span><br><span class="line">        Endpoints:               []<span class="keyword">string</span>&#123;<span class="string">&quot;http://127.0.0.1:2379&quot;</span>&#125;,</span><br><span class="line">        Transport:               client.DefaultTransport,</span><br><span class="line">        HeaderTimeoutPerRequest: time.Second,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c, err := client.New(cfg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    kapi = client.NewKeysAPI(c)</span><br><span class="line">    initConfig()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watchAndUpdate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w := kapi.Watcher(configPath, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// watch 该节点下的每次变化</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            resp, err := w.Next(context.Background())</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            log.Println(<span class="string">&quot;new values is &quot;</span>, resp.Node.Value)</span><br><span class="line"></span><br><span class="line">            err = json.Unmarshal([]<span class="keyword">byte</span>(resp.Node.Value), &amp;appConfig)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err = kapi.Get(context.Background(), configPath, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := json.Unmarshal(resp.Node.Value, &amp;appConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getConfig</span><span class="params">()</span> <span class="title">ConfigStruct</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> appConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// init your app</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果业务规模不大，使用本节中的例子就可以实现功能了。</p>
<p>这里只需要注意一点，我们在更新配置时，进行了一系列操作：watch响应，json解析，这些操作都不具备原子性。当单个业务请求流程中多次获取config时，有可能因为中途config发生变化而导致单个请求前后逻辑不一致。因此，在使用类似这样的方式来更新配置时，需要在单个请求的生命周期内使用同样的配置。具体实现方式可以是只在请求开始的时候获取一次配置，然后依次向下透传等等，具体情况具体分析。</p>
<h3 id="6-6-3-配置膨胀"><a href="#6-6-3-配置膨胀" class="headerlink" title="6.6.3 配置膨胀"></a>6.6.3 配置膨胀</h3><p>随着业务的发展，配置系统本身所承载的压力可能也会越来越大，配置文件可能成千上万。客户端同样上万，将配置内容存储在etcd内部便不再合适了。随着配置文件数量的膨胀，除了存储系统本身的吞吐量问题，还有配置信息的管理问题。我们需要对相应的配置进行权限管理，需要根据业务量进行配置存储的集群划分。如果客户端太多，导致了配置存储系统无法承受瞬时大量的QPS，那可能还需要在客户端侧进行缓存优化，等等。</p>
<p>这也就是为什么大公司都会针对自己的业务额外开发一套复杂配置系统的原因。</p>
<h3 id="6-6-4-配置版本管理"><a href="#6-6-4-配置版本管理" class="headerlink" title="6.6.4 配置版本管理"></a>6.6.4 配置版本管理</h3><p>在配置管理过程中，难免出现用户误操作的情况，例如在更新配置时，输入了无法解析的配置。这种情况下我们可以通过配置校验来解决。</p>
<p>有时错误的配置可能不是格式上有问题，而是在逻辑上有问题。比如我们写SQL时少select了一个字段，更新配置时，不小心丢掉了json字符串中的一个field而导致程序无法理解新的配置而进入诡异的逻辑。为了快速止损，最快且最有效的办法就是进行版本管理，并支持按版本回滚。</p>
<p>在配置进行更新时，我们要为每份配置的新内容赋予一个版本号，并将修改前的内容和版本号记录下来，当发现新配置出问题时，能够及时地回滚回来。</p>
<p>常见的做法是，使用MySQL来存储配置文件或配置字符串的不同版本内容，在需要回滚时，只要进行简单的查询即可。</p>
<h3 id="6-6-5-客户端容错"><a href="#6-6-5-客户端容错" class="headerlink" title="6.6.5 客户端容错"></a>6.6.5 客户端容错</h3><p>在业务系统的配置被剥离到配置中心之后，并不意味着我们的系统可以高枕无忧了。当配置中心本身宕机时，我们也需要一定的容错能力，至少保证在其宕机期间，业务依然可以运转。这要求我们的系统能够在配置中心宕机时，也能拿到需要的配置信息。哪怕这些信息不够新。</p>
<p>具体来讲，在给业务提供配置读取的SDK时，最好能够将拿到的配置在业务机器的磁盘上也缓存一份。这样远程配置中心不可用时，可以直接用硬盘上的内容来做兜底。当重新连接上配置中心时，再把相应的内容进行更新。</p>
<p>加入缓存之后务必需要考虑的是数据一致性问题，当个别业务机器因为网络错误而与其它机器配置不一致时，我们也应该能够从监控系统中知晓。</p>
<p>我们使用一种手段解决了我们配置更新痛点，但同时可能因为使用的手段而带给我们新的问题。实际开发中，我们要对每一步决策多多思考，以使自己不在问题到来时手足无措。</p>
<h2 id="分布式爬虫"><a href="#分布式爬虫" class="headerlink" title="分布式爬虫"></a>分布式爬虫</h2><p>近年来深度学习如雨后春笋一般火热起来，但机器学习很多时候并不是苦于我的模型是否建立得合适，我的参数是否调整得正确，而是苦于最初的起步阶段：没有数据。</p>
<p>作为收集数据的前置工作，有能力去写一个简单的或者复杂的爬虫，对于我们来说依然非常重要。</p>
<h3 id="6-7-1-基于colly的单机爬虫"><a href="#6-7-1-基于colly的单机爬虫" class="headerlink" title="6.7.1 基于colly的单机爬虫"></a>6.7.1 基于colly的单机爬虫</h3><p>《Go 语言编程》一书给出了简单的爬虫示例，经过了多年的发展，现在使用Go语言写一个网站的爬虫要更加方便，比如用colly来实现爬取某网站（虚拟站点，这里用abcdefg作为占位符）在Go语言标签下的前十页内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;regexp&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gocolly/colly&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> visited = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Instantiate default collector</span></span><br><span class="line">    c := colly.NewCollector(</span><br><span class="line">        colly.AllowedDomains(<span class="string">&quot;www.abcdefg.com&quot;</span>),</span><br><span class="line">        colly.MaxDepth(<span class="number">1</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们认为匹配该模式的是该网站的详情页</span></span><br><span class="line">    detailRegex, _ := regexp.Compile(<span class="string">`/go/go\?p=\d+$`</span>)</span><br><span class="line">    <span class="comment">// 匹配下面模式的是该网站的列表页</span></span><br><span class="line">    listRegex, _ := regexp.Compile(<span class="string">`/t/\d+#\w+`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有a标签，上设置回调函数</span></span><br><span class="line">    c.OnHTML(<span class="string">&quot;a[href]&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(e *colly.HTMLElement)</span></span> &#123;</span><br><span class="line">        link := e.Attr(<span class="string">&quot;href&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已访问过的详情页或列表页，跳过</span></span><br><span class="line">        <span class="keyword">if</span> visited[link] &amp;&amp; (detailRegex.Match([]<span class="keyword">byte</span>(link)) || listRegex.Match([]<span class="keyword">byte</span>(link))) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 既不是列表页，也不是详情页</span></span><br><span class="line">        <span class="comment">// 那么不是我们关心的内容，要跳过</span></span><br><span class="line">        <span class="keyword">if</span> !detailRegex.Match([]<span class="keyword">byte</span>(link)) &amp;&amp; !listRegex.Match([]<span class="keyword">byte</span>(link)) &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;not match&quot;</span>, link)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为大多数网站有反爬虫策略</span></span><br><span class="line">        <span class="comment">// 所以爬虫逻辑中应该有 sleep 逻辑以避免被封杀</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;match&quot;</span>, link)</span><br><span class="line"></span><br><span class="line">        visited[link] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">2</span>)</span><br><span class="line">        c.Visit(e.Request.AbsoluteURL(link))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    err := c.Visit(<span class="string">&quot;https://www.abcdefg.com/go/go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;fmt.Println(err)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-7-2-分布式爬虫"><a href="#6-7-2-分布式爬虫" class="headerlink" title="6.7.2 分布式爬虫"></a>6.7.2 分布式爬虫</h3><p>想像一下，你们的信息分析系统运行非常之快。获取信息的速度成为了瓶颈，虽然可以用上Go语言所有优秀的并发特性，将单机的CPU和网络带宽都用满，但还是希望能够加快爬虫的爬取速度。在很多场景下，速度是有意义的：</p>
<ol>
<li>对于价格战期间的电商们来说，希望能够在对手价格变动后第一时间获取到其最新价格，再靠机器自动调整本家的商品价格。</li>
<li>对于类似头条之类的Feed流业务，信息的时效性也非常重要。如果我们慢吞吞地爬到的新闻是昨天的新闻，那对于用户来说就没有任何意义。</li>
</ol>
<p>所以我们需要分布式爬虫。从本质上来讲，分布式爬虫是一套任务分发和执行系统。而常见的任务分发，因为上下游存在速度不匹配问题，必然要借助消息队列。</p>
<p><img src="/images/ch6-dist-crawler.png" alt="dist-crawler"></p>
<p><em>图 6-14 爬虫工作流程</em></p>
<p>上游的主要工作是根据预先配置好的起点来爬取所有的目标“列表页”，列表页的html内容中会包含有所有详情页的链接。详情页的数量一般是列表页的10到100倍，所以我们将这些详情页链接作为“任务”内容，通过消息队列分发出去。</p>
<p>针对页面爬取来说，在执行时是否偶尔会有重复其实不太重要，因为任务结果是幂等的（这里我们只爬页面内容，不考虑评论部分）。</p>
<p>本节我们来简单实现一个基于消息队列的爬虫，本节我们使用nats来做任务分发。实际开发中，应该针对自己的业务对消息本身的可靠性要求和公司的基础架构组件情况进行选型。</p>
<h4 id="6-7-2-1-nats简介"><a href="#6-7-2-1-nats简介" class="headerlink" title="6.7.2.1 nats简介"></a>6.7.2.1 nats简介</h4><p>nats是Go实现的一个高性能分布式消息队列，适用于高并发高吞吐量的消息分发场景。早期的nats以速度为重，没有支持持久化。从16年开始，nats通过nats-streaming支持基于日志的持久化，以及可靠的消息传输。为了演示方便，我们本节中只使用nats。</p>
<p>nats的服务端项目是gnatsd，客户端与gnatsd的通信方式为基于tcp的文本协议，非常简单：</p>
<p>向subject为task发消息：</p>
<p><img src="/images/ch6-09-nats-protocol-pub.png" alt="nats-protocol-pub"></p>
<p><em>图 6-15 nats协议中的pub</em></p>
<p>以workers的queue从tasks subject订阅消息：</p>
<p><img src="/images/ch6-09-nats-protocol-sub.png" alt="nats-protocol-sub"></p>
<p><em>图 6-16 nats协议中的sub</em></p>
<p>其中的queue参数是可选的，如果希望在分布式的消费端进行任务的负载均衡，而不是所有人都收到同样的消息，那么就要给消费端指定相同的queue名字。</p>
<h5 id="基本消息生产"><a href="#基本消息生产" class="headerlink" title="基本消息生产"></a>基本消息生产</h5><p>生产消息只要指定subject即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nc, err := nats.Connect(nats.DefaultURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 subject 为 tasks，消息内容随意</span></span><br><span class="line">err = nc.Publish(<span class="string">&quot;tasks&quot;</span>, []<span class="keyword">byte</span>(<span class="string">&quot;your task content&quot;</span>))</span><br><span class="line"></span><br><span class="line">nc.Flush()</span><br></pre></td></tr></table></figure>

<h5 id="基本消息消费"><a href="#基本消息消费" class="headerlink" title="基本消息消费"></a>基本消息消费</h5><p>直接使用nats的subscribe API并不能达到任务分发的目的，因为pub sub本身是广播性质的。所有消费者都会收到完全一样的所有消息。</p>
<p>除了普通的subscribe之外，nats还提供了queue subscribe的功能。只要提供一个queue group名字（类似Kafka中的consumer group），即可均衡地将任务分发给消费者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nc, err := nats.Connect(nats.DefaultURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// queue subscribe 相当于在消费者之间进行任务分发的分支均衡</span></span><br><span class="line"><span class="comment">// 前提是所有消费者都使用 workers 这个 queue</span></span><br><span class="line"><span class="comment">// nats 中的 queue 概念上类似于 Kafka 中的 consumer group</span></span><br><span class="line">sub, err := nc.QueueSubscribeSync(<span class="string">&quot;tasks&quot;</span>, <span class="string">&quot;workers&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg *nats.Msg</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    msg, err = sub.NextMsg(time.Hour * <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="keyword">break</span>&#125;</span><br><span class="line">    <span class="comment">// 正确地消费到了消息</span></span><br><span class="line">    <span class="comment">// 可用 nats.Msg 对象处理任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-7-3-结合nats和colly的消息生产"><a href="#6-7-3-结合nats和colly的消息生产" class="headerlink" title="6.7.3 结合nats和colly的消息生产"></a>6.7.3 结合nats和colly的消息生产</h3><p>我们为每一个网站定制一个对应的collector，并设置相应的规则，比如abcdefg，hijklmn（虚构的），再用简单的工厂方法来将该collector和其host对应起来，每个站点爬到列表页之后，需要在当前程序中把所有链接解析出来，并把落地页的URL发往消息队列。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/url&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gocolly/colly&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> domain2Collector = <span class="keyword">map</span>[<span class="keyword">string</span>]*colly.Collector&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> nc *nats.Conn</span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> natsURL = <span class="string">&quot;nats://localhost:4222&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factory</span><span class="params">(urlStr <span class="keyword">string</span>)</span> *<span class="title">colly</span>.<span class="title">Collector</span></span> &#123;</span><br><span class="line">    u, _ := url.Parse(urlStr)</span><br><span class="line">    <span class="keyword">return</span> domain2Collector[u.Host]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initABCDECollector</span><span class="params">()</span> *<span class="title">colly</span>.<span class="title">Collector</span></span> &#123;</span><br><span class="line">    c := colly.NewCollector(</span><br><span class="line">        colly.AllowedDomains(<span class="string">&quot;www.abcdefg.com&quot;</span>),</span><br><span class="line">        colly.MaxDepth(maxDepth),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    c.OnResponse(<span class="function"><span class="keyword">func</span><span class="params">(resp *colly.Response)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 做一些爬完之后的善后工作</span></span><br><span class="line">        <span class="comment">// 比如页面已爬完的确认存进 MySQL</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    c.OnHTML(<span class="string">&quot;a[href]&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(e *colly.HTMLElement)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 基本的反爬虫策略</span></span><br><span class="line">        link := e.Attr(<span class="string">&quot;href&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正则 match 列表页的话，就 visit</span></span><br><span class="line">        <span class="keyword">if</span> listRegex.Match([]<span class="keyword">byte</span>(link)) &#123;</span><br><span class="line">            c.Visit(e.Request.AbsoluteURL(link))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正则 match 落地页的话，就发消息队列</span></span><br><span class="line">        <span class="keyword">if</span> detailRegex.Match([]<span class="keyword">byte</span>(link)) &#123;</span><br><span class="line">            err = nc.Publish(<span class="string">&quot;tasks&quot;</span>, []<span class="keyword">byte</span>(link))</span><br><span class="line">            nc.Flush()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initHIJKLCollector</span><span class="params">()</span> *<span class="title">colly</span>.<span class="title">Collector</span></span> &#123;</span><br><span class="line">    c := colly.NewCollector(</span><br><span class="line">        colly.AllowedDomains(<span class="string">&quot;www.hijklmn.com&quot;</span>),</span><br><span class="line">        colly.MaxDepth(maxDepth),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    c.OnHTML(<span class="string">&quot;a[href]&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(e *colly.HTMLElement)</span></span> &#123;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    domain2Collector[<span class="string">&quot;www.abcdefg.com&quot;</span>] = initABCDECollector()</span><br><span class="line">    domain2Collector[<span class="string">&quot;www.hijklmn.com&quot;</span>] = initHIJKLCollector()</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    nc, err = nats.Connect(natsURL)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;os.Exit(<span class="number">1</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    urls := []<span class="keyword">string</span>&#123;<span class="string">&quot;https://www.abcdefg.com&quot;</span>, <span class="string">&quot;https://www.hijklmn.com&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        instance := factory(url)</span><br><span class="line">        instance.Visit(url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-7-4-结合colly的消息消费"><a href="#6-7-4-结合colly的消息消费" class="headerlink" title="6.7.4 结合colly的消息消费"></a>6.7.4 结合colly的消息消费</h3><p>消费端就简单一些了，我们只需要订阅对应的主题，并直接访问网站的详情页(落地页)即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/url&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gocolly/colly&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> domain2Collector = <span class="keyword">map</span>[<span class="keyword">string</span>]*colly.Collector&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> nc *nats.Conn</span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> natsURL = <span class="string">&quot;nats://localhost:4222&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factory</span><span class="params">(urlStr <span class="keyword">string</span>)</span> *<span class="title">colly</span>.<span class="title">Collector</span></span> &#123;</span><br><span class="line">    u, _ := url.Parse(urlStr)</span><br><span class="line">    <span class="keyword">return</span> domain2Collector[u.Host]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initV2exCollector</span><span class="params">()</span> *<span class="title">colly</span>.<span class="title">Collector</span></span> &#123;</span><br><span class="line">    c := colly.NewCollector(</span><br><span class="line">        colly.AllowedDomains(<span class="string">&quot;www.abcdefg.com&quot;</span>),</span><br><span class="line">        colly.MaxDepth(maxDepth),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initV2fxCollector</span><span class="params">()</span> *<span class="title">colly</span>.<span class="title">Collector</span></span> &#123;</span><br><span class="line">    c := colly.NewCollector(</span><br><span class="line">        colly.AllowedDomains(<span class="string">&quot;www.hijklmn.com&quot;</span>),</span><br><span class="line">        colly.MaxDepth(maxDepth),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    domain2Collector[<span class="string">&quot;www.abcdefg.com&quot;</span>] = initV2exCollector()</span><br><span class="line">    domain2Collector[<span class="string">&quot;www.hijklmn.com&quot;</span>] = initV2fxCollector()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    nc, err = nats.Connect(natsURL)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;os.Exit(<span class="number">1</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startConsumer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nc, err := nats.Connect(nats.DefaultURL)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line">    sub, err := nc.QueueSubscribeSync(<span class="string">&quot;tasks&quot;</span>, <span class="string">&quot;workers&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> msg *nats.Msg</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        msg, err = sub.NextMsg(time.Hour * <span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;<span class="keyword">break</span>&#125;</span><br><span class="line"></span><br><span class="line">        urlStr := <span class="keyword">string</span>(msg.Data)</span><br><span class="line">        ins := factory(urlStr)</span><br><span class="line">        <span class="comment">// 因为最下游拿到的一定是对应网站的落地页</span></span><br><span class="line">        <span class="comment">// 所以不用进行多余的判断了，直接爬内容即可</span></span><br><span class="line">        ins.Visit(urlStr)</span><br><span class="line">        <span class="comment">// 防止被封杀</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    startConsumer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码层面上来讲，这里的生产者和消费者其实本质上差不多。如果日后我们要灵活地支持增加、减少各种网站的爬取的话，应该思考如何将这些爬虫的策略、参数尽量地配置化。</p>
<p>在本章的分布式配置一节中已经讲了一些配置系统的使用，读者可以自行进行尝试，这里就不再赘述了。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>