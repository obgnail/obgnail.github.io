<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;testing-单元测试&quot;&gt;&lt;a href=&quot;#testing-单元测试&quot; class=&quot;headerlink&quot; title=&quot;testing - 单元测试&quot;&gt;&lt;/a&gt;testing - 单元测试&lt;/h1&gt;&lt;h2 id=&quot;1-testing-单元测试&quot;&gt;&lt;a href=&quot;#1-testing-单元测试&quot; class=&quot;headerlink&quot; title=&quot;1. testing - 单元测试&quot;&gt;&lt;/a&gt;1. testing - 单元测试&lt;/h2&gt;&lt;p&gt;&lt;code&gt;testing&lt;/code&gt; 为 Go 语言 package 提供自动化测试的支持。通过 &lt;code&gt;go test&lt;/code&gt; 命令，能够自动执行如下形式的任何函数："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>testing | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-04-26</div></div></div><div class="container post-header"><h1>testing</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#testing-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">testing - 单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-testing-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.</span> <span class="toc-text">1. testing - 单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.2.</span> <span class="toc-text">1.1. 第一个单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Table-Driven-Test"><span class="toc-number">1.3.</span> <span class="toc-text">1.2. Table-Driven Test</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-T-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">1.3. T 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E6%8A%A5%E5%91%8A%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.3.1. 报告方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-Parallel-%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.3.2. Parallel 测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">1.5.</span> <span class="toc-text">2. 写一个基本的测试用例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-testing-%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">3. testing 的测试用例形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-testing-%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.</span> <span class="toc-text">4. testing 的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-testing-%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.8.</span> <span class="toc-text">5. testing 的结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-testing-%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.</span> <span class="toc-text">6. testing 的通用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#testing-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-number">2.</span> <span class="toc-text">testing - 基准测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-testing-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-number">2.1.</span> <span class="toc-text">1.testing - 基准测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">1.1. 基准测试示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-B-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">1.2. B 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E8%AE%A1%E6%97%B6%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.2.1. 计时方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">2.3.2.</span> <span class="toc-text">1.2.2. 并行执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E5%86%85%E5%AD%98%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.3.3.</span> <span class="toc-text">1.2.3. 内存统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">2.3.4.</span> <span class="toc-text">1.2.4. 基准测试结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#testing-%E5%AD%90%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AD%90%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">testing - 子测试与子基准测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#testing-%E8%BF%90%E8%A1%8C%E5%B9%B6%E9%AA%8C%E8%AF%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">testing - 运行并验证示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="toc-number">4.1.</span> <span class="toc-text">1.1. 命名约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">1.2. 实现原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#testing-%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="toc-number">5.</span> <span class="toc-text">testing - 其他功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-TestMain"><span class="toc-number">5.1.</span> <span class="toc-text">1.1. TestMain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Test-Coverage"><span class="toc-number">5.2.</span> <span class="toc-text">1.2. Test Coverage</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#httptest-HTTP-%E6%B5%8B%E8%AF%95%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7"><span class="toc-number">6.</span> <span class="toc-text">httptest - HTTP 测试辅助工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-httptest-HTTP-%E6%B5%8B%E8%AF%95%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7"><span class="toc-number">6.1.</span> <span class="toc-text">1.httptest - HTTP 测试辅助工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%AE%80%E5%8D%95%E7%9A%84-Web-%E5%BA%94%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">1.1. 简单的 Web 应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%80%9A%E8%BF%87-httptest-%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">6.3.</span> <span class="toc-text">1.2. 通过 httptest 进行测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B"><span class="toc-number">6.4.</span> <span class="toc-text">1.3. 测试代码改进</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="testing-单元测试"><a href="#testing-单元测试" class="headerlink" title="testing - 单元测试"></a>testing - 单元测试</h1><h2 id="1-testing-单元测试"><a href="#1-testing-单元测试" class="headerlink" title="1. testing - 单元测试"></a>1. testing - 单元测试</h2><p><code>testing</code> 为 Go 语言 package 提供自动化测试的支持。通过 <code>go test</code> 命令，能够自动执行如下形式的任何函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func TestXxx(*testing.T)</span><br></pre></td></tr></table></figure>

<p>注意：Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。</p>
<p>在这些函数中，使用 <code>Error</code>、<code>Fail</code> 或相关方法来发出失败信号。</p>
<p>要编写一个新的测试套件，需要创建一个名称以 _test.go 结尾的文件，该文件包含 <code>TestXxx</code> 函数，如上所述。 将该文件放在与被测试文件相同的包中。该文件将被排除在正常的程序包之外，但在运行 <code>go test</code> 命令时将被包含。 有关详细信息，请运行 <code>go help test</code> 和 <code>go help testflag</code> 了解。</p>
<p>如果有需要，可以调用 <code>*T</code> 和 <code>*B</code> 的 <code>Skip</code> 方法，跳过该测试或基准测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTimeConsuming</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> testing.Short() &#123;</span><br><span class="line">        t.Skip(<span class="string">&quot;skipping test in short mode.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-1-第一个单元测试"><a href="#1-1-第一个单元测试" class="headerlink" title="1.1. 第一个单元测试"></a>1.1. 第一个单元测试</h2><p>要测试的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFib</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        in       = <span class="number">7</span></span><br><span class="line">        expected = <span class="number">13</span></span><br><span class="line">    )</span><br><span class="line">    actual := Fib(in)</span><br><span class="line">    <span class="keyword">if</span> actual != expected &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Fib(%d) = %d; expected %d&quot;</span>, in, actual, expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>go test .</code>，输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test .</span><br><span class="line">ok      chapter09/testing    0.007s</span><br></pre></td></tr></table></figure>

<p>表示测试通过。</p>
<p>我们将 <code>Sum</code> 函数改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再执行 <code>go test .</code>，输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go test .</span><br><span class="line">--- FAIL: TestSum (0.00s)</span><br><span class="line">    t_test.go:16: Fib(10) = 64; expected 13</span><br><span class="line">FAIL</span><br><span class="line">FAIL    chapter09/testing    0.009s</span><br></pre></td></tr></table></figure>



<h2 id="1-2-Table-Driven-Test"><a href="#1-2-Table-Driven-Test" class="headerlink" title="1.2. Table-Driven Test"></a>1.2. Table-Driven Test</h2><p>测试讲究 case 覆盖，按上面的方式，当我们要覆盖更多 case 时，显然通过修改代码的方式很笨拙。这时我们可以采用 Table-Driven 的方式写测试，标准库中有很多测试是使用这种方式写的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFib</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fibTests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        in       <span class="keyword">int</span> <span class="comment">// input</span></span><br><span class="line">        expected <span class="keyword">int</span> <span class="comment">// expected result</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="number">13</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> fibTests &#123;</span><br><span class="line">        actual := Fib(tt.in)</span><br><span class="line">        <span class="keyword">if</span> actual != tt.expected &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;Fib(%d) = %d; expected %d&quot;</span>, tt.in, actual, tt.expected)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们使用的是 <code>t.Errorf</code>，即使其中某个 case 失败，也不会终止测试执行。</p>
<h2 id="1-3-T-类型"><a href="#1-3-T-类型" class="headerlink" title="1.3. T 类型"></a>1.3. T 类型</h2><p>单元测试中，传递给测试函数的参数是 <code>*testing.T</code> 类型。它用于<strong>管理测试状态并支持格式化测试日志</strong>。测试日志会在执行测试的过程中不断累积，并在测试完成时转储至标准输出。</p>
<p>当测试函数返回时，或者当测试函数调用 <code>FailNow</code>、 <code>Fatal</code>、<code>Fatalf</code>、<code>SkipNow</code>、<code>Skip</code>、<code>Skipf</code> 中的任意一个时，则宣告该测试函数结束。跟 <code>Parallel</code> 方法一样，以上提到的这些方法只能在运行测试函数的 goroutine 中调用。</p>
<p>至于其他报告方法，比如 <code>Log</code> 以及 <code>Error</code> 的变种， 则可以在多个 goroutine 中同时进行调用。</p>
<h3 id="1-3-1-报告方法"><a href="#1-3-1-报告方法" class="headerlink" title="1.3.1. 报告方法"></a>1.3.1. 报告方法</h3><p>上面提到的系列包括方法，带 <code>f</code> 的是格式化的，格式化语法参考 <code>fmt</code> 包。</p>
<p>T 类型内嵌了 common 类型，common 提供这一系列方法，我们经常会用到的（注意，这里说的测试中断，都是指当前测试函数）：</p>
<p>1）当我们遇到一个断言错误的时候，标识这个测试失败，会使用到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fail : 测试失败，测试继续，也就是之后的代码依然会执行</span><br><span class="line">FailNow : 测试失败，测试中断</span><br></pre></td></tr></table></figure>

<p>在 <code>FailNow</code> 方法实现的内部，是通过调用 <code>runtime.Goexit()</code> 来中断测试的。</p>
<p>2）当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标识测试失败，会使用到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkipNow : 跳过测试，测试中断</span><br></pre></td></tr></table></figure>

<p>在 <code>SkipNow</code> 方法实现的内部，是通过调用 <code>runtime.Goexit()</code> 来中断测试的。</p>
<p>3）当我们只希望打印信息，会用到 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log : 输出信息</span><br><span class="line">Logf : 输出格式化的信息</span><br></pre></td></tr></table></figure>

<p>注意：默认情况下，单元测试成功时，它们打印的信息不会输出，可以通过加上 <code>-v</code> 选项，输出这些信息。但对于基准测试，它们总是会被输出。</p>
<p>4）当我们希望跳过这个测试，并且打印出信息，会用到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Skip : 相当于 Log + SkipNow</span><br><span class="line">Skipf : 相当于 Logf + SkipNow</span><br></pre></td></tr></table></figure>

<p>5）当我们希望断言失败的时候，标识测试失败，并打印出必要的信息，但是测试继续，会用到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error : 相当于 Log + Fail</span><br><span class="line">Errorf : 相当于 Logf + Fail</span><br></pre></td></tr></table></figure>

<p>6）当我们希望断言失败的时候，标识测试失败，打印出必要的信息，但中断测试，会用到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fatal : 相当于 Log + FailNow</span><br><span class="line">Fatalf : 相当于 Logf + FailNow</span><br></pre></td></tr></table></figure>



<h3 id="1-3-2-Parallel-测试"><a href="#1-3-2-Parallel-测试" class="headerlink" title="1.3.2. Parallel 测试"></a>1.3.2. Parallel 测试</h3><p>包中的 Parallel 方法表示当前测试只会与其他带有 Parallel 方法的测试并行进行测试。</p>
<p>下面例子将演示 Parallel 的使用方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    data   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    locker sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteToMap</span><span class="params">(k, v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    locker.Lock()</span><br><span class="line">    <span class="keyword">defer</span> locker.Unlock()</span><br><span class="line">    data[k] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFromMap</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    locker.RLock()</span><br><span class="line">    <span class="keyword">defer</span> locker.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pairs = []<span class="keyword">struct</span> &#123;</span><br><span class="line">    k <span class="keyword">string</span></span><br><span class="line">    v <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;polaris&quot;</span>, <span class="string">&quot; 徐新华 &quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;studygolang&quot;</span>, <span class="string">&quot;Go 语言中文网 &quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stdlib&quot;</span>, <span class="string">&quot;Go 语言标准库 &quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;polaris1&quot;</span>, <span class="string">&quot; 徐新华 1&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;studygolang1&quot;</span>, <span class="string">&quot;Go 语言中文网 1&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stdlib1&quot;</span>, <span class="string">&quot;Go 语言标准库 1&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;polaris2&quot;</span>, <span class="string">&quot; 徐新华 2&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;studygolang2&quot;</span>, <span class="string">&quot;Go 语言中文网 2&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stdlib2&quot;</span>, <span class="string">&quot;Go 语言标准库 2&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;polaris3&quot;</span>, <span class="string">&quot; 徐新华 3&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;studygolang3&quot;</span>, <span class="string">&quot;Go 语言中文网 3&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stdlib3&quot;</span>, <span class="string">&quot;Go 语言标准库 3&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;polaris4&quot;</span>, <span class="string">&quot; 徐新华 4&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;studygolang4&quot;</span>, <span class="string">&quot;Go 语言中文网 4&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stdlib4&quot;</span>, <span class="string">&quot;Go 语言标准库 4&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 TestWriteToMap 需要在 TestReadFromMap 之前</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWriteToMap</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> pairs &#123;</span><br><span class="line">        WriteToMap(tt.k, tt.v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReadFromMap</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> pairs &#123;</span><br><span class="line">        actual := ReadFromMap(tt.k)</span><br><span class="line">        <span class="keyword">if</span> actual != tt.v &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;the value of key(%s) is %s, expected: %s&quot;</span>, tt.k, actual, tt.v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试验步骤：</p>
<ol>
<li>注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，同时注释掉测试代码中的 t.Parallel，执行测试，测试通过，即使加上 <code>-race</code>，测试依然通过；</li>
<li>只注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，执行测试，测试失败（如果未失败，加上 <code>-race</code> 一定会失败）；</li>
</ol>
<p>如果代码能够进行并行测试，在写测试时，尽量加上 Parallel，这样可以测试出一些可能的问题。</p>
<p>关于 Parallel 的更多内容，会在 <a target="_blank" rel="noopener" href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter09/09.3.html">子测试</a> 中介绍。</p>
<p>当你写完一个函数，结构体，main 之后，你下一步需要的就是测试了。testing 包提供了很简单易用的测试包。</p>
<h2 id="2-写一个基本的测试用例"><a href="#2-写一个基本的测试用例" class="headerlink" title="2. 写一个基本的测试用例"></a>2. 写一个基本的测试用例</h2><p>测试文件的文件名需要以_test.go 为结尾，测试用例需要以 TestXxxx 的形式存在。</p>
<p>比如我要测试 utils 包的 sql.go 中的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func GetOne(db *sql.DB, query string, args ...interface&#123;&#125;) (map[string][]byte, error) &#123;</span><br></pre></td></tr></table></figure>

<p>就需要创建一个 sql_test.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">  _ <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">  <span class="string">&quot;strconv&quot;</span></span><br><span class="line">  <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_GetOne</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:123.abc@tcp(192.168.33.10:3306)/test&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db.Close()</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试 empty</span></span><br><span class="line">  car_brand, err := GetOne(db, <span class="string">&quot;select * from user where id = 999999&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (car_brand != <span class="literal">nil</span>) || (err != <span class="literal">nil</span>) &#123;</span><br><span class="line">    t.Fatal(<span class="string">&quot;emtpy 测试错误 &quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-testing-的测试用例形式"><a href="#3-testing-的测试用例形式" class="headerlink" title="3. testing 的测试用例形式"></a>3. testing 的测试用例形式</h2><p>测试用例有四种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestXxxx(t *testing.T)    // 基本测试用例</span><br><span class="line">BenchmarkXxxx(b *testing.B) // 压力测试的测试用例</span><br><span class="line">Example_Xxx()  // 测试控制台输出的例子</span><br><span class="line">TestMain(m *testing.M) // 测试 Main 函数</span><br></pre></td></tr></table></figure>

<p>给个 Example 的例子 :（Example 需要在最后用注释的方式确认控制台输出和预期是不是一致的）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_GetScore</span><span class="params">()</span></span> &#123;</span><br><span class="line">  score := getScore(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">2.1</span>)</span><br><span class="line">  fmt.Println(score)</span><br><span class="line">  <span class="comment">// Output:</span></span><br><span class="line">  <span class="comment">// 31.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-testing-的变量"><a href="#4-testing-的变量" class="headerlink" title="4. testing 的变量"></a>4. testing 的变量</h2><p>gotest 的变量有这些：</p>
<ul>
<li>test.short : 一个快速测试的标记，在测试用例中可以使用 testing.Short() 来绕开一些测试</li>
<li>test.outputdir : 输出目录</li>
<li>test.coverprofile : 测试覆盖率参数，指定输出文件</li>
<li>test.run : 指定正则来运行某个 / 某些测试用例</li>
<li>test.memprofile : 内存分析参数，指定输出文件</li>
<li>test.memprofilerate : 内存分析参数，内存分析的抽样率</li>
<li>test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析</li>
<li>test.blockprofile : 阻塞事件的分析参数，指定输出文件</li>
<li>test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率</li>
<li>test.timeout : 超时时间</li>
<li>test.cpu : 指定 cpu 数量</li>
<li>test.parallel : 指定运行测试用例的并行数</li>
</ul>
<h2 id="5-testing-的结构体"><a href="#5-testing-的结构体" class="headerlink" title="5. testing 的结构体"></a>5. testing 的结构体</h2><ul>
<li>B : 压力测试</li>
<li>BenchmarkResult : 压力测试结果</li>
<li>Cover : 代码覆盖率相关结构体</li>
<li>CoverBlock : 代码覆盖率相关结构体</li>
<li>InternalBenchmark : 内部使用的结构体</li>
<li>InternalExample : 内部使用的结构体</li>
<li>InternalTest : 内部使用的结构体</li>
<li>M : main 测试使用的结构体</li>
<li>PB : Parallel benchmarks 并行测试使用的结构体</li>
<li>T : 普通测试用例</li>
<li>TB : 测试用例的接口</li>
</ul>
<h2 id="6-testing-的通用方法"><a href="#6-testing-的通用方法" class="headerlink" title="6. testing 的通用方法"></a>6. testing 的通用方法</h2><p>T 结构内部是继承自 common 结构，common 结构提供集中方法，是我们经常会用到的：</p>
<p>1）当我们遇到一个断言错误的时候，我们就会判断这个测试用例失败，就会使用到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fail : case 失败，测试用例继续</span><br><span class="line">FailedNow : case 失败，测试用例中断</span><br></pre></td></tr></table></figure>

<p>2）当我们遇到一个断言错误，只希望跳过这个错误，但是不希望标示测试用例失败，会使用到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkipNow : case 跳过，测试用例不继续</span><br></pre></td></tr></table></figure>

<p>3）当我们只希望在一个地方打印出信息，我们会用到 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log : 输出信息</span><br><span class="line">Logf : 输出有 format 的信息</span><br></pre></td></tr></table></figure>

<p>4）当我们希望跳过这个用例，并且打印出信息 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Skip : Log + SkipNow</span><br><span class="line">Skipf : Logf + SkipNow</span><br></pre></td></tr></table></figure>

<p>5）当我们希望断言失败的时候，测试用例失败，打印出必要的信息，但是测试用例继续：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error : Log + Fail</span><br><span class="line">Errorf : Logf + Fail</span><br></pre></td></tr></table></figure>

<p>6）当我们希望断言失败的时候，测试用例失败，打印出必要的信息，测试用例中断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fatal : Log + FailNow</span><br><span class="line">Fatalf : Logf + FailNow</span><br></pre></td></tr></table></figure>



<h1 id="testing-基准测试"><a href="#testing-基准测试" class="headerlink" title="testing - 基准测试"></a>testing - 基准测试</h1><h2 id="1-testing-基准测试"><a href="#1-testing-基准测试" class="headerlink" title="1.testing - 基准测试"></a>1.testing - 基准测试</h2><p>在 _test.go 结尾的测试文件中，如下形式的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkXxx(*testing.B)</span><br></pre></td></tr></table></figure>

<p>被认为是基准测试，通过 <code>go test</code> 命令，加上 <code>-bench</code> 标志来执行。多个基准测试按照顺序运行。</p>
<p>基准测试函数的形式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHello</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        fmt.Sprintf(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基准函数会运行目标代码 b.N 次。在基准执行期间，程序会自动调整 b.N 直到基准测试函数持续足够长的时间。输出结果形如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkHello    10000000    282 ns/op</span><br></pre></td></tr></table></figure>

<p>意味着循环执行了 10000000 次，每次循环花费 282 纳秒 (ns)。</p>
<p>如果基准测试在循环前需要一些耗时的配置，则可以先重置定时器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkBigLen</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    big := NewBig()</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        big.Len()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果基准测试需要在并行设置中测试性能，则可以使用 <code>RunParallel</code> 辅助函数 ; 这样的基准测试一般与 <code>go test -cpu</code> 标志一起使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkTemplateParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    templ := template.Must(template.New(<span class="string">&quot;test&quot;</span>).Parse(<span class="string">&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;</span>))</span><br><span class="line">    b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 每个 goroutine 有属于自己的 bytes.Buffer.</span></span><br><span class="line">        <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">        <span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">            <span class="comment">// 循环体在所有 goroutine 中总共执行 b.N 次</span></span><br><span class="line">            buf.Reset()</span><br><span class="line">            templ.Execute(&amp;buf, <span class="string">&quot;World&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-1-基准测试示例"><a href="#1-1-基准测试示例" class="headerlink" title="1.1. 基准测试示例"></a>1.1. 基准测试示例</h2><p>接着上一节的例子，我们对 <code>Fib</code> 进行基准测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">                Fib(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>go test -bench=.</code>，输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go test -bench=.</span><br><span class="line">BenchmarkFib10-4        3000000           424 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      chapter09/testing    1.724s</span><br></pre></td></tr></table></figure>

<p>这里测试了 <code>Fib(10)</code> 的情况，我们可能需要测试更多不同的情况，这时可以改写我们的测试代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib1</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(<span class="number">1</span>, b) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib2</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(<span class="number">2</span>, b) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib3</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(<span class="number">3</span>, b) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(<span class="number">10</span>, b) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib20</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(<span class="number">20</span>, b) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib40</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(<span class="number">40</span>, b) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkFib</span><span class="params">(i <span class="keyword">int</span>, b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Fib(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次执行 <code>go test -bench=.</code>，输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go test -bench=.</span><br><span class="line">BenchmarkFib1-4                   1000000000             2.58 ns/op</span><br><span class="line">BenchmarkFib2-4                   200000000             7.38 ns/op</span><br><span class="line">BenchmarkFib3-4                   100000000            13.0 ns/op</span><br><span class="line">BenchmarkFib10-4                   3000000           429 ns/op</span><br><span class="line">BenchmarkFib20-4                     30000         54335 ns/op</span><br><span class="line">BenchmarkFib40-4                         2     805759850 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      chapter09/testing    15.361s</span><br></pre></td></tr></table></figure>

<p>默认情况下，每个基准测试最少运行 1 秒。如果基准测试函数返回时，还不到 1 秒钟，<code>b.N</code> 的值会按照序列 1,2,5,10,20,50,… 增加，同时再次运行基准测测试函数。</p>
<p>我们注意到 <code>BenchmarkFib40</code> 一共才运行 2 次。为了更精确的结果，我们可以通过 <code>-benchtime</code> 标志指定运行时间，从而使它运行更多次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test -bench=Fib40 -benchtime=20s</span><br><span class="line">BenchmarkFib40-4             30     838675800 ns/op</span><br></pre></td></tr></table></figure>



<h2 id="1-2-B-类型"><a href="#1-2-B-类型" class="headerlink" title="1.2. B 类型"></a>1.2. B 类型</h2><p>B 是传递给基准测试函数的一种类型，它用于管理基准测试的计时行为，并<strong>指示应该迭代地运行测试多少次。</strong></p>
<p>当基准测试函数返回时，或者当基准测试函数调用 <code>FailNow</code>、<code>Fatal</code>、<code>Fatalf</code>、<code>SkipNow</code>、<code>Skip</code>、<code>Skipf</code> 中的任意一个方法时，则宣告测试函数结束。至于其他报告方法，比如 <code>Log</code> 和 <code>Error</code> 的变种，则可以在其他 goroutine 中同时进行调用。</p>
<p>跟单元测试一样，基准测试会在执行的过程中积累日志，并在测试完毕时将日志转储到标准错误。但跟单元测试不一样的是，为了避免基准测试的结果受到日志打印操作的影响，基准测试总是会把日志打印出来。</p>
<p>B 类型中的报告方法使用方式和 T 类型是一样的，一般来说，基准测试中也不需要使用，毕竟主要是测性能。这里我们对 B 类型中其他的一些方法进行讲解。</p>
<h3 id="1-2-1-计时方法"><a href="#1-2-1-计时方法" class="headerlink" title="1.2.1. 计时方法"></a>1.2.1. 计时方法</h3><p>有三个方法用于计时：</p>
<ol>
<li>StartTimer：开始对测试进行计时。该方法会在基准测试开始时自动被调用，我们也可以在调用 StopTimer 之后恢复计时；</li>
<li>StopTimer：停止对测试进行计时。当你需要执行一些复杂的初始化操作，并且你不想对这些操作进行测量时，就可以使用这个方法来暂时地停止计时；</li>
<li>ResetTimer：对已经逝去的基准测试时间以及内存分配计数器进行清零。对于正在运行中的计时器，这个方法不会产生任何效果。本节开头有使用示例。</li>
</ol>
<h3 id="1-2-2-并行执行"><a href="#1-2-2-并行执行" class="headerlink" title="1.2.2. 并行执行"></a>1.2.2. 并行执行</h3><p>通过 <code>RunParallel</code> 方法能够并行地执行给定的基准测试。<code>RunParallel</code>会创建出多个 goroutine，并将 b.N 分配给这些 goroutine 执行，其中 goroutine 数量的默认值为 GOMAXPROCS。用户如果想要增加非 CPU 受限（non-CPU-bound）基准测试的并行性，那么可以在 <code>RunParallel</code> 之前调用 <code>SetParallelism</code>（如 <code>SetParallelism(2)</code>，则 goroutine 数量为 2*GOMAXPROCS）。<code>RunParallel</code> 通常会与 <code>-cpu</code> 标志一同使用。</p>
<p><code>body</code> 函数将在每个 goroutine 中执行，这个函数需要设置所有 goroutine 本地的状态，并迭代直到 <code>pb.Next</code> 返回 false 值为止。因为 <code>StartTimer</code>、<code>StopTime</code> 和 <code>ResetTimer</code> 这三个方法都带有全局作用，所以 <code>body</code> 函数不应该调用这些方法； 除此之外，<code>body</code> 函数也不应该调用 <code>Run</code> 方法。</p>
<p>具体的使用示例，在本节开头已经提供！</p>
<h3 id="1-2-3-内存统计"><a href="#1-2-3-内存统计" class="headerlink" title="1.2.3. 内存统计"></a>1.2.3. 内存统计</h3><p><code>ReportAllocs</code> 方法用于打开当前基准测试的内存统计功能， 与 <code>go test</code> 使用 <code>-benchmem</code> 标志类似，但 <code>ReportAllocs</code> 只影响那些调用了该函数的基准测试。</p>
<p>测试示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkTmplExucte</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    b.ReportAllocs()</span><br><span class="line">    templ := template.Must(template.New(<span class="string">&quot;test&quot;</span>).Parse(<span class="string">&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;</span>))</span><br><span class="line">    b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Each goroutine has its own bytes.Buffer.</span></span><br><span class="line">        <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">        <span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">            <span class="comment">// The loop body is executed b.N times total across all goroutines.</span></span><br><span class="line">            buf.Reset()</span><br><span class="line">            templ.Execute(&amp;buf, <span class="string">&quot;World&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkTmplExucte-4        2000000           898 ns/op         368 B/op           9 allocs/op</span><br></pre></td></tr></table></figure>



<h3 id="1-2-4-基准测试结果"><a href="#1-2-4-基准测试结果" class="headerlink" title="1.2.4. 基准测试结果"></a>1.2.4. 基准测试结果</h3><p>对上述结果中的每一项，你是否都清楚是什么意思呢？</p>
<ul>
<li><code>2000000</code> ：基准测试的迭代总次数 b.N</li>
<li><code>898 ns/op</code>：平均每次迭代所消耗的纳秒数</li>
<li><code>368 B/op</code>：平均每次迭代内存所分配的字节数</li>
<li><code>9 allocs/op</code>：平均每次迭代的内存分配次数</li>
</ul>
<p><code>testing</code> 包中的 <code>BenchmarkResult</code> 类型能为你提供帮助，它保存了基准测试的结果，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BenchmarkResult <span class="keyword">struct</span> &#123;</span><br><span class="line">    N         <span class="keyword">int</span>           <span class="comment">// The number of iterations. 基准测试的迭代总次数，即 b.N</span></span><br><span class="line">    T         time.Duration <span class="comment">// The total time taken. 基准测试的总耗时</span></span><br><span class="line">    Bytes     <span class="keyword">int64</span>         <span class="comment">// Bytes processed in one iteration. 一次迭代处理的字节数，通过 b.SetBytes 设置</span></span><br><span class="line">    MemAllocs <span class="keyword">uint64</span>        <span class="comment">// The total number of memory allocations. 内存分配的总次数</span></span><br><span class="line">    MemBytes  <span class="keyword">uint64</span>        <span class="comment">// The total number of bytes allocated. 内存分配的总字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类型还提供了每次迭代操作所消耗资源的计算方法，示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">    <span class="string">&quot;text/template&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    benchmarkResult := testing.Benchmark(<span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        templ := template.Must(template.New(<span class="string">&quot;test&quot;</span>).Parse(<span class="string">&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;</span>))</span><br><span class="line">        <span class="comment">// RunParallel will create GOMAXPROCS goroutines</span></span><br><span class="line">        <span class="comment">// and distribute work among them.</span></span><br><span class="line">        b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">            <span class="comment">// Each goroutine has its own bytes.Buffer.</span></span><br><span class="line">            <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">            <span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">                <span class="comment">// The loop body is executed b.N times total across all goroutines.</span></span><br><span class="line">                buf.Reset()</span><br><span class="line">                templ.Execute(&amp;buf, <span class="string">&quot;World&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fmt.Printf(&quot;%8d\t%10d ns/op\t%10d B/op\t%10d allocs/op\n&quot;, benchmarkResult.N, benchmarkResult.NsPerOp(), benchmarkResult.AllocedBytesPerOp(), benchmarkResult.AllocsPerOp())</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\t%s\n&quot;</span>, benchmarkResult.String(), benchmarkResult.MemString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="testing-子测试与子基准测试"><a href="#testing-子测试与子基准测试" class="headerlink" title="testing - 子测试与子基准测试"></a>testing - 子测试与子基准测试</h1><p>从 Go 1.7 开始，引入了一个新特性：子测试（subtests）与子基准测试（sub-benchmarks），它意味着您现在可以拥有嵌套测试，这对于过滤执行特定测试用例非常有用。</p>
<p>T 和 B 的 <code>Run</code> 方法允许定义子单元测试和子基准测试，而不必为它们单独定义函数。这便于创建基于 Table-Driven 的基准测试和层级测试。它还提供了一种共享通用 <code>setup</code> 和 <code>tear-down</code> 代码的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFoo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// &lt;setup code&gt;</span></span><br><span class="line">    t.Run(<span class="string">&quot;A=1&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; ... &#125;)</span><br><span class="line">    t.Run(<span class="string">&quot;A=2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; ... &#125;)</span><br><span class="line">    t.Run(<span class="string">&quot;B=1&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; ... &#125;)</span><br><span class="line">    <span class="comment">// &lt;tear-down code&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个子测试和子基准测试都有一个唯一的名称：由顶层测试的名称与传递给 <code>Run</code> 的名称组成，以斜杠分隔，并具有可选的尾随序列号，用于消除歧义。</p>
<p>命令行标志 <code>-run</code> 和 <code>-bench</code> 的参数是非固定的正则表达式，用于匹配测试名称。对于由斜杠分隔的测试名称，例如子测试的名称，它名称本身即可作为参数，依次匹配由斜杠分隔的每部分名称。因为参数是非固定的，一个空的表达式匹配任何字符串，所以下述例子中的 “匹配” 意味着 “顶层/子测试名称包含有”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go test -run &#x27;&#x27;      # 执行所有测试。</span><br><span class="line">go test -run Foo     # 执行匹配 &quot;Foo&quot; 的顶层测试，例如 &quot;TestFooBar&quot;。</span><br><span class="line">go test -run Foo/A=  # 对于匹配 &quot;Foo&quot; 的顶层测试，执行其匹配 &quot;A=&quot; 的子测试。</span><br><span class="line">go test -run /A=1    # 执行所有匹配 &quot;A=1&quot; 的子测试。</span><br></pre></td></tr></table></figure>

<p>子测试也可用于程序并行控制。只有子测试全部执行完毕后，父测试才会完成。在下述例子中，所有子测试之间并行运行，此处的 “并行” 只限于这些子测试之间，并不影响定义在其他顶层测试中的子测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGroupedParallel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        tc := tc <span class="comment">// capture range variable</span></span><br><span class="line">        t.Run(tc.Name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            t.Parallel()</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在所有子测试并行运行完毕之前，<code>Run</code> 方法不会返回。下述例子提供了一种方法，用于在子测试并行运行完毕后清理资源：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTeardownParallel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// This Run will not return until the parallel tests finish.</span></span><br><span class="line">    t.Run(<span class="string">&quot;group&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        t.Run(<span class="string">&quot;Test1&quot;</span>, parallelTest1)</span><br><span class="line">        t.Run(<span class="string">&quot;Test2&quot;</span>, parallelTest2)</span><br><span class="line">        t.Run(<span class="string">&quot;Test3&quot;</span>, parallelTest3)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// &lt;tear-down code&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="testing-运行并验证示例"><a href="#testing-运行并验证示例" class="headerlink" title="testing - 运行并验证示例"></a>testing - 运行并验证示例</h1><p><code>testing</code> 包除了测试，还提供了运行并验证示例的功能。示例，一方面是文档的效果，是关于某个功能的使用例子；另一方面，可以被当做测试运行。</p>
<p>一个示例的例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="comment">// Output: Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>Output: Hello</code> 改为：<code>Output: hello</code>，运行测试会失败，提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">got:</span><br><span class="line">Hello</span><br><span class="line">want:</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>一个示例函数以 Example 开头，如果示例函数包含以 “Output:” 开头的行注释，在运行测试时，go 会将示例函数的输出和 “Output:” 注释中的值做比较，就如上面的例子。</p>
<p>有时候，输出顺序可能不确定，比如循环输出 map 的值，那么可以使用 “Unordered output:” 开头的注释。</p>
<p>如果示例函数没有上述输出注释，该示例函数只会被编译而不会被运行。</p>
<h2 id="1-1-命名约定"><a href="#1-1-命名约定" class="headerlink" title="1.1. 命名约定"></a>1.1. 命名约定</h2><p>Go 语言通过大量的命名约定来简化工具的复杂度，规范代码的风格。对示例函数的命名有如下约定：</p>
<ul>
<li>包级别的示例函数，直接命名为 <code>func Example() &#123; ... &#125;</code></li>
<li>函数 F 的示例，命名为 <code>func ExampleF() &#123; ... &#125;</code></li>
<li>类型 T 的示例，命名为 <code>func ExampleT() &#123; ... &#125;</code></li>
<li>类型 T 上的 方法 M 的示例，命名为 <code>func ExampleT_M() &#123; ... &#125;</code></li>
</ul>
<p>有时，我们想要给 包 / 类型 / 函数 / 方法 提供多个示例，可以通过在示例函数名称后附加一个不同的后缀来实现，但这种后缀必须以小写字母开头，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_suffix</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleF_suffix</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleT_suffix</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleT_M_suffix</span><span class="params">()</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>通常，示例代码会放在单独的示例文件中，命名为 <code>example_test.go</code>。可以查看 <code>io</code> 包中的 <code>example_test.go</code> 了解示例的编写。</p>
<h2 id="1-2-实现原理"><a href="#1-2-实现原理" class="headerlink" title="1.2. 实现原理"></a>1.2. 实现原理</h2><p>本节开头提到了示例的两个作用，它们分别是由 <code>godoc</code> 和 <code>go test</code> 这两个命令实现的。</p>
<p>在执行 <code>go test</code> 时，会运行示例。具体的实现原理，可以通过阅读 <code>go test</code> 命令源码和 <code>testing</code> 包中 <code>example.go</code> 文件了解。</p>
<h1 id="testing-其他功能"><a href="#testing-其他功能" class="headerlink" title="testing - 其他功能"></a>testing - 其他功能</h1><h2 id="1-1-TestMain"><a href="#1-1-TestMain" class="headerlink" title="1.1. TestMain"></a>1.1. TestMain</h2><p>在写测试时，有时需要在测试之前或之后进行额外的设置（setup）或拆卸（teardown）；有时，测试还需要控制在主线程上运行的代码。为了支持这些需求，<code>testing</code> 包提供了 <code>TestMain</code> 函数 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func TestMain(m *testing.M)</span><br></pre></td></tr></table></figure>

<p>如果测试文件中包含该函数，那么生成的测试将调用 <code>TestMain(m)</code>，而不是直接运行测试。<code>TestMain</code> 运行在主 goroutine 中 , 可以在调用 <code>m.Run</code> 前后做任何设置和拆卸。注意，在 <code>TestMain</code> 函数的最后，应该使用 <code>m.Run</code> 的返回值作为参数去调用 <code>os.Exit</code>。</p>
<p>另外，在调用 <code>TestMain</code> 时 , <code>flag.Parse</code> 并没有被调用。所以，如果 <code>TestMain</code> 依赖于 command-line 标志（包括 <code>testing</code> 包的标志），则应该显式地调用 <code>flag.Parse</code>。注意，这里的依赖是指，若 <code>TestMain</code> 函数内需要用到 command-line 标志，则必须显式地调用 <code>flag.Parse</code>，否则不需要，因为 <code>m.Run</code> 中调用 <code>flag.Parse</code>。</p>
<p>一个包含 <code>TestMain</code> 的例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mytestmain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Dns <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">    db.Dns = os.Getenv(<span class="string">&quot;DATABASE_DNS&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> db.Dns == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        db.Dns = <span class="string">&quot;root:123456@tcp(localhost:3306)/?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flag.Parse()</span><br><span class="line">    exitCode := m.Run()</span><br><span class="line"></span><br><span class="line">    db.Dns = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出</span></span><br><span class="line">    os.Exit(exitCode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDatabase</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    fmt.Println(db.Dns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 <code>m.Run</code> 感兴趣的可以阅读源码，了解其原理。</p>
<h2 id="1-2-Test-Coverage"><a href="#1-2-Test-Coverage" class="headerlink" title="1.2. Test Coverage"></a>1.2. Test Coverage</h2><p>测试覆盖率，这里讨论的是基于代码的测试覆盖率。</p>
<p>Go 从 1.2 开始，引入了对测试覆盖率的支持，使用的是与 cover 相关的工具（<code>go test -cover</code>、<code>go tool cover</code>）。虽然 <code>testing</code> 包提供了 cover 相关函数，不过它们是给 cover 的工具使用的。</p>
<p>关于测试覆盖率的更多信息，可以参考官方的博文：<a target="_blank" rel="noopener" href="https://blog.golang.org/cover">The cover story</a></p>
<h1 id="httptest-HTTP-测试辅助工具"><a href="#httptest-HTTP-测试辅助工具" class="headerlink" title="httptest - HTTP 测试辅助工具"></a>httptest - HTTP 测试辅助工具</h1><h2 id="1-httptest-HTTP-测试辅助工具"><a href="#1-httptest-HTTP-测试辅助工具" class="headerlink" title="1.httptest - HTTP 测试辅助工具"></a>1.httptest - HTTP 测试辅助工具</h2><p>由于 Go 标准库的强大支持，Go 可以很容易的进行 Web 开发。为此，Go 标准库专门提供了 <code>net/http/httptest</code> 包专门用于进行 http Web 开发测试。</p>
<p>本节我们通过一个社区帖子的增删改查的例子来学习该包。</p>
<h2 id="1-1-简单的-Web-应用"><a href="#1-1-简单的-Web-应用" class="headerlink" title="1.1. 简单的 Web 应用"></a>1.1. 简单的 Web 应用</h2><p>我们首先构建一个简单的 Web 应用。</p>
<p>为了简单起见，数据保存在内存，并且没有考虑并发问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存 Topic，没有考虑并发问题</span></span><br><span class="line"><span class="keyword">var</span> TopicCache = <span class="built_in">make</span>([]*Topic, <span class="number">0</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Topic <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id        <span class="keyword">int</span>       <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">    Title     <span class="keyword">string</span>    <span class="string">`json:&quot;title&quot;`</span></span><br><span class="line">    Content   <span class="keyword">string</span>    <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">    CreatedAt time.Time <span class="string">`json:&quot;created_at&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>Topic</code> 的增删改查代码很简单，可以查看<a target="_blank" rel="noopener" href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/code/src/chapter09/httptest/data.go">完整代码</a>。</p>
<p>接下来，是通过 <code>net/http</code> 包来实现一个 Web 应用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/topic/&quot;</span>, handleRequest)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:2017&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>/topic/</code> 开头的请求都交由 <code>handleRequest</code> 处理，它根据不同的 <code>Method</code> 执行相应的增删改查，详细代码可以查看 <a target="_blank" rel="noopener" href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/code/src/chapter09/httptest/server.go">server.go</a>。</p>
<p>准备好 Web 应用后，我们启动它。</p>
<blockquote>
<p>go run server.go data.go</p>
</blockquote>
<p>通过 <code>curl</code> 进行简单的测试：</p>
<blockquote>
<p>增：curl -i -X POST <a target="_blank" rel="noopener" href="http://localhost:2017/topic/">http://localhost:2017/topic/</a> -H ‘content-type: application/json’ -d ‘{“title”:”The Go Standard Library”,”content”:”It contains many packages.”}’</p>
<p>查：curl -i -X GET <a target="_blank" rel="noopener" href="http://localhost:2017/topic/1">http://localhost:2017/topic/1</a></p>
<p>改：curl -i -X PUT <a target="_blank" rel="noopener" href="http://localhost:2017/topic/1">http://localhost:2017/topic/1</a> -H ‘content-type: application/json’ -d ‘{“title”:”The Go Standard Library By Example”,”content”:”It contains many packages, enjoying it.”}’</p>
<p>删：curl -i -X DELETE <a target="_blank" rel="noopener" href="http://localhost:2017/topic/1">http://localhost:2017/topic/1</a></p>
</blockquote>
<h2 id="1-2-通过-httptest-进行测试"><a href="#1-2-通过-httptest-进行测试" class="headerlink" title="1.2. 通过 httptest 进行测试"></a>1.2. 通过 httptest 进行测试</h2><p>上面，我们通过 <code>curl</code> 对我们的 Web 应用的接口进行了测试。现在，我们通过 <code>net/http/httptest</code> 包进行测试。</p>
<p>我们先测试创建帖子，也就是测试 <code>handlePost</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHandlePost</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/topic/&quot;</span>, handleRequest)</span><br><span class="line"></span><br><span class="line">    reader := strings.NewReader(<span class="string">`&#123;&quot;title&quot;:&quot;The Go Standard Library&quot;,&quot;content&quot;:&quot;It contains many packages.&quot;&#125;`</span>)</span><br><span class="line">    r, _ := http.NewRequest(http.MethodPost, <span class="string">&quot;/topic/&quot;</span>, reader)</span><br><span class="line"></span><br><span class="line">    w := httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line">    mux.ServeHTTP(w, r)</span><br><span class="line"></span><br><span class="line">    resp := w.Result()</span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Response code is %v&quot;</span>, resp.StatusCode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先跟待测试代码一样，配置上路由，对 <code>/topic/</code> 的请求都交由 <code>handleRequest</code> 处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/topic/&quot;</span>, handleRequest)</span><br></pre></td></tr></table></figure>

<p>因为 <code>handlePost</code> 的函数签名是 <code>func handlePost(w http.ResponseWriter, r *http.Request) error</code>，为了测试它，我们必须创建 <code>http.ResponseWriter</code> 和 <code>http.Request</code> 的实例。</p>
<p>接下来的代码就是创建一个 <code>http.Request</code> 实例 和一个 <code>http.ResponseWriter</code> 的实例。这里的关键是，通过 <code>httptest.NewRecorder()</code> 可以获得 <code>httptest.ResponseRecorder</code> 结构，而此结构实现了<code>http.ResponseWriter</code> 接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reader := strings.NewReader(<span class="string">`&#123;&quot;title&quot;:&quot;The Go Standard Library&quot;,&quot;content&quot;:&quot;It contains many packages.&quot;&#125;`</span>)</span><br><span class="line">r, _ := http.NewRequest(http.MethodPost, <span class="string">&quot;/topic/&quot;</span>, reader)</span><br><span class="line"></span><br><span class="line">w := httptest.NewRecorder()</span><br></pre></td></tr></table></figure>

<p>准备好之后，可以测试目标函数了。这里，我们没有直接调用 <code>handlePost(w, r)</code>，而是调用 <code>mux.ServeHTTP(w, r)</code>，实际上这里直接调用 <code>handlePost(w, r)</code> 也是可以的，但调用 <code>mux.ServeHTTP(w, r)</code> 会更完整地测试整个流程。<code>mux.ServeHTTP(w, r)</code> 最终也会调用到 <code>handlePost(w, r)</code>。</p>
<p>最后，通过 <code>go test -v</code> 运行测试。</p>
<p>查、改和删帖子的接口测试代码类似，比如，<code>handleGet</code> 的测试代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHandleGet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/topic/&quot;</span>, handleRequest)</span><br><span class="line"></span><br><span class="line">    r, _ := http.NewRequest(http.MethodGet, <span class="string">&quot;/topic/1&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    w := httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line">    mux.ServeHTTP(w, r)</span><br><span class="line"></span><br><span class="line">    resp := w.Result()</span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Response code is %v&quot;</span>, resp.StatusCode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topic := <span class="built_in">new</span>(Topic)</span><br><span class="line">    json.Unmarshal(w.Body.Bytes(), topic)</span><br><span class="line">    <span class="keyword">if</span> topic.Id != <span class="number">1</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Cannot get topic&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：因为数据没有落地存储，为了保证后面的测试正常，请将 <code>TestHandlePost</code> 放在最前面。</em></p>
<h2 id="1-3-测试代码改进"><a href="#1-3-测试代码改进" class="headerlink" title="1.3. 测试代码改进"></a>1.3. 测试代码改进</h2><p>细心的朋友应该会发现，上面的测试代码有重复，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/topic/&quot;</span>, handleRequest)</span><br></pre></td></tr></table></figure>

<p>以及：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w := httptest.NewRecorder()</span><br></pre></td></tr></table></figure>

<p>这正好是前面学习的 <code>setup</code> 可以做的事情，因此可以使用 <code>TestMain</code> 来做重构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w *httptest.ResponseRecorder</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">    http.DefaultServeMux.HandleFunc(<span class="string">&quot;/topic/&quot;</span>, handleRequest)</span><br><span class="line"></span><br><span class="line">    w = httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line">    os.Exit(m.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>