<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;6-2-同步原语与锁&quot;&gt;&lt;a href=&quot;#6-2-同步原语与锁&quot; class=&quot;headerlink&quot; title=&quot;6.2 同步原语与锁 #&quot;&gt;&lt;/a&gt;6.2 同步原语与锁 &lt;a href=&quot;https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#62-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;Go 语言作为一个原生支持用户态进程（Goroutine）的语言，当提到并发编程、多线程编程时，往往都离不开锁这一概念。锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Golang并发编程 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-08-29</div></div></div><div class="container post-header"><h1>Golang并发编程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#6-2-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">6.2 同步原语与锁 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.1.</span> <span class="toc-text">6.2.1 基本原语 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutex"><span class="toc-number">1.1.1.</span> <span class="toc-text">Mutex </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">状态 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%A5%A5%E9%A5%BF%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">正常模式和饥饿模式 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E5%92%8C%E8%A7%A3%E9%94%81"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">加锁和解锁 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">小结 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RWMutex"><span class="toc-number">1.1.2.</span> <span class="toc-text">RWMutex </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">结构体 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E9%94%81"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">写锁 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E9%94%81"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">读锁 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">小结 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitGroup"><span class="toc-number">1.1.3.</span> <span class="toc-text">WaitGroup </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-1"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">结构体 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">接口 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">小结 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Once"><span class="toc-number">1.1.4.</span> <span class="toc-text">Once </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-2"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">结构体 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-1"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">接口 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">小结 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cond"><span class="toc-number">1.1.5.</span> <span class="toc-text">Cond </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-3"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">结构体 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-2"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">接口 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">小结 </span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-2-%E6%89%A9%E5%B1%95%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.2.</span> <span class="toc-text">6.2.2 扩展原语 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ErrGroup"><span class="toc-number">1.2.1.</span> <span class="toc-text">ErrGroup </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-4"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">结构体 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-3"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">接口 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">小结 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">1.2.2.</span> <span class="toc-text">Semaphore </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">结构体 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">获取 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">释放 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">小结 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SingleFlight"><span class="toc-number">1.2.3.</span> <span class="toc-text">SingleFlight </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-6"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">结构体 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-4"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">接口 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">小结 </span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-3-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">6.2.3 小结 </span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="6-2-同步原语与锁"><a href="#6-2-同步原语与锁" class="headerlink" title="6.2 同步原语与锁 #"></a>6.2 同步原语与锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#62-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%94%81">#</a></h1><p>Go 语言作为一个原生支持用户态进程（Goroutine）的语言，当提到并发编程、多线程编程时，往往都离不开锁这一概念。锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题。</p>
<p>本节会介绍 Go 语言中常见的同步原语 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex"><code>sync.RWMutex</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 以及扩展原语 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group"><code>golang/sync/errgroup.Group</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted"><code>golang/sync/semaphore.Weighted</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。</p>
<h2 id="6-2-1-基本原语"><a href="#6-2-1-基本原语" class="headerlink" title="6.2.1 基本原语 #"></a>6.2.1 基本原语 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#621-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E8%AF%AD">#</a></h2><p>Go 语言在 <a target="_blank" rel="noopener" href="https://golang.org/pkg/sync/"><code>sync</code></a> 包中提供了用于同步的一些基本原语，包括常见的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex"><code>sync.RWMutex</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a>：</p>
<p><img src="/images/2020-01-23-15797104327981-golang-basic-sync-primitives.png" alt="golang-basic-sync-primitives"></p>
<p><strong>图 6-5 基本同步原语</strong></p>
<p>了较为基础的同步功能，但是它们是一种相对原始的同步机制，在多数情况下，我们都应该使用抽象层级的更高的 Channel 实现同步。</p>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex #"></a>Mutex <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#mutex">#</a></h3><p>Go 语言的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a> 由两个字段 <code>state</code> 和 <code>sema</code> 组成。其中 <code>state</code> 表示当前互斥锁的状态，而 <code>sema</code> 是用于控制锁状态的信号量(Semaphore)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;	</span><br><span class="line">	state <span class="keyword">int32</span>	</span><br><span class="line">  sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态 #"></a>状态 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E7%8A%B6%E6%80%81">#</a></h4><p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 <code>mutexLocked</code>、<code>mutexWoken</code> 和 <code>mutexStarving</code>，剩下的位置用来表示当前有多少个 Goroutine 在等待互斥锁的释放：</p>
<p><img src="/images/2020-01-23-15797104328010-golang-mutex-state.png" alt="golang-mutex-state"></p>
<p><strong>图 6-6 互斥锁的状态</strong></p>
<p>在默认情况下，互斥锁的所有状态位都是 0，<code>int32</code> 中的不同位分别表示了不同的状态：</p>
<ul>
<li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li>
<li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li>
<li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li>
<li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</li>
</ul>
<h4 id="正常模式和饥饿模式"><a href="#正常模式和饥饿模式" class="headerlink" title="正常模式和饥饿模式 #"></a>正常模式和饥饿模式 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E6%AD%A3%E5%B8%B8%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%A5%A5%E9%A5%BF%E6%A8%A1%E5%BC%8F">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a> 有两种模式 — <code>正常模式</code>和<code>饥饿模式</code>。</p>
<p>我们需要在这里先了解正常模式和饥饿模式都是什么以及它们有什么样的关系。</p>
<p>在正常模式下，<strong>锁的等待者会按照先进先出的顺序获取锁</strong>。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』。</p>
<p><img src="/images/2020-01-23-15797104328020-golang-mutex-mode.png" alt="golang-mutex-mode"></p>
<p><strong>图 6-7 互斥锁的正常模式与饥饿模式</strong></p>
<p>饥饿模式是在 Go 语言在 1.9 中通过提交 <a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/0556e26273f704db73df9e7c4c3d2e8434dec7be">sync: make Mutex more fair</a> 引入的优化<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#fn:1">1</a>，引入的目的是保证互斥锁的公平性。</p>
<p>在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。<strong>如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</strong></p>
<p>与饥饿模式相比，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p>
<h4 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁 #"></a>加锁和解锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%8A%A0%E9%94%81%E5%92%8C%E8%A7%A3%E9%94%81">#</a></h4><p>我们在这一节中将分别介绍互斥锁的加锁和解锁过程，它们分别使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Lock"><code>sync.Mutex.Lock</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Unlock"><code>sync.Mutex.Unlock</code></a> 方法。</p>
<p>互斥锁的加锁是靠 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Lock"><code>sync.Mutex.Lock</code></a> 完成的，最新的 Go 语言源代码中已经将 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Lock"><code>sync.Mutex.Lock</code></a> 方法进行了简化，方法的主干只保留最常见、简单的情况 — 当锁的状态是 0 时，将 <code>mutexLocked</code> 位置成 1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> &#125;	</span><br><span class="line">  m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果互斥锁的状态不是 0 时就会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.lockSlow"><code>sync.Mutex.lockSlow</code></a> 尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p>
<ol>
<li>判断当前 Goroutine 能否进入自旋；</li>
<li>通过自旋等待互斥锁的释放；</li>
<li>计算互斥锁的最新状态；</li>
<li>更新互斥锁的状态并获取锁；</li>
</ol>
<p>我们先来介绍互斥锁是如何判断当前 Goroutine 能否进入自旋等互斥锁的释放：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">	starving := <span class="literal">false</span></span><br><span class="line">	awoke := <span class="literal">false</span></span><br><span class="line">	iter := <span class="number">0</span></span><br><span class="line">	old := m.state</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp; atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自旋是一种多线程同步机制，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p>
<ol>
<li>互斥锁只有在普通模式才能进入自旋；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_canSpin"><code>runtime.sync_runtime_canSpin</code></a> 需要返回 <code>true</code>：<ol>
<li>运行在多 CPU 的机器上；</li>
<li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li>
</ol>
</li>
</ol>
<p>一旦当前 Goroutine 能够进入自旋就会调用<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_doSpin"><code>runtime.sync_runtime_doSpin</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.procyield"><code>runtime.procyield</code></a> 并执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">  procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,</span><br><span class="line">$<span class="number">0</span><span class="number">-0</span>	MOVL	cycles+<span class="number">0</span>(FP), AXagain:	PAUSE	SUBL	$<span class="number">1</span>, AX	JNZ	again	RET</span><br></pre></td></tr></table></figure>

<p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> := old		</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">new</span> |= mutexLocked		</span><br><span class="line">&#125;		</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift		</span><br><span class="line">&#125;		</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">new</span> |= mutexStarving		</span><br><span class="line">&#125;		</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">  <span class="built_in">new</span> &amp;^= mutexWoken		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算了新的互斥锁状态之后，会使用 CAS 函数 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic.CompareAndSwapInt32"><code>sync/atomic.CompareAndSwapInt32</code></a> 更新状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">break</span> <span class="comment">// 通过 CAS 函数获取了锁	</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">	starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">	old = m.state</span><br><span class="line">	<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">		delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">		<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">			delta -= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	awoke = <span class="literal">true</span></span><br><span class="line">	iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	old = m.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有通过 CAS 获得锁，会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code>runtime.sync_runtime_SemacquireMutex</code></a> 通过信号量保证资源不会被两个 Goroutine 获取。<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code>runtime.sync_runtime_SemacquireMutex</code></a> 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Lock"><code>sync.Mutex.Lock</code></a> 的剩余代码也会继续执行。</p>
<ul>
<li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li>
<li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li>
</ul>
<p>互斥锁的解锁过程 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Unlock"><code>sync.Mutex.Unlock</code></a> 与加锁过程相比就很简单，该过程会先使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic.AddInt32"><code>sync/atomic.AddInt32</code></a> 函数快速解锁，这时会发生下面的两种情况：</p>
<ul>
<li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li>
<li>如果该函数返回的新状态不等于 0，这段代码会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.unlockSlow"><code>sync.Mutex.unlockSlow</code></a> 开始慢速解锁：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)	</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">  	m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.unlockSlow"><code>sync.Mutex.unlockSlow</code></a> 会先校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。</p>
<p>在正常情况下会根据当前互斥锁的状态，分别处理正常模式和饥饿模式下的互斥锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 正常模式		</span></span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 饥饿模式		</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在正常模式下，上述代码会使用如下所示的处理过程：<ul>
<li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li>
<li>如果互斥锁存在等待者，会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.runtime_Semrelease"><code>sync.runtime_Semrelease</code></a> 唤醒等待者并移交锁的所有权；</li>
</ul>
</li>
<li>在饥饿模式下，上述代码会直接调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.runtime_Semrelease"><code>sync.runtime_Semrelease</code></a> 将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结 #"></a>小结 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%B0%8F%E7%BB%93">#</a></h4><p>我们已经从多个方面分析了互斥锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a> 的实现原理，这里我们从加锁和解锁两个方面总结注意事项。</p>
<p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p>
<ul>
<li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li>
<li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code>runtime.sync_runtime_SemacquireMutex</code></a> 将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li>
</ul>
<p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p>
<ul>
<li>当互斥锁已经被解锁时，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Unlock"><code>sync.Mutex.Unlock</code></a> 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.runtime_Semrelease"><code>sync.runtime_Semrelease</code></a> 唤醒对应的 Goroutine；</li>
</ul>
<h3 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex #"></a>RWMutex <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#rwmutex">#</a></h3><p>读写互斥锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex"><code>sync.RWMutex</code></a> 是细粒度的互斥锁，它不限制资源的并发读，但是读写、写写操作无法并行执行。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">读</th>
<th align="center">写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">写</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
</tbody></table>
<p><strong>表 6-1 RWMutex 的读写并发</strong></p>
<p>常见服务的资源读写比例会非常高，因为大多数的读请求之间不会相互影响，所以我们可以分离读写操作，以此来提高服务的性能。</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体 #"></a>结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E7%BB%93%E6%9E%84%E4%BD%93">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex"><code>sync.RWMutex</code></a> 中总共包含以下 5 个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex</span><br><span class="line">	writerSem   <span class="keyword">uint32</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span></span><br><span class="line">	readerCount <span class="keyword">int32</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>w</code> — 复用互斥锁提供的能力；</li>
<li><code>writerSem</code> 和 <code>readerSem</code> — 分别用于写等待读和读等待写：</li>
<li><code>readerCount</code> 存储了当前正在执行的读操作数量；</li>
<li><code>readerWait</code> 表示当写操作被阻塞时等待的读操作个数；</li>
</ul>
<p>我们会依次分析获取写锁和读锁的实现原理，其中：</p>
<ul>
<li>写操作使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Lock"><code>sync.RWMutex.Lock</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Unlock"><code>sync.RWMutex.Unlock</code></a> 方法；</li>
<li>读操作使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RLock"><code>sync.RWMutex.RLock</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code>sync.RWMutex.RUnlock</code></a> 方法；</li>
</ul>
<h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁 #"></a>写锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%86%99%E9%94%81">#</a></h4><p>当资源的使用者想要获取写锁时，需要调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Lock"><code>sync.RWMutex.Lock</code></a> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go</p>
<ol>
<li>调用结构体持有的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a> 结构体的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Lock"><code>sync.Mutex.Lock</code></a> 阻塞后续的写操作；<ul>
<li>因为互斥锁已经被获取，其他 Goroutine 在获取写锁时会进入自旋或者休眠；</li>
</ul>
</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic.AddInt32"><code>sync/atomic.AddInt32</code></a> 函数阻塞后续的读操作：</li>
<li>如果仍然有其他 Goroutine 持有互斥锁的读锁，该 Goroutine 会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code>runtime.sync_runtime_SemacquireMutex</code></a> 进入休眠状态等待所有读锁所有者执行结束后释放 <code>writerSem</code> 信号量将当前协程唤醒；</li>
</ol>
<p>写锁的释放会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Unlock"><code>sync.RWMutex.Unlock</code></a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与加锁的过程正好相反，写锁的释放分以下几个执行：</p>
<ol>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic.AddInt32"><code>sync/atomic.AddInt32</code></a> 函数将 <code>readerCount</code> 变回正数，释放读锁；</li>
<li>通过 for 循环释放所有因为获取读锁而陷入等待的 Goroutine：</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex.Unlock"><code>sync.Mutex.Unlock</code></a> 释放写锁；</li>
</ol>
<p>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作『饿死』。</p>
<h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁 #"></a>读锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E8%AF%BB%E9%94%81">#</a></h4><p>读锁的加锁方法 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RLock"><code>sync.RWMutex.RLock</code></a> 很简单，该方法会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic.AddInt32"><code>sync/atomic.AddInt32</code></a> 将 <code>readerCount</code> 加一：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果该方法返回负数 — 其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex"><code>runtime.sync_runtime_SemacquireMutex</code></a> 陷入休眠等待锁的释放；</li>
<li>如果该方法的结果为非负数 — 没有 Goroutine 获得写锁，当前方法会成功返回；</li>
</ol>
<p>当 Goroutine 想要释放读锁时，会调用如下所示的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code>sync.RWMutex.RUnlock</code></a> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会先减少正在读资源的 <code>readerCount</code> 整数，根据 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic.AddInt32"><code>sync/atomic.AddInt32</code></a> 的返回值不同会分别进行处理：</p>
<ul>
<li>如果返回值大于等于零 — 读锁直接解锁成功；</li>
<li>如果返回值小于零 — 有一个正在执行的写操作，在这时会调用<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.rUnlockSlow"><code>sync.RWMutex.rUnlockSlow</code></a> 方法；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.rUnlockSlow"><code>sync.RWMutex.rUnlockSlow</code></a> 会减少获取锁的写操作等待的读操作数 <code>readerWait</code> 并在所有读操作都被释放之后触发写操作的信号量 <code>writerSem</code>，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结 #"></a>小结 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%B0%8F%E7%BB%93-1">#</a></h4><p>虽然读写互斥锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex"><code>sync.RWMutex</code></a> 提供的功能比较复杂，但是因为它建立在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a> 上，所以实现会简单很多。我们总结一下读锁和写锁的关系：</p>
<ul>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Lock"><code>sync.RWMutex.Lock</code></a> 尝试获取写锁时；<ul>
<li>每次 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.RUnlock"><code>sync.RWMutex.RUnlock</code></a> 都会将 <code>readerCount</code> 其减一，当它归零时该 Goroutine 会获得写锁；</li>
<li>将 <code>readerCount</code> 减少 <code>rwmutexMaxReaders</code> 个数以阻塞后续的读操作；</li>
</ul>
</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.RWMutex.Unlock"><code>sync.RWMutex.Unlock</code></a> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li>
</ul>
<p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p>
<h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup #"></a>WaitGroup <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#waitgroup">#</a></h3><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done() <span class="comment">// res, err := service.call(r)    &#125;(request)&#125;wg.Wait()</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 将原本顺序执行的代码在多个 Goroutine 中并发执行，加快程序处理的速度。</p>
<p><img src="/images/2020-01-23-15797104328028-golang-syncgroup.png" alt="golang-syncgroup"></p>
<p><strong>图 6-8 WaitGroup 等待多个 Goroutine</strong></p>
<h4 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体 #"></a>结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E7%BB%93%E6%9E%84%E4%BD%93-1">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 结构体中只包含两个成员变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;	noCopy noCopy	state1 [<span class="number">3</span>]<span class="keyword">uint32</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>noCopy</code> — 保证 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 不会被开发者通过再赋值的方式拷贝；</li>
<li><code>state1</code> — 存储着状态和信号量；</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.noCopy"><code>sync.noCopy</code></a> 是一个特殊的私有结构体，<a target="_blank" rel="noopener" href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/copylock"><code>tools/go/analysis/passes/copylock</code></a> 包中的分析器会在编译期间检查被拷贝的变量中是否包含 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.noCopy"><code>sync.noCopy</code></a> 或者实现了 <code>Lock</code> 和 <code>Unlock</code> 方法，如果包含该结构体或者实现了对应的方法就会报出以下错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	yawg := wg</span><br><span class="line">	fmt.Println(wg, yawg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> vet proc.<span class="keyword">go</span>./prog.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">10</span>: assignment copies lock value to yawg: sync.WaitGroup./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">14</span>: call of fmt.Println copies lock value: sync.WaitGroup./prog.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">18</span>: call of fmt.Println copies lock value: sync.WaitGroup</span><br></pre></td></tr></table></figure>

<p>这段代码会因为变量赋值或者调用函数时发生值拷贝导致分析器报错。</p>
<p>除了 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.noCopy"><code>sync.noCopy</code></a> 之外，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a>` 结构体中还包含一个总共占用 12 字节的数组，这个数组会存储当前结构体的状态，在 64 位与 32 位的机器上表现也非常不同。</p>
<p><img src="/images/2020-01-23-15797104328035-golang-waitgroup-state.png" alt="golang-waitgroup-state"></p>
<p><strong>图 6-9 WaitGroup 在 64 位和 32 位机器的不同状态</strong></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 提供的私有方法 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.state"><code>sync.WaitGroup.state</code></a> 能够帮我们从 <code>state1</code> 字段中取出它的状态和信号量。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口 #"></a>接口 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E6%8E%A5%E5%8F%A3">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 对外暴露了三个方法 — <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Done"><code>sync.WaitGroup.Done</code></a>。</p>
<p>因为其中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Done"><code>sync.WaitGroup.Done</code></a> 只是向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法传入了 -1，所以我们重点分析另外两个方法，即 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">	v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">	w := <span class="keyword">uint32</span>(state)</span><br><span class="line">	<span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	*statep = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">		runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 可以更新 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 中的计数器 <code>counter</code>。虽然 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法传入的参数可以为负数，但是计数器只能是非负数，一旦出现负数就会发生程序崩溃。当调用计数器归零，即所有任务都执行完成时，才会通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.runtime_Semrelease"><code>sync.runtime_Semrelease</code></a> 唤醒处于等待状态的 Goroutine。</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 的另一个方法 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a> 会在计数器大于 0 并且不存在等待的 Goroutine 时，调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.sync_runtime_Semacquire"><code>runtime.sync_runtime_Semacquire</code></a> 陷入睡眠。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		state := atomic.LoadUint64(statep)</span><br><span class="line">		v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">			runtime_Semacquire(semap)</span><br><span class="line">			<span class="keyword">if</span> +statep != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 的计数器归零时，陷入睡眠状态的 Goroutine 会被唤醒，上述方法也会立刻返回。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结 #"></a>小结 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%B0%8F%E7%BB%93-2">#</a></h4><p>通过对 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 的分析和研究，我们能够得出以下结论：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 必须在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a> 方法返回之后才能被重新使用；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Done"><code>sync.WaitGroup.Done</code></a> 只是对 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法的简单封装，我们可以向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 Goroutine；</li>
<li>可以同时有多个 Goroutine 等待当前 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 计数器的归零，这些 Goroutine 会被同时唤醒；</li>
</ul>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once #"></a>Once <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#once">#</a></h3><p>Go 语言标准库中 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 可以保证在 Go 程序运行期间的某段代码只会执行一次。在运行如下所示的代码时，我们会看到如下所示的运行结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	o := &amp;sync.Once&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">&quot;only once&quot;</span>) &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$ <span class="keyword">go</span> run main.goonly once</span><br></pre></td></tr></table></figure>



<h4 id="结构体-2"><a href="#结构体-2" class="headerlink" title="结构体 #"></a>结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E7%BB%93%E6%9E%84%E4%BD%93-2">#</a></h4><p>每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 结构体中都只包含一个用于标识代码块是否执行过的 <code>done</code> 以及一个互斥锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	done <span class="keyword">uint32</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="接口-1"><a href="#接口-1" class="headerlink" title="接口 #"></a>接口 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E6%8E%A5%E5%8F%A3-1">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.Do"><code>sync.Once.Do</code></a> 是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 结构体对外唯一暴露的方法，该方法会接收一个入参为空的函数：</p>
<ul>
<li>如果传入的函数已经执行过，会直接返回；</li>
<li>如果传入的函数没有执行过，会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.doSlow"><code>sync.Once.doSlow</code></a> 执行传入的函数：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>为当前 Goroutine 获取互斥锁；</li>
<li>执行传入的无入参函数；</li>
<li>运行延迟函数调用，将成员变量 <code>done</code> 更新成 1；</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 会通过成员变量 <code>done</code> 确保函数不会执行第二次。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结 #"></a>小结 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%B0%8F%E7%BB%93-3">#</a></h4><p>作为用于保证函数执行次数的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once"><code>sync.Once</code></a> 结构体，它使用互斥锁和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync/atomic"><code>sync/atomic</code></a> 包提供的方法实现了某个函数在程序运行期间只能执行一次的语义。在使用该结构体时，我们也需要注意以下的问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.Do"><code>sync.Once.Do</code></a> 方法中传入的函数只会被执行一次，哪怕函数中发生了 <code>panic</code>；</li>
<li>两次调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Once.Do"><code>sync.Once.Do</code></a> 方法传入不同的函数只会执行第一次调传入的函数；</li>
</ul>
<h3 id="Cond"><a href="#Cond" class="headerlink" title="Cond #"></a>Cond <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#cond">#</a></h3><p>Go 语言标准库中还包含条件变量 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a>，它可以让一组的 Goroutine 都在满足特定条件时被唤醒。每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 结构体在初始化时都需要传入一个互斥锁，我们可以通过下面的例子了解它的使用方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> listen(c)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">go</span> broadcast(c)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(ch, os.Interrupt) &lt;- ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	atomic.StoreInt64(&amp;status, <span class="number">1</span>)</span><br><span class="line">	c.Broadcast()</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">	c.L.Lock()</span><br><span class="line">	<span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123;</span><br><span class="line">		c.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;listen&quot;</span>)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">$ <span class="keyword">go</span> run main.golisten</span><br><span class="line">...listen</span><br></pre></td></tr></table></figure>

<p>上述代码同时运行了 11 个 Goroutine，这 11 个 Goroutine 分别做了不同事情：</p>
<ul>
<li>10 个 Goroutine 通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Wait"><code>sync.Cond.Wait</code></a> 等待特定条件的满足；</li>
<li>1 个 Goroutine 会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 唤醒所有陷入等待的 Goroutine；</li>
</ul>
<p>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 方法后，上述代码会打印出 10 次 “listen” 并结束调用。</p>
<p><img src="/images/2020-01-23-15797104328042-golang-cond-broadcast.png" alt="golang-cond-broadcast"></p>
<p><strong>图 6-10 Cond 条件广播</strong></p>
<h4 id="结构体-3"><a href="#结构体-3" class="headerlink" title="结构体 #"></a>结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E7%BB%93%E6%9E%84%E4%BD%93-3">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 的结构体中包含以下 4 个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy  noCopy</span><br><span class="line">	L       Locker</span><br><span class="line">	notify  notifyList</span><br><span class="line">	checker copyChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>noCopy</code> — 用于保证结构体不会在编译期间拷贝；</li>
<li><code>copyChecker</code> — 用于禁止运行期间发生的拷贝；</li>
<li><code>L</code> — 用于保护内部的 <code>notify</code> 字段，<code>Locker</code> 接口类型的变量；</li>
<li><code>notify</code> — 一个 Goroutine 的链表，它是实现同步机制的核心结构；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">	wait   <span class="keyword">uint32</span></span><br><span class="line">	notify <span class="keyword">uint32</span></span><br><span class="line">	lock   mutex</span><br><span class="line">	head   *sudog</span><br><span class="line">	tail   *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.notifyList"><code>sync.notifyList</code></a> 结构体中，<code>head</code> 和 <code>tail</code> 分别指向的链表的头和尾，<code>wait</code> 和 <code>notify</code> 分别表示当前正在等待的和已经通知到的 Goroutine 的索引。</p>
<h4 id="接口-2"><a href="#接口-2" class="headerlink" title="接口 #"></a>接口 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E6%8E%A5%E5%8F%A3-2">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 对外暴露的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Wait"><code>sync.Cond.Wait</code></a> 方法会将当前 Goroutine 陷入休眠状态，它的执行过程分成以下两个步骤：</p>
<ol>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.notifyListAdd"><code>runtime.notifyListAdd</code></a> 将等待计数器加一并解锁；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.notifyListWait"><code>runtime.notifyListWait</code></a> 等待其他 Goroutine 的唤醒并加锁：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">	<span class="comment">// runtime.notifyListAdd 的链接名	c.L.Unlock()	</span></span><br><span class="line">	runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">	<span class="comment">//runtime.notifyListWait 的链接名	c.L.Lock()&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.notifyListWait"><code>runtime.notifyListWait</code></a> 会获取当前 Goroutine 并将它追加到 Goroutine 通知链表的最末端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	s := acquireSudog()</span><br><span class="line">	s.g = getg()</span><br><span class="line">	s.ticket = t</span><br><span class="line">	<span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.head = s</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		l.tail.next = s</span><br><span class="line">	&#125;</span><br><span class="line">	l.tail = s</span><br><span class="line">	goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">	releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了将当前 Goroutine 追加到链表的末端之外，我们还会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.goparkunlock"><code>runtime.goparkunlock</code></a> 将当前 Goroutine 陷入休眠，该函数也是在 Go 语言切换 Goroutine 时经常会使用的方法，它会直接让出当前处理器的使用权并等待调度器的唤醒。</p>
<p><img src="/images/2020-01-23-15797104328049-golang-cond-notifylist.png" alt="golang-cond-notifylist"></p>
<p><strong>图 6-11 Cond 条件通知列表</strong></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Signal"><code>sync.Cond.Signal</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 就是用来唤醒陷入休眠的 Goroutine 的方法，它们的实现有一些细微的差别：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Signal"><code>sync.Cond.Signal</code></a> 方法会唤醒队列最前面的 Goroutine；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 方法会唤醒队列中全部的 Goroutine；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.notifyListNotifyOne"><code>runtime.notifyListNotifyOne</code></a> 只会从 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.notifyList"><code>sync.notifyList</code></a> 链表中找到满足 <code>sudog.ticket == l.notify</code> 条件的 Goroutine 并通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.readyWithTime"><code>runtime.readyWithTime</code></a> 唤醒：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	t := l.notify</span><br><span class="line">	atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">		<span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">			n := s.next</span><br><span class="line">			<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.next = n</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l.head = n</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">				l.tail = p</span><br><span class="line">			&#125;</span><br><span class="line">			s.next = <span class="literal">nil</span></span><br><span class="line">			readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.notifyListNotifyAll"><code>runtime.notifyListNotifyAll</code></a> 会依次通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.readyWithTime"><code>runtime.readyWithTime</code></a> 唤醒链表中 Goroutine：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">	s := l.head</span><br><span class="line">	l.head = <span class="literal">nil</span></span><br><span class="line">	l.tail = <span class="literal">nil</span></span><br><span class="line">	atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line">	<span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := s.next</span><br><span class="line">		s.next = <span class="literal">nil</span></span><br><span class="line">		readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">		s = next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Goroutine 的唤醒顺序也是按照加入队列的先后顺序，先加入的会先被唤醒，而后加入的可能 Goroutine 需要等待调度器的调度。</p>
<p>在一般情况下，我们都会先调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Wait"><code>sync.Cond.Wait</code></a> 陷入休眠等待满足期望条件，当满足唤醒条件时，就可以选择使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Signal"><code>sync.Cond.Signal</code></a> 或者 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 唤醒一个或者全部的 Goroutine。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结 #"></a>小结 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%B0%8F%E7%BB%93-4">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 不是一个常用的同步机制，但是在条件长时间无法满足时，与使用 <code>for &#123;&#125;</code> 进行忙碌等待相比，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond"><code>sync.Cond</code></a> 能够让出处理器的使用权，提供 CPU 的利用率。使用时我们也需要注意以下问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Wait"><code>sync.Cond.Wait</code></a> 在调用之前一定要使用获取互斥锁，否则会触发程序崩溃；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Signal"><code>sync.Cond.Signal</code></a> 唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Cond.Broadcast"><code>sync.Cond.Broadcast</code></a> 会按照一定顺序广播通知等待的全部 Goroutine；</li>
</ul>
<h2 id="6-2-2-扩展原语"><a href="#6-2-2-扩展原语" class="headerlink" title="6.2.2 扩展原语 #"></a>6.2.2 扩展原语 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#622-%E6%89%A9%E5%B1%95%E5%8E%9F%E8%AF%AD">#</a></h2><p>除了标准库中提供的同步原语之外，Go 语言还在子仓库 <a target="_blank" rel="noopener" href="https://github.com/golang/sync">sync</a> 中提供了四种扩展原语，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group"><code>golang/sync/errgroup.Group</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted"><code>golang/sync/semaphore.Weighted</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/syncmap.Map"><code>golang/sync/syncmap.Map</code></a>，其中的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/syncmap.Map"><code>golang/sync/syncmap.Map</code></a> 在 1.9 版本中被移植到了标准库中<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#fn:2">2</a>。</p>
<p><img src="/images/2020-01-23-15797104328056-golang-extension-sync-primitives.png" alt="golang-extension-sync-primitives"></p>
<p><strong>图 6-11 Go 扩展原语</strong></p>
<p>本节会介绍 Go 语言在扩展包中提供的三种同步原语，也就是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group"><code>golang/sync/errgroup.Group</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted"><code>golang/sync/semaphore.Weighted</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a>。</p>
<h3 id="ErrGroup"><a href="#ErrGroup" class="headerlink" title="ErrGroup #"></a>ErrGroup <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#errgroup">#</a></h3><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group"><code>golang/sync/errgroup.Group</code></a> 为我们在一组 Goroutine 中提供了同步、错误传播以及上下文取消的功能，我们可以使用如下所示的方式并行获取网页的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g errgroup.Groupvar</span><br><span class="line">urls = []<span class="keyword">string</span>&#123;<span class="string">&quot;http://www.golang.org/&quot;</span>, <span class="string">&quot;http://www.google.com/&quot;</span>, <span class="string">&quot;http://www.somestupidname.com/&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> urls &#123;</span><br><span class="line">	url := urls[i]</span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		resp, err := http.Get(url)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			resp.Body.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Successfully fetched all URLs.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group.Go"><code>golang/sync/errgroup.Group.Go</code></a> 方法能够创建一个 Goroutine 并在其中执行传入的函数，而 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group.Wait"><code>golang/sync/errgroup.Group.Wait</code></a> 会等待所有 Goroutine 全部返回，该方法的不同返回结果也有不同的含义：</p>
<ul>
<li>如果返回错误 — 这一组 Goroutine 最少返回一个错误；</li>
<li>如果返回空值 — 所有 Goroutine 都成功执行；</li>
</ul>
<h4 id="结构体-4"><a href="#结构体-4" class="headerlink" title="结构体 #"></a>结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E7%BB%93%E6%9E%84%E4%BD%93-4">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group"><code>golang/sync/errgroup.Group</code></a> 结构体同时由三个比较重要的部分组成：</p>
<ol>
<li><code>cancel</code> — 创建 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 时返回的取消函数，用于在多个 Goroutine 之间同步取消信号；</li>
<li><code>wg</code> — 用于等待一组 Goroutine 完成子任务的同步原语；</li>
<li><code>errOnce</code> — 用于保证只接收一个子任务返回的错误；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancel  <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	wg      sync.WaitGroup</span><br><span class="line">	errOnce sync.Once</span><br><span class="line">	err     error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些字段共同组成了 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group"><code>golang/sync/errgroup.Group</code></a> 结构体并为我们提供同步、错误传播以及上下文取消等功能。</p>
<h4 id="接口-3"><a href="#接口-3" class="headerlink" title="接口 #"></a>接口 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E6%8E%A5%E5%8F%A3-3">#</a></h4><p>我们能通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.WithContext"><code>golang/sync/errgroup.WithContext</code></a> 构造器创建新的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group"><code>golang/sync/errgroup.Group</code></a> 结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithContext</span><span class="params">(ctx context.Context)</span> <span class="params">(*Group, context.Context)</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">return</span> &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行新的并行子任务需要使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group.Go"><code>golang/sync/errgroup.Group.Go</code></a> 方法，这个方法的执行过程如下：</p>
<ol>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Add"><code>sync.WaitGroup.Add</code></a> 增加待处理的任务；</li>
<li>创建新的 Goroutine 并运行子任务；</li>
<li>返回错误时及时调用 <code>cancel</code> 并对 <code>err</code> 赋值，只有最早返回的错误才会被上游感知到，后续的错误都会被舍弃：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Wait</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	g.wg.Wait()</span><br><span class="line">	<span class="keyword">if</span> g.cancel != <span class="literal">nil</span> &#123;</span><br><span class="line">		g.cancel()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个用于等待的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group.Wait"><code>golang/sync/errgroup.Group.Wait</code></a> 方法只是调用了 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a>，在子任务全部完成时取消 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 并返回可能出现的错误。</p>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结 #"></a>小结 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%B0%8F%E7%BB%93-5">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group"><code>golang/sync/errgroup.Group</code></a> 的实现没有涉及底层和运行时包中的 API，它只是对基本同步语义进行了封装以提供更加复杂的功能。我们在使用时也需要注意下面几个问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/errgroup.Group"><code>golang/sync/errgroup.Group</code></a> 在出现错误或者等待结束后会调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的 <code>cancel</code> 方法同步取消信号；</li>
<li>只有第一个出现的错误才会被返回，剩余的错误会被直接丢弃；</li>
</ul>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore #"></a>Semaphore <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#semaphore">#</a></h3><p>信号量是在并发编程中常见的一种同步机制，在需要控制访问资源的进程数量时就会用到信号量，它会保证持有的计数器在 0 到初始化的权重之间波动。</p>
<ul>
<li>每次获取资源时都会将信号量中的计数器减去对应的数值，在释放时重新加回来；</li>
<li>当遇到计数器大于信号量大小时，会进入休眠等待其他线程释放信号；</li>
</ul>
<p>Go 语言的扩展包中就提供了带权重的信号量 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted"><code>golang/sync/semaphore.Weighted</code></a>，我们可以按照不同的权重对资源的访问进行管理，这个结构体对外也只暴露了四个方法：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.NewWeighted"><code>golang/sync/semaphore.NewWeighted</code></a> 用于创建新的信号量；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.Acquire"><code>golang/sync/semaphore.Weighted.Acquire</code></a> 阻塞地获取指定权重的资源，如果当前没有空闲资源，会陷入休眠等待；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.TryAcquire"><code>golang/sync/semaphore.Weighted.TryAcquire</code></a> 非阻塞地获取指定权重的资源，如果当前没有空闲资源，会直接返回 <code>false</code>；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.Release"><code>golang/sync/semaphore.Weighted.Release</code></a> 用于释放指定权重的资源；</li>
</ul>
<h4 id="结构体-5"><a href="#结构体-5" class="headerlink" title="结构体 #"></a>结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E7%BB%93%E6%9E%84%E4%BD%93-5">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.NewWeighted"><code>golang/sync/semaphore.NewWeighted</code></a> 方法能根据传入的最大权重创建一个指向 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted"><code>golang/sync/semaphore.Weighted</code></a> 结构体的指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWeighted</span><span class="params">(n <span class="keyword">int64</span>)</span> *<span class="title">Weighted</span></span> &#123;</span><br><span class="line">	w := &amp;Weighted&#123;size: n&#125;</span><br><span class="line">	<span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">	size    <span class="keyword">int64</span></span><br><span class="line">	cur     <span class="keyword">int64</span></span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	waiters list.List</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted"><code>golang/sync/semaphore.Weighted</code></a> 结构体中包含一个 <code>waiters</code> 列表，其中存储着等待获取资源的 Goroutine，除此之外它还包含当前信号量的上限以及一个计数器 <code>cur</code>，这个计数器的范围就是 [0, size]：</p>
<p><img src="/images/2020-01-23-15797104328063-golang-semaphore.png" alt="golang-semaphore"></p>
<p><strong>图 6-11 权重信号量</strong></p>
<p>信号量中的计数器会随着用户对资源的访问和释放进行改变，引入的权重概念能够提供更细粒度的资源的访问控制，尽可能满足常见的用例。</p>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取 #"></a>获取 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E8%8E%B7%E5%8F%96">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.Acquire"><code>golang/sync/semaphore.Weighted.Acquire</code></a> 方法能用于获取指定权重的资源，其中包含三种不同情况：</p>
<ol>
<li>当信号量中剩余的资源大于获取的资源并且没有等待的 Goroutine 时，会直接获取信号量；</li>
<li>当需要获取的信号量大于 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted"><code>golang/sync/semaphore.Weighted</code></a> 的上限时，由于不可能满足条件会直接返回错误；</li>
<li>遇到其他情况时会将当前 Goroutine 加入到等待列表并通过 <code>select</code> 等待调度器唤醒当前 Goroutine，Goroutine 被唤醒后会获取信号量；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Acquire</span><span class="params">(ctx context.Context, n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		s.cur += n</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	w := waiter&#123;n: n, ready: ready&#125;</span><br><span class="line">	elem := s.waiters.PushBack(w)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		err := ctx.Err()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ready:</span><br><span class="line">			err = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			s.waiters.Remove(elem)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	<span class="keyword">case</span> &lt;-ready:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个用于获取信号量的方法 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.TryAcquire"><code>golang/sync/semaphore.Weighted.TryAcquire</code></a> 只会非阻塞地判断当前信号量是否有充足的资源，如果有充足的资源会直接立刻返回 <code>true</code>，否则会返回 <code>false</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">TryAcquire</span><span class="params">(n <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	success := s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> success &#123;</span><br><span class="line">		s.cur += n</span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.TryAcquire"><code>golang/sync/semaphore.Weighted.TryAcquire</code></a> 不会等待资源的释放，所以可能更适用于一些延时敏感、用户需要立刻感知结果的场景。</p>
<h4 id="释放"><a href="#释放" class="headerlink" title="释放 #"></a>释放 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E9%87%8A%E6%94%BE">#</a></h4><p>当我们要释放信号量时，<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.Release"><code>golang/sync/semaphore.Weighted.Release</code></a> 方法会从头到尾遍历 <code>waiters</code> 列表中全部的等待者，如果释放资源后的信号量有充足的剩余资源就会通过 Channel 唤起指定的 Goroutine：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Release</span><span class="params">(n <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	s.cur -= n</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		next := s.waiters.Front()</span><br><span class="line">		<span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		w := next.Value.(waiter)</span><br><span class="line">		<span class="keyword">if</span> s.size-s.cur &lt; w.n &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		s.cur += w.n</span><br><span class="line">		s.waiters.Remove(next)</span><br><span class="line">		<span class="built_in">close</span>(w.ready)</span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可能会出现剩余资源无法唤起 Goroutine 的情况，在这时当前方法在释放锁后会直接返回。</p>
<p>通过对 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.Release"><code>golang/sync/semaphore.Weighted.Release</code></a> 的分析我们能发现，如果一个信号量需要的占用的资源非常多，它可能会长时间无法获取锁，这也是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.Acquire"><code>golang/sync/semaphore.Weighted.Acquire</code></a> 引入上下文参数的原因，即为信号量的获取设置超时时间。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结 #"></a>小结 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%B0%8F%E7%BB%93-6">#</a></h4><p>带权重的信号量确实有着更多的应用场景，这也是 Go 语言对外提供的唯一一种信号量实现，在使用的过程中我们需要注意以下的几个问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.Acquire"><code>golang/sync/semaphore.Weighted.Acquire</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.TryAcquire"><code>golang/sync/semaphore.Weighted.TryAcquire</code></a> 都可以用于获取资源，前者会阻塞地获取信号量，后者会非阻塞地获取信号量；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.Release"><code>golang/sync/semaphore.Weighted.Release</code></a> 方法会按照先进先出的顺序唤醒可以被唤醒的 Goroutine；</li>
<li>如果一个 Goroutine 获取了较多地资源，由于 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/semaphore.Weighted.Release"><code>golang/sync/semaphore.Weighted.Release</code></a> 的释放策略可能会等待比较长的时间；</li>
</ul>
<h3 id="SingleFlight"><a href="#SingleFlight" class="headerlink" title="SingleFlight #"></a>SingleFlight <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#singleflight">#</a></h3><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 是 Go 语言扩展包中提供了另一种同步原语，它能够在一个服务中抑制对下游的多次重复请求。一个比较常见的使用场景是：我们在使用 Redis 对数据库中的数据进行缓存，发生缓存击穿时，大量的流量都会打到数据库上进而影响服务的尾延时。</p>
<p><img src="/images/2020-01-23-15797104328070-golang-query-without-single-flight.png" alt="golang-query-without-single-flight"></p>
<p><strong>图 6-12 Redis 缓存击穿问题</strong></p>
<p>但是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 能有效地解决这个问题，它能够限制对同一个键值对的多次重复请求，减少对下游的瞬时流量。</p>
<p><img src="/images/2020-01-23-15797104328078-golang-extension-single-flight.png" alt="golang-extension-single-flight"></p>
<p><strong>图 6-13 缓解缓存击穿问题</strong></p>
<p>在资源的获取非常昂贵时（例如：访问缓存、数据库），就很适合使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 优化服务。我们来了解一下它的使用方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">  requestGroup singleflight.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span> <span class="title">handleRequest</span><span class="params">(ctx context.Context, request Request)</span> <span class="params">(Response, error)</span></span> &#123;</span><br><span class="line">  v, err, _ := requestGroup.Do(request.Hash(), <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    rows, err := <span class="comment">// select * from tables        </span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rows, <span class="literal">nil</span>    </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Response&#123;rows: rows,&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为请求的哈希在业务上一般表示相同的请求，所以上述代码使用它作为请求的键。当然，我们也可以选择其他的字段作为 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.Do"><code>golang/sync/singleflight.Group.Do</code></a> 方法的第一个参数减少重复的请求。</p>
<h4 id="结构体-6"><a href="#结构体-6" class="headerlink" title="结构体 #"></a>结构体 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E7%BB%93%E6%9E%84%E4%BD%93-6">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 结构体由一个互斥锁 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.Mutex"><code>sync.Mutex</code></a> 和一个映射表组成，每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.call"><code>golang/sync/singleflight.call</code></a> 结构体都保存了当前调用对应的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex	m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">  wg sync.WaitGroup	</span><br><span class="line">  val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  err error	</span><br><span class="line">  dups  <span class="keyword">int</span>	</span><br><span class="line">  chans []<span class="keyword">chan</span>&lt;- Result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.call"><code>golang/sync/singleflight.call</code></a> 结构体中的 <code>val</code> 和 <code>err</code> 字段都只会在执行传入的函数时赋值一次并在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a> 返回时被读取；<code>dups</code> 和 <code>chans</code> 两个字段分别存储了抑制的请求数量以及用于同步结果的 Channel。</p>
<h4 id="接口-4"><a href="#接口-4" class="headerlink" title="接口 #"></a>接口 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E6%8E%A5%E5%8F%A3-4">#</a></h4><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 提供了两个用于抑制相同请求的方法：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.Do"><code>golang/sync/singleflight.Group.Do</code></a> — 同步等待的方法；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.DoChan"><code>golang/sync/singleflight.Group.DoChan</code></a> — 返回 Channel 异步等待的方法；</li>
</ul>
<p>这两个方法在功能上没有太多的区别，只是在接口的表现上稍有不同。</p>
<p>每次调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.Do"><code>golang/sync/singleflight.Group.Do</code></a> 方法时都会获取互斥锁，随后判断是否已经存在键对应的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.call"><code>golang/sync/singleflight.call</code></a>：</p>
<ol>
<li>当不存在对应的<code>golang/sync/singleflight.call</code>时：<ol>
<li>初始化一个新的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.call"><code>golang/sync/singleflight.call</code></a> 指针；</li>
<li>增加 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup"><code>sync.WaitGroup</code></a> 持有的计数器；</li>
<li>将 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.call"><code>golang/sync/singleflight.call</code></a> 指针添加到映射表；</li>
<li>释放持有的互斥锁；</li>
<li>阻塞地调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.doCall"><code>golang/sync/singleflight.Group.doCall</code></a> 方法等待结果的返回；</li>
</ol>
</li>
<li>当存在对应的<code>golang/sync/singleflight.call</code>时；<ol>
<li>增加 <code>dups</code> 计数器，它表示当前重复的调用次数；</li>
<li>释放持有的互斥锁；</li>
<li>通过 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a> 等待请求的返回；</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(v <span class="keyword">interface</span>&#123;&#125;, err error, shared <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">		c.dups++</span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">		c.wg.Wait()</span><br><span class="line">		<span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">new</span>(call)</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	g.m[key] = c</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line">	g.doCall(c, key, fn)</span><br><span class="line">	<span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>val</code> 和 <code>err</code> 两个字段都只会在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.doCall"><code>golang/sync/singleflight.Group.doCall</code></a> 方法中赋值，所以当 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.doCall"><code>golang/sync/singleflight.Group.doCall</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Wait"><code>sync.WaitGroup.Wait</code></a> 返回时，函数调用的结果和错误都会返回给 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.Do"><code>golang/sync/singleflight.Group.Do</code></a> 的调用者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">doCall</span><span class="params">(c *call, key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>)</span> &#123;</span><br><span class="line">	c.val, c.err = fn()</span><br><span class="line">	c.wg.Done()</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="built_in">delete</span>(g.m, key)</span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> c.chans &#123;</span><br><span class="line">		ch &lt;- Result&#123;c.val, c.err, c.dups &gt; <span class="number">0</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>运行传入的函数 <code>fn</code>，该函数的返回值会赋值给 <code>c.val</code> 和 <code>c.err</code>；</li>
<li>调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/sync.WaitGroup.Done"><code>sync.WaitGroup.Done</code></a> 方法通知所有等待结果的 Goroutine — 当前函数已经执行完成，可以从 <code>call</code> 结构体中取出返回值并返回了；</li>
<li>获取持有的互斥锁并通过管道将信息同步给使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.DoChan"><code>golang/sync/singleflight.Group.DoChan</code></a> 方法的 Goroutine；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">DoChan</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) &lt;-<span class="title">chan</span> <span class="title">Result</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">		c.dups++</span><br><span class="line">		c.chans = <span class="built_in">append</span>(c.chans, ch)</span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> ch</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;call&#123;chans: []<span class="keyword">chan</span>&lt;- Result&#123;ch&#125;&#125;</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	g.m[key] = c</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> g.doCall(c, key, fn)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.Do"><code>golang/sync/singleflight.Group.Do</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.DoChan"><code>golang/sync/singleflight.Group.DoChan</code></a> 分别提供了同步和异步的调用方式，这让我们使用起来也更加灵活。</p>
<h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结 #"></a>小结 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#%E5%B0%8F%E7%BB%93-7">#</a></h4><p>当我们需要减少对下游的相同请求时，可以使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 来增加吞吐量和服务质量，不过在使用的过程中我们也需要注意以下的几个问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.Do"><code>golang/sync/singleflight.Group.Do</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.DoChan"><code>golang/sync/singleflight.Group.DoChan</code></a> 一个用于同步阻塞调用传入的函数，一个用于异步调用传入的参数并通过 Channel 接收函数的返回值；</li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group.Forget"><code>golang/sync/singleflight.Group.Forget</code></a> 可以通知 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/golang/sync/singleflight.Group"><code>golang/sync/singleflight.Group</code></a> 在持有的映射表中删除某个键，接下来对该键的调用就不会等待前面的函数返回了；</li>
<li>一旦调用的函数返回了错误，所有在等待的 Goroutine 也都会接收到同样的错误；</li>
</ul>
<h2 id="6-2-3-小结"><a href="#6-2-3-小结" class="headerlink" title="6.2.3 小结 #"></a>6.2.3 小结 <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#623-%E5%B0%8F%E7%BB%93">#</a></h2><p>我们在这一节中介绍了 Go 语言标准库中提供的基本原语以及扩展包中的扩展原语，这些并发编程的原语能够帮助我们更好地利用 Go 语言的特性构建高吞吐量、低延时的服务、解决并发带来的问题。</p>
<p>在设计同步原语时，我们不仅要考虑 API 接口的易用、解决并发编程中可能遇到的线程竞争问题，还需要对尾延时进行、优化保证公平性，理解同步原语也是我们理解并发编程无法跨越的一个步骤。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>