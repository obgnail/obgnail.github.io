<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第12章-自动化测试&quot;&gt;&lt;a href=&quot;#第12章-自动化测试&quot; class=&quot;headerlink&quot; title=&quot;第12章 自动化测试&quot;&gt;&lt;/a&gt;第12章 自动化测试&lt;/h2&gt;&lt;p&gt;测试代码应该和程序开发同步进行，通常的工作流程是：编写一部分代码，立刻编写配套的测试，运行测试确保一切正常，继续编写新功能，编写配套测试……按照这个流程不断迭代直至程序完成。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>FlaskWeb开发实战3_进阶 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Flask/" rel="tag">Flask</a></div><div class="post-time">2021-08-29</div></div></div><div class="container post-header"><h1>FlaskWeb开发实战3_进阶</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">第12章 自动化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81"><span class="toc-number">1.2.</span> <span class="toc-text">登录验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#app-context-%E5%92%8C-test-request-context"><span class="toc-number">1.3.</span> <span class="toc-text">app.context() 和 test request_ context()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-flask-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">测试 flask 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99-Flask-%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.</span> <span class="toc-text">编写 Flask 测试命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Selenium%E8%BF%9B%E8%A1%8C%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E6%B5%8B%E8%AF%95"><span class="toc-number">1.6.</span> <span class="toc-text">使用 Selenium进行用户界面测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Coverage-py-%E8%AE%A1%E7%AE%97%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-number">1.7.</span> <span class="toc-text">使用 Coverage.py 计算测试覆盖率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">第13章 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.1.</span> <span class="toc-text">SQL慢查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Flask-Caching-%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">使用 Flask-Caching 设置缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E7%BC%93%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">存缓视图函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">缓存其他函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%98%E7%BC%93"><span class="toc-number">2.2.3.</span> <span class="toc-text">删除存缓</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Flask-Assets-%E4%BC%98%E5%8C%96%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">2.3.</span> <span class="toc-text">使用 Flask-Assets 优化静态资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E9%83%A8%E7%BD%B2%E4%B8%8A%E7%BA%BF"><span class="toc-number">3.</span> <span class="toc-text">第14章 部署上线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Git%E4%B8%8A%E4%BC%A0%E7%A9%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">3.1.</span> <span class="toc-text">Git上传空目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AF%BC%E5%85%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">手动导入环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E8%BD%AC%E5%8F%91"><span class="toc-number">3.3.</span> <span class="toc-text">HTTPS 转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Gunicorn-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">使用 Gunicorn 运行程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Supervisor%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">使用 Supervisor管理进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-Flask-%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91-%E7%BC%96%E5%86%99flask-share"><span class="toc-number">4.</span> <span class="toc-text">第15章 Flask 扩展开发(编写flask-share)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%A1%B9%E7%9B%AE%E9%AA%A8%E6%9E%B6"><span class="toc-number">4.1.</span> <span class="toc-text">扩展项目骨架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%89%A9%E5%B1%95%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">编写扩展类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-setup-py"><span class="toc-number">4.3.</span> <span class="toc-text">创建 setup.py</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-Flask%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">第16章 Flask工作原理与机制解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flask-%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%90%84%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">5.1.</span> <span class="toc-text">Flask 程序包各模块分析表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81"><span class="toc-number">5.2.</span> <span class="toc-text">如何阅读源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.</span> <span class="toc-text">显式程序对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.4.</span> <span class="toc-text">本地上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81"><span class="toc-number">5.5.</span> <span class="toc-text">三种程序状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81"><span class="toc-number">5.5.1.</span> <span class="toc-text">程序设置状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-number">5.5.2.</span> <span class="toc-text">程序运行状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-number">5.5.3.</span> <span class="toc-text">请求运行状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">5.6.</span> <span class="toc-text">自定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flask%E4%B8%8EWSGI"><span class="toc-number">5.7.</span> <span class="toc-text">Flask与WSGI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WSGI-%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.7.1.</span> <span class="toc-text">WSGI 程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WSGI-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">5.7.2.</span> <span class="toc-text">WSGI 服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flask-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%9C%BA%E5%88%B6"><span class="toc-number">5.8.</span> <span class="toc-text">Flask 的工作流程与机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.9.</span> <span class="toc-text">路由系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1"><span class="toc-number">5.9.1.</span> <span class="toc-text">注册路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D"><span class="toc-number">5.9.2.</span> <span class="toc-text">路由匹配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%B8%8A%E4%B8%8B%E6%96%87-1"><span class="toc-number">5.10.</span> <span class="toc-text">本地上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E4%B8%8ELocalProxy"><span class="toc-number">5.10.1.</span> <span class="toc-text">代理与LocalProxy</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h2 id="第12章-自动化测试"><a href="#第12章-自动化测试" class="headerlink" title="第12章 自动化测试"></a>第12章 自动化测试</h2><p>测试代码应该和程序开发同步进行，通常的工作流程是：编写一部分代码，立刻编写配套的测试，运行测试确保一切正常，继续编写新功能，编写配套测试……按照这个流程不断迭代直至程序完成。</p>
<p>自动化测试主要分为下面三种：</p>
<ul>
<li><p>单元测试（Unit Test）：对单独的代码块，比如函数进行测试。单元测试是自动化测试的主要形式，也是最基本的测试方式。</p>
</li>
<li><p>集成测试（Integration Test）：集成测试对代码单位之间的协同工作进行测试，比如测试Flask和各个 Flask扩展的集成代码。这部分的测试不容易编写，各个扩展通常会包含集成测试。在部署到云平台时，集成测试可以确保程序和云平台的各个接口正常协作。</p>
</li>
<li><p>用户界面测试（User Interface  Test）：也被称为端对端测试或全链路测试，因为需要启动服务器并调用浏览器来完成测试，所以耗时比较长，适合用来测试复杂的页面交互，比如包含  JavaScript代码和AJAX请求等实现的功能。</p>
</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line">cur_path = os.path.abspath(__file__)</span><br><span class="line">parent = os.path.dirname</span><br><span class="line">sys.path.append(parent(parent(cur_path)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> create_app</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span>():</span></span><br><span class="line">    app = create_app(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    context = app.app_context()</span><br><span class="line">    context.push()</span><br><span class="line">    <span class="keyword">yield</span> app</span><br><span class="line">    context.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="keyword">return</span> app.test_client()</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.api</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_domain_list</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 测试获取域名列表 &#x27;&#x27;&#x27;</span></span><br><span class="line">    params = &#123;<span class="string">&#x27;cloud&#x27;</span>: <span class="string">&#x27;qcloud&#x27;</span>&#125;</span><br><span class="line">    resp = client.get(<span class="string">&#x27;/domain/list&#x27;</span>, data=params)</span><br><span class="line">    data = json.loads(resp.data)</span><br><span class="line">    <span class="keyword">assert</span> resp.status_code == <span class="number">200</span></span><br><span class="line">    <span class="keyword">assert</span> data[<span class="string">&#x27;state&#x27;</span>] == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> data.get(<span class="string">&#x27;data&#x27;</span>).get(<span class="string">&#x27;domains&#x27;</span>)[<span class="number">0</span>][<span class="string">&#x27;ServerName&#x27;</span>] == <span class="string">&#x27;qcloud&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span>():</span></span><br><span class="line">    app = create_app(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    app.config[<span class="string">&#x27;TESTING&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">    context = app.app_context()</span><br><span class="line">    context.push()</span><br><span class="line">    init_db()</span><br><span class="line">    <span class="keyword">yield</span> app</span><br><span class="line">    app.config[<span class="string">&#x27;TESTING&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">    db.session.remove()</span><br><span class="line">    context.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="keyword">return</span> app.test_client()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthActions</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, client</span>):</span></span><br><span class="line">        self._client = client</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, emp_id=<span class="number">1</span>, password=<span class="string">&quot;123&quot;</span>, remember_me=<span class="literal">False</span></span>):</span></span><br><span class="line">        self._client.post(</span><br><span class="line">            <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">            data=&#123;<span class="string">&quot;emp_id&quot;</span>: emp_id, <span class="string">&quot;password&quot;</span>: password, <span class="string">&#x27;remember_me&#x27;</span>: remember_me&#125;,</span><br><span class="line">            follow_redirects=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> self._client</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logout</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._client.get(<span class="string">&quot;/logout&quot;</span>, follow_redirects=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="keyword">return</span> AuthActions(client)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth_client</span>(<span class="params">auth</span>):</span></span><br><span class="line">    <span class="keyword">return</span> auth.login()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add_page</span>(<span class="params">auth_client</span>):</span></span><br><span class="line">    rep = auth_client.get(url_for(<span class="string">&#x27;dpm.dpm_edit&#x27;</span>, dpm_id=<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">assert</span> rep.status_code == <span class="number">200</span></span><br></pre></td></tr></table></figure>



<h3 id="app-context-和-test-request-context"><a href="#app-context-和-test-request-context" class="headerlink" title="app.context() 和 test request_ context()"></a>app.context() 和 test request_ context()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> app.app_context():</span><br><span class="line">    db.create_all()</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>test_request_context()</code>方法只能构建一个全局的请求上下文环境 , 对应的URL默认为跟地址 , 你可以将自定义的路径作为第一个参数(path)传入</li>
<li>如果你想<strong>使用特定请求的request , session等请求上下文全局变量</strong> . 可以使用with语句来调用<code>test_cilent()</code> , 这回在with语句前创建一个测试用的请求上下文 , 对应当前请</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> app.test_cilent() <span class="keyword">as</span> client:</span><br><span class="line">    <span class="built_in">print</span>(client.get(<span class="string">&#x27;/hello&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(request.endpoint)</span><br><span class="line">    <span class="built_in">print</span>(request.url)</span><br></pre></td></tr></table></figure>



<h3 id="测试-flask-命令"><a href="#测试-flask-命令" class="headerlink" title="测试 flask 命令"></a>测试 flask 命令</h3><ul>
<li>对于flask命令，Flask提供了 <code>app.test_cli_runner()</code>方法用于在测试中调用命令函数、捕捉输出。</li>
<li>对程序实例app调用 <code>test_cli_runner()</code>，它会返回一个 Flask  cli_runner对象，使用它提供的 invoked方法调用命令，<ul>
<li>第一个参数为命令函数对象。返回 Result 对象，其中的 output 属性包含命令的输出内容。</li>
<li>第二个参数为 命令的参数列表</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> sayhello <span class="keyword">import</span> app, db</span><br><span class="line"><span class="keyword">from</span> sayhello.commands <span class="keyword">import</span> forge, initdb</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayHelloTestCase</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        db.create_all()</span><br><span class="line">        self.client = app.test_client()</span><br><span class="line">        self.runner = app.test_cli_runner()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>):</span></span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">    <span class="comment"># 测试 forge命令</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_forge_command</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 触发对应命令的函数</span></span><br><span class="line">        result = self.runner.invoke(forge)  </span><br><span class="line">        self.assertIn(<span class="string">&#x27;Created 20 fake messages.&#x27;</span>, result.output)</span><br><span class="line">        self.assertEqual(Message.query.count(), <span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 测试添加--count选项的 forge命令</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_forge_command_with_count</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = self.runner.invoke(forge, [<span class="string">&#x27;--count&#x27;</span>, <span class="string">&#x27;50&#x27;</span>])</span><br><span class="line">        self.assertIn(<span class="string">&#x27;Created 50 fake messages.&#x27;</span>, result.output)</span><br><span class="line">        self.assertEqual(Message.query.count(), <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>



<h3 id="编写-Flask-测试命令"><a href="#编写-Flask-测试命令" class="headerlink" title="编写 Flask 测试命令"></a>编写 Flask 测试命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unitest</span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.cli.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    test_suite = unittest.TestLoader().discover(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    unittest.TextTestRunner(verbosity=<span class="number">2</span>).run(test_suite)</span><br></pre></td></tr></table></figure>



<h3 id="使用-Selenium进行用户界面测试"><a href="#使用-Selenium进行用户界面测试" class="headerlink" title="使用 Selenium进行用户界面测试"></a>使用 Selenium进行用户界面测试</h3><ul>
<li>对于包含较多 JavaScript代码的程序，仅仅编写单元测试是不够的，我们需要能实际测试页面加载 JavaScript后的实际交互功能。</li>
<li>需要使用一种新的测试形式 : 用户界面（User Interface , UI）测试。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium --dev</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInterfaceTestCase</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        os.environ[<span class="string">&#x27;MOZ_HEADLESS&#x27;</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        self.client = webdriver.Firefox()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.client:</span><br><span class="line">            self.skipTest(<span class="string">&#x27;Web browser not available.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.client:</span><br><span class="line">            self.client.quit()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.client.get(<span class="string">&#x27;http://localhost:5000&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># navigate to login page</span></span><br><span class="line">        self.client.find_element_by_link_text(<span class="string">&#x27;Get Started&#x27;</span>).click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.client.find_element_by_name(<span class="string">&#x27;username&#x27;</span>).send_keys(<span class="string">&#x27;grey&#x27;</span>)</span><br><span class="line">        self.client.find_element_by_name(<span class="string">&#x27;password&#x27;</span>).send_keys(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">        self.client.find_element_by_id(<span class="string">&#x27;login-btn&#x27;</span>).click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_index</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.client.get(<span class="string">&#x27;http://localhost:5000&#x27;</span>)  <span class="comment"># navigate to home page</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        self.assertIn(<span class="string">&#x27;We are todoist, we use todoism.&#x27;</span>, self.client.page_source)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_login</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.login()</span><br><span class="line">        self.assertIn(<span class="string">&#x27;What needs to be done?&#x27;</span>, self.client.page_source)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_new_item</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.login()</span><br><span class="line">        all_item_count = self.client.find_element_by_id(<span class="string">&#x27;all-count&#x27;</span>)</span><br><span class="line">        before_count = <span class="built_in">int</span>(all_item_count.text)</span><br><span class="line">        item_input = self.client.find_element_by_id(<span class="string">&#x27;item-input&#x27;</span>)</span><br><span class="line">        item_input.send_keys(<span class="string">&#x27;Hello, World&#x27;</span>)</span><br><span class="line">        item_input.send_keys(Keys.RETURN)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        after_count = <span class="built_in">int</span>(all_item_count.text)</span><br><span class="line">        self.assertIn(<span class="string">&#x27;Hello, World&#x27;</span>, self.client.page_source)</span><br><span class="line">        self.assertEqual(after_count, before_count + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_delete_item</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.login()</span><br><span class="line">        all_item_count = self.client.find_element_by_id(<span class="string">&#x27;all-count&#x27;</span>)</span><br><span class="line">        before_count = <span class="built_in">int</span>(all_item_count.text)</span><br><span class="line">        item1 = self.client.find_element_by_xpath(<span class="string">&quot;//span[text()=&#x27;test item 1&#x27;]&quot;</span>)</span><br><span class="line">        hover_item1 = ActionChains(self.client).move_to_element(item1)</span><br><span class="line">        hover_item1.perform()</span><br><span class="line">        delete_button = self.client.find_element_by_class_name(<span class="string">&#x27;delete-btn&#x27;</span>)</span><br><span class="line">        delete_button.click()</span><br><span class="line">        after_count = <span class="built_in">int</span>(all_item_count.text)</span><br><span class="line">        self.assertNotIn(<span class="string">&#x27;test item 1&#x27;</span>, self.client.page_source)</span><br><span class="line">        self.assertIn(<span class="string">&#x27;test item 2&#x27;</span>, self.client.page_source)</span><br><span class="line">        self.assertEqual(after_count, before_count - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_edit_item</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.login()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            item = self.client.find_element_by_xpath(<span class="string">&quot;//span[text()=&#x27;test item 1&#x27;]&quot;</span>)</span><br><span class="line">            item_body = <span class="string">&#x27;test item 1&#x27;</span></span><br><span class="line">        <span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">            item = self.client.find_element_by_xpath(<span class="string">&quot;//span[text()=&#x27;test item 2&#x27;]&quot;</span>)</span><br><span class="line">            item_body = <span class="string">&#x27;test item 2&#x27;</span></span><br><span class="line">        hover_item = ActionChains(self.client).move_to_element(item)</span><br><span class="line">        hover_item.perform()</span><br><span class="line">        edit_button = self.client.find_element_by_class_name(<span class="string">&#x27;edit-btn&#x27;</span>)</span><br><span class="line">        edit_button.click()</span><br><span class="line">        edit_item_input = self.client.find_element_by_id(<span class="string">&#x27;edit-item-input&#x27;</span>)</span><br><span class="line">        edit_item_input.send_keys(<span class="string">&#x27; edited&#x27;</span>)</span><br><span class="line">        edit_item_input.send_keys(Keys.RETURN)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.assertIn(<span class="string">&#x27;%s edited&#x27;</span> % item_body, self.client.page_source)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_get_test_account</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.client.get(<span class="string">&#x27;http://localhost:5000&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        self.client.find_element_by_link_text(<span class="string">&#x27;Get Started&#x27;</span>).click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.client.find_element_by_id(<span class="string">&#x27;register-btn&#x27;</span>).click()</span><br><span class="line">        self.client.find_element_by_id(<span class="string">&#x27;login-btn&#x27;</span>).click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.assertIn(<span class="string">&#x27;What needs to be done?&#x27;</span>, self.client.page_source)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_change_language</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.skipTest(reason=<span class="string">&#x27;skip for materialize toast div overlay issue&#x27;</span>)</span><br><span class="line">        self.login()</span><br><span class="line">        self.assertIn(<span class="string">&#x27;What needs to be done?&#x27;</span>, self.client.page_source)</span><br><span class="line"></span><br><span class="line">        self.client.find_element_by_id(<span class="string">&#x27;locale-dropdown-btn&#x27;</span>).click()</span><br><span class="line">        <span class="comment"># ElementClickInterceptedException: Message: Element &lt;a class=&quot;lang-btn&quot;&gt; is not clickable at point</span></span><br><span class="line">        <span class="comment"># (1070.4000244140625,91.75) because another element &lt;div id=&quot;toast-container&quot;&gt; obscures it</span></span><br><span class="line">        self.client.find_element_by_link_text(<span class="string">u&#x27;简体中文&#x27;</span>).click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.assertNotIn(<span class="string">&#x27;What needs to be done?&#x27;</span>, self.client.page_source)</span><br><span class="line">        self.assertNotIn(<span class="string">u&#x27;你要做些什么？&#x27;</span>, self.client.page_source)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_toggle_item</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.skipTest(reason=<span class="string">&#x27;wait for fix&#x27;</span>)</span><br><span class="line">        self.login()</span><br><span class="line">        all_item_count = self.client.find_element_by_id(<span class="string">&#x27;all-count&#x27;</span>)</span><br><span class="line">        active_item_count = self.client.find_element_by_id(<span class="string">&#x27;active-count&#x27;</span>)</span><br><span class="line">        before_all_count = <span class="built_in">int</span>(all_item_count.text)</span><br><span class="line">        before_active_count = <span class="built_in">int</span>(active_item_count.text)</span><br><span class="line">        self.client.find_element_by_xpath(<span class="string">&quot;//a[@class=&#x27;done-btn&#x27;][1]&quot;</span>).click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        after_all_count = <span class="built_in">int</span>(all_item_count.text)</span><br><span class="line">        after_active_count = <span class="built_in">int</span>(active_item_count.text)</span><br><span class="line">        self.assertEqual(after_all_count, before_all_count - <span class="number">1</span>)</span><br><span class="line">        self.assertEqual(after_active_count, before_active_count + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_clear_item</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.login()</span><br><span class="line">        all_item_count = self.client.find_element_by_id(<span class="string">&#x27;all-count&#x27;</span>)</span><br><span class="line">        before_all_count = <span class="built_in">int</span>(all_item_count.text)</span><br><span class="line">        self.client.find_element_by_id(<span class="string">&#x27;clear-btn&#x27;</span>).click()</span><br><span class="line">        after_all_count = <span class="built_in">int</span>(all_item_count.text)</span><br><span class="line">        self.assertEqual(after_all_count, before_all_count - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h3 id="使用-Coverage-py-计算测试覆盖率"><a href="#使用-Coverage-py-计算测试覆盖率" class="headerlink" title="使用 Coverage.py 计算测试覆盖率"></a>使用 Coverage.py 计算测试覆盖率</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install coverage -- dev</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coverage run maths . py</span><br><span class="line"></span><br><span class="line">coverage run --source oa  --branch -m pytest</span><br><span class="line">coverage report</span><br><span class="line">coverage html -d htmlcov</span><br></pre></td></tr></table></figure>

<ul>
<li>传入 –source 选项指定要检查的包或模块为 oa</li>
<li>可选的-branch选项用来开启分支覆盖检查，比如，这会将 if 判断中未执行到的elif或else子句也视为未覆盖。</li>
</ul>
<h2 id="第13章-性能优化"><a href="#第13章-性能优化" class="headerlink" title="第13章 性能优化"></a>第13章 性能优化</h2><h3 id="SQL慢查询"><a href="#SQL慢查询" class="headerlink" title="SQL慢查询"></a>SQL慢查询</h3><ul>
<li>使用Fask-Debug Toolbar来调试程序，其实它还内置了一个 Profiler（性能分析器）。这个 Profiler默认是关闭的，单击工具栏中 <code>Profiler</code>选项右上方的对号按钮来激活它。</li>
<li>记录数据库慢查询的最简单的方式是使用Fask-SQLALchemy提供的 <code>get_debug _queries()</code>函数。当我们开启查询记录后，在每个请求结束时调用 get_debug_queries 函数即可获得该请求所有数据库查询的信息，包括SQL语句、参数、时长等。我们可以通过将配置变量 <code>SQLALCHEMY_RECORD_QUERIES</code>设为True来显式地开启查询记录功能</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般来说，一次合理的查询不应该超过1秒，所以我们把这个值设为1秒。</span></span><br><span class="line">BLUELOG_SLOW_QUERY_THRESHOLD = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_request_handlers</span>(<span class="params">app</span>):</span></span><br><span class="line"><span class="meta">    @app.after_request</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query_profiler</span>(<span class="params">response</span>):</span></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> get_debug_queries():</span><br><span class="line">            <span class="keyword">if</span> q.duration &gt;= app.config[<span class="string">&#x27;BLUELOG_SLOW_QUERY_THRESHOLD&#x27;</span>]:</span><br><span class="line">                app.logger.warning(</span><br><span class="line">                    <span class="string">&#x27;Slow query: Duration: %fs\n Context: %s\nQuery: %s\n &#x27;</span></span><br><span class="line">                    % (q.duration, q.context, q.statement)</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>statement : SQL语句</li>
<li>parameters : 查询参数</li>
<li>end_time : 结束时间</li>
<li>start_time : 开始时间</li>
<li>duration : 持续时间</li>
<li>context : 查询所在的位置</li>
</ul>
</blockquote>
<h3 id="使用-Flask-Caching-设置缓存"><a href="#使用-Flask-Caching-设置缓存" class="headerlink" title="使用 Flask-Caching 设置缓存"></a>使用 Flask-Caching 设置缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-caching</span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure>



<p>CACHE_TYPE的值</p>
<ul>
<li>null（默认值） : 不使用缓存</li>
<li>redis : 使用Redis</li>
<li>simple : 使用本地的 Python字典</li>
<li>uwsgi :  使用 uWSGI 内置的缓存框架</li>
<li>filesystem : 使用文件系统存储</li>
<li>memcached : 使用 Memcached</li>
</ul>
<h4 id="存缓视图函数"><a href="#存缓视图函数" class="headerlink" title="存缓视图函数"></a>存缓视图函数</h4><ul>
<li>为视图函数附加一个 cache cached装饰器即可开启缓存</li>
<li>被缓存的数据会以键值对的形式存储起来，当下次处理请求时会先查找是否存在对应键的数据，所以我们要确保被缓存的不同值的键是唯一的。当缓存视图函数返回值时，它使用当前请求的 request path值来构建缓存数据的键，即<code>view/%(reques.path)s</code>。<strong>也就是说，如果URL中包含查询字符串的话，这部分内容会被忽略掉。</strong><ul>
<li>如果想将query_string一起存缓下来的话 , 可以使用query_string=True参数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CACHE_TYPE = <span class="string">&#x27;redis&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/bar&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@cache.cached(<span class="params">timeout=<span class="number">10</span>*<span class="number">60</span>,query_string=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    args = request.args.get(<span class="string">&#x27;page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;bar.html&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="缓存其他函数"><a href="#缓存其他函数" class="headerlink" title="缓存其他函数"></a>缓存其他函数</h4><ul>
<li>和缓存视图函数相同，我们也使用 cache_cached装饰器设置缓存。</li>
<li>不同的是，你必须使用 <code>key_prefix</code> 关键字为缓存数据<strong>设置一个缓存键</strong>。</li>
<li>如果没有设置，Flask-Caching会使用当前请求的 request path的值，这有可能会覆盖视图函数的数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@cache.cached(<span class="params">key_perfix=<span class="string">&#x27;add&#x27;</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>注意 , <strong>说是说存缓函数 , 其实是存缓函数的返回值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from app import add</span><br><span class="line">&gt;&gt;&gt; add(1,1)    # 第一次调用 , 返回返回值被存缓</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt;add(2,5)     # 因为被存缓 , 所以返回值仍然是2</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt;add(5,5)     # 返回值依旧相同 , 知道存缓过期</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<ul>
<li><p>上面的方法不管参数如何 , 都只是返回同一个值 , 下面的方法就会<strong>考虑传入的参数</strong></p>
</li>
<li><p>使用 memorized装饰器。它的用法和 cached完全相同，</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@cache.memorize()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_pro</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from app import add</span><br><span class="line">&gt;&gt;&gt; add(1,1)    # 第一次调用 , 返回返回值被存缓</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt;add(2,5)     # 参数不同，再次调用函数，返回值被缓存</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt;add(2,5)     # 直接使用缓存，耗时小到忽略不计</span><br><span class="line">7</span><br></pre></td></tr></table></figure>



<h4 id="删除存缓"><a href="#删除存缓" class="headerlink" title="删除存缓"></a>删除存缓</h4><ul>
<li>删除视图存缓 : 调用 cache.delete()方法来清除缓存，传入特定的键来获取对应的缓存。视图函数缓存的键默认为<code>view/&lt;请求路径 request.path&gt;</code>，这里使用 url_for())函数构建缓存的键</li>
<li>删除其他函数存缓 : delete_memorized()方法来删除缓存 </li>
<li>cache.clear()来清除程序中的所有缓存</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/update/bar&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_bar</span>():</span></span><br><span class="line">    cache.delete_memoized(add_pro)  <span class="comment"># 删除 add_pro的存缓</span></span><br><span class="line">    cache.delete(<span class="string">&#x27;view/%s&#x27;</span> %url_for(<span class="string">&#x27;bar&#x27;</span>)) <span class="comment"># 删除视图函数的存缓</span></span><br><span class="line">    cache.clear()  <span class="comment"># 删除全部存缓</span></span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;index&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h3 id="使用-Flask-Assets-优化静态资源"><a href="#使用-Flask-Assets-优化静态资源" class="headerlink" title="使用 Flask-Assets 优化静态资源"></a>使用 Flask-Assets 优化静态资源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-assets</span><br></pre></td></tr></table></figure>

<p>功能 : 将一些文件需要被压缩并打包成单个文件</p>
<h2 id="第14章-部署上线"><a href="#第14章-部署上线" class="headerlink" title="第14章 部署上线"></a>第14章 部署上线</h2><h3 id="Git上传空目录"><a href="#Git上传空目录" class="headerlink" title="Git上传空目录"></a>Git上传空目录</h3><ul>
<li>git无法追踪一个空的文件夹，当用户需要追踪(track)一个空的文件夹的时候，按照惯例，大家会把一个称为<code>.gitkeep</code>的文件放在这些文件夹里。</li>
<li>所以 , 我们可以在目录下创建一个<code>.gitkeep</code>文件 , 写入一个<code>*.log</code>规则 , 这样就会将logs目录添加到git , 但是忽略所有以<code>.log</code>结尾的日志文件</li>
</ul>
<h3 id="手动导入环境变量"><a href="#手动导入环境变量" class="headerlink" title="手动导入环境变量"></a>手动导入环境变量</h3><ul>
<li>在开发时，因为安装了 python-dotenv，使用 flask run命令启动开发服务器时Flask会自动导入存储在<code>.flaskenv</code>或<code>.env</code>文件中的环境变量。</li>
<li>在生产环境下，我们需要使用性能更高的生产服务器，所以不能再使用这个命令启动程序，这时我们需要手动导入环境变量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line">dotenv_path = ps.path.join(ps.path.dirname(__file__),<span class="string">&#x27;.env&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(dotenv_path):</span><br><span class="line">    load_dotenv(dotenv_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bluelog <span class="keyword">import</span> create_app</span><br><span class="line">app = create_app(<span class="string">&#x27;production&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="HTTPS-转发"><a href="#HTTPS-转发" class="headerlink" title="HTTPS 转发"></a>HTTPS 转发</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-sslify</span><br></pre></td></tr></table></figure>

<p>使用超级简单</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sslify <span class="keyword">import</span> SSLify</span><br><span class="line"></span><br><span class="line">sslify = SSLify()</span><br><span class="line">sslify.init_app(app)</span><br></pre></td></tr></table></figure>

<ul>
<li>强制所有发到程序的请求通过 Https，具体的方法是<strong>拦截不安全的请求并重定向到 Https</strong>。</li>
<li>Flask-SSLify会自动为我们的程序处理请求。我们可以通过配置键 <code>SSL_DISABLED</code>来设置关闭SSL转发功能。</li>
</ul>
<h3 id="使用-Gunicorn-运行程序"><a href="#使用-Gunicorn-运行程序" class="headerlink" title="使用 Gunicorn 运行程序"></a>使用 Gunicorn 运行程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在开发时，我们使用 flask run命令启动的开发服务器是由  Werkzeug 提供的。细分的话，Werkzeug提供的这个开发服务器应该被称为 WSGI 服务器，而不是单纯意义上的Web服务器。</p>
</li>
<li><p>Gunicorn 使用下面的命令模式来运行一个WGSI程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn [options] 模块名:变量名</span><br></pre></td></tr></table></figure>

<p>eg :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --work=4 wsgi:app</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>这里的变量名即要运行的WSGI可调用对象，也就是我们<strong>使用Flask创建的程序实例</strong>，</li>
<li>而模块名即包含程序实例的模块。</li>
</ul>
</blockquote>
</li>
<li><p>使用–workers选项来定义 worker（即工作线程）的数量。通常来说，worker的数量建议为<code>（2×CPU核心数）+1</code>。</p>
</li>
</ul>
<h3 id="使用-Supervisor管理进程"><a href="#使用-Supervisor管理进程" class="headerlink" title="使用 Supervisor管理进程"></a>使用 Supervisor管理进程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y supervisor</span><br></pre></td></tr></table></figure>

<ul>
<li>我们直接通过命令来运行 Unicorn，这并不十分可靠。</li>
<li>我们需要一个工具来自动在后台运行它，同时监控它的运行状况，并在系统出错或是重启时自动重启程序</li>
</ul>
<blockquote>
<p>Supervisor是一个使用 Python编写的UNX-like系统进程管理工具，它可以<strong>管理某个项目相关的所有服务</strong>。</p>
</blockquote>
<ul>
<li><p>安装 Supervisor后，它会自动在/etc目录下生成一个包含全局配置的配置文件名为 <code>supervisor.conf</code>的配置文件（IN风格语法）来定义进程相关的命令等信息。</p>
</li>
<li><p>和 Nginx类似，我们也可以将程序相关的配置写在这里，但是为了便于管理，我们可以为程序配置创建单独的配置文件。这个全局配置默认会将<code>/etc/supervisor/conf.d</code>目录下的配置文件也包含在全局配置文件中，所以我们创建一个 bluelog.conf存储程序配置：这个文件可以放在etc/supervisor.conf路径下。我们使用nano来创建这个文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/supervisor/conf.d/bluelog.conf</span><br></pre></td></tr></table></figure></li>
<li><p>配置如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[program:bluelog]</span><br><span class="line">command=pipenv run gunicorn -v 4 wsgi:app</span><br><span class="line">directory=/home/greyli/bluelog</span><br><span class="line">user=heyingliang</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stopasgroup=true</span><br><span class="line">killasgroup=true</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">environment=LC_ALL=&#x27;en_US.UTF-8&#x27;,LANG=&#x27;en_US.UTF-8&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>通过 [program]定义一个 bluelog 程序，</li>
<li>其中用 command 定义命令，我们在命令前添加pipenv run以便在虚拟环境中执行命令；</li>
<li>directory和user则分别用来设置执行命令的工作目录和用户；</li>
<li>通过将 autostart和 autostart设为true开启自动启动和自动重启；</li>
<li>将 stopasgroup和killasgroup设为true则会确保在关闭程序时停止所有相关的子进程</li>
</ol>
</blockquote>
</li>
<li><p>启动supervisor服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service supervisor restart</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第15章-Flask-扩展开发-编写flask-share"><a href="#第15章-Flask-扩展开发-编写flask-share" class="headerlink" title="第15章 Flask 扩展开发(编写flask-share)"></a>第15章 Flask 扩展开发(编写flask-share)</h2><p>如我们将要编写的Flask-Share扩展集成了JavaScript库share.js（<a target="_blank" rel="noopener" href="https://github.com/overtrue/share.js%EF%BC%89%EF%BC%8C%E5%AE%83%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E5%B0%B1%E6%98%AF%E5%85%81%E8%AE%B8%E4%BD%A0%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%A4%BE%E4%BA%A4%E5%88%86%E4%BA%AB%EF%BC%88social">https://github.com/overtrue/share.js），它的主要作用就是允许你在模板中创建社交分享（social</a> share）组件。</p>
<p>Flask扩展通常分为两类：</p>
<ul>
<li>一类是纯功能的实现，比如提供用户认证功能的 Flask-Login；</li>
<li>另一类是对已有的库和工具的包装，比如 Flask-SQLAlchemy就包装了 SQLAlchemy。</li>
</ul>
<h3 id="扩展项目骨架"><a href="#扩展项目骨架" class="headerlink" title="扩展项目骨架"></a>扩展项目骨架</h3><p>一个扩展，在项目文件层面就是一个 Python开源项目。对于一个最小的项目来说，唯一必需的只有程序脚本和<code>setup.py</code>。</p>
<p>但是为了便于开发和协作，其他文件也是必不可少的。一般来说，扩展项目由下面这些文件组成</p>
<ul>
<li>存储扩展代码的程序包或模块（必需）</li>
<li>setup.py（必需）</li>
<li>示例程序</li>
<li>文档</li>
<li>测试脚本或包</li>
<li>README（说明文档）</li>
<li>LISCENCE（许可证文件）</li>
<li>CHANGES（版本变更记录）</li>
<li>.gitignore</li>
</ul>
<h3 id="编写扩展类"><a href="#编写扩展类" class="headerlink" title="编写扩展类"></a>编写扩展类</h3><ul>
<li><p>在创建的Flask扩展文件夹的<code>根目录</code> , 必须要有<code>__init__.py</code> 这会让 flask_share变成包</p>
</li>
<li><p>在大多数情况下，扩展需要创建一个类来实现集成机制，并通过实例化这个类获得的扩展对象来提供主要的功能接口。在编写程序时，当我们要使用某个扩展，我们通常会实例化扩展类，并传人程序实例app以进行初始化。</p>
</li>
<li><p><code>init_app()</code>函数的基本内容 : <strong>获取程序的配置，设置Jinja2环境，向模板上下文中添加变量或是注册各类处理函数。</strong></p>
<p>操作步骤如下:</p>
<ol>
<li><p>将扩展添加到 app.extensions 属性中。</p>
</li>
<li><p>把扩展类添加到模板上下文中 : 如果需要提供用于生成HTML代码的方法，为了让这个方法可以在模板中调用</p>
</li>
<li><p>添加拓展相关配置</p>
</li>
<li><p>设置加载静态资源</p>
</li>
<li><p>设置蓝本 (注意修改static_url_path)</p>
<blockquote>
<p>因为用户通过实例化 Flask类时传入static_url_path参数可以自定义静态文件路径，这里为了和用户的设置保持一致，使用 app.static_url_path属性拼接</p>
</blockquote>
</li>
</ol>
</li>
<li><p>示例 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OALogin</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, app=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> app <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.init_app(app)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_app</span>(<span class="params">self, app</span>):</span></span><br><span class="line">        <span class="comment"># 1.将扩展添加到 app.extensions 属性中</span></span><br><span class="line">        <span class="comment"># 这样就能使用current_app.extensions[&#x27;oalogin&#x27;]获取这个类 , </span></span><br><span class="line">        <span class="comment"># 不过一般是通过from XX.extensions import oalogin来获取的</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(app,<span class="string">&#x27;extensions&#x27;</span>):</span><br><span class="line">            app.extensions = &#123;&#125;</span><br><span class="line">        app.extensions[<span class="string">&#x27;oalogin&#x27;</span>] = self</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2.如果需要提供用于生成HTML代码的方法 , 把扩展类添加到模板上下文中</span></span><br><span class="line">        <span class="comment"># 这样就能通过&#123;&#123; oalogin &#125;&#125;获取这个类 , 之后就可以调用相关函数</span></span><br><span class="line">        app.jinja_env.<span class="built_in">globals</span>[<span class="string">&#x27;oalogin&#x27;</span>] = self</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3.添加拓展相关配置</span></span><br><span class="line">        app.config.setdefault(<span class="string">&quot;ZK_LOGIN_SECRET_KEY&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 设置加载静态资源</span></span><br><span class="line">        <span class="comment"># 这样模板就可以通过&#123;&#123; oalogin.load_css() &#125;&#125;获取静态文件</span></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">load_css</span>(<span class="params">css_url=<span class="literal">None</span>,js_url=<span class="literal">None</span></span>):</span></span><br><span class="line">            <span class="keyword">if</span> css_url <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                css_url = <span class="string">&#x27;http://cdn.bootcss.com/socail-share.js/1.0.16/css/share.min.css&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> js_url <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                js_url = <span class="string">&#x27;http://cdn.bootcss.com/social-share.js/1.016/js/socail-sharea.min.js&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> Markup(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            	&lt;link rel=&quot;stylesheet&quot; href=&quot;%s&quot; type=&quot;text/css&quot;&gt;\n</span></span><br><span class="line"><span class="string">            	&lt;script src=&quot;%s&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span> %(css_url,js_url))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5.设置蓝本</span></span><br><span class="line">        <span class="comment"># 注意修改static_url_path</span></span><br><span class="line">        bp = Blueprint(<span class="string">&#x27;share&#x27;</span>.__name__,static_folder=<span class="string">&#x27;static&#x27;</span>,static_url_path=<span class="string">&#x27;/share&#x27;</span>+app.static_url_path)</span><br><span class="line">        app.register_blueprint(bp)</span><br><span class="line">        </span><br><span class="line">        self.configure_loginmanager(app)</span><br><span class="line">        cache[<span class="string">&quot;redis&quot;</span>] = redis.StrictRedis.from_url(app.config[<span class="string">&quot;ZK_REDIS_CACHE_URL&quot;</span>])</span><br><span class="line">        <span class="comment"># 配置上下文</span></span><br><span class="line"><span class="meta">        @app.context_processor</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">project_name</span>():</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dict</span>(site_name=app.config[<span class="string">&#x27;SITE_NAME&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建-setup-py"><a href="#创建-setup-py" class="headerlink" title="创建 setup.py"></a>创建 setup.py</h3><ul>
<li>为了便于分发程序，我们必须对项目进行打包（packaging），这是让你的程序可以使用pipPipenv或其他工具从PyPI安装的必要步骤。</li>
<li>Python包通常使用 setuptools进行打包</li>
</ul>
<p>setup.py文件 : 这个文件定义了 Python包的元数据，比如包的版本、名称、作者信息等。更重要的是，通过<br>setup.py可以对打包安装等行为进行非常详细的配置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">        name=<span class="string">&#x27;demo&#x27;</span>,     <span class="comment"># 包名字</span></span><br><span class="line">        version=<span class="string">&#x27;1.0&#x27;</span>,   <span class="comment"># 包版本</span></span><br><span class="line">        description=<span class="string">&#x27;This is a test of the setup&#x27;</span>,   <span class="comment"># 简单描述</span></span><br><span class="line">        author=<span class="string">&#x27;huoty&#x27;</span>,  <span class="comment"># 作者</span></span><br><span class="line">        author_email=<span class="string">&#x27;sudohuoty@163.com&#x27;</span>,  <span class="comment"># 作者邮箱</span></span><br><span class="line">        url=<span class="string">&#x27;https://www.konghy.com&#x27;</span>,      <span class="comment"># 包的主页</span></span><br><span class="line">        packages=[<span class="string">&#x27;demo&#x27;</span>],                 <span class="comment"># 包</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>更多参数可见：<a target="_blank" rel="noopener" href="https://setuptools.readthedocs.io/en/latest/setuptools.html#metadata">https://setuptools.readthedocs.io/en/latest/setuptools.html</a></p>
<h2 id="第16章-Flask工作原理与机制解析"><a href="#第16章-Flask工作原理与机制解析" class="headerlink" title="第16章 Flask工作原理与机制解析"></a>第16章 Flask工作原理与机制解析</h2><h3 id="Flask-程序包各模块分析表"><a href="#Flask-程序包各模块分析表" class="headerlink" title="Flask 程序包各模块分析表"></a>Flask 程序包各模块分析表</h3><table>
<thead>
<tr>
<th align="left">模块 / 包</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">json/</td>
<td align="left">提供 JSON 支持</td>
</tr>
<tr>
<td align="left">__init__.py</td>
<td align="left">构造文件，导入了所有其他模块中开放的类和函数</td>
</tr>
<tr>
<td align="left">__main__.py</td>
<td align="left">用来启动flask命令</td>
</tr>
<tr>
<td align="left">_compat.py</td>
<td align="left">定义 Python2 与 Python3 版本兼容代码</td>
</tr>
<tr>
<td align="left">app.py</td>
<td align="left">主脚本，实现了 WSGI 程序对象，包含 Flask 类</td>
</tr>
<tr>
<td align="left">blueprint.py</td>
<td align="left">蓝本支持，包含 Blueprint 类定义</td>
</tr>
<tr>
<td align="left">cli.py</td>
<td align="left">提供命令行支持，包含内置的几个命令</td>
</tr>
<tr>
<td align="left">config.py</td>
<td align="left">实现配置相关的对象</td>
</tr>
<tr>
<td align="left">ctx.py</td>
<td align="left">实现上下文对象，比如请求上下文 RequestContext</td>
</tr>
<tr>
<td align="left">debughelpers.py</td>
<td align="left">一些辅助开发的函数 / 类</td>
</tr>
<tr>
<td align="left">globals.py</td>
<td align="left">定义全局对象，比如 request、session 等</td>
</tr>
<tr>
<td align="left">helpers.py</td>
<td align="left">包含一些常用的辅助函数，比如 flash()、url_for()</td>
</tr>
<tr>
<td align="left">logging.py</td>
<td align="left">提供日志支持</td>
</tr>
<tr>
<td align="left">sessions.py</td>
<td align="left">实现 session 功能</td>
</tr>
<tr>
<td align="left">signals.py</td>
<td align="left">实现信号支持，定义了内置的信号</td>
</tr>
<tr>
<td align="left">templating.py</td>
<td align="left">模板渲染功能</td>
</tr>
<tr>
<td align="left">testing.py</td>
<td align="left">提供用于测试的辅助函数</td>
</tr>
<tr>
<td align="left">views.py</td>
<td align="left">提供了类似 Django 中的类视图，用于编写 Web API 的 MethodView</td>
</tr>
<tr>
<td align="left">wrappers.py</td>
<td align="left">实现 WSGI 封装对象，比如代表请求和响应的 Request 对象和 Response 对象</td>
</tr>
</tbody></table>
<p>我们需要关注的是实现 Flask 核心功能的模块，比如<code>WSGI交互</code>、<code>蓝本</code>、<code>上下文</code>等。</p>
<p>API 文档 : <a target="_blank" rel="noopener" href="https://flask.palletsprojects.com/en/1.1.x/api/">https://flask.palletsprojects.com/en/1.1.x/api/</a></p>
<p>flask-origin : <a target="_blank" rel="noopener" href="https://github.com/greyli/flask-origin/blob/master/flask.py">https://github.com/greyli/flask-origin/blob/master/flask.py</a></p>
<h3 id="如何阅读源码"><a href="#如何阅读源码" class="headerlink" title="如何阅读源码"></a>如何阅读源码</h3><p>在阅读源码时，我们需要带着两个问题去读</p>
<ul>
<li>这段代码实现了什么功能？</li>
<li>它是如何实现的？</li>
</ul>
<ul>
<li><code>Request</code>的最本质作用 : 用来记住匹配的端点值（endpoint）和视图参数（view arguments）</li>
<li><code>_RequestContext</code> : 请求上下文（request context）包含所有请求相关的信息。它会在请求进入时被创建，然后被推送到_request_ctx_stack，在请求结束时会被相应的移除。它会为提供的WSGI环境创建URL适配器（adapter）和请求对象。</li>
<li><code>Flask</code> : 作为一个中心注册处，所有的视图函数、URL规则、模板配置等等都将注册到这里。</li>
</ul>
<h3 id="显式程序对象"><a href="#显式程序对象" class="headerlink" title="显式程序对象"></a>显式程序对象</h3><p>在一些 Python Web框架中，一个视图函数可能类似这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> example framework <span class="keyword">import</span> route</span><br><span class="line"><span class="meta">@route (<span class="params"> <span class="string">&#x27; / &#x27;</span> </span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span> ():</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Hello World ! &#x27;</span></span><br></pre></td></tr></table></figure>

<p>而在 Flask中，则需要这样 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>你应该看到其中的区别了，Flask中存在一个显式的程序对象，我们需要在全局空间中创建它。</p>
<p>这样设计主要有下面几个原因</p>
<ul>
<li>前一种方式（隐式程序对象）在同一时间内只能有一个实例存在，而显式的程序对象允许多个程序实例存在。</li>
<li>允许你通过子类化Flask类来改变程序行为。</li>
<li>Flask需要通过传入的包名称来定位资源（模板和静态文件）。</li>
<li><strong>允许通过工厂函数来创建程序实例</strong>，可以在不同的地方传入不同的配置来创建不同的程序实例。</li>
<li>允许通过蓝本来模块化程序。</li>
</ul>
<h3 id="本地上下文"><a href="#本地上下文" class="headerlink" title="本地上下文"></a>本地上下文</h3><ul>
<li>在多线程环境下，要想让所有视图函数都获取请求对象。最直接的方法就是在调用视图函数时将所有需要的数据作为参数传递进去，但这样一来程序逻辑就变得冗余且不易于维护。另一种方法是将这些数据设为全局变量，但是如果直接将请求对象设为全局变量，那么必然会在不同的线程中导致混乱（非线程安全）。</li>
<li>本地线程（thread  locals）的出现解决了这些问题。</li>
<li><strong>本地线程就是一个全局对象</strong>，你可以使用一种特定线程且线程安全的方式来存储和获取数据。也就是说，<strong>同一个变量在不同的线程内拥有各自的值</strong>，互不干扰。实现原理其实很简单，<strong>就是根据线程的ID来存取数据</strong>。Flask没有使用标准库的  threading.local()，而是使用了 Werkzeug自己实现的本地线程对象 werkzeug.local.Local()，后者增加了对  Greenlet的优先支持。</li>
</ul>
<ul>
<li>Flask使用本地线程来让上下文代理对象全局可访问，比如 request、session、current_app、g，这些对象被称为本地上下文对象（context locals）。因此，在不基于线程、greenlet或单进程实现的并发服务器上，这些代理对象将无法正常工作。</li>
<li>Flask的设计初衷是为了让传统Web程序的开发更加简单和迅速，而不是用来开发大型程序或异步服务器的。但是 Flask的可扩展性却提供了无限的可能性，除了使用扩展，我们还可以<strong>子类化 Flask类</strong>，或是为程序添加中间件。</li>
</ul>
<h3 id="三种程序状态"><a href="#三种程序状态" class="headerlink" title="三种程序状态"></a>三种程序状态</h3><p>Flask提供的四个<strong>本地上下文对象</strong>分别在特定的程序状态下绑定实际的对象。如果我们在访问或使用它们时还没有绑定，那么就会看到初学者经常见到的  Runtime error异常。</p>
<p>在 Flask中存在三种状态，分别是</p>
<ol>
<li>程序设置状态（application setup  state）、</li>
<li>程序运行状态（application runtime state）</li>
<li>请求运行状态（request runtime state）。</li>
</ol>
<h4 id="程序设置状态"><a href="#程序设置状态" class="headerlink" title="程序设置状态"></a>程序设置状态</h4><p>当 Flask类被实例化，也就是创建程序实例app后，就进入了程序设置状态。</p>
<p>这时所有的全局对象都没有被绑定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask , current_app , g , request , session</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(current_app , g , request , session)</span><br><span class="line"><span class="comment"># (</span></span><br><span class="line"><span class="comment"># &lt;LocalProxy unbound&gt;,</span></span><br><span class="line"><span class="comment"># &lt;LocalProxy unbound&gt;,</span></span><br><span class="line"><span class="comment"># &lt;LocalProxy unbound&gt;,</span></span><br><span class="line"><span class="comment"># &lt;LocalProxy unbound&gt;,</span></span><br><span class="line"><span class="comment"># )</span></span><br></pre></td></tr></table></figure>



<h4 id="程序运行状态"><a href="#程序运行状态" class="headerlink" title="程序运行状态"></a>程序运行状态</h4><ul>
<li>当 Flask程序启动，但是还<strong>没有请求进入时</strong>，Flask进入了程序运行状态。在这种状态下，程序上下文对象 current_app和 g 都绑定了各自的对象。</li>
<li>使用 flask shell 命令打开的 Python shell 默认就是这种状态，</li>
<li>我们也可以在普通的 Python shell中通过手动<strong>推送程序上下文</strong>来模拟</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask , current_app , g , request , session</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">ctx = app.app_context()</span><br><span class="line">ctx.push()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(current_app , g , request , session)</span><br><span class="line"><span class="comment"># (</span></span><br><span class="line"><span class="comment"># &lt;Flask &#x27;__main__&#x27;&gt;,</span></span><br><span class="line"><span class="comment"># &lt;Flask.g &#x27;__main__&#x27;&gt;,</span></span><br><span class="line"><span class="comment"># &lt;LocalProxy unbound&gt;,</span></span><br><span class="line"><span class="comment"># &lt;LocalProxy unbound&gt;,</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line">ctx.pop()</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的代码中，我们手动使用 app_context()方法创建了程序上下文，然后调用push())方法把它推送到程序上下文堆栈里。</li>
<li>当请求进入的时候，程序上下文会随着请求上下文一起被自动激活。</li>
<li>但是在没有请求进入的场景，比如离线脚本、测试，或是进行交互式调试的时候，手动推送程序上下文以进入程序运行状态会非常方便。</li>
</ul>
<h4 id="请求运行状态"><a href="#请求运行状态" class="headerlink" title="请求运行状态"></a>请求运行状态</h4><ul>
<li>当请求进入的时候，或是使用 test_request_context()方法、test_client()方法时，Flask会进人请求运行状态。</li>
<li>因为当请求上下文被推送时，程序上下文也会被自动推送，所以在这个状态下4个全局对象都会被绑定，</li>
<li>我们可以通过手动推送<strong>请求上下文</strong>模拟：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask , current_app , g , request , session</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">ctx = app.test_request_context() </span><br><span class="line">ctx.push()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(current_app , g , request , session)</span><br><span class="line"><span class="comment"># (</span></span><br><span class="line"><span class="comment"># &lt;Flask &#x27;__main__&#x27;&gt;,</span></span><br><span class="line"><span class="comment"># &lt;Flask.g &#x27;__main__&#x27;&gt;,</span></span><br><span class="line"><span class="comment"># &lt;Request &#x27;http://localhost/&#x27; [GET]&gt;,</span></span><br><span class="line"><span class="comment"># &lt;NullSession &#123;&#125;&gt;,</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line">ctx.pop()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这也是为什么你可以直接在视图函数和相应的回调函数里直接使用这些上下文对象，而不用推送上下文——Flask在处理请求时会自动帮你推送请求上下文和程序上下文。</p>
</blockquote>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>子类化Flask对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFlask</span>(<span class="params">Flask</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">app = MyFlask(__name__)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>子类化Request对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Request</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span>(<span class="params">Request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.request_class = MyRequest</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>子类化Response对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResponse</span>(<span class="params">Response</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.response_class = MyResponse</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h3 id="Flask与WSGI"><a href="#Flask与WSGI" class="headerlink" title="Flask与WSGI"></a>Flask与WSGI</h3><ul>
<li>Python Web Server Gateway Interface，它是为了让web服务器与 Python 程序能够进行数据交流而定义的一套接口标准/规范。</li>
<li>如果不统一标准，那么众多的 Python Web框架都可能仅被某些Web服务器支持；而Web服务器也没法支持所有的 Python Web框架。</li>
<li>Flask的核心扩展 Werkzeug是一个WSGI工具库。</li>
</ul>
<h4 id="WSGI-程序"><a href="#WSGI-程序" class="headerlink" title="WSGI 程序"></a>WSGI 程序</h4><p>根据WSGI的规定，Web程序（或被称为WSGI程序）必须是一个可调用对象。这个可调用对象接收两个参数</p>
<ul>
<li>environ：包含了请求的所有信息的字典。</li>
<li>start_response：需要在可调用对象中调用的函数，用来发起响应，参数是状态码、响应头部等。</li>
</ul>
<p>WSGI服务器会在调用这个可调用对象时传入这两个参数。另外，这个可调用对象还要返回个可迭代（iterable）的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个最简单的WSGI程序 : func形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">environ, start_response</span>):</span></span><br><span class="line">    status = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line">    response_headers = [(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)]</span><br><span class="line">    start_response(status , response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b&#x27;&lt;h1&gt; Hello , Web&lt;/h1&gt;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 一个最简单的WSGI程序 : class形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,environ,start_response</span>):</span></span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start = start_resopnse</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        status = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line">        response_headers = [(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)]</span><br><span class="line">        self.start(status , response_headers)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">b&#x27;&lt;h1&gt; Hello , Web&lt;/h1&gt;&#x27;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 如果想以类的实例作为WSGI程序，那么这个类必须实现__call__方法。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果想以类的实例作为WSGI程序，那么这个类必须实现<code>__call__</code>方法。</li>
<li>在 Flask中，这个可调用对象就是我们的程序实例app，我们创建app实例时调用的 Flask 类就是另一种可调用对象形式——实现了<code>__call__</code>方法的类</li>
</ul>
<h4 id="WSGI-服务器"><a href="#WSGI-服务器" class="headerlink" title="WSGI 服务器"></a>WSGI 服务器</h4><p>程序编写好了，现在我们需要一个WSGI服务器来运行它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">environ, start_response</span>):</span></span><br><span class="line">    status = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line">    response_headers = [(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)]</span><br><span class="line">    start_response(status , response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b&#x27;&lt;h1&gt; Hello , Web&lt;/h1&gt;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个本地服务器，分别传人主机地址、端口和可调用对象(WSGI程序)</span></span><br><span class="line">server = make_server(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">5000</span>,hello)</span><br><span class="line"><span class="comment"># 运行WSGI服务器</span></span><br><span class="line">server.server_forever()</span><br></pre></td></tr></table></figure>

<ul>
<li>WSGI服务器启动后，它会监听本地机的对应端口（我们设置的5000）。</li>
<li>当接收到请求时它会把请求报文解析为一个 environ 字典，然后调用WSGI程序提供的可调用对象，传递这个字典作为参数，同时传递的另一个参数是一个 start response函数。</li>
<li>所以 , Flask提供的请求对象Request其实就是对 environ字典的解析和封装。</li>
</ul>
<h3 id="Flask-的工作流程与机制"><a href="#Flask-的工作流程与机制" class="headerlink" title="Flask 的工作流程与机制"></a>Flask 的工作流程与机制</h3><ol>
<li>程序启动<ol>
<li>调用fask. cli_run_command()函数 </li>
<li>fask.cli_run_command()函数 调用run_simple() 函数</li>
<li>run_simple() 根据DEBUG模式 , 决定是否调用调试器和重载器 , 然后调用serve_forever() , 运行服务器</li>
</ol>
</li>
<li>请求 In<ol>
<li>当请求进来时 , 调用Flask类的<code>__call__</code>方法，</li>
<li><code>__call__</code>方法内部调用了Flask.wsgi_app()方法</li>
<li>Flask.wsgi_app()首先尝试从 Flask.full_dispatch_request()方法获取响应，如果出错那么就根据错误类型来生成错误响应。</li>
<li>full_dispatch_request()方法首先执行preprocess_request()方法对请求进行预处理(指向所有实用brefore_request钩子注册的函数) , 接着调用dispatch_request()方法匹配并调用对应的视图函数，获取其返回值 , 最后使用finalize_request()方法生成响应</li>
</ol>
</li>
<li>响应 Out<ol>
<li>finalize_request()方法调用make_response()方法 , 接着执行process_response()方法会响应进行预处理</li>
<li>返回response结果回Flask.wsgi_app()方法</li>
</ol>
</li>
</ol>
<h3 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h3><h4 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h4><p>路由表 Map</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = Map()</span><br><span class="line">rule1 = Rule(<span class="string">&#x27;/&#x27;</span>,endpoint=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">m.add(rule1)</span><br></pre></td></tr></table></figure>

<p>route函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span>(<span class="params">self, rule, **options</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;route函数简化版 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">f</span>):</span></span><br><span class="line">        self.add_url_rule(rule, f.__name__, **options)  <span class="comment"># add_url_rule()背后调用url_map.add(rule)</span></span><br><span class="line">        <span class="comment"># 将端点（默认使用函数名，即f.__name__）和函数对象的映射存储到view_functions字典</span></span><br><span class="line">        self.view_functions[f.__name__] = f  </span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>

<ol>
<li>url_map 是 Werkzeug的Map类实例（werkzeug.routing.Map）。它存储了URL规则和相关配置，这里的rule是  Werkzeug提供的Rule实例（werkzeug.routing.Rule），其中保存了端点和URL规则的映射关系。</li>
<li>view function则是 Flask类中定义的一个<strong>字典</strong>，它存储了端点和视图函数的映射关系。</li>
</ol>
<h4 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m = Map()</span><br><span class="line">rule1 = Rule(<span class="string">&#x27;/&#x27;</span>,endpoint=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">m.add(rule1)</span><br><span class="line"></span><br><span class="line">urls = m.bind(<span class="string">&#x27;example.com&#x27;</span>)</span><br><span class="line">res1 = urls.match(<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line">res2 = urls.match(<span class="string">&#x27;/downloads/42&#x27;</span>,<span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res1)  <span class="comment"># (&#x27;index&#x27;,&#123;&#125;)</span></span><br><span class="line"><span class="built_in">print</span>(res2)  <span class="comment"># (&#x27;/downloads/show&#x27;,&#123;&#x27;id&#x27;:42&#125;)</span></span><br></pre></td></tr></table></figure>

<p>Map.bind() 方法和 Map.bind_to_environ()都会返回一个 Map Adapter对象 , 它负责匹配和构建URL.</p>
<p>MapAdapter类的 match方法用来判断传入的URL是否匹配Map对象中存储的路由规则(存储在 self.map.rules列表中).匹配成功后会返回一个包含URL端点和URL变量的元组.</p>
<h3 id="本地上下文-1"><a href="#本地上下文-1" class="headerlink" title="本地上下文"></a>本地上下文</h3><ul>
<li>本地线程（Thread Local）: 在保存数据的同时记录下对应的线程ID，获取数据时根据所在线程的ID即可获取到对应的数据。就像是超市里的存包柜，每个柜子都有一个号码，每个号码对应一份物品。</li>
<li>本地线程自建了一个<code>__storege__</code>属性用于存放数据 , 其数据结构为<code>&#123;线程ID : &#123;名称 : 实际数据&#125;&#125;</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalProxy</span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个错误信息</span></span><br><span class="line">_request_ctx_err_msg = <span class="string">&quot;&quot;&quot;Working outside of request context.&quot;&quot;&quot;</span></span><br><span class="line">_app_ctx_err_msg = <span class="string">&quot;&quot;&quot;Working outside of application context.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找请求上下文对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_req_object</span>(<span class="params">name</span>):</span></span><br><span class="line">    top = _request_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_request_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getattr</span>(top, name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找程序上下文对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_app_object</span>(<span class="params">name</span>):</span></span><br><span class="line">    top = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getattr</span>(top, name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找程序实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_app</span>():</span></span><br><span class="line">    top = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> top.app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个堆栈</span></span><br><span class="line">_request_ctx_stack = LocalStack()  <span class="comment"># 请求上下文堆栈</span></span><br><span class="line">_app_ctx_stack = LocalStack()  <span class="comment"># 程序上下文堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4个全局上下文代理对象</span></span><br><span class="line">current_app = LocalProxy(_find_app)</span><br><span class="line">request = LocalProxy(partial(_lookup_req_object, <span class="string">&quot;request&quot;</span>))</span><br><span class="line">session = LocalProxy(partial(_lookup_req_object, <span class="string">&quot;session&quot;</span>))</span><br><span class="line">g = LocalProxy(partial(_lookup_app_object, <span class="string">&quot;g&quot;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>简单来说，Localstack是基于 Local实现的栈结构（本地堆栈，即实现了本地线程的堆栈），有 push、pop0方法以及获取栈顶的top属性。</li>
<li>在构造函数中创建了  Local()类的实例 local。它把数据存储到 Local中，并将数据的<strong>字典</strong>名称设为<code>&#39;stack&#39;</code>。</li>
<li>注意这里和 Local类一样也定义了call方法，当 Localstack实例被直接调用时，会返回栈顶对象的代理，即  LocalProxy类实例</li>
</ul>
<h4 id="代理与LocalProxy"><a href="#代理与LocalProxy" class="headerlink" title="代理与LocalProxy"></a>代理与LocalProxy</h4><ul>
<li>代理（Proxy）是一种设计模式，</li>
<li>通过创建一个代理对象 , 我们可以使用这个代理对象来操作实际对象。</li>
<li>从字面理解，代理就是使用一个中间人来转发操作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self , obj</span>):</span></span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self , <span class="string">&#x27;_obj&#x27;</span> , obj)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self , name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self._obj , name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">        self._obj[name] = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self._obj[name]</span><br></pre></td></tr></table></figure>

<p>为什么 Flask需要使用代理？</p>
<ul>
<li>总体来说，在这里使用代理对象是因为这些代理可以在线程间共享，让我们可以以动态的方式获取被代理的实际对象。</li>
<li>具体来说，Flask的三种状态中，当上下文没被推送时，响应的全局代理对象处于未绑定状态。而如果这里不使用代理，那么在导入这些全局对象时就会尝试获取上下文，然而这时堆栈是空的，所以获取到的全局对象只能是None。当请求进入并调用视图函数时，虽然这时堆栈里已经推入了上下文，但这里导入的全局对象仍然是None。总而言之，上下文的推送和移除是动态进行的，而使用代理可以让我们拥有动态获取上下文对象的能力。</li>
<li>另外，一个动态的全局对象，也让多个程序实例并存有了可能。这样在不同的程序上下文环境中，current_app总是能对应正确的程序实例。</li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>