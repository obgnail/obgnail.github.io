<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26097310&quot;&gt;https://zhuanlan.zhihu.com/p/26097310&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>flask的上下文 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Flask/" rel="tag">Flask</a></div><div class="post-time">2021-08-29</div></div></div><div class="container post-header"><h1>flask的上下文</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">请求上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%9B%AE%E7%9A%84"><span class="toc-number">1.1.</span> <span class="toc-text">使用目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalStack"><span class="toc-number">1.2.</span> <span class="toc-text">LocalStack</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87-1"><span class="toc-number">2.</span> <span class="toc-text">请求上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%870-1%E7%89%88%E6%9C%AC"><span class="toc-number">2.1.</span> <span class="toc-text">请求上下文0.1版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%870-9%E7%89%88%E6%9C%AC"><span class="toc-number">2.2.</span> <span class="toc-text">请求上下文0.9版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.</span> <span class="toc-text">应用上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%85%B3%E7%9A%84%E2%80%9C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E2%80%9D"><span class="toc-number">4.</span> <span class="toc-text">与上下文对象有关的“全局变量”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#test-request-context-%E5%92%8C-app-context"><span class="toc-number">5.</span> <span class="toc-text">test_request_context() 和 app_context()</span></a></li></ol></details></div><div class="container post-content"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26097310">https://zhuanlan.zhihu.com/p/26097310</a></p>
<h2 id="请求上下文"><a href="#请求上下文" class="headerlink" title="请求上下文"></a>请求上下文</h2><h3 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h3><ul>
<li><p>在Flask中处理请求时，应用会生成一个“请求上下文”对象。</p>
</li>
<li><p>整个请求的处理过程，都会在这个上下文对象中进行。这<strong>保证了请求的处理过程不被干扰</strong>。</p>
</li>
<li><p>处理请求的具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span>(<span class="params">self, environ, start_response</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self.request_context(environ):</span><br><span class="line">        <span class="comment"># with语句中完成请求处理 , 生成一个`response`对象</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="LocalStack"><a href="#LocalStack" class="headerlink" title="LocalStack"></a>LocalStack</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个`LocalStack`对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>local_stack = LocalStack()</span><br><span class="line"><span class="comment"># 查看local_stack中存储的信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>local_stack._local.__storage__</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，这个函数可以向`LocalStack`中添加数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">i</span>):</span></span><br><span class="line">        local_stack.push(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用3个线程运行函数`worker`</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=worker, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看local_stack中存储的信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>local_stack._local.__storage__</span><br><span class="line">&#123;&lt;greenlet.greenlet at <span class="number">0x4bee5a0</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [<span class="number">2</span>]&#125;,</span><br><span class="line"> &lt;greenlet.greenlet at <span class="number">0x4bee638</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [<span class="number">1</span>]&#125;,</span><br><span class="line"> &lt;greenlet.greenlet at <span class="number">0x4bee6d0</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [<span class="number">0</span>]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>存储在LocalStack中的信息以字典的形式存在：键为线程/协程的标识数值，值也是字典形式。每当有一个线程/协程上要将一个对象push进LocalStack栈中，会形成如上一个“键-值”对。</li>
<li>这样的一种结构很好地实现了线程/协程的隔离，每个线程/协程都会根据自己线程/协程的标识数值确定存储在栈结构中的值。</li>
<li>LocalStack还实现了push、pop、top等方法。其中top方法永远指向栈顶的元素。栈顶的元素是指当前线程/协程中最后被推入栈中的元素，即<code>local_stack._local.stack[-1]</code>(注意，是stack键对应的对象中最后被推入的元素)。</li>
</ul>
<h2 id="请求上下文-1"><a href="#请求上下文-1" class="headerlink" title="请求上下文"></a>请求上下文</h2><h3 id="请求上下文0-1版本"><a href="#请求上下文0-1版本" class="headerlink" title="请求上下文0.1版本"></a>请求上下文0.1版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RequestContext</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;请求上下文（request context）包含所有请求相关的信息。它会在请求进入时被创建，</span></span><br><span class="line"><span class="string">    然后被推送到_request_ctx_stack，在请求结束时会被相应的移除。它会为提供的</span></span><br><span class="line"><span class="string">    WSGI环境创建URL适配器（adapter）和请求对象。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 会在flask.Flask.request_context和flask.Flask.test_requset_context方法中</span></span><br><span class="line">    <span class="comment"># 调用，以便生成请求上下文。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, app, environ</span>):</span></span><br><span class="line">        self.app = app</span><br><span class="line">        self.url_adapter = app.url_map.bind_to_environ(environ)  <span class="comment"># 绑定了当前环境信息，用于构建URL，在url_for函数中使用</span></span><br><span class="line">        self.request = app.request_class(environ)  <span class="comment"># 创建请求对象，包含请求信息</span></span><br><span class="line">        self.session = app.open_session(self.request)  <span class="comment"># 创建session对象，用于存储用户会话数据到cookie中</span></span><br><span class="line">        self.g = _RequestGlobals()  <span class="comment"># 创建g对象，用于在当前请求存储全局变量</span></span><br><span class="line">        self.flashes = <span class="literal">None</span>  <span class="comment"># 存储当前请求的通过flash函数发送的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        _request_ctx_stack.push(self)  <span class="comment"># 将当前请求上下文对象推送到_request_ctx_stack堆栈，这个堆栈在最后定义</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_value, tb</span>):</span></span><br><span class="line">        <span class="comment"># 在调试模式（debug mode）而且有异常发生时，不要移除（pop）请求堆栈。</span></span><br><span class="line">        <span class="comment"># 这将允许调试器（debugger）在交互式shell中仍然可以获取请求对象。</span></span><br><span class="line">        <span class="keyword">if</span> tb <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> self.app.debug:</span><br><span class="line">            _request_ctx_stack.pop()</span><br><span class="line">            </span><br><span class="line">_request_ctx_stack = LocalStack()</span><br></pre></td></tr></table></figure>

<ul>
<li>“请求上下文”是一个上下文对象，实现了<code>__enter__</code>和<code>__exit__</code>方法。可以使用with语句构造一个上下文环境。</li>
<li>进入上下文环境时，<code>_request_ctx_stack</code>这个栈中会推入一个<code>_RequestContext</code>对象。这个栈结构就是上面讲的LocalStack栈。</li>
<li>推入栈中的_RequestContext对象有一些属性，包含了请求的的所有相关信息。例如app、request、session、g、flashes。还有一个url_adapter，这个对象可以进行URL匹配。</li>
<li>在with语句构造的上下文环境中可以进行请求处理。当退出上下文环境时，_request_ctx_stack这个栈会销毁刚才存储的上下文对象。</li>
</ul>
<blockquote>
<p>以上的运行逻辑使得请求的处理始终在一个上下文环境中，这保证了请求处理过程不被干扰，而且请求上下文对象保存在LocalStack栈中，也很好地实现了线程/协程的隔离。</p>
</blockquote>
<p>![Untitled Diagram](/images/Untitled Diagram.jpg)</p>
<p>以下是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, _request_ctx_stack</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> threading</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>app = Flask(__name__)</span><br><span class="line"><span class="comment"># 先观察_request_ctx_stack中包含的信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_request_ctx_stack._local.__storage__</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个函数，用于向栈中推入请求上下文</span></span><br><span class="line"><span class="comment"># 本例中不使用`with`语句</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">        <span class="comment"># 使用应用的test_request_context()方法创建请求上下文</span></span><br><span class="line">        request_context = app.test_request_context()</span><br><span class="line">        _request_ctx_stack.push(request_context)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建3个进程分别执行worker方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=worker)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再观察_request_ctx_stack中包含的信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_request_ctx_stack._local.__storage__</span><br><span class="line">&#123;&lt;greenlet.greenlet at <span class="number">0x5e45df0</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [&lt;flask._RequestContext at <span class="number">0x710c668</span>&gt;]&#125;,</span><br><span class="line"> &lt;greenlet.greenlet at <span class="number">0x5e45e88</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [&lt;flask._RequestContext at <span class="number">0x7107f28</span>&gt;]&#125;,</span><br><span class="line"> &lt;greenlet.greenlet at <span class="number">0x5e45f20</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [&lt;flask._RequestContext at <span class="number">0x71077f0</span>&gt;]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_request_ctx_stack</code>中为每一个线程创建了一个“键-值”对，</li>
<li>每一“键-值”对中包含一个请求上下文对象。</li>
<li>如果使用with语句，在离开上下文环境时栈中销毁存储的上下文对象信息。</li>
</ul>
<h3 id="请求上下文0-9版本"><a href="#请求上下文0-9版本" class="headerlink" title="请求上下文0.9版本"></a>请求上下文0.9版本</h3><ul>
<li>在0.9版本中，Flask引入了“应用上下文”的概念，这对“请求上下文”的实现有一定的改变。</li>
<li>这个版本的“请求上下文”也是一个上下文对象。在使用with语句进入上下文环境后，<code>_request_ctx_stack</code>会存储这个上下文对象。不过与0.1版本相比，有以下几点改变：<ul>
<li>请求上下文实现了push、pop方法，这使得对于请求上下文的操作更加的灵活；</li>
<li>伴随着请求上下文对象的生成并存储在栈结构中，Flask还会生成一个“应用上下文”对象，而且“应用上下文”对象也会存储在另一个栈结构中去。这是两个版本最大的不同。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Flask v0.9</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将请求上下文绑定到当前上下文。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># top:最顶层的请求上下文对象</span></span><br><span class="line">    top = _request_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> top.preserved:</span><br><span class="line">        top.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在推送请求上下文之前，我们必须确保存在应用程序上下文。</span></span><br><span class="line">    app_ctx = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> app_ctx <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> app_ctx.app != self.app:</span><br><span class="line">        app_ctx = self.app.app_context()</span><br><span class="line">        app_ctx.push()</span><br><span class="line">        self._implicit_app_ctx_stack.append(app_ctx)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._implicit_app_ctx_stack.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    _request_ctx_stack.push(self)</span><br><span class="line">    self.session = self.app.open_session(self.request)</span><br><span class="line">    <span class="keyword">if</span> self.session <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.session = self.app.make_null_session()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self, exc=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;弹出请求上下文并通过此操作解除绑定。这还将触发执行由：</span></span><br><span class="line"><span class="string">    meth:`~flask.flask.teardown_request`装饰器注册的函数。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    app_ctx = self._implicit_app_ctx_stack.pop()</span><br><span class="line"></span><br><span class="line">    clear_request = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._implicit_app_ctx_stack:</span><br><span class="line">        self.preserved = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> exc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            exc = sys.exc_info()[<span class="number">1</span>]</span><br><span class="line">        self.app.do_teardown_request(exc)</span><br><span class="line">        clear_request = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    rv = _request_ctx_stack.pop()</span><br><span class="line">    <span class="keyword">assert</span> rv <span class="keyword">is</span> self, <span class="string">&#x27;Popped wrong request context.  (%r instead of %r)&#x27;</span> \</span><br><span class="line">        % (rv, self)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在请求结束时去掉循环依赖项，这样我们就不需要GC处于活动状态。</span></span><br><span class="line">    <span class="keyword">if</span> clear_request:</span><br><span class="line">        rv.request.environ[<span class="string">&#x27;werkzeug.request&#x27;</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果有必要的话，也把应用程序扔掉。</span></span><br><span class="line">    <span class="keyword">if</span> app_ctx <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        app_ctx.pop(exc)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>push()</code> : 当要将一个“请求上下文”推入<code>_request_ctx_stack</code>栈中的时候，会先检查另一个栈<code>_app_ctx_stack</code>的栈顶是否存在“应用上下文”对象或者栈顶的“应用上下文”对象的应用是否是当前应用。如果不存在或者不是当前对象，Flask会自动先生成一个“应用上下文”对象，并将其推入_app_ctx_stack中。</li>
<li><code>pop()</code> : 到当要离开“请求上下文”环境的时候，Flask会先将“请求上下文”对象从<code>_request_ctx_stack</code>栈中销毁，之后会根据实际的情况确定销毁“应用上下文”对象。</li>
</ul>
<p>例子说明 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, _request_ctx_stack, _app_ctx_stack</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先检查两个栈的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_request_ctx_stack._local.__storage__</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_app_ctx_stack._local.__storage__</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个请求上下文对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>request_context = app.test_request_context()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>request_context.push()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求上下文推入栈后，再次查看两个栈的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_request_ctx_stack._local.__storage__</span><br><span class="line">&#123;&lt;greenlet.greenlet at <span class="number">0x6eb32a8</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [http://localhost/<span class="string">&#x27; [GET] of __main__&gt;]&#125;&#125;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; _app_ctx_stack._local.__storage__</span></span><br><span class="line"><span class="string">&#123;&lt;greenlet.greenlet at 0x6eb32a8&gt;: &#123;&#x27;</span>stack<span class="string">&#x27;: [&lt;flask.ctx.AppContext at 0x5c96a58&gt;]&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; request_context.pop()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 销毁请求上下文时，再次查看两个栈的内容</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; _request_ctx_stack._local.__storage__</span></span><br><span class="line"><span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; _app_ctx_stack._local.__storage__</span></span><br><span class="line"><span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="应用上下文"><a href="#应用上下文" class="headerlink" title="应用上下文"></a>应用上下文</h2><p>上部分中简单介绍了“应用上下文”和“请求上下文”的关系。那什么是“应用上下文”呢？我们先看一下它的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppContext</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    应用上下文将应用对象隐式绑定到当前线程或greenlet，</span></span><br><span class="line"><span class="string">    其做法类似于`request context`类绑定请求信息的方式。</span></span><br><span class="line"><span class="string">    如果创建了请求上下文，但应用程序不在单个应用程序上下文的顶部，</span></span><br><span class="line"><span class="string">    则也会隐式创建应用程序上下文。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, app</span>):</span></span><br><span class="line">        self.app = app</span><br><span class="line">        self.url_adapter = app.create_url_adapter(<span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 与请求上下文一样，应用上下文可以被多次推送，</span></span><br><span class="line">        <span class="comment"># 但有一个基本的“refcount”(引用计数)跟踪它们。</span></span><br><span class="line">        self._refcnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将应用程序上下文绑定到当前上下文。&quot;&quot;&quot;</span></span><br><span class="line">        self._refcnt += <span class="number">1</span></span><br><span class="line">        _app_ctx_stack.push(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self, exc=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;弹出应用程序上下文&quot;&quot;&quot;</span></span><br><span class="line">        self._refcnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._refcnt &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> exc <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                exc = sys.exc_info()[<span class="number">1</span>]</span><br><span class="line">            self.app.do_teardown_appcontext(exc)</span><br><span class="line">        rv = _app_ctx_stack.pop()</span><br><span class="line">        <span class="keyword">assert</span> rv <span class="keyword">is</span> self, <span class="string">&#x27;Popped wrong app context.  (%r instead of %r)&#x27;</span> % (rv, self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.push()</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_value, tb</span>):</span></span><br><span class="line">        self.pop(exc_value)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>应用上下文</code>也是一个上下文对象，可以使用with语句构造一个上下文环境，它也实现了push、pop等方法。</li>
<li>“应用上下文”的构造函数也和“请求上下文”类似，都有app、url_adapter等属性。</li>
<li>“应用上下文”存在的一个主要功能就是<strong>确定请求所在的应用</strong>。</li>
</ul>
<blockquote>
<p>既然“请求上下文”中也包含app等和当前应用相关的信息，那么只要调用<code>_request_ctx_stack.top.app</code>或者魔法current_app就可以确定请求所在的应用了，那为什么还需要“应用上下文”对象呢？</p>
<ul>
<li>对于单应用单请求来说，使用“请求上下文”确实就可以了。</li>
<li>然而，Flask的设计理念之一就是多应用的支持。当在一个应用的请求上下文环境中，需要嵌套处理另一个应用的相关操作时，“请求上下文”显然就不能很好地解决问题了。</li>
<li>如何让请求找到“正确”的应用呢？我们可能会想到，可以再增加一个请求上下文环境，并将其推入<code>_request_ctx_stack</code>栈中。由于两个上下文环境的运行是独立的，不会相互干扰，所以通过调用<code>_request_ctx_stack.top.app</code>或者魔法current_app也可以获得当前上下文环境正在处理哪个应用。这种办法在一定程度上可行，但是如果对于第二个应用的处理不涉及到相关请求，那也就无从谈起“请求上下文”。</li>
<li>为了应对这个问题，Flask中将应用相关的信息单独拿出来，形成一个“应用上下文”对象。</li>
<li><strong>这个对象可以和“请求上下文”一起使用，也可以单独拿出来使用</strong>。</li>
<li>不过有一点需要注意的是：在创建“请求上下文”时一定要创建一个“应用上下文”对象。有了“应用上下文”对象，便可以很容易地确定当前处理哪个应用，这就是魔法current_app。</li>
<li>在0.1版本中，current_app是对<code>_request_ctx_stack.top.app</code>的引用，而在0.9版本中current_app是对<code>_app_ctx_stack.top.app</code>的引用。</li>
</ul>
</blockquote>
<p>下面以一个多应用的例子进行说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example - Flask v0.9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, _request_ctx_stack, _app_ctx_stack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个Flask应用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>app = Flask(__name__)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>app2 = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先查看两个栈中的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_request_ctx_stack._local.__storage__</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_app_ctx_stack._local.__storage__</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建一个app的请求上下文环境，</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> app.test_request_context():</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Enter app&#x27;s Request Context:&quot;</span></span><br><span class="line">        <span class="built_in">print</span> _request_ctx_stack._local.__storage__</span><br><span class="line">        <span class="built_in">print</span> _app_ctx_stack._local.__storage__</span><br><span class="line">        <span class="built_in">print</span></span><br><span class="line">        <span class="comment"># 在这个环境中运行app2的相关操作</span></span><br><span class="line">        <span class="keyword">with</span> app2.app_context():</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Enter app2&#x27;s App Context:&quot;</span></span><br><span class="line">            <span class="built_in">print</span> _request_ctx_stack._local.__storage__</span><br><span class="line">            <span class="built_in">print</span> _app_ctx_stack._local.__storage__</span><br><span class="line">            <span class="built_in">print</span></span><br><span class="line">            <span class="comment"># do something</span></span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Exit app2&#x27;s App Context:&quot;</span></span><br><span class="line">        <span class="built_in">print</span> _request_ctx_stack._local.__storage__</span><br><span class="line">        <span class="built_in">print</span> _app_ctx_stack._local.__storage__</span><br><span class="line">        <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Result</span></span><br><span class="line">Enter app<span class="string">&#x27;s Request Context:</span></span><br><span class="line"><span class="string">&#123;&lt;greenlet.greenlet object at 0x000000000727A178&gt;: &#123;&#x27;</span>stack<span class="string">&#x27;: [http://localhost/&#x27;</span> [GET] of __main__&gt;]&#125;&#125;</span><br><span class="line">&#123;&lt;greenlet.greenlet <span class="built_in">object</span> at <span class="number">0x000000000727A178</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [&lt;flask.ctx.AppContext <span class="built_in">object</span> at <span class="number">0x0000000005DD0DD8</span>&gt;]&#125;&#125;</span><br><span class="line"></span><br><span class="line">Enter app2<span class="string">&#x27;s App Context:</span></span><br><span class="line"><span class="string">&#123;&lt;greenlet.greenlet object at 0x000000000727A178&gt;: &#123;&#x27;</span>stack<span class="string">&#x27;: [http://localhost/&#x27;</span> [GET] of __main__&gt;]&#125;&#125;</span><br><span class="line">&#123;&lt;greenlet.greenlet <span class="built_in">object</span> at <span class="number">0x000000000727A178</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [&lt;flask.ctx.AppContext <span class="built_in">object</span> at <span class="number">0x0000000005DD0DD8</span>&gt;, &lt;flask.ctx.AppContext <span class="built_in">object</span> at <span class="number">0x0000000007313198</span>&gt;]&#125;&#125;</span><br><span class="line"></span><br><span class="line">Exit app2<span class="string">&#x27;s App Context</span></span><br><span class="line"><span class="string">&#123;&lt;greenlet.greenlet object at 0x000000000727A178&gt;: &#123;&#x27;</span>stack<span class="string">&#x27;: [http://localhost/&#x27;</span> [GET] of __main__&gt;]&#125;&#125;</span><br><span class="line">&#123;&lt;greenlet.greenlet <span class="built_in">object</span> at <span class="number">0x000000000727A178</span>&gt;: &#123;<span class="string">&#x27;stack&#x27;</span>: [&lt;flask.ctx.AppContext <span class="built_in">object</span> at <span class="number">0x0000000005DD0DD8</span>&gt;]&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先创建了两个Flask应用app和app2；</li>
<li>接着我们构建了一个app的请求上下文环境。当进入这个环境中时，这时查看两个栈的内容，发现两个栈中已经有了当前请求的请求上下文对象和应用上下文对象。并且栈顶的元素都是app的请求上下文和应用上下文；</li>
<li>之后，我们再在这个环境中嵌套app2的应用上下文。当进入app2的应用上下文环境时，两个上下文环境便隔离开来，此时再查看两个栈的内容，发现_app_ctx_stack中推入了app2的应用上下文对象，并且栈顶指向它。这时在app2的应用上下文环境中，current_app便会一直指向app2；</li>
<li>当离开app2的应用上下文环境，_app_ctx_stack栈便会销毁app2的应用上下文对象。这时查看两个栈的内容，发现两个栈中只有app的请求的请求上下文对象和应用上下文对象。</li>
<li>最后，离开app的请求上下文环境后，两个栈便会销毁app的请求的请求上下文对象和应用上下文对象，栈为空。</li>
</ul>
<h2 id="与上下文对象有关的“全局变量”"><a href="#与上下文对象有关的“全局变量”" class="headerlink" title="与上下文对象有关的“全局变量”"></a>与上下文对象有关的“全局变量”</h2><p>在Flask中，为了更加方便地处理一些变量，特地提出了“全局变量”的概念。这些全局变量有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Flask v0.9</span></span><br><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line">_app_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(_find_app)</span><br><span class="line">request = LocalProxy(partial(_lookup_object, <span class="string">&#x27;request&#x27;</span>))</span><br><span class="line">session = LocalProxy(partial(_lookup_object, <span class="string">&#x27;session&#x27;</span>))</span><br><span class="line">g = LocalProxy(partial(_lookup_object, <span class="string">&#x27;g&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_object</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从请求栈栈顶的请求上下文对象获取name&quot;&quot;&quot;</span></span><br><span class="line">    top = _request_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;working outside of request context&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getattr</span>(top, name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_app</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;当初应用栈栈顶的应用上下文对象&quot;&quot;&quot;</span></span><br><span class="line">    top = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;working outside of application context&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> top.app</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以看出，Flask中使用的一些“全局变量”，包括current_app、request、session、g等<strong>都来自于上下文对象</strong>。</p>
</li>
<li><p>其中current_app一直指向<code>_app_ctx_stack</code>栈顶的“应用上下文”对象，是对当前应用的引用。</p>
</li>
<li><p>而request、session、g等一直指向<code>_request_ctx_stack</code>栈顶的“请求上下文”对象，分别引用请求上下文的request、session和g。不过，从 Flask 0.10 起，对象 g 存储在应用上下文中而不再是请求上下文中。</p>
</li>
<li><p>在形成这些“全局变量”的时候，使用了werkzeug.local模块的LocalProxy类。</p>
</li>
<li><p>之所以要用该类，主要是为了动态地实现对栈顶元素的引用。如果不使用这个类，在生成上述“全局变量”的时候，它们因为指向栈顶元素，而栈顶元素此时为None，所以这些变量也会被设置为None常量。后续即使有上下文对象被推入栈中，相应的“全局变量”也不会发生改变。为了动态地实现对栈顶元素的引用，这里必须使用werkzeug.local模块的LocalProxy类。</p>
</li>
</ul>
<h2 id="test-request-context-和-app-context"><a href="#test-request-context-和-app-context" class="headerlink" title="test_request_context() 和 app_context()"></a>test_request_context() 和 app_context()</h2><ul>
<li>创建请求上下文对象RequestContext 和 创建应用上下文对象AppContext</li>
<li>如果使用<code>with</code>语句的话就会将这个上下文对象推入请求栈/应用栈</li>
</ul>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>