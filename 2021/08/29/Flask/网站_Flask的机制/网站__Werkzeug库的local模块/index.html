<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;a href=&quot;http://fanchunke.me/Flask/Werkzeug%E5%BA%93%E2%80%94%E2%80%94local%E6%A8%A1%E5%9D%97/&quot;&gt;Werkzeug库——local模块&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Werkzeug库的local模块 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Flask/" rel="tag">Flask</a></div><div class="post-time">2021-08-29</div></div></div><div class="container post-header"><h1>Werkzeug库的local模块</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#local%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">local简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Local%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">Local类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ident-func"><span class="toc-number">2.1.</span> <span class="toc-text">__ident_func__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#storage"><span class="toc-number">2.2.</span> <span class="toc-text">__storage__</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LocalStack%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">LocalStack类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Local%E7%B1%BB%E5%92%8CLocalStack%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.</span> <span class="toc-text">Local类和LocalStack类总结:</span></a></li></ol></li></ol></details></div><div class="container post-content"><p><a target="_blank" rel="noopener" href="http://fanchunke.me/Flask/Werkzeug%E5%BA%93%E2%80%94%E2%80%94local%E6%A8%A1%E5%9D%97/">Werkzeug库——local模块</a></p>
<h2 id="local简介"><a href="#local简介" class="headerlink" title="local简介"></a>local简介</h2><ul>
<li>在<code>local</code>模块中，Werkzeug实现了类似Python标准库中<code>thread.local</code>的功能。</li>
<li><code>thread.local</code>是线程局部变量，也就是每个线程的私有变量，具有线程隔离性，可以通过线程安全的方式获取或者改变线程中的变量。</li>
<li>为什么不用python的内部库<code>thread.local</code>?<ul>
<li>在WSGI中会使用协程 , 而协程会复用线程。</li>
<li>所以不能保证每个请求都有自己的线程，可能是请求正在重用以前的线程。</li>
<li>一个线程中存在多个请求，用<code>thread.local</code>变量处理起来会造成多个请求间数据的相互干扰。</li>
</ul>
</li>
</ul>
<p><code>local</code>模块实现了四个类</p>
<ul>
<li><code>Local</code></li>
<li><code>LocalStack</code></li>
<li><code>LocalProxy</code></li>
<li><code>LocalManager</code></li>
</ul>
<h2 id="Local类"><a href="#Local类" class="headerlink" title="Local类"></a>Local类</h2><ul>
<li><p><code>Local</code>类能够用来存储<strong>线程/协程的私有变量</strong>。在功能上这个<code>thread.local</code>类似。</p>
</li>
<li><p>与之不同的是，<code>Local</code>类支持Python的协程。在Werkzeug库的local模块中，<code>Local</code>类实现了一种数据结构，用来保存线程的私有变量</p>
</li>
<li><p>对于其具体形式，可以参考它的构造函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;__storage__&#x27;</span>, <span class="string">&#x27;__ident_func__&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__storage__&#x27;</span>, &#123;&#125;)</span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;__ident_func__&#x27;</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代Local的时候 , 返回的是&#123;20212: &#123;&#x27;arg0&#x27;: 0 , &#x27;arg1&#x27;: 1&#125;,&#125;这样的字典格式</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self.__storage__.items())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Local</code>类具有两个属性：</p>
<ul>
<li><p><code>__storage__</code> : 一个字典，用来存储不同的线程/协程 , 以及这些线程/协程中的变量。</p>
<p>其数据结构为 : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">20212</span>: &#123;<span class="string">&#x27;arg0&#x27;</span>: <span class="number">0</span> , <span class="string">&#x27;arg1&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="number">20404</span>: &#123;<span class="string">&#x27;arg1&#x27;</span>: <span class="number">1</span>&#125;, </span><br><span class="line">    <span class="number">21512</span>: &#123;<span class="string">&#x27;arg2&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>__ident_func__</code> : 一个函数，用来识别当前线程或协程。</p>
</li>
</ul>
</li>
</ul>
<h3 id="ident-func"><a href="#ident-func" class="headerlink" title="__ident_func__"></a><code>__ident_func__</code></h3><ul>
<li>用于识别当前线程或协程，</li>
<li><code>local</code>模块引入<code>get_ident</code>函数。<ul>
<li>如果支持协程，则从<code>greenlet</code>库中导入相关函数，</li>
<li>否则从<code>thread</code>库中导入相关函数。</li>
</ul>
</li>
<li>调用<code>get_ident</code>将返回一个整数，这个整数可以确定当前线程或者协程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 在有greenlet的情况下，get_indent实际获取的是greenlet的id，而没有greenlet的情况下获取的是thread id</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> greenlet <span class="keyword">import</span> getcurrent <span class="keyword">as</span> get_ident</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">from</span> _thread <span class="keyword">import</span> get_ident</span><br></pre></td></tr></table></figure>



<h3 id="storage"><a href="#storage" class="headerlink" title="__storage__"></a><code>__storage__</code></h3><ul>
<li><code>__storage__</code>是一个字典，用来存储不同的线程/协程，以及这些线程/协程中的变量。</li>
<li>以下是一个简单的多线程的例子，用来说明<code>__storage__</code>的具体结构。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> Local</span><br><span class="line"></span><br><span class="line">l = Local()</span><br><span class="line"><span class="built_in">print</span>(l.__storage__)  <span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_arg</span>(<span class="params">arg, i</span>):</span></span><br><span class="line">    l.__setattr__(arg, i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    arg = <span class="string">&#x27;arg&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    t = threading.Thread(target=add_arg, args=(arg, i))</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(l.__storage__)   <span class="comment"># &#123;20212: &#123;&#x27;arg0&#x27;: 0&#125;, 20404: &#123;&#x27;arg1&#x27;: 1&#125;, 21512: &#123;&#x27;arg2&#x27;: 2&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__storage__</code>这个字典的键表示不同的线程（通过<code>get_ident</code>函数获得线程标识数值），而值表示对应线程中的变量。</li>
<li>这种结构将不同的线程分离开来。当某个线程要访问该线程的变量时，便可以通过<code>get_ident</code>函数获得线程标识数值，进而可以在字典中获得该键对应的值信息了。</li>
</ul>
<h2 id="LocalStack类"><a href="#LocalStack类" class="headerlink" title="LocalStack类"></a>LocalStack类</h2><ul>
<li><p><code>LocalStack</code>类和<code>Local</code>类类似，区别在于其数据结构是栈，而Local是字典的形式。</p>
</li>
<li><p>Local对象存储的时候是类似字典的方式，需要有key和value，而LocalStack是基于栈的，通过push和pop来存储和弹出数据。</p>
</li>
<li><p>另外，当我们想释放存储空间的时候，也可以调用release_local()。</p>
</li>
<li><p><code>请求上下文</code>和<code>应用上下文</code>的实现都是基于LocalStack。</p>
</li>
</ul>
<p>LocalStack的_local属性是一个Local对象。我们的属性的键被定为stack，值是一个列表。通过这个列表实现了栈的push和pop。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._local = Local()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        rv = <span class="built_in">getattr</span>(self._local, <span class="string">&quot;stack&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._local.stack = rv = []</span><br><span class="line">        rv.append(obj)</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        stack = <span class="built_in">getattr</span>(self._local, <span class="string">&quot;stack&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(stack) == <span class="number">1</span>:</span><br><span class="line">            release_local(self._local)</span><br><span class="line">            <span class="keyword">return</span> stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._local.stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">except</span> (AttributeError, IndexError):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>



<ul>
<li>在<code>LocalStack</code>类初始化的时候，便会创建一个<code>Local</code>实例，这个实例用于存储线程/协程的变量。</li>
<li>与此同时，<code>LocalStack</code>类还实现了<code>push</code>、<code>pop</code>、<code>top</code>等方法或属性。调用这些属性或者方法时，该类会根据当前线程或协程的标识数值，在<code>Local</code>实例中对相应的数值进行操作。</li>
<li>以下还是以一个多线程的例子进行说明：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack, LocalProxy</span><br><span class="line"><span class="keyword">import</span> logging, random, threading, time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义logging配置</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;(%(threadName)-10s) %(message)s&#x27;</span>,</span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个LocalStack实例_stack</span></span><br><span class="line">_stack = LocalStack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个RequestConetxt类，它包含一个上下文环境。</span></span><br><span class="line"><span class="comment"># 当调用这个类的实例时，它会将这个上下文对象放入</span></span><br><span class="line"><span class="comment"># _stack栈中去。当退出该上下文环境时，栈会pop其中</span></span><br><span class="line"><span class="comment"># 的上下文对象。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestConetxt</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b, c</span>):</span></span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line">        self.c = c</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        _stack.push(self)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        <span class="keyword">if</span> exc_tb <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            _stack.pop()</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s, %s, %s&#x27;</span> % (self.a, self.b, self.c)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 定义一个可供不同线程调用的方法。当不同线程调用该</span></span><br><span class="line"><span class="comment"># 方法时，首先会生成一个RequestConetxt实例，并在这</span></span><br><span class="line"><span class="comment"># 个上下文环境中先将该线程休眠一定时间，之后打印出</span></span><br><span class="line"><span class="comment"># 目前_stack中的信息，以及当前线程中的变量信息。</span></span><br><span class="line"><span class="comment"># 以上过程会循环两次。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">with</span> request_context(i):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            pause = random.random()</span><br><span class="line">            logging.debug(<span class="string">&#x27;Sleeping %0.02f&#x27;</span>, pause)</span><br><span class="line">            time.sleep(pause)</span><br><span class="line">            logging.debug(<span class="string">&#x27;stack: %s&#x27;</span> % _stack._local.__storage__.items())</span><br><span class="line">            logging.debug(<span class="string">&#x27;ident_func(): %d&#x27;</span> % _stack.__ident_func__())</span><br><span class="line">            logging.debug(<span class="string">&#x27;a=%s; b=%s; c=%s&#x27;</span> %</span><br><span class="line">                          (LocalProxy(<span class="keyword">lambda</span>: _stack.top.a),</span><br><span class="line">                           LocalProxy(<span class="keyword">lambda</span>: _stack.top.b),</span><br><span class="line">                           LocalProxy(<span class="keyword">lambda</span>: _stack.top.c)))</span><br><span class="line">    logging.debug(<span class="string">&#x27;Done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用该函数生成一个RequestConetxt对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_context</span>(<span class="params">i</span>):</span></span><br><span class="line">    i = <span class="built_in">str</span>(i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> RequestConetxt(<span class="string">&#x27;a&#x27;</span>+i, <span class="string">&#x27;b&#x27;</span>+i, <span class="string">&#x27;c&#x27;</span>+i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在程序最开始显示_stack的最初状态</span></span><br><span class="line">logging.debug(<span class="string">&#x27;Stack Initial State: %s&#x27;</span> % _stack._local.__storage__.items())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生两个线程，分别调用worker函数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    t = threading.Thread(target=worker, args=(i,))</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line">main_thread = threading.currentThread()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threading.<span class="built_in">enumerate</span>():</span><br><span class="line">    <span class="keyword">if</span> t <span class="keyword">is</span> <span class="keyword">not</span> main_thread:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在程序最后显示_stack的最终状态</span></span><br><span class="line">logging.debug(<span class="string">&#x27;Stack Finally State: %s&#x27;</span> % _stack._local.__storage__.items())</span><br></pre></td></tr></table></figure>

<p>以上例子的具体分析过程如下：</p>
<ul>
<li>首先，先创建一个LocalStack实例_stack，这个实例将存储线程/协程的变量信息</li>
<li>在程序开始运行时，先检查_stack中包含的信息；</li>
<li>之后创建两个线程，分别执行worker函数；</li>
<li>worker函数首先会产生一个上下文对象，这个上下文对象会放入_stack中。在这个上下文环境中，程序执行一些操作，打印一些数据。当退出上下文环境时，_stack会pop该上下文对象。</li>
<li>在程序结束时，再次检查_stack中包含的信息。</li>
</ul>
<p>结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(MainThread) Stack Initial State: []</span><br><span class="line">(Thread-1  ) Sleeping 0.31</span><br><span class="line">(Thread-2  ) Sleeping 0.02</span><br><span class="line">(Thread-2  ) stack: [(880, &#123;&#x27;stack&#x27;: [a1, b1, c1]&#125;), (13232, &#123;&#x27;stack&#x27;: [a2, b2, c2]&#125;)]</span><br><span class="line">(Thread-2  ) ident_func(): 13232</span><br><span class="line">(Thread-2  ) a=a2; b=b2; c=c2</span><br><span class="line">(Thread-2  ) Sleeping 0.49</span><br><span class="line">(Thread-1  ) stack: [(880, &#123;&#x27;stack&#x27;: [a1, b1, c1]&#125;), (13232, &#123;&#x27;stack&#x27;: [a2, b2, c2]&#125;)]</span><br><span class="line">(Thread-1  ) ident_func(): 880</span><br><span class="line">(Thread-1  ) a=a1; b=b1; c=c1</span><br><span class="line">(Thread-1  ) Sleeping 0.27</span><br><span class="line">(Thread-2  ) stack: [(880, &#123;&#x27;stack&#x27;: [a1, b1, c1]&#125;), (13232, &#123;&#x27;stack&#x27;: [a2, b2, c2]&#125;)]</span><br><span class="line">(Thread-2  ) ident_func(): 13232</span><br><span class="line">(Thread-2  ) a=a2; b=b2; c=c2</span><br><span class="line">(Thread-2  ) Done</span><br><span class="line">(Thread-1  ) stack: [(880, &#123;&#x27;stack&#x27;: [a1, b1, c1]&#125;)]</span><br><span class="line">(Thread-1  ) ident_func(): 880</span><br><span class="line">(Thread-1  ) a=a1; b=b1; c=c1</span><br><span class="line">(Thread-1  ) Done</span><br><span class="line">(MainThread) Stack Finally State: []</span><br></pre></td></tr></table></figure>



<p>注意到：</p>
<ul>
<li>当两个线程在运行时，<code>_stack</code>中会存储这两个线程的信息，每个线程的信息都保存在类似<code>&#123;&#39;stack&#39;: [a1, b1, c1]&#125;</code>的结构中（注：stack键对应的是放入该栈中的对象，此处为了方便打印了该对象的一些属性）。</li>
<li>当线程在休眠和运行中切换时，通过线程的标识数值进行区分不同线程，线程1运行时它通过标识数值只会对属于该线程的数值进行操作，而不会和线程2的数值混淆，这样便起到线程隔离的效果（而不是通过锁的方式）。</li>
<li>由于是在一个上下文环境中运行，当线程执行完毕时，<code>_stack</code>会将该线程存储的信息删除掉。在上面的运行结果中可以看出，当线程2运行结束后，<code>_stack</code>中只包含线程1的相关信息。当所有线程都运行结束，<code>_stack</code>的最终状态将为空。</li>
</ul>
<h3 id="Local类和LocalStack类总结"><a href="#Local类和LocalStack类总结" class="headerlink" title="Local类和LocalStack类总结:"></a>Local类和LocalStack类总结:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">local = Local()</span><br><span class="line">localstack = LocalStack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面本质是设置local的__storage__属性</span></span><br><span class="line"><span class="comment"># 而设置__storage__属性本质是设置__storage__[ident] = &#123;name: value&#125;</span></span><br><span class="line">local.age = <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面本质是设置localstack的_local属性</span></span><br><span class="line">localstack.school = <span class="string">&#x27;gdgydx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以,当我们设置localstack.school = &#x27;gdgydx&#x27; , </span></span><br><span class="line"><span class="comment"># 其实就是设置 localstack._local.__storage__属性</span></span><br><span class="line"><span class="comment"># 进而,就是设置&#123;&lt;greenlet.greenlet at 0x4bee5a0&gt;: &#123;&#x27;school&#x27;: &#x27;gdgydx&#x27;&#125;,&#125;</span></span><br></pre></td></tr></table></figure>





























</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>