<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;什么是canal&quot;&gt;&lt;a href=&quot;#什么是canal&quot; class=&quot;headerlink&quot; title=&quot;什么是canal&quot;&gt;&lt;/a&gt;什么是canal&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用途是基于 &lt;strong&gt;MySQL 数据库增量日志解析&lt;/strong&gt;，提供&lt;strong&gt;增量数据订阅和消费&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;这里我们可以简单地把canal理解为一个用来&lt;strong&gt;同步增量数据的一个工具&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/format,png.png&quot; alt=&quot;img&quot;&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Canal入门 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Canal/" rel="tag">Canal</a></div><div class="post-time">2021-08-29</div></div></div><div class="container post-header"><h1>Canal入门</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFcanal"><span class="toc-number">1.</span> <span class="toc-text">什么是canal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE"><span class="toc-number">3.</span> <span class="toc-text">知识科普</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAcanal"><span class="toc-number">4.</span> <span class="toc-text">如何搭建canal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E6%9C%89%E4%B8%80%E4%B8%AAMySQL%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">首先有一个MySQL服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85canal"><span class="toc-number">4.2.</span> <span class="toc-text">安装canal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">Java客户端操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></details></div><div class="container post-content"><h2 id="什么是canal"><a href="#什么是canal" class="headerlink" title="什么是canal"></a>什么是canal</h2><ul>
<li>用途是基于 <strong>MySQL 数据库增量日志解析</strong>，提供<strong>增量数据订阅和消费</strong>。</li>
<li>这里我们可以简单地把canal理解为一个用来<strong>同步增量数据的一个工具</strong>。</li>
</ul>
<p><img src="/images/format,png.png" alt="img"></p>
<ul>
<li>canal的工作原理就是把自己伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议，MySQL mater收到canal发送过来的dump请求，开始推送binary log给canal，然后canal解析binary log，再发送到存储目的地，比如MySQL，Kafka，Elastic Search等等。</li>
<li>但是canal的数据同步<strong>不是全量的，而是增量</strong>。基于binary log增量订阅和消费，canal可以做：<ul>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>索引构建和实时维护</li>
<li>业务cache(缓存)刷新</li>
<li>带业务逻辑的增量数据处理</li>
</ul>
</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>mysql主备复制实现：</p>
<p><img src="/images/image-20210716161409257.png" alt="image-20210716161409257"></p>
<p>从上层来看，复制分成三步：</p>
<ol>
<li>master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）；</li>
<li>slave将master的binary log events拷贝到它的中继日志(relay log)；</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据。</li>
</ol>
<h2 id="知识科普"><a href="#知识科普" class="headerlink" title="知识科普"></a>知识科普</h2><p>mysql的Binlay Log介绍</p>
<ul>
<li>(<a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.5/en/binary-log.html">http://dev.mysql.com/doc/refman/5.5/en/binary-log.html</a>)</li>
<li>(<a target="_blank" rel="noopener" href="http://www.taobaodba.com/html/474_mysqls-binary-log_details.html">http://www.taobaodba.com/html/474_mysqls-binary-log_details.html</a>)</li>
</ul>
<p>简单点说：</p>
<ul>
<li>mysql的binlog是多文件存储，定位一个LogEvent需要通过binlog filename + binlog position，进行定位</li>
<li>mysql的binlog数据格式，按照生成的方式，主要分为：statement-based、row-based、mixed。</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;binlog_format&#x27;</span>;</span><br><span class="line">    +---------------+-------+</span><br><span class="line">    <span class="params">| Variable_name |</span> Value <span class="params">|</span></span><br><span class="line"><span class="params">    +---------------+-------+</span></span><br><span class="line"><span class="params">    |</span> binlog_format <span class="params">| ROW   |</span></span><br><span class="line">    +---------------+-------+</span><br><span class="line">    <span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>目前canal支持所有模式的增量订阅(但配合同步时，因为statement只有sql，没有数据，无法获取原始的变更日志，所以一般建议为ROW模式)</p>
<h2 id="如何搭建canal"><a href="#如何搭建canal" class="headerlink" title="如何搭建canal"></a>如何搭建canal</h2><h3 id="首先有一个MySQL服务器"><a href="#首先有一个MySQL服务器" class="headerlink" title="首先有一个MySQL服务器"></a>首先有一个MySQL服务器</h3><p>当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.5.x , 5.6.x , 5.7.x , 8.0.x</p>
<p>然后在MySQL中需要创建一个用户，并授权：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用命令登录：mysql -u root -p</span></span><br><span class="line"><span class="comment">-- 创建用户 用户名：canal 密码：Canal@123456</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;Canal@123456&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授权 *.*表示所有库</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;Canal@123456&#x27;</span>;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>下一步在MySQL配置文件my.cnf设置如下信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">mysqld</span>]</span><br><span class="line"><span class="comment"># 打开binlog</span></span><br><span class="line"><span class="string">log-bin=mysql-bin</span></span><br><span class="line"><span class="comment"># 选择ROW(行)模式</span></span><br><span class="line"><span class="string">binlog-format=ROW</span></span><br><span class="line"><span class="comment"># 配置MySQL replaction需要定义，不要和canal的slaveId重复</span></span><br><span class="line"><span class="string">server_id=1</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>改了配置文件之后，重启MySQL，使用命令查看是否打开binlog模式：</p>
<p><img src="/images/20200808151606261.png" alt="在这里插入图片描述"></p>
<p>查看binlog日志文件列表：</p>
<p><img src="/images/20200808151715291.png" alt="在这里插入图片描述"></p>
<p>查看当前正在写入的binlog文件：</p>
<p><img src="/images/2020080815153247.png" alt="在这里插入图片描述"></p>
<p>MySQL服务器这边就搞定了，很简单。</p>
<h3 id="安装canal"><a href="#安装canal" class="headerlink" title="安装canal"></a>安装canal</h3><p>去官网下载页面进行下载：<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal/releases">https://github.com/alibaba/canal/releases</a></p>
<p>我这里下载的是1.1.4的版本：</p>
<p><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70-20210716160315235.png" alt="在这里插入图片描述"></p>
<p>解压<strong>canal.deployer-1.1.4.tar.gz</strong>，我们可以看到里面有四个文件夹：</p>
<p><img src="/images/format,png-20210716160314545.png" alt="img"></p>
<p>接着打开配置文件conf/example/instance.properties，配置信息如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## mysql serverId , v1.0.26+ will autoGen</span></span><br><span class="line"><span class="comment">## v1.0.26版本后会自动生成slaveId，所以可以不用配置</span></span><br><span class="line"><span class="comment"># canal.instance.mysql.slaveId=0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 数据库地址</span></span><br><span class="line"><span class="meta">canal.instance.master.address</span>=<span class="string">127.0.0.1:3306</span></span><br><span class="line"><span class="comment"># binlog日志名称</span></span><br><span class="line"><span class="meta">canal.instance.master.journal.name</span>=<span class="string">mysql-bin.000001</span></span><br><span class="line"><span class="comment"># mysql主库链接时起始的binlog偏移量</span></span><br><span class="line"><span class="meta">canal.instance.master.position</span>=<span class="string">154</span></span><br><span class="line"><span class="comment"># mysql主库链接时起始的binlog的时间戳</span></span><br><span class="line"><span class="meta">canal.instance.master.timestamp</span>=<span class="string"></span></span><br><span class="line"><span class="meta">canal.instance.master.gtid</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># username/password</span></span><br><span class="line"><span class="comment"># 在MySQL服务器授权的账号密码</span></span><br><span class="line"><span class="meta">canal.instance.dbUsername</span>=<span class="string">canal</span></span><br><span class="line"><span class="meta">canal.instance.dbPassword</span>=<span class="string">Canal@123456</span></span><br><span class="line"><span class="comment"># 字符集</span></span><br><span class="line"><span class="meta">canal.instance.connectionCharset</span> = <span class="string">UTF-8</span></span><br><span class="line"><span class="comment"># enable druid Decrypt database password</span></span><br><span class="line"><span class="meta">canal.instance.enableDruid</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># table regex .*\\..*表示监听所有表 也可以写具体的表名，用，隔开</span></span><br><span class="line"><span class="meta">canal.instance.filter.regex</span>=<span class="string">.*\\..*</span></span><br><span class="line"><span class="comment"># mysql 数据解析表的黑名单，多个表用，隔开</span></span><br><span class="line"><span class="meta">canal.instance.filter.black.regex</span>=<span class="string"></span></span><br><span class="line"><span class="attr">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>

<p>我这里用的是win10系统，所以在bin目录下找到startup.bat启动：</p>
<p>启动就报错，坑呀：</p>
<p><img src="/images/format,png-20210716160312417.png" alt="img"></p>
<p>要修改一下启动的脚本startup.bat：</p>
<p><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70-20210716160314749.png" alt="在这里插入图片描述"></p>
<p>然后再启动脚本：<br><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70-20210716160314763.png" alt="在这里插入图片描述"></p>
<p>这就启动成功了。</p>
<h2 id="Java客户端操作"><a href="#Java客户端操作" class="headerlink" title="Java客户端操作"></a>Java客户端操作</h2><p>首先引入maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.otter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>然后创建一个canal项目，使用SpringBoot构建，如图所示：<br><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llaG9uZ3poaTE5OTQ=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"><br>在CannalClient类使用Spring Bean的生命周期函数afterPropertiesSet()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CannalClient</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> BATCH_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        CanalConnector connector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">11111</span>), <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开连接</span></span><br><span class="line">            connector.connect();</span><br><span class="line">            <span class="comment">//订阅数据库表,全部表</span></span><br><span class="line">            connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line">            <span class="comment">//回滚到未进行ack的地方，下次fetch的时候，可以从最后一个没有ack的地方开始拿</span></span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">                Message message = connector.getWithoutAck(BATCH_SIZE);</span><br><span class="line">                <span class="comment">//获取批量ID</span></span><br><span class="line">                <span class="keyword">long</span> batchId = message.getId();</span><br><span class="line">                <span class="comment">//获取批量的数量</span></span><br><span class="line">                <span class="keyword">int</span> size = message.getEntries().size();</span><br><span class="line">                <span class="comment">//如果没有数据</span></span><br><span class="line">                <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//线程休眠2秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果有数据,处理数据</span></span><br><span class="line">                    printEntry(message.getEntries());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//进行 batch id 的确认。确认之后，小于等于此 batchId 的 Message 都会被确认。</span></span><br><span class="line">                connector.ack(batchId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印canal server解析binlog获得的实体类信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEntry</span><span class="params">(List&lt;Entry&gt; entrys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">                <span class="comment">//开启/关闭事务的实体类型，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//RowChange对象，包含了一行数据变化的所有特征</span></span><br><span class="line">            <span class="comment">//比如isDdl 是否是ddl变更操作 sql 具体的ddl sql beforeColumns afterColumns 变更前后的数据字段等等</span></span><br><span class="line">            RowChange rowChage;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChage = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取操作类型：insert/update/delete类型</span></span><br><span class="line">            EventType eventType = rowChage.getEventType();</span><br><span class="line">            <span class="comment">//打印Header信息</span></span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;================》; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class="line">                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class="line">                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class="line">                    eventType));</span><br><span class="line">            <span class="comment">//判断是否是DDL语句</span></span><br><span class="line">            <span class="keyword">if</span> (rowChage.getIsDdl()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;================》;isDdl: true,sql:&quot;</span> + rowChage.getSql());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取RowChange对象里的每一行数据，打印出来</span></span><br><span class="line">            <span class="keyword">for</span> (RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class="line">                <span class="comment">//如果是删除语句</span></span><br><span class="line">                <span class="keyword">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                    <span class="comment">//如果是新增语句</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                    <span class="comment">//如果是更新的语句</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//变更前的数据</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;-------&gt;; before&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                    <span class="comment">//变更后的数据</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;-------&gt;; after&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printColumn</span><span class="params">(List&lt;Column&gt; columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            System.out.println(column.getName() + <span class="string">&quot; : &quot;</span> + column.getValue() + <span class="string">&quot;    update=&quot;</span> + column.getUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就完成了Java客户端的代码。这里不做具体的处理，仅仅是打印，先有个直观的感受。</p>
<p>最后我们开始测试，首先启动MySQL、Canal Server，还有刚刚写的Spring Boot项目。然后创建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_commodity_info` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `commodity_name` <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">  `commodity_price` <span class="type">varchar</span>(<span class="number">36</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;商品价格&#x27;</span>,</span><br><span class="line">  `number` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;商品数量&#x27;</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">2048</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;商品描述&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;商品信息表&#x27;</span>;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>然后我们在控制台就可以看到如下信息：</p>
<p><img src="/images/format,png-20210716160315565.png" alt="img"></p>
<p>如果新增一条数据到表中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_commodity_info <span class="keyword">VALUES</span>(<span class="string">&#x27;3e71a81fd80711eaaed600163e046cc3&#x27;</span>,<span class="string">&#x27;叉烧包&#x27;</span>,<span class="string">&#x27;3.99&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;又大又香的叉烧包，老人小孩都喜欢&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>控制台可以看到如下信息：</p>
<p><img src="/images/20200809230414536.png" alt="在这里插入图片描述"></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/images/image-20210716161543594.png" alt="image-20210716161543594"></p>
<p>说明：</p>
<ul>
<li>server代表一个canal运行实例，对应于一个jvm</li>
<li>instance对应于一个数据队列 （1个server对应1..n个instance)</li>
</ul>
<p>instance模块：</p>
<ul>
<li>eventParser (数据源接入，模拟slave协议和master进行交互，协议解析)</li>
<li>eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作)</li>
<li>eventStore (数据存储)</li>
<li>metaManager (增量订阅&amp;消费信息管理器)</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>canal的好处在于<strong>对业务代码没有侵入</strong>，因为是<strong>基于监听binlog日志去进行同步数据的</strong>。实时性也能做到准实时，其实是很多企业一种比较常见的数据同步的方案。</p>
<p>实际项目我们是<strong>配置MQ模式，配合RocketMQ或者Kafka，canal会把数据发送到MQ的topic中，然后通过消息队列的消费者进行处理</strong>。</p>
<p><img src="/images/format,png-20210716160314597.png" alt="img"></p>
<p>Canal的部署也是支持集群的，需要配合ZooKeeper进行集群管理。Canal还有一个简单的Web管理界面。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>