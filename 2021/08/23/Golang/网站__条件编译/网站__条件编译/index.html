<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;交叉编译&quot;&gt;&lt;a href=&quot;#交叉编译&quot; class=&quot;headerlink&quot; title=&quot;交叉编译&quot;&gt;&lt;/a&gt;交叉编译&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;交叉编译是用来在一个平台上生成另一个平台的可执行程序。&lt;/strong&gt;比如我工作开发时用的Mac，系统内核是&lt;code&gt;darwin&lt;/code&gt;，小张用的是外星人，系统内核是&lt;code&gt;windows&lt;/code&gt; 。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>条件编译 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-08-23</div></div></div><div class="container post-header"><h1>条件编译</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91"><span class="toc-number">1.</span> <span class="toc-text">交叉编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">2.</span> <span class="toc-text">条件编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%A0%87%E7%AD%BE"><span class="toc-number">2.1.</span> <span class="toc-text">构建标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E5%90%8E%E7%BC%80"><span class="toc-number">2.2.</span> <span class="toc-text">文件名后缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BA%E6%A0%87%E7%AD%BE%E8%BF%98%E6%98%AF%E6%96%87%E4%BB%B6%E5%90%8D%E5%90%8E%E7%BC%80"><span class="toc-number">2.3.</span> <span class="toc-text">使用构建标签还是文件名后缀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">实践应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">3.1.</span> <span class="toc-text">设置条件编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91"><span class="toc-number">3.2.</span> <span class="toc-text">执行交叉编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></details></div><div class="container post-content"><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p><strong>交叉编译是用来在一个平台上生成另一个平台的可执行程序。</strong>比如我工作开发时用的Mac，系统内核是<code>darwin</code>，小张用的是外星人，系统内核是<code>windows</code> 。</p>
<p>那么假如我编写的代码依赖了系统底层平台或处理器架构特性的<code>Go</code>包时，比如说我上周在文章《<a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&mid=2247485907&idx=1&sn=76e24be0ac7766ec02be149702f13347&chksm=fa80d844cdf75152c054cda3f3d9040ed041986ea0afdecd52a6dd217979dcc987bf44f90f44&token=2095836062&lang=zh_CN%23rd">Go服务迁到K8s后老抽风重启? 记一次完整的线上问题解决过程</a>》里写的，为了把<code>Go</code>运行时的<code>panic</code>错误重定向到日志文件，我用了<code>syscall.Dup2</code>这个函数把标准错误原来的文件描述符替换成了自己指定的日志文件的描述符。<code>syscall.Dup2</code>是<code>Go</code>语言在类<code>Unix</code>系统，<code>X86_64</code>架构下才有的函数库，在Mac系统上、各种服务器环境上编译都没有问题，但是唯独在像小张用的<code>Windows</code>系统上编译不过去。</p>
<p>所以在上篇文章说的那个为了追踪在<code>Kubernetes</code>上服务老重启的问题，用<code>syscall.Dup2</code>重定向标准输出的解决方案是有副作用的，我贴一下之前这个功能的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RewriteStderrFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">    file, err := os.OpenFile(stdErrFile, os.O_RDWR|os.O_CREATE|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err = syscall.Dup2(<span class="keyword">int</span>(file.Fd()), <span class="keyword">int</span>(os.Stderr.Fd())); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>天真的用了一个**runtime.GOOS == “windows”**的判断，我还想着能在代码里根据内核的不同执行不同的代码，但是<code>Go</code>的软件包是先编译成可执行文件再执行的，这个判断根本没啥用。所以在<code>Windows</code>系统下编译项目的时候，因为没有<code>syscall.Dup2</code>直接就失败了。</p>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>我发现在go的每个内置库里都有很多以不停系统名结尾的文件。下面是<code>Go</code>的<a href="https://link.juejin.cn/?target=https://github.com/golang/go/tree/master/src/os">os</a>内置库源代码的部分截图：</p>
<p><img src="/images/image-20210823142108310.png" alt="image-20210823142108310"></p>
<p>在有些文件里还有类似下面这样的注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> os</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>看了些资料后才知道，他们是用于<code>Go</code>软件包的<a href="https://link.juejin.cn/?target=https://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool"><strong>条件编译</strong></a>的，条件编译的意思就是通过某种方式来指示编译器编译特定代码。</p>
<p><code>Go</code>不支持宏，不可以像c语言那样使用<code>#define</code>来控制是否包含平台相关的特定代码。作为替代，<code>Go</code>使用构建标签(<code>build tags</code>)和代码文件的命名约定来支持<code>Go</code>软件包的条件编译。</p>
<h3 id="构建标签"><a href="#构建标签" class="headerlink" title="构建标签"></a>构建标签</h3><p>构建标签就是上面我说的源代码里的注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> os</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>构建标签必须在代码文件里位于<code>package</code>声明的上方，并且后跟一个空行。</strong></p>
<p>当<code>Go</code>编译一个包时，它会分析包内的每个源码文件并查找构建标签。标签决定了这个源码文件是否被编译。</p>
<p>构建标签遵循以下三个原则：</p>
<ol>
<li>空格隔开的选项是或（OR）的关系</li>
<li>逗号隔开的选项是与（AND）的关系</li>
<li>每个选项由字母和数字组成。如果前面加上<code>!</code>，则表示反义</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build darwin freebsd netbsd openbsd</span></span><br></pre></td></tr></table></figure>

<p>上面的例子，表示这个源码文件只会在支持<code>kqueue</code>的<code>BSD</code>系统中被编译。</p>
<p>一个源码文件可以包含多个构建标签。构建规则是每个独立规则的逻辑与关系。如下例子表示该文件将在<code>linux/386</code>或<code>darwin/386</code>平台才会被编译 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux darwin</span></span><br><span class="line"><span class="comment">// +build 386</span></span><br></pre></td></tr></table></figure>

<p>用逻辑表达式表示就是：**(linux   OR  darwin)  AND  386。**</p>
<h3 id="文件名后缀"><a href="#文件名后缀" class="headerlink" title="文件名后缀"></a>文件名后缀</h3><p>第二种条件编译的方法是通过源码文件的文件名实现的。这种方案比构造标签方案更简单。</p>
<p><code>go/build</code>包的文档有关于命名约定的描述。简单来说，如果文件名包含<code>_$GOOS.go</code>后缀，那么这个源码文件只会在对应的平台被编译。其他平台会忽略这个文件。另一种约定是<code>_$GOARCH.go</code>。这两种后缀可以组合起来，但要保证顺序，正确的格式是<code>_$GOOS_$GOARCH.go</code>，错误的格式是<code>_$GOARCH_$GOOS.go</code>。</p>
<p>以下是文件名后缀的一些例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mypkg_freebsd_arm.<span class="keyword">go</span> <span class="comment">// 只在 freebsd/arm 系统编译</span></span><br><span class="line">mypkg_plan9.<span class="keyword">go</span>       <span class="comment">// 只在 plan9 编译</span></span><br><span class="line">mypkg_darwin.<span class="keyword">go</span>      <span class="comment">// 只在macos 系统编译</span></span><br></pre></td></tr></table></figure>

<p>源码文件光有后缀是不行的，比如如下文件名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_linux.<span class="keyword">go</span></span><br><span class="line">_freebsd_386.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>即使是在Linux或FreeBSD系统，这两个文件也会被忽略，原因是<code>go/build</code>包会忽略所有文件名以<code>.</code>和<code>_</code>开始的文件。</p>
<h3 id="使用构建标签还是文件名后缀"><a href="#使用构建标签还是文件名后缀" class="headerlink" title="使用构建标签还是文件名后缀"></a>使用构建标签还是文件名后缀</h3><p>构建标签和文件名后缀在功能上是重叠的。比如，一个名为<code>mypkg_linux.go</code>的文件，再包含构建标签<code>// +build linux</code>会显得多余。</p>
<p>通常来说，当只有一个特定平台或体系需要指定时，我们选择文件名后缀的方式。比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mypkg_linux.<span class="keyword">go</span>         <span class="comment">// 只在 linux 系统编译</span></span><br><span class="line">mypkg_windows_amd64.<span class="keyword">go</span> <span class="comment">// 只在 windows amd 64位 平台编译</span></span><br></pre></td></tr></table></figure>

<p>相反，如果你的文件需要指定给多个平台或体系架构使用，或者你需要排除某个特定平台时，我们选择构建标签的方式。比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在所有类unix平台编译</span></span><br><span class="line"><span class="comment">// +build darwin dragonfly freebsd linux netbsd openbsd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在非Windows平台编译</span></span><br><span class="line"><span class="comment">// +build !windows</span></span><br></pre></td></tr></table></figure>



<h2 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h2><h3 id="设置条件编译"><a href="#设置条件编译" class="headerlink" title="设置条件编译"></a>设置条件编译</h3><p>首先我向下面这样，在包里建了两个源码文件，用来分别存放在<code>Windows</code>系统和非<code>Windows</code>系统下使用的<code>RewriteStderrFile</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">|</span><br><span class="line">└───pkg1</span><br><span class="line">│   │----rewrite_err_unix.go</span><br><span class="line">│   │----rewrite_err_windows.go</span><br></pre></td></tr></table></figure>

<p>因为我们的项目在那几个大佬电脑的<code>Windows</code>系统上编译和运行的时候都是开发阶段，其他测试上线之类的环境都是<code>Linux</code>系统，所以我懒癌发作，直接写了个空函数，毕竟只要能编译运行小张就不会太难为我了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rewrite_err_windows.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RewritePanicsToFile</span><span class="params">(topic <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于要在服务器上和Mac电脑上编译的源码，跟之前的差不多，只是增加了构建标签：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+build darwin linux</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RewritePanicsToFile</span><span class="params">(topic <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    file, err := os.OpenFile(stdErrFile, os.O_RDWR|os.O_CREATE|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">	  <span class="keyword">if</span> err = syscall.Dup2(<span class="keyword">int</span>(errFileHandler.Fd()), <span class="keyword">int</span>(os.Stderr.Fd())); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		    <span class="keyword">return</span> err</span><br><span class="line">	  &#125;</span><br><span class="line">    ......</span><br><span class="line">  </span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="执行交叉编译"><a href="#执行交叉编译" class="headerlink" title="执行交叉编译"></a>执行交叉编译</h3><p>交叉编译的执行就非常简单了，在编译时给<strong>go build</strong>命令设置<code>OS</code>和<code>ARCH</code>参数即可：</p>
<p>比如在Mac 下编译 <code>Windows</code> 64位可执行程序，用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure>

<p>在Mac系统执行完上面的命令就会编译生成软件包在Windows系统上的可执行文件（.exe文件）</p>
<p>如果是<code>Windows</code> 下编译 Mac 64位可执行程序，用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事实上，除了用于<code>.go</code>的Go源码文件，构建标签和文件名后缀这些条件编译规则可以作用于任何<strong>go tool</strong>可以编译的源码文件，包括<code>.c</code>和<code>.s</code>文件。<code>Go</code>标准库中，尤其是<code>runtime</code>，<code>syscall</code>，<code>os</code>，<code>net</code>包中包含了大量这种例子。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>