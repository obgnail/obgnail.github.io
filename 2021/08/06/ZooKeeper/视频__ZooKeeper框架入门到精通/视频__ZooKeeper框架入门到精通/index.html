<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="地址 : &lt;a href=&quot;https://www.bilibili.com/video/BV1r7411A7fg&quot;&gt;https://www.bilibili.com/video/BV1r7411A7fg&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>ZooKeeper框架入门到精通 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/ZooKeeper/" rel="tag">ZooKeeper</a></div><div class="post-time">2021-08-06</div></div></div><div class="container post-header"><h1>ZooKeeper框架入门到精通</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZooKeeper%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">ZooKeeper特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZooKeeper%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2"><span class="toc-number">3.</span> <span class="toc-text">ZooKeeper集群角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">Zookeeper 数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">4.1.</span> <span class="toc-text">数据结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">节点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">节点属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper-Shell"><span class="toc-number">5.</span> <span class="toc-text">Zookeeper Shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.1.</span> <span class="toc-text">客户端连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">Shell 基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9"><span class="toc-number">5.2.1.</span> <span class="toc-text">创建节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%8A%82%E7%82%B9"><span class="toc-number">5.2.2.</span> <span class="toc-text">读取节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9"><span class="toc-number">5.2.3.</span> <span class="toc-text">更新节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">5.2.4.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quota"><span class="toc-number">5.2.5.</span> <span class="toc-text">quota</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#listquota"><span class="toc-number">5.2.6.</span> <span class="toc-text">listquota</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delquota"><span class="toc-number">5.2.7.</span> <span class="toc-text">delquota</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#history"><span class="toc-number">5.2.8.</span> <span class="toc-text">history</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo"><span class="toc-number">5.2.9.</span> <span class="toc-text">redo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper-Watcher"><span class="toc-number">6.</span> <span class="toc-text">Zookeeper Watcher</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#watch%E6%9C%BA%E5%88%B6%E7%89%B9%E7%82%B9"><span class="toc-number">6.1.</span> <span class="toc-text">watch机制特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E7%8A%B6%E6%80%81%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">通知状态和事件类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E7%BD%AEWatcher"><span class="toc-number">6.3.</span> <span class="toc-text">Shell 客户端设置Watcher</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper%E7%9A%84%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">Zookeeper的选举机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%96%B0%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE"><span class="toc-number">7.2.</span> <span class="toc-text">全新集群选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%85%A8%E6%96%B0%E9%9B%86%E7%BE%A4%E9%80%89%E4%B8%BE"><span class="toc-number">7.3.</span> <span class="toc-text">非全新集群选举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">Zookeeper的典型应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">8.1.</span> <span class="toc-text">数据发布与订阅(配置中心)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1-Naming-Service"><span class="toc-number">8.2.</span> <span class="toc-text">命名服务(Naming Service)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">8.3.</span> <span class="toc-text">分布式锁</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>地址 : <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1r7411A7fg">https://www.bilibili.com/video/BV1r7411A7fg</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Zookeeper是一个分布式协调服务的开源框架。主要用来解决分布式集群中应用系统的一致性问题，例如怎样避免同时操作同一数据造成脏读的问题</li>
<li><strong>ZooKeeper本质上是一个分布式的小文件存储系统</strong>。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理。从而用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。诸如：统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能</li>
</ul>
<h2 id="ZooKeeper特性"><a href="#ZooKeeper特性" class="headerlink" title="ZooKeeper特性"></a>ZooKeeper特性</h2><ol>
<li><p><code>全局数据一致</code> : 每个 server 都保存相同的数据副本，client无论连接到哪个  server，展示的数据都是一致的，这是最重要的特征</p>
</li>
<li><p><code>可靠性</code> ：如果消息被其中一台服务器接受，那么将被所有的服务器接受</p>
</li>
<li><p><code>顺序性</code>：包括全局有序和偏序两种：</p>
<ul>
<li>全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有  Server 上消息a都将在消息b前被发布</li>
<li>偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li>
</ul>
</li>
<li><p><code>数据更新原子性</code>：一次数据更新要么成功（半数以上节点成功），要么失败，不存在中间状态</p>
</li>
<li><p><code>实时性</code>：Zookeeper 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。</p>
</li>
</ol>
<h2 id="ZooKeeper集群角色"><a href="#ZooKeeper集群角色" class="headerlink" title="ZooKeeper集群角色"></a>ZooKeeper集群角色</h2><p><img src="/images/image-20210806154323084.png" alt="image-20210806154323084"></p>
<p><code>Leader</code> : </p>
<ul>
<li>Zookeeper集群工作的核心</li>
<li>事务请求（写操作）的唯一调度和处理者，保证集群事务处理的顺序性</li>
<li>集群内部各个服务器的调度者。</li>
</ul>
<blockquote>
<p>对于  create，setData，delete等有写操作的请求，则需要<strong>统一转发给leader处理</strong>，leader需要决定编号、执行操作，这个过程称为一个事务</p>
</blockquote>
<p><code>Follower</code>：</p>
<ul>
<li>处理客户端非事务（读操作）请求，转发事务请求给 Leader</li>
<li>参与集群 Leader选举投票。</li>
</ul>
<p>此外，针对访问量比较大的 zookeeper集群，还可新增观察者角色。</p>
<p><code>Observer</code> :</p>
<ul>
<li>观察者角色，观察zookeeper集群的最新状态变化并将这些状态同步过来，其对于非事务请求可以进行独立处理，对于事务请求，则会转发给 Leader服务器进行处理</li>
<li><strong>不会参与任何形式的投票</strong>，只提供非事务服务，通常用于在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</li>
</ul>
<h2 id="Zookeeper-数据模型"><a href="#Zookeeper-数据模型" class="headerlink" title="Zookeeper 数据模型"></a>Zookeeper 数据模型</h2><h3 id="数据结构图"><a href="#数据结构图" class="headerlink" title="数据结构图"></a>数据结构图</h3><p>ZooKeeper的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用树形层次结构，Zookeeper树中的每个节点被称为<code>Znode</code>。和文件系统的目录树一样，ZooKeeper树中的每个节点可以拥有子节点。但也有不同之处：</p>
<ol>
<li><strong>Znode兼具文件和目录两种特点</strong>。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子Znode。用户对 znode具有增、删、改、查等操作（权限允许的情况下）。</li>
<li><strong>znode具有原子性操作</strong>，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL（访问控制列表），这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。</li>
<li><strong>znode存储数据大小有限制</strong>。ZooKeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。ZooKeeper的服务器和客户端都被设计为严格检查并限制每个 Znode的数据大小至多1M，当时常规使用中应该远小于此值。</li>
<li><strong>Znode过路径引用</strong>，如同Uinx中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在  Zookeeper中，路径由Unicode字符串组成，并且有一些限制。字符串“/zookeeper”用以保存管理信息，比如关键配额信息。</li>
</ol>
<p><img src="/images/1593940648825.png" alt="1593940648825"></p>
<p>图中的每个节点称为一个 Znode。每个Znode由3部分组成：</p>
<ol>
<li>stat：此为状态信息，描述该 Znode的版本，权限等信息</li>
<li>data：与该 Znode关联的数据</li>
<li>children：该Znode下的子节点</li>
</ol>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li><p>Znode有两种，分别为<code>临时节点</code>和<code>永久节点</code> , 节点的类型在创建时即被确定，并且不能改变</p>
<ul>
<li>临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话结束，临时节点将被自动删除，当然可以也可以手动删除。临时节点不允许拥有子节点。</li>
<li>永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除</li>
</ul>
</li>
<li><p>Znode还有一个<code>序列化</code>的特性，如果创建的时候开启此特性的话，该Znode的名字后面会自动追加一个不断增加的序列号。序列号对于此节点的父节点来说是唯一的，这样便会<strong>记录每个子节点创建的先后顺序</strong>。它的格式为“%10d”（10位数字，没有数值的数位用0补充，例如<code>00000001</code></p>
</li>
</ul>
<p>这样便会存在四种类型的 Znode节点，分别对应：</p>
<ul>
<li>PERSISTENT：永久节点</li>
<li>EPHEMERAL：临时节点</li>
<li>PERSISTENT_SEQUENTIAL：永久节点、序列化</li>
<li>EPHEMERAL_SEQUENTIAL：临时节点、序列化</li>
</ul>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>每个Znode都包含了一系列的属性，通过命令get，可以获得节点的属性。</p>
<p><img src="/images/1593941602610.png" alt="1593941602610"></p>
<ul>
<li><p>dataVersion：数据版本号，每次对节点进行set操作，dataversion的值都会增加1（即使设置的是相同的数据），可有效避免了数据更新时出现的先后顺序问题</p>
</li>
<li><p>cversion：子节点的版本号。当znode的子节点有变化时，cversion的值就会增加1</p>
</li>
<li><p>aclVersion：ACL的版本号</p>
</li>
<li><p>cZxid：Znode创建的事务id</p>
</li>
<li><p>mZxid：Znode被修改的事务id，即每次对znode的修改都会更新mZxid</p>
<ul>
<li>对于zk来说，每次的变化都会产生一个唯一的事务id,zxid（Zookeeper Transaction Id）。</li>
<li>通过zxid，可以确定更新操作的先后顺序。例如，如果 zxid1小于zxid2，说明<br>zxid1操作先于zxid2发生，</li>
<li>zxid对于整个zk都是唯一的 , 即使操作的是不同的 znode</li>
</ul>
</li>
<li><p>ctime：节点创建时的时间戳</p>
</li>
<li><p>mtime：节点最新一次更新发生时的时间戳</p>
</li>
<li><p>ephemeralOwner：如果该节点为临时节点，ephemeralOwner值表示与该节点绑定的 session  id。如果不是，ephemeralOwner值为0。</p>
<blockquote>
<p>在 client和 server通信之前，首先需要建立连接，该连接称为  session，连接建立后，如果发生连接超时、授权失败，或者显式关闭连接，连接便处于 CLOSED状态，此时 session结束。</p>
</blockquote>
</li>
</ul>
<h2 id="Zookeeper-Shell"><a href="#Zookeeper-Shell" class="headerlink" title="Zookeeper Shell"></a>Zookeeper Shell</h2><h3 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h3><p>运行 <code>zkCli.sh - server ip</code> 进入命令行工具 , 输入help，输出 zk shell提示：</p>
<p><img src="/images/1593942269931.png" alt="1593942269931"></p>
<h3 id="Shell-基本操作"><a href="#Shell-基本操作" class="headerlink" title="Shell 基本操作"></a>Shell 基本操作</h3><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [-s] [-e] path data acl</span><br></pre></td></tr></table></figure>

<ul>
<li>-s : 顺序(默认非序列化)</li>
<li>-e : 临时节点(默认永久)</li>
<li>acl : 用户权限控制</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建顺序节点</span></span><br><span class="line">create -s /<span class="built_in">test</span> 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时节点</span></span><br><span class="line">create -e /test-temp 123temp</span><br></pre></td></tr></table></figure>



<h4 id="读取节点"><a href="#读取节点" class="headerlink" title="读取节点"></a>读取节点</h4><p>相关命令 : <code>ls</code> 和 <code>get</code></p>
<ul>
<li>ls : 列出指定节点下面的所有<strong>第一级</strong>子节点 ,</li>
<li>get : 获取指定节点的数据内容和属性信息</li>
<li>ls2 : 比ls显示更全面的信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls path [watch]</span><br><span class="line">get path [watch]</span><br><span class="line">ls2 path [watch]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls /heyingliang</span><br><span class="line">get /heyingliang</span><br><span class="line">ls2 /heyingliang</span><br></pre></td></tr></table></figure>



<h4 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set path data [version]</span><br></pre></td></tr></table></figure>

<ul>
<li>data : 要更新的新内容</li>
<li>version : 数据版本 , 必须和data的数据版本一致,否则不允许更新</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/heyingliang的数值修改为123</span></span><br><span class="line"><span class="built_in">set</span> /heyingliang 123</span><br><span class="line"><span class="comment"># 此时/heyingliang的dataVersion就会+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设此时/heingliang的dataVersio=3</span></span><br><span class="line"><span class="built_in">set</span> /heyingliang 2 <span class="comment"># 执行失败</span></span><br><span class="line"><span class="built_in">set</span> /heyingliang 3 <span class="comment"># 执行成功</span></span><br></pre></td></tr></table></figure>



<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete path [version]</span><br></pre></td></tr></table></figure>

<p>若删除的节点拥有子节点 , 那么将无法删除 , 必须先删除子节点才能删除这个节点</p>
<h4 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h4><p>对节点增加限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setquota -n|-b val path </span><br></pre></td></tr></table></figure>

<ul>
<li>n : 节点的最大个数(子节点+自己)</li>
<li>b : 数据值的最大长度</li>
<li>val : 子节点最大个数 或 数据值的最大长度</li>
<li>path : 节点路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setquota -n 2 /hyl</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 : 这种限制是<code>假的</code> , 就算超出了限制 , 也不会报错 , 只会在日志里写入一个WRANNIG日志</p>
</blockquote>
<h4 id="listquota"><a href="#listquota" class="headerlink" title="listquota"></a>listquota</h4><p>列出节点的quota</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listquota /hyl</span><br></pre></td></tr></table></figure>



<h4 id="delquota"><a href="#delquota" class="headerlink" title="delquota"></a>delquota</h4><p>删除quota</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delquota [-n|-b] path </span><br></pre></td></tr></table></figure>



<h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>列出历史命令</p>
<h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><p>重新执行指定编号的历史命令 (编号可以通过history命令查看)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redo 10</span><br></pre></td></tr></table></figure>



<h2 id="Zookeeper-Watcher"><a href="#Zookeeper-Watcher" class="headerlink" title="Zookeeper Watcher"></a>Zookeeper Watcher</h2><ul>
<li>ZooKeeper提供了<strong>分布式数据发布/订阅</strong>功能，一个典型的发布/订阅模型系统定义了一对多的订阅关系，能让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使他们能够做出相应的处理。</li>
<li>ZooKeeper中，引入了Watcher机制来实现这种分布式的通知功能。</li>
<li>Zookeeper允许客户端向服务端注册一个 Watcher监听，当服务端的一些事件触发了这个Watcher，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。</li>
<li>触发事件种类很多，如：节点创建，节点删除，节点改变，子节点改变等。</li>
</ul>
<p>总的来说可以概括 Watcher为以下三个过程：</p>
<ol>
<li>客户端向服务端注册 Watcher、</li>
<li>服务端事件发生触发  Watcher、</li>
<li>客户端回 Watcher得到触发事件情况</li>
</ol>
<h3 id="watch机制特点"><a href="#watch机制特点" class="headerlink" title="watch机制特点"></a>watch机制特点</h3><ul>
<li><p>一次性触发 : 事件发生触发监听，一个 watcher  event就会被发送到设置监听的客户端这种效果是一次性的，后续再次发生同样的事件，不会再次触发。</p>
</li>
<li><p>事件封装 :  ZooKeeper使用 WatchedEvent对象来封装服务端事件并传递。</p>
<blockquote>
<p>WatchedEvent包含了每一个事件的三个基本属性：</p>
<p><code>通知状态</code>（keeperstate），<code>事件类型</code>（EventType）和<code>节点路径</code>（path）</p>
</blockquote>
</li>
<li><p>event异步发送 : watcher的通知事件从服务端发送到客户端是异步的。</p>
</li>
<li><p>先注册再触发 : Zookeeper中的 watch机制，必须客户端先去服务端注册监听，这样事件发才会触发监听，通知给客户端</p>
</li>
</ul>
<h3 id="通知状态和事件类型"><a href="#通知状态和事件类型" class="headerlink" title="通知状态和事件类型"></a>通知状态和事件类型</h3><p>同一个事件类型在不同的通知状态中代表的含义有所不同，下表列举了常见的通知状态和事件类型。</p>
<p><img src="/images/1593944966320.png" alt="1593944966320"></p>
<p>其中<code>连接状态事件</code>（type=None,path=nul1）不需要客户端注册，客户端只要有需要直接处理就行了。</p>
<h3 id="Shell-客户端设置Watcher"><a href="#Shell-客户端设置Watcher" class="headerlink" title="Shell 客户端设置Watcher"></a>Shell 客户端设置Watcher</h3><p>设置节点数据变动监听 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /hyl watch</span><br></pre></td></tr></table></figure>

<p>通过另一个客户端更改节点数据 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> /hyl 123</span><br></pre></td></tr></table></figure>

<p>此时设置监听的节点收到通知 : </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WATCHER:</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/hyl</span><br><span class="line">get /hyl watch</span><br><span class="line">123</span><br></pre></td></tr></table></figure>



<h2 id="Zookeeper的选举机制"><a href="#Zookeeper的选举机制" class="headerlink" title="Zookeeper的选举机制"></a>Zookeeper的选举机制</h2><p>zookeeper默认的算法是<code>Fast Leader Election</code>，采用<strong>投票数大于半数则胜出</strong>的逻辑</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>服务器ID : </p>
<ul>
<li>比如有三台服务器，编号分别是1，2，3</li>
<li>编号越大在选择算法中的权重越大。</li>
</ul>
</li>
<li><p>选举状态 : </p>
<ul>
<li>LOOKING，竞选状态。</li>
<li>FOLLOWING，随从状态，同步leader状态，参与投票。</li>
<li>OBSERVING，观察状态，同步leader状态，不参与投票</li>
<li>LEADING，领导者状态，</li>
</ul>
</li>
<li><p>数据ID : </p>
<ul>
<li>服务器中存放的最新数据version</li>
<li>值越大说明数据越新，在选举算法中数据越新权重越大</li>
</ul>
</li>
<li><p>逻辑时钟 : </p>
<ul>
<li>也叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。</li>
<li>比如说某台服务器在投票过程中掉线了 , 导致逻辑时钟比别人小 , 那么参与下次投票时 , 这台服务器的权重就会降低 (这是自然的,你都经常掉线了,还怎么当leader)</li>
</ul>
</li>
</ul>
<h3 id="全新集群选举"><a href="#全新集群选举" class="headerlink" title="全新集群选举"></a>全新集群选举</h3><ol>
<li>每个机器都给自己投票</li>
<li>按票数过半则选举法束</li>
</ol>
<p>假设目前有5台服务器，每台服务器均没有数据，它们的编号分别是1，2，3，4，5，按编号依次启动，它们的选择举过程如下：</p>
<ul>
<li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到馈信息，服务器1的状态一直属于 Looking</li>
<li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大，所以服务器2胜出，但此时投票数没有大于半数所以两个服务器的状态依然是LO0KING</li>
<li>服务器3启动，给自己投票，同时与之前启动的服务器1，2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1，2成为小弟。</li>
<li>服务器4启动，给自己投票，同时与之前启动的服务器1，2，3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。</li>
<li>服务器5启动，后面的逻辑同服务器4成为小弟</li>
</ul>
<h3 id="非全新集群选举"><a href="#非全新集群选举" class="headerlink" title="非全新集群选举"></a>非全新集群选举</h3><p>对于运行正常的  zookeeper集群，中途有机器down掉，需要重新选举时，选举过程就需要加入数据ID、服务器ID和逻辑时钟</p>
<ul>
<li>数据ID：数据越新,其versIon就越大，数据每次更新都会更新version . 也就是说 , 数据ID越大 , 说明该服务器保存的数据就越新</li>
<li>服务器ID：就是我们配置的myid中的值，每个机器一个。</li>
<li>逻辑时钟：这个值从0开始递增，每次选举对应一个值。如果在同一次选举中，这个值是一致的。</li>
</ul>
<p>这样选举的标准就变成：</p>
<ol>
<li>逻辑时钟小的选举结果被忽略，重新投票；</li>
<li>统一逻辑时钟后，数据id大的胜出</li>
<li>数据id相同的情况下，服务器id大的胜出</li>
</ol>
<h2 id="Zookeeper的典型应用"><a href="#Zookeeper的典型应用" class="headerlink" title="Zookeeper的典型应用"></a>Zookeeper的典型应用</h2><h3 id="数据发布与订阅-配置中心"><a href="#数据发布与订阅-配置中心" class="headerlink" title="数据发布与订阅(配置中心)"></a>数据发布与订阅(配置中心)</h3><ul>
<li>发布与订阅模型，即所谓的配置中心，顾名思义就是<strong>发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新</strong>。</li>
<li>应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个  Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。比如：<ul>
<li>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在ZK的一些指定节点，供各个客户端订阅使用。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：适合数据量很小的场景，这样数据更新可能会比较快</p>
</blockquote>
<h3 id="命名服务-Naming-Service"><a href="#命名服务-Naming-Service" class="headerlink" title="命名服务(Naming Service)"></a>命名服务(Naming Service)</h3><ul>
<li>在分布式系统中，<strong>通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息</strong>。</li>
<li>被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等一一这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称</li>
<li>阿里巴巴集团开源的分布式服务框架 Dubbo中使用 Zookeeper来作为其命名服务，维护全局的服务地址列表</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul>
<li><p>分布式锁，这个主要得益于  Zookeeper保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p>
</li>
<li><p>所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过 create znode的方式来实现。所有客户端都去创建/distribute_lock节点，最终成功创建的那个客户端也即拥有了这把锁。</p>
</li>
<li><p>控制时序，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里/distribute_lock已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode。EPHEMERAL_SEQUENTIAL来指定），Zk的父节点（/distribute_lock）维持一份  sequence，保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
</li>
</ul>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>