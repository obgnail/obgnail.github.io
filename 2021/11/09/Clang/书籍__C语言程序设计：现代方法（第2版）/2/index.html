<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;结构成员在内存中是按照声明的顺序存储的，成员之间没有间隙&quot;&gt;&lt;a href=&quot;#结构成员在内存中是按照声明的顺序存储的，成员之间没有间隙&quot; class=&quot;headerlink&quot; title=&quot;结构成员在内存中是按照声明的顺序存储的，成员之间没有间隙&quot;&gt;&lt;/a&gt;结构成员在内存中是按照声明的顺序存储的，成员之间没有间隙&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; name[NAME_LEN+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; on_hand;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; part1, part2;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;现在假设&lt;code&gt;NAME_LEN&lt;/code&gt; 的值为25"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>2 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Clang/" rel="tag">Clang</a></div><div class="post-time">2021-11-09</div></div></div><div class="container post-header"><h1>2</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E6%8C%89%E7%85%A7%E5%A3%B0%E6%98%8E%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%8C%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E6%B2%A1%E6%9C%89%E9%97%B4%E9%9A%99"><span class="toc-number">1.</span> <span class="toc-text">结构成员在内存中是按照声明的顺序存储的，成员之间没有间隙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%94%AF%E6%8C%81%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">结构体支持直接赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E8%81%94%E5%90%88%E4%BD%93%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">结构体与联合体在内存上区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E4%BD%93%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97"><span class="toc-number">4.</span> <span class="toc-text">联合体，结构体嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">联合体数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E8%81%94%E5%90%88%E6%B7%BB%E5%8A%A0%E2%80%9C%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5%E2%80%9D"><span class="toc-number">6.</span> <span class="toc-text">为联合添加“标记字段”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E6%B4%9E"><span class="toc-number">7.</span> <span class="toc-text">内存空洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">8.</span> <span class="toc-text">动态存储分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">9.</span> <span class="toc-text">内存泄露</span></a></li></ol></details></div><div class="container post-content"><h3 id="结构成员在内存中是按照声明的顺序存储的，成员之间没有间隙"><a href="#结构成员在内存中是按照声明的顺序存储的，成员之间没有间隙" class="headerlink" title="结构成员在内存中是按照声明的顺序存储的，成员之间没有间隙"></a>结构成员在内存中是按照声明的顺序存储的，成员之间没有间隙</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> number;</span><br><span class="line">  <span class="keyword">char</span> name[NAME_LEN+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> on_hand;</span><br><span class="line">&#125; part1, part2;</span><br></pre></td></tr></table></figure>

<p>现在假设<code>NAME_LEN</code> 的值为25</p>
<p><img src="/images/image-20211108192427769.png" alt="image-20211108192427769"></p>
<h3 id="结构体支持直接赋值"><a href="#结构体支持直接赋值" class="headerlink" title="结构体支持直接赋值"></a>结构体支持直接赋值</h3><p>数组不能用<code>=</code> 运算符进行复制，但是struct支持。</p>
<p>一些程序员利用这种性质来产生“空”结构，以封装稍候将进行复制的数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> a[<span class="number">10</span>]; &#125; a1, a2;</span><br><span class="line">a1 = a2; </span><br></pre></td></tr></table></figure>



<h3 id="结构体与联合体在内存上区别"><a href="#结构体与联合体在内存上区别" class="headerlink" title="结构体与联合体在内存上区别"></a>结构体与联合体在内存上区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">&#125; s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">&#125; u;</span><br></pre></td></tr></table></figure>

<p>结构变量<code>s</code> 和联合变量<code>u</code> 只有一处不同：<code>s</code> 的成员存储在<strong>不同</strong> 的内存地址中，而<code>u</code> 的成员存储在<strong>同一</strong> 内存地址中。下面是<code>s</code> 和<code>u</code> 在内存中的存储情况（假设<code>int</code> 类型的值要占用4个字节内存，而<code>double</code> 类型的值占用8个字节）：</p>
<p><img src="/images/image-20211109122833782.png" alt="image-20211109122833782"></p>
<p>在结构变量<code>s</code> 中，成员<code>i</code> 和<code>d</code> 占有不同的内存单元。<code>s</code> 总共占用了12个字节。在联合变量<code>u</code> 中，成员<code>i</code> 和<code>d</code> 互相交迭（<code>i</code> 实际上是<code>d</code> 的前4个字节），所以<code>u</code> 只占用了8个字节；此外，<code>i</code> 和<code>d</code> 具有相同的地址。</p>
<h3 id="联合体，结构体嵌套"><a href="#联合体，结构体嵌套" class="headerlink" title="联合体，结构体嵌套"></a>联合体，结构体嵌套</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">catalog_item</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> stock_number;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">int</span> item_type;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">char</span> title[TITLE_LEN+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">char</span> author[AUTHOR_LEN+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> num_pages;</span><br><span class="line">    &#125; book;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">char</span> design[DESIGN_LEN+<span class="number">1</span>];</span><br><span class="line">    &#125; mug;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">char</span> design[DESIGN_LEN+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> colors;</span><br><span class="line">      <span class="keyword">int</span> sizes;</span><br><span class="line">    &#125; shirt;</span><br><span class="line">  &#125; item;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="联合体数组"><a href="#联合体数组" class="headerlink" title="联合体数组"></a>联合体数组</h3><p>创建含有不同类型的混合数据的数据结构。现在假设需要数组的元素是<code>int</code> 值和<code>double</code> 值的混合。因为数组的元素必须是相同的类型，所以好像不可能产生如此类型的数组。但是，利用联合这件事就相对容易了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line">Number number_array[<span class="number">1000</span>];</span><br><span class="line">number_array[<span class="number">0</span>].i = <span class="number">5</span>;</span><br><span class="line">number_array[<span class="number">1</span>].d = <span class="number">8.395</span>;</span><br></pre></td></tr></table></figure>



<h3 id="为联合添加“标记字段”"><a href="#为联合添加“标记字段”" class="headerlink" title="为联合添加“标记字段”"></a>为联合添加“标记字段”</h3><p>联合所面临的主要问题是：不容易确定联合最后改变的成员，因此所包含的值可能是无意义的。</p>
<p>为了记录此信息，可以把联合嵌入一个结构中，且此结构还含有另一个成员：“标记字段”或者“判别式”，它是用来提示当前存储在联合中的内容的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_KIND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOUBLE_KIND 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> kind;   <span class="comment">/* tag field */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; Number;</span><br><span class="line"></span><br><span class="line">n.kind = INT_KIND;</span><br><span class="line">n.u.i = <span class="number">82</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(Number n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n.kind == INT_KIND)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n.u.i);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%g&quot;</span>, n.u.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="内存空洞"><a href="#内存空洞" class="headerlink" title="内存空洞"></a>内存空洞</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125; s;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>char</code> 类型的值占有1个字节，而<code>int</code> 类型值占用4个字节，<code>s</code> 会是多大呢？显而易见的答案（5个字节）不一定正确。</li>
<li>一些计算机要求特定数据项的地址是某个字节数（一般是2个、4个或8个字节，由数据项的类型决定）的倍数。为了满足这一要求，编译器会在邻近的成员之间留“空洞”（即不使用的字节），从而使结构的成员“对齐”。</li>
<li>如果假设数据项必须从4个字节的倍数开始，那么结构<code>s</code> 的成员<code>a</code> 后面将有3个字节的空洞，从而<code>sizeof(s)</code> 为8。</li>
</ul>
<p>顺便说一句，就像在成员间有空洞一样，结构也可以在末尾有空洞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">char</span> b;</span><br><span class="line">&#125; s;</span><br></pre></td></tr></table></figure>

<p>可能在成员<code>b</code> 的后边有3个字节的空洞。</p>
<p>这就能解释为什么<strong>使用<code>==</code> 来判定两个结构是否相等是不合法的？</strong></p>
<ul>
<li>逐个比较结构成员将是极没有效率的。比较结构中的全部字节是相对较好的方法（许多计算机有专门的指令可以用来快速执行此类比较）。</li>
<li>然而，如果结构中含有空洞，那么比较字节会产生不正确的结果。即使对应的成员有同样的值，空洞中的废弃值也可能会不同。</li>
<li>这个问题可以通过下列方法解决，那就是编译器要确保空洞始终包含相同的值（比如零）。然而，初始化空洞会影响全部使用结构的程序的性能，所以它是不可行的。</li>
</ul>
<h3 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h3><ul>
<li>数组长度是固定的，无论如何增大数组，始终有可能填满数组。</li>
<li>幸运的是，还有别的办法。C语言支持<code>动态存储分配</code> ，即<strong>在程序执行期间分配内存单元的能力</strong>。</li>
<li>利用动态存储分配，可以设计出能根据需要扩大（和缩小）的数据结构。</li>
</ul>
<p>内存分配函数：</p>
<ul>
<li><code>malloc</code> 函数——分配内存块，但是不对内存块进行初始化。</li>
<li><code>calloc</code> 函数——分配内存块，并且对内存块进行清零。</li>
<li><code>realloc</code> 函数——调整先前分配的内存块大小。</li>
</ul>
<p>为了申请内存块，去调用内存分配函数时，由于函数无法知道计划存储在内存块中的数据是什么类型的，所以它不能返回<code>int</code> 类型、<code>char</code> 类型等普通类型的指针。取而代之的，函数会返回<code>void *</code> 类型的值。<code>void *</code> 类型的值是“通用”指针，本质上它只是内存地址。</p>
<p>当调用内存分配函数时，总存在这样的可能性：<strong>找不到满足我们需要的足够大的内存块</strong>。如果真的发生了这类问题，函数会返回<strong>空指针</strong> （null pointer）。所以在把函数的返回值存储到指针变量中以后，需要判断该指针变量是否为空指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">/* allocation failed;  take appropriate action  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用malloc可以让函数返回一个全新的字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不改变s1和s2，将s1和s2连接，形成新的字符串并返回</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">concat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *result ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `malloc` 函数分配`size` 个字节的内存块，并且返回指向该内存块的指针。</span></span><br><span class="line">  result = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s1) + <span class="built_in">strlen</span>(s2) + <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">NULL</span>)  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error: malloc failed in concat\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span> (EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(result, s1);</span><br><span class="line">  <span class="built_in">strcat</span>(result, s2);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 当不再需要concat函数返回的字符串p时，需要调用free函数来释放它占用的空间。</span></span><br><span class="line">p = concat(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(...);</span><br><span class="line">q = <span class="built_in">malloc</span>(...);</span><br><span class="line">p = q;</span><br></pre></td></tr></table></figure>

<p>在执行完前两条语句后，<code>p</code> 指向了一个内存块，而<code>q</code> 指向了另一个内存块：</p>
<p><img src="/images/image-20211109163327988.png" alt="image-20211109163327988"></p>
<p>在把<code>q</code> 赋值给<code>p</code> 之后，两个指针现在都指向了第二个内存块：</p>
<p><img src="/images/image-20211109163345781.png" alt="image-20211109163345781"></p>
<p>因为没有指针指向第一个内存块，所以再也不能使用此内存块了。</p>
<p>概念也频繁出现在链式数据结构中</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>