<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;C语言的编译链接过程&quot;&gt;&lt;a href=&quot;#C语言的编译链接过程&quot; class=&quot;headerlink&quot; title=&quot;C语言的编译链接过程&quot;&gt;&lt;/a&gt;C语言的编译链接过程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文件是一个外存的概念，文件只存在于&lt;code&gt;外存&lt;/code&gt;（硬盘，U盘，网盘）中，文件由两部分构成：文件名和文件主体。&lt;/li&gt;
&lt;li&gt;文件的分类分为：&lt;ul&gt;
&lt;li&gt;可执行文件：可执行文件由指令和数据构成；Linux是靠文件属性来判断判断是否可执行。&lt;/li&gt;
&lt;li&gt;不可执行文件：不可执行文件：其内容是由数据构成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/image-20211030092559717.png&quot; alt=&quot;image-20211030092559717&quot;&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>C语言基础补充 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Clang/" rel="tag">Clang</a></div><div class="post-time">2021-11-21</div></div></div><div class="container post-header"><h1>C语言基础补充</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">C语言的编译链接过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">声明与定义的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">为什么使用可移植类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define%E5%AE%9A%E4%B9%89%E5%AE%8F%E5%B8%B8%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">#define定义宏常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.</span> <span class="toc-text">#include的本质是拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8Achar%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88%E5%AD%98%E6%94%BE%E4%B8%AD%E6%96%87"><span class="toc-number">6.</span> <span class="toc-text">解释char类型指针存放中文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">7.</span> <span class="toc-text">可见性和生存期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E6%94%B9%E5%8F%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">8.</span> <span class="toc-text">static关键字改变变量的可见性和生存期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof%E6%98%AF%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E4%BC%9A%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%A2%AB%E4%BF%AE%E9%A5%B0%E6%8E%89"><span class="toc-number">9.</span> <span class="toc-text">sizeof是关键字，会在编译时被修饰掉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E5%AE%9A%E4%B9%89%E5%B8%B8%E5%8F%98%E9%87%8F"><span class="toc-number">10.</span> <span class="toc-text">const定义常变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E5%8F%98%E9%87%8F%E5%92%8Cdefine%E5%AE%8F%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9"><span class="toc-number">10.1.</span> <span class="toc-text">常变量和define宏怎么选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#register%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">register关键字的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">12.</span> <span class="toc-text">左值&#x2F;右值的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">13.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82"><span class="toc-number">13.1.</span> <span class="toc-text">指针占多少字节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%80%E5%88%87%E5%90%88%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%98%E6%88%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.</span> <span class="toc-text">typedef可以将一切合法的定义变成类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">15.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">15.1.</span> <span class="toc-text">字符串和字符数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">15.2.</span> <span class="toc-text">指针数组和数组指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3"><span class="toc-number">16.</span> <span class="toc-text">指针详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E3%80%81%E7%A9%BA%E6%8C%87%E9%92%88%E3%80%81%E5%A4%B1%E6%95%88%E6%8C%87%E9%92%88"><span class="toc-number">16.1.</span> <span class="toc-text">野指针、空指针、失效指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">16.2.</span> <span class="toc-text">指针类型的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">16.3.</span> <span class="toc-text">类型对指针解引用的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%B8%B8%E9%87%8F"><span class="toc-number">16.4.</span> <span class="toc-text">地址常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E4%B8%8E%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">16.5.</span> <span class="toc-text">const与指针变量的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">16.6.</span> <span class="toc-text">指针和数组的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">16.7.</span> <span class="toc-text">void指针变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.8.</span> <span class="toc-text">void与泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">16.9.</span> <span class="toc-text">二级指针简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%B9%B6%E4%B8%8D%E6%98%AF%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88"><span class="toc-number">16.10.</span> <span class="toc-text">二维数组并不是二级指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%98%AF%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">16.11.</span> <span class="toc-text">二维数组是数组指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">16.12.</span> <span class="toc-text">指针与二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E6%98%AF%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88"><span class="toc-number">16.13.</span> <span class="toc-text">指针数组是二级指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E7%BB%93%E6%9E%84%E5%8C%B9%E9%85%8D%E7%9A%84%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.14.</span> <span class="toc-text">各种结构匹配的指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">16.15.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.16.</span> <span class="toc-text">使用函数指针实现泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">16.17.</span> <span class="toc-text">使用函数指针实现装饰器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">17.</span> <span class="toc-text">数值的存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">17.1.</span> <span class="toc-text">溢出的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A1%A5%E7%A0%81%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">17.2.</span> <span class="toc-text">为什么使用补码存储数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-number">17.3.</span> <span class="toc-text">小端存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%A6%E8%A7%A3"><span class="toc-number">18.</span> <span class="toc-text">类型转换详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%85%85%EF%BC%88%E5%B0%8F%E8%BD%AC%E5%A4%A7%EF%BC%89"><span class="toc-number">18.1.</span> <span class="toc-text">扩充（小转大）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%AA%E5%8F%96%EF%BC%88%E5%A4%A7%E8%BD%AC%E5%B0%8F%EF%BC%89"><span class="toc-number">18.2.</span> <span class="toc-text">截取（大转小）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">18.3.</span> <span class="toc-text">隐式转化的四种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">18.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%82%A8%E5%AD%98"><span class="toc-number">19.</span> <span class="toc-text">浮点数的储存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B%E7%9A%84%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">19.1.</span> <span class="toc-text">二进制下的科学计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#double%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">19.2.</span> <span class="toc-text">double类型的内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%98%AF%E4%B8%8D%E7%B2%BE%E5%87%86%E7%9A%84"><span class="toc-number">19.3.</span> <span class="toc-text">什么有些浮点型是不精准的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">19.4.</span> <span class="toc-text">整型和浮点型的内存结构对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%BC%BA%E8%BD%AC%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">20.</span> <span class="toc-text">类型强转的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E4%B8%8E%E5%A4%A7%E5%B0%8F"><span class="toc-number">21.</span> <span class="toc-text">结构体对齐与大小</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="toc-number">21.1.</span> <span class="toc-text">为什么要进行字节对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E7%9A%843%E6%9D%A1%E8%A7%84%E5%88%99"><span class="toc-number">21.2.</span> <span class="toc-text">计算结构体大小的3条规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AF%B9%E9%BD%90%E5%80%BC"><span class="toc-number">21.3.</span> <span class="toc-text">指定对齐值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">21.4.</span> <span class="toc-text">快速判断结构体的成员偏移量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F"><span class="toc-number">21.5.</span> <span class="toc-text">位域</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="C语言的编译链接过程"><a href="#C语言的编译链接过程" class="headerlink" title="C语言的编译链接过程"></a>C语言的编译链接过程</h2><ul>
<li>文件是一个外存的概念，文件只存在于<code>外存</code>（硬盘，U盘，网盘）中，文件由两部分构成：文件名和文件主体。</li>
<li>文件的分类分为：<ul>
<li>可执行文件：可执行文件由指令和数据构成；Linux是靠文件属性来判断判断是否可执行。</li>
<li>不可执行文件：不可执行文件：其内容是由数据构成。</li>
</ul>
</li>
</ul>
<p><img src="/images/image-20211030092559717.png" alt="image-20211030092559717"></p>
<h2 id="声明与定义的区别"><a href="#声明与定义的区别" class="headerlink" title="声明与定义的区别"></a>声明与定义的区别</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = a + b;</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的调用</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> z = add_int(x, y);</span><br></pre></td></tr></table></figure>

<p><code>声明</code>：有两重含义，如下：</p>
<ul>
<li>第一重含义：告诉编译器，这个名字已经匹配到一块内存上了。</li>
<li>第二重含义：告诉编译器，我这个名字我先预定了，别的地方再也不能用它来作为变量名。</li>
</ul>
<blockquote>
<p>声明对应的是<code>编译链接过程</code>。</p>
</blockquote>
<p><code>定义</code>：为这个变量分配一块内存并给它取上一个名字，这个名字就是我们经常所说的变量名。</p>
<p>但注意，这个名字一旦和这块内存匹配起来，它们就同生共死，终生不离不弃，并且这块内存的位置也不能被改变。一个变量在一定的区域内（比如函数内，全局等）只能被定义一次，如果定义多次，编译器会提示你重复定义同一个变量或对象。</p>
<blockquote>
<p>定义和声明最重要的区别：<strong>定义创建了对象并为这个对象一块内存，而声明的时候是没有分配内存空间的</strong>。</p>
</blockquote>
<h2 id="为什么使用可移植类型"><a href="#为什么使用可移植类型" class="headerlink" title="为什么使用可移植类型"></a>为什么使用可移植类型</h2><p>C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的，无法提前知道它们到底占用多少个字节。</p>
<table>
<thead>
<tr>
<th></th>
<th>char</th>
<th>short</th>
<th>int</th>
<th>long</th>
</tr>
</thead>
<tbody><tr>
<td>32 位机</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>64 位机</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。</span></span><br><span class="line"><span class="comment">// int8_t：8位有符号整数。</span></span><br><span class="line"><span class="comment">// int16_t：16位有符号整数。</span></span><br><span class="line"><span class="comment">// int32_t：32位有符号整数。</span></span><br><span class="line"><span class="comment">// int64_t：64位有符号整数。</span></span><br><span class="line"><span class="comment">// uint8_t：8位无符号整数。</span></span><br><span class="line"><span class="comment">// uint16_t：16位无符号整数。</span></span><br><span class="line"><span class="comment">// uint32_t：32位无符号整数。</span></span><br><span class="line"><span class="comment">// uint64_t：64位无符号整数。</span></span><br><span class="line"><span class="keyword">int32_t</span> x32 = <span class="number">45933945</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x32 = %d\n&quot;</span>, x32);</span><br></pre></td></tr></table></figure>



<h2 id="define定义宏常量"><a href="#define定义宏常量" class="headerlink" title="#define定义宏常量"></a><code>#define</code>定义宏常量</h2><p>用<code>#define</code>定义的宏常量：可以用<code>#define</code>定义一个标识符来表示一个常量。其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。<strong>本质是字符串替换</strong>。</p>
<p>也因为本质是字符串替换，所以也不会开辟内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 100</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = LEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也能解释为什么宏常量的定义后面不能添加分号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = LEN;</span><br><span class="line"><span class="comment">// 正常情况下，LEN会被替换成100，得到下面结果:</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果宏常量定义时添加分号，得到下面结果，编译不通过</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;;</span><br></pre></td></tr></table></figure>



<h2 id="include的本质是拷贝"><a href="#include的本质是拷贝" class="headerlink" title="#include的本质是拷贝"></a><code>#include</code>的本质是拷贝</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span> <span class="comment">// 本质就是把test.h的内容全部拷贝到main.c</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为本质是拷贝，所以如果导入多次的话就会出现问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span> <span class="comment">// error: previous definition of &#x27;add&#x27; was here</span></span></span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_H</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>但是这样并不能真正的解决问题。如果有两个.c文件都include了test.h，他们都生成了一个obj文件。等到链接过程时就将这两个obj文件进行链接，此时一样会出现重复定义的问题。</p>
<p>因此真正的解决方案就是：<strong>只在.h声明变量，具体定义放到其他文件中</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_H</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解释char类型指针存放中文"><a href="#解释char类型指针存放中文" class="headerlink" title="解释char类型指针存放中文"></a>解释char类型指针存放中文</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = <span class="string">&quot;春天春天春天春天春天春天春天春天春天春天春天&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); <span class="comment">// 春天春天春天春天春天春天春天春天春天春天春天</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(s)); <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>char *s=“春天春天春天春天春天春天春天春天春天春天春天”;</code>这个语句完成的是：</p>
<ol>
<li>定义一个<code>char *s</code>，申请空间分配内存；</li>
<li>申请空间存储 “春天春天春天春天春天春天春天春天春天春天春天”；</li>
<li>把 “春天春天春天春天春天春天春天春天春天春天春天” 的首地址赋值给 s；</li>
</ol>
<p>这样就能解释为什么不管字符串多长，<code>sizeof(s)</code>永远是8</p>
<p>如果不使用char类型指针，那么数组长度必须大于字符串的字节长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// &quot;我真的真的真的好爱中国&quot;长达34字节，所以数组p的长度必须大于等于34</span></span><br><span class="line">  <span class="keyword">char</span> p[<span class="number">34</span>] = <span class="string">&quot;我真的真的真的好爱中国&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(p);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n); <span class="comment">// 34</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p); <span class="comment">// 我真的真的真的好爱中国</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="可见性和生存期"><a href="#可见性和生存期" class="headerlink" title="可见性和生存期"></a>可见性和生存期</h2><p><img src="/images/image-20211030131357194.png" alt="image-20211030131357194"></p>
<p><img src="/images/1-15030412404Q30.png" alt="img"></p>
<table>
<thead>
<tr>
<th>内存分区</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序代码区(code area)</td>
<td align="left">存放函数体的二进制代码</td>
</tr>
<tr>
<td>静态数据区(data area)</td>
<td align="left">也称全局数据区，包含的数据类型比较多，如全局变量、静态变量、一般常量、字符串常量。其中：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。常量数据（一般常量、字符串常量）存放在另一个区域。 注意：静态数据区的内存在程序结束后由操作系统释放。</td>
</tr>
<tr>
<td>堆区(heap area)</td>
<td align="left">一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。<a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/html/137.html">malloc()</a>、<a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/html/134.html">calloc()</a>、<a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/html/135.html">free()</a> 等函数操作的就是这块内存，这也是本章要讲解的重点。  注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。</td>
</tr>
<tr>
<td>栈区(stack area)</td>
<td align="left">由系统自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。</td>
</tr>
<tr>
<td>命令行参数区</td>
<td align="left">存放命令行参数和环境变量的值，如通过main()函数传递的值。</td>
</tr>
</tbody></table>
<p>当<code>进程</code>在执行的时候，需要为其分配两种资源：</p>
<ul>
<li>CPU资源</li>
<li>内存资源。其中内存资源又分成了四个部分<ul>
<li>代码区</li>
<li>数据区</li>
<li>堆区</li>
<li>栈区</li>
</ul>
</li>
</ul>
<p><code>可见性（作用域）</code>：标识符能够被使用的范围，也就是说只有在作用域内标识符才可以被使用。<strong>此阶段针对编译和链接过程</strong>。</p>
<ul>
<li>函数中定义的标识符，包括形参和函数体中定义的局部变量，作用域都在该函数内，也称作函数域。</li>
<li>文件作用域也称全局作用域。定义在所有函数之外的标识符，具有文件作用域。作用域为从定义处到整<br>个源文件结束。文件中定义的全局变量和函数都具有文件作用域。</li>
</ul>
<p><code>生存期（生命期，Lifetime）</code>：生命期指的是标识符从程序开始运行时被创建，具有存储空间，到程序运行结束时消亡，释放存储空间的时间段。<strong>此阶段针对的是程序的执行过程</strong>。</p>
<ul>
<li>局部变量的生存期是：函数被调用时，为其分配存储空间，到函数执行结束，存储空间释放。存储在.stack区。</li>
<li>全局变量的生存期是：从程序执行前开始，到执行后结束。存储在.data区。</li>
<li>动态生命期是：标识符由特定的函数调用或运算来创建和释放，如调用malloc()为变量分配存储空间变量的生命期开始，而调用free()释放空间或程序结束时，变量生命期结束。具有动态生命期的变量。存储在堆区heap。</li>
</ul>
<blockquote>
<ul>
<li>编译时，检查变量的作用域。</li>
<li>执行时，检查变量的生存期。</li>
</ul>
</blockquote>
<p>解释下面代码为什么执行失败？对于g_max是全局变量，第六行代码<code>c=g_max</code>可以直接去.data区获取g_max的数据，那为什么会报错呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = a + b;</span><br><span class="line">  c = g_max;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_max = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = add_int(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因很简单：</p>
<ul>
<li><code>编译 – 执行</code>是有先后关系的，只有先编译成功，生成可执行文件了，之后才能执行。</li>
<li>在编译的时候，检查g_max的作用域的时候失败了，自然没有生成可执行文件。</li>
</ul>
<blockquote>
<p>总结：变量只有同时保证<code>作用域</code>和<code>生存期</code>没有问题才能执行，一旦作用域出现问题，自然无法生成可执行文件，就走不到检查生存期的步骤了。</p>
</blockquote>
<h2 id="static关键字改变变量的可见性和生存期"><a href="#static关键字改变变量的可见性和生存期" class="headerlink" title="static关键字改变变量的可见性和生存期"></a>static关键字改变变量的可见性和生存期</h2><p>static关键字修饰变量和函数。</p>
<ul>
<li><p>局部变量：当函数第一被调用，函数中的静态局部变量被初始化，再次调用这个函数，这个static变量也不会再次被初始化，仍是保存的前一次函数调用时的结果。（<strong>作用域不变，生存期改变</strong>）</p>
<blockquote>
<p>实际上，变量后static修饰后，就从.stack区移动到了.data区。所以该变量的生存期变成整个程序的执行时间。</p>
</blockquote>
</li>
<li><p>全局变量：static说明的全局变量只可以在当前c程序文件中使用（<strong>作用域受到限制，生存期不变</strong>）。</p>
</li>
<li><p>函数：static说明的函数只可以在当前c程序文件中使用（<strong>作用域受到限制，生存期不变</strong>）。</p>
</li>
</ul>
<h2 id="sizeof是关键字，会在编译时被修饰掉"><a href="#sizeof是关键字，会在编译时被修饰掉" class="headerlink" title="sizeof是关键字，会在编译时被修饰掉"></a>sizeof是关键字，会在编译时被修饰掉</h2><p>sizeof是关键字，sizeof的结果<strong>只和参数的类型有关</strong>，所以在编译的时候就可以确定大小。实际上也是在编译的时候就返回了大小，在实际运行代码的时候，是没有sizeof的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="comment">// 编译时，发现++a是int类型，所以在编译的时候，x就已经确定是4。</span></span><br><span class="line">  <span class="comment">// 也就是说，x=sizeof(++a);在编译后，直接就被替换成x=4;</span></span><br><span class="line">  x = <span class="keyword">sizeof</span>(++a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">//  4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="const定义常变量"><a href="#const定义常变量" class="headerlink" title="const定义常变量"></a>const定义常变量</h2><p>下面的x为变量，但是添加了const修饰词，使之不能被修改。像这样的不能被修改值的变量，我们称之为<code>常变量</code>。</p>
<p>注意：虽说不能修改值，但是x依旧是变量，不能像字面常量来使用，所以下面的代码是错误的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[x]; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>



<h3 id="常变量和define宏怎么选择"><a href="#常变量和define宏怎么选择" class="headerlink" title="常变量和define宏怎么选择"></a>常变量和define宏怎么选择</h3><ul>
<li><strong>常变量在编译时替换，所以有完整的类型检查。define在预编译时替换</strong>。</li>
<li>const定义的是变量，而宏定义的是常量，所以const定义的对象有数据类型，而宏定义的对象没有数据类型。所以编译器可以对前者进行类型安全检查，而对后者只是机械地进行字符替换，没有类型安全检查。这样就很容易出现<code>边际问题</code>和<code>括号问题</code>。</li>
<li>有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</li>
<li>所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用cons和define都可以的情况下<strong>尽量使用常变量来取代宏。</strong></li>
</ul>
<h2 id="register关键字的限制"><a href="#register关键字的限制" class="headerlink" title="register关键字的限制"></a>register关键字的限制</h2><p>register这个关键字<strong>建议编译器尽可能的将变量存在CPU内部寄存器中而不是通过内存寻址访问</strong>以提高效率，如果一个变量被register来修饰，就意味着该变量作为一个寄存器变量，让该变量的访问速度达到最快。</p>
<p>使用register修饰符有几点限制：</p>
<ul>
<li>register变量必须是能被CPU所接受的类型。<br>这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。</li>
<li>因为register变量可能不存放在内存中，所以不能用<code>&amp;</code>来获取register变量的地址。</li>
<li>只有局部变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。<br>在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。</li>
<li>局部静态变量不能定义为寄存器变量。不能写成：<code>register static int a</code>；</li>
<li>由于寄存器的数量有限（不同的gpu寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。</li>
</ul>
<h2 id="左值-右值的理解"><a href="#左值-右值的理解" class="headerlink" title="左值/右值的理解"></a>左值/右值的理解</h2><ul>
<li>以赋值符号<code>=</code>为界，<code>=</code>左边的就是左值(L-value)，<code>=</code>右边就是右值(R-value)。</li>
<li>可以将L-value的L理解成Location，表示可寻址。R-value中的R指的是Read，表示可读。</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>内存：</p>
<ul>
<li>是<strong>外存（硬盘）与CPU进行沟通的桥梁</strong>。计算机中所有程序的运行都是在内存中进行，</li>
<li><strong>为了有效的使用内存，就把内存以8位二进制（bit）划分为存储单元</strong>（也就是1字节）。</li>
<li>为了有效的访问到内存的每个存储单元，就给内存存储单元进行了编号，这些编号被称为该内存存储单元的<code>地址</code>。</li>
</ul>
<blockquote>
<ul>
<li>简单来讲，所谓的32位系统，就是有2^32(4294967296)个地址。</li>
<li>每个地址为8bit(1byte)，所以32位系统可以使用的内存为2^32byte，即为4GB。</li>
<li>因为总共有2^32个地址，所以我们将第一个地址记为<code>0000 0000 0000 0000 0000 0000 0000 0000</code>，将最后一个地址记为<code>1111 1111 1111 1111 1111 1111 1111 111</code>。也就是说，我们需要使用4byte(4*8=32位数字)的空间来存放<code>地址编号</code></li>
</ul>
<p><img src="/images/20190108112108901.png" alt="在这里插入图片描述"></p>
<p>我们将地址编号靠近<code>0000 0000 0000 0000 0000 0000 0000 0000</code>的内存称为<code>低地址</code>，反之称为<code>高地址</code>。</p>
<p><img src="/images/image-20211030153525306.png" alt="image-20211030153525306"></p>
</blockquote>
<h3 id="指针占多少字节"><a href="#指针占多少字节" class="headerlink" title="指针占多少字节"></a>指针占多少字节</h3><ul>
<li>在32位地址中，我们使用2^32个地址，所以需要使用32位二进制数来表示一个地址的编号，也就是说需要32bit(4字节)来表示一个地址的编号。所以指针占4字节。</li>
<li>在64位地址中，我们使用2^64个地址，所以需要使用64位二进制数来表示一个地址的编号，也就是说需要64bit(8字节)来表示一个地址的编号。所以指针占8字节。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">int</span> *ip;</span><br><span class="line">  <span class="keyword">char</span> *cp;</span><br><span class="line"></span><br><span class="line">  ip = &amp;a;</span><br><span class="line">  cp = &amp;ch;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在64位系统中,需要使用64位二进制数来表示一个地址的编号</span></span><br><span class="line">  <span class="comment">// 所以在64位系统中,指针的占用大小就是64位，即8字节</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p,%p\n&quot;</span>, ip, &amp;a); <span class="comment">// 000000000061FE0C,000000000061FE0C</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p,%p\n&quot;</span>, cp, &amp;ch); <span class="comment">// 000000000061FE0B,000000000061FE0B</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,<span class="keyword">sizeof</span>(ip),<span class="keyword">sizeof</span>(cp)); <span class="comment">// 8,8</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="typedef可以将一切合法的定义变成类型"><a href="#typedef可以将一切合法的定义变成类型" class="headerlink" title="typedef可以将一切合法的定义变成类型"></a>typedef可以将一切合法的定义变成类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局变量UINT</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将unsigned int这个类型取一个别名，称为UINT</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="comment">// 使用UINT类型</span></span><br><span class="line">UINT a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="字符串和字符数组"><a href="#字符串和字符数组" class="headerlink" title="字符串和字符数组"></a>字符串和字符数组</h3><ul>
<li>类似于<code>char arr3[] = &#123;&quot;hyl&quot;&#125;;</code>没有显式限定数组大小，使用双引号的，我们称之为<code>字符串</code>。其strlen因为包含<code>\0</code>，所以为4。</li>
<li>类似于<code>char arr4[] = &#123;&#39;h&#39;, &#39;y&#39;, &#39;l&#39;&#125;;</code>没有显式限定数组大小，使用单引号的，我们称之为<code>字符数组</code>。其strlen因为不包含<code>\0</code>，所以strlen()函数会越界数组继续查询，直达遇到<code>\0</code>，所以其strlen是不确定的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> arr1[<span class="number">10</span>] = &#123;<span class="string">&quot;hyl&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> arr2[<span class="number">10</span>] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> arr3[] = &#123;<span class="string">&quot;hyl&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> arr4[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr1),<span class="built_in">strlen</span>(arr1)); <span class="comment">// 10,3</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr2),<span class="built_in">strlen</span>(arr2)); <span class="comment">// 10,3</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr3),<span class="built_in">strlen</span>(arr3)); <span class="comment">// 4,3</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr4),<span class="built_in">strlen</span>(arr4)); <span class="comment">// 3,6(不确定)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>, d = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 指针数组: 这是一个数组，数组的元素是整型类型的指针</span></span><br><span class="line"><span class="keyword">int</span> *arr[<span class="number">5</span>] = &#123;&amp;a, &amp;b, &amp;c, &amp;d&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组指针: 这是以一个指针，这个指针指向一个数组，其数组的元素类型是整型类型</span></span><br><span class="line"><span class="keyword">int</span>(*pa)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>可以通过操作符的优先级进行判断。</p>
<ul>
<li><p><code>int *p1[10];</code></p>
<p><code>[]</code>的优先级比<code>*</code>要高。p1 先与 <code>[]</code> 结合，构成一个数组的定义，数组名为 p1，<code>int *</code> 修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含 10 个指向 int 类型数据的指针，即指针数组。</p>
</li>
<li><p><code>int (*p2)[10];</code></p>
<p><code>()</code>的优先级比 <code>[]</code> 高，<code>*</code> 号和 p2 构成一个指针的定义，指针变量名为 p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚 p2 是一个指针，它指向一个包含 10 个 int 类型数据的数组，即数组指针。</p>
</li>
</ul>
<p><img src="/images/1-120205202113a8.jpg" alt="img"></p>
<h2 id="指针详解"><a href="#指针详解" class="headerlink" title="指针详解"></a>指针详解</h2><p><img src="/images/image-20211031143955616.png" alt="image-20211031143955616"></p>
<h3 id="野指针、空指针、失效指针"><a href="#野指针、空指针、失效指针" class="headerlink" title="野指针、空指针、失效指针"></a>野指针、空指针、失效指针</h3><p>如下，第三行指针ip没有赋值，所以ip指向的是一个随机的地址。第四行将这个指向的地址设置为100，这是极其危险的。因为你根本不知道ip到底指向的是哪里，有可能是堆区，栈区，数据区，代码区等等。假如 将代码区的内存修改了，很可能整个程序就都崩溃了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 野指针</span></span><br><span class="line">  <span class="keyword">int</span>* ip; <span class="comment">// 随机值</span></span><br><span class="line">  *ip = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：将野指针初始化为<code>空指针</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 空指针</span></span><br><span class="line">  <span class="keyword">int</span>* ip = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  ip = &amp;a</span><br><span class="line">  *ip = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C语言中，函数不能返回<code>局部变量</code>，否则就会出现失效指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ip = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 失效指针</span></span><br><span class="line">  <span class="comment">// 函数调用后，栈帧已经被回收了，p指向的变量可能就被回收了。</span></span><br><span class="line">  <span class="comment">// 此时就说，ip指针已经失效了</span></span><br><span class="line">  ip = func(); </span><br><span class="line">  <span class="keyword">if</span> (ip != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,%d\n&quot;</span>, ip, *ip);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：使用<code>全局变量</code>，或者<code>静态变量</code>，或者<code>将指针作为函数参数</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ip = <span class="literal">NULL</span>;</span><br><span class="line">  ip = func();</span><br><span class="line">  <span class="keyword">if</span> (ip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,%d\n&quot;</span>,ip,*ip)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">int</span> global_num = <span class="number">100</span></span><br><span class="line"><span class="keyword">int</span>* func() &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;global_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *ip = <span class="literal">NULL</span>;</span><br><span class="line">  ip = func();</span><br><span class="line">  <span class="keyword">if</span> (ip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,%d\n&quot;</span>,ip,*ip)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将指针作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">(<span class="keyword">int</span>* ip)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ip != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    *ip = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">  <span class="keyword">int</span>*s = <span class="literal">NULL</span>;</span><br><span class="line">  s = func(p);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, *s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指针类型的作用"><a href="#指针类型的作用" class="headerlink" title="指针类型的作用"></a>指针类型的作用</h3><ul>
<li>周所周知，在x86系统下，只要是指针变量，其所占空间大小为4字节。虽然double类型占8字节，但是指针的大小依旧是4字节，值为double数据的低地址。</li>
<li>定义指针变量时，类型对指针变量起到2个作用。<ul>
<li>指针变量加1的能力</li>
<li>解析存储单元的大小。</li>
</ul>
</li>
</ul>
<p>指针变量加1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p -&gt; %d\n&quot;</span>, p, *p);</span><br><span class="line">        p++; <span class="comment">// 这里的p++，实际上是加上整型的所占字节数：+sizeof(int)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `*`,`&amp;`，`++`,`--`具体相同优先级。都是右结合性。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = arr;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    x = *p++;</span><br><span class="line">    y = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,x,y); <span class="comment">// 12,23</span></span><br><span class="line"></span><br><span class="line">    x = ++*p;</span><br><span class="line">    y = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,x,y); <span class="comment">// 24,24</span></span><br><span class="line"></span><br><span class="line">    x = *++p;</span><br><span class="line">    y = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,x,y); <span class="comment">// 34,34 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,arr[i]); <span class="comment">// 12,24,34,45,56,</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类型对指针解引用的影响"><a href="#类型对指针解引用的影响" class="headerlink" title="类型对指针解引用的影响"></a>类型对指针解引用的影响</h3><p>指针的类型解决了指针对内存数据的识别能力。也就是说，指针类型决定了指针是如何解引用内存数据的。</p>
<p><img src="/images/image-20211031170152310.png" alt="image-20211031170152310"></p>
<ul>
<li>代码第五行，因为ip指向了a，所以ip指针指向的低地址为<code>0x00EDFDA8</code></li>
<li>代码第七行，将int类型的指针，强行转为char类型的指针。这两个指针指向的低地址是一样的，都是<code>0x00EDFDA8</code>。但是ip指针能修改包括低地址共4个字节的内存数据，而cp指针只能修改低地址1个字节的内存数据。</li>
<li>代码11行，将<code>0x00EDFDA8</code>从cc改成了7f，而<code>0x00EDFDA9</code>，<code>0x00EDFDAA</code>，<code>0x00EDFDAB</code>保持不变。</li>
</ul>
<p>示例2：求ix，sx，cx的值</p>
<p><img src="/images/image-20211031171543908.png" alt="image-20211031171543908"></p>
<h3 id="地址常量"><a href="#地址常量" class="headerlink" title="地址常量"></a>地址常量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = &amp;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码<code>int *p = &amp;b;</code>中，<code>&amp;b</code>就是b变量的内存地址。我们回顾<code>定义变量</code>的知识点</p>
<blockquote>
<p><code>定义</code>：为这个变量分配一块内存并给它取上一个名字，这个名字就是我们经常所说的变量名。</p>
<p>但注意，这个<strong>名字一旦和这块内存匹配起来，它们就同生共死，终生不离不弃，并且这块内存的位置也不能被改变</strong>。一个变量在一定的区域内（比如函数内，全局等）只能被定义一次，如果定义多次，编译器会提示你重复定义同一个变量或对象。</p>
</blockquote>
<p>也就是说，此时<code>b</code>这个标识符，就已经和<code>0x00dff7a4</code>这块内存绑死了。直到b的存活期结束前，都不能修改。这个<code>0x00dff7a4</code>就称为<code>地址常量</code>。</p>
<blockquote>
<p>因此，<strong>地址常量可读不可写</strong>。</p>
</blockquote>
<p><img src="/images/image-20211031173649401.png" alt="image-20211031173649401"></p>
<p>所以，下面的代码是不行的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 相当于&amp;a=&amp;b,也就是想要修改a对应d的地址常量</span></span><br><span class="line">  &amp;*p = &amp;b; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="const与指针变量的关系"><a href="#const与指针变量的关系" class="headerlink" title="const与指针变量的关系"></a>const与指针变量的关系</h3><blockquote>
<p>如何区分下面两种？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;a; </span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br></pre></td></tr></table></figure>

<p>根据结合性解析，赋值语句都是从右向左解释：</p>
<ul>
<li>第一行，<code>*</code>号首先和p1结合，构成指针的解释。然后和const结合，所以const解释的指针，表示这个指针是常性的。最后和int结合，表示这个指针是整型指针。</li>
<li>第二行，p2首先和const结合，所以const解释的是变量，表示这个变量本身是常性的。然后和<code>*</code>号结合，表示p2是一个指针变量。最后和int结合，表示这个指针变量是整型指针。</li>
</ul>
<p>指针一共有两个值：<code>自身的值</code>和<code>所指之物的值</code>。所以两个的区别：</p>
<ul>
<li>p1的指向是常性的。即：p1不可修改所指之物的值。所以p1被称为<code>指向常性指针</code><ul>
<li>p2变量本身是常性的。即：p2不可修改自身的值。所以p2被称为<code>常性指针</code></li>
</ul>
</li>
</ul>
</blockquote>
<p>指向常性指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当const在*号左边，此时的const修饰的就是`指向能力`，</span></span><br><span class="line"><span class="comment">// 即: p1不可以修改所指之物的值</span></span><br><span class="line"><span class="comment">// 也就是说 </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;a; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 常性指针限制的是`通过解引用修改变量`的能力，但是指针本身是可以指向其他值的</span></span><br><span class="line">p1 = &amp;b;</span><br><span class="line">*p = <span class="number">200</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>常性指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 当const在*号右边，此时const修饰的就是p2变量</span></span><br><span class="line"><span class="comment">// 即: p2不可修改自身的值。</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line"></span><br><span class="line">*p2 = <span class="number">100</span>; <span class="comment">// 修改指针所指之物的值</span></span><br><span class="line">p2 = &amp;b; <span class="comment">// error：指针本身的值不可修改</span></span><br></pre></td></tr></table></figure>

<p>同时封锁两种能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;a</span><br></pre></td></tr></table></figure>



<p>常变量必须使用<code>指向常性指针</code>：</p>
<p>常变量的值本身就是不可改变的。如果可以使用指针去间接修改常变量的值，那就不符合最开始的常变量的定义了。因此必须使用指向常性指针去指向常变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;c; <span class="comment">// 指向常性指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = &amp;c; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>



<h3 id="指针和数组的关系"><a href="#指针和数组的关系" class="headerlink" title="指针和数组的关系"></a>指针和数组的关系</h3><blockquote>
<p>只有在<code>sizeof</code>中，数组变量才表示<code>整个数组</code>的意义。其他情况都表示<code>数组首个元素的地址</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(arr); <span class="comment">// sizeof(int) * 5 = 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p \n&quot;</span>, arr); <span class="comment">// 数组首元素的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p \n&quot;</span>, &amp;arr[<span class="number">0</span>]); <span class="comment">// 数组首元素的地址</span></span><br></pre></td></tr></table></figure>

<p>数组名是指针，非常方便，但是却<strong>丢失了数组另一个要素：数组的大小</strong>，即数组元素的数量。编译器按数组定义时的大小分配内存，但<strong>运行时（runtime）对数组的边界不加检测</strong>。这会带来无法预知的严重错误。</p>
<p><img src="/images/image-20211101082915336.png" alt="image-20211101082915336"></p>
<p>C语言的下标运算符[]是以指针作为操作数的，ar[i]被编译系统解释为<code>*(ar+i)</code>，即表示为ar所指（固定不可变）元素向后第i个元素。无论以下标方式或指针方式存取数组元素时，<strong>编译器都会转换为指针方法实现</strong>。逻辑上有两种方式，物理上只有一种方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 下面四种都是可以的。</span></span><br><span class="line">  <span class="comment">// arr[i]在编译器就是解释成*(arr+i)</span></span><br><span class="line">  <span class="comment">// 所以就算i[arr]这种诡异的形式也是可以的，因为会被解释成*(i+arr)</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d,&quot;</span>, arr+i, *(arr+i), arr[i], i[arr])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为数组在使用的时候丢失了数组大小这一属性，因此当数组作为参数传递到函数的时候，必须传入数组大小这个变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是数组本身，也就是数组名，第二个参数是数组长度。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = sum_array(a, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>



<h3 id="void指针变量"><a href="#void指针变量" class="headerlink" title="void指针变量"></a>void指针变量</h3><ul>
<li>void被称为抽象类型。</li>
<li>void变量可以指向任何变量的地址，但是不能<code>解引用</code>去获取变量的值。</li>
<li>原因很简单：指针类型的其中一项能力就是解析存储单元的大小。而void指针是无类型，自然不可能知道改变量需要几个字节存储。</li>
<li>同理，自然也无法使用指针的+1偏移能力。</li>
<li>需要使用void指针解引用的时候，必须将其强转为明确的类型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p); <span class="comment">// error: dereferencing &#x27;void *&#x27; pointer</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> * new_p = (<span class="keyword">char</span> *) p; <span class="comment">// 将void指针强转为明确的类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *new_p); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211106145713760.png" alt="image-20211106145713760"></p>
<h3 id="void与泛型"><a href="#void与泛型" class="headerlink" title="void与泛型"></a>void与泛型</h3><ul>
<li>根据上面的介绍，void变量可以存储指针，但是会丢失<code>指针类型</code>这一个重要信息。而指针类型本质就是某种类型在内存中占几个字节。</li>
<li>也就是说，如果我们手动传入指针类型所占字节数，那么void变量就可以接收任何类型的数据。这就实现了泛型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_memset</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *cp = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        *cp = ch;</span><br><span class="line">        cp++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">10</span>];</span><br><span class="line">    my_memset(&amp;a[<span class="number">0</span>], <span class="string">&#x27;2&#x27;</span>, <span class="keyword">sizeof</span>(a)); <span class="comment">// 每个元素初始化为字符&#x27;2&#x27;</span></span><br><span class="line">    my_memset(&amp;b[<span class="number">0</span>], <span class="string">&#x27;3&#x27;</span>, <span class="keyword">sizeof</span>(b)); <span class="comment">// 每个元素初始化为字符&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c,%c&quot;</span>, a[<span class="number">1</span>], b[<span class="number">2</span>]); <span class="comment">// 2,3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理可以编写<code>memcpy</code>，<code>memmove</code>等函数。</p>
<h3 id="二级指针简单使用"><a href="#二级指针简单使用" class="headerlink" title="二级指针简单使用"></a>二级指针简单使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">// 设置变量</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a;  <span class="comment">// 设置一级指针，指向变量</span></span><br><span class="line">    <span class="keyword">int</span> **s = &amp;p1; <span class="comment">// 设置二级指针，指向一级指针</span></span><br><span class="line">  </span><br><span class="line">    **s = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,**s); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二维数组并不是二级指针"><a href="#二维数组并不是二级指针" class="headerlink" title="二维数组并不是二级指针"></a>二维数组并不是二级指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> **data,<span class="keyword">int</span> row,<span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; column;++ j)</span><br><span class="line">            cout &lt;&lt; data[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">fun</span>(data,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译无法通过，提示<code>no known conversion from &#39;float [2][3]&#39; to &#39;float **&#39; for 1st argument</code>。如果在main函数中将data强制转换成二级指针，编译能通过，运行时发生段错误。究其根本，是因为<strong>二维数组名，并不是一个二级指针</strong>。</p>
<blockquote>
<p>反证法：</p>
<p>如果二维数组名是一个二级指针。对于数组<code>A[3][3]</code>，假设<code>int**p=A</code>； 那么要对行递增执行p++时，编译器如何知道列宽？</p>
<p>因为<code>int**</code>是指向一个 int 类型的指针，其数据宽度是4字节，因此p将指向下一个整数元素地址，也就是p递增了4字节，而不是3个int型数据的宽度，这就错位了。 所以<code>A[3][3]</code>的地址类型不是简单的指针的指针，而是<strong>行指针的指针</strong>，而行宽是由你定义的数组列数和元素类型所决定，int类型就是<code>4*3=12</code>个字节。这叫数据对齐。</p>
<p>因此编译器在转换数组名时，会根据对齐要求而确定相应的指针类型，所以A的地址应该是<code>int (*p)[3]=A</code>,而不是<code>int **</code>。 其含义为：<strong>p是一个指向（含3个int类型元素的一维数组或行的）指针</strong>。</p>
</blockquote>
<p>总结：</p>
<ul>
<li>数组名等同于数组的首元素的地址。</li>
<li>因此，一维数组的数组名等同于首变量的地址。</li>
<li>二维数组的数组名等同于<strong>首行数组的地址</strong>。也就是说，二维数组的数组名其实是一个数组指针。</li>
</ul>
<h3 id="二维数组是数组指针"><a href="#二维数组是数组指针" class="headerlink" title="二维数组是数组指针"></a>二维数组是数组指针</h3><p>不管是一维还是多维数组，都是内存中一块线性连续空间，因此在内存级别上，其实都只是一维。</p>
<p><img src="/images/15031621526830.png" alt="C语言中的二级指针和二维数组问题"></p>
<p>访问数组元素其实非常简单，原因就在于元素在内存中的线性排列。</p>
<ul>
<li>对一维数组的访问：<code>arr1[index] = *(arr1+index*sizeof(T))</code></li>
<li>对二维数组的访问：<code>arr2[i][j]=*(arr2+(i*col+j)*sizeof(T))</code></li>
</ul>
<p>对于二维数组<code>int data[2][3]</code>，可看做特殊的一维数组<code>data[2]</code>，包含两个元素，每个元素的类型是<code>int [3]</code>。<br>无论如何，数组名总是代表数组首元素的地址，因此，<strong>二维数组名是一个数组指针，指向首行地址，而非二级指针</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*ptr)[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">ptr = data;      <span class="comment">// ptr指向data的第0行</span></span><br><span class="line">ptr = &amp;data[<span class="number">1</span>];  <span class="comment">// ptr指向data的第1行</span></span><br></pre></td></tr></table></figure>

<p>数组指针的声明中，方括号中的维数指明了对应的指针变量偏移一个单位对应的内存偏移量。（如ptr + 1,ptr会向高地址移动3*4Byte）</p>
<blockquote>
<p>上述声明中，圆括号不能省略，因为[]具有更高的有衔接，<code>int *var[3]</code>声明的是一个元素为int *的数组（指针数组)。</p>
</blockquote>
<h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>由于数组的起始地址是常用操作，<code>&amp;array[0]</code>的写法有点麻烦，C 语言提供了便利写法，<strong>数组名等同于起始地址</strong>，也就是说，数组名就是指向第一个成员（<code>array[0]</code>）的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">int</span>* p = a;</span><br></pre></td></tr></table></figure>

<p>既然<code>a</code>等同于<code>&amp;a[0]</code>，表示的都是<code>数组首元素的地址</code>。那么我又该如何表示<code>数组本身的地址</code>？答案是：使用<code>&amp;a</code>。</p>
<p>也就是说，对于<code>int arr[4];</code>来说，虽然arr和&amp;arr指向的地址是相同的，但是含义是不同的：</p>
<ul>
<li><code>arr</code>：等同于<code>&amp;ar[0]</code>，代表数组首元素的地址。</li>
<li><code>&amp;arr</code>：代表数组本身的地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ar[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ar: 首元素的地址</span></span><br><span class="line"><span class="keyword">int</span> *p = ar;  <span class="comment">// 等同于 int *p = &amp;ar[0];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组本身的地址</span></span><br><span class="line"><span class="keyword">int</span> (*s)[<span class="number">4</span>] = &amp;ar;</span><br></pre></td></tr></table></figure>



<p>在二维数组的情况下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dx[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = dx; <span class="comment">// 首元素地址(首元素为一维数组&#123;1,2,3,4&#125;)</span></span><br><span class="line"><span class="keyword">int</span> (*s)[<span class="number">3</span>][<span class="number">4</span>] = &amp;dx; <span class="comment">// 数组本身的地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p));    <span class="comment">// 4，p为数组指针，指针的大小在32位系统为4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*p));   <span class="comment">// 16，数组指针进行解引用得到数组，值为一维数组的大小，row*sizeof(int)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(s));    <span class="comment">// 4，s为二维数组指针，指针的大小在32位系统为4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*s));   <span class="comment">// 48，二维数组指针进行解引用得到二维数组，值为二维数组的大小，row*line*sizeof(int)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(**s));  <span class="comment">// 16,代表二维数组的元素，也就是一维数组，row*sizeof(int)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(***s)); <span class="comment">// 4，代表二维数组的元素的元素，也就是一维数组的元素，就是整型的大小，sizeof(int)</span></span><br></pre></td></tr></table></figure>



<p>所以，对于下面这张图的情况：</p>
<p><img src="/images/image-20211110230152539.png" alt="image-20211110230152539"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s存储的是ar0这个数组的地址</span></span><br><span class="line"><span class="keyword">int</span> (*s)[<span class="number">4</span>] = ar0;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为s存储的是ar0数组的地址，所以s+1代表下一个数组的地址，即&amp;ar1</span></span><br><span class="line">s+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为s+1等同于&amp;ar1。所以*(s+1)等同于*&amp;ar1，即ar1</span></span><br><span class="line"><span class="comment">// 而ar1代表的是ar1首元素的地址，即&amp;ar1[0]</span></span><br><span class="line">*(s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表ar2[3]的地址,即&amp;ar2[3]</span></span><br><span class="line">*(s+<span class="number">2</span>)+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出ar2[3]的值。可以简写为下标形式s[2][3]</span></span><br><span class="line">*(*(s+<span class="number">2</span>)+<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> (*s)[<span class="number">4</span>] = dx;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(*(s+<span class="number">2</span>)+<span class="number">3</span>)); <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 数组名s是&amp;s[0]的别名，代表首元素1的地址</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = s;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p1); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3的地址</span></span><br><span class="line">    <span class="keyword">int</span> *p2 = &amp;s[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p2); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组本身的地址</span></span><br><span class="line">    <span class="keyword">int</span> (*p3)[<span class="number">5</span>] = &amp;s;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, **p3); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">5</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">9</span>, <span class="number">10</span>&#125;&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// dx[1]是一维数组,同时也是首元素&amp;dx[1][0]的别名</span></span><br><span class="line">    <span class="keyword">int</span> *p4 = dx[<span class="number">1</span>];          <span class="comment">// p指向元素3的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p4[<span class="number">3</span>]);    <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;dx[1]是一维数组本身的地址</span></span><br><span class="line">    <span class="keyword">int</span> (*p5)[<span class="number">2</span>] = &amp;dx[<span class="number">1</span>];    <span class="comment">// s指向一维数组&#123;3，4&#125;的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p5[<span class="number">1</span>][<span class="number">3</span>]); <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>在定义指针时，例如<code>int s[5] = &#123;1, 2, 3, 4, 5&#125;;</code>，如果<code>s</code>单独出现。那么就是<code>&amp;s[0]</code>的别名。如果<code>s</code>不是单独出现。那么一律代表数组<code>s</code>本身。</strong></p>
</blockquote>
<ul>
<li><code>int *p1 = s;</code>：<code>s</code>单独出现，是<code>&amp;s[0]</code>的别名，所以变成<code>int *p1 = &amp;s[0]</code>，也就是数组的首元素的地址。</li>
<li><code>int *p2 = &amp;s[2];</code>：数组的第3元素的地址。</li>
<li><code>int (*p3)[5] = &amp;s;</code>：<code>s</code>代表数组本身，所以<code>&amp;s</code>就是数组本身的地址。</li>
<li><code>int *p4 = dx[1];</code>：<code>dx</code>代表二维数组，所以<code>dx[1]</code>代表一维数组<code>&#123;3, 4&#125;</code>本身。同时一维数组本身又是一维数组首元素的别名，所以<code>dx[1]</code>又是<code>&amp;dx[1][0]</code>。</li>
<li><code>int (*p5)[2] = &amp;dx[1];</code>：<code>dx</code>代表二维数组，所以<code>dx[1]</code>代表一维数组<code>&#123;3, 4&#125;</code>本身。所以<code>&amp;dx[1]</code>就是一维数组本身的地址。</li>
</ul>
<h3 id="指针数组是二级指针"><a href="#指针数组是二级指针" class="headerlink" title="指针数组是二级指针"></a>指针数组是二级指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* pstr[<span class="number">5</span>] = &#123;<span class="string">&quot;qwe&quot;</span>,<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;zxc&quot;</span>,<span class="string">&quot;ert&quot;</span>,<span class="string">&quot;sdf&quot;</span>&#125;;</span><br><span class="line">  print_arr1(pstr,<span class="number">5</span>);</span><br><span class="line">  print_arr2(pstr,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(ps+i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="各种结构匹配的指针类型"><a href="#各种结构匹配的指针类型" class="headerlink" title="各种结构匹配的指针类型"></a>各种结构匹配的指针类型</h3><table>
<thead>
<tr>
<th>结构</th>
<th>示例</th>
<th>匹配的指针类型</th>
<th>指针类型名称</th>
</tr>
</thead>
<tbody><tr>
<td>二维数组</td>
<td><code>char c[8][10]; </code></td>
<td><code> char (*c)[10];</code></td>
<td>数组指针</td>
</tr>
<tr>
<td>指针数组</td>
<td><code>char *c[10];</code></td>
<td><code>char **c; </code></td>
<td>二级指针</td>
</tr>
<tr>
<td>数组指针(行指针)</td>
<td><code>char (*c)[10];</code></td>
<td><code>char (*c)[10];</code></td>
<td>数组指针</td>
</tr>
<tr>
<td>二级指针</td>
<td><code>char **c;</code></td>
<td><code>char **c;</code></td>
<td>二级指针</td>
</tr>
</tbody></table>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>在程序中定义了一个函数，当编译链接成功，运行程序时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且<strong>函数名表示的就是这个地址</strong>。既然是地址，我们就可以定义一个额指针变量来存放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a * b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a / b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 函数列表</span></span><br><span class="line">    <span class="keyword">int</span> (*op_func[<span class="number">4</span>])(<span class="keyword">int</span>, <span class="keyword">int</span>) = &#123;Add, Sub, Mul, Del&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(op_func); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, op_func[i](<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 5 -1 6 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用函数指针实现泛型"><a href="#使用函数指针实现泛型" class="headerlink" title="使用函数指针实现泛型"></a>使用函数指针实现泛型</h3><p>C语言实现泛型的方法很蠢很窒息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Student</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">int</span> n, <span class="keyword">int</span> size, <span class="keyword">void</span> print_func(<span class="keyword">const</span> <span class="keyword">void</span> *))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        print_func(ptr);</span><br><span class="line">        ptr += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_int</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *ele = (<span class="keyword">int</span> *) ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, *ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_double</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> *ele = (<span class="keyword">double</span> *) ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\t&quot;</span>, *ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_char</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ele = (<span class="keyword">char</span> *) ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, *ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_str</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **ele = (<span class="keyword">const</span> <span class="keyword">char</span> **) ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, *ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_student</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">ele</span> =</span> (<span class="keyword">const</span> struct Student *) ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s,age:%d\t&quot;</span>, ele-&gt;name, ele-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> char_arr[<span class="number">4</span>] = &#123;<span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> int_arr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> double_arr[<span class="number">4</span>] = &#123;<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *str_arr[] = &#123;<span class="string">&quot;123&quot;</span>, <span class="string">&quot;qwead&quot;</span>, <span class="string">&quot;csdfs&quot;</span>, <span class="string">&quot;frsdfsdfsf&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">my_student</span>[] =</span> &#123;</span><br><span class="line">            &#123;<span class="string">&quot;hyl&quot;</span>, <span class="number">23</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;czj&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    my_print(char_arr, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="keyword">sizeof</span>(char_arr) / <span class="keyword">sizeof</span>(char_arr[<span class="number">0</span>]), print_char);</span><br><span class="line">    my_print(int_arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(int_arr) / <span class="keyword">sizeof</span>(int_arr[<span class="number">0</span>]), print_int);</span><br><span class="line">    my_print(double_arr, <span class="keyword">sizeof</span>(<span class="keyword">double</span>), <span class="keyword">sizeof</span>(double_arr) / <span class="keyword">sizeof</span>(double_arr[<span class="number">0</span>]), print_double);</span><br><span class="line">    my_print(str_arr, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *), <span class="keyword">sizeof</span>(str_arr) / <span class="keyword">sizeof</span>(str_arr[<span class="number">0</span>]), print_str);</span><br><span class="line">    my_print(my_student, <span class="keyword">sizeof</span>(struct Student), <span class="keyword">sizeof</span>(my_student) / <span class="keyword">sizeof</span>(my_student[<span class="number">0</span>]), print_student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用函数指针实现装饰器"><a href="#使用函数指针实现装饰器" class="headerlink" title="使用函数指针实现装饰器"></a>使用函数指针实现装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco_func</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wapper</span>(<span class="params">a,b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> f(a,b) + <span class="number">1000</span></span><br><span class="line">    <span class="keyword">return</span> wapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base_func</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">base_func = deco_func(base_func)</span><br><span class="line"><span class="built_in">print</span>(base_func(<span class="number">10</span>,<span class="number">20</span>)) <span class="comment"># 1003</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*Func)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">base_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_1000</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base_func(a, b) + <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Func <span class="title">deco_func</span><span class="params">(Func base_func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_1000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    Func new_add = deco_func(base_func);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, new_add(a, b));  <span class="comment">// 1003</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, base_func(a,b)); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数值的存储方式"><a href="#数值的存储方式" class="headerlink" title="数值的存储方式"></a>数值的存储方式</h2><p>计算机存储整型数据是以补码存储。</p>
<ul>
<li>原码：所谓原码就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。</li>
<li>正数的原码 = 反码 = 补码。</li>
<li>负数的原码是符号不变按位取反，变成反码。再加1变为补码。</li>
</ul>
<table>
<thead>
<tr>
<th>十进制数</th>
<th>5</th>
<th>-5</th>
</tr>
</thead>
<tbody><tr>
<td>原码</td>
<td><strong>0</strong>000 0101</td>
<td><strong>1</strong>000 0101</td>
</tr>
<tr>
<td>反码</td>
<td><strong>0</strong>000 0101</td>
<td><strong>1</strong>111 1010</td>
</tr>
<tr>
<td>补码</td>
<td><strong>0</strong>000 0101</td>
<td><strong>1</strong>111 1011</td>
</tr>
</tbody></table>
<blockquote>
<p>简单计算：</p>
<ul>
<li>5的补码就是：<code>5</code>的二进制数</li>
<li>-5的补码就是：<code>2^8 - 5</code>的二进制数</li>
</ul>
</blockquote>
<h3 id="溢出的本质"><a href="#溢出的本质" class="headerlink" title="溢出的本质"></a>溢出的本质</h3><p><img src="/images/image-20211116102910465.png" alt="image-20211116102910465"></p>
<ul>
<li><code>char a;</code>的起始数为0000 0000，最大的正数为0111 1111。</li>
<li><code>0111 1111 + 1 = 1000 0000</code>，也就是-128</li>
</ul>
<h3 id="为什么使用补码存储数据？"><a href="#为什么使用补码存储数据？" class="headerlink" title="为什么使用补码存储数据？"></a>为什么使用补码存储数据？</h3><ul>
<li>因为成本原因，CPU只有<code>加法器</code>和<code>取反器</code>。没有减法器，为了实现减法，必须将<code>5-5</code>改成<code>5+(-5)</code></li>
<li>如果使用补码的话，-5是<code>1111 1011</code>，5是<code>0000 0101</code>，相加得出<code>1 0000 0000</code>。而1因为溢出被舍弃，结果为<code>0000 0000</code>。即为0。</li>
</ul>
<h3 id="小端存储"><a href="#小端存储" class="headerlink" title="小端存储"></a>小端存储</h3><p><img src="/images/image-20211114174104206.png" alt="image-20211114174104206"></p>
<h2 id="类型转换详解"><a href="#类型转换详解" class="headerlink" title="类型转换详解"></a>类型转换详解</h2><h3 id="扩充（小转大）"><a href="#扩充（小转大）" class="headerlink" title="扩充（小转大）"></a>扩充（小转大）</h3><ul>
<li>有符号类型：填充符号位</li>
<li>无符号类型：填充0</li>
</ul>
<p><img src="/images/image-20211117104813945.png" alt="image-20211117104813945"></p>
<h3 id="截取（大转小）"><a href="#截取（大转小）" class="headerlink" title="截取（大转小）"></a>截取（大转小）</h3><p>保留低地址，抛弃高地址。</p>
<p><img src="/images/image-20211117105048705.png" alt="image-20211117105048705"></p>
<h3 id="隐式转化的四种情况"><a href="#隐式转化的四种情况" class="headerlink" title="隐式转化的四种情况"></a>隐式转化的四种情况</h3><ul>
<li>算术运算式中，低类型能转为高类型</li>
<li>赋值表达式中，右边表达式自动隐式转换为左边变量的类型，并赋值给他</li>
<li>函数调用中参数传递时，系统隐式地将实参转化为形参的类型后，赋给形参</li>
<li>函数有返回时，系统隐式的将返回表达式类型转化为返回值类型，复制给调用函数。</li>
</ul>
<p>遇到不同类型的数据进行运算，若一个运算符两侧的数据类型不同，则先自动进行类型转换，使两者具有同一类型，然后进行运算，规律总结如下：</p>
<p>等级：</p>
<ol>
<li>double</li>
<li>unsigned long long</li>
<li>long long</li>
<li>unsigned int</li>
<li>int</li>
</ol>
<blockquote>
<p>C语言自动转换不同类型的行为称之为隐式类型转换 ，转换的基本原则是：低精度类型向高精度类型转换，具体是：</p>
<ul>
<li>int -&gt; unsigned int -&gt; long -&gt; unsigned long -&gt; long long -&gt; unsigned long long -&gt; float -&gt; double -&gt; long double </li>
<li>注意，上面的顺序并不一定适用于你的机器，比如当int和long具有相同字长时，unsigned int的精度就会比long的精度高(事实上大多数针对32机的编译器都是如此)。</li>
<li>另外需要注意的一点是并没有将char和short型写入上式，原因是他们可以被提升到int也可能被提升到unsigned int。</li>
</ul>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">-5</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &gt; %d\n&quot;</span>, a, b); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &lt; %d\n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output： -5 &gt; 10</span></span><br></pre></td></tr></table></figure>

<p>原因：执行<code>a &gt; b</code>时，char类型会被隐式转为unsigned int。char a对应的二进制位<code>1000 0101</code>变成<code>1111 1111 1111 1111 1111 1111 1000 0101 </code>。自然比unsigned int 10的二进制位<code>0000 0000 0000 0000 0000 0000 0000 1010</code>大。</p>
<p>同理，因为<code>sizeof(int)</code>返回值为<code>unsigned int</code>，导致<code> i &gt; unsigned int</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-4</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: 空输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-4</span>; i &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -4,-3,-2,-1,0,1,2,3,</span></span><br></pre></td></tr></table></figure>



<p>溢出问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="number">200</span>; <span class="comment">// 溢出, 实际上为-56</span></span><br><span class="line">    <span class="keyword">char</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, c, a + b); <span class="comment">// 44,44</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> y = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> z = x + y; <span class="comment">// 溢出, 实际上为44</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, z, x + y); <span class="comment">// 44 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>隐式转化和强转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> uc = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> us = <span class="number">0</span>;</span><br><span class="line">    us = c + uc;</span><br><span class="line">    <span class="comment">// c本身为有符号数，隐式转为int，填充符号为1</span></span><br><span class="line">    <span class="comment">// c  = 1000 0000 -&gt;   1111 1111 1000 0000</span></span><br><span class="line">    <span class="comment">// uc = 1000 0000 -&gt;   0000 0000 1000 0000</span></span><br><span class="line">    <span class="comment">//                   ---------------------</span></span><br><span class="line">    <span class="comment">//                   1 0000 0000 0000 0000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x \n&quot;</span>, us); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    us = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) c + uc;</span><br><span class="line">    <span class="comment">// (unsigned char)c本身为无符号数，隐式为int,填充0</span></span><br><span class="line">    <span class="comment">// c&#x27;  = 1000 0000 -&gt; 0000 0000 1000 0000</span></span><br><span class="line">    <span class="comment">// uc  = 1000 0000 -&gt; 0000 0000 1000 0000</span></span><br><span class="line">    <span class="comment">//                    -------------------</span></span><br><span class="line">    <span class="comment">//                    0000 0001 0000 0000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x \n&quot;</span>, us); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    us = c + (<span class="keyword">char</span>) uc;</span><br><span class="line">    <span class="comment">// (char)c本身为有符号数，隐式为int,填充符号位1</span></span><br><span class="line">    <span class="comment">// c   = 1000 0000 -&gt; 1111 1111 1000 0000</span></span><br><span class="line">    <span class="comment">// uc&#x27; = 1000 0000 -&gt; 1111 1111 1000 0000</span></span><br><span class="line">    <span class="comment">//                    -------------------</span></span><br><span class="line">    <span class="comment">//                  1 1111 1111 0000 0000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x \n&quot;</span>, us); <span class="comment">// ff00</span></span><br><span class="line"></span><br><span class="line">    us = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) c + uc;</span><br><span class="line">    <span class="comment">// c为有符号数，强转为无符号数(unsigned short)c，填充符号位</span></span><br><span class="line">  	<span class="comment">// (unsigned short)强转为int</span></span><br><span class="line">  	<span class="comment">// uc为无符号数，强转为int，填充0</span></span><br><span class="line">    <span class="comment">// c   = 1000 0000 -&gt; 1111 1111 1000 0000</span></span><br><span class="line">    <span class="comment">// uc&#x27; = 1000 0000 -&gt; 0000 0000 1000 0000</span></span><br><span class="line">    <span class="comment">//                    -------------------</span></span><br><span class="line">    <span class="comment">//                  1 0000 0000 0000 0000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x \n&quot;</span>, us); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="浮点数的储存"><a href="#浮点数的储存" class="headerlink" title="浮点数的储存"></a>浮点数的储存</h2><h3 id="二进制下的科学计数法"><a href="#二进制下的科学计数法" class="headerlink" title="二进制下的科学计数法"></a>二进制下的科学计数法</h3><p>将十进制的浮点数转为<code>二进制下的科学计数法</code>。形如<code>(-1)^S * M * 2^E</code>。</p>
<ul>
<li>S为符号位</li>
<li>M为有效数字</li>
<li>E为指数</li>
</ul>
<p>其步骤如下：</p>
<ol>
<li>将十进制的浮点数转为二进制</li>
<li>对这个二进制数进行科学计数法<ul>
<li>如果此数为正数，将正号改成<code>(-1)^0</code></li>
<li>如果此数为负数，将负号改成<code>(-1)^1</code></li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">十进制数 -&gt; 二进制数  -&gt; 科学计数法</span><br><span class="line">12.25   -&gt; 1100.01 -&gt; (-1)^0 * 1.10001 * 2^3</span><br><span class="line">-0.25   -&gt; -0.01   -&gt; (-1)^1 * 1 * 2^-2</span><br><span class="line"></span><br><span class="line">S，M，E分别为</span><br><span class="line">0，1.10001，3</span><br><span class="line">1，1，-2</span><br></pre></td></tr></table></figure>

<p><strong>对于32位的浮点数，最高的1位是符号位S，接着的8位时指数E，剩下的23位为有效数字M</strong></p>
<p><img src="/images/image-20211118105356857.png" alt="image-20211118105356857"></p>
<blockquote>
<p>注意写入内存的<code>E</code>是：<code>127+二进制科学计数法E</code>，使用无符号的二进制位表示。</p>
<p>比如12.25的二进制科学计数法为<code>(-1)^0 * 1.10001 * 2^3</code>。其中S=0，M=1.10001，E=3。最终写入内存的E为<code>127+3=130</code>。即<code>0111 1111 + 0000 0011 = 1000 0010</code>。最终写入内存的就是<code>1000 0010</code>。</p>
</blockquote>
<p>所以12.25的内存表示就是：<code>0100 0001 0100 0100 0000 0000 0000 0000</code>  。转为十六进制就是： <code>0x41440000</code></p>
<h3 id="double类型的内存结构"><a href="#double类型的内存结构" class="headerlink" title="double类型的内存结构"></a>double类型的内存结构</h3><p>对于64位的浮点型，最高的1位是符号位S，接着是11位的指数E，剩下的52位是有有效数字M。</p>
<p><img src="/images/image-20211118111650982.png" alt="image-20211118111650982"></p>
<h3 id="什么有些浮点型是不精准的"><a href="#什么有些浮点型是不精准的" class="headerlink" title="什么有些浮点型是不精准的"></a>什么有些浮点型是不精准的</h3><p>原因很简单，对这些浮点型转为二进制的科学计数法时，有效数字M就是无限循环小数，存入内存时只能存入前23位(double类型存入前52位)</p>
<h3 id="整型和浮点型的内存结构对比"><a href="#整型和浮点型的内存结构对比" class="headerlink" title="整型和浮点型的内存结构对比"></a>整型和浮点型的内存结构对比</h3><p><strong>虽然整型和浮点型都是4字节，但是存储的方案完全不同。</strong></p>
<p>整型：</p>
<p><img src="/images/image-20211118110949950.png" alt="image-20211118110949950"></p>
<p>浮点型：</p>
<p><img src="/images/cbb096bf-image-20211118105356857.png" alt="image-20211118105356857"></p>
<h2 id="类型强转的本质"><a href="#类型强转的本质" class="headerlink" title="类型强转的本质"></a>类型强转的本质</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">float</span> ft = <span class="number">12.25</span>;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> *fp = &amp;ft;</span><br><span class="line">  <span class="keyword">int</span> * ip = &amp;a;</span><br><span class="line"></span><br><span class="line">  a = ft;</span><br><span class="line">  </span><br><span class="line">  a = (<span class="keyword">int</span>)ft;</span><br><span class="line">  ip = (<span class="keyword">int</span> *)fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们已经知道整型和浮点型的内存结构完全不同。所以需要不同类型的指针对内存数据执行不同解析方案。</li>
<li><code>a = (int)ft</code>和<code>ip = (int *)fp</code>，一个是普通的类型强转，一个是指针类型强转，这两种强转有本质上的不同。<ul>
<li><code>a = (int)ft</code>：解析出ft的值为12.25，然后将整数部分12写入到变量a对应的内存地址中。</li>
<li><code>ip = (int *)fp</code>：找出fp对应的内存地址，然后**更改解析方案(从浮点型的解析方案，改成整型的解析方案)**，解析出12，赋给ip。</li>
</ul>
</li>
</ul>
<h2 id="结构体对齐与大小"><a href="#结构体对齐与大小" class="headerlink" title="结构体对齐与大小"></a>结构体对齐与大小</h2><h3 id="为什么要进行字节对齐"><a href="#为什么要进行字节对齐" class="headerlink" title="为什么要进行字节对齐"></a>为什么要进行字节对齐</h3><ul>
<li>内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问变量，但是实际上，<strong>CPU并非逐字节读写内存，而是以2,4或8的倍数的字节块来读写内存</strong>，因此就会对基本数据类型的地址作出一些限制，即它的地址必须是2，4或8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是<code>对齐</code>。</li>
<li>有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凌才能得到该32bit数据。显然在读取效率上下降很多。</li>
<li><strong>不同平台对齐方式可能不同</strong>，如此一来，同样的结构在不同的平台其大小可能不同，在无意识的情况下互相发送的数据可能出现错乱，甚至引发严重的问题。</li>
</ul>
<h3 id="计算结构体大小的3条规则"><a href="#计算结构体大小的3条规则" class="headerlink" title="计算结构体大小的3条规则"></a>计算结构体大小的3条规则</h3><ol>
<li>结构体变量的首地址，必须是结构体变量中的<code>最大基本数据类型成员所占字节数</code>的整教倍</li>
<li>结构体变量中的每个成员相对于结构体首地址的偏移量，都是<code>该成员基本数据类型所占字节数</code>的整数倍</li>
<li>结构体变量的总大小，为结构体变量中<code>最大基本数据类型成员所占字节数</code>的整数倍</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> cha;</span><br><span class="line">    <span class="keyword">int</span> ia;</span><br><span class="line">    <span class="keyword">char</span> chb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node2</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> cha;</span><br><span class="line">  <span class="keyword">char</span> chb;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">sd</span> =</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size1 = <span class="keyword">sizeof</span>(sd);</span><br><span class="line">    <span class="keyword">int</span> size2 = <span class="keyword">sizeof</span>(struct node);</span><br><span class="line">    <span class="keyword">int</span> size3 = <span class="keyword">sizeof</span> sd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\t%d\t&quot;</span>, size1, size2, size3); <span class="comment">// 12 12 12</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">int</span> size4 = <span class="keyword">sizeof</span>(struct node2)</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,size4) <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指定对齐值"><a href="#指定对齐值" class="headerlink" title="指定对齐值"></a>指定对齐值</h3><ul>
<li>指定对齐值预处理指令<code>#pragma pack(n)</code>可以改变默认对齐数。n取值是1，2，4，8，16</li>
<li>计算方式：<ul>
<li>结构体变量的首地址，必须是<code>MIN&#123;结构体最大基本数据类型成员所占字节数，指定对齐方式&#125;</code>大小的整数倍</li>
<li>结构体每个成员相对于结构体首地址的偏移量，都是<code>MIN&#123;基本数据类型成员，指定对齐方式&#125;</code>大小的整数倍。</li>
<li>结构体的总大小，为<code>MIN&#123;结构体最大基本数据类型成员所占字节数（将嵌套结构体里的基本类型也算上，得出最大基本数据类型成员所占字节数），指定对齐方式&#125;</code>大小的整数倍</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> cha;</span><br><span class="line">    <span class="keyword">int</span> ia;</span><br><span class="line">    <span class="keyword">char</span> chb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size1 = <span class="keyword">sizeof</span>(struct node);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, size1); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快速判断结构体的成员偏移量"><a href="#快速判断结构体的成员偏移量" class="headerlink" title="快速判断结构体的成员偏移量"></a>快速判断结构体的成员偏移量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> cha;</span><br><span class="line">  <span class="keyword">int</span> ia;</span><br><span class="line">  <span class="keyword">char</span> chb;</span><br><span class="line">  <span class="keyword">double</span> dx;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">int</span> ib;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// (struct Node*)0：把零地址强转为结构体Node的指针</span></span><br><span class="line">	<span class="comment">// ((struct Node *) 0)-&gt;ib：取出成员ib</span></span><br><span class="line">  <span class="comment">// &amp;((struct Node*)0)-&gt;ib：取出ib对应的地址</span></span><br><span class="line">  <span class="comment">// (int)(&amp;((struct Node*)0)-&gt;ib)：将地址强转为整型</span></span><br><span class="line">  <span class="keyword">int</span> dist = (<span class="keyword">int</span>)(&amp;((struct Node*)<span class="number">0</span>)-&gt;ib);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将其定义为宏函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> my_offset(type, exp) (int)&amp;(((type*)0)-&gt;exp)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> cha;</span><br><span class="line">    <span class="keyword">int</span> ia;</span><br><span class="line">    <span class="keyword">char</span> chb;</span><br><span class="line">    <span class="keyword">double</span> dx;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> ib;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, my_offset(struct Node, dx)); <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><ul>
<li>位域会修改<code>成员基本数据类型所占字节数</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  	<span class="comment">// unsigned char本来有8位的空间，现在只能使用3位(从低地址算起)</span></span><br><span class="line">  	<span class="comment">// unsigned char本来有8位的空间，所以位域不能超过8</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a:<span class="number">3</span>;</span><br><span class="line">  	<span class="comment">// char本来有8位的空间，现在只能使用2位(从低地址算起)</span></span><br><span class="line">    <span class="keyword">char</span> b:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c:<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> d:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">x</span> =</span> &#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">17</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  	<span class="comment">// 超出的位数会被舍弃</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\t%d\t%d&quot;</span>, x.a, x.b, x.c, x.d);<span class="comment">// 7 -2 17 -8</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 因为位域会影响基本数据类型的所占字节数，所以就会影响类型指针的解析能力，进而就不能再使用指针了</span></span><br><span class="line">  	<span class="keyword">char</span> *ptr = &amp;x.a; <span class="comment">//  error: cannot take address of bit-field &#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位域会影响<code>成员基本数据类型所占字节数</code>，进而也会影响结构体的对齐方式。</p>
</blockquote>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>