<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;组织结构&quot;&gt;&lt;a href=&quot;#组织结构&quot; class=&quot;headerlink&quot; title=&quot;组织结构&quot;&gt;&lt;/a&gt;组织结构&lt;/h2&gt;&lt;p&gt;本书分为4个部分。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>C语言程序设计：现代方法（第2版） | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Clang/" rel="tag">Clang</a></div><div class="post-time">2021-11-08</div></div></div><div class="container post-header"><h1>C语言程序设计：现代方法（第2版）</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">组织结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E9%83%A8%E5%88%86-C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">第1部分 C语言的基本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">2.1.</span> <span class="toc-text">编译和链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4%E7%9A%84%E9%99%A4%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">向上取整的除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%BB%BA%E8%AE%AE%E9%81%B5%E5%BE%AA%E5%8E%86%E5%8F%B2%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%A8%E5%A4%A7%E5%86%99"><span class="toc-number">2.3.</span> <span class="toc-text">宏定义建议遵循历史，使用全大写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E5%86%99%E8%9B%87%E5%BD%A2"><span class="toc-number">2.4.</span> <span class="toc-text">C普通变量建议使用小写蛇形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-number">2.5.</span> <span class="toc-text">GCC命令行选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%B0%86%E6%B3%A8%E9%87%8A%E6%9B%BF%E6%8D%A2%E6%88%90%E7%A9%BA%E6%A0%BC"><span class="toc-number">2.6.</span> <span class="toc-text">编译器将注释替换成空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf%E5%87%BD%E6%95%B0%E8%AF%86%E5%88%AB%E6%95%B4%E6%95%B0%E6%88%96%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">2.7.</span> <span class="toc-text">scanf函数识别整数或浮点数的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf%E7%9A%84%E9%98%9F%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">2.8.</span> <span class="toc-text">scanf的队列问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%BC%9A%E6%A0%B9%E6%8D%AE%E6%9C%BA%E5%99%A8%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%8D%E5%90%8C%E8%80%8C%E4%B8%8D%E5%90%8C"><span class="toc-number">2.9.</span> <span class="toc-text">整数类型的取值范围会根据机器和编译器的不同而不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">2.10.</span> <span class="toc-text">数字转义序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf-%E5%92%8Cgetchar-%E5%87%BD%E6%95%B0%E9%83%BD%E6%98%AF%E4%BB%8E%E8%BE%93%E5%85%A5%E6%B5%81%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%80%BC%E7%9A%84"><span class="toc-number">2.11.</span> <span class="toc-text">scanf()和getchar()函数都是从输入流缓冲区中读取值的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%BA%E8%BD%AC%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E6%B3%A8%E6%84%8F"><span class="toc-number">2.12.</span> <span class="toc-text">通过强转解决数据溢出问题注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86arrlen%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%AE%8F"><span class="toc-number">2.13.</span> <span class="toc-text">将arrlen设置为宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%AC%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E6%98%AF%E5%90%88%E6%B3%95%E7%9A%84"><span class="toc-number">2.14.</span> <span class="toc-text">对同一个数组元素进行多次初始化操作是合法的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E5%AE%9E%E5%8F%82%E5%92%8C%E5%BD%A2%E5%8F%82%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-number">2.15.</span> <span class="toc-text">允许实参和形参类型不匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-number">2.16.</span> <span class="toc-text">函数参数使用变长数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">2.17.</span> <span class="toc-text">注意全局变量带来的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E7%90%86%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.18.</span> <span class="toc-text">合理的文件语法顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E9%83%A8%E5%88%86-C%E8%AF%AD%E8%A8%80%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">第2部分 C语言的高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%EF%BC%8C%E5%9B%9E%E9%81%BF%E6%8E%89%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%80%BC%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">将返回值作为函数指针参数，回避掉函数只能返回一个值的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%AF%94%E8%BE%83"><span class="toc-number">3.2.</span> <span class="toc-text">指针比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84x%E4%B8%8Ey%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text">多维数组x与y的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.4.</span> <span class="toc-text">多维数组的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">自动变量与静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text">字符数组与字符指针的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.7.</span> <span class="toc-text">函数返回字符串的四种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scanf-%E5%87%BD%E6%95%B0%E4%B8%8Egets-%E5%87%BD%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">scanf 函数与gets 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%EF%BC%8C%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E7%82%B9"><span class="toc-number">3.9.</span> <span class="toc-text">设计输入函数，需要考虑的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%93"><span class="toc-number">3.10.</span> <span class="toc-text">C语言的字符串库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#strcpy-%E5%87%BD%E6%95%B0"><span class="toc-number">3.10.1.</span> <span class="toc-text">strcpy 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcat"><span class="toc-number">3.10.2.</span> <span class="toc-text">strcat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcmp"><span class="toc-number">3.10.3.</span> <span class="toc-text">strcmp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%83%AF%E7%94%A8%E6%B3%95"><span class="toc-number">3.11.</span> <span class="toc-text">字符串惯用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.11.1.</span> <span class="toc-text">遍历字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E5%88%B6"><span class="toc-number">3.11.2.</span> <span class="toc-text">字符串复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84"><span class="toc-number">3.12.</span> <span class="toc-text">字符串数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.13.</span> <span class="toc-text">预处理器的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB"><span class="toc-number">3.14.</span> <span class="toc-text">预处理指令分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E4%B8%93%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%92%8C"><span class="toc-number">3.15.</span> <span class="toc-text">预处理指令专用运算符#和##</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BE%83%E9%95%BF%E7%9A%84%E5%AE%8F"><span class="toc-number">3.16.</span> <span class="toc-text">创建较长的宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">3.17.</span> <span class="toc-text">预定义宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">3.18.</span> <span class="toc-text">条件编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">3.19.</span> <span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9C%A8-h%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="toc-number">3.20.</span> <span class="toc-text">为什么需要在.h文件中声明变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%9A%E6%96%87%E4%BB%B6%E7%A8%8B%E5%BA%8F%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.21.</span> <span class="toc-text">构建多文件程序步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#makefile"><span class="toc-number">3.21.1.</span> <span class="toc-text">makefile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%9C%9F%E9%97%B4%E7%9A%84%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5"><span class="toc-number">3.21.2.</span> <span class="toc-text">链接期间的错误排查</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><p>本书分为4个部分。</p>
<ul>
<li><strong>C语言的基本特性</strong> 。第1章~第10章包含的C语言内容足以帮助读者编写出使用数组和函数的单文件程序。</li>
<li><strong>C语言的高级特性</strong> 。第11章~第20章建立在前面各章内容的基础上，内容有一定的难度，深入介绍了指针、字符串、预处理器、结构、联合、枚举以及C语言的底层特性。此外，第15章和第19章提供了程序设计方面的指导。</li>
<li><strong>C语言标准库</strong> 。第21章~第27章集中介绍C语言库——与编译器相关联的庞大函数集合。其中一部分内容适合讲解，但大部分材料更适合作为参考。</li>
<li><strong>参考资料</strong> 。附录A给出了C语言运算符的完整列表。附录B描述了C99和C89之间的主要差别。附录C讨论了C89和经典C之间的差异。附录D按字母顺序列出了C89和C99标准库中的全部函数，并为每个函数给出了详尽的说明。附录E列出了ASCII字符集。还有一个带注解的参考文献列表为读者指明了其他的信息来源。</li>
</ul>
<h2 id="第1部分-C语言的基本特性"><a href="#第1部分-C语言的基本特性" class="headerlink" title="第1部分 C语言的基本特性"></a>第1部分 C语言的基本特性</h2><h3 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h3><p>把程序转化为机器可以执行的形式。对于C程序来说，通常包含下列3个步骤。</p>
<ul>
<li><strong>预处理</strong> 。首先程序会被送交给<strong>预处理器</strong> （preprocessor）。预处理器执行以<code>#</code> 开头的命令（通常称为<strong>指令</strong> ）。预处理器有点类似于编辑器，它可以给程序添加内容，也可以对程序进行修改。</li>
<li><strong>编译</strong> 。修改后的程序现在可以进入<strong>编译器</strong> （compiler）了。编译器会把程序翻译成机器指令（即<strong>目标代码</strong> ）。然而，这样的程序还是不可以运行的。</li>
<li><strong>链接</strong> 。在最后一个步骤中，<strong>链接器</strong> （linker）把由编译器产生的目标代码和所需的其他附加代码整合在一起，这样才最终产生了完全可执行的程序。这些附加代码包括程序中用到的库函数（如<code>printf</code> 函数）。</li>
</ul>
<h3 id="向上取整的除法"><a href="#向上取整的除法" class="headerlink" title="向上取整的除法"></a>向上取整的除法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight是向下取整</span></span><br><span class="line">weight = volume / <span class="number">166</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上取整: (被除数 + (除数 - 1)) / 除数</span></span><br><span class="line">weight = (volume + <span class="number">165</span>) / <span class="number">166</span>;</span><br></pre></td></tr></table></figure>



<h3 id="宏定义建议遵循历史，使用全大写"><a href="#宏定义建议遵循历史，使用全大写" class="headerlink" title="宏定义建议遵循历史，使用全大写"></a>宏定义建议遵循历史，使用全大写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECIPROCAL_OF_PI (1.0f / 3.14159f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意要加f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14f</span></span><br></pre></td></tr></table></figure>



<h3 id="C普通变量建议使用小写蛇形"><a href="#C普通变量建议使用小写蛇形" class="headerlink" title="C普通变量建议使用小写蛇形"></a>C普通变量建议使用小写蛇形</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> symbol_table;</span><br><span class="line"><span class="keyword">char</span>[] name_and_address;</span><br></pre></td></tr></table></figure>



<h3 id="GCC命令行选项"><a href="#GCC命令行选项" class="headerlink" title="GCC命令行选项"></a>GCC命令行选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Wall</code></td>
<td>使编译器在检测到可能的错误时生成警告消息。（<code>-W</code> 后面可以加上具体的警告代码，<code>-Wall</code> 表示“所有的<code>-W</code> 选项”。）为了获得最好的效果，该选项应与<code>-O</code> 选项结合使用。</td>
</tr>
<tr>
<td><code>-W</code></td>
<td>除了<code>-Wall</code> 生成的警告消息外，还需要针对具体情况的额外警告消息。</td>
</tr>
<tr>
<td><code>-pedantic</code></td>
<td>根据C标准的要求生成警告消息。这样可以避免在程序中使用非标准特性。</td>
</tr>
<tr>
<td><code>-ansi</code></td>
<td>禁用GCC的非标准C特性，并启用一些不太常用的标准特性。</td>
</tr>
<tr>
<td><code>-std=c89</code> 或<code>-std=c99</code></td>
<td>指明使用哪个版本的C编译器来检查程序。</td>
</tr>
</tbody></table>
<p>这些选项常常可以结合使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O -Wall -W -pedantic -ansi -std=c99 -o pun pun.c</span><br></pre></td></tr></table></figure>



<h3 id="编译器将注释替换成空格"><a href="#编译器将注释替换成空格" class="headerlink" title="编译器将注释替换成空格"></a>编译器将注释替换成空格</h3><p>一些早期的编译器会删除每条注释中的所有字符，使得语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a/**/b = 0;</span><br></pre></td></tr></table></figure>

<p>可能被编译器理解成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab = 0;</span><br></pre></td></tr></table></figure>

<p>然而，依据C标准，编译器必须用一个空格字符替换每条注释语句，因此上面提到的技巧并不可行。我们实际上会得到下面的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b = 0;</span><br></pre></td></tr></table></figure>



<h3 id="scanf函数识别整数或浮点数的规则"><a href="#scanf函数识别整数或浮点数的规则" class="headerlink" title="scanf函数识别整数或浮点数的规则"></a>scanf函数识别整数或浮点数的规则</h3><ul>
<li>在要求读入整数时，<code>scanf</code> 函数首先寻找正号或负号，然后读取数字直到读到一个非数字时才停止。</li>
<li>当要求读入浮点数时，<code>scanf</code> 函数会寻找一个正号或负号（可选），随后是一串数字（可能含有小数点），再后是一个指数（可选）。指数由字母<code>e</code> （或者字母<code>E</code> ）、可选的符号和一个或多个数字构成。</li>
<li>在用于<code>scanf</code> 函数时，转换说明<code>%e</code> 、<code>%f</code> 和<code>%g</code> 是可以互换的，这3种转换说明在识别浮点数方面都遵循相同的规则。</li>
</ul>
<h3 id="scanf的队列问题"><a href="#scanf的队列问题" class="headerlink" title="scanf的队列问题"></a>scanf的队列问题</h3><p>当<code>scanf</code> 函数遇到一个不可能属于当前项的字符时， 它会把此字符<strong>放回原处</strong>，以便在扫描下一个输入项或者下一次调用<code>scanf</code> 函数时再次读入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%f%f&quot;</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br><span class="line"><span class="comment">// 用户输入: 1-20.3-4.0e3\n</span></span><br></pre></td></tr></table></figure>

<ol>
<li>转换说明<code>%d</code> 。第一个非空的输入字符是<code>1</code> ；因为整数可以以<code>1</code> 开始，所以<code>scanf</code> 函数接着读取下一个字符，即<code>-</code> 。<code>scanf</code> 函数识别出字符<code>-</code> 不能出现在整数内，所以把1存入变量<code>i</code> 中，而把字符<code>-</code> 放回原处。</li>
<li>转换说明<code>%d</code> 。随后，<code>scanf</code> 函数读取字符<code>-</code> 、<code>2</code> 、<code>0</code> 和<code>.</code> （句点）。因为整数不能包含小数点，所以<code>scanf</code> 函数把-20存入变量<code>j</code> 中，而把字符<code>.</code> 放回原处。</li>
<li>转换说明<code>%f</code> 。接下来<code>scanf</code> 函数读取字符<code>.</code> 、<code>3</code> 和<code>-</code> 。因为浮点数不能在数字后边有负号，所以<code>scanf</code> 函数把0.3存入变量<code>x</code> 中，而将字符<code>-</code> 放回原处。</li>
<li>转换说明<code>%f</code> 。最后，<code>scanf</code> 函数读取字符<code>-</code> 、<code>4</code> 、<code>.</code> 、<code>0</code> 、<code>e</code> 、<code>3</code> 和<code>¤</code> （换行符）。因为浮点数不能包含换行符，所以<code>scanf</code> 函数把<code>-4.0*10^3</code> 存入变量<code>y</code> 中，而把换行符放回原处。</li>
</ol>
<p>在这个例子中，<code>scanf</code> 函数能够把格式串中的每个转换说明与一个输入项进行匹配。<strong>因为换行符没有读取，它将留给下一次<code>scanf</code> 函数调用</strong>。</p>
<blockquote>
<p>在<code>scanf</code> 格式串末尾放置换行符通常是一个坏主意。对<code>scanf</code> 函数来说，格式串中的换行符等价于空格，两者都会引发<code>scanf</code> 函数提前进入到下一个非空白字符。例如，如果格式串是<code>&quot;%d\n&quot;</code> ，那么<code>scanf</code> 函数将跳过空白字符，读取一个整数，然后跳到下一个非空白字符处。像这样的格式串可能会导致交互式程序一直“挂起”直到用户输入一个非空白字符为止。</p>
</blockquote>
<p>通过编写含有普通字符和转换说明的格式串能更进一步地理解模式匹配的概念。处理格式串中的普通字符时，<code>scanf</code> 函数采取的动作依赖于这个字符是否为空白字符。</p>
<ul>
<li><strong>空白字符</strong> 。当在格式串中遇到一个或多个连续的空白字符时，<code>scanf</code> 函数从输入中重复读空白字符直到遇到一个非空白字符（把该字符“放回原处”）为止。格式串中空白字符的数量无关紧要，格式串中的一个空白字符可以与输入中任意数量的空白字符相匹配。（附带提一下，在格式串中包含空白字符并不意味着输入中必须包含空白字符。格式串中的一个空白字符可以与输入中<strong>任意</strong> 数量的空白字符相匹配，包括零个。）</li>
<li><strong>其他字符</strong> 。当在格式串中遇到非空白字符时，<code>scanf</code> 函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么<code>scanf</code> 函数会放弃输入字符而继续处理格式串。如果两个字符不匹配，那么<code>scanf</code> 函数会把不匹配的字符放回输入中，然后异常退出，而不进一步处理格式串或者从输入中读取字符。</li>
</ul>
<p>假设格式串是<code>&quot;%d/%d&quot;</code> 。如果输入是(<code>•</code>表示空格)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• 5/ • 96</span><br></pre></td></tr></table></figure>

<p>在寻找整数时，<code>scanf</code> 函数会跳过第一个空格，把<code>%d</code> 与<code>5</code> 相匹配，把<code>/</code> 与<code>/</code> 相匹配，在寻找下一个整数时跳过一个空格，并且把<code>%d</code> 与<code>96</code> 相匹配。</p>
<p>另一方面，如果输入是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• 5 • / • 96</span><br></pre></td></tr></table></figure>

<p><code>scanf</code> 函数会跳过一个空格，把<code>%d</code> 与<code>5</code> 相匹配，然后试图把格式串中的<code>/</code> 与输入中的空格相匹配。但是二者不匹配，所以<code>scanf</code> 函数把空格放回原处，把字符<code>•/•96</code> 留给下一次<code>scanf</code> 函数调用来读取。为了允许第一个数后边有空格，应使用格式串<code>&quot;%d /%d&quot;</code> 。</p>
<p>编写一个程序，要求用户输入一个两位数，然后按数位的逆序打印出这个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%1d%1d&quot;</span>,&amp;i,&amp;k);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%1d%1d&quot;</span>,k,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="整数类型的取值范围会根据机器和编译器的不同而不同"><a href="#整数类型的取值范围会根据机器和编译器的不同而不同" class="headerlink" title="整数类型的取值范围会根据机器和编译器的不同而不同"></a>整数类型的取值范围会根据机器和编译器的不同而不同</h3><p>32位机的整数类型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>short int</code></td>
<td align="center">-32 768</td>
<td align="center">32 767</td>
</tr>
<tr>
<td align="center"><code>unsigned short int</code></td>
<td align="center">0</td>
<td align="center">65 535</td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center">-2 147 483 648</td>
<td align="center">2 147 483 647</td>
</tr>
<tr>
<td align="center"><code>unsigned int</code></td>
<td align="center">0</td>
<td align="center">4 294 967 295</td>
</tr>
<tr>
<td align="center"><code>long int</code></td>
<td align="center">-2 147 483 648</td>
<td align="center">2 147 483 647</td>
</tr>
<tr>
<td align="center"><code>unsigned long int</code></td>
<td align="center">0</td>
<td align="center">4 294 967 295</td>
</tr>
</tbody></table>
<p>64位机的整数类型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>short int</code></td>
<td align="center">-32 768</td>
<td align="center">32 767</td>
</tr>
<tr>
<td align="center"><code>unsigned short int</code></td>
<td align="center">0</td>
<td align="center">65 535</td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center">-2 147 483 648</td>
<td align="center">2 147 483 647</td>
</tr>
<tr>
<td align="center"><code>unsigned int</code></td>
<td align="center">0</td>
<td align="center">4 294 967 295</td>
</tr>
<tr>
<td align="center"><code>long int</code></td>
<td align="center">-9 223 372 036 854 775 808</td>
<td align="center">9 223 372 036 854 775 807</td>
</tr>
<tr>
<td align="center"><code>unsigned long int</code></td>
<td align="center">0</td>
<td align="center">18 446 744 073 709 551 615</td>
</tr>
</tbody></table>
<blockquote>
<p>上面的取值范围不是C标准强制的，会<strong>随着编译器的不同而不同</strong>。对于特定的实现，确定整数类型范围的一种方法是检查<code>&lt;limits.h&gt;</code> 头。其中定义了表示每种整数类型的最大值和最小值的宏。</p>
</blockquote>
<h3 id="数字转义序列"><a href="#数字转义序列" class="headerlink" title="数字转义序列"></a>数字转义序列</h3><p>数字转义序列可以表示<strong>任何</strong>字符。</p>
<p>为了把特殊字符书写成数字转义序列，首先需要在表中查找字符的八进制或十六进制值。例如，某个ASCII码转义字符（十进制值为27）对应的八进制值为33，对应的十六进制值为1B。上述八进制或十六进制码可以用来书写转义序列。</p>
<ul>
<li><p><strong>八进制转义序列</strong> 由字符<code>\</code> 和跟随其后的一个最多含有三位数字的八进制数组成。（此数必须表示为无符号字符，所以最大值通常是八进制的377。）</p>
<p>例如，可以将转义字符写成<code>\33</code> 或<code>\033</code> 。跟八进制常量不同，转义序列中的八进制数不一定要用0开头。</p>
</li>
<li><p><strong>十六进制转义序列</strong> 由<code>\x</code> 和跟随其后的一个十六进制数组成。虽然标准C对于十六进制数的位数没有限制，但其必须表示成无符号字符（因此，如果字符长度是8位，那么十六进制数的值不能超过<code>FF</code> ）。若采用这种表示法，可以把转义字符写成<code>\x1b</code> 或<code>\x1B</code> 的形式。字符<code>x</code> 必须小写，但是十六进制的数字（例如<code>b</code> ）不限大小写。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">十进制</th>
<th align="center">转义序列八进制</th>
<th align="center">转义序列十六进制</th>
<th align="center">转义序列字符</th>
<th align="center">字符</th>
<th align="center">十进制</th>
<th align="center">字符</th>
<th align="center">十进制</th>
<th align="center">字符</th>
<th>十进制</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center"><code>\0</code></td>
<td align="center"><code>\x00</code></td>
<td align="center"></td>
<td align="center"><em>nul</em></td>
<td align="center">32</td>
<td align="center"></td>
<td align="center">64</td>
<td align="center">@</td>
<td>96</td>
<td>`</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><code>\1</code></td>
<td align="center"><code>\x01</code></td>
<td align="center"></td>
<td align="center"><em>soh</em> (^A)</td>
<td align="center">33</td>
<td align="center">!</td>
<td align="center">65</td>
<td align="center">A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>\2</code></td>
<td align="center"><code>\x02</code></td>
<td align="center"></td>
<td align="center"><em>stx</em> (^B)</td>
<td align="center">34</td>
<td align="center">“</td>
<td align="center">66</td>
<td align="center">B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>\3</code></td>
<td align="center"><code>\x03</code></td>
<td align="center"></td>
<td align="center"><em>etx</em> (^C)</td>
<td align="center">35</td>
<td align="center">#</td>
<td align="center">67</td>
<td align="center">C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>\4</code></td>
<td align="center"><code>\x04</code></td>
<td align="center"></td>
<td align="center"><em>eot</em> (^D)</td>
<td align="center">36</td>
<td align="center"></td>
<td align="center">68</td>
<td align="center">D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>\5</code></td>
<td align="center"><code>\x05</code></td>
<td align="center"></td>
<td align="center"><em>enq</em> (^E)</td>
<td align="center">37</td>
<td align="center">%</td>
<td align="center">69</td>
<td align="center">E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><code>\6</code></td>
<td align="center"><code>\x06</code></td>
<td align="center"></td>
<td align="center"><em>ack</em> (^F)</td>
<td align="center">38</td>
<td align="center">&amp;</td>
<td align="center">70</td>
<td align="center">F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>\7</code></td>
<td align="center"><code>\x07</code></td>
<td align="center"><code>\a</code></td>
<td align="center"><em>bel</em> (^G)</td>
<td align="center">39</td>
<td align="center">‘</td>
<td align="center">71</td>
<td align="center">G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><code>\10</code></td>
<td align="center"><code>\x08</code></td>
<td align="center"><code>\b</code></td>
<td align="center"><em>bs</em>  (^H)</td>
<td align="center">40</td>
<td align="center">(</td>
<td align="center">72</td>
<td align="center">H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>\11</code></td>
<td align="center"><code>\x09</code></td>
<td align="center"><code>\t</code></td>
<td align="center"><em>ht</em>  (^I)</td>
<td align="center">41</td>
<td align="center">)</td>
<td align="center">73</td>
<td align="center">I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><code>\12</code></td>
<td align="center"><code>\x0a</code></td>
<td align="center"><code>\n</code></td>
<td align="center"><em>lf</em>  (^J)</td>
<td align="center">42</td>
<td align="center">*</td>
<td align="center">74</td>
<td align="center">J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><code>\13</code></td>
<td align="center"><code>\x0b</code></td>
<td align="center"><code>\v</code></td>
<td align="center"><em>vt</em>  (^K)</td>
<td align="center">43</td>
<td align="center">+</td>
<td align="center">75</td>
<td align="center">K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><code>\14</code></td>
<td align="center"><code>\x0c</code></td>
<td align="center"><code>\f</code></td>
<td align="center"><em>ff</em>  (^L)</td>
<td align="center">44</td>
<td align="center">,</td>
<td align="center">76</td>
<td align="center">L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><code>\15</code></td>
<td align="center"><code>\x0d</code></td>
<td align="center"><code>\r</code></td>
<td align="center"><em>cr</em>  (^M)</td>
<td align="center">45</td>
<td align="center">-</td>
<td align="center">77</td>
<td align="center">M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><code>\16</code></td>
<td align="center"><code>\x0e</code></td>
<td align="center"></td>
<td align="center"><em>so</em>  (^N)</td>
<td align="center">46</td>
<td align="center">.</td>
<td align="center">78</td>
<td align="center">N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><code>\17</code></td>
<td align="center"><code>\x0f</code></td>
<td align="center"></td>
<td align="center"><em>si</em>  (^O)</td>
<td align="center">47</td>
<td align="center">/</td>
<td align="center">79</td>
<td align="center">O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><code>\20</code></td>
<td align="center"><code>\x10</code></td>
<td align="center"></td>
<td align="center"><em>dle</em> (^P)</td>
<td align="center">48</td>
<td align="center">0</td>
<td align="center">80</td>
<td align="center">P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center"><code>\21</code></td>
<td align="center"><code>\x11</code></td>
<td align="center"></td>
<td align="center"><em>dc1</em> (^Q)</td>
<td align="center">49</td>
<td align="center">1</td>
<td align="center">81</td>
<td align="center">Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center"><code>\22</code></td>
<td align="center"><code>\x12</code></td>
<td align="center"></td>
<td align="center"><em>dc2</em> (^R)</td>
<td align="center">50</td>
<td align="center">2</td>
<td align="center">82</td>
<td align="center">R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center"><code>\23</code></td>
<td align="center"><code>\x13</code></td>
<td align="center"></td>
<td align="center"><em>dc3</em> (^S)</td>
<td align="center">51</td>
<td align="center">3</td>
<td align="center">83</td>
<td align="center">S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center"><code>\24</code></td>
<td align="center"><code>\x14</code></td>
<td align="center"></td>
<td align="center"><em>dc4</em> (^T)</td>
<td align="center">52</td>
<td align="center">4</td>
<td align="center">84</td>
<td align="center">T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center"><code>\25</code></td>
<td align="center"><code>\x15</code></td>
<td align="center"></td>
<td align="center"><em>nak</em> (^U)</td>
<td align="center">53</td>
<td align="center">5</td>
<td align="center">85</td>
<td align="center">U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center"><code>\26</code></td>
<td align="center"><code>\x16</code></td>
<td align="center"></td>
<td align="center"><em>syn</em> (^V)</td>
<td align="center">54</td>
<td align="center">6</td>
<td align="center">86</td>
<td align="center">V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center"><code>\27</code></td>
<td align="center"><code>\x17</code></td>
<td align="center"></td>
<td align="center"><em>etb</em> (^W)</td>
<td align="center">55</td>
<td align="center">7</td>
<td align="center">87</td>
<td align="center">W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center"><code>\30</code></td>
<td align="center"><code>\x18</code></td>
<td align="center"></td>
<td align="center"><em>can</em> (^X)</td>
<td align="center">56</td>
<td align="center">8</td>
<td align="center">88</td>
<td align="center">X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td align="center">25</td>
<td align="center"><code>\31</code></td>
<td align="center"><code>\x19</code></td>
<td align="center"></td>
<td align="center"><em>em</em>  (^Y)</td>
<td align="center">57</td>
<td align="center">9</td>
<td align="center">89</td>
<td align="center">Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center"><code>\32</code></td>
<td align="center"><code>\x1a</code></td>
<td align="center"></td>
<td align="center"><em>sub</em> (^Z)</td>
<td align="center">58</td>
<td align="center">:</td>
<td align="center">90</td>
<td align="center">Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center"><code>\33</code></td>
<td align="center"><code>\x1b</code></td>
<td align="center"></td>
<td align="center"><em>esc</em></td>
<td align="center">59</td>
<td align="center">;</td>
<td align="center">91</td>
<td align="center">[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><code>\34</code></td>
<td align="center"><code>\x1c</code></td>
<td align="center"></td>
<td align="center"><em>fs</em></td>
<td align="center">60</td>
<td align="center">&lt;</td>
<td align="center">92</td>
<td align="center">\</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center"><code>\35</code></td>
<td align="center"><code>\x1d</code></td>
<td align="center"></td>
<td align="center"><em>gs</em></td>
<td align="center">61</td>
<td align="center">=</td>
<td align="center">93</td>
<td align="center">]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center"><code>\36</code></td>
<td align="center"><code>\x1e</code></td>
<td align="center"></td>
<td align="center"><em>rs</em></td>
<td align="center">62</td>
<td align="center">&gt;</td>
<td align="center">94</td>
<td align="center">^</td>
<td>126</td>
<td>~</td>
</tr>
<tr>
<td align="center">31</td>
<td align="center"><code>\37</code></td>
<td align="center"><code>\x1f</code></td>
<td align="center"></td>
<td align="center"><em>us</em></td>
<td align="center">63</td>
<td align="center">?</td>
<td align="center">95</td>
<td align="center">_</td>
<td>127</td>
<td>del</td>
</tr>
</tbody></table>
<p>作为字符常量使用时，转义序列必须用一对单引号括起来。例如，表示转义字符的常量可以写成<code>&#39;\33&#39;</code> （或<code>&#39;\x1b&#39;</code> ）的形式。转义序列可能有点隐晦，所以采用<code>#define</code> 的方式给它们命名通常是个不错的主意：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ESC <span class="meta-string">&#x27;\33&#x27;</span>    <span class="comment">/* ASCII escape character */</span></span></span><br></pre></td></tr></table></figure>



<h3 id="scanf-和getchar-函数都是从输入流缓冲区中读取值的"><a href="#scanf-和getchar-函数都是从输入流缓冲区中读取值的" class="headerlink" title="scanf()和getchar()函数都是从输入流缓冲区中读取值的"></a>scanf()和getchar()函数都是从输入流缓冲区中读取值的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a command: &quot;</span>);</span><br><span class="line">command = getchar();</span><br></pre></td></tr></table></figure>

<p>在读入<code>i</code> 的同时，<code>scanf</code> 函数调用将会留下没有消耗掉的任意字符，包括（但不限于）换行符。<code>getchar</code> 函数随后将取回第一个剩余字符，但这不是我们所希望的结果。</p>
<h3 id="通过强转解决数据溢出问题注意"><a href="#通过强转解决数据溢出问题注意" class="headerlink" title="通过强转解决数据溢出问题注意"></a>通过强转解决数据溢出问题注意</h3><p>可以使用强制类型转换避免数据溢出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">i = (<span class="keyword">long</span>) j * j;</span><br></pre></td></tr></table></figure>

<p>因为强制运算符的优先级高于<code>*</code> ，所以第一个变量<code>j</code> 会被转换成<code>long int</code> 类型，同时也迫使第二个<code>j</code> 进行转换。注意，语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (<span class="keyword">long</span>) (j * j);   <span class="comment">/*** WRONG ***/</span></span><br></pre></td></tr></table></figure>

<p>是不对的，因为溢出在强制类型转换之前就已经发生了。</p>
<h3 id="将arrlen设置为宏"><a href="#将arrlen设置为宏" class="headerlink" title="将arrlen设置为宏"></a>将arrlen设置为宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE(arr) (int)(sizeof(arr) / sizeof(arr[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">100</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ARR_SIZE(arr)); <span class="comment">// 100</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">5</span>][<span class="number">9</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                 &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; ARR_SIZE(arr);i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; ARR_SIZE(arr[<span class="number">0</span>]); j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对同一个数组元素进行多次初始化操作是合法的"><a href="#对同一个数组元素进行多次初始化操作是合法的" class="headerlink" title="对同一个数组元素进行多次初始化操作是合法的"></a>对同一个数组元素进行多次初始化操作是合法的</h3><p>工作原理：编译器在处理初始化式列表时，会记录下一个待初始化的数组元素的位置。正常情况下，下一个元素是刚被初始化的元素后面的那个。但是，当列表中出现初始化式时，下一个元素会被强制为指示符对应的元素，即使该元素已经被初始化了。</p>
<p>下面逐步分析编译器处理数组<code>a</code> 的初始化式的操作：</p>
<ul>
<li>用4初始化元素0，下一个待初始化的是元素1；</li>
<li>用9初始化元素1，下一个待初始化的是元素2；</li>
<li>用1初始化元素2，下一个待初始化的是元素3；</li>
<li>用8初始化元素3，下一个待初始化的是元素4；</li>
<li>[0]指示符导致下一个元素是元素0，所以用5初始化元素0（替换先前存储的4）。下一个待初始化的是元素1；</li>
<li>用7初始化元素1（替换先前存储的9）。下一个待初始化的是元素2（跟本例不相关，因为已经到达列表的末尾）。</li>
</ul>
<p>最终效果跟下面的声明一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;5, 7, 1, 8&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，数组的长度为4。</p>
<h3 id="允许实参和形参类型不匹配"><a href="#允许实参和形参类型不匹配" class="headerlink" title="允许实参和形参类型不匹配"></a>允许实参和形参类型不匹配</h3><p>C语言允许在实际参数的类型与形式参数的类型不匹配的情况下进行函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">3.0f</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = square(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ret); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数参数使用变长数组"><a href="#函数参数使用变长数组" class="headerlink" title="函数参数使用变长数组"></a>函数参数使用变长数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 明确说明数组长度和参数n相关</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[n], <span class="keyword">int</span> n)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_arr</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> arr[x][y])</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">concatenate</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> a[m], <span class="keyword">int</span> b[n], <span class="keyword">int</span> c[m+n])</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用*号取代数组长度: 数组的长度与形式参数列表中前面的参数相关</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a[*])</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="注意全局变量带来的影响"><a href="#注意全局变量带来的影响" class="headerlink" title="注意全局变量带来的影响"></a>注意全局变量带来的影响</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_one_row</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_all_rows</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = i; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        print_one_row();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    print_all_rows(); <span class="comment">// **********</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="合理的文件语法顺序"><a href="#合理的文件语法顺序" class="headerlink" title="合理的文件语法顺序"></a>合理的文件语法顺序</h3><ol>
<li><code>#include</code> 指令；</li>
<li><code>#define</code> 指令；</li>
<li>类型定义；</li>
<li>外部变量的声明；</li>
<li>除<code>main</code> 函数之外的函数的原型；</li>
<li><code>main</code> 函数的定义；</li>
<li>其他函数的定义。</li>
</ol>
<h2 id="第2部分-C语言的高级特性"><a href="#第2部分-C语言的高级特性" class="headerlink" title="第2部分 C语言的高级特性"></a>第2部分 C语言的高级特性</h2><h3 id="将返回值作为函数指针参数，回避掉函数只能返回一个值的限制"><a href="#将返回值作为函数指针参数，回避掉函数只能返回一个值的限制" class="headerlink" title="将返回值作为函数指针参数，回避掉函数只能返回一个值的限制"></a>将返回值作为函数指针参数，回避掉函数只能返回一个值的限制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE(arr) (int)(sizeof(arr) / sizeof(arr[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">int</span> arr[n], <span class="keyword">int</span> *max, <span class="keyword">int</span> *min)</span> </span>&#123;</span><br><span class="line">    *max = *min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        *max = arr[i] &gt; *max ? arr[i] : *max;</span><br><span class="line">        *min = arr[i] &lt; *min ? arr[i] : *min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">34</span>, <span class="number">82</span>, <span class="number">49</span>, <span class="number">102</span>, <span class="number">7</span>, <span class="number">94</span>, <span class="number">23</span>, <span class="number">11</span>, <span class="number">50</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> max, min;</span><br><span class="line">    max_min(ARR_SIZE(arr), arr, &amp;max, &amp;min);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>, max, min);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指针比较"><a href="#指针比较" class="headerlink" title="指针比较"></a>指针比较</h3><ol>
<li>指针比较只对相同对象才有意义。</li>
<li>如果两个指针指向同一个简单对象，则相等；</li>
<li>如果指针指向同一个结构的不同成员，则指向结构中后声明的成员的指针较大；</li>
<li>如果指针指向同一个联合的不同成员，则相等；</li>
<li>如果指针指向一个数组的不同成员，则它们之间的比较等价于对应下标之间的比较。</li>
<li>如果指针 P 指向数组的最后一个成员，尽管 P+1 已指向数组的界外，但 P+1 仍比 P 大。</li>
</ol>
<h3 id="多维数组x与y的位置"><a href="#多维数组x与y的位置" class="headerlink" title="多维数组x与y的位置"></a>多维数组x与y的位置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE(arr) (int)(sizeof(arr) / sizeof(arr[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">10</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">34</span>, <span class="number">82</span>, <span class="number">49</span>, <span class="number">102</span>, <span class="number">7</span>, <span class="number">94</span>, <span class="number">23</span>, <span class="number">11</span>, <span class="number">50</span>, <span class="number">31</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,   <span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,  <span class="number">10</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>, arr[<span class="number">0</span>][<span class="number">1</span>], arr[<span class="number">1</span>][<span class="number">0</span>]); <span class="comment">// 82,1</span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ARR_SIZE(arr[<span class="number">0</span>])); <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, arr[<span class="number">0</span>][<span class="number">1</span>], arr[<span class="number">1</span>][<span class="number">0</span>]); <span class="comment">// 82,1</span></span><br><span class="line">    <span class="keyword">int</span> *q = arr[<span class="number">0</span>] + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, *q, *(q + <span class="number">10</span>)); <span class="comment">// 49,3</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> x = ARR_SIZE(arr);</span><br><span class="line">    <span class="keyword">int</span> y = ARR_SIZE(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> *end = &amp;(arr[x<span class="number">-1</span>][y<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> *q = arr[<span class="number">0</span>]; q &lt; end; q += y) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, *(q + <span class="number">2</span>)); <span class="comment">// 49,3,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多维数组的指针"><a href="#多维数组的指针" class="headerlink" title="多维数组的指针"></a>多维数组的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>a 不是指向<code>a[0][0]</code> 的指针，而是指向<code>a[0] </code>的指针。否则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>是不能获取到<code>a[0]</code>这个一维数组的长度的。</p>
<h3 id="自动变量与静态变量"><a href="#自动变量与静态变量" class="headerlink" title="自动变量与静态变量"></a>自动变量与静态变量</h3><ul>
<li>C语言中使用auto关键字声明自动变量，使用static关键字声明静态变量。</li>
<li><strong>在函数中定义局部变量时，如果没有被声明为其他类型的变量都是自动变量</strong>。</li>
<li>在编写代码时，有时需要在调用函数中的某个局部变量以后，这个变量的值不消失，并且保持原值不变，也就是该函数所占用的存储空间不被释放，在下次调用该函数时，变量中的值是上次调用该函数结束时变量的值。这时，使用的变量类型是静态变量，使用static 关键字进行声明。</li>
</ul>
<h3 id="字符数组与字符指针的区别"><a href="#字符数组与字符指针的区别" class="headerlink" title="字符数组与字符指针的区别"></a>字符数组与字符指针的区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> date[] = <span class="string">&quot;June 14&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *date = <span class="string">&quot;June 14&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>前者声明<code>date</code> 是一个<strong>数组</strong> ，后者声明<code>date</code> 是一个<strong>指针</strong> 。正因为有了数组和指针之间的紧密关系，才使上面这两个声明中的<code>date</code> 都可以用作字符串。尤其是，任何期望传递字符数组或字符指针的函数都能够接收这两种声明的<code>date</code> 作为参数。</p>
<p>然而，需要注意，不能错误地认为上面这两种<code>date</code> 可以互换。两者之间有很大的差异：</p>
<ul>
<li>在声明为数组时，就像任意数组元素一样，可以修改存储在<code>date</code> 中的字符。在声明为指针时，<code>date</code> 指向字符串字面量，而字符串字面量是不可以修改的。</li>
<li>在声明为数组时，<code>date</code> 是数组名。在声明为指针时，<code>date</code> 是变量，这个变量可以在程序执行期间指向其他字符串。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;C Language&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">&quot;C Language&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    str1[<span class="number">1</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    *(str2+<span class="number">1</span>) = <span class="string">&#x27;-&#x27;</span>;  <span class="comment">//错！不能改变字符串常量的值</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 在静态区开辟“C Language”内存，然后ps指针指向这块内存。</span></span><br><span class="line">  	<span class="comment">// 可以写为：</span></span><br><span class="line">  	<span class="keyword">char</span> *ps;</span><br><span class="line">		ps=<span class="string">&quot;C Language&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 不能写为：</span></span><br><span class="line">  	<span class="keyword">char</span> st[<span class="number">20</span>];</span><br><span class="line">		st=&#123;<span class="string">&quot;C Language&quot;</span>&#125;; <span class="comment">// 数组不能放在=左侧，只能一个一个的赋值</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 在栈区开辟数组p，然后将“123”写入数组p</span></span><br><span class="line">    <span class="keyword">char</span> p[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> arr1[<span class="number">10</span>] = &#123;<span class="string">&quot;hyl&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> arr2[<span class="number">10</span>] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> arr3[] = &#123;<span class="string">&quot;hyl&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> arr4[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr1),<span class="built_in">strlen</span>(arr1)); <span class="comment">// 10,3</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr2),<span class="built_in">strlen</span>(arr2)); <span class="comment">// 10,3</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr3),<span class="built_in">strlen</span>(arr3)); <span class="comment">// 4,3</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr4),<span class="built_in">strlen</span>(arr4)); <span class="comment">// 3,6(不确定)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<ul>
<li><p>从内存上看，<code>char *date = &quot;June 14&quot;;</code>与<code>char date[] = &quot;June 14&quot;;</code>都是指针，唯一的区别就是前者存储在静态区，后者存储在栈区。这就导致了：<strong>前者指针只可读不可写，后者指针可读可写</strong>。</p>
<p>也就是说：**<code>char *date = &quot;June 14”</code>就是<code>char const date[] = &#123;&#39;J&#39;,&#39;u&#39;,&#39;n&#39;,&#39;e&#39;,&#39; &#39;,&#39;1&#39;,&#39;4&#39;,&#39;\0&#39;&#125;;</code>的语法糖罢了**</p>
</li>
<li><p>从内存上看，<code>char arr3[] = &#123;&quot;hyl&quot;&#125;;</code>与<code>char arr4[] = &#123;&#39;h&#39;, &#39;y&#39;, &#39;l&#39;&#125;;</code>都是指针，唯一的区别就是前者在最后添加了<code>\0</code>，后者没有。这就导致了：<strong>后者边界难以确定</strong></p>
</li>
</ul>
</blockquote>
<h3 id="函数返回字符串的四种方法"><a href="#函数返回字符串的四种方法" class="headerlink" title="函数返回字符串的四种方法"></a>函数返回字符串的四种方法</h3><ol>
<li>将字符串指针作为函数参数传入，并返回该指针。</li>
<li>使用malloc函数动态分配内存，注意在主调函数中释放。</li>
<li>返回一个静态局部变量。</li>
<li>使用全局变量。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串指针作为函数参数传入，并返回该指针。</span></span><br><span class="line"><span class="comment">// 典型的strcpy()函数就是采用的这种方法，第一个参数为指向目的字符串的指针,返回值也为这个指针。</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *des, <span class="keyword">const</span> <span class="keyword">char</span> *source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *r = des;</span><br><span class="line">    assert((des != <span class="literal">NULL</span>) &amp;&amp; (source != <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> ((*r++ = *source++) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用malloc函数动态分配内存，注意在主调函数中释放。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">retstring</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * name2;</span><br><span class="line">    name2 = retstring();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,name2);</span><br><span class="line">    <span class="comment">//记住一定要用free释放，否则会造成内存泄露</span></span><br><span class="line">    <span class="built_in">free</span>(name2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">retstring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    name = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line">    <span class="built_in">strcpy</span>(name,<span class="string">&quot;张汉青&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个静态局部变量。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">retstring</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * name2;</span><br><span class="line">    name2 = retstring();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,name2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">retstring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(name,<span class="string">&quot;张汉青&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用全局变量。</span></span><br><span class="line"><span class="keyword">char</span> g_s[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(g_s, <span class="string">&quot;abc &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> g_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="scanf-函数与gets-函数"><a href="#scanf-函数与gets-函数" class="headerlink" title="scanf 函数与gets 函数"></a><code>scanf</code> 函数与<code>gets</code> 函数</h3><ul>
<li>用<code>scanf</code> 函数读入字符串永远不会包含空白字符。因此，<code>scanf</code> 函数通常不会读入一整行输入。换行符会使<code>scanf</code> 函数停止读入，空格符或制表符也会产生同样的结果。</li>
<li>为了一次读入一整行输入，可以使用<code>gets</code> 函数。类似于<code>scanf</code> 函数，<code>gets</code> 函数把读入的字符放到数组中，然后存储一个空字符。</li>
<li>然而，在其他方面<code>gets</code> 函数有些不同于<code>scanf</code> 函数。<ul>
<li><code>gets</code> 函数不会在开始读字符串之前跳过空白字符（<code>scanf</code> 函数会跳过）。</li>
<li><code>gets</code> 函数会持续读入直到找到换行符才停止（<code>scanf</code> 函数会在任意空白字符处停止）。</li>
<li><code>gets</code> 函数会忽略掉换行符，不会把它存储到数组中，用空字符代替换行符。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在把字符读入数组时，<code>scanf</code> 函数和<code>gets</code> 函数都无法检测数组何时被填满。因此，它们存储字符时可能越过数组的边界，这会导致未定义的行为。<code>gets</code> 函数天生就是不安全的，<code>fgets</code> 函数是一种好得多的选择。</p>
</blockquote>
<h3 id="设计输入函数，需要考虑的点"><a href="#设计输入函数，需要考虑的点" class="headerlink" title="设计输入函数，需要考虑的点"></a>设计输入函数，需要考虑的点</h3><ul>
<li>在开始存储字符串之前，函数应该跳过空白字符吗？</li>
<li>什么字符会导致函数停止读取：换行符、任意空白字符还是其他某种字符？需要存储这类字符还是忽略掉？</li>
<li>如果输入的字符串太长以致无法存储，那么函数应该做些什么：忽略额外的字符还是把它们留给下一次输入操作？</li>
</ul>
<h3 id="C语言的字符串库"><a href="#C语言的字符串库" class="headerlink" title="C语言的字符串库"></a>C语言的字符串库</h3><p>函数的原型驻留在<code>&lt;string.h&gt;</code> 头。</p>
<h4 id="strcpy-函数"><a href="#strcpy-函数" class="headerlink" title="strcpy 函数"></a><code>strcpy</code> 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>strcpy</code> 函数把<code>s2</code> 中的字符复制到<code>s1</code> 中直到遇到<code>s2</code> 中的第一个空字符为止（该空字符也需要复制）。<code>strcpy</code> 函数返回<code>s1</code> （即指向目标字符串的指针）。这一过程不会改变<code>s2</code> 指向的字符串，因此将其声明为<code>const</code> 。</p>
<p><code>strcpy</code> 函数的存在弥补了不能使用赋值运算符复制字符串的不足。例如，假设我们想把字符串<code>&quot;abcd&quot;</code> 存储到<code>str2</code> 中，不能使用下面的赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str2 = <span class="string">&quot;abcd&quot;</span>;            <span class="comment">/*** WRONG ***/</span></span><br></pre></td></tr></table></figure>

<p>这是因为<code>str2</code> 是数组名，不能出现在赋值运算的左侧。但是，这时可以调用<code>strcpy</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str2, <span class="string">&quot;abcd&quot;</span>);     <span class="comment">/* str2 now contains &quot;abcd&quot; */</span></span><br></pre></td></tr></table></figure>

<p>类似地，不能直接把<code>str2</code> 赋值给<code>str1</code> ，但是可以调用<code>strcpy</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str1, str2);       <span class="comment">/* str1 now contains &quot;abcd&quot; */</span></span><br></pre></td></tr></table></figure>

<p>大多数情况下我们会忽略<code>strcpy</code> 函数的返回值，但有时候<code>strcpy</code> 函数调用是一个更大的表达式的一部分，这时其返回值就比较有用了。例如，可以把一系列<code>strcpy</code> 函数调用连起来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str1, <span class="built_in">strcpy</span>(str2, <span class="string">&quot;abcd&quot;</span>));</span><br><span class="line">   <span class="comment">/* both str1 and str2 now contain &quot;abcd&quot; */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>最安全的就是使用strncpy函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(str1, str2, <span class="keyword">sizeof</span>(str1) - <span class="number">1</span>);</span><br><span class="line">str1[<span class="keyword">sizeof</span>(str1)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str1, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(str1, <span class="string">&quot;def&quot;</span>);   <span class="comment">/* str1 now contains &quot;abcdef&quot; */</span></span><br><span class="line"><span class="built_in">strcpy</span>(str1, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(str2, <span class="string">&quot;def&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(str1, str2);    <span class="comment">/* str1 now contains &quot;abcdef&quot; */</span></span><br></pre></td></tr></table></figure>

<p>更安全的strncat：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncat</span>(str1,  str2, <span class="keyword">sizeof</span>(str1) - <span class="built_in">strlen</span>(str1) - <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure>



<h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>strcmp<code> 函数比较字符串</code>s1<code> 和字符串</code>s2<code> ，然后根据</code>s1<code> 是小于、等于或大于</code>s2</p>
<h3 id="字符串惯用法"><a href="#字符串惯用法" class="headerlink" title="字符串惯用法"></a>字符串惯用法</h3><h4 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h4><p>搜索字符串结尾的空字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (*s++) &#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="字符串复制"><a href="#字符串复制" class="headerlink" title="字符串复制"></a>字符串复制</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (*p++ = *s2++);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">while</span> ((*p++ = *s2++) != <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>存储字符串数组的最佳方式是什么？最明显的解决方案是创建二维的字符数组，然后按照每行一个字符串的方式把字符串存储到数组中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> planets[][<span class="number">8</span>] = &#123;<span class="string">&quot;Mercury&quot;</span>, <span class="string">&quot;Venus&quot;</span>, <span class="string">&quot;Earth&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Mars&quot;</span>, <span class="string">&quot;Jupiter&quot;</span>, <span class="string">&quot;Saturn&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Uranus&quot;</span>, <span class="string">&quot;Neptune&quot;</span>, <span class="string">&quot;Pluto&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>因为大部分字符串集都是长字符串和短字符串的混合，所以这个例子所暴露的低效性是在处理字符串时经常遇到的问题。</p>
<p><img src="/images/image-20211105151631411.png" alt="image-20211105151631411"></p>
<p>我们需要的是<strong>参差不齐的数组</strong> （ragged array），即每一行有不同长度的二维数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *planets[] = &#123;<span class="string">&quot;Mercury&quot;</span>, <span class="string">&quot;Venus&quot;</span>, <span class="string">&quot;Earth&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Mars&quot;</span>, <span class="string">&quot;Jupiter&quot;</span>, <span class="string">&quot;Saturn&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;Uranus&quot;</span>, <span class="string">&quot;Neptune&quot;</span>, <span class="string">&quot;Pluto&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211105151658033.png" alt="image-20211105151658033"></p>
<p><code>planets</code> 的每一个元素都是指向以空字符结尾的字符串的指针。虽然必须为<code>planets</code> 数组中的指针分配空间，但是字符串中不再有任何浪费的字符。</p>
<h3 id="预处理器的工作原理"><a href="#预处理器的工作原理" class="headerlink" title="预处理器的工作原理"></a>预处理器的工作原理</h3><p>预处理器的行为是由<strong>预处理指令</strong> （由<code>#</code> 字符开头的一些命令）控制的。</p>
<p>预处理器的输入是一个C语言程序，程序可能包含指令。预处理器会执行这些指令，并在处理过程中删除这些指令。预处理器的输出是另一个C程序：原程序编辑后的版本，不再包含指令。预处理器的输出被直接交给编译器，编译器检查程序是否有错误，并将程序翻译为目标代码（机器指令）。</p>
<p><img src="/images/image-20211105165252748.png" alt="image-20211105165252748"></p>
<p>下面是原来的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Converts a Fahrenheit temperature to Celsius */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREEZING_PT 32.0f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCALE_FACTOR (5.0f / 9.0f)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> fahrenheit, celsius;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter Fahrenheit temperature: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;fahrenheit);</span><br><span class="line"></span><br><span class="line">  celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Celsius equivalent is: %.1f\n&quot;</span>, celsius);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理结束后，程序是下面的样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">空行</span><br><span class="line">空行</span><br><span class="line">从stdio.h中引入的行</span><br><span class="line">空行</span><br><span class="line">空行</span><br><span class="line">空行</span><br><span class="line">空行</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> fahrenheit, celsius;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter Fahrenheit temperature:  &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;fahrenheit);</span><br><span class="line"></span><br><span class="line">  celsius = (fahrenheit - <span class="number">32.0f</span>) * (<span class="number">5.0f</span> / <span class="number">9.0f</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Celsius equivalent is: %.1f\n&quot;</span>, celsius);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>预处理器通过引入<code>stdio.h</code> 的内容来响应<code>#include</code> 指令。</li>
<li>预处理器也删除了<code>#define</code> 指令，并且替换了该文件中稍后出现在任何位置上的<code>FREEZING_PT</code> 和<code>SCALE_FACTOR</code> 。</li>
<li>请注意预处理器并没有删除包含指令的行，而是简单地将它们替换为空。</li>
</ul>
<p>大部分C编译器都提供了一种方法，使用户可以看到预处理器的输出。在指定某个特定的选项（GCC编译器用的是<code>-E</code> ）时编译器会产生预处理器的输出。</p>
<blockquote>
<p>注意，预处理器仅知道少量C语言的规则。因此，它在执行指令时非常有可能产生非法的程序。经常是原始程序看起来没问题，使错误查找起来很难。对于较复杂的程序，检查预处理器的输出可能是找到这类错误的有效途径。</p>
</blockquote>
<h3 id="预处理指令分类"><a href="#预处理指令分类" class="headerlink" title="预处理指令分类"></a>预处理指令分类</h3><p>大多数预处理指令都属于下面3种类型之一。</p>
<ul>
<li><strong>宏定义</strong> 。<code>#define</code> 指令定义一个宏，<code>#undef</code> 指令删除一个宏定义。</li>
<li><strong>文件包含</strong> 。<code>#include</code> 指令导致一个指定文件的内容被包含到程序中。</li>
<li><strong>条件编译</strong> 。<code>#if</code> 、<code>#ifdef</code> 、<code>#ifndef</code> 、<code>#elif</code> 、<code>#else</code> 和<code>#endif</code> 指令可以根据预处理器可以测试的条件来确定是将一段文本块包含到程序中还是将其排除在程序之外。</li>
</ul>
<h3 id="预处理指令专用运算符-和"><a href="#预处理指令专用运算符-和" class="headerlink" title="预处理指令专用运算符#和##"></a>预处理指令专用运算符<code>#</code>和<code>##</code></h3><ul>
<li><code>#</code> 运算符将宏的一个参数字符串化。</li>
<li><code>##</code> 运算符可将两个记号（如标识符）“粘合”在一起，成为一个记号。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_INT(n) printf(#n <span class="meta-string">&quot; = %d\n&quot;</span>, n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">PRINT_INT(i/j);</span><br><span class="line"><span class="comment">// 会变为:</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i/j&quot;</span> <span class="string">&quot; = %d\n&quot;</span>, i/j);</span><br><span class="line"><span class="comment">// 即:</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i/j = %d\n&quot;</span>, i/j);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MK_ID(n) i##n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MK_ID</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">MK_ID</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">MK_ID</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// 会变成:</span></span><br><span class="line"><span class="keyword">int</span> i1, i2, i3;</span><br></pre></td></tr></table></figure>



<h3 id="创建较长的宏"><a href="#创建较长的宏" class="headerlink" title="创建较长的宏"></a>创建较长的宏</h3><p>在创建较长的宏时，逗号运算符会十分有用。特别是可以使用逗号运算符来使替换列表包含一系列表达式。例如，下面的宏会读入一个字符串，再把字符串显示出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s) (gets(s), puts(s))</span></span><br></pre></td></tr></table></figure>

<p>也可以使用do_while语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO(s)      \</span></span><br><span class="line"><span class="meta">        do &#123;         \</span></span><br><span class="line"><span class="meta">          gets(s);   \</span></span><br><span class="line"><span class="meta">          puts(s);   \</span></span><br><span class="line"><span class="meta">        &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时注意要加分号</span></span><br><span class="line">ECHO(smy_tr);</span><br></pre></td></tr></table></figure>



<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><table>
<thead>
<tr>
<th align="center">名字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>__LINE__</code></td>
<td align="center">被编译的文件中的行号</td>
</tr>
<tr>
<td align="center"><code>__FILE__</code></td>
<td align="center">被编译的文件名</td>
</tr>
<tr>
<td align="center"><code>__DATE__</code></td>
<td align="center">编译的日期（格式<code>&quot;mm dd yyyy&quot;</code> ）</td>
</tr>
<tr>
<td align="center"><code>__TIME__</code></td>
<td align="center">编译的时间（格式<code>&quot;hh:mm:ss&quot;</code> ）</td>
</tr>
<tr>
<td align="center"><code>__STDC__</code></td>
<td align="center">如果编译器符合C标准（C89或C99），那么值为1</td>
</tr>
</tbody></table>
<p>我们可以使用<code>__LINE__</code> 宏和<code>__FILE__</code> 宏来找到错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_ZERO(divisor)  \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (divisor == 0) \</span></span><br><span class="line"><span class="meta">    printf(<span class="meta-string">&quot;*** Attempt to divide by zero on line %d  &quot;</span>  \</span></span><br><span class="line"><span class="meta">           <span class="meta-string">&quot;of file %s  ***\n&quot;</span>, __LINE__, __FILE__)</span></span><br></pre></td></tr></table></figure>



<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #if 指令会把没有定义过的标识符当作是值为0的宏对待</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Value of i: %d\n&quot;</span>, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Value of j: %d\n&quot;</span>, j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;c:\cprogs\utils.h&quot;</span>     <span class="comment">/* Windows path */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/cprogs/utils.h&quot;</span>       <span class="comment">/* UNIX path */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;..\include\utils.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(IA32)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> CPU_FILE <span class="meta-string">&quot;ia32.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(IA64)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> CPU_FILE <span class="meta-string">&quot;ia64.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(AMD64)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> CPU_FILE <span class="meta-string">&quot;amd64.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> CPU_FILE</span></span><br></pre></td></tr></table></figure>



<h3 id="为什么需要在-h文件中声明变量"><a href="#为什么需要在-h文件中声明变量" class="headerlink" title="为什么需要在.h文件中声明变量"></a>为什么需要在.h文件中声明变量</h3><ul>
<li>假设源文件包含函数<code>f</code> 的调用，而函数<code>f</code> 是定义在另一个文件<code>foo.c</code> 中的。</li>
<li><strong>调用没有声明的函数<code>f</code> 是非常危险的</strong>。如果没有函数原型可依赖，编译器会假定函数<code>f</code> 的返回类型是<code>int</code> 类型的，并假定形式参数的数量和函数<code>f</code> 的调用中的实际参数的数量是匹配的。通过默认的实际参数提升，实际参数自身自动转化为“标准格式”。编译器的假定很可能是错误的，但是，因为<strong>一次只能编译一个文件，所以是没有办法进行检查的</strong>。如果这些假定是错误的，那么程序很可能无法工作，而且没有线索可以用来查找原因。（基于这个原因，C99禁止在编译器看到函数声明或定义之前对函数进行调用。）</li>
<li>所以，当调用在其他文件中定义的函数<code>f</code> 时，要始终确保编译器在调用之前已看到函数<code>f</code> 的原型。即解决方法就是：把函数<code>f</code> 的原型放进一个头文件中，然后在所有调用函数<code>f</code> 的地方包含这个头文件。</li>
</ul>
<h3 id="构建多文件程序步骤"><a href="#构建多文件程序步骤" class="headerlink" title="构建多文件程序步骤"></a>构建多文件程序步骤</h3><ol>
<li><strong>编译</strong>。必须对程序中的每个源文件分别进行编译。对于<strong>每个源文件，编译器会产生一个包含目标代码的文件</strong>。这些文件称为<strong>目标文件</strong> （object file），在UNIX系统中的扩展名为<code>.o</code> ，在Windows系统中的扩展名为<code>.obj</code> 。</li>
<li><strong>链接</strong>。链接器把上一步产生的目标文件和库函数的代码结合在一起生成可执行的程序。链接器的一个职责是要解决编译器遗留的外部引用问题。（<strong>外部引用发生在一个文件中的函数调用另一个文件中定义的函数或者访问另一个文件中定义的变量时</strong>。）</li>
</ol>
<h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><p>把所有源文件的名字放在命令行中很快变得枯燥乏味。更糟糕的是，如果重新编译所有源文件而不仅仅是最近修改过的源文件，重新构建程序的过程中可能会浪费大量的时间。</p>
<p>为了更易于构建大型程序，UNIX系统发明了makefile的概念，这个文件包含构建程序的必要信息。makefile不仅列出了作为程序的一部分的那些文件，而且还描述了文件之间的<strong>依赖性</strong> 。假设文件<code>foo.c</code> 包含文件<code>bar.h</code> ，那么就说<code>foo.c</code> “依赖于”<code>bar.h</code> ，因为修改<code>bar.h</code> 之后将需要重新编译<code>foo.c</code> 。</p>
<p>下面是针对程序<code>justify</code> 而设的UNIX系统的makefile，它用GCC进行编译和链接：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">justify: justify.o word.o line.o</span></span><br><span class="line">        gcc -o justify justify.o word.o line.o</span><br><span class="line"></span><br><span class="line"><span class="section">justify.o: justify.c word.h line.h</span></span><br><span class="line">        gcc -c justify.c</span><br><span class="line"></span><br><span class="line"><span class="section">word.o: word.c word.h</span></span><br><span class="line">        gcc -c word.c</span><br><span class="line"></span><br><span class="line"><span class="section">line.o: line.c line.h</span></span><br><span class="line">        gcc -c line.c</span><br></pre></td></tr></table></figure>

<p>这里有4组代码行，每组称为一条<strong>规则</strong> 。</p>
<ul>
<li>每条规则的第一行给出了<strong>目标</strong> 文件，跟在后边的是它所依赖的文件。</li>
<li>第二行是待执行的<strong>命令</strong> （当目标文件所依赖的文件发生改变时，需要重新构建目标文件，此时执行第二行的命令）。</li>
</ul>
<p>在第一条规则中，<code>justify</code> （可执行程序）是目标文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">justify: justify.o word.o line.o</span></span><br><span class="line">        gcc -o justify justify.o word.o line.o</span><br></pre></td></tr></table></figure>

<p>第一行说明<code>justify</code> 依赖于<code>justify.o</code> 、<code>word.o</code> 和<code>line.o</code> 这三个文件。在程序的上一次构建完成之后，只要这三个文件中有一个发生改变，<code>justify</code> 都需要重新构建。</p>
<p>下一行信息说明如何重新构建<code>justify</code> （通过使用<code>gcc</code> 命令链接三个目标文件）。</p>
<p>在第二条规则中，<code>justify.o</code> 是目标文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">justify.o: justify.c word.h line.h</span></span><br><span class="line">        gcc -c justify.c</span><br></pre></td></tr></table></figure>

<p>第一行说明，如果<code>justify.c</code> 、<code>word.h</code> 或<code>line.h</code> 文件发生改变，那么<code>justify.o</code> 需要重新构建。（提及<code>word.h</code> 和<code>line.h</code> 的理由是，<code>justify.c</code> 包含这两个文件，它们的改变都可能会对<code>justify.c</code> 产生影响。）</p>
<p>下一行信息说明如何更新<code>justify.o</code> （通过重新编译<code>justify.c</code> ）。选项<code>-c</code> 通知编译器把<code>justify.c</code> 编译为目标文件，但是不要试图链接它。</p>
<p>一旦为程序创造了makefile，就能使用<code>make</code> 实用程序来构建（或重新构建)该程序了。通过检查与程序中每个文件相关的时间和日期，<code>make</code> 可以确定哪个文件是过期的。然后，它会调用必要的命令来重新构建程序。</p>
<h4 id="链接期间的错误排查"><a href="#链接期间的错误排查" class="headerlink" title="链接期间的错误排查"></a>链接期间的错误排查</h4><p>一些在编译期间无法发现的错误将会在链接期间被发现。比如，如程序中丢失了函数定义或变量定义，那么链接器将无法解析外部引用，从而导致出现类似“<code>undefined symbol</code> ”或“<code>undefined reference</code> ”的消息。</p>
<p>链接器检查到的错误通常很容易修改。下面是一些最常见的错误起因。</p>
<ul>
<li><strong>拼写错误</strong> 。如果变量名或函数名拼写错误，那么链接器将进行缺失报告。例如，如果在程序中定义了函数<code>read_char</code> ，但调用时却把它写为<code>read_cahr</code> ，那么链接器将报告说缺失<code>read_cahr</code> 函数。</li>
<li><strong>缺失文件</strong> 。如果链接器不能找到文件<code>foo.c</code> 中的函数，那么它可能不会知道此文件。这时就要检查makefile或工程文件来确保<code>foo.c</code> 文件是列出了的。</li>
<li><strong>缺失库</strong> 。链接器不可能找到程序中用到的全部库函数。UNIX系统中有一个使用了<code>&lt;math.h&gt;</code> 的经典例子。在程序中简单地包含该头可能是不够的，很多UNIX版本要求在链接程序时指明选项<code>-lm</code> ，这会导致链接器去搜索一个包含<code>&lt;math.h&gt;</code> 函数的编译版本的系统文件。不使用这个选项可能会在链接时导致“undefined reference”消息。</li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>