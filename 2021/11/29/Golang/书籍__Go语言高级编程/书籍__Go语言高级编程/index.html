<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;ch1-basic&quot;&gt;&lt;a href=&quot;#ch1-basic&quot; class=&quot;headerlink&quot; title=&quot;ch1-basic&quot;&gt;&lt;/a&gt;ch1-basic&lt;/h1&gt;&lt;h2 id=&quot;1-3-数组、字符串和切片&quot;&gt;&lt;a href=&quot;#1-3-数组、字符串和切片&quot; class=&quot;headerlink&quot; title=&quot;1.3 数组、字符串和切片&quot;&gt;&lt;/a&gt;1.3 数组、字符串和切片&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以将数组看作一个特殊的结构体，结构的字段名对应数组的索引，同时结构体成员的数目是固定的。&lt;/li&gt;
&lt;li&gt;内置函数&lt;code&gt;len&lt;/code&gt;可以用于计算数组的长度，&lt;code&gt;cap&lt;/code&gt;函数可以用于计算数组的容量。不过对于数组类型来说，&lt;code&gt;len&lt;/code&gt;和&lt;code&gt;cap&lt;/code&gt;函数返回的结果始终是一样的，都是对应数组类型的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;for-range性能更高&quot;&gt;&lt;a href=&quot;#for-range性能更高&quot; class=&quot;headerlink&quot; title=&quot;for range性能更高&quot;&gt;&lt;/a&gt;for range性能更高&lt;/h3&gt;&lt;p&gt;用&lt;code&gt;for range&lt;/code&gt;方式迭代的性能会比&lt;code&gt;for i := 0; i &amp;lt; len(arr); i++ &lt;/code&gt;更好一些，因为这种迭代可以保证不会出现数组越界的情形，&lt;strong&gt;每轮迭代对数组元素的访问时可以省去对下标越界的判断&lt;/strong&gt;。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Go语言高级编程 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-11-29</div></div></div><div class="container post-header"><h1>Go语言高级编程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ch1-basic"><span class="toc-number">1.</span> <span class="toc-text">ch1-basic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">1.1.</span> <span class="toc-text">1.3 数组、字符串和切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-range%E6%80%A7%E8%83%BD%E6%9B%B4%E9%AB%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">for range性能更高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-range%E7%9B%B4%E6%8E%A5%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">for range直接迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8struct-%E4%BD%9C%E4%B8%BAchannel%E4%BF%A1%E6%81%AF%E8%BD%BD%E4%BD%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">使用struct{}作为channel信息载体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.1.4.</span> <span class="toc-text">string其实是个结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%92%8C-rune%E4%BA%92%E8%BD%AC%E9%9A%90%E5%90%AB%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.1.5.</span> <span class="toc-text">string和[]rune互转隐含重新分配内存的代价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E4%B8%8Ebytes%E7%9A%84%E4%BA%92%E8%BD%AC%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">string与bytes的互转模拟实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%85%B6%E5%AE%9E%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.1.6.</span> <span class="toc-text">切片其实是结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">1.4 函数、方法和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">闭包使用引用的方式获取外部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E4%B8%8D%E4%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">Go不会栈溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct%E5%92%8C%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%85%E4%B8%AD%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">struct和方法必须在同一个包中定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%8F%E6%84%8F%E4%BA%92%E8%BD%AC"><span class="toc-number">1.2.4.</span> <span class="toc-text">限制接口与对象之间的随意互转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E9%9D%A2%E5%90%91%E5%B9%B6%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.5 面向并发的内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%AD%90%E6%A3%80%E6%B5%8B%E6%A0%87%E5%BF%97%E4%BD%8D%E6%9D%A5%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-number">1.3.1.</span> <span class="toc-text">使用原子检测标志位来提高性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">顺序一致性内存模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">1.6 常见的并发模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.4.1.</span> <span class="toc-text">go并发原语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-Mutex"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">sync.Mutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-WaitGroup"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">sync.WaitGroup</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">生产者消费者模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">发布订阅模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">channel控制并发数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E9%80%80%E5%87%BA%E5%A4%9A%E4%B8%AAgoroutine"><span class="toc-number">1.4.5.</span> <span class="toc-text">优雅退出多个goroutine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.5.</span> <span class="toc-text">1.7 错误和异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch2-cgo"><span class="toc-number">2.</span> <span class="toc-text">ch2-cgo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EC%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.1.</span> <span class="toc-text">基于C标准库函数输出字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84C%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">使用自己的C函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E4%BB%A3%E7%A0%81%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">2.1.3.</span> <span class="toc-text">C代码的模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BAGo%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E7%BB%99C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.4.</span> <span class="toc-text">导出Go语言函数给C语言函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GoString-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.5.</span> <span class="toc-text">_GoString_预定义类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-CGO%E5%9F%BA%E7%A1%80"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 CGO基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cgo%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">#cgo语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">2.3.1.</span> <span class="toc-text">Go 字符串和切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E8%81%94%E5%90%88%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">结构体、联合、枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">2.3.3.</span> <span class="toc-text">数组、字符串和切片</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch4-rpc"><span class="toc-number">3.</span> <span class="toc-text">ch4-rpc</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-RPC%E5%85%A5%E9%97%A8"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 RPC入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84RPC%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.1.</span> <span class="toc-text">更安全的RPC接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84RPC"><span class="toc-number">3.1.2.</span> <span class="toc-text">跨语言的RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http%E4%B8%8A%E7%9A%84RPC"><span class="toc-number">3.1.3.</span> <span class="toc-text">Http上的RPC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Protobuf"><span class="toc-number">3.2.</span> <span class="toc-text">4.2 Protobuf</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%8F%92%E4%BB%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">定制代码生成插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%8E%A9%E8%BD%ACRPC"><span class="toc-number">3.3.</span> <span class="toc-text">4.3 玩转RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERPC%E5%AE%9E%E7%8E%B0Watch%E5%8A%9F%E8%83%BD"><span class="toc-number">3.3.1.</span> <span class="toc-text">基于RPC实现Watch功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91RPC"><span class="toc-number">3.3.2.</span> <span class="toc-text">反向RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF"><span class="toc-number">3.3.3.</span> <span class="toc-text">上下文信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-gRPC%E5%85%A5%E9%97%A8"><span class="toc-number">3.4.</span> <span class="toc-text">4.4 gRPC入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gRPC%E6%B5%81"><span class="toc-number">3.4.1.</span> <span class="toc-text">gRPC流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">发布和订阅模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-gRPC%E8%BF%9B%E9%98%B6"><span class="toc-number">3.5.</span> <span class="toc-text">4.5 gRPC进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-gRPC%E5%92%8CProtobuf%E6%89%A9%E5%B1%95"><span class="toc-number">3.6.</span> <span class="toc-text">4.6 gRPC和Protobuf扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%99%A8"><span class="toc-number">3.6.1.</span> <span class="toc-text">验证器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REST%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.6.2.</span> <span class="toc-text">REST接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx"><span class="toc-number">3.6.3.</span> <span class="toc-text">Nginx</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch5-web"><span class="toc-number">4.</span> <span class="toc-text">ch5-web</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-router-%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1"><span class="toc-number">4.1.</span> <span class="toc-text">5.2 router 请求路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#httprouter%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.1.</span> <span class="toc-text">httprouter原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">压缩字典树创建过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E8%8A%82%E7%82%B9%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">子节点冲突处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">5.3 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%86%99%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">更优雅的中间件写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-validator%E8%AF%B7%E6%B1%82%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.3.</span> <span class="toc-text">5.4 validator请求校验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Database"><span class="toc-number">4.4.</span> <span class="toc-text">5.5 Database</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Ratelimit-%E6%9C%8D%E5%8A%A1%E6%B5%81%E9%87%8F%E9%99%90%E5%88%B6"><span class="toc-number">4.5.</span> <span class="toc-text">5.6 Ratelimit 服务流量限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%81%E9%87%8F%E9%99%90%E5%88%B6%E6%89%8B%E6%AE%B5"><span class="toc-number">4.5.1.</span> <span class="toc-text">常见的流量限制手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">4.5.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-layout-%E5%B8%B8%E8%A7%81%E5%A4%A7%E5%9E%8B-Web-%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B1%82"><span class="toc-number">4.6.</span> <span class="toc-text">5.7 layout :常见大型 Web 项目分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">4.7.</span> <span class="toc-text">5.8 接口和表驱动开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-number">4.7.1.</span> <span class="toc-text">业务系统的发展过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">4.7.2.</span> <span class="toc-text">使用函数封装业务流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%81%9A%E6%8A%BD%E8%B1%A1"><span class="toc-number">4.7.3.</span> <span class="toc-text">使用接口来做抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.7.4.</span> <span class="toc-text">接口的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">4.7.5.</span> <span class="toc-text">表驱动开发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E5%92%8C-A-B-test"><span class="toc-number">4.8.</span> <span class="toc-text">5.9 灰度发布和 A&#x2F;B test</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%88%86%E6%89%B9%E6%AC%A1%E9%83%A8%E7%BD%B2%E5%AE%9E%E7%8E%B0%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83"><span class="toc-number">4.8.1.</span> <span class="toc-text">通过分批次部署实现灰度发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%E8%BF%9B%E8%A1%8C%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83"><span class="toc-number">4.8.2.</span> <span class="toc-text">通过业务规则进行灰度发布</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E8%A7%84%E5%88%99"><span class="toc-number">4.8.2.1.</span> <span class="toc-text">可选规则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch6-cloud"><span class="toc-number">5.</span> <span class="toc-text">ch6-cloud</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95A%EF%BC%9AGo%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E5%9D%91"><span class="toc-number">6.</span> <span class="toc-text">附录A：Go语言常见坑</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0CPU%E5%AF%BC%E8%87%B4%E5%85%B6%E5%AE%83Goroutine%E9%A5%BF%E6%AD%BB"><span class="toc-number">6.1.</span> <span class="toc-text">独占CPU导致其它Goroutine饿死</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8CGoroutine%E4%B9%8B%E9%97%B4%E4%B8%8D%E6%BB%A1%E8%B6%B3%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">不同Goroutine之间不满足顺序一致性内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E5%BE%AA%E7%8E%AF%E5%86%85%E9%83%A8%E6%89%A7%E8%A1%8Cdefer%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.3.</span> <span class="toc-text">避免在循环内部执行defer语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%95%B4%E4%B8%AA%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E8%A2%AB%E9%94%81%E5%AE%9A"><span class="toc-number">6.4.</span> <span class="toc-text">切片会导致整个底层数组被锁定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Goroutine%E6%B3%84%E9%9C%B2"><span class="toc-number">6.5.</span> <span class="toc-text">Goroutine泄露</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="ch1-basic"><a href="#ch1-basic" class="headerlink" title="ch1-basic"></a>ch1-basic</h1><h2 id="1-3-数组、字符串和切片"><a href="#1-3-数组、字符串和切片" class="headerlink" title="1.3 数组、字符串和切片"></a>1.3 数组、字符串和切片</h2><ul>
<li>可以将数组看作一个特殊的结构体，结构的字段名对应数组的索引，同时结构体成员的数目是固定的。</li>
<li>内置函数<code>len</code>可以用于计算数组的长度，<code>cap</code>函数可以用于计算数组的容量。不过对于数组类型来说，<code>len</code>和<code>cap</code>函数返回的结果始终是一样的，都是对应数组类型的长度。</li>
</ul>
<h3 id="for-range性能更高"><a href="#for-range性能更高" class="headerlink" title="for range性能更高"></a>for range性能更高</h3><p>用<code>for range</code>方式迭代的性能会比<code>for i := 0; i &lt; len(arr); i++ </code>更好一些，因为这种迭代可以保证不会出现数组越界的情形，<strong>每轮迭代对数组元素的访问时可以省去对下标越界的判断</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestArrayRange</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Printf(item)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		fmt.Printf(arr[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="for-range直接迭代"><a href="#for-range直接迭代" class="headerlink" title="for range直接迭代"></a>for range直接迭代</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> times [<span class="number">5</span>][<span class="number">0</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> times &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;1&quot;</span>) <span class="comment">// 11111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用struct-作为channel信息载体"><a href="#使用struct-作为channel信息载体" class="headerlink" title="使用struct{}作为channel信息载体"></a>使用struct{}作为channel信息载体</h3><p>如果channel接收和发送操作只是用于消息的同步，一般使用无类型的匿名结构体作为信息载体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;c2&quot;</span>)</span><br><span class="line">	c2 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// struct&#123;&#125;部分是类型, &#123;&#125;表示对应的结构体值</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-c2</span><br></pre></td></tr></table></figure>



<h3 id="string其实是个结构体"><a href="#string其实是个结构体" class="headerlink" title="string其实是个结构体"></a>string其实是个结构体</h3><p>Go语言字符串的底层结构在<code>reflect.StringHeader</code>中定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串结构由两个信息组成：</p>
<ul>
<li>第一个是字符串指向的底层字节数组，</li>
<li>第二个是字符串的字节的长度。</li>
</ul>
<blockquote>
<p>使用unsafe来获取string的len：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello, world&quot;</span>[:<span class="number">5</span>]</span><br><span class="line">s2 := <span class="string">&quot;hello, world&quot;</span>[<span class="number">7</span>:]</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;len(s):&quot;</span>, (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Len)   <span class="comment">// 12</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len(s1):&quot;</span>, (*reflect.StringHeader)(unsafe.Pointer(&amp;s1)).Len) <span class="comment">// 5</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len(s2):&quot;</span>, (*reflect.StringHeader)(unsafe.Pointer(&amp;s2)).Len) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>字符串其实是一个结构体，因此字符串的赋值操作也就是<code>reflect.StringHeader</code>结构体的复制过程，并不会涉及底层字节数组的复制。</p>
<p>看看字符串“Hello, world”本身对应的内存结构：</p>
<p><img src="/images/image-20210611120619076.png" alt="image-20210611120619076"></p>
<p>可以发现，“Hello, world”字符串底层数据和以下数组是完全一致的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [...]<span class="keyword">byte</span>&#123;</span><br><span class="line">	<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下图展示了“Hello, 世界”字符串的内存结构布局:</p>
<p><img src="/images/image-20210611121120439.png" alt="image-20210611121120439"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;\xe4\xb8\x96&quot;</span>) <span class="comment">// 打印: 世</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\xe7\x95\x8c&quot;</span>) <span class="comment">// 打印: 界</span></span><br></pre></td></tr></table></figure>



<h3 id="string和-rune互转隐含重新分配内存的代价"><a href="#string和-rune互转隐含重新分配内存的代价" class="headerlink" title="string和[]rune互转隐含重新分配内存的代价"></a>string和[]rune互转隐含重新分配内存的代价</h3><ul>
<li>string的底层数组是[]byte，也就是说<strong>string转byte是不会产生运行时开销的</strong></li>
<li>[]rune其实就是[]int32</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// []byte(&quot;世界abc&quot;)不产生运行时开销</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> []<span class="keyword">byte</span>(<span class="string">&quot;世界abc&quot;</span>) &#123;</span><br><span class="line">	fmt.Println(i, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>字符串相关的强制类型转换主要涉及到<code>[]byte</code>和<code>[]rune</code>两种类型。</p>
<blockquote>
<p>因为<strong>一般强制类型转换要求两个类型的底层内存结构要尽量一致</strong>，显然它们底层对应的<code>[]byte</code>和<code>[]int32</code>类型是完全不同的内部布局，因此这种转换可能隐含重新分配内存的操作。</p>
</blockquote>
<p>同样因为底层内存结构的差异，<code>[]rune</code>到字符串的转换也必然会导致重新构造字符串。</p>
<h4 id="string与bytes的互转模拟实现"><a href="#string与bytes的互转模拟实现" class="headerlink" title="string与bytes的互转模拟实现"></a>string与bytes的互转模拟实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// []byte(string)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		c := s[i]</span><br><span class="line">		p[i] = c</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string([]byte)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2str</span><span class="params">(s []<span class="keyword">byte</span>)</span> <span class="params">(p <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">		data[i] = c</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;p))</span><br><span class="line">	hdr.Data = <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;data[<span class="number">0</span>]))</span><br><span class="line">	hdr.Len = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="切片其实是结构体"><a href="#切片其实是结构体" class="headerlink" title="切片其实是结构体"></a>切片其实是结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data <span class="keyword">uintptr</span></span><br><span class="line">	Len  <span class="keyword">int</span></span><br><span class="line">	Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出切片的开头部分和字符串是一样的，但是切片多了一个<code>Cap</code>成员表示切片指向的内存空间的最大容量（对应元素的个数，而不是字节数）。</p>
<p>下图是<code>x := []int&#123;2,3,5,7,11&#125;</code>和<code>y := x[1:3]</code>两个切片对应的内存结构。</p>
<p><img src="/images/image-20210611144003770.png" alt="image-20210611144003770"></p>
<h2 id="1-4-函数、方法和接口"><a href="#1-4-函数、方法和接口" class="headerlink" title="1.4 函数、方法和接口"></a>1.4 函数、方法和接口</h2><ul>
<li><p>Go语言程序的初始化和执行总是从<code>main.main</code>函数开始的。但是如果<code>main</code>包导入了其它的包，则会按照顺序将它们包含进<code>main</code>包里。</p>
</li>
<li><p><strong>如果某个包被多次导入的话，在执行的时候只会导入一次</strong>。</p>
</li>
<li><p>Go程序函数启动顺序的示意图：</p>
<p><img src="/images/image-20210611172404355.png" alt="image-20210611172404355"></p>
</li>
</ul>
<blockquote>
<p>要注意的是，在<code>main.main</code>函数执行之前所有代码都运行在同一个goroutine，也就是程序的主系统线程中。</p>
<p>因此，如果某个<code>init</code>函数内部用go关键字启动了新的goroutine的话，新的goroutine只有在进入<code>main.main</code>函数之后才可能被执行到。</p>
</blockquote>
<h3 id="闭包使用引用的方式获取外部变量"><a href="#闭包使用引用的方式获取外部变量" class="headerlink" title="闭包使用引用的方式获取外部变量"></a>闭包使用引用的方式获取外部变量</h3><p>闭包对捕获的外部变量并不是传值方式访问，而是以引用的方式访问。</p>
<p>闭包的这种引用方式访问外部变量的行为可能会导致一些隐含的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="built_in">println</span>(i) &#125; ()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为是闭包，在<code>for</code>迭代语句中，每个<code>defer</code>语句延迟执行的函数引用的都是同一个<code>i</code>迭代变量，在循环结束后这个变量的值为3，因此最终输出的都是3。</p>
</blockquote>
<blockquote>
<p>修复的思路是在每轮迭代中为每个<code>defer</code>函数生成独有的变量。可以用下面两种方式：</p>
<ul>
<li>第一种方法是在循环体内部再定义一个局部变量，这样每次迭代<code>defer</code>语句的闭包函数捕获的都是不同的变量，这些变量的值对应迭代时的值。</li>
<li>第二种方式是将迭代变量通过闭包函数的参数传入，<code>defer</code>语句会马上对调用参数求值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		i := i <span class="comment">// 定义一个循环体内局部变量i</span></span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="built_in">println</span>(i) &#125; ()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 通过函数传入i</span></span><br><span class="line">		<span class="comment">// defer 语句会马上对调用参数求值</span></span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123; <span class="built_in">println</span>(i) &#125; (i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Go不会栈溢出"><a href="#Go不会栈溢出" class="headerlink" title="Go不会栈溢出"></a>Go不会栈溢出</h3><ul>
<li>Go语言函数的递归调用深度逻辑上没有限制，函数调用的栈是不会出现溢出错误的，因为Go语言运行时会根据需要动态地调整函数栈的大小。</li>
<li>每个goroutine刚启动时只会分配很小的栈（4或8KB，具体依赖实现），根据需要动态调整栈的大小，栈最大可以达到GB级（依赖具体实现，在目前的实现中，32位体系结构为250MB,64位体系结构为1GB）。</li>
<li>Go语言函数的栈会自动调整大小，所以普通Go程序员已经很少需要关心栈的运行机制的。在Go语言规范中甚至故意没有讲到栈和堆的概念。我们无法知道函数参数或局部变量到底是保存在栈中还是堆中，我们只需要知道它们能够正常工作就可以了。</li>
</ul>
<blockquote>
<p>Go语言中指针不是固定不变的</p>
<p>因此不能随意将指针保持到数值变量中，Go语言的地址也不能随意保存到不在GC控制的环境中，因此使用CGO时不能在C语言中长期持有Go语言对象的地址。</p>
</blockquote>
<h3 id="struct和方法必须在同一个包中定义"><a href="#struct和方法必须在同一个包中定义" class="headerlink" title="struct和方法必须在同一个包中定义"></a>struct和方法必须在同一个包中定义</h3><ul>
<li>每种类型对应的方法必须和类型的定义在同一个包中</li>
<li>因此是无法给<code>int</code>这类内置类型添加方法的（因为方法的定义和类型的定义不在一个包中）</li>
</ul>
<h3 id="限制接口与对象之间的随意互转"><a href="#限制接口与对象之间的随意互转" class="headerlink" title="限制接口与对象之间的随意互转"></a>限制接口与对象之间的随意互转</h3><p>有两种方法：</p>
<ul>
<li><p>interface创建一个偏僻的无用的函数，只要不实现这个方法，就无法转为此interface。避免其它类型无意中适配了该接口。</p>
<p>不过这种做法只是君子协定，如果有人刻意伪造一个RuntimeError函数也是很容易的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> runtime.Error <span class="keyword">interface</span> &#123;</span><br><span class="line">	error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RuntimeError is a no-op function but</span></span><br><span class="line">	<span class="comment">// serves to distinguish types that are run time</span></span><br><span class="line">	<span class="comment">// errors from ordinary errors: a type is a</span></span><br><span class="line">	<span class="comment">// run time error if it has a RuntimeError method.</span></span><br><span class="line">	RuntimeError()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>给接口定义一个私有方法。只有满足了这个私有方法的对象才可能满足这个接口。</p>
<p>因为只有包内才能定义私有函数，所以此接口只有包内才能使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> testing.TB <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Errorf(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A private method to prevent users implementing the</span></span><br><span class="line">	<span class="comment">// interface and so future additions to it will not</span></span><br><span class="line">	<span class="comment">// violate Go 1 compatibility.</span></span><br><span class="line">	private()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种防护措施也不是绝对的，恶意的用户依然可以绕过这种保护机制，</p>
<p>比如使用unsafe包强行添加一个private函数。</p>
<p>通过在结构体中嵌入匿名类型成员，可以继承匿名类型的方法。其实这个被嵌入的匿名成员不一定是普通类型，也可以是接口类型。我们可以通过嵌入匿名的<code>testing.TB</code>接口来伪造私有的<code>private</code>方法，因为接口方法是延迟绑定，编译时<code>private</code>方法是否真的存在并不重要。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TB <span class="keyword">struct</span> &#123;</span><br><span class="line">	testing.TB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *TB)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;TB.Fatal disabled!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> tb testing.TB = <span class="built_in">new</span>(TB)</span><br><span class="line">	tb.Fatal(<span class="string">&quot;Hello, playground&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="1-5-面向并发的内存模型"><a href="#1-5-面向并发的内存模型" class="headerlink" title="1.5 面向并发的内存模型"></a>1.5 面向并发的内存模型</h2><h3 id="使用原子检测标志位来提高性能"><a href="#使用原子检测标志位来提高性能" class="headerlink" title="使用原子检测标志位来提高性能"></a>使用原子检测标志位来提高性能</h3><ul>
<li>原子操作配合互斥锁可以实现非常高效的单件模式。</li>
<li><strong>互斥锁的代价比普通整数的原子读写高很多</strong>，在性能敏感的地方可以增加一个数字型的标志位，通过原子检测标志位状态降低互斥锁的使用次数来提高性能。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	instance    *singleton</span><br><span class="line">	initialized <span class="keyword">uint32</span>  <span class="comment">// 原子检测标志位</span></span><br><span class="line">	mu          sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Instance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;initialized) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instance</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;initialized, <span class="number">1</span>)</span><br><span class="line">		instance = &amp;singleton&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实``sync.Once`就是使用了原子检测标志位来实现的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	m    Mutex</span><br><span class="line">	done <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	instance *singleton</span><br><span class="line">	once     sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Instance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		instance = &amp;singleton&#123;&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> !done &#123;&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>并不能保证对<code>done</code>的写入操作发生在对字符串<code>a</code>的写入的操作之后，因此程序很可能打印一个空字符串。</li>
<li>更糟糕的是，因为两个线程之间没有同步事件，<code>setup</code>线程对<code>done</code>的写入操作甚至无法被<code>main</code>线程看到，<code>main</code>函数有可能陷入死循环中。</li>
</ul>
<p>GO内存模型：</p>
<ul>
<li>在Go语言中，同一个Goroutine线程内部，顺序一致性内存模型是得到保证的。</li>
<li>但是<strong>不同的Goroutine之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考。</strong></li>
<li>如果两个事件不可排序，那么就说这两个事件是并发的。为了最大化并行，Go语言的编译器和处理器在不影响上述规定的前提下可能会对执行语句重新排序（CPU也会对一些指令进行乱序执行）。</li>
</ul>
<blockquote>
<p>因此，如果在一个Goroutine中顺序执行<code>a = 1; b = 2;</code>两个语句，虽然在当前的Goroutine中可以认为<code>a = 1;</code>语句先于<code>b = 2;</code>语句执行，但是在另一个Goroutine中<code>b = 2;</code>语句可能会先于<code>a = 1;</code>语句执行，甚至在另一个Goroutine中无法看到它们的变化（可能始终在寄存器中）。</p>
<p>也就是说<strong>在另一个Goroutine看来, <code>a = 1; b = 2;</code>两个语句的执行顺序是不确定的。</strong>如果一个并发程序无法确定事件的顺序关系，那么程序的运行结果往往会有不确定的结果。</p>
</blockquote>
<p>用前面的原子操作并不能解决问题，因为我们无法确定两个原子操作之间的顺序。解决问题的办法就是通过同步原语来给两个事件明确排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;你好, 世界&quot;</span>)</span><br><span class="line">		done &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-6-常见的并发模式"><a href="#1-6-常见的并发模式" class="headerlink" title="1.6 常见的并发模式"></a>1.6 常见的并发模式</h2><h3 id="go并发原语"><a href="#go并发原语" class="headerlink" title="go并发原语"></a>go并发原语</h3><h4 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;你好, 世界&quot;</span>)</span><br><span class="line">		mu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	mu.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第二次加锁时会因为锁已经被占用（不是递归锁）而阻塞，<code>main</code>函数的阻塞状态驱动后台线程继续向前执行。</p>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 带缓存的管道</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;你好, 世界&quot;</span>)</span><br><span class="line">		done &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>) <span class="comment">// 带 10 个缓存</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开N个后台打印线程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;你好, 世界&quot;</span>)</span><br><span class="line">			done &lt;- <span class="number">1</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待N个后台线程完成</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">		&lt;-done</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开N个后台打印线程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;你好, 世界&quot;</span>)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待N个后台线程完成</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者: 生成 factor 整数倍的序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(factor <span class="keyword">int</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">		out &lt;- i*factor</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>) <span class="comment">// 成果队列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> Producer(<span class="number">3</span>, ch) <span class="comment">// 生成 3 的倍数的序列</span></span><br><span class="line">	<span class="keyword">go</span> Producer(<span class="number">5</span>, ch) <span class="comment">// 生成 5 的倍数的序列</span></span><br><span class="line">	<span class="keyword">go</span> Consumer(ch)    <span class="comment">// 消费 生成的队列</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 运行一定时间后退出</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h3><ul>
<li>发布订阅（publish-and-subscribe）模型通常被简写为pub/sub模型。</li>
<li>在这个模型中，消息生产者成为发布者（publisher），而消息消费者则成为订阅者（subscriber），生产者和消费者是M:N的关系。</li>
<li>在传统生产者和消费者模型中，是将消息发送到一个队列中，而发布订阅模型则是将消息发布给一个主题。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package pubsub implements a simple multi-topic pub-sub library.</span></span><br><span class="line"><span class="keyword">package</span> pubsub</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	subscriber <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;         <span class="comment">// 订阅者为一个管道</span></span><br><span class="line">	topicFunc  <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span> // 主题为一个过滤器</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者对象</span></span><br><span class="line"><span class="keyword">type</span> Publisher <span class="keyword">struct</span> &#123;</span><br><span class="line">	m           sync.RWMutex             <span class="comment">// 读写锁</span></span><br><span class="line">	buffer      <span class="keyword">int</span>                      <span class="comment">// 订阅队列的缓存大小</span></span><br><span class="line">	timeout     time.Duration            <span class="comment">// 发布超时时间</span></span><br><span class="line">	subscribers <span class="keyword">map</span>[subscriber]topicFunc <span class="comment">// 订阅者信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个发布者对象, 可以设置发布超时时间和缓存队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPublisher</span><span class="params">(publishTimeout time.Duration, buffer <span class="keyword">int</span>)</span> *<span class="title">Publisher</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Publisher&#123;</span><br><span class="line">		buffer:      buffer,</span><br><span class="line">		timeout:     publishTimeout,</span><br><span class="line">		subscribers: <span class="built_in">make</span>(<span class="keyword">map</span>[subscriber]topicFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个新的订阅者，订阅全部主题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Subscribe</span><span class="params">()</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> p.SubscribeTopic(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个新的订阅者，订阅过滤器筛选后的主题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">SubscribeTopic</span><span class="params">(topic topicFunc)</span> <span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, p.buffer)</span><br><span class="line">	p.m.Lock()</span><br><span class="line">	p.subscribers[ch] = topic</span><br><span class="line">	p.m.Unlock()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出订阅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Evict</span><span class="params">(sub <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	p.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(p.subscribers, sub)</span><br><span class="line">	<span class="built_in">close</span>(sub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布一个主题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Publish</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	p.m.RLock()</span><br><span class="line">	<span class="keyword">defer</span> p.m.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> sub, topic := <span class="keyword">range</span> p.subscribers &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> p.sendTopic(sub, topic, v, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭发布者对象，同时关闭所有的订阅者管道。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> sub := <span class="keyword">range</span> p.subscribers &#123;</span><br><span class="line">		<span class="built_in">delete</span>(p.subscribers, sub)</span><br><span class="line">		<span class="built_in">close</span>(sub)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送主题，可以容忍一定的超时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Publisher)</span> <span class="title">sendTopic</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	sub subscriber, topic topicFunc, v <span class="keyword">interface</span>&#123;&#125;, wg *sync.WaitGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">if</span> topic != <span class="literal">nil</span> &amp;&amp; !topic(v) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> sub &lt;- v:</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(p.timeout):</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子中，有两个订阅者分别订阅了全部主题和含有”golang”的主题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;path/to/pubsub&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := pubsub.NewPublisher(<span class="number">100</span>*time.Millisecond, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">defer</span> p.Close()</span><br><span class="line"></span><br><span class="line">	all := p.Subscribe()</span><br><span class="line">	golang := p.SubscribeTopic(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> s, ok := v.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> strings.Contains(s, <span class="string">&quot;golang&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	p.Publish(<span class="string">&quot;hello,  world!&quot;</span>)</span><br><span class="line">	p.Publish(<span class="string">&quot;hello, golang!&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span>  msg := <span class="keyword">range</span> all &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;all:&quot;</span>, msg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span>  msg := <span class="keyword">range</span> golang &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;golang:&quot;</span>, msg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 运行一定时间后退出</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="channel控制并发数"><a href="#channel控制并发数" class="headerlink" title="channel控制并发数"></a>channel控制并发数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			limit &lt;- <span class="number">1</span></span><br><span class="line">			w()</span><br><span class="line">			&lt;-limit</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以做一个抽象类型<code>gate</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gate <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g gate)</span> <span class="title">enter</span><span class="params">()</span></span> &#123; g &lt;- <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g gate)</span> <span class="title">leave</span><span class="params">()</span></span> &#123; &lt;-g &#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gate <span class="keyword">struct</span> &#123;</span><br><span class="line">	ch <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *gate)</span> <span class="title">enter</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g.ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *gate)</span> <span class="title">leave</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;- g.ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Printer <span class="keyword">struct</span> &#123;</span><br><span class="line">	g    *gate</span><br><span class="line">	list []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPrinter</span><span class="params">(sema <span class="keyword">int</span>)</span> *<span class="title">Printer</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, sema)</span><br><span class="line">	<span class="keyword">return</span> &amp;Printer&#123;&amp;gate&#123;c&#125;, <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Printer)</span> <span class="title">AppendList</span><span class="params">(num <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.list = <span class="built_in">append</span>(p.list, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Printer)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.g.enter()</span><br><span class="line">	<span class="keyword">defer</span> p.g.leave()</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> p.list &#123;</span><br><span class="line">		fmt.Print(s)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := NewPrinter(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>&#125; &#123;</span><br><span class="line">		p.AppendList(s)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> p.Print()</span><br><span class="line">	<span class="keyword">go</span> p.Print()</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优雅退出多个goroutine"><a href="#优雅退出多个goroutine" class="headerlink" title="优雅退出多个goroutine"></a>优雅退出多个goroutine</h3><p>可以通过<code>close</code>关闭一个管道来实现广播的效果，所有从关闭管道接收的操作均会收到一个零值和一个可选的失败标志。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup, cancel <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-cancel:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> worker(&amp;wg, cancel)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="built_in">close</span>(cancel)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-7-错误和异常"><a href="#1-7-错误和异常" class="headerlink" title="1.7 错误和异常"></a>1.7 错误和异常</h2><p>在处理错误返回值的时候，没有错误的返回值最好直接写为<code>nil</code>。</p>
<p>异常流程: </p>
<ol>
<li>当函数调用<code>panic</code>抛出异常，函数将停止执行后续的普通语句，但是之前注册的<code>defer</code>函数调用仍然保证会被正常执行，然后再返回到调用者。</li>
<li>对于当前函数的调用者，因为处理异常状态还没有被捕获，和直接调用<code>panic</code>函数的行为类似。</li>
<li>在异常发生时，如果在<code>defer</code>中执行<code>recover</code>调用，它可以捕获触发<code>panic</code>时的参数，并且恢复到正常的执行流程。</li>
</ol>
<p>我们必须在<code>defer</code>函数中直接调用<code>recover</code>。如果<code>defer</code>中调用的是<code>recover</code>函数的包装函数的话，异常的捕获工作将失败</p>
<blockquote>
<p>必须要和有异常的栈帧只隔一个栈帧，<code>recover</code>函数才能正常捕获异常。</p>
<p>换言之，<code>recover</code>函数捕获的是祖父一级调用函数栈帧的异常（刚好可以跨越一层<code>defer</code>函数）！</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> x := r.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> runtime.Error:</span><br><span class="line">				<span class="comment">// 这是运行时错误类型异常</span></span><br><span class="line">			<span class="keyword">case</span> error:</span><br><span class="line">				<span class="comment">// 普通错误类型异常</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 其他类型异常</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 失败</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 无法捕获异常</span></span><br><span class="line">		<span class="keyword">if</span> r := MyRecover(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyRecover</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;trace...&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">recover</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyRecover</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">recover</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 可以正常捕获异常</span></span><br><span class="line">	<span class="keyword">defer</span> MyRecover()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="ch2-cgo"><a href="#ch2-cgo" class="headerlink" title="ch2-cgo"></a>ch2-cgo</h1><h2 id="2-1-快速入门"><a href="#2-1-快速入门" class="headerlink" title="2.1 快速入门"></a>2.1 快速入门</h2><h3 id="基于C标准库函数输出字符串"><a href="#基于C标准库函数输出字符串" class="headerlink" title="基于C标准库函数输出字符串"></a>基于C标准库函数输出字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	C.puts(C.CString(<span class="string">&quot;Hello, World\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>import &quot;C&quot;</code>语句启用CGO特性，<code>go build</code>命令会在编译和链接阶段启动gcc编译器。紧跟在这行语句前面的注释是一种特殊语法，里面包含的是正常的C语言代码。</li>
<li>包含C语言的<code>&lt;stdio.h&gt;</code>头文件。</li>
<li>通过CGO包的<code>C.CString</code>函数将Go语言字符串转为C语言字符串，</li>
<li>调用CGO包的<code>C.puts</code>函数向标准输出窗口打印转换后的C字符串。</li>
</ul>
<h3 id="使用自己的C函数"><a href="#使用自己的C函数" class="headerlink" title="使用自己的C函数"></a>使用自己的C函数</h3><p>自定义<code>SayHello</code>的C函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void SayHello(const char* s) &#123;</span></span><br><span class="line"><span class="comment">	puts(s);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	C.SayHello(C.CString(<span class="string">&quot;Hello, World\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>引用外部的C文件：</p>
<p>将<code>SayHello</code>函数放到当前目录下的一个C语言源文件中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//void SayHello(const char* s);</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	C.SayHello(C.CString(<span class="string">&quot;Hello, World\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SayHello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为是编写在独立的C文件中，为了允许外部引用，所以需要去掉函数的<code>static</code>修饰符。</p>
</blockquote>
<ul>
<li>既然可以将<code>SayHello</code>函数放到独立的C文件中，自然就可以引用对应的C文件编译打包为静态库或动态库文件。</li>
<li>如果是以静态库或动态库方式引用<code>SayHello</code>函数的话，需要将对应的C源文件移出当前目录（CGO构建程序会自动构建当前目录下的C源文件，从而导致C函数名冲突）。</li>
</ul>
<h3 id="C代码的模块化"><a href="#C代码的模块化" class="headerlink" title="C代码的模块化"></a>C代码的模块化</h3><p>模块化编程的核心是<code>面向程序接口编程</code>（这里的接口并不是Go语言的interface，而是API的概念）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SayHello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SayHello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//void SayHello(const char* s);</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	C.SayHello(C.CString(<span class="string">&quot;Hello, World\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="导出Go语言函数给C语言函数调用"><a href="#导出Go语言函数给C语言函数调用" class="headerlink" title="导出Go语言函数给C语言函数调用"></a>导出Go语言函数给C语言函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SayHello</span><span class="params">(<span class="comment">/*const*/</span> <span class="keyword">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export SayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(s *C.char)</span></span> &#123;</span><br><span class="line">	fmt.Print(C.GoString(s), <span class="string">&quot;123&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//void SayHello(const char* s);</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	C.SayHello(C.CString(<span class="string">&quot;Hello, World\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为了适配CGO导出的C语言函数，我们禁止了在函数的声明语句中的const修饰符。</li>
<li>通过CGO的<code>//export SayHello</code>指令将Go语言实现的函数<code>SayHello</code>导出为C语言函数。</li>
</ul>
<h3 id="GoString-预定义类型"><a href="#GoString-预定义类型" class="headerlink" title="_GoString_预定义类型"></a><code>_GoString_</code>预定义类型</h3><p>正常我们使用CGO如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//void SayHello(char* s);</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	C.SayHello(C.CString(<span class="string">&quot;Hello, World\n&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export SayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(s *C.char)</span></span> &#123;</span><br><span class="line">	fmt.Print(C.GoString(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go1.10中CGO新增加了一个<code>_GoString_</code>预定义的C语言类型，用来表示Go语言字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build go1.10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//void SayHello(_GoString_ s);</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	C.SayHello(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export SayHello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Print(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-CGO基础"><a href="#2-2-CGO基础" class="headerlink" title="2.2 CGO基础"></a>2.2 CGO基础</h2><p>cgo将当前包引用的C语言符号都放到了虚拟的C包中，同时当前包依赖的其它Go语言包内部可能也通过cgo引入了相似的虚拟C包。</p>
<p>比如我们希望在Go中定义一个C语言字符指针对应的CChar类型，然后增加一个GoString方法返回Go语言字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cgo_helper</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CChar C.char</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *CChar)</span> <span class="title">GoString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> C.GoString((*C.char)(p))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintCString</span><span class="params">(cs *C.char)</span></span> &#123;  <span class="comment">// 这里的cs的类型是*cgo_helper.C.char</span></span><br><span class="line">	C.puts(cs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可能会想在其它的Go语言包中也使用这个辅助函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//static const char* cs = &quot;hello&quot;;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./cgo_helper&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cgo_helper.PrintCString(C.cs) <span class="comment">// 这里的C.cs的类型是*main.C.char</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码是不能正常工作的，原因是两个文件的<code>C.cs</code>的类型其实是不同的。<ul>
<li>main包引入的<code>*C.char</code>类型是<code>*main.C.char</code>，</li>
<li>cgo_helper包引入的<code>*C.char</code>类型是<code>*cgo_helper.C.char</code>。</li>
</ul>
</li>
<li>在Go语言中方法是依附于类型存在的，不同Go包中引入的虚拟的C包的类型却是不同的（<code>main.C</code>不等于<code>cgo_helper.C</code>），这导致从它们延伸出来的Go类型也是不同的类型（<code>*main.C.char</code>不等于<code>*cgo_helper.C.char</code>），这最终导致了前面代码不能正常工作。</li>
</ul>
<blockquote>
<p>简单来说，</p>
<ul>
<li>一个包如果在公开的接口中直接使用了<code>*C.char</code>等类似的虚拟C包的类型，那么其它的Go包是无法直接使用这些类型的，除非这个Go包同时也提供了<code>*C.char</code>类型的构造函数。</li>
<li>因为这些诸多因素，如果想在go test环境直接测试这些cgo导出的类型也会有相同的限制。</li>
</ul>
</blockquote>
<h3 id="cgo语句"><a href="#cgo语句" class="headerlink" title="#cgo语句"></a><code>#cgo</code>语句</h3><ul>
<li>在<code>import &quot;C&quot;</code>语句前的注释中可以通过<code>#cgo</code>语句设置编译阶段和链接阶段的相关参数。</li>
<li>编译阶段的参数主要用于定义相关宏和指定头文件检索路径。</li>
<li>链接阶段的参数主要是指定库文件检索路径和要链接的库文件。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #cgo CFLAGS: -DPNG_DEBUG=1 -I./include</span></span><br><span class="line"><span class="comment">// #cgo LDFLAGS: -L/usr/local/lib -lpng</span></span><br><span class="line"><span class="comment">// #include &lt;png.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>CFLAGS部分，</p>
<ul>
<li><p><code>-D</code>部分定义了宏PNG_DEBUG，值为1；</p>
<p><code>-I</code>定义了头文件包含的检索目录。</p>
</li>
</ul>
</li>
<li><p>LDFLAGS部分，</p>
<ul>
<li><code>-L</code>指定了链接时库文件检索目录，</li>
<li><code>-l</code>指定了链接时需要链接png库。</li>
</ul>
</li>
</ul>
<p><code>#cgo</code>指令还支持条件选择，当满足某个操作系统或某个CPU架构类型时后面的编译或链接选项生效。</p>
<p>下面是分别针对windows和非windows下平台的编译和链接选项：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #cgo windows CFLAGS: -DX86=1</span></span><br><span class="line"><span class="comment">// #cgo !windows LDFLAGS: -lm</span></span><br></pre></td></tr></table></figure>

<p>其中在windows平台下，编译前会预定义X86宏为1；在非widnows平台下，在链接阶段会要求链接math数学库。这种用法对于在不同平台下只有少数编译选项差异的场景比较适用。</p>
<h2 id="2-3-类型转换"><a href="#2-3-类型转换" class="headerlink" title="2.3 类型转换"></a>2.3 类型转换</h2><p>Go语言和C语言类型对比：</p>
<table>
<thead>
<tr>
<th>C语言类型</th>
<th>CGO类型</th>
<th>Go语言类型</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>C.char</td>
<td>byte</td>
</tr>
<tr>
<td>singed char</td>
<td>C.schar</td>
<td>int8</td>
</tr>
<tr>
<td>unsigned char</td>
<td>C.uchar</td>
<td>uint8</td>
</tr>
<tr>
<td>short</td>
<td>C.short</td>
<td>int16</td>
</tr>
<tr>
<td>unsigned short</td>
<td>C.ushort</td>
<td>uint16</td>
</tr>
<tr>
<td>int</td>
<td>C.int</td>
<td>int32</td>
</tr>
<tr>
<td>unsigned int</td>
<td>C.uint</td>
<td>uint32</td>
</tr>
<tr>
<td>long</td>
<td>C.long</td>
<td>int32</td>
</tr>
<tr>
<td>unsigned long</td>
<td>C.ulong</td>
<td>uint32</td>
</tr>
<tr>
<td>long long int</td>
<td>C.longlong</td>
<td>int64</td>
</tr>
<tr>
<td>unsigned long long int</td>
<td>C.ulonglong</td>
<td>uint64</td>
</tr>
<tr>
<td>float</td>
<td>C.float</td>
<td>float32</td>
</tr>
<tr>
<td>double</td>
<td>C.double</td>
<td>float64</td>
</tr>
<tr>
<td>size_t</td>
<td>C.size_t</td>
<td>uint</td>
</tr>
</tbody></table>
<ul>
<li>CGO中，虽然C语言的<code>int</code>固定为4字节的大小，但是Go语言自己的<code>int</code>和<code>uint</code>却在32位和64位系统下分别对应4个字节和8个字节大小。</li>
<li>如果需要在C语言中访问Go语言的<code>int</code>类型，可以通过<code>GoInt</code>类型访问，<code>GoInt</code>类型在CGO工具生成的<code>_cgo_export.h</code>头文件中定义。</li>
<li>下面是64位环境下，<code>_cgo_export.h</code>头文件生成的Go数值类型的定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> GoInt8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> GoUint8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span> GoInt16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> GoUint16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> GoInt32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> GoUint32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> GoInt64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> GoUint64;</span><br><span class="line"><span class="keyword">typedef</span> GoInt64 GoInt;</span><br><span class="line"><span class="keyword">typedef</span> GoUint64 GoUint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> GoFloat32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> GoFloat64;</span><br></pre></td></tr></table></figure>



<h3 id="Go-字符串和切片"><a href="#Go-字符串和切片" class="headerlink" title="Go 字符串和切片"></a>Go 字符串和切片</h3><p>在CGO生成的<code>_cgo_export.h</code>头文件中还会为Go语言的字符串、切片、字典、接口和管道等特有的数据类型生成对应的C语言类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">const</span> <span class="keyword">char</span> *p; GoInt n; &#125; GoString;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *GoMap;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *GoChan;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">void</span> *t; <span class="keyword">void</span> *v; &#125; GoInterface;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">void</span> *data; GoInt len; GoInt cap; &#125; GoSlice;</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，其中<strong>只有字符串和切片在CGO中有一定的使用价值</strong>，因为CGO为他们的某些GO语言版本的操作函数生成了C语言版本，因此二者可以在Go调用C语言函数时马上使用;而CGO并未针对其他的类型提供相关的辅助函数，且Go语言特有的内存模型导致我们无法保持这些由Go语言管理的内存指针，所以它们C语言环境并无使用的价值。</p>
<h3 id="结构体、联合、枚举类型"><a href="#结构体、联合、枚举类型" class="headerlink" title="结构体、联合、枚举类型"></a>结构体、联合、枚举类型</h3><p>结构体的内存布局按照C语言的通用对齐规则。</p>
<p>结构体的简单用法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct A &#123;</span></span><br><span class="line"><span class="comment">	int i;</span></span><br><span class="line"><span class="comment">	float f;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a C.struct_A</span><br><span class="line">	fmt.Println(a.i)</span><br><span class="line">	fmt.Println(a.f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果结构体的成员名字中碰巧是Go语言的关键字，可以通过在成员名开头添加下划线来访问：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct A &#123;</span></span><br><span class="line"><span class="comment">	int type; // type 是 Go 语言的关键字</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a C.struct_A</span><br><span class="line">	fmt.Println(a._type) <span class="comment">// _type 对应 type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是如果有2个成员：一个是以Go语言关键字命名，另一个刚好是以下划线和Go语言关键字命名，那么以Go语言关键字命名的成员将无法访问（被屏蔽）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct A &#123;</span></span><br><span class="line"><span class="comment">	int   type;  // type 是 Go 语言的关键字</span></span><br><span class="line"><span class="comment">	float _type; // 将屏蔽CGO对 type 成员的访问</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a C.struct_A</span><br><span class="line">	fmt.Println(a._type) <span class="comment">// _type 对应 _type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>C语言结构体中<code>位字段成员</code>无法在Go语言中访问，如果需要操作位字段成员，需要通过在C语言中定义辅助函数来完成。</li>
<li>C语言结构体中<code>零长数组成员</code>无法在Go语言中直接访问数组的元素，但其中零长的数组成员所在位置的偏移量依然可以通过<code>unsafe.Offsetof(a.arr)</code>来访问。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct A &#123;</span></span><br><span class="line"><span class="comment">	int   size: 10; // 位字段无法访问</span></span><br><span class="line"><span class="comment">	float arr[];    // 零长的数组也无法访问</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a C.struct_A</span><br><span class="line">	fmt.Println(a.size) <span class="comment">// 错误: 位字段无法访问</span></span><br><span class="line">	fmt.Println(a.arr)  <span class="comment">// 错误: 零长的数组也无法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>在C语言中，我们无法直接访问Go语言定义的结构体类型。</strong></p>
<p>对于联合类型，我们可以通过<code>C.union_xxx</code>来访问。但是Go语言中并不支持C语言联合类型，所以它们会被转为对应大小的字节数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdint.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">union B1 &#123;</span></span><br><span class="line"><span class="comment">	int i;</span></span><br><span class="line"><span class="comment">	float f;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">union B2 &#123;</span></span><br><span class="line"><span class="comment">	int8_t i8;</span></span><br><span class="line"><span class="comment">	int64_t i64;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b1 C.union_B1;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, b1) <span class="comment">// [4]uint8</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b2 C.union_B2;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, b2) <span class="comment">// [8]uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果需要操作C语言的联合类型变量，一般有三种方法：</p>
<ul>
<li>在C语言中定义辅助函数；</li>
<li>通过Go语言的”encoding/binary”手工解码成员(需要注意大端小端问题)；</li>
<li>使用<code>unsafe</code>包强制转型为对应类型(这是性能最好的方式)。</li>
</ul>
<p>下面展示通过<code>unsafe</code>包访问联合类型成员的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;stdint.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">union B &#123;</span></span><br><span class="line"><span class="comment">	int i;</span></span><br><span class="line"><span class="comment">	float f;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b C.union_B;</span><br><span class="line">	fmt.Println(<span class="string">&quot;b.i:&quot;</span>, *(*C.<span class="keyword">int</span>)(unsafe.Pointer(&amp;b)))</span><br><span class="line">	fmt.Println(<span class="string">&quot;b.f:&quot;</span>, *(*C.float)(unsafe.Pointer(&amp;b)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然<code>unsafe</code>包访问最简单、性能也最好，但是对于有嵌套联合类型的情况处理会导致问题复杂化。对于复杂的联合类型，推荐通过在C语言中定义辅助函数的方式处理。</p>
</blockquote>
<p>对于枚举类型，我们可以通过<code>C.enum_xxx</code>来访问C语言中定义的<code>enum xxx</code>结构体类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">enum C &#123;</span></span><br><span class="line"><span class="comment">	ONE,</span></span><br><span class="line"><span class="comment">	TWO,</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c C.enum_C = C.TWO</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(C.ONE)</span><br><span class="line">	fmt.Println(C.TWO)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C语言中，枚举类型底层对应<code>int</code>类型，支持负数类型的值。我们可以通过<code>C.ONE</code>、<code>C.TWO</code>等直接访问定义的枚举值。</p>
<h3 id="数组、字符串和切片"><a href="#数组、字符串和切片" class="headerlink" title="数组、字符串和切片"></a>数组、字符串和切片</h3><ul>
<li>在C语言中，数组名其实对应于一个指针，指向特定类型特定长度的一段内存，但是这个指针不能被修改；当把数组名传递给一个函数时，实际上传递的是数组第一个元素的地址。为了讨论方便，我们将一段特定长度的内存统称为数组。C语言的字符串是一个char类型的数组，字符串的长度需要根据表示结尾的NULL字符的位置确定。C语言中没有切片类型。</li>
<li>在Go语言中，数组是一种值类型，而且数组的长度是数组类型的一个部分。<strong>Go语言字符串对应一段长度确定的只读byte类型的内存</strong>。Go语言的切片则是一个简化版的动态数组。</li>
</ul>
<p>Go语言和C语言的数组、字符串和切片之间的相互转换，可以<strong>简化为Go语言的切片和C语言中指向一定长度内存的指针之间的转换</strong>。</p>
<p>CGO的C虚拟包提供了以下一组函数，用于Go语言和C语言之间数组和字符串的双向转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go string to C string</span></span><br><span class="line"><span class="comment">// The C string is allocated in the C heap using malloc.</span></span><br><span class="line"><span class="comment">// It is the caller&#x27;s responsibility to arrange for it to be</span></span><br><span class="line"><span class="comment">// freed, such as by calling C.free (be sure to include stdlib.h</span></span><br><span class="line"><span class="comment">// if C.free is needed).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">CString</span><span class="params">(<span class="keyword">string</span>)</span> *<span class="title">C</span>.<span class="title">char</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go []byte slice to C array</span></span><br><span class="line"><span class="comment">// The C array is allocated in the C heap using malloc.</span></span><br><span class="line"><span class="comment">// It is the caller&#x27;s responsibility to arrange for it to be</span></span><br><span class="line"><span class="comment">// freed, such as by calling C.free (be sure to include stdlib.h</span></span><br><span class="line"><span class="comment">// if C.free is needed).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">CBytes</span><span class="params">([]<span class="keyword">byte</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C string to Go string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">GoString</span><span class="params">(*C.char)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C data with explicit length to Go string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">GoStringN</span><span class="params">(*C.char, C.<span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C data with explicit length to Go []byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span>.<span class="title">GoBytes</span><span class="params">(unsafe.Pointer, C.<span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>其中<code>C.CString</code>针对输入的Go字符串，克隆一个C语言格式的字符串；返回的字符串由C语言的<code>malloc</code>函数分配，不使用时需要通过C语言的<code>free</code>函数释放。<code>C.CBytes</code>函数的功能和<code>C.CString</code>类似，用于从输入的Go语言字节切片克隆一个C语言版本的字节数组，同样返回的数组需要在合适的时候释放。<code>C.GoString</code>用于将从NULL结尾的C语言字符串克隆一个Go语言字符串。<code>C.GoStringN</code>是另一个字符数组克隆函数。<code>C.GoBytes</code>用于从C语言数组，克隆一个Go语言字节切片。</li>
</ul>
<p>该组辅助函数都是以克隆的方式运行。当Go语言字符串和切片向C语言转换时，克隆的内存由C语言的<code>malloc</code>函数分配，最终可以通过<code>free</code>函数释放。当C语言字符串或数组向Go语言转换时，克隆的内存由Go语言分配管理。通过该组转换函数，转换前和转换后的内存依然在各自的语言环境中，它们并没有跨越Go语言和C语言。克隆方式实现转换的优点是接口和内存管理都很简单，缺点是克隆需要分配新的内存和复制操作都会导致额外的开销。</p>
<h1 id="ch4-rpc"><a href="#ch4-rpc" class="headerlink" title="ch4-rpc"></a>ch4-rpc</h1><h2 id="4-1-RPC入门"><a href="#4-1-RPC入门" class="headerlink" title="4.1 RPC入门"></a>4.1 RPC入门</h2><p>server：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go语言的RPC规则：必须是公开的方法，只能有两个可序列化的参数，其中第二个参数是指针类型。返回一个error类型。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	*reply = <span class="string">&quot;hello:&quot;</span> + request</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将所有满足RPC规则的对象方法注册为RPC函数</span></span><br><span class="line">	rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenTCP error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conn, err := listener.Accept()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Accept error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;HelloService.Hello&quot;</span>, <span class="string">&quot;hello&quot;</span>, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="更安全的RPC接口"><a href="#更安全的RPC接口" class="headerlink" title="更安全的RPC接口"></a>更安全的RPC接口</h3><p>在涉及RPC的应用中，作为开发人员一般至少有三种角色：</p>
<ul>
<li>服务端实现RPC方法的开发人员，</li>
<li>客户端调用RPC方法的人员，</li>
<li>制定服务端和客户端RPC接口规范的设计人员。</li>
</ul>
<blockquote>
<p>前面的例子中我们为了简化将以上几种角色的工作全部放到了一起，看似实现简单，但是不利于后期的维护和工作的切割。</p>
</blockquote>
<p>明确服务的名字和接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HelloServiceName = <span class="string">&quot;path/to/pkg.HelloService&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloServiceInterface = <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHelloService</span><span class="params">(svc HelloServiceInterface)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rpc.RegisterName(HelloServiceName, svc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	*reply = <span class="string">&quot;hello:&quot;</span> + request</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	RegisterHelloService(<span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenTCP error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;Accept error:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> rpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将RPC服务的接口规范分为三个部分：</p>
<ul>
<li>服务的名字，</li>
<li>服务要实现的详细方法列表，</li>
<li>注册该类型服务的函数。</li>
</ul>
<blockquote>
<p>为了避免名字冲突，我们在RPC服务的名字中增加了包路径前缀（这个是RPC服务抽象的包路径，并非完全等价Go语言的包路径）。</p>
</blockquote>
<p>对client进行包装：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloServiceClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	*rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ HelloServiceInterface = (*HelloServiceClient)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialHelloService</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*HelloServiceClient, error)</span></span> &#123;</span><br><span class="line">	c, err := rpc.Dial(network, address)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;HelloServiceClient&#123;Client: c&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceClient)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Client.Call(HelloServiceName+<span class="string">&quot;.Hello&quot;</span>, request, reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	client, err := DialHelloService(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	err = client.Hello(<span class="string">&quot;hello&quot;</span>, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="跨语言的RPC"><a href="#跨语言的RPC" class="headerlink" title="跨语言的RPC"></a>跨语言的RPC</h3><p>Go语言的RPC框架有两个比较有特色的设计：</p>
<ul>
<li>RPC数据打包时可以通过插件实现自定义的编码和解码；</li>
<li>RPC建立在抽象的io.ReadWriteCloser接口之上的，我们可以将RPC架设在不同的通讯协议之上。</li>
</ul>
<p>通过官方自带的net/rpc/jsonrpc扩展实现一个跨语言的RPC。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenTCP error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;Accept error:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用rpc.ServeCodec函数替代了rpc.ServeConn函数</span></span><br><span class="line">    <span class="comment">// 传入的参数：针对服务端的json编解码器。</span></span><br><span class="line">		<span class="keyword">go</span> rpc.ServeCodec(jsonrpc.NewServerCodec(conn))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;net.Dial:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;HelloService.Hello&quot;</span>, <span class="string">&quot;hello&quot;</span>, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过直接向架设了RPC服务的TCP服务器发送json数据模拟RPC方法调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo -e &#x27;&#123;&quot;method&quot;:&quot;HelloService.Hello&quot;,&quot;params&quot;:[&quot;hello&quot;],&quot;id&quot;:1&#125;&#x27; | nc localhost 1234</span><br></pre></td></tr></table></figure>

<p>返回的结果也是一个json格式的数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;result&quot;</span>:<span class="string">&quot;hello:hello&quot;</span>,<span class="attr">&quot;error&quot;</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Http上的RPC"><a href="#Http上的RPC" class="headerlink" title="Http上的RPC"></a>Http上的RPC</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/jsonrpc&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> conn io.ReadWriteCloser = <span class="keyword">struct</span> &#123;</span><br><span class="line">			io.Writer</span><br><span class="line">			io.ReadCloser</span><br><span class="line">		&#125;&#123;</span><br><span class="line">			ReadCloser: r.Body,</span><br><span class="line">			Writer:     w,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rpc.ServeRequest(jsonrpc.NewServerCodec(conn))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-Protobuf"><a href="#4-2-Protobuf" class="headerlink" title="4.2 Protobuf"></a>4.2 Protobuf</h2><p>Protobuf中最基本的数据单元是message，是类似Go语言中结构体的存在。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Protobuf核心的工具集是C++语言开发的，在官方的protoc编译器中并不支持Go语言。要想基于上面的hello.proto文件生成相应的Go代码，需要安装相应的插件。首先是安装官方的protoc工具，可以从 <a target="_blank" rel="noopener" href="https://github.com/google/protobuf/releases">https://github.com/google/protobuf/releases</a> 下载。然后是安装针对Go语言的代码生成插件，可以通过<code>go get github.com/golang/protobuf/protoc-gen-go</code>命令安装。</p>
</blockquote>
<p>然后通过以下命令生成相应的Go代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. hello.proto</span><br></pre></td></tr></table></figure>

<p>其中<code>go_out</code>参数告知protoc编译器去加载对应的protoc-gen-go工具，然后通过该工具生成代码，生成代码放到当前目录。最后是一系列要处理的protobuf文件的列表。</p>
<p>通过Protobuf来定义HelloService服务：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> Hello (String) <span class="keyword">returns</span> (String)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>$ protoc --go_out=. hello.proto</code>，发现重新生成的Go代码并没有发生变化。</p>
<p>这是因为世界上的RPC实现有千万种，protoc编译器并不知道该如何为HelloService服务生成代码。在protoc-gen-go内部已经集成了一个名字为<code>grpc</code>的插件，可以针对gRPC生成代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=plugins=grpc:. hello.proto</span><br></pre></td></tr></table></figure>



<h3 id="定制代码生成插件"><a href="#定制代码生成插件" class="headerlink" title="定制代码生成插件"></a>定制代码生成插件</h3><p>Protobuf的protoc编译器是<strong>通过插件机制实现对不同语言的支持</strong>。</p>
<blockquote>
<p>比如protoc命令出现<code>--xxx_out</code>格式的参数，</p>
<ol>
<li>protoc将首先查询是否有内置的xxx插件，</li>
<li>如果没有内置的xxx插件那么将继续查询当前系统中是否存在protoc-gen-xxx命名的可执行程序，最终通过查询到的插件生成代码。</li>
<li>对于Go语言的protoc-gen-go插件来说，<strong>里面又实现了一层静态插件系统</strong>。</li>
<li>比如protoc-gen-go内置了一个gRPC插件，用户可以通过<code>--go_out=plugins=grpc</code>参数来生成gRPC相关代码，否则只会针对message生成相关代码。</li>
</ol>
</blockquote>
<p>参考gRPC插件的代码，可以发现generator.RegisterPlugin函数可以用来注册插件。</p>
<p>插件是一个generator.Plugin接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Plugin provides functionality to add to the output during</span></span><br><span class="line"><span class="comment">// Go code generation, such as to produce RPC stubs.</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Name identifies the plugin.</span></span><br><span class="line">	Name() <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Init is called once after data structures are built but before</span></span><br><span class="line">	<span class="comment">// code generation begins.</span></span><br><span class="line">	Init(g *Generator)</span><br><span class="line">	<span class="comment">// Generate produces the code generated by the plugin for this file,</span></span><br><span class="line">	<span class="comment">// except for the imports, by calling the generator&#x27;s methods P, In,</span></span><br><span class="line">	<span class="comment">// and Out.</span></span><br><span class="line">	Generate(file *FileDescriptor)</span><br><span class="line">	<span class="comment">// GenerateImports produces the import declarations for this file.</span></span><br><span class="line">	<span class="comment">// It is called after Generate.</span></span><br><span class="line">	GenerateImports(file *FileDescriptor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Name方法返回插件的名字，这是Go语言的Protobuf实现的插件体系，和protoc插件的名字并无关系。</li>
<li>Init函数是通过g参数对插件进行初始化，g参数中包含Proto文件的所有信息。</li>
<li>Generate和GenerateImports方法用于生成主体代码和对应的导入包代码。</li>
</ul>
<p>因此我们可以设计一个netrpcPlugin插件，用于为标准库的RPC框架生成代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/golang/protobuf/protoc-gen-go/generator&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> netrpcPlugin <span class="keyword">struct</span>&#123; *generator.Generator &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *netrpcPlugin)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span>                &#123; <span class="keyword">return</span> <span class="string">&quot;netrpc&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *netrpcPlugin)</span> <span class="title">Init</span><span class="params">(g *generator.Generator)</span></span> &#123; p.Generator = g &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *netrpcPlugin)</span> <span class="title">GenerateImports</span><span class="params">(file *generator.FileDescriptor)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(file.Service) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		p.genImportCode(file)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *netrpcPlugin)</span> <span class="title">Generate</span><span class="params">(file *generator.FileDescriptor)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, svc := <span class="keyword">range</span> file.Service &#123;</span><br><span class="line">		p.genServiceCode(svc)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *netrpcPlugin)</span> <span class="title">genImportCode</span><span class="params">(file *generator.FileDescriptor)</span></span> &#123;</span><br><span class="line">	p.P(<span class="string">&quot;// TODO: import code&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *netrpcPlugin)</span> <span class="title">genServiceCode</span><span class="params">(svc *descriptor.ServiceDescriptorProto)</span></span> &#123;</span><br><span class="line">	p.P(<span class="string">&quot;// TODO: service code, Name = &quot;</span> + svc.GetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Name方法返回插件的名字。</li>
<li>netrpcPlugin插件内置了一个匿名的<code>*generator.Generator</code>成员，然后在Init初始化的时候用参数g进行初始化，因此插件是从g参数对象继承了全部的公有方法。</li>
<li>其中GenerateImports方法调用自定义的genImportCode函数生成导入代码。</li>
<li>Generate方法调用自定义的genServiceCode方法生成每个服务的代码。</li>
</ul>
<p>要使用该插件需要先通过generator.RegisterPlugin函数注册插件，可以在init函数中完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	generator.RegisterPlugin(<span class="built_in">new</span>(netrpcPlugin))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Go语言的包只能静态导入，我们无法向已经安装的protoc-gen-go添加我们新编写的插件。我们将重新克隆protoc-gen-go对应的main函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/golang/protobuf/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/golang/protobuf/protoc-gen-go/generator&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := generator.New()</span><br><span class="line"></span><br><span class="line">	data, err := ioutil.ReadAll(os.Stdin)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		g.Error(err, <span class="string">&quot;reading input&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := proto.Unmarshal(data, g.Request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		g.Error(err, <span class="string">&quot;parsing input proto&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(g.Request.FileToGenerate) == <span class="number">0</span> &#123;</span><br><span class="line">		g.Fail(<span class="string">&quot;no files to generate&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g.CommandLineParameters(g.Request.GetParameter())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a wrapped version of the Descriptors and EnumDescriptors that</span></span><br><span class="line">	<span class="comment">// point to the file that defines them.</span></span><br><span class="line">	g.WrapTypes()</span><br><span class="line"></span><br><span class="line">	g.SetPackageNames()</span><br><span class="line">	g.BuildTypeNameMap()</span><br><span class="line"></span><br><span class="line">	g.GenerateAllFiles()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send back the results.</span></span><br><span class="line">	data, err = proto.Marshal(g.Response)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		g.Error(err, <span class="string">&quot;failed to marshal output proto&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = os.Stdout.Write(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		g.Error(err, <span class="string">&quot;failed to write output proto&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免对protoc-gen-go插件造成干扰，我们将我们的可执行程序命名为protoc-gen-go-netrpc，表示包含了netrpc插件。然后用以下命令重新编译hello.proto文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go-netrpc_out=plugins=netrpc:. hello.proto</span><br></pre></td></tr></table></figure>

<p>其中<code>--go-netrpc_out</code>参数告知protoc编译器加载名为protoc-gen-go-netrpc的插件，插件中的<code>plugins=netrpc</code>指示启用内部唯一的名为netrpc的netrpcPlugin插件。在新生成的hello.pb.go文件中将包含增加的注释代码。</p>
<p>至此，手工定制的Protobuf代码生成插件终于可以工作了。</p>
<h2 id="4-3-玩转RPC"><a href="#4-3-玩转RPC" class="headerlink" title="4.3 玩转RPC"></a>4.3 玩转RPC</h2><h3 id="基于RPC实现Watch功能"><a href="#基于RPC实现Watch功能" class="headerlink" title="基于RPC实现Watch功能"></a>基于RPC实现Watch功能</h3><p>在很多系统中都提供了Watch监视功能的接口，当系统满足某种条件时Watch方法返回监控的结果。在这里我们可以尝试通过RPC框架实现一个基本的Watch功能。</p>
<p>为了便于演示，我们计划通过RPC构造一个简单的内存KV数据库。首先定义服务如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KVStoreService <span class="keyword">struct</span> &#123;</span><br><span class="line">	m      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// 用于存储KV数据</span></span><br><span class="line">	filter <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> // 对应每个<span class="title">Watch</span>调用时定义的过滤器函数列表</span></span><br><span class="line">	mu     sync.Mutex <span class="comment">// 用于在多个Goroutine访问或修改时对其它成员提供保护</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKVStoreService</span><span class="params">()</span> *<span class="title">KVStoreService</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;KVStoreService&#123;</span><br><span class="line">		m:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">		filter: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span>),</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *KVStoreService)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>, value *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> v, ok := p.m[key]; ok &#123;</span><br><span class="line">		*value = v</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当修改某个key对应的值时会调用每一个过滤器函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *KVStoreService)</span> <span class="title">Set</span><span class="params">(kv [2]<span class="keyword">string</span>, reply *<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	key, value := kv[<span class="number">0</span>], kv[<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">if</span> oldValue := p.m[key]; oldValue != value &#123;</span><br><span class="line">		<span class="keyword">for</span> _, fn := <span class="keyword">range</span> p.filter &#123;</span><br><span class="line">			fn(key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.m[key] = value</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤器列表在Watch方法中提供</span></span><br><span class="line"><span class="comment">// 输入参数是超时的秒数。当有key变化时将key作为返回值返回。如果超过时间后依然没有key被修改，则返回超时的错误。</span></span><br><span class="line"><span class="comment">// 用唯一的id表示每个Watch调用，然后根据id将自身对应的过滤器函数注册到p.filter列表。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *KVStoreService)</span> <span class="title">Watch</span><span class="params">(timeoutSecond <span class="keyword">int</span>, keyChanged *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	id := fmt.Sprintf(<span class="string">&quot;watch-%s-%03d&quot;</span>, time.Now(), rand.Int())</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>) <span class="comment">// buffered</span></span><br><span class="line"></span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	p.filter[id] = <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123; ch &lt;- key &#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Duration(timeoutSecond) * time.Second):</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> key := &lt;-ch:</span><br><span class="line">		*keyChanged = key</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doClientWork</span><span class="params">(client *rpc.Client)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> keyChanged <span class="keyword">string</span></span><br><span class="line">		err := client.Call(<span class="string">&quot;KVStoreService.Watch&quot;</span>, <span class="number">30</span>, &amp;keyChanged)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;watch:&quot;</span>, keyChanged)</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	err := client.Call(</span><br><span class="line">		<span class="string">&quot;KVStoreService.Set&quot;</span>, [<span class="number">2</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc-value&quot;</span>&#125;,</span><br><span class="line">		<span class="built_in">new</span>(<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先启动一个独立的Goroutine监控key的变化。同步的watch调用会阻塞，直到有key发生变化或者超时。然后在通过Set方法修改KV值时，服务器会将变化的key通过Watch方法返回。这样我们就可以实现对某些状态的监控。</p>
<h3 id="反向RPC"><a href="#反向RPC" class="headerlink" title="反向RPC"></a>反向RPC</h3><p>在公司内网提供一个RPC服务，但是在外网无法链接到内网的服务器。</p>
<p>这种时候我们可以参考类似反向代理的技术，首先从内网主动链接到外网的TCP服务器，然后基于TCP链接向外网提供RPC服务。</p>
<p>反向RPC的内网服务将不再主动提供TCP监听服务，而是首先主动链接到对方的TCP服务器。然后基于每个建立的TCP链接向对方提供RPC服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpc.Register(<span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, _ := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:1234&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> conn == <span class="literal">nil</span> &#123;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rpc.ServeConn(conn)</span><br><span class="line">		conn.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而RPC客户端则需要在一个公共的地址提供一个TCP服务，用于接受RPC服务器的链接请求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenTCP error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	clientChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *rpc.Client)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := listener.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatal(<span class="string">&quot;Accept error:&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			clientChan &lt;- rpc.NewClient(conn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	doClientWork(clientChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当每个链接建立后，基于网络链接构造RPC客户端对象并发送到clientChan管道。</p>
<p>客户端执行RPC调用的操作在doClientWork函数完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doClientWork</span><span class="params">(clientChan &lt;-<span class="keyword">chan</span> *rpc.Client)</span></span> &#123;</span><br><span class="line">	client := &lt;-clientChan</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;HelloService.Hello&quot;</span>, <span class="string">&quot;hello&quot;</span>, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从管道去取一个RPC客户端对象，并且通过defer语句指定在函数退出前关闭客户端。然后是执行正常的RPC调用。</p>
<h3 id="上下文信息"><a href="#上下文信息" class="headerlink" title="上下文信息"></a>上下文信息</h3><p>基于上下文我们可以针对不同客户端提供定制化的RPC服务。我们可以通过为每个链接提供独立的RPC服务来实现对上下文特性的支持。</p>
<p>首先改造HelloService，里面增加了对应链接的conn成员：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;</span><br><span class="line">	conn net.Conn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为每个链接启动独立的RPC服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenTCP error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;Accept error:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">			p := rpc.NewServer()</span><br><span class="line">			p.Register(&amp;HelloService&#123;conn: conn&#125;)</span><br><span class="line">			p.ServeConn(conn)</span><br><span class="line">		&#125; ()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hello方法中就可以根据conn成员识别不同链接的RPC调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	*reply = <span class="string">&quot;hello:&quot;</span> + request + <span class="string">&quot;, from&quot;</span> + p.conn.RemoteAddr().String()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于上下文信息，我们可以方便地为RPC服务增加简单的登陆状态的验证：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span> &#123;</span><br><span class="line">	conn    net.Conn</span><br><span class="line">	isLogin <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Login</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> request != <span class="string">&quot;user:password&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;auth failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;login ok&quot;</span>)</span><br><span class="line">	p.isLogin = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !p.isLogin &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;please login&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	*reply = <span class="string">&quot;hello:&quot;</span> + request + <span class="string">&quot;, from&quot;</span> + p.conn.RemoteAddr().String()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以要求在客户端链接RPC服务时，首先要执行登陆操作，登陆成功后才能正常执行其他的服务。</p>
<h2 id="4-4-gRPC入门"><a href="#4-4-gRPC入门" class="headerlink" title="4.4 gRPC入门"></a>4.4 gRPC入门</h2><p>gRPC技术栈</p>
<p><img src="/images/image-20210615211107053.png" alt="image-20210615211107053"></p>
<p>gRPC和标准库的RPC框架有一个区别，<strong>gRPC生成的接口并不支持异步调用</strong>。不过我们可以在多个Goroutine之间安全地共享gRPC底层的HTTP/2链接，因此可以通过在另一个Goroutine阻塞调用的方式模拟异步调用。</p>
<h3 id="gRPC流"><a href="#gRPC流" class="headerlink" title="gRPC流"></a>gRPC流</h3><ul>
<li>RPC是远程函数调用，因此每次调用的函数参数和返回值不能太大，否则将严重影响每次调用的响应时间。</li>
<li>因此传统的RPC方法调用对于上传和下载较大数据量场景并不适合。同时传统RPC模式也不适用于对时间不确定的订阅和发布模式。</li>
<li>为此，gRPC框架针对服务器端和客户端分别提供了流特性。</li>
</ul>
<p>我们在HelloService增加一个支持双向流的Channel方法：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> Hello (String) <span class="keyword">returns</span> (String)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> Channel (stream String) <span class="keyword">returns</span> (stream String)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字stream指定启用流特性，参数部分是接收客户端参数的流，返回值是返回给客户端的流。</p>
<p>重新生成代码可以看到接口中新增加的Channel方法的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(context.Context, *String) (*String, error)</span><br><span class="line">	Channel(HelloService_ChannelServer) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> HelloServiceClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(ctx context.Context, in *String, opts ...grpc.CallOption) (</span><br><span class="line">		*String, error,</span><br><span class="line">	)</span><br><span class="line">	Channel(ctx context.Context, opts ...grpc.CallOption) (</span><br><span class="line">		HelloService_ChannelClient, error,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务端的Channel方法参数是一个新的HelloService_ChannelServer类型的参数，可以用于和客户端双向通信。客户端的Channel方法返回一个HelloService_ChannelClient类型的返回值，可以用于和服务端进行双向通信。</p>
<p>HelloService_ChannelServer和HelloService_ChannelClient均为接口类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloService_ChannelServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*String) error</span><br><span class="line">	Recv() (*String, error)</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService_ChannelClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*String) error</span><br><span class="line">	Recv() (*String, error)</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现服务端和客户端的流辅助接口均定义了Send和Recv方法用于流数据的双向通信。</p>
<p>现在我们可以实现流服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceImpl)</span> <span class="title">Channel</span><span class="params">(stream HelloService_ChannelServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		args, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		reply := &amp;String&#123;Value: <span class="string">&quot;hello:&quot;</span> + args.GetValue()&#125;</span><br><span class="line"></span><br><span class="line">		err = stream.Send(reply)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，发送和接收的操作并不需要一一对应，用户可以根据真实场景进行组织代码。</p>
</blockquote>
<p>客户端需要先调用Channel方法获取返回的流对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream, err := client.Channel(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端我们将发送和接收操作放到两个独立的Goroutine。首先是向服务端发送数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(&amp;String&#123;Value: <span class="string">&quot;hi&quot;</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>然后在循环中接收服务端返回的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	reply, err := stream.Recv()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(reply.GetValue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了完整的流接收和发送支持。</p>
<h3 id="发布和订阅模式"><a href="#发布和订阅模式" class="headerlink" title="发布和订阅模式"></a>发布和订阅模式</h3><ul>
<li>在发布和订阅模式中，由调用者主动发起的发布行为类似一个普通函数调用，而被动的订阅者则类似gRPC客户端单向流中的接收者。</li>
<li>现在我们可以尝试基于gRPC的流特性构造一个发布和订阅系统。</li>
</ul>
<p>下面是基于pubsub包实现的本地发布订阅代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/moby/moby/pkg/pubsub&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := pubsub.NewPublisher(<span class="number">100</span>*time.Millisecond, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `p.SubscribeTopic()`可以通过函数筛选感兴趣的主题进行订阅。</span></span><br><span class="line">	golang := p.SubscribeTopic(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> key, ok := v.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> strings.HasPrefix(key, <span class="string">&quot;golang:&quot;</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line">  </span><br><span class="line">	docker := p.SubscribeTopic(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> key, ok := v.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> strings.HasPrefix(key, <span class="string">&quot;docker:&quot;</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> p.Publish(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> p.Publish(<span class="string">&quot;golang: https://golang.org&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> p.Publish(<span class="string">&quot;docker: https://www.docker.com/&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;golang topic:&quot;</span>, &lt;-golang)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;docker topic:&quot;</span>, &lt;-docker)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在尝试基于gRPC和pubsub包，提供一个跨网络的发布和订阅系统。首先通过Protobuf定义一个发布订阅服务接口：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">PubsubService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> Publish (String) <span class="keyword">returns</span> (String)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> Subscribe (String) <span class="keyword">returns</span> (stream String)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中Publish是普通的RPC方法，Subscribe则是一个单向的流服务。</strong></p>
<p>gRPC插件会为服务端和客户端生成对应的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PubsubServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Publish(context.Context, *String) (*String, error)</span><br><span class="line">	Subscribe(*String, PubsubService_SubscribeServer) error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PubsubServiceClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Publish(context.Context, *String, ...grpc.CallOption) (*String, error)</span><br><span class="line">	Subscribe(context.Context, *String, ...grpc.CallOption) (</span><br><span class="line">		PubsubService_SubscribeClient, error,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PubsubService_SubscribeServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*String) error</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Subscribe是服务端的单向流，因此生成的HelloService_SubscribeServer接口中只有Send方法。</p>
<p>然后就可以实现发布和订阅服务了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PubsubService <span class="keyword">struct</span> &#123;</span><br><span class="line">	pub *pubsub.Publisher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPubsubService</span><span class="params">()</span> *<span class="title">PubsubService</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;PubsubService&#123;</span><br><span class="line">		pub: pubsub.NewPublisher(<span class="number">100</span>*time.Millisecond, <span class="number">10</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后是实现发布方法和订阅方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PubsubService)</span> <span class="title">Publish</span><span class="params">(ctx context.Context, arg *String)</span> <span class="params">(*String, error)</span></span> &#123;</span><br><span class="line">	p.pub.Publish(arg.GetValue())</span><br><span class="line">	<span class="keyword">return</span> &amp;String&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PubsubService)</span> <span class="title">Subscribe</span><span class="params">(arg *String, stream PubsubService_SubscribeServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ch := p.pub.SubscribeTopic(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> key, ok := v.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> strings.HasPrefix(key,arg.GetValue()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(&amp;String&#123;Value: v.(<span class="keyword">string</span>)&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样就可以从客户端向服务器发布信息了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:1234&quot;</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	client := NewPubsubServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	_, err = client.Publish(</span><br><span class="line">		context.Background(), &amp;String&#123;Value: <span class="string">&quot;golang: hello Go&quot;</span>&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = client.Publish(</span><br><span class="line">		context.Background(), &amp;String&#123;Value: <span class="string">&quot;docker: hello Docker&quot;</span>&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后就可以在另一个客户端进行订阅信息了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:1234&quot;</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	client := NewPubsubServiceClient(conn)</span><br><span class="line">	stream, err := client.Subscribe(</span><br><span class="line">		context.Background(), &amp;String&#123;Value: <span class="string">&quot;golang:&quot;</span>&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		reply, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Println(reply.GetValue())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此我们就基于gRPC简单实现了一个跨网络的发布和订阅服务。</p>
<h2 id="4-5-gRPC进阶"><a href="#4-5-gRPC进阶" class="headerlink" title="4.5 gRPC进阶"></a>4.5 gRPC进阶</h2><ul>
<li>gRPC建立在HTTP/2协议之上，对TLS提供了很好的支持。</li>
<li>我们前面章节中gRPC的服务都没有提供证书支持，因此客户端在链接服务器中通过<code>grpc.WithInsecure()</code>选项跳过了对服务器证书的验证。没有启用证书的gRPC服务在和客户端进行的是明文通讯，信息面临被任何第三方监听的风险。</li>
<li>为了保障gRPC通信不被第三方监听篡改或伪造，我们可以对服务器启动TLS加密特性。</li>
</ul>
<p>基于证书的认证是针对每个gRPC链接的认证。gRPC还为每个gRPC方法调用提供了认证支持，这样就基于用户Token对不同的方法访问进行<strong>权限管理</strong>。</p>
<h2 id="4-6-gRPC和Protobuf扩展"><a href="#4-6-gRPC和Protobuf扩展" class="headerlink" title="4.6 gRPC和Protobuf扩展"></a>4.6 gRPC和Protobuf扩展</h2><h3 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h3><p>第三版的Protobuf移除了第二版的默认值特性，可以为字符串或数值类型的成员定义默认值。</p>
<p>我们采用第二版的Protobuf语法创建文件：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">string</span> name = <span class="number">1</span> [default = <span class="string">&quot;gopher&quot;</span>];</span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">int32</span> age = <span class="number">2</span> [default = <span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内置的默认值语法其实是通过Protobuf的扩展选项特性实现。在第三版的Protobuf中不再支持默认值特性，但是我们可以通过扩展选项自己模拟默认值特性。</p>
<p>下面是用proto3语法的扩展特性重新改写上述的proto文件：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/descriptor.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">extend google.protobuf.FieldOptions &#123;</span><br><span class="line">	<span class="built_in">string</span> default_string = <span class="number">50000</span>;</span><br><span class="line">	<span class="built_in">int32</span> default_int = <span class="number">50001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> name = <span class="number">1</span> [(default_string) = <span class="string">&quot;gopher&quot;</span>];</span><br><span class="line">	<span class="built_in">int32</span> age = <span class="number">2</span>[(default_int) = <span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中成员后面的方括号内部的就是扩展语法。重新生成Go语言代码，里面会包含扩展选项相关的元信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> E_DefaultString = &amp;proto.ExtensionDesc&#123;</span><br><span class="line">	ExtendedType:  (*descriptor.FieldOptions)(<span class="literal">nil</span>),</span><br><span class="line">	ExtensionType: (*<span class="keyword">string</span>)(<span class="literal">nil</span>),</span><br><span class="line">	Field:         <span class="number">50000</span>,</span><br><span class="line">	Name:          <span class="string">&quot;main.default_string&quot;</span>,</span><br><span class="line">	Tag:           <span class="string">&quot;bytes,50000,opt,name=default_string,json=defaultString&quot;</span>,</span><br><span class="line">	Filename:      <span class="string">&quot;helloworld.proto&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> E_DefaultInt = &amp;proto.ExtensionDesc&#123;</span><br><span class="line">	ExtendedType:  (*descriptor.FieldOptions)(<span class="literal">nil</span>),</span><br><span class="line">	ExtensionType: (*<span class="keyword">int32</span>)(<span class="literal">nil</span>),</span><br><span class="line">	Field:         <span class="number">50001</span>,</span><br><span class="line">	Name:          <span class="string">&quot;main.default_int&quot;</span>,</span><br><span class="line">	Tag:           <span class="string">&quot;varint,50001,opt,name=default_int,json=defaultInt&quot;</span>,</span><br><span class="line">	Filename:      <span class="string">&quot;helloworld.proto&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在运行时通过类似反射的技术解析出Message每个成员定义的扩展选项，然后从每个扩展的相关联的信息中解析出我们定义的默认值。</p>
<p>在开源社区中，github.com/mwitkow/go-proto-validators 已经基于Protobuf的扩展特性实现了功能较为强大的验证器功能。要使用该验证器首先需要下载其提供的代码生成插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/mwitkow/go-proto-validators/protoc-gen-govalidators</span><br></pre></td></tr></table></figure>

<p>然后基于go-proto-validators验证器的规则为Message成员增加验证规则：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/mwitkow/go-proto-validators/validator.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> important_string = <span class="number">1</span> [</span><br><span class="line">		(validator.field) = &#123;regex: <span class="string">&quot;^[a-z]&#123;2,5&#125;$&quot;</span>&#125;</span><br><span class="line">	];</span><br><span class="line">	<span class="built_in">int32</span> age = <span class="number">2</span> [</span><br><span class="line">		(validator.field) = &#123;int_gt: <span class="number">0</span>, int_lt: <span class="number">100</span>&#125;</span><br><span class="line">	];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在方括弧表示的成员扩展中，validator.field表示扩展是validator包中定义的名为field扩展选项。validator.field的类型是FieldValidator结构体，在导入的validator.proto文件中定义。</p>
<p>所有的验证规则都由validator.proto文件中的FieldValidator定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> validator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/descriptor.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line">extend google.protobuf.FieldOptions &#123;</span><br><span class="line">	<span class="keyword">optional</span> FieldValidator field = <span class="number">65020</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">FieldValidator</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Uses a Golang RE2-syntax regex to match the field contents.</span></span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">string</span> regex = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// Field value of integer strictly greater than this value.</span></span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">int64</span> int_gt = <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// Field value of integer strictly smaller than this value.</span></span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">int64</span> int_lt = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... more ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从FieldValidator定义的注释中我们可以看到验证器扩展的一些语法：其中regex表示用于字符串验证的正则表达式，int_gt和int_lt表示数值的范围。</p>
<p>然后采用以下的命令生成验证函数代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protoc  \</span><br><span class="line">	--proto_path=$&#123;GOPATH&#125;/src \</span><br><span class="line">	--proto_path=$&#123;GOPATH&#125;/src/github.com/google/protobuf/src \</span><br><span class="line">	--proto_path=. \</span><br><span class="line">	--govalidators_out=. --go_out=plugins=grpc:.\</span><br><span class="line">	hello.proto</span><br></pre></td></tr></table></figure>

<blockquote>
<p>windows:替换 <code>$&#123;GOPATH&#125;</code> 为 <code>%GOPATH%</code> 即可.</p>
</blockquote>
<p>以上的命令会调用protoc-gen-govalidators程序，生成一个独立的名为hello.validator.pb.go的文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _regex_Message_ImportantString = regexp.MustCompile(<span class="string">&quot;^[a-z]&#123;2,5&#125;$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Message)</span> <span class="title">Validate</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !_regex_Message_ImportantString.MatchString(this.ImportantString) &#123;</span><br><span class="line">		<span class="keyword">return</span> go_proto_validators.FieldError(<span class="string">&quot;ImportantString&quot;</span>, fmt.Errorf(</span><br><span class="line">			<span class="string">`value &#x27;%v&#x27; must be a string conforming to regex &quot;^[a-z]&#123;2,5&#125;$&quot;`</span>,</span><br><span class="line">			this.ImportantString,</span><br><span class="line">		))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !(this.Age &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> go_proto_validators.FieldError(<span class="string">&quot;Age&quot;</span>, fmt.Errorf(</span><br><span class="line">			<span class="string">`value &#x27;%v&#x27; must be greater than &#x27;0&#x27;`</span>, this.Age,</span><br><span class="line">		))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !(this.Age &lt; <span class="number">100</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> go_proto_validators.FieldError(<span class="string">&quot;Age&quot;</span>, fmt.Errorf(</span><br><span class="line">			<span class="string">`value &#x27;%v&#x27; must be less than &#x27;100&#x27;`</span>, this.Age,</span><br><span class="line">		))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码为Message结构体增加了一个Validate方法，用于验证该成员是否满足Protobuf中定义的条件约束。无论采用何种类型，所有的Validate方法都用相同的签名，因此可以满足相同的验证接口。</p>
<p>通过生成的验证函数，并结合gRPC的截取器，我们可以很容易为每个方法的输入参数和返回值进行验证。</p>
<h3 id="REST接口"><a href="#REST接口" class="headerlink" title="REST接口"></a>REST接口</h3><p>grpc-gateway的工作原理如下图：</p>
<p><img src="/images/image-20210615213855531.png" alt="image-20210615213855531"></p>
<p><strong>通过在Protobuf文件中添加路由相关的元信息</strong>，通过自定义的代码插件生成路由相关的处理代码，最终将REST请求转给更后端的gRPC服务处理。</p>
<p>路由扩展元信息也是通过Protobuf的元数据扩展用法提供：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/api/annotations.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">StringMessage</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">RestService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> Get(StringMessage) <span class="keyword">returns</span> (StringMessage) </span>&#123;</span><br><span class="line">		<span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">			get: <span class="string">&quot;/get/&#123;value&#125;&quot;</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> Post(StringMessage) <span class="keyword">returns</span> (StringMessage) </span>&#123;</span><br><span class="line">		<span class="keyword">option</span> (google.api.http) = &#123;</span><br><span class="line">			post: <span class="string">&quot;/post&quot;</span></span><br><span class="line">			body: <span class="string">&quot;*&quot;</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先为gRPC定义了Get和Post方法，然后通过元扩展语法在对应的方法后添加路由信息。其中“/get/{value}”路径对应的是Get方法，<code>&#123;value&#125;</code>部分对应参数中的value成员，结果通过json格式返回。Post方法对应“/post”路径，body中包含json格式的请求信息。</p>
<p>然后通过以下命令安装protoc-gen-grpc-gateway插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway</span><br></pre></td></tr></table></figure>

<p>再通过插件生成grpc-gateway必须的路由处理代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ protoc -I/usr/local/include -I. \</span><br><span class="line">	-I$GOPATH/src \</span><br><span class="line">	-I$GOPATH/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis \</span><br><span class="line">	--grpc-gateway_out=. --go_out=plugins=grpc:.\</span><br><span class="line">	hello.proto</span><br></pre></td></tr></table></figure>

<blockquote>
<p>windows:替换 <code>$&#123;GOPATH&#125;</code> 为 <code>%GOPATH%</code> 即可.</p>
</blockquote>
<p>插件会为RestService服务生成对应的RegisterRestServiceHandlerFromEndpoint函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRestServiceHandlerFromEndpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	ctx context.Context, mux *runtime.ServeMux, endpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	opts []grpc.DialOption,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RegisterRestServiceHandlerFromEndpoint函数用于将定义了Rest接口的请求转发到真正的gRPC服务。注册路由处理函数之后就可以启动Web服务了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	mux := runtime.NewServeMux()</span><br><span class="line"></span><br><span class="line">	err := RegisterRestServiceHandlerFromEndpoint(</span><br><span class="line">		ctx, mux, <span class="string">&quot;localhost:5000&quot;</span>,</span><br><span class="line">		[]grpc.DialOption&#123;grpc.WithInsecure()&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动grpc服务 ,端口5000</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RestServiceImpl <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RestServiceImpl)</span> <span class="title">Get</span><span class="params">(ctx context.Context, message *StringMessage)</span> <span class="params">(*StringMessage, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;StringMessage&#123;Value: <span class="string">&quot;Get hi:&quot;</span> + message.Value + <span class="string">&quot;#&quot;</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RestServiceImpl)</span> <span class="title">Post</span><span class="params">(ctx context.Context, message *StringMessage)</span> <span class="params">(*StringMessage, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;StringMessage&#123;Value: <span class="string">&quot;Post hi:&quot;</span> + message.Value + <span class="string">&quot;@&quot;</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	grpcServer := grpc.NewServer()</span><br><span class="line">	RegisterRestServiceServer(grpcServer, <span class="built_in">new</span>(RestServiceImpl))</span><br><span class="line">	lis, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:5000&quot;</span>)</span><br><span class="line">	grpcServer.Serve(lis)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先通过runtime.NewServeMux()函数创建路由处理器，然后通过RegisterRestServiceHandlerFromEndpoint函数将RestService服务相关的REST接口中转到后面的gRPC服务。grpc-gateway提供的runtime.ServeMux类也实现了http.Handler接口，因此可以和标准库中的相关函数配合使用。</p>
<p>当gRPC和REST服务全部启动之后，就可以用curl请求REST服务了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/get/gopher</span><br><span class="line">&#123;&quot;value&quot;:&quot;Get: gopher&quot;&#125;</span><br><span class="line"></span><br><span class="line">$ curl localhost:8080/post -X POST --data &#x27;&#123;&quot;value&quot;:&quot;grpc&quot;&#125;&#x27;</span><br><span class="line">&#123;&quot;value&quot;:&quot;Post: grpc&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>在对外公布REST接口时，我们一般还会提供一个Swagger格式的文件用于描述这个接口规范。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger</span><br><span class="line"></span><br><span class="line">$ protoc -I. \</span><br><span class="line">  -I$GOPATH/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis \</span><br><span class="line">  --swagger_out=. \</span><br><span class="line">  hello.proto</span><br></pre></td></tr></table></figure>

<p>然后会生成一个hello.swagger.json文件。这样的话就可以通过swagger-ui这个项目，在网页中提供REST接口的文档和测试等功能。</p>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>最新的Nginx对gRPC提供了深度支持。可以通过Nginx将后端多个gRPC服务聚合到一个Nginx服务。同时Nginx也提供了为同一种gRPC服务注册多个后端的功能，这样可以轻松实现gRPC负载均衡的支持。</p>
<h1 id="ch5-web"><a href="#ch5-web" class="headerlink" title="ch5-web"></a>ch5-web</h1><p>Go的<code>net/http</code>包写一个简单的<code>http echo server</code>只需要30s：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//brief_intro/echo.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (...)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(wr http.ResponseWriter， r *http.Request)</span></span> &#123;</span><br><span class="line">	msg， err := ioutil.ReadAll(r.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		wr.Write([]<span class="keyword">byte</span>(<span class="string">&quot;echo error&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	writeLen， err := wr.Write(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || writeLen != <span class="built_in">len</span>(msg) &#123;</span><br><span class="line">		log.Println(err， <span class="string">&quot;write len:&quot;</span>， writeLen)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>， echo)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>， <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Go-web开源界有这么几种框架，</p>
<ul>
<li>对httpRouter进行简单的封装，然后提供定制的中间件和一些简单的小工具集成比如gin，主打轻量，易学，高性能。</li>
<li>借鉴其它语言的编程风格的一些MVC类框架，例如beego，方便从其它语言迁移过来的程序员快速上手，快速开发。</li>
<li>还有一些框架功能更为强大，除了数据库schema设计，大部分代码直接生成，例如goa。</li>
</ul>
<h2 id="5-2-router-请求路由"><a href="#5-2-router-请求路由" class="headerlink" title="5.2 router 请求路由"></a>5.2 router 请求路由</h2><h3 id="httprouter原理"><a href="#httprouter原理" class="headerlink" title="httprouter原理"></a>httprouter原理</h3><p>较流行的开源go Web框架大多使用httprouter，或是基于httprouter的变种对路由进行支持。</p>
<p>httprouter和众多衍生router使用的数据结构被称为压缩字典树（Radix Tree）。</p>
<p>普通的字典树有一个明显的缺点，就是每个字母都需要建立一个孩子节点，这样会导致字典树的层数比较深，压缩字典树相对好地平衡了字典树的优点和缺点。是典型的压缩字典树结构：</p>
<p><img src="/images/image-20210617143513244.png" alt="image-20210617143513244"></p>
<p>每个节点上不只存储一个字母了，这也是压缩字典树中“压缩”的主要含义。使用压缩字典树可以减少树的层数，同时因为每个节点上数据存储也比通常的字典树要多，所以程序的局部性较好（一个节点的path加载到cache即可进行多个字符的对比），从而对CPU缓存友好。</p>
<h4 id="压缩字典树创建过程"><a href="#压缩字典树创建过程" class="headerlink" title="压缩字典树创建过程"></a>压缩字典树创建过程</h4><p>我们来跟踪一下httprouter中，一个典型的压缩字典树的创建过程，路由设定如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /user/installations/:installation_id/repositories/:repository_id</span><br><span class="line"></span><br><span class="line">GET /marketplace_listing/plans/</span><br><span class="line">GET /marketplace_listing/plans/:id/accounts</span><br><span class="line">GET /search</span><br><span class="line">GET /status</span><br><span class="line">GET /support</span><br><span class="line"></span><br><span class="line">补充路由：</span><br><span class="line">GET /marketplace_listing/plans/ohyes</span><br></pre></td></tr></table></figure>



<p>httprouter的Router结构体中存储压缩字典树使用的是下述数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略去了其它部分的 Router struct</span></span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	trees <span class="keyword">map</span>[<span class="keyword">string</span>]*node</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>trees</code>中的<code>key</code>即为HTTP 1.1的RFC中定义的各种方法，如<code>GET</code>，<code>POST</code></p>
<p>每一种方法对应的都是一棵独立的压缩字典树，这些树彼此之间不共享数据。具体到我们上面用到的路由，<code>PUT</code>和<code>GET</code>是两棵树而非一棵。</p>
<p>节点类型为<code>*httprouter.node</code>，为了说明方便，我们留下了目前关心的几个字段：</p>
<ul>
<li>path: 当前节点对应的路径中的字符串</li>
<li>wildChild: 子节点是否为参数节点，即 :id 这种类型的节点</li>
<li>nType: 当前节点类型，有四个枚举值:<ul>
<li>static：非根节点的普通字符串节点</li>
<li>root：根节点</li>
<li>param：参数节点，例如 :id</li>
<li>catchAll：通配符节点，例如 *anyway</li>
</ul>
</li>
<li>indices：子节点索引，当子节点为非参数类型，即本节点的wildChild为false时，会将每个子节点的首字母放在该索引数组。说是数组，实际上是个string。</li>
</ul>
<p>简单来讲，某个方法第一次插入的路由就会导致对应字典树的根节点被创建，我们按顺序，先是一个<code>PUT</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r := httprouter.New()</span><br><span class="line">r.PUT(<span class="string">&quot;/user/installations/:installation_id/repositories/:reposit&quot;</span>， Hello)</span><br></pre></td></tr></table></figure>

<p>这样<code>PUT</code>对应的根节点就会被创建出来。把这棵<code>PUT</code>的树画出来：</p>
<p><img src="/images/ch6-02-radix-put.png" alt="put radix tree"></p>
<p>如法炮制，插入<code>/marketplace_listing/plans/</code>，<code>/marketplace_listing/plans/:id/accounts</code>，<code>/search</code></p>
<p><img src="/images/image-20210617150006110.png" alt="image-20210617150006110"></p>
<p>原有路径和新的路径在初始的<code>/</code>位置发生分裂，这样需要把原有的root节点内容下移，再将新路由 <code>search</code>同样作为子节点挂在root节点之下。这时候因为子节点出现多个，<strong>root节点的indices提供子节点索引</strong>，这时候该字段就需要派上用场了。”ms”代表子节点的首字母分别为m（marketplace）和s（search）。</p>
<p>把<code>GET /status</code>和<code>GET /support</code>也插入到树中。这时候会导致在<code>search</code>节点上再次发生分裂，最终结果：</p>
<p><img src="/images/image-20210617150149970.png" alt="image-20210617150149970"></p>
<h4 id="子节点冲突处理"><a href="#子节点冲突处理" class="headerlink" title="子节点冲突处理"></a>子节点冲突处理</h4><p>在路由本身只有字符串的情况下，不会发生任何冲突。只有当路由中含有wildcard（类似 :id）或者catchAll的情况下才可能冲突。</p>
<p>子节点的冲突处理很简单，分几种情况：</p>
<ol>
<li>在插入wildcard节点时，父节点的children数组非空且wildChild被设置为false。例如：<code>GET /user/getAll</code>和<code>GET /user/:id/getAddr</code>，或者<code>GET /user/*aaa</code>和<code>GET /user/:id</code>。</li>
<li>在插入wildcard节点时，父节点的children数组非空且wildChild被设置为true，但该父节点的wildcard子节点要插入的wildcard名字不一样。例如：<code>GET /user/:id/info</code>和<code>GET /user/:name/info</code>。</li>
<li>在插入catchAll节点时，父节点的children非空。例如：<code>GET /src/abc</code>和<code>GET /src/*filename</code>，或者<code>GET /src/:id</code>和<code>GET /src/*filename</code>。</li>
<li>在插入static节点时，父节点的wildChild字段被设置为true。</li>
<li>在插入static节点时，父节点的children非空，且子节点nType为catchAll。</li>
</ol>
<p>只要发生冲突，都会在初始化的时候panic。例如，在插入我们臆想的路由<code>GET /marketplace_listing/plans/ohyes</code>时，出现第4种冲突情况：它的父节点<code>marketplace_listing/plans/</code>的wildChild字段为true。</p>
<h2 id="5-3-中间件"><a href="#5-3-中间件" class="headerlink" title="5.3 中间件"></a>5.3 中间件</h2><p>需求：想要统计hello服务的处理耗时</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger = log.New(os.Stdout, <span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	timeStart := time.Now()</span><br><span class="line">	wr.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">	timeElapsed := time.Since(timeStart)</span><br><span class="line">	logger.Println(timeElapsed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, hello)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码犯的最大的错误，是把<strong>业务代码和非业务代码揉在了一起</strong>。</p>
<p>可以使用一种叫<code>function adapter</code>的方法来对<code>helloHandler()</code>进行包装：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	wr.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件通过包装handler，再返回一个新的handle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeMiddleware</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		timeStart := time.Now()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// next handler</span></span><br><span class="line">		next.ServeHTTP(wr, r)</span><br><span class="line"></span><br><span class="line">		timeElapsed := time.Since(timeStart)</span><br><span class="line">		logger.Println(timeElapsed)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.Handle(<span class="string">&quot;/&quot;</span>, timeMiddleware(http.HandlerFunc(hello)))</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>http.Handler</code>的定义在<code>net/http</code>包中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要你的handler函数签名是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure>

<p>那么这个<code>handler</code>和<code>http.HandlerFunc()</code>就有了一致的函数签名，可以将该<code>handler()</code>函数进行类型转换，转为<code>http.HandlerFunc</code>。</p>
</blockquote>
<h3 id="更优雅的中间件写法"><a href="#更优雅的中间件写法" class="headerlink" title="更优雅的中间件写法"></a>更优雅的中间件写法</h3><p>将</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customizedHandler = logger(timeout(ratelimit(helloHandler)))</span><br></pre></td></tr></table></figure>

<p>优化成下面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = NewRouter()</span><br><span class="line">r.Use(logger)</span><br><span class="line">r.Use(timeout)</span><br><span class="line">r.Use(ratelimit)</span><br><span class="line">r.Add(<span class="string">&quot;/&quot;</span>, helloHandler)</span><br></pre></td></tr></table></figure>

<p>通过多步设置，我们拥有了和上一节差不多的执行函数链。胜在直观易懂，如果我们要增加或者删除中间件，只要简单地增加删除对应的<code>Use()</code>调用就可以了。非常方便。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> middleware <span class="function"><span class="keyword">func</span><span class="params">(http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">	middlewareChain [] middleware</span><br><span class="line">	mux <span class="keyword">map</span>[<span class="keyword">string</span>] http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">Router</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Router&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Use</span><span class="params">(m middleware)</span></span> &#123;</span><br><span class="line">	r.middlewareChain = <span class="built_in">append</span>(r.middlewareChain, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Add</span><span class="params">(route <span class="keyword">string</span>, h http.Handler)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mergedHandler = h</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组遍历顺序和用户希望的调用顺序应该是相反的</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(r.middlewareChain) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		mergedHandler = r.middlewareChain[i](mergedHandler)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.mux[route] = mergedHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-4-validator请求校验"><a href="#5-4-validator请求校验" class="headerlink" title="5.4 validator请求校验"></a>5.4 validator请求校验</h2><p>引入一个新的validator库：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/go-playground/validator">https://github.com/go-playground/validator</a></p>
</blockquote>
<p>使用 <code>go get github.com/go-playground/validator/v10</code> 可以下载 validator 库。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RegisterReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 字符串的 gt=0 表示长度必须 &gt; 0，gt = greater than</span></span><br><span class="line">	Username       <span class="keyword">string</span>   <span class="string">`validate:&quot;gt=0&quot;`</span></span><br><span class="line">	<span class="comment">// 同上</span></span><br><span class="line">	PasswordNew    <span class="keyword">string</span>   <span class="string">`validate:&quot;gt=0&quot;`</span></span><br><span class="line">	<span class="comment">// eqfield 跨字段相等校验</span></span><br><span class="line">	PasswordRepeat <span class="keyword">string</span>   <span class="string">`validate:&quot;eqfield=PasswordNew&quot;`</span></span><br><span class="line">	<span class="comment">// 合法 email 格式校验</span></span><br><span class="line">	Email          <span class="keyword">string</span>   <span class="string">`validate:&quot;email&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validate = validator.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateFunc</span><span class="params">(req RegisterReq)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := validate.Struct(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		doSomething()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用反射</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;regexp&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Nested <span class="keyword">struct</span> &#123;</span><br><span class="line">	Email <span class="keyword">string</span> <span class="string">`validate:&quot;email&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	Age	<span class="keyword">int</span> <span class="string">`validate:&quot;eq=10&quot;`</span></span><br><span class="line">	Nested Nested</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateEmail</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> pass, _ := regexp.MatchString(</span><br><span class="line">		<span class="string">`^([\w\.\_]&#123;2,10&#125;)@(\w&#123;1,&#125;).([a-z]&#123;2,4&#125;)$`</span>, input,</span><br><span class="line">	); pass &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">bool</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	validateResult := <span class="literal">true</span></span><br><span class="line">	errmsg := <span class="string">&quot;success&quot;</span></span><br><span class="line">	vt := reflect.TypeOf(v)</span><br><span class="line">	vv := reflect.ValueOf(v)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vv.NumField(); i++ &#123;</span><br><span class="line">		fieldVal := vv.Field(i)</span><br><span class="line">		tagContent := vt.Field(i).Tag.Get(<span class="string">&quot;validate&quot;</span>)</span><br><span class="line">		k := fieldVal.Kind()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> k &#123;</span><br><span class="line">		<span class="keyword">case</span> reflect.Int:</span><br><span class="line">			val := fieldVal.Int()</span><br><span class="line">			tagValStr := strings.Split(tagContent, <span class="string">&quot;=&quot;</span>)</span><br><span class="line">			tagVal, _ := strconv.ParseInt(tagValStr[<span class="number">1</span>], <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">			<span class="keyword">if</span> val != tagVal &#123;</span><br><span class="line">				errmsg = <span class="string">&quot;validate int failed, tag is: &quot;</span>+ strconv.FormatInt(</span><br><span class="line">					tagVal, <span class="number">10</span>,</span><br><span class="line">				)</span><br><span class="line">				validateResult = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> reflect.String:</span><br><span class="line">			val := fieldVal.String()</span><br><span class="line">			tagValStr := tagContent</span><br><span class="line">			<span class="keyword">switch</span> tagValStr &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;email&quot;</span>:</span><br><span class="line">				nestedResult := validateEmail(val)</span><br><span class="line">				<span class="keyword">if</span> nestedResult == <span class="literal">false</span> &#123;</span><br><span class="line">					errmsg = <span class="string">&quot;validate mail failed, field val is: &quot;</span>+ val</span><br><span class="line">					validateResult = <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">			<span class="comment">// 如果有内嵌的 struct，那么深度优先遍历</span></span><br><span class="line">			<span class="comment">// 就是一个递归过程</span></span><br><span class="line">			valInter := fieldVal.Interface()</span><br><span class="line">			nestedResult, msg := validate(valInter)</span><br><span class="line">			<span class="keyword">if</span> nestedResult == <span class="literal">false</span> &#123;</span><br><span class="line">				validateResult = <span class="literal">false</span></span><br><span class="line">				errmsg = msg</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> validateResult, errmsg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = T&#123;Age: <span class="number">10</span>, Nested: Nested&#123;Email: <span class="string">&quot;abc@abc.com&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">	validateResult, errmsg := validate(a)</span><br><span class="line">	fmt.Println(validateResult, errmsg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-5-Database"><a href="#5-5-Database" class="headerlink" title="5.5 Database"></a>5.5 Database</h2><p>入门使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// db 是一个 sql.DB 类型的对象</span></span><br><span class="line">	<span class="comment">// 该对象线程安全，且内部已包含了一个连接池</span></span><br><span class="line">	<span class="comment">// 连接池的选项可以在 sql.DB 的方法中设置，这里为了简单省略了</span></span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>,</span><br><span class="line">		<span class="string">&quot;user:password@tcp(127.0.0.1:3306)/hello&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		id <span class="keyword">int</span></span><br><span class="line">		name <span class="keyword">string</span></span><br><span class="line">	)</span><br><span class="line">	rows, err := db.Query(<span class="string">&quot;select id, name from users where id = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 必须要把 rows 里的内容读完，或者显式调用 Close() 方法，</span></span><br><span class="line">	<span class="comment">// 否则在 defer 的 rows.Close() 执行之前，连接永远不会释放</span></span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		err := rows.Scan(&amp;id, &amp;name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Println(id, name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = rows.Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现如今，大型的互联网公司核心线上业务都会在代码中把SQL放在显眼的位置提供给DBA评审，举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	getAllByProductIDAndCustomerID = <span class="string">`select * from p_orders where product_id in (:product_id) and customer_id=:customer_id`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetAllByProductIDAndCustomerID</span></span><br><span class="line"><span class="comment">// @param driver_id</span></span><br><span class="line"><span class="comment">// @param rate_date</span></span><br><span class="line"><span class="comment">// @return []Order, error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAllByProductIDAndCustomerID</span><span class="params">(ctx context.Context, productIDs []<span class="keyword">uint64</span>, customerID <span class="keyword">uint64</span>)</span> <span class="params">([]Order, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> orderList []Order</span><br><span class="line"></span><br><span class="line">	params := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">&quot;product_id&quot;</span> : productIDs,</span><br><span class="line">		<span class="string">&quot;customer_id&quot;</span>: customerID,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// getAllByProductIDAndCustomerID 是 const 类型的 sql 字符串</span></span><br><span class="line">	sql, args, err := sqlutil.Named(getAllByProductIDAndCustomerID, params)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = dao.QueryList(ctx, sqldbInstance, sql, args, &amp;orderList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> orderList, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-6-Ratelimit-服务流量限制"><a href="#5-6-Ratelimit-服务流量限制" class="headerlink" title="5.6 Ratelimit 服务流量限制"></a>5.6 Ratelimit 服务流量限制</h2><h3 id="常见的流量限制手段"><a href="#常见的流量限制手段" class="headerlink" title="常见的流量限制手段"></a>常见的流量限制手段</h3><p>流量限制的手段有很多，最常见的：漏桶、令牌桶两种：</p>
<ol>
<li><code>漏桶</code>是指我们有一个一直装满了水的桶，每过固定的一段时间即向外漏一滴水。如果你接到了这滴水，那么你就可以继续服务请求，如果没有接到，那么就需要等待下一滴水。</li>
<li><code>令牌桶</code>则是指匀速向桶中添加令牌，服务请求时需要从桶中获取令牌，令牌的数目可以按照需要消耗的资源进行相应的调整。如果没有令牌，可以选择等待，或者放弃。</li>
</ol>
<p>这两种方法看起来很像，不过还是有区别的。<strong>漏桶流出的速率固定，而令牌桶只要在桶中有令牌，那就可以拿</strong>。也就是说令牌桶是允许一定程度的并发的，比如同一个时刻，有100个用户请求，只要令牌桶中有100个令牌，那么这100个请求全都会放过去。令牌桶在桶中没有令牌的情况下也会退化为漏桶模型。</p>
<p><img src="/images/ch5-token-bucket.png" alt="token bucket"></p>
<p>实际应用中令牌桶应用较为广泛，开源界流行的限流器大多数都是基于令牌桶思想的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucket</span><span class="params">(fillInterval time.Duration, capacity <span class="keyword">int64</span>)</span> *<span class="title">Bucket</span></span></span><br></pre></td></tr></table></figure>

<p>默认的令牌桶，<code>fillInterval</code>指每过多长时间向桶里放一个令牌，<code>capacity</code>是桶的容量，超过桶容量的部分会被直接丢弃。桶初始是满的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucketWithQuantum</span><span class="params">(fillInterval time.Duration, capacity, quantum <span class="keyword">int64</span>)</span> *<span class="title">Bucket</span></span></span><br></pre></td></tr></table></figure>

<p>和普通的<code>NewBucket()</code>的区别是，每次向桶中放令牌时，是放<code>quantum</code>个令牌，而不是一个令牌。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBucketWithRate</span><span class="params">(rate <span class="keyword">float64</span>, capacity <span class="keyword">int64</span>)</span> *<span class="title">Bucket</span></span></span><br></pre></td></tr></table></figure>

<p>这个就有点特殊了，会按照提供的比例，每秒钟填充令牌数。例如<code>capacity</code>是100，而<code>rate</code>是0.1，那么每秒会填充10个令牌。</p>
<p>从桶中获取令牌也提供了几个API：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span> <span class="title">Take</span><span class="params">(count <span class="keyword">int64</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span> <span class="title">TakeAvailable</span><span class="params">(count <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span> <span class="title">TakeMaxDuration</span><span class="params">(count <span class="keyword">int64</span>, maxWait time.Duration)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	time.Duration, <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span> <span class="title">Wait</span><span class="params">(count <span class="keyword">int64</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *Bucket)</span> <span class="title">WaitMaxDuration</span><span class="params">(count <span class="keyword">int64</span>, maxWait time.Duration)</span> <span class="title">bool</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>名称和功能都比较直观，这里就不再赘述了。相比于开源界更为有名的Google的Java工具库Guava中提供的ratelimiter，这个库不支持令牌桶预热，且无法修改初始的令牌容量，所以可能个别极端情况下的需求无法满足。但在明白令牌桶的基本原理之后，如果没办法满足需求，相信你也可以很快对其进行修改并支持自己的业务场景。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>从功能上来看，令牌桶模型就是对全局计数的加减法操作过程，但使用计数需要我们自己加读写锁。如果我们对Go语言已经比较熟悉的话，很容易想到可以用buffered channel来完成简单的加令牌取令牌操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tokenBucket = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity)</span><br></pre></td></tr></table></figure>

<p>每过一段时间向<code>tokenBucket</code>中添加<code>token</code>，如果<code>bucket</code>已经满了，那么直接放弃：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fillInterval = time.Millisecond * <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> capacity = <span class="number">100</span></span><br><span class="line">	<span class="keyword">var</span> tokenBucket = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity)</span><br><span class="line"></span><br><span class="line">	fillToken := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ticker := time.NewTicker(fillInterval)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> tokenBucket &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">				fmt.Println(<span class="string">&quot;current token cnt:&quot;</span>, <span class="built_in">len</span>(tokenBucket), time.Now())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> fillToken()</span><br><span class="line">	time.Sleep(time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">current token cnt: 98 2018-06-16 18:17:50.234556981 +0800 CST m=+0.981524018</span><br><span class="line">current token cnt: 99 2018-06-16 18:17:50.243575354 +0800 CST m=+0.990542391</span><br><span class="line">current token cnt: 100 2018-06-16 18:17:50.254628067 +0800 CST m=+1.001595104</span><br><span class="line">current token cnt: 100 2018-06-16 18:17:50.264537143 +0800 CST m=+1.011504180</span><br><span class="line">current token cnt: 100 2018-06-16 18:17:50.273613018 +0800 CST m=+1.020580055</span><br><span class="line">current token cnt: 100 2018-06-16 18:17:50.2844406 +0800 CST m=+1.031407637</span><br><span class="line">current token cnt: 100 2018-06-16 18:17:50.294528695 +0800 CST m=+1.041495732</span><br><span class="line">current token cnt: 100 2018-06-16 18:17:50.304550145 +0800 CST m=+1.051517182</span><br><span class="line">current token cnt: 100 2018-06-16 18:17:50.313970334 +0800 CST m=+1.060937371</span><br></pre></td></tr></table></figure>

<p>在1s钟的时候刚好填满100个，没有太大的偏差。不过这里可以看到，Go的定时器存在大约0.001s的误差，所以如果令牌桶大小在1000以上的填充可能会有一定的误差。对于一般的服务来说，这一点误差无关紧要。</p>
<p>上面的令牌桶的取令牌操作实现起来也比较简单，简化问题，我们这里只取一个令牌：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TakeAvailable</span><span class="params">(block <span class="keyword">bool</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> takenResult <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">if</span> block &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-tokenBucket:</span><br><span class="line">			takenResult = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-tokenBucket:</span><br><span class="line">			takenResult = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			takenResult = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> takenResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些公司自己造的限流的轮子就是用上面这种方式来实现的，不过如果开源版 ratelimit 也如此的话，那我们也没什么可说的了。现实并不是这样的。</p>
<p>我们来思考一下，令牌桶每隔一段固定的时间向桶中放令牌，如果我们记下上一次放令牌的时间为 t1，和当时的令牌数k1，放令牌的时间间隔为ti，每次向令牌桶中放x个令牌，令牌桶容量为cap。现在如果有人来调用<code>TakeAvailable</code>来取n个令牌，我们将这个时刻记为t2。在t2时刻，令牌桶中理论上应该有多少令牌呢？伪代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cur = k1 + ((t2 - t1)/ti) * x</span><br><span class="line">cur = cur &gt; <span class="built_in">cap</span> ? <span class="built_in">cap</span> : cur</span><br></pre></td></tr></table></figure>

<p>我们用两个时间点的时间差，再结合其它的参数，理论上在取令牌之前就完全可以知道桶里有多少令牌了。那劳心费力地像本小节前面向channel里填充token的操作，理论上是没有必要的。只要在每次<code>Take</code>的时候，再对令牌桶中的token数进行简单计算，就可以得到正确的令牌数。是不是很像<code>惰性求值</code>的感觉？</p>
<p>在得到正确的令牌数之后，再进行实际的<code>Take</code>操作就好，这个<code>Take</code>操作只需要对令牌数进行简单的减法即可，记得加锁以保证并发安全。<code>github.com/juju/ratelimit</code>这个库就是这样做的。</p>
<h2 id="5-7-layout-常见大型-Web-项目分层"><a href="#5-7-layout-常见大型-Web-项目分层" class="headerlink" title="5.7 layout :常见大型 Web 项目分层"></a>5.7 layout :常见大型 Web 项目分层</h2><p>下图是一个前后分离的系统的简易交互图。</p>
<p><img src="/images/image-20210617164159192.png" alt="image-20210617164159192"></p>
<p>对于复杂的项目，一个C和一个M层显然是不够用的，现在比较流行的纯后端API模块一般采用下述划分方法：</p>
<ol>
<li>Controller，服务入口，负责处理路由，参数校验，请求转发。</li>
<li>Logic/Service，逻辑（服务）层，一般是业务逻辑的入口，可以认为从这里开始，所有的请求参数一定是合法的。业务逻辑和业务流程也都在这一层中。常见的设计中会将该层称为 Business Rules。</li>
<li>DAO/Repository，这一层主要负责和数据、存储打交道。将下层存储以更简单的函数、接口形式暴露给 Logic 层来使用。负责数据的持久化工作。</li>
</ol>
<p><img src="/images/image-20210617164558320.png" alt="image-20210617164558320"></p>
<p>划分为CLD三层之后，在C层之前我们可能还需要同时支持多种协议。比如gRPC和http。即除了CLD之外，还需要一个单独的protocol层，负责处理各种交互协议的细节。</p>
<p><img src="/images/image-20210617164736985.png" alt="image-20210617164736985"></p>
<h2 id="5-8-接口和表驱动开发"><a href="#5-8-接口和表驱动开发" class="headerlink" title="5.8 接口和表驱动开发"></a>5.8 接口和表驱动开发</h2><h3 id="业务系统的发展过程"><a href="#业务系统的发展过程" class="headerlink" title="业务系统的发展过程"></a>业务系统的发展过程</h3><p>互联网公司只要可以活过三年，工程方面面临的首要问题就是代码膨胀。</p>
<p>系统的代码膨胀之后，可以<strong>将系统中与业务本身流程无关的部分做拆解和异步化</strong>。</p>
<blockquote>
<p>什么算是业务无关呢，比如一些统计、反作弊、营销发券、价格计算、用户状态更新等等需求。这些需求往往依赖于主流程的数据，但又只是挂在主流程上的旁支，自成体系。</p>
</blockquote>
<p>这时候我们就可以把这些旁支拆解出去，作为独立的系统来部署、开发以及维护。</p>
<ul>
<li>这些旁支流程的时延如若非常敏感，比如用户在界面上点了按钮，需要立刻返回（价格计算、支付），那么需要与主流程系统进行RPC通信，并且在通信失败时，要将结果直接返回给用户。</li>
<li>如果时延不敏感，比如抽奖系统，结果稍后公布的这种，或者非实时的统计类系统，那么就没有必要在主流程里为每一套系统做一套RPC流程。我们只要将下游需要的数据打包成一条消息，传入消息队列，之后的事情与主流程一概无关（当然，与用户的后续交互流程还是要做的）。</li>
</ul>
<h3 id="使用函数封装业务流程"><a href="#使用函数封装业务流程" class="headerlink" title="使用函数封装业务流程"></a>使用函数封装业务流程</h3><p>随着业务发展，单一职责的模块也会变得越来越复杂，这是必然的趋势。一件事情本身变的复杂的话，这时候拆解和异步化就不灵了。我们还是要对事情本身进行一定程度的封装抽象。</p>
<p>最基本的封装过程，我们把相似的行为放在一起，然后打包成一个一个的函数，让自己杂乱无章的代码变成下面这个样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BusinessProcess</span><span class="params">(ctx context.Context, params Params)</span> <span class="params">(resp, error)</span></span>&#123;</span><br><span class="line">	ValidateLogin()</span><br><span class="line">	ValidateParams()</span><br><span class="line">	AntispamCheck()</span><br><span class="line">	GetPrice()</span><br><span class="line">	CreateOrder()</span><br><span class="line">	UpdateUserStatus()</span><br><span class="line">	NotifyDownstreamSystems()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是多么复杂的业务，系统内的逻辑都是可以分解为<code>step1 -&gt; step2 -&gt; step3 ...</code>这样的流程的。</p>
<p>每一个步骤内部也会有复杂的流程，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ValidateDistrict()    <span class="comment">// 判断是否是地区限定商品</span></span><br><span class="line">	ValidateVIPProduct()  <span class="comment">// 检查是否是只提供给 vip 的商品</span></span><br><span class="line">	GetUserInfo()         <span class="comment">// 从用户系统获取更详细的用户信息</span></span><br><span class="line">	GetProductDesc()      <span class="comment">// 从商品系统中获取商品在该时间点的详细信息</span></span><br><span class="line">	DecrementStorage()    <span class="comment">// 扣减库存</span></span><br><span class="line">	CreateOrderSnapshot() <span class="comment">// 创建订单快照</span></span><br><span class="line">	<span class="keyword">return</span> CreateSuccess</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用接口来做抽象"><a href="#使用接口来做抽象" class="headerlink" title="使用接口来做抽象"></a>使用接口来做抽象</h3><p>业务发展的早期，是不适宜引入接口（interface）的，很多时候业务流程变化很大，过早引入接口会使业务系统本身增加很多不必要的分层，从而导致每次修改几乎都要全盘否定之前的工作。</p>
<p>如果我们在开发过程中，已经对业务步骤进行了良好的封装，这时候进行接口抽象化就会变的非常容易，伪代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OrderCreator 创建订单流程</span></span><br><span class="line"><span class="keyword">type</span> OrderCreator <span class="keyword">interface</span> &#123;</span><br><span class="line">	ValidateDistrict()    <span class="comment">// 判断是否是地区限定商品</span></span><br><span class="line">	ValidateVIPProduct()  <span class="comment">// 检查是否是只提供给 vip 的商品</span></span><br><span class="line">	GetUserInfo()         <span class="comment">// 从用户系统获取更详细的用户信息</span></span><br><span class="line">	GetProductDesc()      <span class="comment">// 从商品系统中获取商品在该时间点的详细信息</span></span><br><span class="line">	DecrementStorage()    <span class="comment">// 扣减库存</span></span><br><span class="line">	CreateOrderSnapshot() <span class="comment">// 创建订单快照</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只要把之前写过的步骤函数签名都提到一个接口中，就可以完成抽象了。</p>
<p><img src="/images/image-20210617173824471.png" alt="image-20210617173824471"></p>
<p>在进行抽象之前，我们应该想明白的一点是，引入接口对我们的系统本身是否有意义，这是要按照场景去进行分析的。假如我们的系统只服务一条产品线，并且内部的代码只是针对很具体的场景进行定制化开发，那么引入接口是不会带来任何收益的。</p>
<blockquote>
<p>如果没有接口的话，我们会怎么做？</p>
<p>没错，就是无穷无尽的<code>switch</code>，和没完没了的垃圾代码。引入了接口之后，我们的<code>switch</code>只需要在业务入口做一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sample.com/travelorder&quot;</span></span><br><span class="line">	<span class="string">&quot;sample.com/marketorder&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> businessType &#123;</span><br><span class="line">	<span class="keyword">case</span> TravelBusiness:</span><br><span class="line">		travelorder.CreateOrder()</span><br><span class="line">	<span class="keyword">case</span> MarketBusiness:</span><br><span class="line">		marketorder.CreateOrderForMarket()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;not supported business&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateUser</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> businessType &#123;</span><br><span class="line">	<span class="keyword">case</span> TravelBusiness:</span><br><span class="line">		travelorder.ValidateUserVIP()</span><br><span class="line">	<span class="keyword">case</span> MarketBusiness:</span><br><span class="line">		marketorder.ValidateUserRegistered()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;not supported business&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">switch</span> ...</span><br><span class="line"><span class="keyword">switch</span> ...</span><br><span class="line"><span class="keyword">switch</span> ...</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BusinessInstance <span class="keyword">interface</span> &#123;</span><br><span class="line">	ValidateLogin()</span><br><span class="line">	ValidateParams()</span><br><span class="line">	AntispamCheck()</span><br><span class="line">	GetPrice()</span><br><span class="line">	CreateOrder()</span><br><span class="line">	UpdateUserStatus()</span><br><span class="line">	NotifyDownstreamSystems()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entry</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> bi BusinessInstance</span><br><span class="line">	<span class="keyword">switch</span> businessType &#123;</span><br><span class="line">		<span class="keyword">case</span> TravelBusiness:</span><br><span class="line">			bi = travelorder.New()</span><br><span class="line">		<span class="keyword">case</span> MarketBusiness:</span><br><span class="line">			bi = marketorder.New()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> errors.New(<span class="string">&quot;not supported business&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BusinessProcess</span><span class="params">(bi BusinessInstance)</span></span> &#123;</span><br><span class="line">	bi.ValidateLogin()</span><br><span class="line">	bi.ValidateParams()</span><br><span class="line">	bi.AntispamCheck()</span><br><span class="line">	bi.GetPrice()</span><br><span class="line">	bi.CreateOrder()</span><br><span class="line">	bi.UpdateUserStatus()</span><br><span class="line">	bi.NotifyDownstreamSystems()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="接口的优缺点"><a href="#接口的优缺点" class="headerlink" title="接口的优缺点"></a>接口的优缺点</h3><p>如果接口中没有A模块中定义的数据类型，那B模块中甚至都不用<code>import A</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> log</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetOutput</span><span class="params">(w io.Writer)</span></span> &#123;</span><br><span class="line">	output = w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="表驱动开发"><a href="#表驱动开发" class="headerlink" title="表驱动开发"></a>表驱动开发</h3><p>熟悉开源lint工具的同学应该见到过圈复杂度的说法，在函数中如果有<code>if</code>和<code>switch</code>的话，会使函数的圈复杂度上升，所以有强迫症的同学即使在入口一个函数中有<code>switch</code>，还是想要干掉这个<code>switch</code>，有没有什么办法呢？</p>
<p>当然有，用表驱动的方式来存储我们需要实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entry</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> bi BusinessInstance</span><br><span class="line">	<span class="keyword">switch</span> businessType &#123;</span><br><span class="line">	<span class="keyword">case</span> TravelBusiness:</span><br><span class="line">		bi = travelorder.New()</span><br><span class="line">	<span class="keyword">case</span> MarketBusiness:</span><br><span class="line">		bi = marketorder.New()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;not supported business&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> businessInstanceMap = <span class="keyword">map</span>[<span class="keyword">int</span>]BusinessInstance &#123;</span><br><span class="line">	TravelBusiness : travelorder.New(),</span><br><span class="line">	MarketBusiness : marketorder.New(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entry</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bi := businessInstanceMap[businessType]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表驱动的设计方式，很多设计模式相关的书籍并没有把它作为一种设计模式来讲，但我认为这依然是一种非常重要的帮助我们来简化代码的手段。在日常的开发工作中可以多多思考，哪些不必要的<code>switch case</code>可以用一个字典和一行代码就可以轻松搞定。</p>
<p>当然，表驱动也不是没有缺点，因为需要对输入<code>key</code>计算哈希，在性能敏感的场合，需要多加斟酌。</p>
<h2 id="5-9-灰度发布和-A-B-test"><a href="#5-9-灰度发布和-A-B-test" class="headerlink" title="5.9 灰度发布和 A/B test"></a>5.9 灰度发布和 A/B test</h2><p>互联网系统的灰度发布一般通过两种方式实现：</p>
<ol>
<li>通过分批次部署实现灰度发布</li>
<li>通过业务规则进行灰度发布</li>
</ol>
<p>在对系统的旧功能进行升级迭代时，第一种方式用的比较多。新功能上线时，第二种方式用的比较多。当然，对比较重要的老功能进行较大幅度的修改时，一般也会选择按业务规则来进行发布，因为直接全量开放给所有用户风险实在太大。</p>
<h3 id="通过分批次部署实现灰度发布"><a href="#通过分批次部署实现灰度发布" class="headerlink" title="通过分批次部署实现灰度发布"></a>通过分批次部署实现灰度发布</h3><p>假如服务部署在15个实例（可能是物理机，也可能是容器）上，我们把这15个实例分为四组，按照先后顺序，分别有1-2-4-8台机器，保证每次扩展时大概都是二倍的关系。</p>
<p><img src="/images/ch5-online-group.png" alt="online group"></p>
<blockquote>
<p>为什么要用2倍？这样能够保证我们不管有多少台机器，都不会把组划分得太多。例如1024台机器，也就只需要1-2-4-8-16-32-64-128-256-512部署十次就可以全部部署完毕。</p>
</blockquote>
<p>这样我们上线最开始影响到的用户在整体用户中占的比例也不大，比如1000台机器的服务，我们上线后如果出现问题，也只影响1/1000的用户。如果10组完全平均分，那一上线立刻就会影响1/10的用户，1/10的业务出问题，那可能对于公司来说就已经是一场不可挽回的事故了。</p>
<p>在上线时，最有效的观察手法是查看程序的错误日志，如果较明显的逻辑错误，一般错误日志的滚动速度都会有肉眼可见的增加。这些错误也可以通过metrics一类的系统上报给公司内的监控系统，所以在上线过程中，也可以通过观察监控曲线，来判断是否有异常发生。</p>
<p>如果有异常情况，首先要做的自然就是回滚了。</p>
<h3 id="通过业务规则进行灰度发布"><a href="#通过业务规则进行灰度发布" class="headerlink" title="通过业务规则进行灰度发布"></a>通过业务规则进行灰度发布</h3><p>常见的灰度策略有多种，较为简单的需求，例如我们的策略是要按照千分比来发布，那么我们可以用用户id、手机号、用户设备信息，等等，来生成一个简单的哈希值，然后再求模，用伪代码表示一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pass 3/1000</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passed</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	key := hashFunctions(userID) % <span class="number">1000</span></span><br><span class="line">	<span class="keyword">if</span> key &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="可选规则"><a href="#可选规则" class="headerlink" title="可选规则"></a>可选规则</h4><p>常见的灰度发布系统会有下列规则提供选择：</p>
<ol>
<li>按城市发布</li>
<li>按概率发布</li>
<li>按百分比发布</li>
<li>按白名单发布</li>
<li>按业务线发布</li>
<li>按UA发布(APP、Web、PC)</li>
<li>按分发渠道发布</li>
</ol>
<p>因为和公司的业务相关，所以城市、业务线、UA、分发渠道这些都可能会被直接编码在系统里，不过功能其实大同小异。</p>
<p>按白名单发布比较简单，功能上线时，可能我们希望只有公司内部的员工和测试人员可以访问到新功能，会直接把账号、邮箱写入到白名单，拒绝其它任何账号的访问。</p>
<p>按概率发布则是指实现一个简单的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTrue</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span> according to the rate provided by user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其可以按照用户指定的概率返回<code>true</code>或者<code>false</code>，当然，<code>true</code>的概率加<code>false</code>的概率应该是100%。这个函数不需要任何输入。</p>
<p>按百分比发布，是指实现下面这样的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTrue</span><span class="params">(phone <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> hash of phone matches &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况可以按照指定的百分比，返回对应的<code>true</code>和<code>false</code>，和上面的单纯按照概率的区别是这里我们需要调用方提供给我们一个输入参数，我们以该输入参数作为源来计算哈希，并以哈希后的结果来求模，并返回结果。这样可以保证同一个用户的返回结果多次调用是一致的，在下面这种场景下，必须使用这种结果可预期的灰度算法</p>
<h1 id="ch6-cloud"><a href="#ch6-cloud" class="headerlink" title="ch6-cloud"></a>ch6-cloud</h1><p>详见<a href="../%E7%BD%91%E7%AB%99__%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%AB%99__%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.md">分布式系统</a></p>
<h1 id="附录A：Go语言常见坑"><a href="#附录A：Go语言常见坑" class="headerlink" title="附录A：Go语言常见坑"></a>附录A：Go语言常见坑</h1><p>这里列举的Go语言常见坑都是符合Go语言语法的，可以正常的编译，但是可能是运行结果错误，或者是有资源泄漏的风险。</p>
<h2 id="独占CPU导致其它Goroutine饿死"><a href="#独占CPU导致其它Goroutine饿死" class="headerlink" title="独占CPU导致其它Goroutine饿死"></a>独占CPU导致其它Goroutine饿死</h2><p>Goroutine是协作式抢占调度，Goroutine本身不会主动放弃CPU：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;&#125; <span class="comment">// 占用CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决的方法是在for循环加入runtime.Gosched()调度函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		runtime.Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者是通过阻塞的方式避免CPU占用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">		os.Exit(<span class="number">0</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="不同Goroutine之间不满足顺序一致性内存模型"><a href="#不同Goroutine之间不满足顺序一致性内存模型" class="headerlink" title="不同Goroutine之间不满足顺序一致性内存模型"></a>不同Goroutine之间不满足顺序一致性内存模型</h2><p>因为在不同的Goroutine，main函数中无法保证能打印出<code>hello, world</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决的办法是用显式同步：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	&lt;-done</span><br><span class="line">	<span class="built_in">println</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>msg的写入是在channel发送之前，所以能保证打印<code>hello, world</code></p>
<h2 id="避免在循环内部执行defer语句"><a href="#避免在循环内部执行defer语句" class="headerlink" title="避免在循环内部执行defer语句"></a>避免在循环内部执行defer语句</h2><p>defer在函数退出时才能执行，在for执行defer会导致资源延迟释放：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		f, err := os.Open(<span class="string">&quot;/path/to/file&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决的方法可以在for中构造一个局部函数，在局部函数内部执行defer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			f, err := os.Open(<span class="string">&quot;/path/to/file&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatal(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> f.Close()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="切片会导致整个底层数组被锁定"><a href="#切片会导致整个底层数组被锁定" class="headerlink" title="切片会导致整个底层数组被锁定"></a>切片会导致整个底层数组被锁定</h2><p>切片会导致整个底层数组被锁定，底层数组无法释放内存。如果底层数组较大会对内存产生很大的压力。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	headerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		name := <span class="string">&quot;/path/to/file&quot;</span></span><br><span class="line">		data, err := ioutil.ReadFile(name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		headerMap[name] = data[:<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// do some thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决的方法是将结果克隆一份，这样可以释放底层的数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	headerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		name := <span class="string">&quot;/path/to/file&quot;</span></span><br><span class="line">		data, err := ioutil.ReadFile(name)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		headerMap[name] = <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;&#125;, data[:<span class="number">1</span>]...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// do some thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Goroutine泄露"><a href="#Goroutine泄露" class="headerlink" title="Goroutine泄露"></a>Goroutine泄露</h2><p>Go语言是带内存自动回收的特性，因此内存一般不会泄漏。但是Goroutine确存在泄漏的情况，同时泄漏的Goroutine引用的内存同样无法被回收。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="function"><span class="keyword">func</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">				ch &lt;- i</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; ()</span><br><span class="line">		<span class="keyword">return</span> ch</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">5</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序中后台Goroutine向管道输入自然数序列，main函数中输出序列。但是当break跳出for循环的时候，<strong>后台Goroutine就处于无法被回收的状态了。</strong></p>
<p>我们可以通过context包来避免这个问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	ch := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; ()</span><br><span class="line">		<span class="keyword">return</span> ch</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">5</span> &#123;</span><br><span class="line">			cancel()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当main函数在break跳出循环时，通过调用<code>cancel()</code>来通知后台Goroutine退出，这样就避免了Goroutine的泄漏。</p>
<p>TODO：跳过了ch2-cgo和ch3-asm两个大章节</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>