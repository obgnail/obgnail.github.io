<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第一章-入门&quot;&gt;&lt;a href=&quot;#第一章-入门&quot; class=&quot;headerlink&quot; title=&quot;第一章 入门&quot;&gt;&lt;/a&gt;第一章 入门&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;没有隐式的数值转换，&lt;/li&gt;
&lt;li&gt;没有构造函数和析构函数，&lt;/li&gt;
&lt;li&gt;没有运算符重载，&lt;/li&gt;
&lt;li&gt;没有默认参数，&lt;/li&gt;
&lt;li&gt;没有继承，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没有泛型&lt;/strong&gt;，&lt;/li&gt;
&lt;li&gt;没有异常，&lt;/li&gt;
&lt;li&gt;没有宏，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没有函数修饰&lt;/strong&gt;，&lt;/li&gt;
&lt;li&gt;更没有线程局部存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Go语言的面向对象机制与一般语言不同。它没有类层次结构，甚至可以说没有类；仅仅通过组合（而不是继承）简单的对象来构建复杂的对象。&lt;/li&gt;
&lt;li&gt;方法不仅可以定义在结构体上, 而且可以定义在任何用户自定义的类型上；并且具体类型和抽象类型（接口）之间的关系是隐式的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Go语言的代码通过包（package）组织，&lt;/li&gt;
&lt;li&gt;包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。&lt;/li&gt;
&lt;li&gt;每个源文件都以一条 package 声明语句开始，表示该文件属于哪个包&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;编译器会主动把特定符号后的换行符转换为分号, 因此&lt;strong&gt;换行符添加的位置会影响Go代码的正确解析&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;举个例子, 函数的左括号 &lt;code&gt;&amp;#123;&lt;/code&gt; 必须和 func 函数声明在同一行上, 且位于末尾，不能独占一行，而在表达式 x + y 中，可在 + 后换行，不能在 + 前换行。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>GO语言圣经 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-07-23</div></div></div><div class="container post-header"><h1>GO语言圣经</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">第一章 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C"><span class="toc-number">1.1.</span> <span class="toc-text">查找重复的行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AAURL"><span class="toc-number">1.2.</span> <span class="toc-text">并发获取多个URL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">第二章 程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">new函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.2.</span> <span class="toc-text">&#x3D; 和 :&#x3D; 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">变量的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.4.</span> <span class="toc-text">垃圾回收机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%BB%E6%84%8F%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">刻意区分类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">包和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%85-%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E7%9A%84symbol"><span class="toc-number">2.3.1.</span> <span class="toc-text">导入同一个包 , 不同文件的symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E4%B8%8D%E5%90%8C%E5%8C%85%E7%9A%84symbol"><span class="toc-number">2.3.2.</span> <span class="toc-text">导入不同包的symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.3.</span> <span class="toc-text">包的初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.4.</span> <span class="toc-text">变量作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">第三章 基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unicode"><span class="toc-number">3.3.1.</span> <span class="toc-text">Unicode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%BA%92%E8%BD%AC"><span class="toc-number">3.3.2.</span> <span class="toc-text">编码互转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8Cslice%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.3.</span> <span class="toc-text">字符串和slice转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bytes%E7%9A%84Buffer%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.4.</span> <span class="toc-text">bytes的Buffer类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.5.</span> <span class="toc-text">字符串和数字的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">3.4.</span> <span class="toc-text">常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">无类型常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B8%B8%E9%87%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">使用内置函数初始化常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%B6%E5%9C%B0%E5%9D%80"><span class="toc-number">3.4.3.</span> <span class="toc-text">常量无法获取其地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">第四章 复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%A6%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.1.</span> <span class="toc-text">数组的另类初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.1.2.</span> <span class="toc-text">数组的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5"><span class="toc-number">4.1.3.</span> <span class="toc-text">将数组作为函数参数传入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slice"><span class="toc-number">4.2.</span> <span class="toc-text">Slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#slice%E6%BA%90%E7%A0%81"><span class="toc-number">4.2.1.</span> <span class="toc-text">slice源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%B9%95%E5%90%8E%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.2.</span> <span class="toc-text">slice初始化的幕后操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.3.</span> <span class="toc-text">slice对象的索引和切片操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#append%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.4.</span> <span class="toc-text">append操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.5.</span> <span class="toc-text">copy操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.6.</span> <span class="toc-text">slice内存操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">4.3.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0OrderDict%E5%8A%9F%E8%83%BD"><span class="toc-number">4.3.1.</span> <span class="toc-text">实现OrderDict功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97map"><span class="toc-number">4.3.2.</span> <span class="toc-text">嵌套map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.4.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E6%94%B6%E8%80%85%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BC%9A%E9%9A%90%E5%90%AB%E5%9C%B0%E4%B9%9F%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E6%94%B6%E8%80%85%E6%98%AF%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%B5%8C%E5%A5%97-%E9%80%92%E5%BD%92%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.2.</span> <span class="toc-text">结构体的嵌套(递归数据结构)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E5%BF%85%E9%A1%BB%E5%A4%A7%E5%86%99%E6%89%8D%E8%83%BD%E5%AF%BC%E5%87%BA"><span class="toc-number">4.4.3.</span> <span class="toc-text">结构体的成员必须大写才能导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83"><span class="toc-number">4.4.4.</span> <span class="toc-text">结构体比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E5%92%8C%E5%8C%BF%E5%90%8D%E6%88%90%E5%91%98"><span class="toc-number">4.4.5.</span> <span class="toc-text">结构体嵌入和匿名成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON"><span class="toc-number">4.5.</span> <span class="toc-text">JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">4.5.1.</span> <span class="toc-text">编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81"><span class="toc-number">4.5.2.</span> <span class="toc-text">解码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%92%8CHTML%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.6.</span> <span class="toc-text">文本和HTML模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8bare-return%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.1.</span> <span class="toc-text">使用bare return自动初始化返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF"><span class="toc-number">5.2.</span> <span class="toc-text">错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.1.</span> <span class="toc-text">错误处理策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE%E9%94%99%E8%AF%AF%EF%BC%88EOF%EF%BC%89"><span class="toc-number">5.2.2.</span> <span class="toc-text">文件结尾错误（EOF）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">函数值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%88%96%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.3.1.</span> <span class="toc-text">函数作为函数的参数或函数的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E4%BB%BFpython%E7%9A%84%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">模仿python的函数装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">集中处理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E9%99%B7%E9%98%B1-%E6%8D%95%E8%8E%B7%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">闭包和匿名函数的陷阱(捕获迭代变量)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deferred%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">Deferred函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Panic%E5%BC%82%E5%B8%B8"><span class="toc-number">5.6.</span> <span class="toc-text">Panic异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Recover%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">5.6.1.</span> <span class="toc-text">Recover捕获异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AFnil%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.1.</span> <span class="toc-text">一个包含nil指针的接口不是nil接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-Handler%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.</span> <span class="toc-text">http.Handler接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.3.</span> <span class="toc-text">error接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E8%AF%A2%E9%97%AE%E8%A1%8C%E4%B8%BA"><span class="toc-number">7.4.</span> <span class="toc-text">通过类型断言询问行为</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Goroutines%E5%92%8CChannels"><span class="toc-number">8.</span> <span class="toc-text">Goroutines和Channels</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84Channels"><span class="toc-number">8.1.</span> <span class="toc-text">不带缓存的Channels</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%81%94%E7%9A%84Channels%EF%BC%88Pipeline%EF%BC%89"><span class="toc-number">8.1.1.</span> <span class="toc-text">串联的Channels（Pipeline）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84Channels"><span class="toc-number">8.2.</span> <span class="toc-text">带缓存的Channels</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine%E6%B3%84%E6%BC%8F"><span class="toc-number">8.2.1.</span> <span class="toc-text">goroutine泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AD%97%E5%85%B8%E9%81%8D%E5%8E%86"><span class="toc-number">8.3.</span> <span class="toc-text">并发的字典遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E5%B9%B6%E5%8F%91%E5%8A%A0%E5%85%A5%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%8A%9F%E8%83%BD"><span class="toc-number">8.3.1.</span> <span class="toc-text">Go 并发加入进度条功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9Agoroutine%E5%85%B1%E7%94%A8channel%E5%B9%B6%E5%85%B3%E9%97%AD"><span class="toc-number">8.3.2.</span> <span class="toc-text">多goroutine共用channel并关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine%E7%9A%84%E9%80%80%E5%87%BA"><span class="toc-number">8.3.3.</span> <span class="toc-text">goroutine的退出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="toc-number">9.</span> <span class="toc-text">基于共享变量的并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8channel%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">9.1.</span> <span class="toc-text">使用channel实现互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#golang%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">9.2.</span> <span class="toc-text">golang不支持可重入锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="toc-number">9.3.</span> <span class="toc-text">内存同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BC%93%E5%AD%98"><span class="toc-number">9.4.</span> <span class="toc-text">并发的非阻塞缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.5.</span> <span class="toc-text">Goroutines和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine%E6%B2%A1%E6%9C%89ID%E5%8F%B7"><span class="toc-number">9.5.1.</span> <span class="toc-text">Goroutine没有ID号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-number">10.</span> <span class="toc-text">包和工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%8C%85"><span class="toc-number">10.1.</span> <span class="toc-text">内部包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">11.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-number">11.1.</span> <span class="toc-text">基准测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">12.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BC%96%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">底层编程</span></a></li></ol></details></div><div class="container post-content"><h1 id="第一章-入门"><a href="#第一章-入门" class="headerlink" title="第一章 入门"></a>第一章 入门</h1><ul>
<li>没有隐式的数值转换，</li>
<li>没有构造函数和析构函数，</li>
<li>没有运算符重载，</li>
<li>没有默认参数，</li>
<li>没有继承，</li>
<li><strong>没有泛型</strong>，</li>
<li>没有异常，</li>
<li>没有宏，</li>
<li><strong>没有函数修饰</strong>，</li>
<li>更没有线程局部存储。</li>
</ul>
<ul>
<li>Go语言的面向对象机制与一般语言不同。它没有类层次结构，甚至可以说没有类；仅仅通过组合（而不是继承）简单的对象来构建复杂的对象。</li>
<li>方法不仅可以定义在结构体上, 而且可以定义在任何用户自定义的类型上；并且具体类型和抽象类型（接口）之间的关系是隐式的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。</li>
</ul>
<ul>
<li>Go语言的代码通过包（package）组织，</li>
<li>包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。</li>
<li>每个源文件都以一条 package 声明语句开始，表示该文件属于哪个包</li>
</ul>
<ul>
<li>编译器会主动把特定符号后的换行符转换为分号, 因此<strong>换行符添加的位置会影响Go代码的正确解析</strong></li>
<li>举个例子, 函数的左括号 <code>&#123;</code> 必须和 func 函数声明在同一行上, 且位于末尾，不能独占一行，而在表达式 x + y 中，可在 + 后换行，不能在 + 前换行。</li>
</ul>
<blockquote>
<p>初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。</p>
</blockquote>
<h2 id="查找重复的行"><a href="#查找重复的行" class="headerlink" title="查找重复的行"></a>查找重复的行</h2><p>要善用<strong>变量初始化是隐式赋值</strong>的特点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	m[<span class="string">&quot;heyingliang&quot;</span>]++</span><br><span class="line">	fmt.Println(m) <span class="comment">// map[heyingliang:1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="并发获取多个URL"><a href="#并发获取多个URL" class="headerlink" title="并发获取多个URL"></a>并发获取多个URL</h2><ul>
<li><strong>main函数本身也运行在一个goroutine中</strong>，</li>
<li>而go function则表示创建一个新的goroutine，并在 这个新的goroutine中执行这个函数。</li>
</ul>
<h1 id="第二章-程序结构"><a href="#第二章-程序结构" class="headerlink" title="第二章 程序结构"></a>第二章 程序结构</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>包本身的名字一般总是用小写字母。</p>
</li>
<li><p>Go语言主要有四种类型的声明语句：var、const、type和func , 分别对应变量、常量、类型和函数</p>
</li>
<li><p>简短变量声明语句中必须<strong>至少要声明一个新的变量</strong>，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码将不能编译通过：</span></span><br><span class="line">f, err := os.Open(infile)</span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// compile error: no new variables</span></span><br><span class="line"><span class="comment">// 解决方法是第二个改用</span></span><br><span class="line"><span class="keyword">var</span> f ,err = os.Create(outfile)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码可以通过编译:</span></span><br><span class="line"><span class="comment">// 这种情况下 , err会被重新赋值</span></span><br><span class="line">in, err := os.Open(infile)</span><br><span class="line">out, err := os.Create(outfile)</span><br></pre></td></tr></table></figure></li>
<li><p>指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line">fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="literal">nil</span>) <span class="comment">// &quot;true false false&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>*p++</code> : 只是增加p指向的变量的值，并不改变p指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(p *<span class="keyword">int</span>)</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">	*p++ <span class="comment">// 非常重要：只是增加p指向的变量的值，并不改变p指针！！！</span></span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := <span class="number">1</span></span><br><span class="line">	fmt.Println(&amp;v) <span class="comment">// 0xc0000120b0</span></span><br><span class="line"></span><br><span class="line">	a := incr(&amp;v)</span><br><span class="line">	<span class="comment">// 并没有改变指针 , 但是指针指向的变量 的值改变了</span></span><br><span class="line">	fmt.Println(a, *a) <span class="comment">// 0xc0000120b0 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><ul>
<li>另一个<strong>创建变量</strong>的方法是调用用内建的new函数。</li>
<li>new函数自动初始化 , 返回值是<code>指针</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">	fmt.Println(v, *v) <span class="comment">// 0xc0000120b0 0</span></span><br><span class="line">	*v = <span class="number">2</span></span><br><span class="line">	fmt.Println(*v) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="= 和 := 的区别"></a>= 和 := 的区别</h3><ul>
<li>= 是<code>赋值</code>， := 是<code>声明</code>变量并<code>赋值</code>。</li>
<li>注意 : := 必须至少声明一个<strong>新</strong>变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码将不能编译通过：</span></span><br><span class="line">f, err := os.Open(infile)</span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// compile error: no new variables</span></span><br><span class="line"><span class="comment">// 解决方法是第二个改用</span></span><br><span class="line"><span class="keyword">var</span> f ,err = os.Create(outfile)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码可以通过编译:</span></span><br><span class="line"><span class="comment">// 这种情况下 , err会被重新赋值</span></span><br><span class="line">in, err := os.Open(infile)</span><br><span class="line">out, err := os.Create(outfile)</span><br></pre></td></tr></table></figure>



<h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><ul>
<li>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。</li>
<li>对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。</li>
<li>局部变量的生命周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后<br>变量的存储空间可能被回收。</li>
<li>函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</li>
</ul>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><ul>
<li>从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</li>
<li>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="刻意区分类型"><a href="#刻意区分类型" class="headerlink" title="刻意区分类型"></a>刻意区分类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AbsoluteZeroC Celsius = <span class="number">-273.15</span></span><br><span class="line">	FreezingC     Celsius = <span class="number">0</span></span><br><span class="line">	BoilingC      Celsius = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span> <span class="title">Fahrenheit</span></span> &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span> <span class="title">Celsius</span></span> &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>) &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。</li>
<li>Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。<strong>类型转换不会改变值本身，但是会使它们的语义发生变化</strong>。</li>
</ul>
<h2 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h2><ul>
<li><strong>一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中</strong>，通常一个包所在目录路径的后缀是包的导入路径</li>
<li>每个包都对应一个独立的名字空间。</li>
<li>按照惯例，包的名字和包的导入路径的最后一个字段相同，例如gopl.io/ch2/tempconv包的名字一般是tempconv。</li>
<li>如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。</li>
</ul>
<h3 id="导入同一个包-不同文件的symbol"><a href="#导入同一个包-不同文件的symbol" class="headerlink" title="导入同一个包 , 不同文件的symbol"></a>导入同一个包 , 不同文件的symbol</h3><p>目录如下 :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">    |-- aaa.<span class="keyword">go</span></span><br><span class="line">    |-- bbb.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bbb.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Test()</span><br><span class="line">	fmt.Println(<span class="string">&quot;2123123&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行的时候不能认为你去跑main然后IDE会将你需要的所有文件都编译，所以这个时候我们需要动手改下命令行来运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run aaa.go bbb.go</span><br></pre></td></tr></table></figure>



<h3 id="导入不同包的symbol"><a href="#导入不同包的symbol" class="headerlink" title="导入不同包的symbol"></a>导入不同包的symbol</h3><p>目录如下 :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">    |-- cf</span><br><span class="line">        |-- aaa.<span class="keyword">go</span></span><br><span class="line">    |-- utils</span><br><span class="line">        |-- bbb.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bbb.go</span></span><br><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStudent <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;hello/utils&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	s := utils.MyStudent&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h3><ul>
<li><p>python是解释性语言 , 因此是逐行执行的 . 但是go不一样, go在编译的时候可能会将代码的执行顺序进行调整</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">// a 第三个初始化, 为 3</span></span><br><span class="line"><span class="keyword">var</span> b = f()   <span class="comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span>     <span class="comment">// c 第一个初始化, 为 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span>  &#123; <span class="keyword">return</span> c + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a, b, c) <span class="comment">// 3 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件<strong>根据文件名排序</strong>，然后依次调用编译器编译。</p>
</li>
<li><p>对于在<code>包级别</code>声明的变量，</p>
<ul>
<li><p>如果有初始化表达式则用表达式初始化，</p>
</li>
<li><p>还有一些没有初始化表达式的，可以用一个特殊的<code>init初始化函数</code>来简化初始化工作。</p>
</li>
<li><p>每个文件都可以包含多个init初始化函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</p>
</li>
</ul>
</li>
<li><p>GO的<code>包的初始化</code>工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之<br>前，所有依然的包都已经完成初始化工作了。</p>
</li>
<li><p>举例 :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> popcount</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="keyword">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">		pc[i] = pc[i/<span class="number">2</span>] + <span class="keyword">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 , 当其他包导入这个popcount包的时候 , pc已经初始化数据了</p>
<p>当然 , 也可以<strong>通过将初始化逻辑包装为一个匿名函数处理</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="keyword">byte</span> = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(pc [256]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">		pc[i] = pc[i/<span class="number">2</span>] + <span class="keyword">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li>
<li><p>举例2:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Name <span class="keyword">string</span> = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;heyl&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello/utils&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(utils.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>举例3:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hello/utils&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(utils.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Name, _ := myfunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;678&quot;</span>, <span class="string">&quot;qwe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面utils的代码是行不通的 , 因为<code>:=</code> 是短变量<code>声明</code> , 在init()里面声明了一个新的Name . 而我们需要的是使用init()给Name<code>赋值</code></p>
<p>所以 , 解决方法就是<code>Name, _ := myfunc()</code> 改成 <code>Name, _ = myfunc()</code> , 将短变量声明 改成 赋值</p>
</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul>
<li><p><strong>声明语句的作用域是指源代码中可以有效使用这个名字的范围</strong>。</p>
</li>
<li><p>不要将作用域和生命周期混为一谈。</p>
<ul>
<li>声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。</li>
<li>一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</li>
</ul>
</li>
<li><p>对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。</p>
</li>
<li><p>注意下面代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> char = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	char = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(char) <span class="comment">// 1</span></span><br><span class="line">	myfunc()</span><br><span class="line">	fmt.Println(char) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python采用<code>LEGB</code>原则 , 函数内部是无法修改全局变量的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># 1</span></span><br><span class="line">func()  </span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="第三章-基础数据类型"><a href="#第三章-基础数据类型" class="headerlink" title="第三章 基础数据类型"></a>第三章 基础数据类型</h1><p>Go语言将数据类型分为四类：</p>
<ul>
<li>基础类型 : 数字、字符串、布尔型</li>
<li>复合类型 : 数组、结构体</li>
<li>引用类型 : 指针、切片、字典、函数、通道</li>
<li>接口类型 : interface</li>
</ul>
<blockquote>
<p>对<code>引用类型</code>数据的修改都会影响所有该引用的拷贝</p>
</blockquote>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><ul>
<li>Unicode字符rune类型是和int32等价的类型，通常用于表示一个<code>Unicode码点</code>。</li>
<li>byte也是uint8类型的等价类型，byte类型一般用于强调<strong>数值是一个原始的数据</strong>而不是一个小整数。</li>
<li>无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程是才需要</li>
</ul>
<ul>
<li><p>在Go语言中，<code>%</code>取模运算符的符号和被取模数的符号总是一致的，因此 -5%3 和 -5%-3 结果都是-2</p>
</li>
<li><p>除法运算符 <code>/ </code>的行为则依赖于操作数<strong>是否为全为整数</strong>，比如 5.0/4.0 的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。</p>
</li>
<li><p>如果一个算术运算的结果，不管是有符号或者是无符号的，如果需要更多的bit位才能正确表示的话，就说明计算结果是溢出了。<strong>超出的高位的bit位部分将被丢弃</strong>。如果原始的数值是有符号类型，而且最左边的bit为是1的话，那么最终结果可能是负的，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u <span class="keyword">uint8</span> = <span class="number">255</span></span><br><span class="line">fmt.Println(u, u+<span class="number">1</span>, u*u) <span class="comment">// &quot;255 0 1&quot;</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line">fmt.Println(i, i+<span class="number">1</span>, i*i) <span class="comment">// &quot;127 -128 1&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>无符号数往往只有在位运算或其它特殊的运算场景才会使用</p>
</li>
<li><p>许多整形数之间的相互转换并不会改变数值；它们<strong>只是告诉编译器如何解释这个值</strong>。但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度</p>
</li>
</ul>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1).</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float64</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z) <span class="comment">// &quot;0 -0 +Inf -Inf NaN&quot;</span></span><br></pre></td></tr></table></figure>



<p>和JavaScript一样 , <code>math.NaN</code>和任何数值都不相等 , 要使用<code>math.isNaN()</code>判断</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>文本字符串通常被解释为<strong>采用UTF8编码的Unicode码点（rune）序列</strong></p>
</li>
<li><p><strong>内置的len函数可以返回一个字符串中的字节数目</strong>（不是rune字符数目），如果试图访问超出字符串索引范围的字节将会导致panic异常</p>
</li>
<li><p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;L&#x27;</span> <span class="comment">// compile error: cannot assign to s[0]</span></span><br></pre></td></tr></table></figure></li>
<li><p>不变性使得字符串在很多情况下没有必要分配内存 :</p>
<ul>
<li><p><strong>两个字符串共享相同的底层数据的话是安全的</strong> , 这使得复制任何长度的字符串代价是低廉的。</p>
</li>
<li><p><strong>字符串的切片操作也可以共享内存</strong> . 因此字符串切片操作代价也是低廉的。</p>
<p><img src="/images/1589291795332.png" alt="1589291795332"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><ul>
<li><p>用Unicode（ <a target="_blank" rel="noopener" href="http://unicode.org/">http://unicode.org</a> ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型</p>
</li>
<li><p>我们可以将一个符文序列表示为一个int32序列。这种编码方式叫<code>UTF-32</code>，每个Unicode码点都使用同样的大小32bit来表示。这种方式比较简单统一，但是它会浪费很多存储空间</p>
</li>
<li><p>UTF8是一个将Unicode码点编码为字节序列的变长编码。每个符号编码后<strong>第一个字节的高端bit位用于表示总共有多少编码个字节</strong></p>
<ul>
<li>如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统<br>的ASCII编码兼容。</li>
<li>如果第一个字节的高端bit是110，则说明需要2个字节；</li>
<li>后续的每个高端bit都以10开头。更大的Unicode码点也是采用类似的策略处理。</li>
</ul>
<table>
<thead>
<tr>
<th>Unicode</th>
<th>Utf-8</th>
</tr>
</thead>
<tbody><tr>
<td>000000-00007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>000080-0007FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>000800-00FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>010000-10FFFF</td>
<td>11110xxx10xxxxxx10xxxxxx10xxxxxx</td>
</tr>
</tbody></table>
</li>
<li><p>UTF8是一个前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看。像GBK之类的编码，如果不知道起点位置则可能会出现歧义。<strong>没有任何字符的编码是其它字符编码的子串</strong>，或是其它编码序列的字串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰。</p>
</li>
<li><p><code>�</code> : 说明程序遇到一个错误的UTF8编码输入</p>
</li>
</ul>
<h3 id="编码互转"><a href="#编码互转" class="headerlink" title="编码互转"></a>编码互转</h3><p>UTF8编码转为Unicode字符 : </p>
<p><strong>Go语言的源文件采用UTF8编码</strong> , 使用[]rune的类型转换，可以将一个UTF8编码的字符串<strong>解码为Unicode字符</strong>序列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;プログラム&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;% x\n&quot;</span>, s) <span class="comment">// &quot;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&quot;</span></span><br><span class="line">r := []<span class="keyword">rune</span>(s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, r) <span class="comment">// &quot;[30d7 30ed 30b0 30e9 30e0]&quot;</span></span><br></pre></td></tr></table></figure>



<p>Unicode字符转为UTF8编码 :</p>
<p>将一个<code>[]rune</code>类型的Unicode字符slice或数组转为string类型，则对它们进行UTF8编码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="keyword">string</span>(r)) <span class="comment">// &quot;プログラム&quot;</span></span><br></pre></td></tr></table></figure>



<p>整数转为UTF8编码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="keyword">string</span>(<span class="number">65</span>)) <span class="comment">// &quot;A&quot;, not &quot;65&quot;</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(<span class="number">0x4eac</span>)) <span class="comment">// &quot;京&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串和slice转换"><a href="#字符串和slice转换" class="headerlink" title="字符串和slice转换"></a>字符串和slice转换</h3><p>字符串和字节slice之间可以相互转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line">s2 := <span class="keyword">string</span>(b)</span><br></pre></td></tr></table></figure>

<ul>
<li>一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。</li>
<li>将一个字节slice转到字符串的string(b)操作则是<strong>构造一个字符串</strong>拷贝，以确保s2字符串是只读的。</li>
</ul>
<h3 id="bytes的Buffer类型"><a href="#bytes的Buffer类型" class="headerlink" title="bytes的Buffer类型"></a>bytes的Buffer类型</h3><ul>
<li>bytes包提供了Buffer类型用于<strong>字节slice的缓存</strong>。</li>
<li>一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要处理化，因为零值也是有效的</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intsToString</span><span class="params">(values []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">			buf.WriteString(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	buf.WriteByte(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(intsToString([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)) <span class="comment">// &quot;[1, 2, 3]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符串和数字的转换"><a href="#字符串和数字的转换" class="headerlink" title="字符串和数字的转换"></a>字符串和数字的转换</h3><p>将一个整数转为字符串，</p>
<ul>
<li>一种方法是用fmt.Sprintf返回一个格式化的字符串；</li>
<li>另一个方法是用<code>strconv.Itoa(“整数到ASCII”)</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">123</span></span><br><span class="line">y := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">fmt.Println(y, strconv.Itoa(x)) <span class="comment">// &quot;123 123&quot;</span></span><br></pre></td></tr></table></figure>



<p><code>FormatInt</code>和<code>FormatUint</code>函数 : 进制转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strconv.FormatInt(<span class="keyword">int64</span>(x), <span class="number">2</span>)) <span class="comment">// &quot;1111011&quot;</span></span><br></pre></td></tr></table></figure>



<p>将字符串转为整数</p>
<ul>
<li>使用strconv包的Atoi或ParseInt函数</li>
<li>ParseUint函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>) <span class="comment">// x is an int</span></span><br><span class="line">y, err := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// base 10, up to 64 bits</span></span><br><span class="line"><span class="comment">// ParseInt函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int</span></span><br></pre></td></tr></table></figure>



<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><ul>
<li><p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意有一个确定的基础类型，例如int或float64，或者是<strong>类似time.Duration这样命名的基础类型</strong>，但是许多常量并没有一个明确的基础类型。</p>
</li>
<li><p>在Go中只有常量才可以是无类型的 , 编译器为这些没有明确的基础类型的数字常量提供比基础类型<strong>更高精度</strong>的算术运算；</p>
</li>
<li><p>六种未明确类型的常量类型，分别是</p>
<ul>
<li>无类型的布尔型、</li>
<li>无类型的整数、</li>
<li>无类型的字符、</li>
<li>无类型的浮点数、</li>
<li>无类型的复数、</li>
<li>无类型的字符串。</li>
</ul>
</li>
<li><p>借助<strong>推迟确定从属类型，无类型常量不仅能够暂时维持更高的精度</strong>，与类型已确定的常量相比，还能写进更多的表达式无需类型转换。</p>
</li>
<li><p>如果将无类型的常量声明为变量或者在类型明确的变量赋值的右方出现无类型的常量，则常量会被<strong>隐式转换</strong>为该变量的类型</p>
</li>
<li><p>示例 : </p>
<p>ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	_ = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	KiB <span class="comment">// 1024</span></span><br><span class="line">	MiB <span class="comment">// 1048576</span></span><br><span class="line">	GiB <span class="comment">// 1073741824</span></span><br><span class="line">	TiB <span class="comment">// 1099511627776 (超出 1 &lt;&lt; 32)</span></span><br><span class="line">	PiB <span class="comment">// 1125899906842624</span></span><br><span class="line">	EiB <span class="comment">// 1152921504606846976</span></span><br><span class="line">	ZiB <span class="comment">// 1180591620717411303424 (超出 1 &lt;&lt; 64)</span></span><br><span class="line">	YiB <span class="comment">// 1208925819614629174706176</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用内置函数初始化常量"><a href="#使用内置函数初始化常量" class="headerlink" title="使用内置函数初始化常量"></a>使用内置函数初始化常量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;heyingliang&quot;</span></span><br><span class="line"><span class="keyword">const</span> l = <span class="built_in">len</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(l) <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码为什么执行成功 : </p>
<ul>
<li>常量操作数，所有数学运算、逻辑运算和比较运算的结果依然是<code>常量</code></li>
<li>常量的类型转换结果和某些内置函数的<code>返回值</code>，例如<code>len,cap,real,imag,complex,unsafe.Sizeof</code>同样是常量。</li>
</ul>
<blockquote>
<p>也就是说 , 这些<strong>函数在编译的时候就能知道结果</strong></p>
</blockquote>
<h3 id="常量无法获取其地址"><a href="#常量无法获取其地址" class="headerlink" title="常量无法获取其地址"></a>常量无法获取其地址</h3><p>数字常量在预处理阶段<code>直接展开</code>，作为指令数据使用，不分配内存，因此无法获取地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;heyingliang&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(&amp;name) <span class="comment">// error:cannot take the address of name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>直接展开</code>是什么意思</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">100</span>    <span class="comment">//x没有明确指定类型，也就是前面说的待定类型</span></span><br><span class="line"><span class="keyword">const</span> y <span class="keyword">byte</span> = x <span class="comment">//直接展开x，相当于const y byte = 100</span></span><br></pre></td></tr></table></figure>

<p>也就是说 <code>const y byte = x</code> 在编译时就被视为<code>const y byte = 100</code></p>
</blockquote>
<h1 id="第四章-复合数据类型"><a href="#第四章-复合数据类型" class="headerlink" title="第四章 复合数据类型"></a>第四章 复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组的长度必须是常量表达式，因为<strong>数组的长度需要在编译阶段确定</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">q = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="comment">// compile error: cannot assign [4]int to [3]int</span></span><br></pre></td></tr></table></figure>



<h3 id="数组的另类初始化"><a href="#数组的另类初始化" class="headerlink" title="数组的另类初始化"></a>数组的另类初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般初始化</span></span><br><span class="line">symbol := [...]<span class="keyword">string</span>&#123;<span class="string">&quot;$&quot;</span>, <span class="string">&quot;€&quot;</span>, <span class="string">&quot;￡&quot;</span>, <span class="string">&quot;￥&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另类初始化</span></span><br><span class="line">symbol := [...]<span class="keyword">string</span>&#123;<span class="number">10</span>: <span class="string">&quot;8&quot;</span>, <span class="number">0</span>: <span class="string">&quot;0&quot;</span>, <span class="number">1</span>: <span class="string">&quot;$&quot;</span>, <span class="number">2</span>: <span class="string">&quot;€&quot;</span>, <span class="number">4</span>: <span class="string">&quot;￡&quot;</span>, <span class="number">3</span>: <span class="string">&quot;￥&quot;</span>&#125;</span><br><span class="line">fmt.Println(symbol) <span class="comment">// [0 $ € ￥ ￡      8]</span></span><br><span class="line">fmt.Println(symbol[<span class="number">10</span>]) <span class="comment">//8</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(symbol)) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>类似于python中的<code>关键字参数</code> , 这里的关键字就是<code>索引index</code></p>
<p>所以 , 有如下的快速定义数组的方法 :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</span></span><br><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组的比较"><a href="#数组的比较" class="headerlink" title="数组的比较"></a>数组的比较</h3><p>数组只要在<strong>长度一样</strong>且<strong>元素类型一致</strong>的情况下才可以比较 , 否则就会编译错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr1 := [...]<span class="keyword">string</span>&#123;<span class="string">&quot;q&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;e&quot;</span>&#125;</span><br><span class="line">	arr2 := [...]<span class="keyword">string</span>&#123;<span class="string">&quot;q&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">	arr3 := [...]<span class="keyword">string</span>&#123;<span class="string">&quot;q&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">	arr4 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(arr1 == arr4) <span class="comment">// error : mismatched types [3]string and [3]int</span></span><br><span class="line">	fmt.Println(arr1 == arr2) <span class="comment">//false</span></span><br><span class="line">	fmt.Println(arr1 == arr3) <span class="comment">// error : mismatched types [3]string and [4]string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="将数组作为函数参数传入"><a href="#将数组作为函数参数传入" class="headerlink" title="将数组作为函数参数传入"></a>将数组作为函数参数传入</h3><ul>
<li>当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的<strong>副本</strong>，并不是原始调用的变量。</li>
<li>因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。</li>
<li>在这个方面，Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。GO是<strong>显式地传入一个数组指针</strong>，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。</li>
<li>数组很少用作函数参数；相反，我们一般使用slice来替代数组。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ptr &#123;</span><br><span class="line">        ptr[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><ul>
<li><strong>切片是一个数组片段的描述</strong>。slice的底层引<strong>用一个数组对象</strong></li>
<li>一个slice由三个部分构成：<code>指针</code>、<code>长度</code>和<code>容量</code>。<ul>
<li><strong>指针指向第一个slice元素对应的底层数组元素的地址</strong> , </li>
<li>长度对应slice中元素的数目；长度不能超过容量，</li>
<li>容量一般是从slice的开始位置到底层数据的结尾位置。</li>
</ul>
</li>
<li>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。</li>
</ul>
<p><img src="/images/1589339800937.png" alt="1589339800937"></p>
<h3 id="slice源码"><a href="#slice源码" class="headerlink" title="slice源码"></a>slice源码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// 元素指针</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>元素指针</code>，指向底层数组 , 可以使用这个指针操作底层的数组(可以修改底层数组) , 也就是说 : 可以通过指向底层数据的指针，可以改变切片的底层数据</p>
</blockquote>
<h3 id="slice初始化的幕后操作"><a href="#slice初始化的幕后操作" class="headerlink" title="slice初始化的幕后操作"></a>slice初始化的幕后操作</h3><p>当我们使用字面量 <code>[]int&#123;1, 2, 3&#125;</code> 创建新的切片时，<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/f07059d949057f414dd0f8303f93ca727d716c62/src/cmd/compile/internal/gc/sinit.go#L595-L766"><code>cmd/compile/internal/gc.slicelit</code></a> 函数会在编译期间将它展开成如下所示的代码片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vstat [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">vstat[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">vstat[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">vstat[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> vauto *[<span class="number">3</span>]<span class="keyword">int</span> = <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">*vauto = vstat</span><br><span class="line">slice := vauto[:] </span><br></pre></td></tr></table></figure>

<ol>
<li>根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</li>
<li>将这些字面量元素存储到初始化的数组中；</li>
<li>创建一个同样指向 <code>[3]int</code> 类型的<code>数组指针</code>；</li>
<li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址；</li>
<li>通过 <code>[:]</code> 操作获取一个底层使用 <code>vauto</code> 的切片；</li>
</ol>
<h3 id="slice对象的索引和切片操作"><a href="#slice对象的索引和切片操作" class="headerlink" title="slice对象的索引和切片操作"></a>slice对象的索引和切片操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d ptr=%p %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	slice1 := arr1[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">	printSlice(slice1) <span class="comment">// len=3 cap=8 ptr=0xc0000101e8 [2 3 4]</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//fmt.Println(slice1[7]) // panic:out of range</span></span><br><span class="line"></span><br><span class="line">	slice2 := slice1[:<span class="number">7</span>]</span><br><span class="line">	printSlice(slice1) <span class="comment">// len=3 cap=8 ptr=0xc0000101e8 [2 3 4]</span></span><br><span class="line">	printSlice(slice2) <span class="comment">// len=7 cap=8 ptr=0xc0000101e8 [2 3 4 5 6 7 8]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码我们可以使用slice的源代码解释 :</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// 切片的第一个元素的指针</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为数组是连续排放的 , 当我们知道第一个元素的指针对应的内存地址时 , 就很容易得到第二个元素的指针对应的内存地址 . </li>
<li> 当我们进行<code>slice1[7]</code>索引操作的时候 , 在编译时 , 系统会检测索引值<code>idx</code>是否大于slice的<code>len</code>属性 , 超出及报错 . 没超出则利用数组的连续排放性质进行索引 . </li>
<li>当我们使用<code>arr1[1:4]</code>切片操作的时候 , 就会创建一个slice对象 , 同时利用底层数组初始化好<code>array</code> , <code>len</code> , <code>cap</code>属性 . </li>
<li>当我们使用<code>slice1[:7]</code>对slice进行切片操作的时候 , 和上面一样 , 还是利用底层数组初始化好<code>array</code> , <code>len</code> , <code>cap</code>属性 , 不过是这时候的<code>len</code>属性更大了 , 能获取到底层数组的更多元素了而已 . </li>
</ul>
<h3 id="append操作"><a href="#append操作" class="headerlink" title="append操作"></a>append操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">	s = s[:<span class="number">0</span>]</span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拓展其长度</span></span><br><span class="line">	s = s[:<span class="number">5</span>]</span><br><span class="line">	printSlice(s)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 第一次增加</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">	printSlice(s)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 第二次增加</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">	printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d ptr=%p %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// len=6 cap=6 ptr=0x450000 [2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">// len=0 cap=6 ptr=0x450000 []</span></span><br><span class="line"><span class="comment">// len=5 cap=6 ptr=0x450000 [2 3 5 7 11]</span></span><br><span class="line"><span class="comment">// len=6 cap=6 ptr=0x450000 [2 3 5 7 11 1]</span></span><br><span class="line"><span class="comment">// len=7 cap=12 ptr=0x44e030 [2 3 5 7 11 1 1]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一次append的时候，长度没有超过容量，所以容量没有变。</li>
<li>第二次append的时候，<strong>长度超过了容量，这时容量会扩展到原来的2倍</strong>。</li>
<li>同时，增加后的切片地址和原来不同，也就是说：<br>append操作可能会导致原本使用同一个底层数组的两个Slice变量变为<strong>使用不同的底层数组</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 截取切片使其长度为 0</span></span><br><span class="line">	s = s[:<span class="number">0</span>]</span><br><span class="line">	printSlice(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拓展其长度</span></span><br><span class="line">	s = s[:<span class="number">4</span>]</span><br><span class="line">	printSlice(s)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// append后再切片</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">    s = s[:<span class="number">6</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// len=6 cap=6 [2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">// len=0 cap=6 []</span></span><br><span class="line"><span class="comment">// len=4 cap=6 [2 3 5 7]</span></span><br><span class="line"><span class="comment">// len=6 cap=6 [2 3 5 7 4 13]</span></span><br></pre></td></tr></table></figure>

<p>在[2 3 5 7]基础上append一个4后，在全容量获取切片，发现最后一个13还在，只是11被4替换了。这说明<strong>append的写入是把slice后边数据逐个覆盖掉</strong>。</p>
<blockquote>
<p>上面两段代码 , 还是可以使用 slice源码 来解释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// 切片的第一个元素的指针</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 长度 </span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当我们appent一个元素之前 , 就会判断<code>len == cap</code> , </li>
<li>如果不等于 , 那么就会获取<code>slice[len+1]</code>这个元素的指针 , 根据这个指针来修改内存数据 , 这样就实现了<code>覆盖</code>的效果</li>
<li>如果相等 , 那么就会创建一个<strong>cap*2</strong>大小的新数组 , 将原底层数组的数据复制到这个新的数组 , 再根据新数组创建一个新的slice , 这样就解释了 为什么append之后slice会使用不同的底层数组</li>
<li>代码如下:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="keyword">int</span>, y <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> z []<span class="keyword">int</span></span><br><span class="line">	zlen := <span class="built_in">len</span>(x) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">		<span class="comment">// 有成长的空间则会扩展切片。</span></span><br><span class="line">		z = x[:zlen]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 空间不足。分配一个新数组。</span></span><br><span class="line">		<span class="comment">// 以双倍的速度增长，为了摊销的线性复杂性。</span></span><br><span class="line">		zcap := zlen</span><br><span class="line">		<span class="keyword">if</span> zcap &lt; <span class="number">2</span>*<span class="built_in">len</span>(x) &#123;</span><br><span class="line">			zcap = <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">		&#125;</span><br><span class="line">		z = <span class="built_in">make</span>([]<span class="keyword">int</span>, zlen, zcap)</span><br><span class="line">		<span class="built_in">copy</span>(z, x)</span><br><span class="line">	&#125;</span><br><span class="line">	z[<span class="built_in">len</span>(x)] = y</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/1589387685439.png" alt="1589387685439"></p>
<p><img src="/images/1589387700303.png" alt="1589387700303"></p>
</blockquote>
<blockquote>
<ul>
<li>内置的append函数可能使用更复杂的内存扩展策略。</li>
<li>因此我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。</li>
<li>同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。</li>
<li>因此，通常是将append返回的结果直接赋值给输入的slice变量：<strong>更新slice变量</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新slice变量</span></span><br><span class="line">runes = <span class="built_in">append</span>(runes, r)</span><br></pre></td></tr></table></figure>

<p>实际上对应任何<strong>可能导致长度、容量或底层数组变化的操作都有必要进行更新slice变量</strong>。</p>
</blockquote>
<h3 id="copy操作"><a href="#copy操作" class="headerlink" title="copy操作"></a>copy操作</h3><p>用于将内容从一个数组切片复制到另一个数组切片。如果加入的两个数组切片不一样大，就<strong>会按其中较小的那个数组切片的元素个数进行复制</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	slice2 := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">	slice3 := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">copy</span>(slice2, slice1) <span class="comment">// 只会复制slice1的前3个元素到slice2中</span></span><br><span class="line">	printSlice(slice2)    <span class="comment">// len=3 cap=3 [1 2 3]</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">copy</span>(slice1, slice3) <span class="comment">// 只会复制slice3的3个元素到slice1的前3个位置</span></span><br><span class="line">	printSlice(slice1)    <span class="comment">// len=5 cap=5 [5 4 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="slice内存操作"><a href="#slice内存操作" class="headerlink" title="slice内存操作"></a>slice内存操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonempty</span><span class="params">(strings []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">		<span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			strings[i] = s</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings[:i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := []<span class="keyword">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, nonempty(data)) <span class="comment">// [&quot;one&quot; &quot;three&quot;]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, data) <span class="comment">// [&quot;one&quot; &quot;three&quot; &quot;three&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入的slice和输出的slice共享一个底层数组 , 原来的数据将可能会被覆盖</p>
<p>因此我们通常会这样使用nonempty函数： <code>data = nonempty(data)</code> 。</p>
<blockquote>
<p>以这种方式重用一个slice一般都要求最多<strong>为每个输入值产生一个输出值</strong> , 也就是<code>data = nonempty(data)</code> 。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>切片的长度和容量不同，长度表示左指针至右指针之间的距离，容量表示左指针至底层数组末尾的距离。</li>
<li>切片的扩容机制，append的时候，如果长度增加后超过容量，则将容量增加2倍，同时<strong>变换了底层数组</strong>。</li>
<li>切片append机制，是把slice后边数据逐个<strong>覆盖写入</strong>。</li>
<li>切片copy机制，按其中较小的那个数组切片的元素个数进行复制。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li><p>在Go语言中，一个map就是一个哈希表的<code>引用</code></p>
</li>
<li><p> 因为精度问题 , 最好不要使用float作为key</p>
</li>
<li><p>delete操作 和 map[key] 是安全的 </p>
<ul>
<li><code>delete(m,&quot;name&quot;)</code> : 不管name这个key存不存在 都可以</li>
<li><code>ages[&quot;bob&quot;]++</code> : 不管bob这个key存不存在 都可以</li>
</ul>
</li>
<li><p>禁止对map的元素进行取址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	m[<span class="string">&quot;age&quot;</span>] = <span class="number">21</span></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// _ = &amp;m[&quot;bob&quot;] // 禁止对map的元素进行取址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因 : <strong>map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</strong></p>
</blockquote>
</li>
<li><p>最经常使用的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">&quot;bob&quot;</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实现OrderDict功能"><a href="#实现OrderDict功能" class="headerlink" title="实现OrderDict功能"></a>实现OrderDict功能</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;alice&quot;</span>:   <span class="number">31</span>,</span><br><span class="line">		<span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	names := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(ages))</span><br><span class="line">	<span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">		names = <span class="built_in">append</span>(names, name)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	sort.Strings(names)</span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, ages[name])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="嵌套map"><a href="#嵌套map" class="headerlink" title="嵌套map"></a>嵌套map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">	innerM := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">		<span class="string">&quot;heyingliang&quot;</span> :<span class="literal">true</span>,</span><br><span class="line">		<span class="string">&quot;dengshouze&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	m[<span class="string">&quot;123&quot;</span>] = innerM</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul>
<li>结构体是一种<code>聚合</code>的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的<code>成员</code>。</li>
</ul>
<h3 id="如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法"><a href="#如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法" class="headerlink" title="如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法"></a>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Address <span class="keyword">string</span></span><br><span class="line">	Salary <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/* 结构体实例成员的指针 */</span></span><br><span class="line">	e1 := Employee&#123;&#125;</span><br><span class="line">	s := &amp;e1.Salary</span><br><span class="line">	*s = <span class="number">999</span></span><br><span class="line">	fmt.Println(e1.Salary) <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 结构体实例的指针 */</span></span><br><span class="line">	<span class="keyword">var</span> e2 Employee</span><br><span class="line">	e := &amp;e2</span><br><span class="line">	e.Address = <span class="string">&quot;lixinjie&quot;</span></span><br><span class="line">	fmt.Println(e.Address) <span class="comment">// lixinjie</span></span><br><span class="line"></span><br><span class="line">	e3 := Employee&#123;&#125;</span><br><span class="line">	e3.Salary = <span class="number">888</span></span><br><span class="line">	fmt.Println(e3.Salary) <span class="comment">// 888</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面三者都可以正常获取 :</p>
<ul>
<li>结构体实例的值成员</li>
<li>结构体实例指针的值成员</li>
<li>结构体实例的指针成员</li>
</ul>
<blockquote>
<p>如果是按 pointer 调用，go 会自动进行转换，因为有了指针总是能得到指针指向的值是什么，如果是 value 调用，go 将无从得知 value 的原始值是什么，因为 value 是份拷贝。go 会把指针进行隐式转换得到 value，但反过来则不行。</p>
<p>（任何一个 <code>Cat</code> 类型的值可能会有很多 <code>*Cat</code> 类型的指针指向它，如果我们尝试通过 <code>Cat</code> 类型的值来调用 <code>*Cat</code> 的方法，根本就不知道对应的是哪个指针。相反，如果 <code>Dog</code> 类型上有一个方法，通过 <code>*Dog</code>来调用这个方法可以确切的找到该指针对应的 <code>Gog</code> 类型的值，从而调用上面的方法。）</p>
</blockquote>
<h3 id="结构体的嵌套-递归数据结构"><a href="#结构体的嵌套-递归数据结构" class="headerlink" title="结构体的嵌套(递归数据结构)"></a>结构体的嵌套(递归数据结构)</h3><ul>
<li>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）</li>
<li>但是S类型的结构体可以包含<code>*S</code>指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	val  <span class="keyword">int</span></span><br><span class="line">	next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">NewNextNode</span><span class="params">(val <span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	n.next = &amp;Node&#123;val: val&#125;</span><br><span class="line">	<span class="keyword">return</span> n.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeLink</span><span class="params">(<span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> head *Node</span><br><span class="line"></span><br><span class="line">	dummy := &amp;Node&#123;val: <span class="number">0</span>&#125;</span><br><span class="line">	head = dummy</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		dummy = dummy.NewNextNode(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *(head.next)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LinkDesc</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> node.next != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(node.val)</span><br><span class="line">		node = node.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l := MakeLink(<span class="number">10</span>)</span><br><span class="line">	LinkDesc(&amp;l) <span class="comment">// 1 2 3 ... 9 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree <span class="keyword">struct</span> &#123;</span><br><span class="line">	val   <span class="keyword">int</span></span><br><span class="line">	left  *Tree</span><br><span class="line">	right *Tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *Tree)</span> <span class="title">add</span><span class="params">(val <span class="keyword">int</span>)</span> *<span class="title">Tree</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tree == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;Tree&#123;val: val&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> val &lt; tree.val &#123;</span><br><span class="line">			tree.left = tree.left.add(val)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tree.right = tree.right.add(val)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tree</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *Tree)</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tree == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tree.left.show()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v , (%v , %v)\n&quot;</span>, tree.val, tree.left, tree.right)</span><br><span class="line">		tree.right.show()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := &amp;Tree&#123;val: <span class="number">5</span>&#125;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		tree.add(num)</span><br><span class="line">	&#125;</span><br><span class="line">	tree.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体的成员必须大写才能导出"><a href="#结构体的成员必须大写才能导出" class="headerlink" title="结构体的成员必须大写才能导出"></a>结构体的成员必须大写才能导出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> p</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123; a, b <span class="keyword">int</span> &#125; <span class="comment">// a and b are not exported</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> q</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;p&quot;</span></span><br><span class="line"><span class="keyword">var</span> _ = p.T&#123;a: <span class="number">1</span>, b: <span class="number">2</span>&#125; <span class="comment">// compile error: can&#x27;t reference a, b</span></span><br><span class="line"><span class="keyword">var</span> _ = p.T&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// compile error: can&#x27;t reference a, b</span></span><br></pre></td></tr></table></figure>



<h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的。</p>
<h3 id="结构体嵌入和匿名成员"><a href="#结构体嵌入和匿名成员" class="headerlink" title="结构体嵌入和匿名成员"></a>结构体嵌入和匿名成员</h3><blockquote>
<p>先看下面 , <strong>结构体的嵌套 导致 需要使用多重点号获取成员</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">int</span> <span class="comment">// 点的坐标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	P Point</span><br><span class="line">	R <span class="keyword">int</span> <span class="comment">// 半径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 车轮</span></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">	Circle Circle</span><br><span class="line">	Spokes <span class="keyword">int</span> <span class="comment">// 辐条的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> w Wheel</span><br><span class="line">	w.Circle.P.X = <span class="number">8</span></span><br><span class="line">	w.Circle.P.Y = <span class="number">7</span></span><br><span class="line">	w.Circle.R = <span class="number">6</span></span><br><span class="line">	w.Spokes = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名成员的引用就是为了<strong>只用一次点号就能获取</strong></li>
<li>也就是说 : <strong>直接访问叶子属性而不需要给出完整的路径</strong></li>
</ul>
</blockquote>
<ul>
<li><code>匿名成员</code> : 只声明成员的数据类型而不指名成员的名字</li>
<li>匿名成员的数据类型必须是命名的<code>类型</code>或指向一个命名的<code>类型的指针</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Point</span><br><span class="line">	R <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">	Circle</span><br><span class="line">	Spokes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	w := Wheel&#123;&#125;</span><br><span class="line">	w.X = <span class="number">9</span></span><br><span class="line">	w.Y = <span class="number">8</span></span><br><span class="line">	w.R = <span class="number">7</span></span><br><span class="line">	w.Spokes = <span class="number">6</span></span><br><span class="line">	fmt.Println(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">20</span>&#125; <span class="comment">// compile error: unknown fields</span></span><br><span class="line">w = Wheel&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>, Radius: <span class="number">5</span>, Spokes: <span class="number">20</span>&#125; <span class="comment">// compile error: unknown fields</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>到目前为止，我们看到匿名成员特性只是对访问嵌套成员的点运算符提供了简短的语法糖。</li>
<li>其实匿名成员并不要求是结构体类型；任何命名的类型都可以作为结构体的匿名成员。</li>
<li>为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？<br>答案是<code>匿名类型的方法集</code>。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。</li>
<li>实际上，<strong>外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法</strong>。</li>
<li>这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>由标准库中的<code>encoding/json</code>、<code>encoding/xml</code>、<code>encoding/asn1</code>等包提供支持，并且这类包都有着相似的API接口</li>
<li>GO中的<code>结构体</code>非常适合Json的数据格式</li>
</ul>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title <span class="keyword">string</span></span><br><span class="line">	Year <span class="keyword">int</span> <span class="string">`json:&quot;released&quot;`</span></span><br><span class="line">	Color <span class="keyword">bool</span> <span class="string">`json:&quot;color,omitempty&quot;`</span></span><br><span class="line">	Actors []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">	&#123;Title: <span class="string">&quot;Casablanca&quot;</span>, Year: <span class="number">1942</span>, Color: <span class="literal">false</span>,</span><br><span class="line">		Actors: []<span class="keyword">string</span>&#123;<span class="string">&quot;Humphrey Bogart&quot;</span>, <span class="string">&quot;Ingrid Bergman&quot;</span>&#125;&#125;,</span><br><span class="line">	&#123;Title: <span class="string">&quot;Cool Hand Luke&quot;</span>, Year: <span class="number">1967</span>, Color: <span class="literal">true</span>,</span><br><span class="line">		Actors: []<span class="keyword">string</span>&#123;<span class="string">&quot;Paul Newman&quot;</span>&#125;&#125;,</span><br><span class="line">	&#123;Title: <span class="string">&quot;Bullitt&quot;</span>, Year: <span class="number">1968</span>, Color: <span class="literal">true</span>,</span><br><span class="line">		Actors: []<span class="keyword">string</span>&#123;<span class="string">&quot;Steve McQueen&quot;</span>, <span class="string">&quot;Jacqueline Bisset&quot;</span>&#125;&#125;,</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>json:&quot;released&quot;</code> 和 <code>json:&quot;color,omitempty&quot;</code> 是结构体成员Tag</li>
<li>结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:”value”键值对序列；</li>
<li>因为值中含义双引号字符，因此成员Tag一般用原生字符串面值的形式书写。</li>
<li><code>json</code>开头键名对应的值用于<strong>控制encoding/json包的编码和解码的行为</strong><ul>
<li>json对应值的第一部分用于指定JSON对象的名字 (上面例子就是将Year字段改成released字段)</li>
<li>omitempty选项，表示当Go语言结构体成员为空或零值时就不输出这个成员 (上面例子 , 当Color字段为false时 , 就不会输出)</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>将一个Go语言中类似movies的<code>结构体slice</code>转为JSON的过程叫<code>编组</code>（marshaling）。</li>
<li>编组通过调用<code>json.Marshal</code>函数完成 , Marshal函数返还一个编码后的<code>字节slice</code></li>
<li><code>json.MarshalIndent</code>函数将产生整齐缩进的输出</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// data, err := json.Marshal(movies) 或者</span></span><br><span class="line">           data, err := json.MarshalIndent(movies, <span class="string">&quot;&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 : <strong>只有支持导出的结构体成员(大写)才会被编码</strong>。</p>
</blockquote>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><ul>
<li>将JSON数据解码为Go语言的数据结构</li>
<li>Go语言中一般叫<code>unmarshaling</code>，通过json.Unmarshal函数完成。</li>
<li>通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> titles []<span class="keyword">struct</span>&#123; Title <span class="keyword">string</span> &#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;JSON unmarshaling failed: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(titles) <span class="comment">// &quot;[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]&quot;</span></span><br></pre></td></tr></table></figure>



<p>解码多字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IssuesSearchResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	TotalCount <span class="keyword">int</span> <span class="string">`json:&quot;total_count&quot;`</span></span><br><span class="line">	Items      []*Issue</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Issue <span class="keyword">struct</span> &#123;</span><br><span class="line">	Number    <span class="keyword">int</span></span><br><span class="line">	HTMLURL   <span class="keyword">string</span> <span class="string">`json:&quot;html_url&quot;`</span></span><br><span class="line">	Title     <span class="keyword">string</span></span><br><span class="line">	State     <span class="keyword">string</span></span><br><span class="line">	User      *User</span><br><span class="line">	CreatedAt time.Time <span class="string">`json:&quot;created_at&quot;`</span></span><br><span class="line">	Body      <span class="keyword">string</span>    <span class="comment">// in Markdown format</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Login   <span class="keyword">string</span></span><br><span class="line">	HTMLURL <span class="keyword">string</span> <span class="string">`json:&quot;html_url&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result IssuesSearchResult</span><br><span class="line"><span class="comment">//resp.Body 是假设已知的响应体</span></span><br><span class="line"><span class="comment">// 基于流式的解码器json.Decoder，它可以从一个输入流解码JSON数据</span></span><br><span class="line"><span class="comment">// 调用Decode方法来填充result变量。</span></span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(result)</span><br></pre></td></tr></table></figure>



<h2 id="文本和HTML模板"><a href="#文本和HTML模板" class="headerlink" title="文本和HTML模板"></a>文本和HTML模板</h2><ul>
<li>复杂的打印格式是由<code>text/template</code>和<code>html/template</code>等模板包提供的 . 它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li><p>Go没有<code>关键字参数</code> , 也没有<code>默认参数</code> , 每一次函数调用都必须按照声明顺序为所有参数提供实参</p>
</li>
<li><p>Go的函数是<code>值传递</code> , 但是可以传入引用类型参数 </p>
<ul>
<li>指针</li>
<li>slice(切片)</li>
<li>map</li>
<li>function</li>
<li>channel</li>
</ul>
</li>
<li><p>没有函数体的函数声明 , 这表示<strong>该函数不是以Go实现的。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float</span> //<span class="title">implemented</span> <span class="title">in</span> <span class="title">assembly</span> <span class="title">language</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>函数的返回值的习惯约定 : </p>
<ul>
<li>最后一个bool类型的返回值表示函数是否运行成功，通常被命名为<code>ok</code></li>
<li>error类型的返回值代表函数的错误信息，通常被命名为<code>err</code></li>
</ul>
</li>
</ul>
<h2 id="使用bare-return自动初始化返回值"><a href="#使用bare-return自动初始化返回值" class="headerlink" title="使用bare return自动初始化返回值"></a>使用bare return自动初始化返回值</h2><p>下面代码 , 系统就会自动初始化x , y .这是非常方便的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFunc</span><span class="params">()</span> <span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(testFunc()) <span class="comment">// 0 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种技巧经常用于<code>if err!=nil</code>的情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountWordsAndImages</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(words, images <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><ul>
<li>最后一个bool类型的返回值表示函数是否运行成功，通常被命名为<code>ok</code></li>
<li>error类型的返回值代表函数的错误信息，通常被命名为<code>err</code></li>
</ul>
<blockquote>
<ul>
<li>如果函数只有一种错误 , 那么一般使用<code>ok</code></li>
<li>如果函数有多种错误 , 那么一般使用<code>err</code></li>
</ul>
</blockquote>
<ul>
<li><p>内置的error是接口类型。error类型可能是<code>nil</code>或者<code>non-nil</code>。</p>
</li>
<li><p>对于non-nil的error类型,我们可以通过调用error的<code>Error函数</code>或者输出函数获得字符串类型的错误信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>, err)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此 , 我们就发现了Go的python在异常的区别 :</p>
<ul>
<li>python在函数执行失败的时候是<code>raise Exception</code></li>
<li>go在函数执行失败的时候是<code>return error</code></li>
</ul>
<blockquote>
<p>即 : 在Go中，函数运行失败时会<strong>返回错误信息</strong> , 而不是<strong>抛出异常</strong></p>
</blockquote>
<h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><p>当函数调用返回错误时 , 一般有5种处理方式</p>
<ul>
<li><p>传播错误</p>
<ul>
<li>直接传播</li>
<li>添加新的错误信息并返回，错误信息应提供清晰的从原因到后果的因果链</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nill, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;parsing %s as HTML: %v&quot;</span>, url,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重新尝试失败的操作 , 需要限制重试的时间间隔或重试的次数，防止无限制的重试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> tries := <span class="number">0</span>; time.Now().Before(deadline); tries++ &#123;</span><br><span class="line">    _, err := http.Head(url)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// success</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;server not responding (%s);retrying…&quot;</span>, err)</span><br><span class="line">    time.Sleep(time.Second &lt;&lt; <span class="keyword">uint</span>(tries)) <span class="comment">// exponential back-off</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出错误信息并结束程序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := WaitForServer(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Fprintf(os.Stderr, <span class="string">&quot;Site is down: %v\n&quot;</span>, err)</span><br><span class="line">	os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> err := WaitForServer(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;Site is down: %v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种策略只应在main中执行。对库函数而言，应仅向上传播错误。</p>
</blockquote>
</li>
<li><p>只需要输出错误信息就足够了，不需要中断程序的运行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Ping(); err != <span class="literal">nil</span> &#123;	log.Printf(<span class="string">&quot;ping failed: %v; networking disabled&quot;</span>,err)&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>直接忽略掉错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir, err := ioutil.TempDir(<span class="string">&quot;&quot;</span>, <span class="string">&quot;scratch&quot;</span>)<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create temp dir: %v&quot;</span>,err)&#125;<span class="comment">// ...use temp dir…</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="文件结尾错误（EOF）"><a href="#文件结尾错误（EOF）" class="headerlink" title="文件结尾错误（EOF）"></a>文件结尾错误（EOF）</h3><p>io包保证任何由文件结束引起的读取失败都返回同一个错误——<code>io.EOF</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* EOF定义*/</span></span><br><span class="line"><span class="keyword">package</span> io</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="comment">// EOF是当没有更多的输入可用时，Read返回的错误。</span></span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>使用如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	r, _, err := in.ReadRune()</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		<span class="keyword">break</span> <span class="comment">// finished reading</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read failed:%v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...use r…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h2><p>在Go中 , 函数是一等公民</p>
<ul>
<li>拥有类型，</li>
<li>可以被赋值给其他变量，</li>
<li>传递给函数，</li>
<li>从函数返回</li>
</ul>
<p>需要注意的是 , <strong>给函数起别名</strong>还是要类型检查的 , 不能随意赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>     &#123; <span class="keyword">return</span> n * n &#125;<span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>   &#123; <span class="keyword">return</span> -n &#125;<span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(m, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> m * n &#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, square)   <span class="comment">// func(int) int	fmt.Printf(&quot;%T\n&quot;, negative) // func(int) int	fmt.Printf(&quot;%T\n&quot;, product)  // func(int, int) int	f := square	fmt.Println(f(3)) // &quot;9&quot;	f = negative	fmt.Println(f(3)) // &quot;-3&quot;	f = product // compile error: can&#x27;t assign func(int, int) int to func(int) int&#125;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</li>
<li>函数值可以与nil比较：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">f(<span class="number">3</span>) <span class="comment">// 此处f的值为nil, 会引起panic错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>函数之间是不可比较的</li>
<li><strong>不能用函数值作为map的key</strong></li>
<li>可以有<code>函数数组</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>     &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>   &#123; <span class="keyword">return</span> -n &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span><span class="title">int</span>, 2)</span></span><br><span class="line">	arr[<span class="number">0</span>] = square</span><br><span class="line">	arr[<span class="number">1</span>] = negative</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数作为函数的参数或函数的返回值"><a href="#函数作为函数的参数或函数的返回值" class="headerlink" title="函数作为函数的参数或函数的返回值"></a>函数作为函数的参数或函数的返回值</h3><h4 id="模仿python的函数装饰器"><a href="#模仿python的函数装饰器" class="headerlink" title="模仿python的函数装饰器"></a>模仿python的函数装饰器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deco</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> f(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> num + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	add1 := deco(add1)</span><br><span class="line">	res := add1(<span class="number">2</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="集中处理模式"><a href="#集中处理模式" class="headerlink" title="集中处理模式"></a>集中处理模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span>(<span class="params">num</span>):</span>	<span class="keyword">return</span> num +1<span class="keyword">def</span> sub1(num):	<span class="keyword">return</span> num -1<span class="keyword">def</span> numHander(arr,*func):	m = <span class="built_in">dict</span>()	<span class="keyword">for</span> f <span class="keyword">in</span> func:		m[f.__name__] = [f(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> arr]	<span class="keyword">return</span> mif __name__ == <span class="string">&#x27;__main__&#x27;</span>:	arr = [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>]	res = numHander(arr,add1,sub1)	<span class="built_in">print</span>(res) <span class="comment"># &#123;&#x27;add1&#x27;: [10, 7, 4, 9, 6, 3, 8, 5, 2], &#x27;sub1&#x27;: [8, 5, 2, 7, 4, 1, 6, 3, 0]&#125;</span></span><br></pre></td></tr></table></figure>

<p>go版本</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> num + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub1</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> num - <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numHandler</span><span class="params">(numArr []<span class="keyword">int</span>, f1, f2 <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">map</span>[<span class="title">string</span>][]<span class="title">int</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> arr1 []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> arr2 []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> numArr &#123;</span><br><span class="line">		arr1 = <span class="built_in">append</span>(arr1, f1(val))</span><br><span class="line">		arr2 = <span class="built_in">append</span>(arr1, f2(val))</span><br><span class="line">	&#125;</span><br><span class="line">	m[<span class="string">&quot;f1&quot;</span>] = arr1</span><br><span class="line">	m[<span class="string">&quot;f2&quot;</span>] = arr2</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>&#125;</span><br><span class="line">	res := numHandler(arr, add1, sub1)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	<span class="comment">// map[f1:[10 7 4 9 6 3 8 5 2] f2:[10 7 4 9 6 3 8 5 2 0]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		num++</span><br><span class="line">		<span class="keyword">return</span> num * num</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := squares()</span><br><span class="line">	fmt.Println(f()) <span class="comment">// 1</span></span><br><span class="line">	fmt.Println(f()) <span class="comment">// 4</span></span><br><span class="line">	fmt.Println(f()) <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="闭包和匿名函数的陷阱-捕获迭代变量"><a href="#闭包和匿名函数的陷阱-捕获迭代变量" class="headerlink" title="闭包和匿名函数的陷阱(捕获迭代变量)"></a>闭包和匿名函数的陷阱(捕获迭代变量)</h3><blockquote>
<p><strong>闭包中记录的是循环变量的内存地址，而不是循环变量某一时刻的值</strong></p>
</blockquote>
<p>python中一样存在这个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_mutilpliers</span>():</span>	<span class="keyword">return</span> [<span class="keyword">lambda</span> x:i*x <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]<span class="keyword">for</span> m <span class="keyword">in</span> create_mutilpliers():	<span class="built_in">print</span>(m(<span class="number">2</span>)) <span class="comment"># 8 8 8 8 8</span></span><br></pre></td></tr></table></figure>

<p>上面的<code>create_mutilpliers()</code>改成def形式比较好说明 : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_multipliers</span>():</span>    multipliers = []    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):        <span class="function"><span class="keyword">def</span> <span class="title">multiplier</span>(<span class="params">x</span>):</span>            <span class="keyword">return</span> i * x                multipliers.append(multiplier)    <span class="keyword">return</span> multipliersfor m <span class="keyword">in</span> create_mutilpliers():	<span class="built_in">print</span>(m(<span class="number">2</span>)) <span class="comment"># 8 8 8 8 8</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当<code>create_multipliers()</code>函数返回五个函数时,这三个变量所引用的变量<code>i</code>的值已经变成了4,</li>
<li>因为在返回的时候五个函数并没有被调用,所以此时它们并没有及时计算它们对应的<code>i</code>乘以<code>i</code>的值,</li>
<li>等到五个函数都返回时,然后调用五个函数,此时<code>i</code>的值已经为4,计算i乘以<code>i</code>的值自然就都是8了.</li>
</ul>
<blockquote>
<p>简单来讲 : </p>
<ul>
<li><strong>闭包中记录的是循环变量的内存地址，而不是循环变量某一时刻的值</strong></li>
<li>执行<code>multipliers.append(multiplier)</code>时 , python发现<code>multiplier</code> , 需要使用到变量<code>i</code> , 此时就默默记录下变量<code>i</code>的内存地址 , 等调用的时候就根据这个地址去拿取具体的数据</li>
<li>执行<code>m(2)</code>时 , 就根据刚刚的内存地址获取数据 , 但是此时的数据已经变成了<code>i=4</code></li>
</ul>
</blockquote>
<p>python的解决方法就是添加一个默认关键字 , <strong>直接将<code>值</code>传入闭包</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_mutilpliers</span>():</span>    multipliers = []    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):	    <span class="comment"># 使用默认参数 , 直接将`值`传入闭包    	def multiplier(x,i=i):    		return i * x    	multipliers.append(multiplier)    return multipliersfor m in create_mutilpliers():	print(m(2)) # 0 2 4 6 8</span></span><br></pre></td></tr></table></figure>



<p>Go的情况如下</p>
<blockquote>
<p>形成这种情况的原因有二 :</p>
<ul>
<li><strong>闭包中记录的是循环变量的内存地址，而不是循环变量某一时刻的值</strong></li>
<li>循环变量共用同一个内存地址</li>
</ul>
<p>所以 , 解决方法就是给循环变量加一个副本</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;	<span class="keyword">var</span> funcArr = <span class="built_in">make</span>([]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span>, 0)	<span class="title">for</span> _, <span class="title">val</span> := <span class="title">range</span> <span class="title">arr</span></span> &#123;		funcArr = <span class="built_in">append</span>(funcArr, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;			<span class="keyword">return</span> val * <span class="number">2</span>		&#125;)	&#125;	<span class="keyword">for</span> _, f := <span class="keyword">range</span> funcArr &#123;		fmt.Println(f()) <span class="comment">// 10 10 10 10 10	&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>解决如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;	<span class="keyword">var</span> funcArr = <span class="built_in">make</span>([]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span>, 0)	<span class="title">for</span> _, <span class="title">val</span> := <span class="title">range</span> <span class="title">arr</span></span> &#123;		<span class="comment">/*5次打印值都是同一个		模拟一下实际的情况，假设 v 变量的地址在 0x12345678 上，		for 循环在迭代过程中，所有变量值都是在这地址上迭代的。		当最后调用匿名函数的时候，取值也是在这块地址上。		所以最后输出的结果都是迭代的最后一个值。*/</span>		fmt.Println(&amp;val)		temp := val <span class="comment">// 添加这一句		// 5次打印值都不同		fmt.Println(&amp;temp)		funcArr = append(funcArr, func() int &#123;			return temp * 2		&#125;)	&#125;	for _, f := range funcArr &#123;		fmt.Println(f()) // 2 4 6 8 10	&#125;&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul>
<li>对于拥有可变参数的函数 , 调用者会隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数</li>
<li>对于python , 将<code>切片</code>传给函数用的是<code>元组拆包</code> (<strong>前面加星号</strong>), GO是<strong>后面加省略号</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">*args</span>):</span>	res = <span class="number">0</span>	<span class="keyword">for</span> a <span class="keyword">in</span> args:		res += a	<span class="keyword">return</span> resx = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]<span class="built_in">print</span>(<span class="built_in">sum</span>(*x)) <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(num ...<span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>)</span></span> &#123;	<span class="keyword">for</span> _, n := <span class="keyword">range</span> num &#123;		res += n	&#125;	<span class="keyword">return</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="comment">// 注意是切片,不是数组.若是数组会报错	slice := []int&#123;1,2,3,4,5&#125;	fmt.Println(sum(slice...)) // 15	// 数组需要转成切片	arr := [...]int&#123;1,2,3,4,5&#125;	fmt.Println(sum(arr[:]...)) // 15&#125;</span></span><br></pre></td></tr></table></figure>



<p>虽然可变参数和参数是切片的函数用起来差不多 , 但是他们还是不同的函数类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(num ...<span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>)</span></span> &#123;	<span class="keyword">for</span> _, n := <span class="keyword">range</span> num &#123;		res += n	&#125;	<span class="keyword">return</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">sum2</span><span class="params">(num []<span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>)</span></span> &#123;	<span class="keyword">for</span> _, n := <span class="keyword">range</span> num &#123;		res += n	&#125;	<span class="keyword">return</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;	fmt.Println(sum(slice...)) <span class="comment">// 15	fmt.Println(sum2(slice))   // 15	fmt.Printf(&quot;%T\n&quot;, sum)  // func(...int) int	fmt.Printf(&quot;%T\n&quot;, sum2) // func([]int) int	f := sum	f = sum2 // Cannot use &#x27;sum2&#x27; (type func(num []int) (res int)) as type func(num ...int) (res int)&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="Deferred函数"><a href="#Deferred函数" class="headerlink" title="Deferred函数"></a>Deferred函数</h2><ul>
<li> defer语句是用来<strong>延迟执行函数的</strong>，而且延迟发生在<strong>调用函数 return 之后</strong></li>
<li> 它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。</li>
<li> defer语句需要特别注意，<strong>只有在函数执行完毕后，这些被延迟的函数才会执行</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> num + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> t(num)</span><br><span class="line">	<span class="keyword">return</span> num * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(test(<span class="number">10</span>)) <span class="comment">// 20 , 注意不是22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ioutil</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">return</span> ReadAll(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Printf(<span class="string">&quot;double(%d) = %d\n&quot;</span>, x,result) &#125;()</span><br><span class="line">	<span class="keyword">return</span> x + x</span><br><span class="line">&#125;</span><br><span class="line">_ = double(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;double(4) = 8&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a>Panic异常</h2><ul>
<li>Go的panic机制类似于其他语言的异常</li>
<li>有些错误只能<code>在运行时检查</code>，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</li>
<li>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常</li>
<li><strong>当panic异常发生时，程序会中断运行，并立即执行在该goroutine中defer函数</strong></li>
</ul>
<h3 id="Recover捕获异常"><a href="#Recover捕获异常" class="headerlink" title="Recover捕获异常"></a>Recover捕获异常</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="params">(s *Syntax, err error)</span></span> &#123;  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;    <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;      err = fmt.Errorf(<span class="string">&quot;internal error: %v&quot;</span>, p)    &#125;  &#125;()  <span class="comment">// ...parser...&#125;</span></span><br></pre></td></tr></table></figure>

<p>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你<strong>不应该试图去恢复其他包引起的panic</strong>。公有的API应该将函数的运 行失败作为error返回，而不是panic。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul>
<li>建议使用其类型的第一个字母作为接收器的名字，比如使用Point的首字母p。</li>
<li>将两个<strong>包级别</strong>的变量变成<strong>struct级别</strong>的变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (  mu sync.Mutex <span class="comment">// guards mapping  mapping = make(map[string]string))func Lookup(key string) string &#123;  mu.Lock()  v := mapping[key]  mu.Unlock()  return v&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;  sync.Mutex  mapping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#125;&#123;  mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),&#125;<span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;  cache.Lock()  v := cache.mapping[key]  cache.Unlock()  <span class="keyword">return</span> v&#125;</span><br></pre></td></tr></table></figure>



<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将 它们进行比较就会失败并且panic:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x inerface&#123;&#125; = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;fmt.Println(x == x) <span class="comment">// // panic: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure>



<h2 id="一个包含nil指针的接口不是nil接口"><a href="#一个包含nil指针的接口不是nil接口" class="headerlink" title="一个包含nil指针的接口不是nil接口"></a>一个包含nil指针的接口不是nil接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNilInterface</span><span class="params">(t *testing.T)</span></span> &#123;	a := <span class="built_in">new</span>(bytes.Buffer)	f(a) <span class="comment">// pass	var b *bytes.Buffer  f(b) // panic: invalid memory address or nil pointer dereference&#125;func f(out io.Writer) &#123;	if out != nil &#123;		out.Write([]byte(&quot;done!\n&quot;))	&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口，所以防御性检查out!=nil的结果依然是true。</p>
<p><img src="/images/image-20210604185324110.png" alt="image-20210604185324110"></p>
<h2 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a>http.Handler接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> httptype Handler <span class="keyword">interface</span> &#123;  ServeHTTP(w ResponseWriter, r *Request)&#125;<span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="keyword">string</span>, h Handler)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>ListenAndServe函数需要一个例如“localhost:8000”的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db := database&#123;<span class="string">&quot;shoes&quot;</span>: <span class="number">50</span>, <span class="string">&quot;socks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">  log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, db))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dollars <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dollars)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;$%.2f&quot;</span>, d) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="keyword">string</span>]dollars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> req.URL.Path &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;/list&quot;</span>:</span><br><span class="line">      <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%s: %s\n&quot;</span>, item, price)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;/price&quot;</span>:</span><br><span class="line">      item := req.URL.Query().Get(<span class="string">&quot;item&quot;</span>)</span><br><span class="line">      price, ok := db[item]</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;no such item: %q\n&quot;</span>, item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    	fmt.Fprintf(w, <span class="string">&quot;%s\n&quot;</span>, price)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">      fmt.Fprintf(w, <span class="string">&quot;no such page: %s\n&quot;</span>, req.URL)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a>error接口</h2><p>实际上它就是interface类型，这个类型有一个返回错误信息的单一方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个errors包仅只有4行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> &amp;errorString&#123;text&#125; &#125;</span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123; text <span class="keyword">string</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.text &#125;</span><br></pre></td></tr></table></figure>

<p>承载errorString的类型是<strong>一个结构体而非一个字符串</strong>，这是为了保护它表示的错误避免粗心 （或有意）的更新。并且因为是指针类型 *errorString 满足error接口而非errorString类型， 所以<strong>每个New函数的调用都分配了一个独特的和其他错误不相同的实例</strong>。</p>
<p>我们也不想要重要的error例如io.EOF和一个刚好有相同错误消息的error比较后相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(errors.New(<span class="string">&quot;EOF&quot;</span>) == errors.New(<span class="string">&quot;EOF&quot;</span>)) <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="通过类型断言询问行为"><a href="#通过类型断言询问行为" class="headerlink" title="通过类型断言询问行为"></a>通过类型断言询问行为</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeString</span><span class="params">(w io.Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">type</span> stringWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteString(<span class="keyword">string</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当w能通过强转改成stringWriter，说明w就有WriteString函数，说明w调用WriteString就不会出错</span></span><br><span class="line">  <span class="keyword">if</span> sw, ok := w.(stringWriter); ok &#123;</span><br><span class="line">    <span class="keyword">return</span> sw.WriteString(s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> w.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Goroutines和Channels"><a href="#Goroutines和Channels" class="headerlink" title="Goroutines和Channels"></a>Goroutines和Channels</h1><p>goroutine和channel，其支持“顺序通信进程”(communicating sequential processes，CSP)。CSP是一种现代的并发编程模型，在这种编程模型中<strong>值会在不同的运行实例(goroutine)中传递</strong>，尽管大多数情况下仍然是被限制在单一实例中。</p>
<p>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。</p>
<h2 id="不带缓存的Channels"><a href="#不带缓存的Channels" class="headerlink" title="不带缓存的Channels"></a>不带缓存的Channels</h2><ul>
<li>一个基于无缓存Channels的发送操作将导致<strong>发送者goroutine阻塞</strong>，直到另一个goroutine在相同的Channels上执行接收操作</li>
<li>当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。</li>
<li>反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</li>
</ul>
<blockquote>
<p>基于无缓存Channels的发送和接收操作将导致<strong>两个goroutine做一次同步操作</strong>。因为这个原因，无缓存Channels有时候也被称为<code>同步Channels</code>。</p>
</blockquote>
<p><strong>当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前</strong></p>
<blockquote>
<p>happens before：这是Go语言并发内存模型的一个关键术语！</p>
<p>在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要<strong>保证在此之前的事件都已经完成了</strong>，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</p>
</blockquote>
<h3 id="串联的Channels（Pipeline）"><a href="#串联的Channels（Pipeline）" class="headerlink" title="串联的Channels（Pipeline）"></a>串联的Channels（Pipeline）</h3><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">  squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Counter</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">      naturals &lt;- x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(naturals)</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Squarer</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> naturals &#123;</span><br><span class="line">      squares &lt;- x * x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(squares)</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Printer (in main goroutine)</span></span><br><span class="line">  <span class="keyword">for</span> x := <span class="keyword">range</span> squares &#123;</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="带缓存的Channels"><a href="#带缓存的Channels" class="headerlink" title="带缓存的Channels"></a>带缓存的Channels</h2><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时 通过第二个参数指定的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan string, 3)</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20210605150215389.png" alt="image-20210605150215389"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- &quot;A&quot;</span><br><span class="line">ch &lt;- &quot;B&quot;</span><br><span class="line">ch &lt;- &quot;C&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20210605150311604.png" alt="image-20210605150311604"></p>
<h3 id="goroutine泄漏"><a href="#goroutine泄漏" class="headerlink" title="goroutine泄漏"></a>goroutine泄漏</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirroredQuery</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  responses := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;asia.gopl.io&quot;</span>) &#125;()</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;europe.gopl.io&quot;</span>) &#125;()</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; responses &lt;- request(<span class="string">&quot;americas.gopl.io&quot;</span>) &#125;()</span><br><span class="line">  <span class="keyword">return</span> &lt;-responses <span class="comment">// return the quickest response</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(hostname <span class="keyword">string</span>)</span> <span class="params">(response <span class="keyword">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住</strong>。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines 并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_0607_2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">	ch &lt;- <span class="number">2</span> <span class="comment">// 发生阻塞</span></span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot;yes&quot;</span>) <span class="comment">// 根本不会执行到这里</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> lines := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(lines)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为ch的存缓队列只有一个，当执行执行到<code>ch &lt;- 2</code>的时候就会阻塞，根本不会执行<code>fmt.Print(&quot;yes&quot;)</code>及其下面的代码</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails4</span><span class="params">(filenames []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  errors := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      _, err := thumbnail.ImageFile(f)</span><br><span class="line">      errors &lt;- err</span><br><span class="line">    &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> filenames &#123;</span><br><span class="line">      <span class="keyword">if</span> err := &lt;-errors; err != <span class="literal">nil</span> &#123;</span><br><span class="line">	      <span class="keyword">return</span> err <span class="comment">// <span class="doctag">NOTE:</span> incorrect: goroutine leak!</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序有一个微妙的bug。当它遇到第一个非nil的error时会直接将error返回到调用方，使得<strong>没有一个goroutine去排空errors channel</strong>。这样剩下的worker goroutine在向这个channel中发送值时，都会永远地阻塞下去，并且永远都不会退出。这种情况叫做goroutine泄露。可能会导致整个程序卡住或者跑出out of memory的错误。</p>
<p>最简单的解决办法就是用一个具有合适大小的buffered channel，这样这些worker goroutine向 channel中发送错误时就不会被阻塞。(一个可选的解决办法是创建一个另外的goroutine，当 main goroutine返回第一个错误的同时去排空channel)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails5</span><span class="params">(filenames []<span class="keyword">string</span>)</span> <span class="params">(thumbfiles []<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">type</span> item <span class="keyword">struct</span> &#123;</span><br><span class="line">    thumbfile <span class="keyword">string</span></span><br><span class="line">    err error</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> item, <span class="built_in">len</span>(filenames))</span><br><span class="line">  <span class="keyword">for</span> _, f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">var</span> it item</span><br><span class="line">      it.thumbfile, it.err = thumbnail.ImageFile(f)</span><br><span class="line">      ch &lt;- it</span><br><span class="line">    &#125;(f)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    it := &lt;-ch</span><br><span class="line">    <span class="keyword">if</span> it.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, it.err</span><br><span class="line">    &#125;</span><br><span class="line">    thumbfiles = <span class="built_in">append</span>(thumbfiles, it.thumbfile)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> thumbfiles, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>更好的方法是使用sync.WaitGroup</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails6</span><span class="params">(filenames &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">  sizes := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int64</span>)</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> f := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// worker</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      thumb, err := thumbnail.ImageFile(f)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      info, _ := os.Stat(thumb) <span class="comment">// OK to ignore error</span></span><br><span class="line">      sizes &lt;- info.Size()</span><br><span class="line">    &#125;(f)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// closer</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(sizes)</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> total <span class="keyword">int64</span></span><br><span class="line">  <span class="keyword">for</span> size := <span class="keyword">range</span> sizes &#123;</span><br><span class="line">    total += size</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20210605160818119.png" alt="image-20210605160818119"></p>
<h2 id="并发的字典遍历"><a href="#并发的字典遍历" class="headerlink" title="并发的字典遍历"></a>并发的字典遍历</h2><h3 id="Go-并发加入进度条功能"><a href="#Go-并发加入进度条功能" class="headerlink" title="Go 并发加入进度条功能"></a>Go 并发加入进度条功能</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProgress</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			c &lt;- i</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(c)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> num, ok := &lt;-c:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="keyword">break</span> LOOP</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;print:&quot;</span>, num)</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.Tick(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">			fmt.Println(<span class="string">&quot;this is Tick&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多goroutine共用channel并关闭"><a href="#多goroutine共用channel并关闭" class="headerlink" title="多goroutine共用channel并关闭"></a>多goroutine共用channel并关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFileLines</span><span class="params">(linesChan <span class="keyword">chan</span> <span class="keyword">string</span>, filePath <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fi, err := os.Open(filePath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Error: %s\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fi.Close()</span><br><span class="line"></span><br><span class="line">	scanner := bufio.NewScanner(fi)</span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		scanner.Bytes()</span><br><span class="line">		linesChan &lt;- scanner.Text()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test100</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	filePaths := []<span class="keyword">string</span>&#123;<span class="string">&quot;nginxApi.log&quot;</span>&#125;</span><br><span class="line">	linesChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">		<span class="keyword">for</span> _, filePath := <span class="keyword">range</span> filePaths &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(filePath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">				<span class="keyword">defer</span> wg.Done()</span><br><span class="line">				<span class="keyword">if</span> err := readFileLines(linesChan, filePath); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Fatal(err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(filePath)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="built_in">close</span>(linesChan)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> lines := <span class="keyword">range</span> linesChan &#123;</span><br><span class="line">		fmt.Println(lines)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="goroutine的退出"><a href="#goroutine的退出" class="headerlink" title="goroutine的退出"></a>goroutine的退出</h3><p>已经关闭的channel执行<code>case &lt;- chan</code>会被捕获成功：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelled</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExitGoroutine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	fmt.Println(cancelled()) <span class="comment">// false</span></span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	fmt.Println(cancelled()) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelled</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- done:</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跑一个goroutine单独去监听关闭条件</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  os.Stdin.Read(<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>))</span><br><span class="line">  <span class="built_in">close</span>(done)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;- done:</span><br><span class="line">    <span class="comment">// 在关闭之前需要排空其他chan剩余的东西</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> fileChan &#123;</span><br><span class="line">			<span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">case</span> file, ok := &lt;- fileChan &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// walkDir这个goroutine一启动就会轮询取消状态，如果取消状态被设置的话会直接返回，并且不做额外的事情。这样我们将所有在取消事件之后创建的goroutine改变为无操作。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkDir</span><span class="params">(dir <span class="keyword">string</span>, n *sync.WaitGroup, fileSizes <span class="keyword">chan</span>&lt;- <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> n.Done()</span><br><span class="line">  <span class="keyword">if</span> cancelled() &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, entry := <span class="keyword">range</span> dirents(dir) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="基于共享变量的并发"><a href="#基于共享变量的并发" class="headerlink" title="基于共享变量的并发"></a>基于共享变量的并发</h1><blockquote>
<p>并发安全(concurrency-safe)：也叫线程安全。</p>
</blockquote>
<p>数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。</p>
<p>根据上述定义，有三种方式可以避免数 据竞争：</p>
<ul>
<li><p>不要去写变量</p>
<p>初始化的时候，就把变量写好了，等并发的时候就只是读取。</p>
</li>
<li><p>避免从多个goroutine访问变量</p>
<blockquote>
<p>不要使用共享数据来通信；使用通信来共享数据。</p>
<p>一个提供对一个指定的变量通过channel来请求的goroutine叫做这个变量的监控 (monitor)goroutine</p>
</blockquote>
</li>
<li><p>允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。这种方式被称为“互斥”</p>
</li>
</ul>
<h2 id="使用channel实现互斥锁"><a href="#使用channel实现互斥锁" class="headerlink" title="使用channel实现互斥锁"></a>使用channel实现互斥锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>) <span class="comment">// a binary semaphore guarding balance</span></span><br><span class="line">  balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// acquire token</span></span><br><span class="line">  balance = balance + amount</span><br><span class="line">  &lt;-sema <span class="comment">// release token</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// acquire token</span></span><br><span class="line">  b := balance</span><br><span class="line">  &lt;-sema <span class="comment">// release token</span></span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="golang不支持可重入锁"><a href="#golang不支持可重入锁" class="headerlink" title="golang不支持可重入锁"></a>golang不支持可重入锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存款</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  balance = balance + amount</span><br><span class="line">  mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> not atomic!</span></span><br><span class="line"><span class="comment">// 取钱函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  Deposit(-amount)</span><br><span class="line">  <span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">    Deposit(amount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 存款不足</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当过多的取款操作同时执行时， balance可能会瞬时被减到0以下。这可能会引起一个并发的取款被不合逻辑地拒绝。</p>
<blockquote>
<p>因为没有锁住withdraw整个函数，会出现下面情况：</p>
<p>goroutineA执行完毕<code>Deposit(-amount)</code>后，跳转到goroutineB执行<code>Deposit(-amount)</code></p>
</blockquote>
<p>这里的问题是取款 不是一个原子操作：它包含了三个步骤，每一步都需要去获取并释放互斥锁，但任何一次锁 都不会锁上整个取款流程。</p>
<blockquote>
<p>理想情况下，取款应该只在整个操作中获得一次互斥锁。下面这样的尝试是错误的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  mu.Lock() <span class="comment">// 加锁</span></span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  Deposit(-amount)</span><br><span class="line">  <span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">    Deposit(amount)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Deposit会调用mu.Lock()第二次去获取互斥锁，但因为mutex已经锁上了， 而无法被重入</p>
</blockquote>
<p>一个通用的解决方案是<strong>将Deposit变成一个线程不安全的函数，由外部的Mutex提供线程安全</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  deposit(-amount)</span><br><span class="line">  <span class="keyword">if</span> balance &lt; <span class="number">0</span> &#123;</span><br><span class="line">    deposit(amount)</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  deposit(amount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function requires that the lock be held.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123; balance += amount &#125;</span><br></pre></td></tr></table></figure>



<h2 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x = <span class="number">1</span> <span class="comment">// A1</span></span><br><span class="line">  fmt.Print(<span class="string">&quot;y:&quot;</span>, y, <span class="string">&quot; &quot;</span>) <span class="comment">// A2</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  y = <span class="number">1</span> <span class="comment">// B1</span></span><br><span class="line">  fmt.Print(<span class="string">&quot;x:&quot;</span>, x, <span class="string">&quot; &quot;</span>) <span class="comment">// B2</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们自认为有几种不同的交错执行时的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y:0 x:1</span><br><span class="line">x:0 y:1</span><br><span class="line">x:1 y:1</span><br><span class="line">y:1 x:1</span><br></pre></td></tr></table></figure>

<p>第四行可以被解释为执行顺序A1,B1,A2,B2或者B1,A1,A2,B2的执行结果。</p>
<p> 然而实际的运行时，还是有下面的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x:0 y:0</span><br><span class="line">y:0 x:0</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的；也就是说goroutine是顺序连贯的。</li>
<li>但是在不使用channel、mutex这样的显式同步操作时，我们就没法保证<strong>事件在不同的goroutine中看到的执行顺序是一致的</strong>。尽管goroutineA中一定需要观察到x=1执行成功之后才会去读取y，但它<strong>没法确保goroutineB中对y的写入</strong>，所以A还可能会打印出y的一个旧版的值。</li>
<li>因为赋值和打印指向不同的变量，<strong>编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序</strong>。如果两个goroutine在不同的CPU上执行，每一个核心有自己的缓存，这样一个goroutine的写入对于其它goroutine的Print，在主存同步之前就是不可见的了。</li>
<li>所有并发的问题都可以用一致的、简单的既定的模式来规避。<ul>
<li>将变量限定在goroutine内部</li>
<li>如果是多个goroutine都需要访问的变量，使用互斥条件来访问。</li>
</ul>
</li>
</ul>
<h2 id="并发的非阻塞缓存"><a href="#并发的非阻塞缓存" class="headerlink" title="并发的非阻塞缓存"></a>并发的非阻塞缓存</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">  res result</span><br><span class="line">  ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed when res is ready</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f Func)</span> *<span class="title">Memo</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*entry)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">  f Func</span><br><span class="line">  mu sync.Mutex <span class="comment">// guards cache</span></span><br><span class="line">  cache <span class="keyword">map</span>[<span class="keyword">string</span>]*entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">  memo.mu.Lock()</span><br><span class="line">  e := memo.cache[key]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// This is the first request for this key.</span></span><br><span class="line">    <span class="comment">// This goroutine becomes responsible for computing</span></span><br><span class="line">    <span class="comment">// the value and broadcasting the ready condition.</span></span><br><span class="line">    e = &amp;entry&#123;ready: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">    memo.cache[key] = e</span><br><span class="line">    memo.mu.Unlock()</span><br><span class="line">    e.res.value, e.res.err = memo.f(key)</span><br><span class="line">    <span class="built_in">close</span>(e.ready) <span class="comment">// broadcast ready condition</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// This is a repeat request for this key.</span></span><br><span class="line">    memo.mu.Unlock()</span><br><span class="line">    &lt;-e.ready <span class="comment">// wait for ready condition</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e.res.value, e.res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取互斥锁来保护共享变量cache map，查询map中是否存在指定条目，</li>
<li>如果没有找到那么分配空间插入一个新条目，释放互斥锁。</li>
<li>如果存在条目的 话且其值没有写入完成(也就是有其它的goroutine在调用f这个慢函数)时，goroutine必须等待值ready之后才能读到条目的结果。而<strong>想知道是否ready的话，可以直接从ready channel中读取</strong>，由于这个读取操作在channel关闭之前一直是阻塞。</li>
</ul>
<p>优化后，得到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memo</span><br><span class="line"></span><br><span class="line"><span class="comment">// Func is the type of the function to memoize.</span></span><br><span class="line"><span class="keyword">type</span> Func <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A result is the result of calling a Func.</span></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err   error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	res   result</span><br><span class="line">	ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed when res is ready</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A request is a message requesting that the Func be applied to key.</span></span><br><span class="line"><span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">	key      <span class="keyword">string</span></span><br><span class="line">	response <span class="keyword">chan</span>&lt;- result <span class="comment">// the client wants a single result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span>&#123; requests <span class="keyword">chan</span> request &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns a memoization of f.  Clients must subsequently call Close.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f Func)</span> *<span class="title">Memo</span></span> &#123;</span><br><span class="line">	memo := &amp;Memo&#123;requests: <span class="built_in">make</span>(<span class="keyword">chan</span> request)&#125;</span><br><span class="line">	<span class="keyword">go</span> memo.server(f)</span><br><span class="line">	<span class="keyword">return</span> memo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	response := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line">	memo.requests &lt;- request&#123;key, response&#125;</span><br><span class="line">	res := &lt;-response</span><br><span class="line">	<span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Close</span><span class="params">()</span></span> &#123; <span class="built_in">close</span>(memo.requests) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">server</span><span class="params">(f Func)</span></span> &#123;</span><br><span class="line">	cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*entry)</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> memo.requests &#123;</span><br><span class="line">		e := cache[req.key]</span><br><span class="line">		<span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// This is the first request for this key.</span></span><br><span class="line">			e = &amp;entry&#123;ready: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">			cache[req.key] = e</span><br><span class="line">			<span class="keyword">go</span> e.call(f, req.key) <span class="comment">// call f(key)</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> e.deliver(req.response)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">call</span><span class="params">(f Func, key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Evaluate the function.</span></span><br><span class="line">	e.res.value, e.res.err = f(key)</span><br><span class="line">	<span class="comment">// Broadcast the ready condition.</span></span><br><span class="line">	<span class="built_in">close</span>(e.ready)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">deliver</span><span class="params">(response <span class="keyword">chan</span>&lt;- result)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Wait for the ready condition.</span></span><br><span class="line">	&lt;-e.ready</span><br><span class="line">	<span class="comment">// Send the result to the client.</span></span><br><span class="line">	response &lt;- e.res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Goroutines和线程"><a href="#Goroutines和线程" class="headerlink" title="Goroutines和线程"></a>Goroutines和线程</h2><ul>
<li>OS线程会被操作系统内核调度。</li>
<li>每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会挂起当前执行的线程并保存内存中它的寄存器内容，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。</li>
<li>因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。</li>
</ul>
<ul>
<li>Go调度器的工作和内核的调度是相似 的，但是这个调度器只关注单独的Go程序中的goroutine(按程序独立)。</li>
<li>例如当一个goroutine调用了time.Sleep或者被channel调用或者mutex操作阻 塞时，调度器会使其进入休眠并开始执行另一个goroutine直到时机到了再去唤醒第一个 goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度 一个线程代价要低得多。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">go</span> fmt.Print(<span class="number">0</span>)</span><br><span class="line">  fmt.Print(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ GOMAXPROCS=<span class="number">1</span> <span class="keyword">go</span> run hacker-cliché.<span class="keyword">go</span></span><br><span class="line"><span class="number">111111111111111111110000000000000000000011111.</span>..</span><br><span class="line">$ GOMAXPROCS=<span class="number">2</span> <span class="keyword">go</span> run hacker-cliché.<span class="keyword">go</span></span><br><span class="line"><span class="number">010101010101010101011001100101011010010100110.</span>..</span><br></pre></td></tr></table></figure>

<ul>
<li>在第一次执行时，最多同时只能有一个goroutine被执行。初始情况下只有main goroutine被执行，所以会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个 goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。</li>
<li>在第二次执行时，我们使用了两个操作系统线程，所以<strong>两个goroutine可以一起被执行， 以同样的频率交替打印0和1</strong>。</li>
<li>必须强调的是goroutine的调度是受很多因子影响的，而 runtime也是在不断地发展演进的，所以这里的你实际得到的结果可能会因为版本的不同而与我们运行的结果有所不同。</li>
</ul>
<h3 id="Goroutine没有ID号"><a href="#Goroutine没有ID号" class="headerlink" title="Goroutine没有ID号"></a>Goroutine没有ID号</h3><p>goroutine没有可以被程序员获取到的身份(id)的概念。这一点是设计上故意而为之，由于 thread-local storage总是会被滥用。</p>
<h1 id="包和工具"><a href="#包和工具" class="headerlink" title="包和工具"></a>包和工具</h1><p>Go语言的闪电般的编译速度主要得益于三个语言特性。</p>
<ul>
<li>所有导入的包必须在每个文件的开头显式声明， 这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li>
<li>禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。</li>
<li>编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（很多都是重复的间接依赖）。</li>
</ul>
<p>默认包名一般采用导入路径名的最后一段的约定也有三种例外情况</p>
<ul>
<li>包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为 main的包是给go build构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。</li>
<li>包所在的目录中可能有一些文件名是以 _test.go 为后缀的Go源文件，并且这些源文件声 明的包名也是以 _test 为后缀名的。</li>
<li>一些依赖版本号的管理工具会在导入路径后追加版本号信息，例 如”gopkg.in/yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml。</li>
</ul>
<p>有些包可能需要<strong>针对不同平台和处理器类型使用不同版本的代码文件</strong>，以便于处理底层的可移植性问题或为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。</p>
<p>还有一个特别的构建注释参数可以提供更多的构建过程控制。例如，文件中可能包含下面的注释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build linux darwin</span></span><br></pre></td></tr></table></figure>

<p>在包声明和包注释的前面，该构建注释参数告诉 go build 只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。</p>
<p>下面的构建注释则表示不编译这个文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build ignore</span></span><br></pre></td></tr></table></figure>



<h2 id="内部包"><a href="#内部包" class="headerlink" title="内部包"></a>内部包</h2><p>没有导出的标识符只在同一个包内部可以访问， 而导出的标识符则是面向全宇宙都是可见的。</p>
<p>有时候，可能需要一个中间的状态，标识符对于一小部分信任的包是可见的，但并不 是对所有调用者都可见。</p>
<blockquote>
<p>例如，</p>
<ul>
<li>当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，</li>
<li>或者我们只是想实验一个新包的还并不稳定的接口，暂时只暴露给一些受限制的用户使用。</li>
</ul>
</blockquote>
<p>为了满足这些需求，Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处 理。这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。</p>
<p>例如，</p>
<ul>
<li>net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被 net/url包导入。</li>
<li>不过net/url包却可以导入net/http/httputil包。</li>
</ul>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul>
<li>一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确； go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。</li>
<li>基准测试函数是以 Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；</li>
</ul>
<p>测试覆盖率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool cover</span><br></pre></td></tr></table></figure>

<p>生成HTML报告：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool cover -html=c.o</span><br></pre></td></tr></table></figure>



<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>基准测试是测量一个程序在固定工作负载下的性能。</p>
<p>在Go语言中，基准测试函数和普通测试 函数写法类似，但是以Benchmark为前缀名，并且带有一个 <code>*testing.B</code> 类型的参数； <code>*testing.B </code>参数除了提供和 *testing.T 类似的方法，还有额外一些和性能测量相关的方 法。它还提供了一个整数N，用于指定操作执行的循环次数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsPalindrome函数的基准测试，其中循环将执行N次。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIsPalindrome</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">    IsPalindrome(<span class="string">&quot;A man, a plan, a canal: Panama&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和普通测试不同的是，默认情况下不运行任何基准测试。 我们需要通过 -bench 命令行标志参数手工指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中“.”模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和 -bench=IsPalindrome参数是等价 的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=.</span><br></pre></td></tr></table></figure>



<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><strong>在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射</strong>。</p>
<p> reflect 包定义了两个重要的类型, Type 和 Value. </p>
<ul>
<li><strong>一个 Type 表示一个 Go类型</strong>. 它是一个接口, 有许多方法来区分类型和检查它们的组件, 例如一个结构体的成员或一个函数的参数等. 唯一能反映 reflect.Type 实现的是接口的类型描述信息，同样的实体标识了动态类型的接口值.</li>
<li><strong>一个 reflect.Value 可以持有一个任意类型的值</strong>. 函数 reflect.ValueOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Value.</li>
</ul>
<p>函数 reflect.TypeOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Type:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(<span class="number">3</span>) <span class="comment">// a reflect.Type</span></span><br><span class="line">fmt.Println(t.String()) <span class="comment">// &quot;int&quot;</span></span><br><span class="line">fmt.Println(t) <span class="comment">// &quot;int&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 reflect.TypeOf 返回的是一个动态类型的接口值, 它总是返回具体的类型. </span></span><br><span class="line"><span class="comment">// 因此, 下面的代码将打印 &quot;*os.File&quot; 而不是 &quot;io.Writer&quot;</span></span><br><span class="line"><span class="keyword">var</span> w io.Writer = os.Stdout</span><br><span class="line">fmt.Println(reflect.TypeOf(w)) <span class="comment">// &quot;*os.File&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：fmt.Printf 提供的简短的 %T 标志参数, 内部就是使用 reflect.TypeOf 的结果输出</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> format</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any formats any value as a string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Any</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> formatAtom(reflect.ValueOf(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// formatAtom formats a value without inspecting its internal structure.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatAtom</span><span class="params">(v reflect.Value)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;invalid&quot;</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16,reflect.Int32, reflect.Int64:</span><br><span class="line">		<span class="keyword">return</span> strconv.FormatInt(v.Int(), <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16,reflect.Uint32, reflect.Uint64, reflect.Uintptr:</span><br><span class="line">		<span class="keyword">return</span> strconv.FormatUint(v.Uint(), <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// ...floating-point and complex cases omitted for brevity...</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">return</span> strconv.FormatBool(v.Bool())</span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		<span class="keyword">return</span> strconv.Quote(v.String())</span><br><span class="line">	<span class="keyword">case</span> reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:</span><br><span class="line">		<span class="keyword">return</span> v.Type().String() + <span class="string">&quot; 0x&quot;</span> +</span><br><span class="line">			strconv.FormatUint(<span class="keyword">uint64</span>(v.Pointer()), <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// reflect.Array, reflect.Struct, reflect.Interface</span></span><br><span class="line">		<span class="keyword">return</span> v.Type().String() + <span class="string">&quot; value&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> d time.Duration = <span class="number">1</span> * time.Nanosecond</span><br><span class="line">fmt.Println(format.Any(x)) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">fmt.Println(format.Any(d)) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">fmt.Println(format.Any([]<span class="keyword">int64</span>&#123;x&#125;)) <span class="comment">// &quot;[]int64 0x8202b87b0&quot;</span></span><br><span class="line">fmt.Println(format.Any([]time.Duration&#123;d&#125;)) <span class="comment">// &quot;[]time.Duration 0x8202b87e0&quot;</span></span><br></pre></td></tr></table></figure>



<h1 id="底层编程"><a href="#底层编程" class="headerlink" title="底层编程"></a>底层编程</h1><p>略</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>