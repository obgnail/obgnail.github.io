<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="groupcache 不像其它的一些缓存数据库有个服务端，需要客户端去连接，换句话说，它本没有服务端或者人人都是服务端。相对于 memcached，groupcache 提供更小的功能集和更高的效率，以第三方库的形式提供服务"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>groupcache | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-07-19</div></div></div><div class="container post-header"><h1>groupcache</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#groupcache-%E4%B8%8E-memcached-%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">1.</span> <span class="toc-text">groupcache 与 memcached 的不同之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">使用示例</span></a></li></ol></details></div><div class="container post-content"><p>groupcache 不像其它的一些缓存数据库有个服务端，需要客户端去连接，换句话说，它本没有服务端或者人人都是服务端。相对于 memcached，groupcache 提供更小的功能集和更高的效率，以第三方库的形式提供服务</p>
<h2 id="groupcache-与-memcached-的不同之处"><a href="#groupcache-与-memcached-的不同之处" class="headerlink" title="groupcache 与 memcached 的不同之处"></a>groupcache 与 memcached 的不同之处</h2><ul>
<li>不需要对服务器进行单独的设置，这将大幅度减少部署和配置的工作量。groupcache 既是客户端库也是服务器库，并连接到自己的 peer 上。</li>
<li>具有缓存过滤机制。众所周知，在 memcached 出现“Sorry，cache miss（缓存丢失）”时，经常会因为不受控制用户数量的请求而导致数据库（或者其它组件）产生“惊群效应（thundering herd）”；groupcache 会协调缓存填充，只会将重复调用中的一个放于缓存，而处理结果将发送给所有相同的调用者。</li>
<li><strong>不支持多个版本的值</strong>。如果“foo”键对应的值是“bar”，那么键“foo”的值永远都是“bar”。这里既没有缓存的有效期，也没有明确的缓存回收机制，因此同样也没有 <code>CAS</code> 或者 <code>Increment/Decrement</code>。</li>
<li>基于上一点的改变，groupcache 就具备了自动备份“超热”项进行多重处理，这就避免了 memcached 中对某些键值过量访问而造成所在机器 CPU 或者 NIC 过载。</li>
</ul>
<blockquote>
<p>一旦写进去后就不会变动。在放弃update/delete 的特性后，换来的是： </p>
<ul>
<li>Cluster 的能力。 </li>
<li>处理热点的能力。</li>
</ul>
</blockquote>
<p>groupcache 避免多次非缓存查询， 并且支持多节点缓存（即便多节点，也还支持同一个key同一时刻只查询一次）。除此之外还支持分组，不同分组有各自的查询方式和缓存，分组只是逻辑上的，互不影响，所以这里分组同一分组的情况。</p>
<p>groupcache 没有支持 cache 的过期时间，而是限制 cache 的总内存大小，通过 LRU 的方法使用 cache ，到达上限后，最少被使用的会被最先清除出缓存。</p>
<p>groupcache 在此基础上，添加了多节点的支持，每个节点(peer)都有缓存，只缓存属于它的key（通过将字符串key平均分到不同的peer）。</p>
<p>不同的peer只负责查询和缓存它的属于它的key。如果一个peer接收到不属于它的key，它就转发到别的peer上进行查询。</p>
<p>什么 key 属于哪个 peer 通过一个神奇的hash算法实现的。</p>
<p><strong>只加载一次</strong>是 groupcache 最重要的特性，groupcache可以阻止加载两次，因为一次Load操作开始并未完成前，后面的其它查询都会等待这个结果，这其它查询包括从本地的查询和从别的节点的查询。</p>
<p>假设一种查询路经(这个例子中，耗时的操作只在peer2中进行了一次):</p>
<ul>
<li>查询节点peer1，查询的key不属于peer1</li>
<li>peer1发现这个key属于peer2，以同一key查询peer2</li>
<li>peer2发现该key属于自己，但没有自己的缓存中</li>
<li>peer2发起耗时查询（比如DB查询)并等待完成</li>
<li>再次以同一key查询节点peer1，但是peer1还有同一个key的查询还未完成，所以阻塞等待</li>
<li>以同一key查询peer2, peer2发现这个key属于自己，但没有自己的缓存中</li>
<li>peer2发起查询，但是peer2的同一个key还在查询，所以等待。</li>
<li>peer2的第一个查询完成，并放到peer2的main cache中 。peer2的第二个查询被通知，得到同一结果。</li>
<li>peer2的第一个查询是peer1转发来的，所以结果被返回peer1，并被放到peer1的hot cache中，peer1的第一个查询结束。peer1的第二个被阻塞的查询也被通知而拿到了结果。</li>
</ul>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><ul>
<li>groupcache由于是框架，需要导入在编写业务代码才能运作</li>
<li>缓存方式可自定义：db，文件等</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/golang/groupcache&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TblCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id    <span class="keyword">int</span></span><br><span class="line">	Key   <span class="keyword">string</span></span><br><span class="line">	Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义节点数量以及地址</span></span><br><span class="line">	peers_addrs := []<span class="keyword">string</span>&#123;<span class="string">&quot;http://127.0.0.1:8001&quot;</span>, <span class="string">&quot;http://127.0.0.1:8002&quot;</span>&#125;</span><br><span class="line">	db, _ := sql.Open(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;./console.db&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;local_addr must in(127.0.0.1:8001,127.0.0.1:8002)&quot;</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	local_addr := os.Args[<span class="number">1</span>]</span><br><span class="line">	peers := groupcache.NewHTTPPool(<span class="string">&quot;http://&quot;</span> + local_addr)</span><br><span class="line">	peers.Set(peers_addrs...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取group对象</span></span><br><span class="line">	image_cache := groupcache.NewGroup(<span class="string">&quot;testGroup&quot;</span>, <span class="number">8</span>&lt;&lt;<span class="number">30</span>,</span><br><span class="line">		<span class="comment">// 自定义数据获取来源</span></span><br><span class="line">		groupcache.GetterFunc(</span><br><span class="line">			<span class="function"><span class="keyword">func</span><span class="params">(ctx groupcache.Context, key <span class="keyword">string</span>, dest groupcache.Sink)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">				rows, _ := db.Query(<span class="string">&quot;SELECT key, value FROM tbl_cache_map where key = ?&quot;</span>, key)</span><br><span class="line">				<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">					p := <span class="built_in">new</span>(TblCache)</span><br><span class="line">					err := rows.Scan(&amp;p.Key, &amp;p.Value)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						fmt.Println(err)</span><br><span class="line">					&#125;</span><br><span class="line">					fmt.Printf(<span class="string">&quot;get %s of value from tbl_cache_map\n&quot;</span>, key)</span><br><span class="line">					dest.SetString(<span class="string">&quot;tbl_cache_map.value : &quot;</span> + p.Value)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;,</span><br><span class="line">		),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义返回方式</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/get&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> data []<span class="keyword">byte</span></span><br><span class="line">		k := r.URL.Query().Get(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;user get %s of value from groupcache\n&quot;</span>, k)</span><br><span class="line">		image_cache.Get(<span class="literal">nil</span>, k, groupcache.AllocatingByteSliceSink(&amp;data))</span><br><span class="line">		rw.Write([]<span class="keyword">byte</span>(data))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	log.Fatal(http.ListenAndServe(local_addr, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>groupcache.NewGroup() 获取group对象</li>
<li>groupcache.GetterFunc() 定义数据缓存方式</li>
<li>http.HandleFunc() 定义返回方式</li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>