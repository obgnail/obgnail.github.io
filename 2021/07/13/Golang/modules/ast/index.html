<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;Tokenizer-和-Lexical-anaylizer&quot;&gt;&lt;a href=&quot;#Tokenizer-和-Lexical-anaylizer&quot; class=&quot;headerlink&quot; title=&quot;Tokenizer 和 Lexical anaylizer&quot;&gt;&lt;/a&gt;Tokenizer 和 Lexical anaylizer&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这段&lt;strong&gt;go&lt;/strong&gt;代码做了什么？很简单吧，package是main，定义了个main函数，main函数里调用了println函数，参数是“Hello, World!”。好，你是知道了，可当你运行&lt;strong&gt;go&lt;/strong&gt; run时，&lt;strong&gt;go&lt;/strong&gt;怎么知道的？"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>ast | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-07-13</div></div></div><div class="container post-header"><h1>ast</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tokenizer-%E5%92%8C-Lexical-anaylizer"><span class="toc-number">1.1.</span> <span class="toc-text">Tokenizer 和 Lexical anaylizer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E7%9A%84AST"><span class="toc-number">1.2.</span> <span class="toc-text">Go的AST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Go%E7%9A%84AST-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">Go的AST(抽象语法树)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E7%9A%84AST%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E7%9A%84%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">Go的AST内部是如何组织的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">语法树的生成过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">遍历语法树</span></a></li></ol></details></div><div class="container post-content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Tokenizer-和-Lexical-anaylizer"><a href="#Tokenizer-和-Lexical-anaylizer" class="headerlink" title="Tokenizer 和 Lexical anaylizer"></a>Tokenizer 和 Lexical anaylizer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="built_in">println</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段<strong>go</strong>代码做了什么？很简单吧，package是main，定义了个main函数，main函数里调用了println函数，参数是“Hello, World!”。好，你是知道了，可当你运行<strong>go</strong> run时，<strong>go</strong>怎么知道的？</p>
<p><strong>go先要把你的代码打散成自己可以理解的构成部分（token），这一过程就叫tokenize。</strong></p>
<p>例如，第一行就被拆成了package和main。 这个阶段，<strong>go</strong>就像小婴儿只会理解我、要、吃饭等词，但串不成合适句子。因为“吃饭我要”是讲不通的，所以<strong>把词按一定的语法串起来的过程就是lexical anaylize</strong>或者parse，简单吧！和人脑不同的是，被程序理解的代码，通常会以abstract syntax tree（<strong>AST</strong>）的形式存储起来，方便进行校验和查找。</p>
<h2 id="Go的AST"><a href="#Go的AST" class="headerlink" title="Go的AST"></a>Go的AST</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;go/ast&quot;</span></span><br><span class="line">	<span class="string">&quot;go/parser&quot;</span></span><br><span class="line">	<span class="string">&quot;go/token&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这就是上一章的代码.</span></span><br><span class="line">	src := <span class="string">`</span></span><br><span class="line"><span class="string">package main</span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">	println(&quot;Hello, World!&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create the AST by parsing src.</span></span><br><span class="line">	fset := token.NewFileSet() <span class="comment">// positions are relative to fset</span></span><br><span class="line">	f, err := parser.ParseFile(fset, <span class="string">&quot;&quot;</span>, src, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Print the AST.</span></span><br><span class="line">	ast.Print(fset, f)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了不吓到你，我先只打印前6行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0  *ast.File &#123;</span><br><span class="line">1  .  Package: 2:1</span><br><span class="line">2  .  Name: *ast.Ident &#123;</span><br><span class="line">3  .  .  NamePos: 2:9</span><br><span class="line">4  .  .  Name: &quot;main&quot;</span><br><span class="line">5  .  &#125;</span><br><span class="line">// 省略之后的50＋行</span><br></pre></td></tr></table></figure>

<p>可见，<strong>go</strong> 解析出了package这个关键词在文本的第二行的第一个（2:1）。“main”也解析出来了，在第二行的第9个字符，但是<strong>go</strong>的解析器还给它安了一个叫法：<strong>ast</strong>.Ident, 标示符 或者大家常说的ID，如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ident +------------+</span><br><span class="line">                   |                         </span><br><span class="line">Package +-----+    |</span><br><span class="line">              v    v</span><br><span class="line">           package main</span><br></pre></td></tr></table></figure>

<p>接下来我们看看那个main函数被整成了什么样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 6  .  Decls: []ast.Decl (len = 1) &#123;</span><br><span class="line"> 7  .  .  0: *ast.FuncDecl &#123;</span><br><span class="line"> 8  .  .  .  Name: *ast.Ident &#123;</span><br><span class="line"> 9  .  .  .  .  NamePos: 3:6</span><br><span class="line">10  .  .  .  .  Name: &quot;main&quot;</span><br><span class="line">11  .  .  .  .  Obj: *ast.Object &#123;</span><br><span class="line">12  .  .  .  .  .  Kind: func</span><br><span class="line">13  .  .  .  .  .  Name: &quot;main&quot;</span><br><span class="line">14  .  .  .  .  .  Decl: *(obj @ 7)</span><br></pre></td></tr></table></figure>

<p>此处func main被解析成<strong>ast</strong>.FuncDecl（function declaration）,而函数的参数（Params）和函数体（Body）自然也在这个FuncDecl中。Params对应的是<em><strong>ast</strong>.FieldList，顾名思义就是项列表；而由大括号“｛｝”组成的函数体对应的是</em><em>ast</em>*.BlockStmt（block statement）。如果不清楚，可以参考下面的图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                 FuncDecl.Params +----------+</span><br><span class="line">                                            |</span><br><span class="line">                   FuncDecl.Name +--------+ |</span><br><span class="line">                                          v v</span><br><span class="line">          +----------------------&gt; func main() &#123;</span><br><span class="line">          |                    +-&gt;</span><br><span class="line">FuncDecl ++    FuncDecl.Body +-+       println(&quot;Hello, World!&quot;)</span><br><span class="line">          |                    +-&gt;</span><br><span class="line">          +----------------------&gt; &#125;</span><br></pre></td></tr></table></figure>

<p>而对于main函数的函数体中，我们可以看到调用了println函数，在<strong>ast</strong>中对应的是ExprStmt（Express Statement），调用函数的表达式对应的是CallExpr(Call Expression)，调用的参数自然不能错过，因为参数只有字符串，所以<strong>go</strong>把它归为<strong>ast</strong>.BasicLis (a literal of basic type)。如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----+ ExprStmt +---------------+</span><br><span class="line">|                                |</span><br><span class="line">|    CallExpr   BasicLit         |</span><br><span class="line">|        +          +            |</span><br><span class="line">|        v          v            |</span><br><span class="line">+---&gt; println(&quot;Hello, World!&quot;)&lt;--+</span><br></pre></td></tr></table></figure>



<p>还有什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">50  .  Scope: *ast.Scope &#123;</span><br><span class="line">51  .  .  Objects: map[string]*ast.Object (len = 1) &#123;</span><br><span class="line">52  .  .  .  &quot;main&quot;: *(obj @ 11)</span><br><span class="line">53  .  .  &#125;</span><br><span class="line">54  .  &#125;</span><br><span class="line">55  .  Unresolved: []*ast.Ident (len = 1) &#123;</span><br><span class="line">56  .  .  0: *(obj @ 29)</span><br><span class="line">57  .  &#125;</span><br><span class="line">58  &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看出<strong>ast</strong>还解析出了函数的作用域，以及作用域对应的对象。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>Go</strong>将所有可以识别的token抽象成Node，通过interface方式组织在一起，它们之间的关系如下图示意：</p>
<p><img src="/images/golang_ast_relation.png" alt="golang_ast_relation"></p>
<ul>
<li>ast.Expr - 代表表达式和类型的节点</li>
<li>ast.Stmt - 代表报表节点</li>
<li>ast.Decl - 代表声明节点</li>
</ul>
<h1 id="Go的AST-抽象语法树"><a href="#Go的AST-抽象语法树" class="headerlink" title="Go的AST(抽象语法树)"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28516587">Go的AST(抽象语法树)</a></h1><h2 id="Go的AST内部是如何组织的？"><a href="#Go的AST内部是如何组织的？" class="headerlink" title="Go的AST内部是如何组织的？"></a>Go的AST内部是如何组织的？</h2><p>我们知道，根据编译过程，一般来说首先我们需要词法分析，然后才有语法分析。</p>
<p>Go的parser接受的输入是源文件,内嵌了一个scanner,最后把scanner生成的token变成一颗抽象语法树(AST)。</p>
<p>我们现在打印下输出hello,world的抽象语法树。这也是官网的例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;go/ast&quot;</span></span><br><span class="line">	<span class="string">&quot;go/parser&quot;</span></span><br><span class="line">	<span class="string">&quot;go/token&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// src is the input for which we want to print the AST.</span></span><br><span class="line">	src := <span class="string">`</span></span><br><span class="line"><span class="string">package main</span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">	println(&quot;Hello, World!&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create the AST by parsing src.</span></span><br><span class="line">	fset := token.NewFileSet() <span class="comment">// positions are relative to fset</span></span><br><span class="line">	f, err := parser.ParseFile(fset, <span class="string">&quot;&quot;</span>, src, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Print the AST.</span></span><br><span class="line">	ast.Print(fset, f)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看下语法树，解释下都有哪些东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">0  *ast.File &#123;</span><br><span class="line">     1  .  Package: 2:1</span><br><span class="line">     2  .  Name: *ast.Ident &#123;</span><br><span class="line">     3  .  .  NamePos: 2:9</span><br><span class="line">     4  .  .  Name: &quot;main&quot;</span><br><span class="line">     5  .  &#125;</span><br><span class="line">     6  .  Decls: []ast.Decl (len = 1) &#123;</span><br><span class="line">     7  .  .  0: *ast.FuncDecl &#123;</span><br><span class="line">     8  .  .  .  Name: *ast.Ident &#123;</span><br><span class="line">     9  .  .  .  .  NamePos: 3:6</span><br><span class="line">    10  .  .  .  .  Name: &quot;main&quot;</span><br><span class="line">    11  .  .  .  .  Obj: *ast.Object &#123;</span><br><span class="line">    12  .  .  .  .  .  Kind: func</span><br><span class="line">    13  .  .  .  .  .  Name: &quot;main&quot;</span><br><span class="line">    14  .  .  .  .  .  Decl: *(obj @ 7)</span><br><span class="line">    15  .  .  .  .  &#125;</span><br><span class="line">    16  .  .  .  &#125;</span><br><span class="line">    17  .  .  .  Type: *ast.FuncType &#123;</span><br><span class="line">    18  .  .  .  .  Func: 3:1</span><br><span class="line">    19  .  .  .  .  Params: *ast.FieldList &#123;</span><br><span class="line">    20  .  .  .  .  .  Opening: 3:10</span><br><span class="line">    21  .  .  .  .  .  Closing: 3:11</span><br><span class="line">    22  .  .  .  .  &#125;</span><br><span class="line">    23  .  .  .  &#125;</span><br><span class="line">    24  .  .  .  Body: *ast.BlockStmt &#123;</span><br><span class="line">    25  .  .  .  .  Lbrace: 3:13</span><br><span class="line">    26  .  .  .  .  List: []ast.Stmt (len = 1) &#123;</span><br><span class="line">    27  .  .  .  .  .  0: *ast.ExprStmt &#123;</span><br><span class="line">    28  .  .  .  .  .  .  X: *ast.CallExpr &#123;</span><br><span class="line">    29  .  .  .  .  .  .  .  Fun: *ast.Ident &#123;</span><br><span class="line">    30  .  .  .  .  .  .  .  .  NamePos: 4:5</span><br><span class="line">    31  .  .  .  .  .  .  .  .  Name: &quot;println&quot;</span><br><span class="line">    32  .  .  .  .  .  .  .  &#125;</span><br><span class="line">    33  .  .  .  .  .  .  .  Lparen: 4:12</span><br><span class="line">    34  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) &#123;</span><br><span class="line">    35  .  .  .  .  .  .  .  .  0: *ast.BasicLit &#123;</span><br><span class="line">    36  .  .  .  .  .  .  .  .  .  ValuePos: 4:13</span><br><span class="line">    37  .  .  .  .  .  .  .  .  .  Kind: STRING</span><br><span class="line">    38  .  .  .  .  .  .  .  .  .  Value: &quot;\&quot;Hello, World!\&quot;&quot;</span><br><span class="line">    39  .  .  .  .  .  .  .  .  &#125;</span><br><span class="line">    40  .  .  .  .  .  .  .  &#125;</span><br><span class="line">    41  .  .  .  .  .  .  .  Ellipsis: -</span><br><span class="line">    42  .  .  .  .  .  .  .  Rparen: 4:28</span><br><span class="line">    43  .  .  .  .  .  .  &#125;</span><br><span class="line">    44  .  .  .  .  .  &#125;</span><br><span class="line">    45  .  .  .  .  &#125;</span><br><span class="line">    46  .  .  .  .  Rbrace: 5:1</span><br><span class="line">    47  .  .  .  &#125;</span><br><span class="line">    48  .  .  &#125;</span><br><span class="line">    49  .  &#125;</span><br><span class="line">    50  .  Scope: *ast.Scope &#123;</span><br><span class="line">    51  .  .  Objects: map[string]*ast.Object (len = 1) &#123;</span><br><span class="line">    52  .  .  .  &quot;main&quot;: *(obj @ 11)</span><br><span class="line">    53  .  .  &#125;</span><br><span class="line">    54  .  &#125;</span><br><span class="line">    55  .  Unresolved: []*ast.Ident (len = 1) &#123;</span><br><span class="line">    56  .  .  0: *(obj @ 29)</span><br><span class="line">    57  .  &#125;</span><br><span class="line">    58  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Package: 2:1代表Go解析出package这个词在第二行的第一个</li>
<li>main是一个ast.Ident标识符，它的位置在第二行的第9个</li>
<li>此处func main被解析成ast.FuncDecl（function declaration）,而函数的参数（Params）和函数体（Body）自然也在这个FuncDecl中。Params对应的是*ast.FieldList，顾名思义就是项列表；而由大括号“｛｝”组成的函数体对应的是ast.BlockStmt（block statement）</li>
<li>而对于main函数的函数体中，我们可以看到调用了println函数，在ast中对应的是ExprStmt（Express Statement），调用函数的表达式对应的是CallExpr(Call Expression)，调用的参数自然不能错过，因为参数只有字符串，所以go把它归为ast.BasicLis (a literal of basic type)。</li>
<li>最后，我们可以看出ast还解析出了函数的作用域，以及作用域对应的对象。</li>
<li>Go将所有可以识别的token抽象成Node，通过interface方式组织在一起。</li>
<li>在这里说到token我们需要说一下词法分析，token是词法分析的结果，即将字符序列转换为标记(token)的过程，这个操作由词法分析器完成。这里的标记是一个字符串，是构成源代码的最小单位。</li>
</ul>
<h2 id="语法树的生成过程"><a href="#语法树的生成过程" class="headerlink" title="语法树的生成过程"></a>语法树的生成过程</h2><p><code>FileSet</code>就是源文件集合，因为我们一次解析可能不止解析一个文件，而是一系列文件。</p>
<p><code>FileSet</code>最主要的用途是用来保存<code>token</code>的位置信息，每个token在当前文件的位置可以用行号，列号，token在当前文件中的偏移量这三个属性来描述，使用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/go/token/position.go#L20"><code>Position</code></a>这个结构体来描述，<code>FileSet</code>中保存所有<code>token</code>的<code>Position</code>信息，而在<code>ast</code>中，只保存一个<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/go/token/position.go#L76"><code>Pos</code></a>索引。当遍历<code>ast</code>的时候，我们需要使用<code>Pos</code>索引向<a target="_blank" rel="noopener" href="https://mcll.top/2019/06/19/ast/"><code>FileSet</code></a>获取<code>Position</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fset := token.NewFileSet()</span><br></pre></td></tr></table></figure>

<p>新建一个AST文件集合，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileSet represents a set of source files.</span></span><br><span class="line"><span class="comment">// Methods of file sets are synchronized; multiple goroutines</span></span><br><span class="line"><span class="comment">// may invoke them concurrently.</span></span><br><span class="line"><span class="keyword">type</span> FileSet <span class="keyword">struct</span> &#123;</span><br><span class="line">	mutex sync.RWMutex <span class="comment">// 加锁保护</span></span><br><span class="line">	base  <span class="keyword">int</span>          <span class="comment">// 基准偏移</span></span><br><span class="line">	files []*File      <span class="comment">// 按顺序被加入的文件集合</span></span><br><span class="line">	last  *File        <span class="comment">// 最后一个文件缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，解析该集合，<code>f, err := parser.ParseFile(fset, &quot;&quot;, src, 0)</code></p>
<p><strong>ParseFile会解析单个Go源文件的源代码并返回相应的ast.File节点。</strong></p>
<p>源代码可以通过传入源文件的文件名，或src参数提供。如果src！= nil，则ParseFile将从src中解析源代码，文件名为仅在记录位置信息时使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFile</span><span class="params">(fset *token.FileSet, filename <span class="keyword">string</span>, src <span class="keyword">interface</span>&#123;&#125;, mode Mode)</span> <span class="params">(f *ast.File, err error)</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> fset == <span class="literal">nil</span> &#123;</span><br><span class="line">  		<span class="built_in">panic</span>(<span class="string">&quot;parser.ParseFile: no token.FileSet provided (fset == nil)&quot;</span>)</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 读取源文件，返回[]byte类型数据</span></span><br><span class="line">    <span class="comment">// 读取源文件，如果src不为空，则从src读取，否则读取filename指定的文件</span></span><br><span class="line">  	text, err := readSource(filename, src)</span><br><span class="line">  	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">var</span> p parser</span><br><span class="line">  	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  		<span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">  			<span class="comment">// resume same panic if it&#x27;s not a bailout</span></span><br><span class="line">  			<span class="keyword">if</span> _, ok := e.(bailout); !ok &#123;</span><br><span class="line">  				<span class="built_in">panic</span>(e)</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line"></span><br><span class="line">  		<span class="comment">// set result values</span></span><br><span class="line">  		<span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line">  			<span class="comment">// source is not a valid Go source file - satisfy</span></span><br><span class="line">  			<span class="comment">// ParseFile API and return a valid (but) empty</span></span><br><span class="line">  			<span class="comment">// *ast.File</span></span><br><span class="line">  			f = &amp;ast.File&#123;</span><br><span class="line">  				Name:  <span class="built_in">new</span>(ast.Ident),</span><br><span class="line">  				Scope: ast.NewScope(<span class="literal">nil</span>),</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line"></span><br><span class="line">  		p.errors.Sort()</span><br><span class="line">  		err = p.errors.Err()</span><br><span class="line">  	&#125;()</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 解析文件</span></span><br><span class="line">    <span class="comment">// 初始化解析器parser</span></span><br><span class="line">  	p.init(fset, filename, text, mode)</span><br><span class="line">    <span class="comment">// 解析文件，生成AST</span></span><br><span class="line">  	f = p.parseFile()</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>parse是解析器的结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parser 结构体是解析器的核心</span></span><br><span class="line">  <span class="keyword">type</span> parser <span class="keyword">struct</span> &#123;</span><br><span class="line">  	file    *token.File</span><br><span class="line">  	errors  scanner.ErrorList</span><br><span class="line">  	scanner scanner.Scanner </span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 追踪和问题排查</span></span><br><span class="line">  	mode   Mode <span class="comment">// 解析模式</span></span><br><span class="line">  	trace  <span class="keyword">bool</span> <span class="comment">// == (mode &amp; Trace != 0)</span></span><br><span class="line">  	indent <span class="keyword">int</span>  <span class="comment">// 跟踪输出的缩进</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// Comments</span></span><br><span class="line">  	comments    []*ast.CommentGroup</span><br><span class="line">  	leadComment *ast.CommentGroup </span><br><span class="line">  	lineComment *ast.CommentGroup </span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 定义下一个标识</span></span><br><span class="line">  	pos token.Pos   </span><br><span class="line">  	tok token.Token </span><br><span class="line">  	lit <span class="keyword">string</span>     </span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 错误恢复</span></span><br><span class="line">  	syncPos token.Pos</span><br><span class="line">  	syncCnt <span class="keyword">int</span>       </span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 非句法解析器控制</span></span><br><span class="line">  	exprLev <span class="keyword">int</span>  </span><br><span class="line">  	inRhs   <span class="keyword">bool</span> </span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 普通标识符范围</span></span><br><span class="line">  	pkgScope   *ast.Scope       </span><br><span class="line">  	topScope   *ast.Scope       </span><br><span class="line">  	unresolved []*ast.Ident     </span><br><span class="line">  	imports    []*ast.ImportSpec </span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 标签范围</span></span><br><span class="line">  	labelScope  *ast.Scope    </span><br><span class="line">  	targetStack [][]*ast.Ident </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下具体的解析过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *parser)</span> <span class="title">parseFile</span><span class="params">()</span> *<span class="title">ast</span>.<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="comment">// 追踪模式</span></span><br><span class="line">  	<span class="keyword">if</span> p.trace &#123;</span><br><span class="line">  		<span class="keyword">defer</span> un(trace(p, <span class="string">&quot;File&quot;</span>))</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们扫描第一个令牌时出现错误，不影响其他的解析</span></span><br><span class="line">    <span class="comment">// 如果执行parser.next时有错误发生</span></span><br><span class="line">  	<span class="keyword">if</span> p.errors.Len() != <span class="number">0</span> &#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// package的条款(package前面的注释被认为是当前文件的doc)</span></span><br><span class="line">  	doc := p.leadComment</span><br><span class="line">    <span class="comment">// 期待第一个token是`package`关键字，该方法内会执行parser.next方法，前进到下一个token</span></span><br><span class="line">  	pos := p.expect(token.PACKAGE)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析当前的token为标识符，也就是包名</span></span><br><span class="line">  	ident := p.parseIdent()</span><br><span class="line">  	<span class="keyword">if</span> ident.Name == <span class="string">&quot;_&quot;</span> &amp;&amp; p.mode&amp;DeclarationErrors != <span class="number">0</span> &#123;</span><br><span class="line">  		p.error(p.pos, <span class="string">&quot;invalid package name _&quot;</span>)</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// 读取`;`，如果没有的话，需要插入一个`;`</span></span><br><span class="line">    <span class="comment">// 也就是说go会自动在语句末尾插入`;`</span></span><br><span class="line">  	p.expectSemi()</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 如果前面解析标识符时失败</span></span><br><span class="line">  	<span class="keyword">if</span> p.errors.Len() != <span class="number">0</span> &#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置topScope</span></span><br><span class="line">    <span class="comment">// scope用于保存当前作用域内声明的符号引用，比如声明的方法、类型或常/变量等</span></span><br><span class="line">  	p.openScope()</span><br><span class="line">    <span class="comment">// 设置包作用域</span></span><br><span class="line">  	p.pkgScope = p.topScope</span><br><span class="line">    <span class="comment">// 声明的node集合</span></span><br><span class="line">    <span class="comment">// 一个源文件是由一系列声明组成的:</span></span><br><span class="line">    <span class="comment">// import声明</span></span><br><span class="line">    <span class="comment">// 方法声明</span></span><br><span class="line">    <span class="comment">// 类型声明</span></span><br><span class="line">    <span class="comment">// 全局常量/变量声明</span></span><br><span class="line">    <span class="comment">// 这里的ast.Decl是这些声明的公共接口</span></span><br><span class="line">  	<span class="keyword">var</span> decls []ast.Decl</span><br><span class="line">    <span class="comment">// 如果不是只解析包名</span></span><br><span class="line">  	<span class="keyword">if</span> p.mode&amp;PackageClauseOnly == <span class="number">0</span> &#123;</span><br><span class="line">  		<span class="comment">// 解析导入声明,确保当前token的`import`</span></span><br><span class="line">  		<span class="keyword">for</span> p.tok == token.IMPORT &#123;</span><br><span class="line">        <span class="comment">// p.parserImportSpec解析具体的导入声明</span></span><br><span class="line">  			decls = <span class="built_in">append</span>(decls, p.parseGenDecl(token.IMPORT, p.parseImportSpec))</span><br><span class="line">  		&#125;</span><br><span class="line">      </span><br><span class="line">			<span class="comment">// 如果不是只解析导入声明</span></span><br><span class="line">  		<span class="keyword">if</span> p.mode&amp;ImportsOnly == <span class="number">0</span> &#123;</span><br><span class="line">  			<span class="comment">// 解析源代码后面的其他内容</span></span><br><span class="line">  			<span class="keyword">for</span> p.tok != token.EOF &#123;</span><br><span class="line">  				decls = <span class="built_in">append</span>(decls, p.parseDecl(syncDecl))</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 关闭作用域</span></span><br><span class="line">  	p.closeScope()</span><br><span class="line">    <span class="comment">// 确保topScope为nil，否则说明有多余的`&#123;&#125;`没有匹配</span></span><br><span class="line">  	assert(p.topScope == <span class="literal">nil</span>, <span class="string">&quot;unbalanced scopes&quot;</span>)</span><br><span class="line">  	assert(p.labelScope == <span class="literal">nil</span>, <span class="string">&quot;unbalanced label scopes&quot;</span>)</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 解析同一文件中的全局标识符</span></span><br><span class="line">  	i := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 在包作用域内查找未解析的符号引用，比如在方法内引用了全局的方法，变量等</span></span><br><span class="line">  	<span class="keyword">for</span> _, ident := <span class="keyword">range</span> p.unresolved &#123;</span><br><span class="line">      <span class="comment">// i &lt;= index for current ident</span></span><br><span class="line">  		assert(ident.Obj == unresolved, <span class="string">&quot;object already resolved&quot;</span>)</span><br><span class="line">  		ident.Obj = p.pkgScope.Lookup(ident.Name) <span class="comment">// also removes unresolved sentinel</span></span><br><span class="line">      <span class="comment">// 有的是在同一个包的其他文件中声明的</span></span><br><span class="line">  		<span class="keyword">if</span> ident.Obj == <span class="literal">nil</span> &#123;</span><br><span class="line">  			p.unresolved[i] = ident</span><br><span class="line">  			i++</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// 构造AST文件</span></span><br><span class="line">  	<span class="keyword">return</span> &amp;ast.File&#123;</span><br><span class="line">  		Doc:        doc,</span><br><span class="line">  		Package:    pos,</span><br><span class="line">  		Name:       ident,</span><br><span class="line">  		Decls:      decls,</span><br><span class="line">  		Scope:      p.pkgScope,</span><br><span class="line">  		Imports:    p.imports,</span><br><span class="line">  		Unresolved: p.unresolved[<span class="number">0</span>:i],</span><br><span class="line">  		Comments:   p.comments,</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>我们来看下AST的每种类型结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的AST树的节点都需要实现Node接口</span></span><br><span class="line">  <span class="keyword">type</span> Node <span class="keyword">interface</span> &#123;</span><br><span class="line">  	Pos() token.Pos <span class="comment">// position of first character belonging to the node</span></span><br><span class="line">  	End() token.Pos <span class="comment">// position of first character immediately after the node</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的表达式都需要实现Expr接口</span></span><br><span class="line">  <span class="keyword">type</span> Expr <span class="keyword">interface</span> &#123;</span><br><span class="line">  	Node</span><br><span class="line">  	exprNode()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的语句都需要实现Stmt接口</span></span><br><span class="line">  <span class="keyword">type</span> Stmt <span class="keyword">interface</span> &#123;</span><br><span class="line">  	Node</span><br><span class="line">  	stmtNode()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的声明都需要实现Decl接口</span></span><br><span class="line">  <span class="keyword">type</span> Decl <span class="keyword">interface</span> &#123;</span><br><span class="line">  	Node</span><br><span class="line">  	declNode()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面就是语法的三个主体,表达式(expression),语句(statement)和声明(declaration),Node是基类接口,任何类型的主体都是Node，用于标记该节点位置的开始和结束.</p>
<p>不过三个主体的函数没有实际意义,只是用三个interface来区分不同的语法单位,如果某个语法是Stmt的话,就实现一个空的stmtNode函数即可.</p>
<p>这样的好处是可以对语法单元进行comma,ok来判断类型,并且保证只有这些变量可以赋值给对应的interface.但是实际上这个划分不是很严格</p>
<h1 id="遍历语法树"><a href="#遍历语法树" class="headerlink" title="遍历语法树"></a>遍历语法树</h1><p>语法树层级较深，嵌套关系复杂，如果不能完全掌握node之间的关系和嵌套规则，我们很难自己写出正确的遍历方法。不过好在<code>ast</code>包已经为我们提供了遍历方法：</p>
<blockquote>
<p>$GOROOT/src/go/ast/ast.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(v Visitor, node Node)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Visit(node Node) (w Visitor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Walk</code>方法会按照深度优先搜索方法（depth-first order）遍历整个语法树，我们只需按照我们的业务需要，实现<code>Visitor</code>接口即可。 <code>Walk</code>每遍历一个节点就会调用<code>Visitor.Visit</code>方法，传入当前节点。如果<code>Visit</code>返回<code>nil</code>，则停止遍历当前节点的子节点。本示例的<code>Visitor</code>实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Visitor</span></span><br><span class="line"><span class="keyword">type</span> Visitor <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Visitor)</span> <span class="title">Visit</span><span class="params">(node ast.Node)</span> <span class="title">ast</span>.<span class="title">Visitor</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> node.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *ast.GenDecl:</span><br><span class="line">		genDecl := node.(*ast.GenDecl)</span><br><span class="line">		<span class="comment">// 查找有没有import context包</span></span><br><span class="line">		<span class="comment">// Notice：没有考虑没有import任何包的情况</span></span><br><span class="line">		<span class="keyword">if</span> genDecl.Tok == token.IMPORT &#123;</span><br><span class="line">			v.addImport(genDecl)</span><br><span class="line">			<span class="comment">// 不需要再遍历子树</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> *ast.InterfaceType:</span><br><span class="line">		<span class="comment">// 遍历所有的接口类型</span></span><br><span class="line">		iface := node.(*ast.InterfaceType)</span><br><span class="line">		addContext(iface)</span><br><span class="line">		<span class="comment">// 不需要再遍历子树</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Visitor)</span> <span class="title">addImport</span><span class="params">(genDecl *ast.GenDecl)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 是否已经import</span></span><br><span class="line">	hasImported := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> genDecl.Specs &#123;</span><br><span class="line">		imptSpec := v.(*ast.ImportSpec)</span><br><span class="line">		<span class="comment">// 如果已经包含&quot;context&quot;</span></span><br><span class="line">		<span class="keyword">if</span> imptSpec.Path.Value == strconv.Quote(<span class="string">&quot;context&quot;</span>) &#123;</span><br><span class="line">			hasImported = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果没有import context，则import</span></span><br><span class="line">	<span class="keyword">if</span> !hasImported &#123;</span><br><span class="line">		genDecl.Specs = <span class="built_in">append</span>(genDecl.Specs, &amp;ast.ImportSpec&#123;</span><br><span class="line">			Path: &amp;ast.BasicLit&#123;</span><br><span class="line">				Kind:  token.STRING,</span><br><span class="line">				Value: strconv.Quote(<span class="string">&quot;context&quot;</span>),</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addContext 添加context参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addContext</span><span class="params">(iface *ast.InterfaceType)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接口方法不为空时，遍历接口方法</span></span><br><span class="line">	<span class="keyword">if</span> iface.Methods != <span class="literal">nil</span> || iface.Methods.List != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> iface.Methods.List &#123;</span><br><span class="line">			ft := v.Type.(*ast.FuncType)</span><br><span class="line">			hasContext := <span class="literal">false</span></span><br><span class="line">			<span class="comment">// 判断参数中是否包含context.Context类型</span></span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> ft.Params.List &#123;</span><br><span class="line">				<span class="keyword">if</span> expr, ok := v.Type.(*ast.SelectorExpr); ok &#123;</span><br><span class="line">					<span class="keyword">if</span> ident, ok := expr.X.(*ast.Ident); ok &#123;</span><br><span class="line">						<span class="keyword">if</span> ident.Name == <span class="string">&quot;context&quot;</span> &#123;</span><br><span class="line">							hasContext = <span class="literal">true</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 为没有context参数的方法添加context参数</span></span><br><span class="line">			<span class="keyword">if</span> !hasContext &#123;</span><br><span class="line">				ctxField := &amp;ast.Field&#123;</span><br><span class="line">					Names: []*ast.Ident&#123;</span><br><span class="line">						ast.NewIdent(<span class="string">&quot;ctx&quot;</span>),</span><br><span class="line">					&#125;,</span><br><span class="line">					<span class="comment">// Notice: 没有考虑import别名的情况</span></span><br><span class="line">					Type: &amp;ast.SelectorExpr&#123;</span><br><span class="line">						X:   ast.NewIdent(<span class="string">&quot;context&quot;</span>),</span><br><span class="line">						Sel: ast.NewIdent(<span class="string">&quot;Context&quot;</span>),</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">				list := []*ast.Field&#123;</span><br><span class="line">					ctxField,</span><br><span class="line">				&#125;</span><br><span class="line">				ft.Params.List = <span class="built_in">append</span>(list, ft.Params.List...)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>