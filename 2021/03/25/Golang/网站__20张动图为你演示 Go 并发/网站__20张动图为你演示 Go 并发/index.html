<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="地址：&lt;a href=&quot;https://learnku.com/go/t/39490&quot;&gt;20 张动图为你演示 Go 并发&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>20张动图为你演示 Go 并发 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-03-25</div></div></div><div class="container post-header"><h1>20张动图为你演示 Go 并发</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-Concurrent-world"><span class="toc-number">1.</span> <span class="toc-text">Hello, Concurrent world</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Timers"><span class="toc-number">2.</span> <span class="toc-text">Timers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ping-pong"><span class="toc-number">3.</span> <span class="toc-text">Ping-pong</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fan-In"><span class="toc-number">4.</span> <span class="toc-text">Fan-In</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Workers-fan-out"><span class="toc-number">5.</span> <span class="toc-text">Workers( fan-out )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%B7%A5%E4%BD%9C%E8%80%85"><span class="toc-number">7.</span> <span class="toc-text">服务器 + 工作者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%B4%A0%E7%AD%9B-%E7%B4%A0%E7%AD%9B%E6%8C%87%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">并发素筛 (素筛指素数筛法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GOMAXPROCS%EF%BC%88%E8%B0%83%E6%95%B4%E5%B9%B6%E5%8F%91%E7%9A%84%E8%BF%90%E8%A1%8C%E6%80%A7%E8%83%BD%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">GOMAXPROCS（调整并发的运行性能）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Goroutines-leak"><span class="toc-number">10.</span> <span class="toc-text">Goroutines leak</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallelism-is-not-Concurrency"><span class="toc-number">11.</span> <span class="toc-text">Parallelism is not Concurrency</span></a></li></ol></details></div><div class="container post-content"><p>地址：<a target="_blank" rel="noopener" href="https://learnku.com/go/t/39490">20 张动图为你演示 Go 并发</a></p>
<h2 id="Hello-Concurrent-world"><a href="#Hello-Concurrent-world" class="headerlink" title="Hello, Concurrent world"></a>Hello, Concurrent world</h2><p>代码很简单 —— 单个通道，单个 goroutine，单次写入，单次读取。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个int类型的通道</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启一个匿名 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 向通道发送数字42</span></span><br><span class="line">        ch &lt;- <span class="number">42</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 从通道中读取</span></span><br><span class="line">    &lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/cVBILoho3N.gif!large" alt="img"></p>
<ul>
<li>蓝色线代表随时间运行的 goroutine. </li>
<li>连接‘main’和‘go #19’的蓝色细线用来标记 goroutine 的开始和结束同时展示了父子关系，</li>
<li>最后，红线代表发送 / 接收动作。</li>
<li>虽然这是两个独立的动作，我还是尝试用 “从 A 发送到 B” 的动画将他们表示成一个动作. </li>
<li>goroutine 名称中的 “#19” 是 goroutine 真实的内部 ID</li>
</ul>
<h2 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h2><p>实际上，可以通过以下方法构建一个简单的计时器 —— 创建一个通道，开启一个 goroutine 让其在指定的时间间隔后向通道中写入数据，然后将这个通道返回给调用者。于是调用函数就会在读取通道时阻塞，直到之前设定的时间间隔过去。接下来我们调用 24 次计时器然后尝试具象化调用过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timer</span><span class="params">(d time.Duration)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(d)</span><br><span class="line">        c &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">24</span>; i++ &#123;</span><br><span class="line">        c := timer(<span class="number">1</span> * time.Second)</span><br><span class="line">        &lt;-c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/nrqtA14Z8P.gif!large" alt="img"></p>
<h2 id="Ping-pong"><a href="#Ping-pong" class="headerlink" title="Ping-pong"></a>Ping-pong</h2><p>这里我们用一个通道代表乒乓球台。一个整型变量代表球，然后用两个 goroutine 代表玩家，玩家通过增加整型变量的值（点击计数器）模拟击球动作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> Ball <span class="keyword">int</span></span><br><span class="line">    table := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> player(table)</span><br><span class="line">    <span class="keyword">go</span> player(table)</span><br><span class="line"></span><br><span class="line">    table &lt;- Ball</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &lt;-table</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">player</span><span class="params">(table <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ball := &lt;-table</span><br><span class="line">        ball++</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        table &lt;- ball</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/8Ije4V9mQL.gif!large" alt="img"></p>
<p>现在，我们添加三个玩家看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go player(table)</span><br><span class="line">go player(table)</span><br><span class="line">go player(table)</span><br></pre></td></tr></table></figure>

<p><img src="/images/uaRMkCMVpp.gif!large" alt="img"></p>
<p>我们可以看到每个玩家都按照次序轮流操作，你可能会想为什么会这样。为什么多个玩家（goroutine）会按照严格的顺序接到 “球” 呢。</p>
<p>答案是 **Go 运行时环境维护了一个 接收者 FIFO 队列 (存储需要从某一通道上接收数据的 goroutine)**，在我们的例子里，每个玩家在刚发出球后就做好了接球准备。我们来看一下更复杂的情况，加入 100 个玩家。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> player(table)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pingpong100.gif" alt="img"></p>
<p>先进先出顺序很明显了，是吧？我们可以创建一百万个 goroutine，因为它们很轻量，但是对于实现我们的目的来说没有必要。我们来想想其他可以玩的。 例如，常见的消息传递模式。</p>
<h2 id="Fan-In"><a href="#Fan-In" class="headerlink" title="Fan-In"></a>Fan-In</h2><p>并发世界中流行的模式之一是所谓的 <em>fan-in</em> 模式。这与 <em>fan-out</em> 模式相反，稍后我们将介绍。简而言之，fan-in 是一项功能，可以<strong>从多个输入中读取数据并将其全部多路复用到单个通道中</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, d time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">        i++</span><br><span class="line">        time.Sleep(d)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reader</span><span class="params">(out <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> out &#123;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> producer(ch, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">go</span> producer(ch, <span class="number">250</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">go</span> reader(out)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/BZ73qt6wx2.gif!large" alt="img"></p>
<p>如我们所见，第一个 producer 每 100 毫秒生成一次值，第二个每 250 毫秒生成一次值，但是 reader 会立即从这两个生产者那里接受值。实际上，多路复用发生在 main 的 range 循环中。</p>
<h2 id="Workers-fan-out"><a href="#Workers-fan-out" class="headerlink" title="Workers( fan-out )"></a>Workers( fan-out )</h2><p>与 fan-in 相反的模式是 fan-out 或者 worker 模式。<strong>多个 goroutine 可以从单个通道读取，从而在 CPU 内核之间分配大量的工作量</strong>，因此是 worker 的名称。在 Go 中，此模式易于实现 - 只需以通道为参数启动多个 goroutine，然后将值发送至该通道 - Go 运行时会自动地进行分配和复用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tasksCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        task, ok := &lt;-tasksCh</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        d := time.Duration(task) * time.Millisecond</span><br><span class="line">        time.Sleep(d)</span><br><span class="line">        fmt.Println(<span class="string">&quot;processing task&quot;</span>, task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pool</span><span class="params">(wg *sync.WaitGroup, workers, tasks <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    tasksCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(tasksCh, wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasks; i++ &#123;</span><br><span class="line">        tasksCh &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(tasksCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">36</span>)</span><br><span class="line">    <span class="keyword">go</span> pool(&amp;wg, <span class="number">36</span>, <span class="number">50</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/0PVJ8MIMs3.gif!large" alt="img"></p>
<p>这里值得一提的是：并行性。如您所见，<strong>所有 goroutine 并行’运行‘，等待通道给予它们‘工作’</strong>。</p>
<p>鉴于上面的动画，很容易发现 goroutine 几乎立即接连地收到它们的工作。不幸的是，该动画在 goroutine 确实在处理工作还是仅仅是在等待输入的地方没有用颜色显示出来，但是此动画是在 GOMAXPROCS=4 的情况下录制的，因此只有 4 个 goroutine 有效地并行运行。我们将很快讨论这个主题。</p>
<p>现在，让我们做一些更复杂的事情，并启动一些有自己 workers（subworders）的 workers。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    WORKERS    = <span class="number">5</span></span><br><span class="line">    SUBWORKERS = <span class="number">3</span></span><br><span class="line">    TASKS      = <span class="number">20</span></span><br><span class="line">    SUBTASKS   = <span class="number">10</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subworker</span><span class="params">(subtasks <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        task, ok := &lt;-subtasks</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(time.Duration(task) * time.Millisecond)</span><br><span class="line">        fmt.Println(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tasks &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        task, ok := &lt;-tasks</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subtasks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SUBWORKERS; i++ &#123;</span><br><span class="line">            <span class="keyword">go</span> subworker(subtasks)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SUBTASKS; i++ &#123;</span><br><span class="line">            task1 := task * i</span><br><span class="line">            subtasks &lt;- task1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(subtasks)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(WORKERS)</span><br><span class="line">    tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; WORKERS; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(tasks, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; TASKS; i++ &#123;</span><br><span class="line">        tasks &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(tasks)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/6KixmlEiUo.gif!large" alt="img"></p>
<p>很好。当然，我们可以将 worker 和 subworker 的数量设置为更高的值，但是我试图使动画清晰易懂。</p>
<p>更酷的 fan-out 模式确实存在，例如<strong>动态数量的 worker/subworker</strong>，通过通道发送通道，但是 fan-out 的想法现在应该很清楚了。</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>下一个常见的模式类似于扇出，但是会在很短的时间内生成 goroutine，只是为了完成某些任务。它通常用于实现服务器 - 创建侦听器，循环运行 accept () 并为每个接受的连接启动 goroutine。它非常具有表现力，可以实现尽可能简单的服务器处理程序。看一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    c.Write([]<span class="keyword">byte</span>(<span class="string">&quot;ok&quot;</span>))</span><br><span class="line">    c.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:5000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handler(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/IBirPWYXDk.gif!large" alt="img"></p>
<p>这不是很有趣 - 似乎并发方面没有发生任何事情。当然，在引擎盖下有很多复杂性，这是我们特意隐藏的。 “简单性很复杂”.</p>
<p>但是，让我们回到并发性并向我们的服务器添加一些交互。假设每个处理程序都希望异步写入记录器。在我们的示例中，记录器本身是一个单独的 goroutine，它可以完成此任务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(c net.Conn, ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- c.RemoteAddr().String()</span><br><span class="line">    c.Write([]<span class="keyword">byte</span>(<span class="string">&quot;ok&quot;</span>))</span><br><span class="line">    c.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(l net.Listener, ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handler(c, ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:5000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> logger(ch)</span><br><span class="line">    <span class="keyword">go</span> server(l, ch)</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/gM6p6EUFNf.gif!large" alt="img"></p>
<p>如果请求数量增加并且日志记录操作花费一些时间 (例如，准备和编码数据)，我们的 * logger * goroutine 很快就会成为瓶颈。我们可以使用一个已知的扇出模式。我们开始做吧。</p>
<h2 id="服务器-工作者"><a href="#服务器-工作者" class="headerlink" title="服务器 + 工作者"></a>服务器 + 工作者</h2><p>带工作程序的服务器示例是记录器的高级版本。它不仅可以完成一些工作，而且还可以通过 * results * 通道将其工作结果发送回池中。没什么大不了的，但是它将我们的记录器示例扩展到了更实际的示例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(c net.Conn, ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    addr := c.RemoteAddr().String()</span><br><span class="line">    ch &lt;- addr</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    c.Write([]<span class="keyword">byte</span>(<span class="string">&quot;ok&quot;</span>))</span><br><span class="line">    c.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">(wch <span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        data := &lt;-wch</span><br><span class="line">        data++</span><br><span class="line">        results &lt;- data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(results <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-results</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pool</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    wch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> logger(wch, results)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> parse(results)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        addr := &lt;-ch</span><br><span class="line">        l := <span class="built_in">len</span>(addr)</span><br><span class="line">        wch &lt;- l</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(l net.Listener, ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handler(c, ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:5000&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> pool(ch, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">go</span> server(l, ch)</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/zVrbDVQHSM.gif!large" alt="img"></p>
<p>我们在 4 个 goroutine 之间分配了工作，有效地提高了记录器的吞吐量，但是从此动画中，我们可以看到记录器仍然可能是问题的根源。成千上万的连接在分配之前会汇聚在一个通道中，这可能导致记录器再次成为瓶颈。但是，当然，它会在更高的负载下发生。</p>
<h2 id="并发素筛-素筛指素数筛法"><a href="#并发素筛-素筛指素数筛法" class="headerlink" title="并发素筛 (素筛指素数筛法)"></a>并发素筛 (素筛指素数筛法)</h2><p>素数筛，或 [Eratosthenes 筛) 是一种古老的算法，用于查找达到给定限制的素数。它通过按顺序消除所有质数的倍数来工作。天真的算法并不是真正有效的算法，尤其是在多核计算机上。</p>
<p>该算法的并发变体使用 goroutine 过滤数字 - 每个发现的素数一个 goroutine，以及用于将数字从生成器发送到过滤器的通道。找到质数后，它将通过通道发送到 * main * 以进行输出。当然，该算法也不是很有效，特别是如果您想找到大质数并寻找最低的 Big O 复杂度，但是我发现它非常优雅。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发的主筛</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将序列2、3、4，...发送到频道“ ch”。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Generate</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">        ch &lt;- i <span class="comment">// Send &#x27;i&#x27; to channel &#x27;ch&#x27;.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将值从通道“ in”复制到通道“ out”，</span></span><br><span class="line"><span class="comment">//删除可被“素数”整除的那些。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Filter</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, prime <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i := &lt;-in <span class="comment">// Receive value from &#x27;in&#x27;.</span></span><br><span class="line">        <span class="keyword">if</span> i%prime != <span class="number">0</span> &#123;</span><br><span class="line">            out &lt;- i <span class="comment">// Send &#x27;i&#x27; to &#x27;out&#x27;.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主筛：菊花链过滤器过程。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// Create a new channel.</span></span><br><span class="line">    <span class="keyword">go</span> Generate(ch)      <span class="comment">// Launch Generate goroutine.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        prime := &lt;-ch</span><br><span class="line">        fmt.Println(prime)</span><br><span class="line">        ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">go</span> Filter(ch, ch1, prime)</span><br><span class="line">        ch = ch1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/tmKSCZZCyq.gif!large" alt="img"></p>
<p>generate * goroutine 发出从 2 开始的每个整数，每个新的 goroutine 仅过滤特定的质数倍数 - 2、3、5、7 …，将第一个找到的质数发送给 * main *。如果旋转它从顶部看，您会看到从 goroutine 发送到 main 的所有数字都是质数。漂亮的算法，尤其是在 3D 中。</p>
<h2 id="GOMAXPROCS（调整并发的运行性能）"><a href="#GOMAXPROCS（调整并发的运行性能）" class="headerlink" title="GOMAXPROCS（调整并发的运行性能）"></a>GOMAXPROCS（调整并发的运行性能）</h2><p>GOMAXPROCS 设置可以同时执行的最大 CPU 数量。</p>
<p>当然，CPU 是指逻辑 CPU。我修改了一些示例，以使他们真正地工作 (而不仅仅是睡觉) 并使用实际的 CPU 时间。然后，我运行了代码，没有进行任何修改，只是设置了不同的 GOMAXPROCS 值。 Linux 机顶盒有 2 个 CPU，每个 CPU 具有 12 个内核，因此有 24 个内核。</p>
<p>因此，第一次运行演示了该程序在 1 个内核上运行，而第二次 - 使用了所有 24 个内核的功能。</p>
<p><img src="/images/rIf3S5DYqQ.gif!large" alt="img"></p>
<p>这些动画中的时间速度是不同的 (我希望所有动画都适合同一时间 /height)，因此区别很明显。当 GOMAXPROCS = 1 时，下一个工作人员只有在上一个工作完成后才能开始实际工作。在 GOMAXPROCS = 24 的情况下，加速非常大，而复用的开销可以忽略不计。</p>
<p>不过，重要的是要了解，增加 GOMAXPROCS 并不总是可以提高性能，在某些情况下实际上会使它变得更糟。</p>
<h2 id="Goroutines-leak"><a href="#Goroutines-leak" class="headerlink" title="Goroutines leak"></a>Goroutines leak</h2><p>我们可以从 Go 中的并发时间中证明什么呢？我想到的一件事情是 goroutine 泄漏。例如，如果您启动 goroutine，但超出范围，可能会发生泄漏。或者，您只是忘记添加结束条件，而运行了 for {} 循环。</p>
<p>第一次在代码中遇到 goroutine 泄漏时，我的脑海中出现了可怕的图像，并且在下个周末我写了 expvarmon。现在，我可以使用 WebGL 可视化该恐怖图像。</p>
<p><img src="/images/idzWShNbga.gif!large" alt="img"></p>
<h2 id="Parallelism-is-not-Concurrency"><a href="#Parallelism-is-not-Concurrency" class="headerlink" title="Parallelism is not Concurrency"></a>Parallelism is not Concurrency</h2><ul>
<li>并行是简单的并行运行事物。</li>
<li>并发是一种构造程序的方法。</li>
</ul>
<p>因此，并发程序可能是并行的，也可能不是并行的，这些概念在某种程度上是正交的。我们在演示 GOMAXPROCS 设置效果时已经看到了这一点。</p>
<p>这是并行性:</p>
<p><img src="/images/Uqo7QN5qnT.gif!large" alt="img"></p>
<p>但这是并发的：</p>
<p><img src="/images/tmKSCZZCyq-20210325153417539.gif!large" alt="img"></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>