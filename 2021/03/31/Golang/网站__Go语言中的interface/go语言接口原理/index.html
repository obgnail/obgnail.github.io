<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;Go语言接口的原理&quot;&gt;&lt;a href=&quot;#Go语言接口的原理&quot; class=&quot;headerlink&quot; title=&quot;Go语言接口的原理&quot;&gt;&lt;/a&gt;Go语言接口的原理&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在计算机科学中，&lt;strong&gt;接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息&lt;/strong&gt;。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>go语言接口原理 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-03-31</div></div></div><div class="container post-header"><h1>go语言接口原理</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">Go语言接口的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">隐式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.1.2.</span> <span class="toc-text">接口类型检查的时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.4.</span> <span class="toc-text">指针和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nil-%E5%92%8C-non-nil"><span class="toc-number">1.1.5.</span> <span class="toc-text">nil 和 non-nil</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">类型结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#itab-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">itab 结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">结构体类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.4.</span> <span class="toc-text">类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.1.</span> <span class="toc-text">非空接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.2.</span> <span class="toc-text">空接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%B4%BE%E5%8F%91"><span class="toc-number">1.5.</span> <span class="toc-text">动态派发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">基准测试</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h1 id="Go语言接口的原理"><a href="#Go语言接口的原理" class="headerlink" title="Go语言接口的原理"></a>Go语言接口的原理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在计算机科学中，<strong>接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息</strong>。</p>
<p>如下图所示，<strong>接口的本质是引入一个新的中间层</strong>，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。</p>
<p><img src="/images/golang-interface.png" alt="golang-interface"></p>
<p>可移植操作系统接口（Portable Operating System Interface，POSIX)就是一个典型的例子，它定义了应用程序接口和命令行等标准，为计算机软件带来了可移植性 — 只要操作系统实现了 POSIX，计算机软件就可以直接在不同操作系统上运行。</p>
<p>除了解耦有依赖关系的上下游，接口还能够帮助我们隐藏底层实现，减少关注点。SQL 就是接口的一个例子，当我们使用 SQL 语句查询数据时，其实不需要关心底层数据库的具体实现，我们只在乎 SQL 返回的结果是否符合预期。</p>
<p><img src="/images/2020-01-12-15787970694046-sql-and-databases.png" alt="sql-and-databases"></p>
<h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>很多面向对象语言都有接口这一概念，例如 Java 和 C#。Java 的接口不仅可以定义方法签名，还可以定义变量，这些定义的变量可以直接在实现接口的类中使用，这里简单介绍一下 Java 中的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String hello = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码定义了一个必须实现的方法 <code>sayHello</code> 和一个**会注入到实现类的变量 <code>hello</code>**。在下面的代码中，<code>MyInterfaceImpl</code> 实现了 <code>MyInterface</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(MyInterface.hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 中的类必须通过上述方式显式地声明实现的接口，</p>
<p>但是在 Go 语言中实现接口就不需要使用类似的方式。首先，我们简单了解一下在 Go 语言中如何定义接口。定义接口需要使用 <code>interface</code> 关键字，在接口中我们只能定义方法签名，不能包含成员变量，一个常见的 Go 语言接口是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类型需要实现 <code>error</code> 接口，那么它只需要实现 <code>Error() string</code> 方法，下面的 <code>RPCError</code> 结构体就是 <code>error</code> 接口的一个实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code    <span class="keyword">int64</span></span><br><span class="line">	Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *RPCError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, code=%d&quot;</span>, e.Message, e.Code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心的读者可能会发现上述代码根本就没有 <code>error</code> 接口的影子，这是为什么呢？Go 语言中<strong>接口的实现都是隐式的</strong>，我们只需要实现 <code>Error() string</code> 方法就实现了 <code>error</code> 接口。Go 语言实现接口的方式与 Java 完全不同：</p>
<ul>
<li>在 Java 中：实现接口需要显式地声明接口并实现所有方法；</li>
<li>在 Go 中：实现接口的所有方法就隐式地实现了接口；</li>
</ul>
<h3 id="接口类型检查的时机"><a href="#接口类型检查的时机" class="headerlink" title="接口类型检查的时机"></a>接口类型检查的时机</h3><p>我们使用上述 <code>RPCError</code> 结构体时并不关心它实现了哪些接口，<strong>Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查</strong>，这里举几个例子来演示发生接口类型检查的时机：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rpcErr error = NewRPCError(<span class="number">400</span>, <span class="string">&quot;unknown err&quot;</span>) <span class="comment">// typecheck1</span></span><br><span class="line">	err := AsErr(rpcErr) <span class="comment">// typecheck2</span></span><br><span class="line">	<span class="built_in">println</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRPCError</span><span class="params">(code <span class="keyword">int64</span>, msg <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RPCError&#123; <span class="comment">// typecheck3</span></span><br><span class="line">		Code:    code,</span><br><span class="line">		Message: msg,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsErr</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言在<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">编译期间</a>对代码进行类型检查，上述代码总共触发了三次类型检查：</p>
<ol>
<li>将 <code>*RPCError</code> 类型的变量赋值给 <code>error</code> 类型的变量 <code>rpcErr</code>；</li>
<li>将 <code>*RPCError</code> 类型的变量 <code>rpcErr</code> 传递给签名中参数类型为 <code>error</code> 的 <code>AsErr</code> 函数；</li>
<li>将 <code>*RPCError</code> 类型的变量从函数签名的返回值类型为 <code>error</code> 的 <code>NewRPCError</code> 函数中返回；</li>
</ol>
<p>从类型检查的过程来看，编译器仅在需要时才检查类型。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束，不过 Go 语言中有两种略微不同的接口，</p>
<ul>
<li>一种是带有一组方法的接口：<code>runtime.iface</code></li>
<li>另一种是不带任何方法的 <code>interface&#123;&#125;</code>：<code>runtime.eface </code></li>
</ul>
<p>两种接口虽然都使用 <code>interface</code> 声明，但是由于后者在 Go 语言中很常见，所以在实现时使用了特殊的类型。</p>
<blockquote>
<p>需要注意的是，与 C 语言中的 <code>void *</code> 不同，<code>interface&#123;&#125;</code> 类型<strong>不是任意类型</strong>。如果我们将类型转换成了 <code>interface&#123;&#125;</code> 类型，变量在运行期间的类型也会发生变化，获取变量类型时会得到 <code>interface&#123;&#125;</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Test <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	v := Test&#123;&#125;</span><br><span class="line">	Print(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数不接受任意类型的参数，只接受 <code>interface&#123;&#125;</code> 类型的值，<strong>在调用 <code>Print</code> 函数时会对参数 <code>v</code> 进行类型转换，将原来的 <code>Test</code> 类型转换成 <code>interface&#123;&#125;</code> 类型</strong>，本节会在后面介绍类型转换的实现原理。</p>
</blockquote>
<h3 id="指针和接口"><a href="#指针和接口" class="headerlink" title="指针和接口"></a>指针和接口</h3><p>在 Go 语言中同时使用指针和接口时会发生一些让人困惑的问题，接口在定义一组方法时没有对实现的接收者做限制，所以我们会看到某个类型实现接口的两种方式：</p>
<p><img src="/images/golang-interface-and-pointer.png" alt="golang-interface-and-pointer"></p>
<p>虽然两种类型不同，但是上图中的两种实现不可以同时存在，Go 语言的编译器会在结构体类型和指针类型都实现一个方法时报错 “method redeclared”。</p>
<p>对 <code>Cat</code> 结构体来说，它在实现接口时可以选择接受者的类型，即结构体或者结构体指针，在初始化时也可以初始化成结构体或者指针。下面的代码总结了如何使用结构体、结构体指针实现接口，以及如何使用结构体、结构体指针初始化变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c  Cat)</span> <span class="title">Quack</span></span> &#123;&#125;  <span class="comment">// 使用结构体实现接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Quack</span></span> &#123;&#125;  <span class="comment">// 使用结构体指针实现接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d Duck = Cat&#123;&#125;      <span class="comment">// 使用结构体初始化变量</span></span><br><span class="line"><span class="keyword">var</span> d Duck = &amp;Cat&#123;&#125;     <span class="comment">// 使用结构体指针初始化变量</span></span><br></pre></td></tr></table></figure>

<p>实现接口的类型和初始化返回的类型两个维度共组成了四种情况，然而这四种情况不是都能通过编译器的检查：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">结构体实现接口</th>
<th align="center">结构体指针实现接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">结构体初始化变量</td>
<td align="center">通过</td>
<td align="center">不通过</td>
</tr>
<tr>
<td align="center">结构体指针初始化变量</td>
<td align="center">通过</td>
<td align="center">通过</td>
</tr>
</tbody></table>
<p>四种中只有使用指针实现接口，使用结构体初始化变量无法通过编译，其他的三种情况都可以正常执行。当实现接口的类型和初始化变量时返回的类型时相同时，代码通过编译是理所应当的：</p>
<ul>
<li>方法接受者和初始化类型都是结构体；</li>
<li>方法接受者和初始化类型都是结构体指针；</li>
</ul>
<p>而剩下的两种方式为什么一种能够通过编译，另一种无法通过编译呢？我们先来看一下能够通过编译的情况，即方法的接受者是结构体，而初始化的变量是结构体指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为指针的 <code>&amp;Cat&#123;&#125;</code> 变量能够<strong>隐式地获取</strong>到指向的结构体，所以能在结构体上调用 <code>Walk</code> 和 <code>Quack</code> 方法。我们可以将这里的调用理解成 C 语言中的 <code>d-&gt;Walk()</code> 和 <code>d-&gt;Speak()</code>，它们都会先获取指向的结构体再执行对应的方法。</p>
<p>但是如果我们将上述代码中方法的接受者和初始化的类型进行交换，代码就无法通过编译了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = Cat&#123;&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> build <span class="keyword">interface</span>.<span class="keyword">go</span></span><br><span class="line">./<span class="keyword">interface</span>.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">6</span>: cannot use Cat literal (<span class="keyword">type</span> Cat) as <span class="keyword">type</span> Duck in assignment:</span><br><span class="line">	Cat does not implement Duck (Quack method has pointer receiver)</span><br></pre></td></tr></table></figure>

<p>编译器会提醒我们：<code>Cat</code> 类型没有实现 <code>Duck</code> 接口，<code>Quack</code> 方法的接受者是指针。这两个报错对于刚刚接触 Go 语言的开发者比较难以理解，如果我们想要搞清楚这个问题，首先要知道 Go 语言在<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/">传递参数</a>时都是传值的。</p>
<p><img src="/images/golang-interface-method-receiver.png" alt="golang-interface-method-receive"></p>
<p>如上图所示，无论上述代码中初始化的变量 <code>c</code> 是 <code>Cat&#123;&#125;</code> 还是 <code>&amp;Cat&#123;&#125;</code>，使用 <code>c.Quack()</code> 调用方法时都会发生值拷贝：</p>
<ul>
<li>如上图左侧，对于 <code>&amp;Cat&#123;&#125;</code> 来说，这意味着拷贝一个新的 <code>&amp;Cat&#123;&#125;</code> 指针，这个指针与原来的指针指向一个相同并且唯一的结构体，所以编译器可以隐式的对变量解引用（dereference）获取指针指向的结构体；</li>
<li>如上图右侧，对于 <code>Cat&#123;&#125;</code> 来说，这意味着 <code>Quack</code> 方法会接受一个全新的 <code>Cat&#123;&#125;</code>，因为方法的参数是 <code>*Cat</code>，编译器不会无中生有创建一个新的指针；即使编译器可以创建新指针，这个指针指向的也不是最初调用该方法的结构体；</li>
</ul>
<p>上面的分析解释了指针类型的现象，当我们使用指针实现接口时，只有指针类型的变量才会实现该接口；当我们使用结构体实现接口时，指针类型和结构体类型都会实现该接口。当然这并不意味着我们应该一律使用结构体实现接口，这个问题在实际工程中也没那么重要，在这里我们只想解释现象背后的原因。</p>
<h3 id="nil-和-non-nil"><a href="#nil-和-non-nil" class="headerlink" title="nil 和 non-nil"></a>nil 和 non-nil</h3><p>我们可以通过一个例子理解<strong>Go 语言的接口类型不是任意类型</strong>这一句话，下面的代码在 <code>main</code> 函数中初始化了一个 <code>*TestStruct</code> 类型的变量，由于指针的零值是 <code>nil</code>，所以变量 <code>s</code> 在初始化之后也是 <code>nil</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NilOrNot</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *TestStruct</span><br><span class="line">	fmt.Println(s == <span class="literal">nil</span>)      <span class="comment">// #=&gt; true</span></span><br><span class="line">	fmt.Println(NilOrNot(s))   <span class="comment">// #=&gt; false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现上述现象的原因是 —— 调用 <code>NilOrNot</code> 函数时发生了<strong>隐式的类型转换</strong>，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，**<code>*TestStruct</code> 类型会转换成 <code>interface&#123;&#125;</code> 类型**，转换后的变量不仅包含转换前的变量，还包含变量的类型信息 <code>TestStruct</code>，所以转换后的变量与 <code>nil</code> 不相等。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>从源代码和汇编指令层面介绍接口的底层数据结构。</p>
<p>Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：</p>
<ul>
<li>使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体表示包含方法的接口</li>
<li>使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.eface"><code>runtime.eface</code></a> 结构体表示不包含任何方法的 <code>interface&#123;&#125;</code> 类型；</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.eface"><code>runtime.eface</code></a> 结构体在 Go 语言中的定义是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">	_type *_type</span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>interface&#123;&#125;</code> 类型不包含任何方法，所以它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针。从上述结构我们也能推断出 — Go 语言的任意类型都可以转换成 <code>interface&#123;&#125;</code>。</p>
<p>另一个用于表示接口的结构体是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a>，这个结构体中有指向原始数据的指针 <code>data</code>，不过更重要的是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 类型的 <code>tab</code> 字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们将详细分析 Go 语言接口中的这两个类型，即 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime._type"><code>runtime._type</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a>。</p>
<h3 id="类型结构体"><a href="#类型结构体" class="headerlink" title="类型结构体"></a>类型结构体</h3><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime._type"><code>runtime._type</code></a> 是 Go 语言类型的运行时表示。下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="keyword">uintptr</span></span><br><span class="line">	ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">	hash       <span class="keyword">uint32</span></span><br><span class="line">	tflag      tflag</span><br><span class="line">	align      <span class="keyword">uint8</span></span><br><span class="line">	fieldAlign <span class="keyword">uint8</span></span><br><span class="line">	kind       <span class="keyword">uint8</span></span><br><span class="line">	equal      <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line">	gcdata     *<span class="keyword">byte</span></span><br><span class="line">	str        nameOff</span><br><span class="line">	ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code> 字段存储了类型占用的内存空间，为内存空间的分配提供信息；</li>
<li><code>hash</code> 字段能够帮助我们快速确定类型是否相等；</li>
<li><code>equal</code> 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 <code>typeAlg</code> 结构体中迁移过来的；</li>
</ul>
<p>我们只需要对 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime._type"><code>runtime._type</code></a> 结构体中的字段有一个大体的概念，不需要详细理解所有字段的作用和意义。</p>
<h3 id="itab-结构体"><a href="#itab-结构体" class="headerlink" title="itab 结构体"></a>itab 结构体</h3><p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 结构体是接口类型的核心组成部分，每一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 都占 32 字节，我们<strong>可以将其看成接口类型和具体类型的组合，它们分别用 <code>inter</code> 和 <code>_type</code> 两个字段表示</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123; <span class="comment">// 32 字节</span></span><br><span class="line">	inter *interfacetype</span><br><span class="line">	_type *_type</span><br><span class="line">	hash  <span class="keyword">uint32</span></span><br><span class="line">	_     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">	fun   [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了 <code>inter</code> 和 <code>_type</code> 两个用于表示类型的字段之外，上述结构体中的另外两个字段也有自己的作用：</p>
<ul>
<li><code>hash</code> 是对 <code>_type.hash</code> 的拷贝，当我们想将 <code>interface</code> 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime._type"><code>runtime._type</code></a> 是否一致；</li>
<li><code>fun</code> 是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 <code>fun</code> 数组中保存的元素数量是不确定的；</li>
</ul>
<p>我们会在类型断言中介绍 <code>hash</code> 字段的使用，在动态派发一节中介绍 <code>fun</code> 数组中存储的函数指针是如何被使用的。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>既然我们已经了解了接口在运行时的数据结构，接下来会通过几个例子来深入理解接口类型是如何初始化和传递的，本节会介绍在实现接口时使用指针类型和结构体类型的区别。这两种不同的接口实现方式会导致 Go 语言编译器生成不同的汇编代码，进而影响最终的处理过程。</p>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>首先回到这一节开头提到的 <code>Duck</code> 接口的例子，我们使用 <code>//go:noinline</code> 指令禁止 <code>Quack</code> 方法的内联编译：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(c.Name + <span class="string">&quot; meow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用编译器将上述代码编译成汇编语言、删掉一些对理解接口原理无用的指令并保留与赋值语句 <code>var c Duck = &amp;Cat&#123;Name: &quot;draven&quot;&#125;</code> 相关的代码，这里将生成的汇编指令拆分成三部分分析：</p>
<ol>
<li>结构体 <code>Cat</code> 的初始化；</li>
<li>赋值触发的类型转换过程；</li>
<li>调用接口的方法 <code>Quack()</code>；</li>
</ol>
<p>我们先来分析结构体 <code>Cat</code> 的初始化过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LEAQ	<span class="keyword">type</span>.<span class="string">&quot;&quot;</span>.Cat(SB), AX                ;; AX = &amp;<span class="keyword">type</span>.<span class="string">&quot;&quot;</span>.Cat</span><br><span class="line">MOVQ	AX, (SP)                           ;; SP = &amp;<span class="keyword">type</span>.<span class="string">&quot;&quot;</span>.Cat</span><br><span class="line">CALL	runtime.newobject(SB)              ;; SP + <span class="number">8</span> = &amp;Cat&#123;&#125;</span><br><span class="line">MOVQ	<span class="number">8</span>(SP), DI                          ;; DI = &amp;Cat&#123;&#125;</span><br><span class="line">MOVQ	$<span class="number">6</span>, <span class="number">8</span>(DI)                          ;; StringHeader(DI.Name).Len = <span class="number">6</span></span><br><span class="line">LEAQ	<span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">&quot;draven&quot;</span>(SB), AX         ;; AX = &amp;<span class="string">&quot;draven&quot;</span></span><br><span class="line">MOVQ	AX, (DI)                           ;; StringHeader(DI.Name).Data = &amp;<span class="string">&quot;draven&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>获取 <code>Cat</code> 结构体类型指针并将其作为参数放到栈上；</li>
<li>通过 <code>CALL</code> 指定调用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.newobject"><code>runtime.newobject</code></a> 函数，这个函数会以 <code>Cat</code> 结构体类型指针作为入参，分配一片新的内存空间并将指向这片内存空间的指针返回到 SP+8 上；</li>
<li>SP+8 现在存储了一个指向 <code>Cat</code> 结构体的指针，我们将栈上的指针拷贝到寄存器 <code>DI</code> 上方便操作；</li>
<li>由于 <code>Cat</code> 中只包含一个字符串类型的 <code>Name</code> 变量，所以在这里会分别将字符串地址 <code>&amp;&quot;draven&quot;</code> 和字符串长度 6 设置到结构体上，最后三行汇编指令等价于 <code>cat.Name = &quot;draven&quot;</code>；</li>
</ol>
<p>字符串在运行时的表示是指针加上字符串长度，在前面的章节<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/">字符串</a>已经介绍过它的底层表示和实现原理，但是这里要看一下初始化之后的 <code>Cat</code> 结构体在内存中的表示是什么样的：</p>
<p><img src="/images/golang-new-struct-pointer.png" alt="golang-new-struct-pointer"></p>
<p>因为 <code>Cat</code> 结构体的定义中只包含一个字符串，而字符串在 Go 语言中总共占 16 字节，所以每一个 <code>Cat</code> 结构体的大小都是 16 字节。初始化 <code>Cat</code> 结构体之后就进入了将 <code>*Cat</code> 转换成 <code>Duck</code> 类型的过程了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEAQ	<span class="keyword">go</span>.itab.*<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck(SB), AX    ;; AX = *itab(<span class="keyword">go</span>.itab.*<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck)</span><br><span class="line">MOVQ	DI, (SP)                           ;; SP = AX</span><br></pre></td></tr></table></figure>

<p>类型转换的过程比较简单，<code>Duck</code> 作为一个包含方法的接口，它在底层使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体表示。<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体包含两个字段，其中一个是指向数据的指针，另一个是表示接口和结构体关系的 <code>tab</code> 字段，我们已经通过上一段代码 SP+8 初始化了 <code>Cat</code> 结构体指针，这段代码只是将编译期间生成的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 结构体指针复制到 SP 上：</p>
<p><img src="/images/golang-struct-pointer-to-iface.png" alt="golang-struct-pointer-to-iface"></p>
<p>到这里，我们会发现 SP ~ SP+16 共同组成了 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体，而栈上的这个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 也是 <code>Quack</code> 方法的第一个入参。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL    <span class="string">&quot;&quot;</span>.(*Cat).Quack(SB)                ;; SP.Quack()</span><br></pre></td></tr></table></figure>

<p>上述代码会直接通过 <code>CALL</code> 指令完成方法的调用，细心的读者可能会发现一个问题 —— 为什么在代码中我们调用的是 <code>Duck.Quack</code> 但生成的汇编是 <code>*Cat.Quack</code> 呢？Go 语言的编译器会在编译期间将一些需要动态派发的方法调用改写成对目标方法的直接调用，以减少性能的额外开销。如果在这里禁用编译器优化，就会看到动态派发的过程，我们会在后面分析接口的动态派发以及性能上的额外开销。</p>
<h3 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h3><p>在这里我们继续修改上一节中的代码，使用结构体类型实现 <code>Duck</code> 接口并初始化结构体类型的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(c.Name + <span class="string">&quot; meow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在初始化变量时使用指针类型 <code>&amp;Cat&#123;Name: &quot;draven&quot;&#125;</code> 也能够通过编译，不过生成的汇编代码和上一节中的几乎完全相同，所以这里也就不分析这个情况了。</p>
<p>编译上述代码会得到如下所示的汇编指令，需要注意的是为了代码更容易理解和分析，这里的汇编指令依然经过了删减，不过不影响具体的执行过程。与上一节一样，我们将汇编代码的执行过程分成以下几个部分：</p>
<ol>
<li>初始化 <code>Cat</code> 结构体；</li>
<li>完成从 <code>Cat</code> 到 <code>Duck</code> 接口的类型转换；</li>
<li>调用接口的 <code>Quack</code> 方法；</li>
</ol>
<p>我们先来看一下上述汇编代码中用于初始化 <code>Cat</code> 结构体的部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XORPS   X0, X0                          ;; X0 = <span class="number">0</span></span><br><span class="line">MOVUPS  X0, <span class="string">&quot;&quot;</span>..autotmp_1+<span class="number">32</span>(SP)        ;; StringHeader(SP+<span class="number">32</span>).Data = <span class="number">0</span></span><br><span class="line">LEAQ    <span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">&quot;draven&quot;</span>(SB), AX      ;; AX = &amp;<span class="string">&quot;draven&quot;</span></span><br><span class="line">MOVQ    AX, <span class="string">&quot;&quot;</span>..autotmp_1+<span class="number">32</span>(SP)        ;; StringHeader(SP+<span class="number">32</span>).Data = AX</span><br><span class="line">MOVQ    $<span class="number">6</span>, <span class="string">&quot;&quot;</span>..autotmp_1+<span class="number">40</span>(SP)        ;; StringHeader(SP+<span class="number">32</span>).Len = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>这段汇编指令会在栈上初始化 <code>Cat</code> 结构体，而上一节的代码在堆上申请了 16 字节的内存空间，栈上只有一个指向 <code>Cat</code> 的指针。</p>
<p>初始化结构体后会进入类型转换的阶段，编译器会将 <code>go.itab.&quot;&quot;.Cat,&quot;&quot;.Duck</code> 的地址和指向 <code>Cat</code> 结构体的指针作为参数一并传入 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.convT2I"><code>runtime.convT2I</code></a> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEAQ	<span class="keyword">go</span>.itab.<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck(SB), AX     ;; AX = &amp;(<span class="keyword">go</span>.itab.<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck)</span><br><span class="line">MOVQ	AX, (SP)                           ;; SP = AX</span><br><span class="line">LEAQ	<span class="string">&quot;&quot;</span>..autotmp_1+<span class="number">32</span>(SP), AX           ;; AX = &amp;(SP+<span class="number">32</span>) = &amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">MOVQ	AX, <span class="number">8</span>(SP)                          ;; SP + <span class="number">8</span> = AX</span><br><span class="line">CALL	runtime.convT2I(SB)                ;; runtime.convT2I(SP, SP+<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>这个函数会获取 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 中存储的类型，根据类型的大小申请一片内存空间并将 <code>elem</code> 指针中的内容拷贝到目标的内存中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</span><br><span class="line">	t := tab._type</span><br><span class="line">	x := mallocgc(t.size, t, <span class="literal">true</span>)</span><br><span class="line">	typedmemmove(t, x, elem)</span><br><span class="line">	i.tab = tab</span><br><span class="line">	i.data = x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.convT2I"><code>runtime.convT2I</code></a> 会返回一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a>，其中包含 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 指针和 <code>Cat</code> 变量。当前函数返回之后，<code>main</code> 函数的栈上会包含以下数据：</p>
<p><img src="/images/golang-struct-to-iface.png" alt="golang-struct-to-iface"></p>
<p>SP 和 SP+8 中存储的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 和 <code>Cat</code> 指针是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.convT2I"><code>runtime.convT2I</code></a> 函数的入参，这个函数的返回值位于 SP+16，是一个占 16 字节内存空间的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体，SP+32 存储的是在栈上的 <code>Cat</code> 结构体，它会在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.convT2I"><code>runtime.convT2I</code></a> 执行的过程中拷贝到堆上。</p>
<p>在最后，我们会通过以下的指令调用 <code>Cat</code> 实现的接口方法 <code>Quack()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOVQ	<span class="number">16</span>(SP), AX ;; AX = &amp;(<span class="keyword">go</span>.itab.<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck)</span><br><span class="line">MOVQ	<span class="number">24</span>(SP), CX ;; CX = &amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">MOVQ	<span class="number">24</span>(AX), AX ;; AX = AX.fun[<span class="number">0</span>] = Cat.Quack</span><br><span class="line">MOVQ	CX, (SP)   ;; SP = CX</span><br><span class="line">CALL	AX         ;; CX.Quack()</span><br></pre></td></tr></table></figure>

<p>这几个汇编指令还是非常好理解的，<code>MOVQ 24(AX), AX</code> 是最关键的指令，它从 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 结构体中取出 <code>Cat.Quack</code> 方法指针作为 <code>CALL</code> 指令调用时的参数。接口变量的第 24 字节是 <code>itab.fun</code> 数组开始的位置，由于 <code>Duck</code> 接口只包含一个方法，所以 <code>itab.fun[0]</code> 中存储的就是指向 <code>Quack</code> 方法的指针了。</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>上一节介绍是如何把具体类型转换成接口类型，而这一节介绍的是如何将一个接口类型转换成具体类型。本节会根据接口中是否存在方法分两种情况介绍类型断言的执行过程。</p>
<h3 id="非空接口"><a href="#非空接口" class="headerlink" title="非空接口"></a>非空接口</h3><p>首先分析接口中包含方法的情况，<code>Duck</code> 接口一个非空的接口，我们来分析从 <code>Duck</code> 转换回 <code>Cat</code> 结构体的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">switch</span> c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *Cat:</span><br><span class="line">		cat := c.(*Cat)</span><br><span class="line">		cat.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将编译得到的汇编指令分成两部分分析，第一部分是变量的初始化，第二部分是类型断言，第一部分的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000</span> TEXT	<span class="string">&quot;&quot;</span>.main(SB), ABIInternal, $<span class="number">32</span><span class="number">-0</span></span><br><span class="line">...</span><br><span class="line"><span class="number">00029</span> XORPS	X0, X0</span><br><span class="line"><span class="number">00032</span> MOVUPS	X0, <span class="string">&quot;&quot;</span>..autotmp_4+<span class="number">8</span>(SP)</span><br><span class="line"><span class="number">00037</span> LEAQ	<span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">&quot;draven&quot;</span>(SB), AX</span><br><span class="line"><span class="number">00044</span> MOVQ	AX, <span class="string">&quot;&quot;</span>..autotmp_4+<span class="number">8</span>(SP)</span><br><span class="line"><span class="number">00049</span> MOVQ	$<span class="number">6</span>, <span class="string">&quot;&quot;</span>..autotmp_4+<span class="number">16</span>(SP)</span><br></pre></td></tr></table></figure>

<p>0037 ~ 0049 三个指令初始化了 <code>Duck</code> 变量，<code>Cat</code> 结构体初始化在 SP+8 ~ SP+24 上。因为 Go 语言的编译器做了一些优化，所以代码中没有<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 的构建过程，不过对于这一节要介绍的类型断言和转换没有太多的影响。下面进入类型转换的部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00058</span> CMPL  <span class="keyword">go</span>.itab.*<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck+<span class="number">16</span>(SB), $<span class="number">593696792</span></span><br><span class="line">                                        ;; <span class="keyword">if</span> (c.tab.hash != <span class="number">593696792</span>) &#123;</span><br><span class="line"><span class="number">00068</span> JEQ   <span class="number">80</span>                          ;;</span><br><span class="line"><span class="number">00070</span> MOVQ  <span class="number">24</span>(SP), BP                  ;;      BP = SP+<span class="number">24</span></span><br><span class="line"><span class="number">00075</span> ADDQ  $<span class="number">32</span>, SP                     ;;      SP += <span class="number">32</span></span><br><span class="line"><span class="number">00079</span> RET                               ;;      <span class="keyword">return</span></span><br><span class="line">                                        ;; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">00080</span> LEAQ  <span class="string">&quot;&quot;</span>..autotmp_4+<span class="number">8</span>(SP), AX     ;;      AX = &amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line"><span class="number">00085</span> MOVQ  AX, (SP)                    ;;      SP = AX</span><br><span class="line"><span class="number">00089</span> CALL  <span class="string">&quot;&quot;</span>.(*Cat).Quack(SB)         ;;      SP.Quack()</span><br><span class="line"><span class="number">00094</span> JMP   <span class="number">70</span>                          ;;      ...</span><br><span class="line">                                        ;;      BP = SP+<span class="number">24</span></span><br><span class="line">                                        ;;      SP += <span class="number">32</span></span><br><span class="line">                                        ;;      <span class="keyword">return</span></span><br><span class="line">                                        ;; &#125;</span><br></pre></td></tr></table></figure>

<p>switch语句生成的汇编指令会将目标类型的 <code>hash</code> 与接口变量中的 <code>itab.hash</code> 进行比较：</p>
<ul>
<li><p>如果两者相等意味着变量的具体类型是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat</span><br></pre></td></tr></table></figure>

<p>，我们会跳转到 0080 所在的分支完成类型转换。</p>
<ol>
<li>获取 SP+8 存储的 <code>Cat</code> 结构体指针；</li>
<li>将结构体指针拷贝到栈顶；</li>
<li>调用 <code>Quack</code> 方法；</li>
<li>恢复函数的栈并返回；</li>
</ol>
</li>
<li><p>如果接口中存在的具体类型不是 <code>Cat</code>，就会直接恢复栈指针并返回到调用方；</p>
</li>
</ul>
<p><img src="/images/golang-interface-to-struct.png" alt="golang-interface-to-struct"></p>
<p>上图展示了调用 <code>Quack</code> 方法时的堆栈情况，其中 <code>Cat</code> 结构体存储在 SP+8 ~ SP+24 上，<code>Cat</code> 指针存储在栈顶并指向上述结构体。</p>
<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>当我们使用空接口类型 <code>interface&#123;&#125;</code> 进行类型断言时，如果不关闭 Go 语言编译器的优化选项，生成的汇编指令是差不多的。编译器会省略将 <code>Cat</code> 结构体转换成 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.eface"><code>runtime.eface</code></a> 的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = &amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">switch</span> c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *Cat:</span><br><span class="line">		cat := c.(*Cat)</span><br><span class="line">		cat.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果禁用编译器优化，上述代码会在类型断言时就不是直接获取变量中具体类型的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime._type"><code>runtime._type</code></a>，而是从 <code>eface._type</code> 中获取，汇编指令仍然会使用目标类型的 <code>hash</code> 与变量的类型比较。</p>
<h2 id="动态派发"><a href="#动态派发" class="headerlink" title="动态派发"></a>动态派发</h2><p>动态派发（Dynamic dispatch）是在运行期间选择具体多态操作（方法或者函数）执行的过程，它是面向对象语言中的常见特性<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:6">6</a>。Go 语言虽然不是严格意义上的面向对象语言，但是接口的引入为它带来了动态派发这一特性，调用接口类型的方法时，如果编译期间不能确认接口的类型，Go 语言会在运行期间决定具体调用该方法的哪个实现。</p>
<p>在如下所示的代码中，<code>main</code> 函数调用了两次 <code>Quack</code> 方法：</p>
<ol>
<li>第一次以 <code>Duck</code> 接口类型的身份调用，调用时需要经过运行时的动态派发；</li>
<li>第二次以 <code>*Cat</code> 具体类型的身份调用，编译期就会确定调用的函数：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">	c.(*Cat).Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为编译器优化影响了我们对原始汇编指令的理解，所以需要使用编译参数 <code>-N</code> 关闭编译器优化。如果不指定这个参数，编译器会对代码进行重写，与最初生成的执行过程有一些偏差，例如：</p>
<ul>
<li>因为接口类型中的 <code>tab</code> 参数并没有被使用，所以优化从 <code>Cat</code> 转换到 <code>Duck</code> 的过程；</li>
<li>因为变量的具体类型是确定的，所以删除从 <code>Duck</code> 接口类型转换到 <code>*Cat</code> 具体类型时可能会发生崩溃的分支；</li>
<li>…</li>
</ul>
<p>在具体分析调用 <code>Quack</code> 方法的两种姿势之前，我们要先了解 <code>Cat</code> 结构体究竟是如何初始化的，以及初始化后的栈上有哪些数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LEAQ	<span class="keyword">type</span>.<span class="string">&quot;&quot;</span>.Cat(SB), AX</span><br><span class="line">MOVQ	AX, (SP)</span><br><span class="line">CALL	runtime.newobject(SB)              ;; SP + <span class="number">8</span> = <span class="built_in">new</span>(Cat)</span><br><span class="line">MOVQ	<span class="number">8</span>(SP), DI                          ;; DI = SP + <span class="number">8</span></span><br><span class="line">MOVQ	DI, <span class="string">&quot;&quot;</span>..autotmp_2+<span class="number">32</span>(SP)           ;; SP + <span class="number">32</span> = DI</span><br><span class="line">MOVQ	$<span class="number">6</span>, <span class="number">8</span>(DI)                          ;; StringHeader(cat).Len = <span class="number">6</span></span><br><span class="line">LEAQ	<span class="keyword">go</span>.<span class="keyword">string</span>.<span class="string">&quot;draven&quot;</span>(SB), AX         ;; AX = &amp;<span class="string">&quot;draven&quot;</span></span><br><span class="line">MOVQ	AX, (DI)                           ;; StringHeader(cat).Data = AX</span><br><span class="line">MOVQ	<span class="string">&quot;&quot;</span>..autotmp_2+<span class="number">32</span>(SP), AX           ;; AX = &amp;Cat&#123;...&#125;</span><br><span class="line">MOVQ	AX, <span class="string">&quot;&quot;</span>..autotmp_1+<span class="number">40</span>(SP)           ;; SP + <span class="number">40</span> = &amp;Cat&#123;...&#125;</span><br><span class="line">LEAQ	<span class="keyword">go</span>.itab.*<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck(SB), CX    ;; CX = &amp;<span class="keyword">go</span>.itab.*<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck</span><br><span class="line">MOVQ	CX, <span class="string">&quot;&quot;</span>.c+<span class="number">48</span>(SP)                    ;; iface(c).tab = SP + <span class="number">48</span> = CX</span><br><span class="line">MOVQ	AX, <span class="string">&quot;&quot;</span>.c+<span class="number">56</span>(SP)                    ;; iface(c).data = SP + <span class="number">56</span> = AX</span><br></pre></td></tr></table></figure>

<p>这段代码的初始化过程其实和上两节中的过程没有太多的差别，它先初始化了 <code>Cat</code> 结构体指针，再将 <code>Cat</code> 和 <code>tab</code> 打包成了一个 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 类型的结构体，我们直接来看初始化结束后的栈情况：</p>
<p><img src="/images/stack-after-initialize.png" alt="stack-after-initialize"></p>
<ul>
<li>SP 是 <code>Cat</code> 类型，它也是运行时 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.newobject"><code>runtime.newobject</code></a> 方法的参数；</li>
<li>SP+8 是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.newobject"><code>runtime.newobject</code></a> 方法的返回值，即指向堆上的 <code>Cat</code> 结构体的指针；</li>
<li>SP+32、SP+40 是对 SP+8 的拷贝，这两个指针都会指向堆上的 <code>Cat</code> 结构体；</li>
<li>SP+48 ~ SP+64 是接口变量 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体，其中包含了 <code>tab</code> 结构体指针和 <code>*Cat</code> 指针；</li>
</ul>
<p>初始化过程结束后，就进入到了动态派发的过程，<code>c.Quack()</code> 语句展开的汇编指令会在运行时确定函数指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOVQ	<span class="string">&quot;&quot;</span>.c+<span class="number">48</span>(SP), AX                    ;; AX = iface(c).tab</span><br><span class="line">MOVQ	<span class="number">24</span>(AX), AX                         ;; AX = iface(c).tab.fun[<span class="number">0</span>] = Cat.Quack</span><br><span class="line">MOVQ	<span class="string">&quot;&quot;</span>.c+<span class="number">56</span>(SP), CX                    ;; CX = iface(c).data</span><br><span class="line">MOVQ	CX, (SP)                           ;; SP = CX = &amp;Cat&#123;...&#125;</span><br><span class="line">CALL	AX                                 ;; SP.Quack()</span><br></pre></td></tr></table></figure>

<p>这段代码的执行过程可以分成以下三个步骤：</p>
<ol>
<li>从接口变量中获取保存 <code>Cat.Quack</code> 方法指针的 <code>tab.func[0]</code>；</li>
<li>接口变量在 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 中的数据会被拷贝到栈顶；</li>
<li>方法指针会被拷贝到寄存器中并通过汇编指令 <code>CALL</code> 触发：</li>
</ol>
<p>另一个调用 <code>Quack</code> 方法的语句 <code>c.(*Cat).Quack()</code> 生成的汇编指令看起来会有一些复杂，但是代码前半部分都是在做类型转换，将接口类型转换成 <code>*Cat</code> 类型，只有最后两行代码才是函数调用相关的指令：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOVQ	<span class="string">&quot;&quot;</span>.c+<span class="number">56</span>(SP), AX                    ;; AX = iface(c).data = &amp;Cat&#123;...&#125;</span><br><span class="line">MOVQ	<span class="string">&quot;&quot;</span>.c+<span class="number">48</span>(SP), CX                    ;; CX = iface(c).tab</span><br><span class="line">LEAQ	<span class="keyword">go</span>.itab.*<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck(SB), DX    ;; DX = &amp;&amp;<span class="keyword">go</span>.itab.*<span class="string">&quot;&quot;</span>.Cat,<span class="string">&quot;&quot;</span>.Duck</span><br><span class="line">CMPQ	CX, DX                             ;; CMP(CX, DX)</span><br><span class="line">JEQ	<span class="number">163</span></span><br><span class="line">JMP	<span class="number">201</span></span><br><span class="line">MOVQ	AX, <span class="string">&quot;&quot;</span>..autotmp_3+<span class="number">24</span>(SP)           ;; SP+<span class="number">24</span> = &amp;Cat&#123;...&#125;</span><br><span class="line">MOVQ	AX, (SP)                           ;; SP = &amp;Cat&#123;...&#125;</span><br><span class="line">CALL	<span class="string">&quot;&quot;</span>.(*Cat).Quack(SB)                ;; SP.Quack()</span><br></pre></td></tr></table></figure>

<p>下面的几行代码只是将 <code>Cat</code> 指针拷贝到了栈顶并调用 <code>Quack</code> 方法。这一次调用的函数指针在编译期就已经确定了，所以运行时就不需要动态查找方法的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVQ	<span class="string">&quot;&quot;</span>.c+<span class="number">48</span>(SP), AX                    ;; AX = iface(c).tab</span><br><span class="line">MOVQ	<span class="number">24</span>(AX), AX                         ;; AX = iface(c).tab.fun[<span class="number">0</span>] = Cat.Quack</span><br><span class="line">MOVQ	<span class="string">&quot;&quot;</span>.c+<span class="number">56</span>(SP), CX                    ;; CX = iface(c).data</span><br></pre></td></tr></table></figure>

<p>两次方法调用对应的汇编指令差异就是动态派发带来的额外开销，这些额外开销在有低延时、高吞吐量需求的服务中是不能被忽视的，我们来详细分析一下产生的额外汇编指令对性能造成的影响。</p>
<h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>下面代码中的两个方法 <code>BenchmarkDirectCall</code> 和 <code>BenchmarkDynamicDispatch</code> 分别会调用结构体方法和接口方法，在接口上调用方法时会使用动态派发机制，我们以直接调用作为基准分析动态派发带来了多少额外开销：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDirectCall</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	c := &amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		<span class="comment">// MOVQ	AX, &quot;&quot;.c+24(SP)</span></span><br><span class="line">		<span class="comment">// MOVQ	AX, (SP)</span></span><br><span class="line">		<span class="comment">// CALL	&quot;&quot;.(*Cat).Quack(SB)</span></span><br><span class="line">		c.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDynamicDispatch</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	c := Duck(&amp;Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		<span class="comment">// MOVQ	&quot;&quot;.d+56(SP), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	24(AX), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	&quot;&quot;.d+64(SP), CX</span></span><br><span class="line">		<span class="comment">// MOVQ	CX, (SP)</span></span><br><span class="line">		<span class="comment">// CALL	AX</span></span><br><span class="line">		c.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们直接运行下面的命令，使用 1 个 CPU 运行上述代码，每一个基准测试都会被执行 3 次：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -gcflags=-N -benchmem -test.count=<span class="number">3</span> -test.cpu=<span class="number">1</span> -test.benchtime=<span class="number">1</span>s -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/golang/playground</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.11</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">2.94</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.04</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">500000000</span>	         <span class="number">3.40</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">500000000</span>	         <span class="number">3.79</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">500000000</span>	         <span class="number">3.55</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure>

<ul>
<li>调用结构体方法时，每一次调用需要 ~3.03ns；</li>
<li>使用动态派发时，每一调用需要 ~3.58ns；</li>
</ul>
<p>在关闭编译器优化的情况下，从上面的数据来看，动态派发生成的指令会带来 ~18% 左右的额外性能开销。</p>
<p>这些性能开销在一个复杂的系统中不会带来太多的影响。一个项目不可能只使用动态派发，而且如果我们开启编译器优化后，动态派发的额外开销会降低至 ~5%，这对应用性能的整体影响就更小了，所以与使用接口带来的好处相比，动态派发的额外开销往往可以忽略。</p>
<p>上面的性能测试建立在实现和调用方法的都是结构体指针上，当我们将结构体指针换成结构体又会有比较大的差异：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDirectCall</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	c := Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		<span class="comment">// MOVQ	AX, (SP)</span></span><br><span class="line">		<span class="comment">// MOVQ	$6, 8(SP)</span></span><br><span class="line">		<span class="comment">// CALL	&quot;&quot;.Cat.Quack(SB)</span></span><br><span class="line">		c.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkDynamicDispatch</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	c := Duck(Cat&#123;Name: <span class="string">&quot;draven&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		<span class="comment">// MOVQ	16(SP), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	24(SP), CX</span></span><br><span class="line">		<span class="comment">// MOVQ	AX, &quot;&quot;.d+32(SP)</span></span><br><span class="line">		<span class="comment">// MOVQ	CX, &quot;&quot;.d+40(SP)</span></span><br><span class="line">		<span class="comment">// MOVQ	&quot;&quot;.d+32(SP), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	24(AX), AX</span></span><br><span class="line">		<span class="comment">// MOVQ	&quot;&quot;.d+40(SP), CX</span></span><br><span class="line">		<span class="comment">// MOVQ	CX, (SP)</span></span><br><span class="line">		<span class="comment">// CALL	AX</span></span><br><span class="line">		c.Quack()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们重新执行相同的基准测试时，会得到如下所示的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -gcflags=-N -benchmem -test.count=<span class="number">3</span> -test.cpu=<span class="number">1</span> -test.benchtime=<span class="number">1</span>s .</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/golang/playground</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.15</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.02</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDirectCall      	<span class="number">500000000</span>	         <span class="number">3.09</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">200000000</span>	         <span class="number">6.92</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">200000000</span>	         <span class="number">6.91</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br><span class="line">BenchmarkDynamicDispatch 	<span class="number">200000000</span>	         <span class="number">7.10</span> ns/op	       <span class="number">0</span> B/op	       <span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure>

<p>直接调用方法需要消耗时间的平均值和使用指针实现接口时差不多，约为 ~3.09ns，而使用动态派发调用方法却需要 ~6.98ns 相比直接调用额外消耗了 ~125% 的时间，从生成的汇编指令我们也能看出后者的额外开销会高很多。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">直接调用</th>
<th align="center">动态派发</th>
</tr>
</thead>
<tbody><tr>
<td align="center">指针</td>
<td align="center">~3.03ns</td>
<td align="center">~3.58ns</td>
</tr>
<tr>
<td align="center">结构体</td>
<td align="center">~3.09ns</td>
<td align="center">~6.98ns</td>
</tr>
</tbody></table>
<p><em>表 4-2 直接调用和动态派发的性能对比</em></p>
<p>从上述表格我们可以看到使用结构体实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，这也提醒我们应当尽量避免使用结构体类型实现接口。</p>
<p>使用结构体带来的巨大性能差异不只是接口带来的问题，带来性能问题主要因为 Go 语言在函数调用时是传值的，动态派发的过程只是放大了参数拷贝带来的影响。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>