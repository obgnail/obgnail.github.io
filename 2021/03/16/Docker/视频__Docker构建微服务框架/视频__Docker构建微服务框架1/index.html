<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av73285635/&quot;&gt;Docker技术教程&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Docker构建微服务框架1 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Docker/" rel="tag">Docker</a></div><div class="post-time">2021-03-16</div></div></div><div class="container post-header"><h1>Docker构建微服务框架1</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80"><span class="toc-number">1.</span> <span class="toc-text">地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E4%BE%9D%E8%B5%96%E7%9A%84-Linux%E5%86%85%E6%A0%B8%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">Docker依赖的 Linux内核特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Namespaces%E4%BA%94%E7%A7%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.1.</span> <span class="toc-text">Namespaces五种命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Control-groups%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.2.</span> <span class="toc-text">Control groups的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-number">1.1.3.</span> <span class="toc-text">Docker容器的能力</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E7%9A%84CS%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">Docker的CS模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-Machine"><span class="toc-number">1.3.</span> <span class="toc-text">Docker Machine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-machine%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.1.</span> <span class="toc-text">Docker machine命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.4.</span> <span class="toc-text">容器的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">查找退出状态的容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DockerFile%E6%B3%A8%E6%84%8F"><span class="toc-number">1.5.</span> <span class="toc-text">DockerFile注意</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerFile%E7%9A%84Debug"><span class="toc-number">1.5.1.</span> <span class="toc-text">DockerFile的Debug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%E7%9A%84%E5%85%B8%E5%9E%8B%E5%86%99%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">Docker关于命令的典型写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ENTRYPOINT-%E5%8A%A0%E8%BD%BDsh%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">使用ENTRYPOINT 加载sh文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E7%BD%91%E7%BB%9C"><span class="toc-number">1.6.</span> <span class="toc-text">Docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.6.1.</span> <span class="toc-text">网络分层复习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">容器之间的网络连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-network"><span class="toc-number">1.7.</span> <span class="toc-text">docker network</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-network-ls"><span class="toc-number">1.7.1.</span> <span class="toc-text">docker network ls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-network-inspect-networkID"><span class="toc-number">1.7.2.</span> <span class="toc-text">docker network inspect [networkID ]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bridge%E7%BD%91%E7%BB%9C%E4%B8%8B%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E9%80%9A%E8%AE%AF%E7%9A%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">bridge网络下容器之间是怎么通讯的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bridge%E7%BD%91%E7%BB%9C%E4%B8%8B%E5%AE%B9%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91%E7%9A%84-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT"><span class="toc-number">1.7.4.</span> <span class="toc-text">bridge网络下容器是怎么访问外网的 (网络地址转换NAT)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84link"><span class="toc-number">1.8.</span> <span class="toc-text">容器之间的link</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89network"><span class="toc-number">1.8.1.</span> <span class="toc-text">自定义network</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E6%97%B6%E6%8C%87%E5%AE%9Anetwork"><span class="toc-number">1.8.2.</span> <span class="toc-text">创建容器时指定network</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAnetwork"><span class="toc-number">1.8.3.</span> <span class="toc-text">将存在的容器连接到另一个network</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window%E6%88%96Mac%E4%B8%AD-run%E5%91%BD%E4%BB%A4-p%E5%8F%82%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">window或Mac中 run命令-p参数的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#none%E7%BD%91%E7%BB%9C"><span class="toc-number">1.9.</span> <span class="toc-text">none网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#host%E7%BD%91%E7%BB%9C"><span class="toc-number">1.10.</span> <span class="toc-text">host网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#network%E6%80%BB%E7%BB%93"><span class="toc-number">1.11.</span> <span class="toc-text">network总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.12.</span> <span class="toc-text">Docker持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-Data-Volume"><span class="toc-number">1.12.1.</span> <span class="toc-text">数据持久化 : Data Volume</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-volume-ls"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">docker volume ls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-volume-inspect"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">docker volume inspect</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9ABind-Mouting"><span class="toc-number">1.12.2.</span> <span class="toc-text">数据持久化：Bind Mouting</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-compose"><span class="toc-number">1.13.</span> <span class="toc-text">Docker-compose</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Docker-compose"><span class="toc-number">1.13.1.</span> <span class="toc-text">为什么使用Docker-compose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDocker-compose"><span class="toc-number">1.13.2.</span> <span class="toc-text">什么是Docker-compose</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-compose%E4%B8%89%E5%A4%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">1.14.</span> <span class="toc-text">Docker-compose三大概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serices"><span class="toc-number">1.14.1.</span> <span class="toc-text">Serices</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose-yml%E7%A4%BA%E4%BE%8B%E4%B8%80"><span class="toc-number">1.14.2.</span> <span class="toc-text">docker-compose.yml示例一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose-yml%E7%A4%BA%E4%BE%8B%E4%BA%8C"><span class="toc-number">1.14.3.</span> <span class="toc-text">docker-compose.yml示例二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-number">1.14.4.</span> <span class="toc-text">指定自定义网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%BD%91%E7%BB%9C"><span class="toc-number">1.14.5.</span> <span class="toc-text">配置默认网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-number">1.14.6.</span> <span class="toc-text">使用已经存在的网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-compose%E6%B3%A8%E6%84%8F"><span class="toc-number">1.15.</span> <span class="toc-text">docker-compose注意</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E6%8C%87%E5%AE%9A-image-%E5%92%8C-build-%E4%B8%A4%E4%B8%AA%E6%A0%87%E7%AD%BE"><span class="toc-number">1.15.1.</span> <span class="toc-text">同时指定 image 和 build 两个标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#environment%E5%92%8Carg%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.2.</span> <span class="toc-text">environment和arg的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends%E6%A0%87%E7%AD%BE"><span class="toc-number">1.15.3.</span> <span class="toc-text">extends标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-compose%E5%91%BD%E4%BB%A4"><span class="toc-number">1.16.</span> <span class="toc-text">docker-compose命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.16.1.</span> <span class="toc-text">Docker-compose常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-comose-scale-%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.16.2.</span> <span class="toc-text">docker-comose scale 实现负载均衡</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av73285635/">Docker技术教程</a></p>
<p><a target="_blank" rel="noopener" href="https://michael728.github.io/2019/06/15/docker-compose-networks/">Docker Compose 方式下的容器网络基础知识点</a></p>
<h2 id="Docker依赖的-Linux内核特性"><a href="#Docker依赖的-Linux内核特性" class="headerlink" title="Docker依赖的 Linux内核特性"></a>Docker依赖的 Linux内核特性</h2><ul>
<li><p>Namespaces 命名空间</p>
<blockquote>
<p>Linux内核提供的一种对<code>系统资源隔离</code>的机制，例如进程、网络、挂载点等资源。</p>
</blockquote>
</li>
<li><p>Control groups(cgroups) 控制组</p>
<blockquote>
<p>Linux内核提供的一种限制进程资源的机制；例如CPU、内存等资源。</p>
</blockquote>
</li>
<li><p>Union file systems(联合文件系统)</p>
<blockquote>
<p>Container和Image的分层</p>
</blockquote>
</li>
</ul>
<h3 id="Namespaces五种命名空间"><a href="#Namespaces五种命名空间" class="headerlink" title="Namespaces五种命名空间"></a>Namespaces五种命名空间</h3><ul>
<li>PID（Process iD）进程隔离</li>
<li>NET（Network）管理网络接口</li>
<li>IPC（InterProcess Communication）管理跨进程通信的访问</li>
<li>MNT（Mount）管理挂载点</li>
<li>UTS（Unix Timesharing System）隔离內核和版本标识</li>
</ul>
<h3 id="Control-groups的功能"><a href="#Control-groups的功能" class="headerlink" title="Control groups的功能"></a>Control groups的功能</h3><ul>
<li>资源限制</li>
<li>优先级设定</li>
<li>资源计量</li>
<li>资源控制</li>
</ul>
<h3 id="Docker容器的能力"><a href="#Docker容器的能力" class="headerlink" title="Docker容器的能力"></a>Docker容器的能力</h3><p>Namespaces和Control groups使得Docker具有以下功能:</p>
<ul>
<li>文件系统隔离：每个容器都有自己的root文件系统</li>
<li>进程隔离：每个容器都运行在自己的进程环境中</li>
<li>网络隔离：容器间的虚拟网络接口和|P地址都是分开的</li>
<li>资源隔离和分组：使用 groups将CPU和内存之类的资源独立分配给每个Docker容器</li>
</ul>
<p>在运行中的容器内启动<code>新进程</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [-d][-i][-t] 容器名 [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>



<h2 id="Docker的CS模式"><a href="#Docker的CS模式" class="headerlink" title="Docker的CS模式"></a>Docker的CS模式</h2><p><img src="/images/1573281178333.png" alt="1573281178333"></p>
<ul>
<li>守护进程会在Docker启动后一直运行 , 负责实现Docker的各种功能</li>
<li>用户则是通过与Docker的客户端交互 , 进而与Docker的守护进程信息通讯</li>
</ul>
<blockquote>
<p>现在我们学得 , 客户端都是以命令行的形式与用户进行交互的 .</p>
<p>然而Docker还有API形式 , 可以集成到代码中 . 这个API被称为<code>remote API</code></p>
<p><img src="/images/1573281455767.png" alt="1573281455767"></p>
<p><img src="/images/1573363261690.png" alt="1573363261690"></p>
</blockquote>
<h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>docker-machine就是帮助你快速去创建安装docker环境的工具</p>
<ul>
<li>当人们说“Docker”时，他们通常是指 Docker Engine，它是一个客户端 - 服务器应用程序，由 Docker 守护进程、一个REST API指定与守护进程交互的接口、和一个命令行接口（CLI）与守护进程通信（通过封装REST API）。Docker Engine 从 CLI 中接受docker 命令，例如 <code>docker run &lt;image&gt;</code>、<code>docker ps</code> 来列出正在运行的容器。</li>
<li>Docker Machine 是一个用于配置和管理你的宿主机（上面具有 Docker Engine 的主机）的工具。通常，你在你的本地系统上安装 Docker Machine。Docker Machine有自己的命令行客户端 docker-machine 和 Docker Engine 客户端 docker。你可以使用 Machine 在一个或多个虚拟系统上安装 Docker Engine。</li>
<li>使用docker-machine命令，可以启动、审查、停止、重启托管的docker 也可以升级Docker客户端和守护程序并配置docker客户端和宿主机通信。</li>
</ul>
<h3 id="Docker-machine命令"><a href="#Docker-machine命令" class="headerlink" title="Docker machine命令"></a>Docker machine命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>active</td>
<td>查看当前激活状态的Docker主机</td>
</tr>
<tr>
<td>config</td>
<td>查看当前激活状态Docker主机的连接信息</td>
</tr>
<tr>
<td>creat</td>
<td>创建Docker主机</td>
</tr>
<tr>
<td>env</td>
<td>显示连接到某个主机需要的环境变量</td>
</tr>
<tr>
<td>inspect</td>
<td>以json格式输出指定Docker的详细信息</td>
</tr>
<tr>
<td>ip</td>
<td>获取指定Docker主机的地址</td>
</tr>
<tr>
<td>kill</td>
<td>直接杀死指定的Docker主机</td>
</tr>
<tr>
<td>ls</td>
<td>列出所有的管理主机</td>
</tr>
<tr>
<td>provision</td>
<td>重新配置指定主机</td>
</tr>
<tr>
<td>regenerate-certs</td>
<td>为某个主机重新生成TLS信息</td>
</tr>
<tr>
<td>restart</td>
<td>重启指定的主机</td>
</tr>
<tr>
<td>rm</td>
<td>删除某台Docker主机，对应的虚拟机也会被删除</td>
</tr>
<tr>
<td>ssh</td>
<td>通过SSH连接到主机上，执行命令</td>
</tr>
<tr>
<td>scp</td>
<td>在Docker主机之间以及Docker主机和本地主机之间通过scp远程复制数据</td>
</tr>
<tr>
<td>mount</td>
<td>使用SSHFS从计算机装载或卸载目录</td>
</tr>
<tr>
<td>start</td>
<td>启动一个指定的Docker主机，如果对象是个虚拟机，该虚拟机将被启动</td>
</tr>
<tr>
<td>status</td>
<td>获取指定Docker主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等</td>
</tr>
<tr>
<td>stop</td>
<td>停止一个指定的Docker主机</td>
</tr>
<tr>
<td>upgrade</td>
<td>将一个指定主机的Docker版本更新为最新</td>
</tr>
<tr>
<td>url</td>
<td>获取指定Docker主机的监听URL</td>
</tr>
<tr>
<td>version</td>
<td>显示Docker Machine的版本或者主机Docker版本</td>
</tr>
<tr>
<td>help</td>
<td>显示帮助信息</td>
</tr>
</tbody></table>
<h2 id="容器的本质"><a href="#容器的本质" class="headerlink" title="容器的本质"></a>容器的本质</h2><ul>
<li>容器其实本质就是在镜像层上面添加了一个<code>container layer</code> , 这个<code>container layer</code>是可读可写的</li>
<li>image负责app的存储和分发，Container负责运行app</li>
</ul>
<p><img src="/images/1573364789756.png" alt="1573364789756"></p>
<h3 id="查找退出状态的容器"><a href="#查找退出状态的容器" class="headerlink" title="查找退出状态的容器"></a>查找退出状态的容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -f <span class="string">&quot;status=exited&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="DockerFile注意"><a href="#DockerFile注意" class="headerlink" title="DockerFile注意"></a>DockerFile注意</h2><ul>
<li><p>为了美观，复杂的RUN请用反斜线换行！避免无用分层，合并多条命令成一行！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update &amp;&amp; yum install-y vim \</span><br><span class="line">python-dev <span class="comment">#反斜线换行</span></span><br></pre></td></tr></table></figure></li>
<li><p>用 WORKDIR，不要用 RUN CD！<code>尽量使用绝对目录！</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /root</span><br><span class="line">ADD hello <span class="built_in">test</span>/   <span class="comment"># /root/test/hello</span></span><br></pre></td></tr></table></figure></li>
<li><p>能使用copy就不要使用add</p>
</li>
<li><p>尽量使用ENV , 增加可维护性</p>
</li>
<li><p>RUN vs CMD vs ENTRYPOINT</p>
<blockquote>
<p>RUN：执行命令并创建新的 Image Layer</p>
<p>CMD：设置容器启动后默认执行的命令和参数</p>
<p>ENTRYPOINT：设置容器启动时运行的命令和参数</p>
</blockquote>
</li>
<li><p>Shell格式和Exec格式</p>
<blockquote>
<p>shell格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get install -y vim</span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;hello docker&quot;</span></span><br><span class="line">ENTRYPOINT <span class="built_in">echo</span> <span class="string">&quot;hello docker&quot;</span></span><br></pre></td></tr></table></figure>

<p>exec格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN [<span class="string">&quot;apt-get&quot;</span> , <span class="string">&quot;install&quot;</span> ,<span class="string">&quot;-y&quot;</span> ,<span class="string">&quot;vim&quot;</span>]</span><br><span class="line">CMD [<span class="string">&quot;/bin/echo&quot;</span> , <span class="string">&quot;hello docker&quot;</span>]</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/bin/echo&quot;</span> , <span class="string">&quot;hello docker&quot;</span>]</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h3 id="DockerFile的Debug"><a href="#DockerFile的Debug" class="headerlink" title="DockerFile的Debug"></a>DockerFile的Debug</h3><p>当我们build出现问题的时候就会有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Step 1/7 : FROM python</span><br><span class="line">  ---&gt; 12wdx2asd2</span><br><span class="line">Step 2/7 : RUN pip install flask</span><br><span class="line">   ---&gt; asdw24dasx</span><br><span class="line">Step 3/7 : COPY app.py /app/</span><br><span class="line">   ---&gt; 2dfg44dsad</span><br></pre></td></tr></table></figure>

<p>DockerFile支持我们进入这些出现Bug的<code>image layer</code> .</p>
<p>也就是说 , <code>12wdx2asd2</code> , <code>asdw24dasx</code> , <code>2dfg44dsad</code>  都是可以通过<code>docker run -it xxxx</code>进入的</p>
<h3 id="Docker关于命令的典型写法"><a href="#Docker关于命令的典型写法" class="headerlink" title="Docker关于命令的典型写法"></a>Docker关于命令的典型写法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ...</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT[<span class="string">&quot;/usr/bin/stress&quot;</span>]</span><br><span class="line">CMD [--verbose]</span><br></pre></td></tr></table></figure>

<p>执行<code>docker run -it my_container --vm 1</code></p>
<blockquote>
<p>解释 : </p>
<ul>
<li><code>ENTRYPOINT</code>的作用是追加</li>
<li><code>docker run -it my_container --vm 1</code> 后面的<code>--vm 1</code>会被CMD捕获</li>
<li>所以上面的Dockerfile就有这种效果<ol>
<li>默认执行<code>/usr/bin/stress --verbose </code></li>
<li>如果docker run命令带有参数,就像<code>docker run -it my_container --vm 1</code> 那么命令就会变成 <code>/usr/bin/stress --vm 1</code></li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="使用ENTRYPOINT-加载sh文件"><a href="#使用ENTRYPOINT-加载sh文件" class="headerlink" title="使用ENTRYPOINT 加载sh文件"></a>使用ENTRYPOINT 加载sh文件</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /<span class="built_in">test</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /<span class="built_in">test</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;scripts/dev.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> APP_CONFIG=<span class="string">&quot;test.server.config&quot;</span></span><br><span class="line">python manage.py create_db</span><br><span class="line">python manage.py create_admin</span><br><span class="line">python manage.py create_data</span><br><span class="line">python manage.py runserver -h 0.0.0.0</span><br></pre></td></tr></table></figure>



<h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><p>单机</p>
<ul>
<li>Bridge Network</li>
<li>Host Network</li>
<li>None Network</li>
</ul>
<p>多机</p>
<ul>
<li>Overlay Network</li>
</ul>
<h3 id="网络分层复习"><a href="#网络分层复习" class="headerlink" title="网络分层复习"></a>网络分层复习</h3><p><img src="/images/1573369538056.png" alt="1573369538056"></p>
<p>Ping和 telnet</p>
<ul>
<li>ping检测IP的可达性</li>
<li>telnet验证服务的可用性<br>(比如远端服务器的3306端口开了个SQL服务 , 我们就可以使用Telnet检测是否可以使用这个服务)</li>
</ul>
<h3 id="容器之间的网络连接"><a href="#容器之间的网络连接" class="headerlink" title="容器之间的网络连接"></a>容器之间的网络连接</h3><ul>
<li>容器指甲你的网络连接其实是内网 , 外部其实是无法访问的</li>
<li>两个容器就像下图的Namespace test1和Namespace test2</li>
</ul>
<p><img src="/images/1574261087516.png" alt="1574261087516"></p>
<h2 id="docker-network"><a href="#docker-network" class="headerlink" title="docker network"></a>docker network</h2><h3 id="docker-network-ls"><a href="#docker-network-ls" class="headerlink" title="docker network ls"></a>docker network ls</h3><p>当前宿主机上有哪些网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">b6c8a4ac1b80        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">2683635c0cda        host                host                <span class="built_in">local</span></span><br><span class="line">528b0dc5abe2        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure>



<h3 id="docker-network-inspect-networkID"><a href="#docker-network-inspect-networkID" class="headerlink" title="docker network inspect [networkID ]"></a>docker network inspect [networkID ]</h3><p>查看当前网络的信息</p>
<p>其中有一个<code>Containers</code> , 查看使用当前网络的容器</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;81bd6a69a884a5b5848b5ce7b5ed697b0376020d4beb5785262f2e703abb4ca0&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;epic_napier&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;7952063ceabc83147def3b9a709800c5ebd9606ef7df76891623e015c2d169e9&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.17.0.2/16&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="bridge网络下容器之间是怎么通讯的"><a href="#bridge网络下容器之间是怎么通讯的" class="headerlink" title="bridge网络下容器之间是怎么通讯的"></a>bridge网络下容器之间是怎么通讯的</h3><p><img src="/images/1574261890525.png" alt="1574261890525"></p>
<ul>
<li>不同的容器通过不同的pair连接到docker0</li>
<li>docker0就是一个网桥 , 以此沟通了两个容器</li>
<li>docker0 再通过NAT连接到宿主机的eth0网卡 去访问外网 , <strong>这就解释了docker容器为什么能访问外网</strong></li>
</ul>
<h3 id="bridge网络下容器是怎么访问外网的-网络地址转换NAT"><a href="#bridge网络下容器是怎么访问外网的-网络地址转换NAT" class="headerlink" title="bridge网络下容器是怎么访问外网的 (网络地址转换NAT)"></a>bridge网络下容器是怎么访问外网的 (网络地址转换NAT)</h3><p><img src="/images/1573369728786.png" alt="1573369728786"></p>
<p>NAT其实就是一个<strong>映射翻译表</strong></p>
<ul>
<li>内部网络有私有地址 , 但是只有少数几个网络出口</li>
<li>因此就需要<strong>使用NAT来对内部网络地址进行翻译 , 确定哪条信息是属于哪个网络地址的</strong></li>
</ul>
<blockquote>
<p>说人话 :</p>
<ul>
<li>NAT用于映射内部网络到宿主机的网卡</li>
<li>比如说宿主机从外网获取数据 , 就是通过NAT知道到底这份数据是属于哪个容器的</li>
</ul>
</blockquote>
<h2 id="容器之间的link"><a href="#容器之间的link" class="headerlink" title="容器之间的link"></a>容器之间的link</h2><p><strong>默认 bridge 网络上的容器只能通过 IP 地址互相访问，除非使用在 docker run 时添加 <code>—link</code> 参数。</strong></p>
<ul>
<li>link用于容器之间的连接 , 常用于后台容器访问数据库容器</li>
<li>一般而言 , 后台容器需要知道数据库容器的ip地址才能连接,但是ip地址是不确定的 .</li>
<li>因此我们可以数据库容器起一个名字 , 然后通过名字来访问这个容器</li>
</ul>
<p><img src="/images/6d9475f6ly1g415cdupwjj20fa0faq3q.jpg" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name test2 --link test1</span><br></pre></td></tr></table></figure>

<p>创建test2 , 并且把test2连接到test1上(这个test1一般就是数据库容器)</p>
<p>此时我们使用<code>docker exec -it test2 /bin/sh</code>进入test2 , 然后执行<code>ping test1</code> 发现可以ping通</p>
<blockquote>
<ul>
<li><code>docker run -d --name test2 --link test1</code>有点类似于该test2添加一个DNS记录(实际上就是加入到hosts文件)</li>
<li>原理 : 因为test1容器本身就是存在的 , 所以可以获取test1的IP,将其映射到test1上</li>
<li>使用 : 如果tests1就是mysql , 那么我们就可以使用<code>test1:3306</code>来访问MySQL了</li>
</ul>
</blockquote>
<p>注意 : </p>
<ul>
<li>LINK有指向性</li>
<li><code>docker run -d --name test2 --link test1</code> 只能是test2指向test1 , 不能反过来</li>
<li>也就是说 , 在test1容器里 , 是不能ping test2的</li>
<li>本质 : 只会往一个容器的hosts文件加入对方的IP</li>
</ul>
<h3 id="自定义network"><a href="#自定义network" class="headerlink" title="自定义network"></a>自定义network</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-bridge</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-d</code> : drive</p>
</blockquote>
<p>之后使用<code>docker network ls</code> 查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                             DRIVER              SCOPE</span><br><span class="line">000836550c9f        bridge                           bridge              <span class="built_in">local</span></span><br><span class="line">2683635c0cda        host                             host                <span class="built_in">local</span></span><br><span class="line">d5de830f3890        my-bridge                        bridge              <span class="built_in">local</span></span><br><span class="line">528b0dc5abe2        none                             null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure>



<h3 id="创建容器时指定network"><a href="#创建容器时指定network" class="headerlink" title="创建容器时指定network"></a>创建容器时指定network</h3><p>这样 , 我们就可以在创建容器的时候指定network</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network my-bridge busybox</span><br></pre></td></tr></table></figure>



<h3 id="将存在的容器连接到另一个network"><a href="#将存在的容器连接到另一个network" class="headerlink" title="将存在的容器连接到另一个network"></a>将存在的容器连接到另一个network</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-bridge busybox</span><br></pre></td></tr></table></figure>

<p>将busybox容器 连接到 my-bridge 这个网络上</p>
<blockquote>
<p>注意 : <strong>如果两个容器连接到自定义的网络 , 那么这两个容器就是自动link好的</strong></p>
<p>如果是连接到默认的<code>bridge</code> 则不会</p>
</blockquote>
<blockquote>
<p>注意 : docker-compose中的networks是这个容器待加入的网络 , 如果网络不存在就会报错 .</p>
<p>这时就需要在底下创建network</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mongo:4</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">devops-mongo</span> <span class="comment"># 容器名</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;27017:27017&quot;</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;/data/docker_local/mongo/configdb:/data/configdb&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;/data/docker_local/mongo/data/db:/data/db&quot;</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">--auth</span> <span class="comment"># 开启授权验证</span></span><br><span class="line">        <span class="attr">networks:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">mongo_net</span></span><br><span class="line"><span class="comment"># 创建network</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">mongo_net:</span></span><br><span class="line">  	<span class="attr">name:</span> <span class="string">mongo_net</span></span><br></pre></td></tr></table></figure>

<p>如果你想要你的容器加入到一个已存在的网络中，使用 <code>external</code> 选项:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">proxy:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./proxy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">outside</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./app</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">outside:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这时候不会去创建一个 <code>[projectname]_outside</code> 的网络， Compose 会去查找一个已存在的叫做 <code>outside</code> 的网络，并且将它和 <code>proxy</code> 服务相连。</p>
</blockquote>
<h3 id="window或Mac中-run命令-p参数的本质"><a href="#window或Mac中-run命令-p参数的本质" class="headerlink" title="window或Mac中 run命令-p参数的本质"></a>window或Mac中 run命令-p参数的本质</h3><p><img src="/images/1574263682922.png" alt="1574263682922"></p>
<ul>
<li>-p的功能就是映射了<code>eth1</code> 和<code>docker0</code></li>
</ul>
<h2 id="none网络"><a href="#none网络" class="headerlink" title="none网络"></a>none网络</h2><p>创建一个network为none的容器 , 我们通过 <code>docker network inspect [networkID]</code> , 查看Containers信息</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;85735c6a7a54d4f8ed8b603485fe973d60c4ab7240556b853cbacb822537870a&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;pensive_borg&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;793d5c30f9e715151544b5c6eb9009cce59d5ba761d20fd3b66525aac37ec032&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>发现<code>MacAddress</code>,<code>IPv4Address</code>,<code>IPv6Address</code>都是空的</p>
<p>所以 , 该容器只能通过<code>docker exec -it </code>的方式连接这个容器</p>
<h2 id="host网络"><a href="#host网络" class="headerlink" title="host网络"></a>host网络</h2><p>创建一个network为host的容器 , 我们通过 <code>docker network inspect [networkID]</code> , 查看Containers信息</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;df4d59714558f78fc9ece107fc42a28e6a4dd9e9ddefc47b5833ecd41f3f1227&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;hardcore_leakey&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;ca5e05d54e5a7fc7eeb8db5687bb6272ab5983c11800c21bc24c15dbd35efd42&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>host网络 : 没有独立的network Namespace , 共用宿主机的网络</p>
<h2 id="network总结"><a href="#network总结" class="headerlink" title="network总结"></a>network总结</h2><ol>
<li>none : 只能通过<code>docker exec -it </code>的方式连接这个容器</li>
<li>bridge : 在不使用<code>--link</code>的时候 , 使用默认的bridge的容器之间只是IP互通 , 无法通过link方式连接 , 而使用自定义容器却可以以link方式连接</li>
<li>host : 没有独立的network Namespace , 共用宿主机的网络</li>
</ol>
<h2 id="Docker持久化"><a href="#Docker持久化" class="headerlink" title="Docker持久化"></a>Docker持久化</h2><p>持久化数据的方案</p>
<ul>
<li>基于<code>本地文件系统</code>的 Volume : 可以在执行 Docker create或 Docker  run时，通过<code>-v</code>参数将主机的目录作为容器的数据卷。这部分功能便是基于本地文件系统的 volume管理。</li>
<li>基于plugin的 Volume : 支持第三方的存储方案，比如NAS, aws</li>
</ul>
<h3 id="数据持久化-Data-Volume"><a href="#数据持久化-Data-Volume" class="headerlink" title="数据持久化 : Data Volume"></a>数据持久化 : Data Volume</h3><h4 id="docker-volume-ls"><a href="#docker-volume-ls" class="headerlink" title="docker volume ls"></a>docker volume ls</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br><span class="line"><span class="comment"># DRIVER              VOLUME NAME</span></span><br><span class="line"><span class="comment"># local               f4d1af1ff85d46d3d8faabca45f7e898da2074413a9ec1607d05290527806367</span></span><br></pre></td></tr></table></figure>

<h4 id="docker-volume-inspect"><a href="#docker-volume-inspect" class="headerlink" title="docker volume inspect"></a>docker volume inspect</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect f4d1af1ff85d46d3d8faabca45f7e898da2074413a9ec1607d05290527806367</span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#     &#123;</span></span><br><span class="line"><span class="comment">#         &quot;CreatedAt&quot;: &quot;2019-11-20T03:06:20Z&quot;,</span></span><br><span class="line"><span class="comment">#         &quot;Driver&quot;: &quot;local&quot;,</span></span><br><span class="line"><span class="comment">#         &quot;Labels&quot;: null,</span></span><br><span class="line"><span class="comment">#         &quot;Mountpoint&quot;: &quot;/mnt/sda1/var/lib/docker/volumes/f4d1af1ff85d46d3d8faabca45f7e898da2074413a9ec1607d05290527806367/_data&quot;,</span></span><br><span class="line"> <span class="comment">#        &quot;Name&quot;: &quot;f4d1af1ff85d46d3d8faabca45f7e898da2074413a9ec1607d05290527806367&quot;,</span></span><br><span class="line"><span class="comment">#       &quot;Options&quot;: null,</span></span><br><span class="line"> <span class="comment">#      &quot;Scope&quot;: &quot;local&quot;</span></span><br><span class="line">  <span class="comment">#   &#125;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><img src="/images/1574341291438.png" alt="1574341291438"></p>
<p>可见 , </p>
<ul>
<li>Data Volume其实并不是将数据存储到容器的<code>layer</code>中 </li>
<li>而是将数据存储到<code>Volume</code>中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v msyql:/dev/mysql/data</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 , 这里并不是连接宿主机和容器的数据卷 , 而是给<code>/dev/mysql/data</code>这个数据卷起一个名字<code>mysql</code>而已</p>
<p>我们可以通过<code>docker volume create mysql</code>来创建这个数据卷</p>
<p>eg:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge test_volume</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="数据持久化：Bind-Mouting"><a href="#数据持久化：Bind-Mouting" class="headerlink" title="数据持久化：Bind Mouting"></a>数据持久化：Bind Mouting</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /home/aaa:/root/aaa</span><br></pre></td></tr></table></figure>

<p>联通宿主机和容器的两个目录</p>
<h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h2><h3 id="为什么使用Docker-compose"><a href="#为什么使用Docker-compose" class="headerlink" title="为什么使用Docker-compose"></a>为什么使用Docker-compose</h3><blockquote>
<p>多容器的APP太恶心</p>
<ul>
<li>要从 Dockerfile build image或者Dockerhub拉取image</li>
<li>要创建多个 container</li>
<li>要管理这些 container（启动停止删除）</li>
</ul>
</blockquote>
<p>所以我们就想要使用文件来批量处理多个容器</p>
<h3 id="什么是Docker-compose"><a href="#什么是Docker-compose" class="headerlink" title="什么是Docker-compose"></a>什么是Docker-compose</h3><ul>
<li>Docker Compose是一个工具</li>
<li>这个工具可以通过一个yml文件定义多容器的 docker 应用</li>
<li>通过一条命令就可以根据yml文件的定义去创建或者管理多个容器</li>
</ul>
<p>就像dockerFile的默认名为<code>dockerfile</code>一样 , 这个yml文件的默认名为<code>docker-compose.yml</code></p>
<h2 id="Docker-compose三大概念"><a href="#Docker-compose三大概念" class="headerlink" title="Docker-compose三大概念"></a>Docker-compose三大概念</h2><ul>
<li>Serices</li>
<li>Networks</li>
<li>Volumes</li>
</ul>
<blockquote>
<ul>
<li>使用<code>docker-compose up</code> 就可以将serices启动了</li>
<li>默认寻找<code>docker-compose</code>文件</li>
<li>如果文件名改了 , 就可以使用<code>docker -compose -f my_docker-compose.yml up</code>启动</li>
</ul>
</blockquote>
<h3 id="Serices"><a href="#Serices" class="headerlink" title="Serices"></a>Serices</h3><ul>
<li><strong>一个 service代表一个 container</strong>，这个 container 可以从dockerhub的 image 来创建，或者从本地的 Dockerfile buld出来的image来创建</li>
<li>Service的启动类似 docker run，我们可以给其指定network和 volume，所以可以给 service指定 network 和Volume的引用</li>
</ul>
<h3 id="docker-compose-yml示例一"><a href="#docker-compose-yml示例一" class="headerlink" title="docker-compose.yml示例一"></a>docker-compose.yml示例一</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">	<span class="attr">wordpress:</span></span><br><span class="line">		<span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">		<span class="attr">ports:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">		<span class="attr">environment:</span></span><br><span class="line">			<span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql</span></span><br><span class="line">			<span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">		<span class="attr">networks:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">my-bridge</span></span><br><span class="line">	</span><br><span class="line">	<span class="attr">mysql:</span></span><br><span class="line">		<span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">		<span class="attr">encironment:</span></span><br><span class="line">			<span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">			<span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">		<span class="attr">volumes:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">		<span class="attr">networks:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">my-bridge</span></span><br><span class="line">	</span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">	<span class="attr">mysql-data:</span></span><br><span class="line">	</span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">	<span class="attr">my-bridge:</span></span><br><span class="line">		<span class="attr">driver:</span> <span class="string">brige</span></span><br></pre></td></tr></table></figure>

<h3 id="docker-compose-yml示例二"><a href="#docker-compose-yml示例二" class="headerlink" title="docker-compose.yml示例二"></a>docker-compose.yml示例二</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">op-tasks:</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/bash</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">                gunicorn -c gunicorn.py app:app &amp;</span></span><br><span class="line"><span class="string">                python run_celery.py worker -l info --beat -c 1</span></span><br><span class="line"><span class="string"></span>        <span class="attr">container_name:</span> <span class="string">op-tasks</span></span><br><span class="line">        <span class="attr">env_file:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">optasks-variables.env</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;50020:5000&#x27;</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">.:/var/www/op-tasks</span></span><br><span class="line">        <span class="attr">depends_on:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">op-tasks-redis</span></span><br><span class="line">        <span class="attr">links:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">op-tasks-redis</span></span><br><span class="line">        <span class="attr">network_mode:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">op-tasks-redis:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">op-tasks-redis</span></span><br><span class="line">        <span class="attr">network_mode:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>



<h3 id="指定自定义网络"><a href="#指定自定义网络" class="headerlink" title="指定自定义网络"></a>指定自定义网络</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">proxy:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./proxy</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">front</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./app</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">front</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">back</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">back</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">front:</span></span><br><span class="line">    <span class="comment"># Use a custom driver</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">custom-driver-1</span></span><br><span class="line">  <span class="attr">back:</span></span><br><span class="line">    <span class="comment"># Use a custom driver which takes special options</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">custom-driver-2</span></span><br><span class="line">    <span class="attr">driver_opts:</span></span><br><span class="line">      <span class="attr">foo:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">      <span class="attr">bar:</span> <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="配置默认网络"><a href="#配置默认网络" class="headerlink" title="配置默认网络"></a>配置默认网络</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="comment"># Use a custom driver</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">custom-driver-1</span></span><br></pre></td></tr></table></figure>



<h3 id="使用已经存在的网络"><a href="#使用已经存在的网络" class="headerlink" title="使用已经存在的网络"></a>使用已经存在的网络</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">my-pre-existing-network</span></span><br></pre></td></tr></table></figure>



<h2 id="docker-compose注意"><a href="#docker-compose注意" class="headerlink" title="docker-compose注意"></a>docker-compose注意</h2><h3 id="同时指定-image-和-build-两个标签"><a href="#同时指定-image-和-build-两个标签" class="headerlink" title="同时指定 image 和 build 两个标签"></a>同时指定 image 和 build 两个标签</h3><p>如果同时指定了 image 和 build 两个标签，那么 Compose 会构建镜像并且把镜像命名为 image 后面的那个名字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build: ./dir</span><br><span class="line">image: webapp:tag</span><br></pre></td></tr></table></figure>



<h3 id="environment和arg的区别"><a href="#environment和arg的区别" class="headerlink" title="environment和arg的区别"></a>environment和arg的区别</h3><ul>
<li>environment可以保存变量到镜像里面，也就是说启动的容器也会包含这些变量设置，</li>
<li>arg 不能保存变量到镜像里面。</li>
</ul>
<h3 id="extends标签"><a href="#extends标签" class="headerlink" title="extends标签"></a>extends标签</h3><ul>
<li>extends标签可以扩展另一个服务，</li>
<li>扩展内容可以是来自在当前文件，也可以是来自其他文件，</li>
<li><strong>相同服务的情况下，后来者会有选择地覆盖原有配置</strong>。</li>
</ul>
<h2 id="docker-compose命令"><a href="#docker-compose命令" class="headerlink" title="docker-compose命令"></a>docker-compose命令</h2><ul>
<li><p>就像<code>docker ps</code>一样 ,有<code>docker-compose ps</code>命令  </p>
</li>
<li><p>同理有 : <code>docker-compose rm</code></p>
</li>
<li><p><code>docker-compose stop</code></p>
</li>
<li><p><code>docker-compose start</code></p>
</li>
<li><p><code>docker-compose down</code> : 退出并删除容器 (不会删除image)</p>
</li>
<li><p><code>docker-compose up -d</code> : 后台运行容器</p>
</li>
<li><p><code>docker-compose images</code> : 列出docker-compose.yml文件中定义的image</p>
</li>
<li><p><code>docker-compose exec my_container XXX</code> : 执行某个容器的exec的XXX命令</p>
<blockquote>
<p>eg : <code>docker-compose exec my_container bash</code></p>
</blockquote>
</li>
<li><p><code>docker</code></p>
</li>
</ul>
<h3 id="Docker-compose常用命令"><a href="#Docker-compose常用命令" class="headerlink" title="Docker-compose常用命令"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moxiaoan/p/9299404.html">Docker-compose常用命令</a></h3><p>docker能用的命令docker-compose基本都能用</p>
<ul>
<li>docker-compose ps</li>
<li>docker-compose exec</li>
<li>docker-compose images</li>
<li>docker-compose build</li>
<li>…</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>docker-compose up -d nginx</td>
<td>构建建启动nignx容器</td>
</tr>
<tr>
<td>docker-compose exec nginx bash</td>
<td>登录到nginx容器中</td>
</tr>
<tr>
<td>docker-compose down</td>
<td>删除所有nginx容器,镜像</td>
</tr>
<tr>
<td>docker-compose ps</td>
<td>显示所有容器</td>
</tr>
<tr>
<td>docker-compose restart nginx</td>
<td>重新启动nginx容器</td>
</tr>
<tr>
<td>docker-compose run –no-deps –rm php-fpm php -v</td>
<td>在php-fpm中不启动关联容器，并容器执行php -v 执行完成后删除容器</td>
</tr>
<tr>
<td>docker-compose build nginx</td>
<td>构建镜像 。</td>
</tr>
<tr>
<td>docker-compose build –no-cache nginx</td>
<td>不带缓存的构建。</td>
</tr>
<tr>
<td>docker-compose logs  nginx</td>
<td>查看nginx的日志</td>
</tr>
<tr>
<td>docker-compose logs -f nginx</td>
<td>查看nginx的实时日志</td>
</tr>
<tr>
<td>docker-compose config  -q</td>
<td>验证（docker-compose.yml）文件配置，当配置正确时，不输出任何内容，当文件配置错误，输出错误信息。</td>
</tr>
<tr>
<td>docker-compose events –json nginx</td>
<td>以json的形式输出nginx的docker日志</td>
</tr>
<tr>
<td>docker-compose pause nginx</td>
<td>暂停nignx容器</td>
</tr>
<tr>
<td>docker-compose unpause nginx</td>
<td>恢复ningx容器</td>
</tr>
<tr>
<td>docker-compose rm nginx</td>
<td>删除容器（删除前必须关闭容器）</td>
</tr>
<tr>
<td>docker-compose stop nginx</td>
<td>停止nignx容器</td>
</tr>
<tr>
<td>docker-compose start nginx</td>
<td>启动nignx容器</td>
</tr>
</tbody></table>
<h3 id="docker-comose-scale-实现负载均衡"><a href="#docker-comose-scale-实现负载均衡" class="headerlink" title="docker-comose scale 实现负载均衡"></a>docker-comose scale 实现负载均衡</h3><ul>
<li>scale : 规模</li>
<li>就是说 , scale命令能创建多个一模一样的容器</li>
</ul>
<p>示例 :</p>
<p>现在<code>docker-compose.yml</code>文件如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">		<span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">		</span><br><span class="line">	<span class="attr">web:</span></span><br><span class="line">		<span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">		<span class="attr">posts:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="number">8080</span><span class="string">:5000</span></span><br><span class="line">		<span class="attr">environement:</span></span><br><span class="line">			<span class="string">REDIS_HOST:redis</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --scale web=3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码其实就执行错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting flaskredis_web_1 ... <span class="keyword">done</span></span><br><span class="line">Starting flaskredis_web_2  ... error</span><br><span class="line">Starting flaskredis_web_3 ... error</span><br></pre></td></tr></table></figure>

<ul>
<li>可见第一个启动成功 , 接下来的都是启动失败 </li>
<li>原因 : <code>端口占用</code> , </li>
<li>flask需要使用端口 , 而 <code>--scale</code>开启了一模一样的容器 , 自然端口也一样</li>
<li>这时只需要将<code>docker-compose.yml</code>中的posts标签删掉即可</li>
</ul>
</blockquote>
<p>因为开启了3个web容器 , 但只有一个redis容器 , 这么这3个web容器都会去访问redis容器</p>
<p>如果在前面添加一个<code>负载均衡器</code>(HAProxy) , 能把外界的访问平均负载到多个web容器 , 这样就实现了<strong>负载均衡</strong></p>
<p><img src="/images/1574346624394.png" alt="1574346624394"></p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>