<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第二章-快速开始一个Go程序&quot;&gt;&lt;a href=&quot;#第二章-快速开始一个Go程序&quot; class=&quot;headerlink&quot; title=&quot;第二章 快速开始一个Go程序&quot;&gt;&lt;/a&gt;第二章 快速开始一个Go程序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个包定义一组编译过的代码。&lt;/li&gt;
&lt;li&gt;Go 编译器不允许声明导入某个包却不使用。下划线让编译器接受这类导入，并且调用对应包内的所有代码文件里定义的 init 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;防止goroutine提前退出&quot;&gt;&lt;a href=&quot;#防止goroutine提前退出&quot; class=&quot;headerlink&quot; title=&quot;防止goroutine提前退出&quot;&gt;&lt;/a&gt;防止goroutine提前退出&lt;/h3&gt;&lt;h4 id=&quot;使用休眠&quot;&gt;&lt;a href=&quot;#使用休眠&quot; class=&quot;headerlink&quot; title=&quot;使用休眠&quot;&gt;&lt;/a&gt;使用休眠&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; ; i++&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; fmt.Println(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    time.Sleep(time.Second)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h4 id=&quot;使用管道&quot;&gt;&lt;a href=&quot;#使用管道&quot; class=&quot;headerlink&quot; title=&quot;使用管道&quot;&gt;&lt;/a&gt;使用管道&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fmt.Println(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            c &amp;lt;- &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h4 id=&quot;使用sync-WaitGroup&quot;&gt;&lt;a href=&quot;#使用sync-WaitGroup&quot; class=&quot;headerlink&quot; title=&quot;使用sync.WaitGroup&quot;&gt;&lt;/a&gt;使用sync.WaitGroup&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WaitGroup&lt;/code&gt; 对象内部有一个计数器，最初从0开始，它有三个方法：&lt;code&gt;Add(), Done(), Wait()&lt;/code&gt; 用来控制计数器的数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(n)&lt;/code&gt; 把计数器设置为&lt;code&gt;n&lt;/code&gt; ，&lt;code&gt;Done()&lt;/code&gt; 每次把计数器&lt;code&gt;-1&lt;/code&gt; ，&lt;code&gt;wait()&lt;/code&gt; 会阻塞代码的运行，直到计数器地值减为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;sync&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wg := sync.WaitGroup&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wg.Add(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fmt.Println(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            wg.Done()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wg.Wait() &lt;span class=&quot;comment&quot;&gt;// 阻塞代码，直到计数降到零&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;done&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;注意：WaitGroup对象不是一个引用类型，WaitGroup对象不是一个引用类型，在通过函数传值的时候需要使用地址："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>GO语言实战 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2021-03-26</div></div></div><div class="container post-header"><h1>GO语言实战</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">第二章 快速开始一个Go程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2goroutine%E6%8F%90%E5%89%8D%E9%80%80%E5%87%BA"><span class="toc-number">1.1.</span> <span class="toc-text">防止goroutine提前退出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BC%91%E7%9C%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93"><span class="toc-number">1.1.2.</span> <span class="toc-text">使用管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8sync-WaitGroup"><span class="toc-number">1.1.3.</span> <span class="toc-text">使用sync.WaitGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#For-range%E9%81%8D%E5%8E%86%E9%80%9A%E9%81%93"><span class="toc-number">1.1.4.</span> <span class="toc-text">For range遍历通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.2.</span> <span class="toc-text">全局的适配器的最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%89%93%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE"><span class="toc-number">2.</span> <span class="toc-text">第三章 打包和工具链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go-get%E8%8E%B7%E5%8F%96%E7%9A%84%E5%8C%85%E5%92%8Cgit-clone%E8%8E%B7%E5%8F%96%E7%9A%84%E5%8C%85%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">go get获取的包和git clone获取的包区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E5%8C%85%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E4%BB%BB%E6%84%8F%E5%A4%9A%E4%B8%AA-init-%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">每个包可以包含任意多个 init 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Go-%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">2.3.</span> <span class="toc-text">使用 Go 的工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E6%98%A0%E5%B0%84"><span class="toc-number">3.</span> <span class="toc-text">第四章 数组、切片和映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">第五章 Go 语言的类型系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B9%B6%E5%8F%91"><span class="toc-number">5.</span> <span class="toc-text">第六章 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine"><span class="toc-number">5.1.</span> <span class="toc-text">Goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E7%8A%B6%E6%80%81"><span class="toc-number">5.2.</span> <span class="toc-text">竞争状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E4%BD%8F%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">5.3.</span> <span class="toc-text">锁住共享资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.1.</span> <span class="toc-text">原子函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">5.3.2.</span> <span class="toc-text">互斥锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93"><span class="toc-number">5.4.</span> <span class="toc-text">通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">5.4.1.</span> <span class="toc-text">无缓冲的通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">5.4.2.</span> <span class="toc-text">有缓冲的通道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">第七章 并发模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#runner"><span class="toc-number">6.1.</span> <span class="toc-text">runner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pool"><span class="toc-number">6.2.</span> <span class="toc-text">pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#work"><span class="toc-number">6.3.</span> <span class="toc-text">work</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">7.</span> <span class="toc-text">第八章 标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#log"><span class="toc-number">7.1.</span> <span class="toc-text">log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E7%9A%84%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%99%A8"><span class="toc-number">7.1.1.</span> <span class="toc-text">定制的日志记录器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#json"><span class="toc-number">7.2.</span> <span class="toc-text">json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io"><span class="toc-number">7.3.</span> <span class="toc-text">io</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Writer-%E5%92%8C-Reader-%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.3.1.</span> <span class="toc-text">Writer 和 Reader 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%90%88%E5%B9%B6%E5%AE%8C%E6%88%90%E5%B7%A5%E4%BD%9C"><span class="toc-number">7.3.2.</span> <span class="toc-text">整合并完成工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84curl"><span class="toc-number">7.3.3.</span> <span class="toc-text">简单的curl</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-%E4%B9%9D-%E7%AB%A0-%E6%B5%8B%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD"><span class="toc-number">8.</span> <span class="toc-text">第 九 章 测试和性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">8.1.</span> <span class="toc-text">基础单元测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E4%BB%BF%E8%B0%83%E7%94%A8"><span class="toc-number">8.2.</span> <span class="toc-text">模仿调用</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="第二章-快速开始一个Go程序"><a href="#第二章-快速开始一个Go程序" class="headerlink" title="第二章 快速开始一个Go程序"></a>第二章 快速开始一个Go程序</h2><ul>
<li>一个包定义一组编译过的代码。</li>
<li>Go 编译器不允许声明导入某个包却不使用。下划线让编译器接受这类导入，并且调用对应包内的所有代码文件里定义的 init 函数。</li>
</ul>
<h3 id="防止goroutine提前退出"><a href="#防止goroutine提前退出" class="headerlink" title="防止goroutine提前退出"></a>防止goroutine提前退出</h3><h4 id="使用休眠"><a href="#使用休眠" class="headerlink" title="使用休眠"></a>使用休眠</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span> ; i++&#123;</span><br><span class="line">        <span class="keyword">go</span> fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            c &lt;- <span class="literal">true</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        &lt;-c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用sync-WaitGroup"><a href="#使用sync-WaitGroup" class="headerlink" title="使用sync.WaitGroup"></a>使用sync.WaitGroup</h4><ul>
<li><code>WaitGroup</code> 对象内部有一个计数器，最初从0开始，它有三个方法：<code>Add(), Done(), Wait()</code> 用来控制计数器的数量。</li>
<li><code>Add(n)</code> 把计数器设置为<code>n</code> ，<code>Done()</code> 每次把计数器<code>-1</code> ，<code>wait()</code> 会阻塞代码的运行，直到计数器地值减为0。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 阻塞代码，直到计数降到零</span></span><br><span class="line">  	fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：WaitGroup对象不是一个引用类型，WaitGroup对象不是一个引用类型，在通过函数传值的时候需要使用地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> f(i, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要通过指针传值，不然进程会进入死锁状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123; </span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="For-range遍历通道"><a href="#For-range遍历通道" class="headerlink" title="For range遍历通道"></a>For range遍历通道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 启动一个 goroutine 来监控是否所有的工作都做完了</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 等候所有任务完成</span></span><br><span class="line">		waitGroup.Wait()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 用关闭通道的方式，通知 Display 函数</span></span><br><span class="line">		<span class="comment">//  可以退出程序了</span></span><br><span class="line">		<span class="built_in">close</span>(results)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(results <span class="keyword">chan</span> *Result)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通道会一直被阻塞，直到有结果写入</span></span><br><span class="line">	<span class="comment">// 一旦通道被关闭，for 循环就会终止</span></span><br><span class="line">	<span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;%s:\n%s\n\n&quot;</span>, result.Field, result.Content)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="全局的适配器的最佳实践"><a href="#全局的适配器的最佳实践" class="headerlink" title="全局的适配器的最佳实践"></a>全局的适配器的最佳实践</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> defaultMatcher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> matcher defaultMatcher</span><br><span class="line">	Register(<span class="string">&quot;default&quot;</span>, matcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Matcher <span class="keyword">interface</span> &#123;</span><br><span class="line">	Search(feed *Feed, searchTerm <span class="keyword">string</span>) ([]*Result, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GlobleMatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">  matchers <span class="keyword">map</span>[<span class="keyword">string</span>]Matcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globleMatcher GlobleMatcher</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(feedType <span class="keyword">string</span>, matcher Matcher)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, exists := matchers[feedType]; exists &#123;</span><br><span class="line">		log.Fatalln(feedType, <span class="string">&quot;Matcher already registered&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;Register&quot;</span>, feedType, <span class="string">&quot;matcher&quot;</span>)</span><br><span class="line">	GlobleMatcher.matchers[feedType] = matcher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，matchers就注册了<code>defaultMatcher</code></p>
<p>示例二：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了search接口搜索器</span></span><br><span class="line"><span class="keyword">type</span> Searcher <span class="keyword">interface</span> &#123;</span><br><span class="line">	Search(url <span class="keyword">string</span>) (content []<span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认搜索器</span></span><br><span class="line"><span class="keyword">type</span> defaultSearcher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d defaultSearcher)</span> <span class="title">Search</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(content []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义搜索器</span></span><br><span class="line"><span class="keyword">type</span> mySearcher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d mySearcher)</span> <span class="title">Search</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(content []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局搜索器</span></span><br><span class="line"><span class="keyword">type</span> SearchMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	searchMap <span class="keyword">map</span>[<span class="keyword">string</span>]Searcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSearchMap</span><span class="params">()</span> <span class="title">SearchMap</span></span> &#123;</span><br><span class="line">	s := SearchMap&#123;</span><br><span class="line">		searchMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Searcher),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globleSearchMap = NewSearchMap()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册搜索器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(Type <span class="keyword">string</span>, s Searcher)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> Type == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;error, Type is empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">if</span> _, exists := globleSearchMap.searchMap[Type]; exists &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Matcher already registered&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	globleSearchMap.searchMap[Type] = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ds := defaultSearcher&#123;&#125;</span><br><span class="line">  ms := mySearcher&#123;&#125;</span><br><span class="line">	Register(<span class="string">&quot;default&quot;</span>, ds)</span><br><span class="line">  Register(<span class="string">&quot;my&quot;</span>, ms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> globleSearchMap.searchMap &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例三：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Target <span class="keyword">struct</span> &#123;</span><br><span class="line">	urls <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Target</span></span> &#123;</span><br><span class="line">	t := &amp;Target&#123;</span><br><span class="line">		urls: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> strings.Trim(url, <span class="string">&quot; &quot;</span>) == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;url is empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	target.urls &lt;- url</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Register(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第三章-打包和工具链"><a href="#第三章-打包和工具链" class="headerlink" title="第三章 打包和工具链"></a>第三章 打包和工具链</h2><h3 id="go-get获取的包和git-clone获取的包区别"><a href="#go-get获取的包和git-clone获取的包区别" class="headerlink" title="go get获取的包和git clone获取的包区别"></a>go get获取的包和git clone获取的包区别</h3><ul>
<li>go get 将获取任意指定的 URL 的包，或者一个已经导入的包所依赖的其他包。由于 go get 的这种递归特性，这个命令会扫描某个包的源码树，获取能找到的所有依赖包。</li>
</ul>
<h3 id="每个包可以包含任意多个-init-函数"><a href="#每个包可以包含任意多个-init-函数" class="headerlink" title="每个包可以包含任意多个 init 函数"></a>每个包可以包含任意多个 init 函数</h3><h3 id="使用-Go-的工具"><a href="#使用-Go-的工具" class="headerlink" title="使用 Go 的工具"></a>使用 Go 的工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用 clean 后会删除编译生成的可执行文件。</span><br><span class="line">go clean hello.go</span><br><span class="line"></span><br><span class="line">会编译chapter3 目录下的所有包</span><br><span class="line">go build github.com/goinaction/code/chapter3/...</span><br></pre></td></tr></table></figure>



<h2 id="第四章-数组、切片和映射"><a href="#第四章-数组、切片和映射" class="headerlink" title="第四章 数组、切片和映射"></a>第四章 数组、切片和映射</h2><ul>
<li>当迭代切片时，关键字 range创建了每个元素的副本，而不是直接返回对该元素的引用</li>
</ul>
<h2 id="第五章-Go-语言的类型系统"><a href="#第五章-Go-语言的类型系统" class="headerlink" title="第五章 Go 语言的类型系统"></a>第五章 Go 语言的类型系统</h2><p>值的类型给编译器提供两部分信息：</p>
<ul>
<li>第一部分，需要分配多少内存给这个值（即值的规模）；</li>
<li>第二部分，这段内存表示什么。对于许多内置类型的情况来说，规模和表示是类型名的一部分。</li>
</ul>
<blockquote>
<p>int64 类型的值需要 8 字节（64 位），表示一个整数值；</p>
<p>float32 类型的值需要 4 字节（32 位），表示一个 IEEE-754 定义的二进制浮点数；</p>
<p>bool 类型的值需要 1 字节（8 位），表示布尔值 true 和 false。</p>
</blockquote>
<p>Go 语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称作<code>标头（header）值</code>。从技术细节上说，字符串也是一种引用类型。</p>
<p><strong>每个引用类型创建的标头值是包含一个指向底层数据结构的指针。</strong></p>
<blockquote>
<p>每个引用类型还包含一组独特的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本质上就是在共享底层数据结构。</p>
</blockquote>
<h2 id="第六章-并发"><a href="#第六章-并发" class="headerlink" title="第六章 并发"></a>第六章 并发</h2><ul>
<li>CSP 是一种消息传递模型，通过<strong>在 goroutine 之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。</strong>用于在 goroutine 之间同步和传递数据的关键数据类型叫作通道（channel）。</li>
</ul>
<p>下图为操作系统线程、逻辑处理器和本地运行队列之间的关系。</p>
<blockquote>
<p>一个逻辑处理器运行在一个CPU上</p>
</blockquote>
<ul>
<li>如果创建一个 goroutine 并准备运行，这个 goroutine 就会被放到调度器的全局运行队列中。</li>
<li>之后，调度器就将这些队列中的 goroutine 分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中。本地运行队列中的 goroutine 会一直等待直到自己被分配的逻辑处理器执行。</li>
<li>有时，正在运行的 goroutine 需要执行一个阻塞的系统调用，如打开一个文件。当这类调用发生时，<strong>线程和 goroutine 会从逻辑处理器上分离，该线程会继续阻塞，等待系统调用的返回</strong>。与此同时，这个逻辑处理器就失去了用来运行的线程。所以，调度器会创建一个新线程，并将其绑定到该逻辑处理器上。之后，调度器会从本地运行队列里选择另一个 goroutine 来运行。</li>
<li>一旦被阻塞的系统调用执行完成并返回，对应的 goroutine 会放回到本地运行队列，而之前的线程会保存好，以便之后可以继续使用。</li>
</ul>
<p><img src="/images/image-20210207174923879.png" alt="image-20210207174923879"></p>
<h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 分配一个逻辑处理器给调度器使用</span></span><br><span class="line">  runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// wg 用来等待程序完成</span></span><br><span class="line">  <span class="comment">// 计数加 2，表示要等待两个 goroutine</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Start Goroutines&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明一个匿名函数，并创建一个 goroutine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">	<span class="comment">// 在函数退出时调用 Done 来通知 main 函数工作已经完成</span></span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示字母表 3 次</span></span><br><span class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123; </span><br><span class="line">		<span class="keyword">for</span> char := <span class="string">&#x27;a&#x27;</span>; char &lt; <span class="string">&#x27;a&#x27;</span>+<span class="number">26</span>; char++ &#123; </span><br><span class="line">			fmt.Printf(<span class="string">&quot;%c &quot;</span>, char)</span><br><span class="line">    &#125;&#125; </span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明一个匿名函数，并创建一个 goroutine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">	<span class="comment">// 在函数退出时调用 Done 来通知 main 函数工作已经完成</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示字母表 3 次</span></span><br><span class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123; </span><br><span class="line">		<span class="keyword">for</span> char := <span class="string">&#x27;A&#x27;</span>; char &lt; <span class="string">&#x27;A&#x27;</span>+<span class="number">26</span>; char++ &#123; </span><br><span class="line">			fmt.Printf(<span class="string">&quot;%c &quot;</span>, char)</span><br><span class="line">    &#125; &#125; </span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待 goroutine 结束</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Waiting To Finish&quot;</span>)</span><br><span class="line">  wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;\nTerminating Program&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于调度器的内部算法，一个正运行的 goroutine 在工作结束前，可以被停止并重新调度。调度器这样做的目的是防止某个 goroutine 长时间占用逻辑处理器。当 goroutine 占用时间过长时，调度器会停止当前正运行的 goroutine，并给其他可运行的 goroutine 运行的机会。</p>
<p>图 6-4 从逻辑处理器的角度展示了这一场景。</p>
<ol>
<li>在第 1 步，调度器开始运行 goroutine A，而goroutine B 在运行队列里等待调度。</li>
<li>之后，在第 2 步，调度器交换了 goroutine A 和 goroutine B。由于 goroutine A 并没有完成工作，因此被放回到运行队列。</li>
<li>之后，在第 3 步，goroutine B 完成了它的工作并被系统销毁。这也让 goroutine A 继续之前的工作。</li>
</ol>
<p><img src="/images/image-20210207180451538.png" alt="image-20210207180451538"></p>
<h3 id="竞争状态"><a href="#竞争状态" class="headerlink" title="竞争状态"></a>竞争状态</h3><ul>
<li>如果两个或者多个 goroutine 在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作竞争状态（race candition）。</li>
<li>竞争状态的存在是让并发程序变得复杂的地方，十分容易引起潜在问题。对一个共享资源的读和写操作必须是原子化的，换句话说，同一时刻只能有一个 goroutine 对共享资源进行读和写操作。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// counter 是所有 goroutine 都要增加其值的变量</span></span><br><span class="line">	counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// wg 用来等待程序结束</span></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 计数加 2，表示要等待两个 goroutine</span></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待 goroutine 结束</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Final Counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incCounter 增加包里 counter 变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">		<span class="comment">// 捕获 counter 的值</span></span><br><span class="line">    <span class="comment">// 每个 goroutine 都会先读出这个 counter 变量的值，并在第 40 行将 counter 变量的副本存入一个叫作 value 的本地变量。</span></span><br><span class="line">		value := counter</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前 goroutine 从线程退出，并放回到队列。给其他 goroutine 运行的机会。</span></span><br><span class="line">		runtime.Gosched()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 增加本地 value 变量的值</span></span><br><span class="line">		value++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将该值保存回 counter</span></span><br><span class="line">		counter = value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终输出：Final Counter: 2</span></span><br></pre></td></tr></table></figure>

<p>变量counter会进行4次读和写操作，每个 goroutine 执行两次。但是，程序终止时，counter 变量的值为 2。</p>
<ul>
<li><strong>每个 goroutine 都会覆盖另一个 goroutine 的工作。</strong></li>
<li>这种覆盖发生在 goroutine 切换的时候。每个 goroutine 创造了一个 counter 变量的副本，之后就切换到另一个 goroutine。当这个 goroutine再次运行的时候，counter 变量的值已经改变了，但是 goroutine 并没有更新自己的那个副本的值，而是继续使用这个副本的值，用这个值递增，并存回 counter 变量，结果覆盖了另一个goroutine 完成的工作。</li>
</ul>
<p><img src="/images/image-20210207181815574.png" alt="image-20210207181815574"></p>
<p>Go 语言有一个特别的工具，可以在代码里检测竞争状态。在查找这类错误的时候，这个工具非常好用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -race // 用竞争检测器标志来编译程序</span><br></pre></td></tr></table></figure>



<h3 id="锁住共享资源"><a href="#锁住共享资源" class="headerlink" title="锁住共享资源"></a>锁住共享资源</h3><p>Go 语言提供了传统的同步 goroutine 的机制，就是对共享资源加锁。如果需要顺序访问一个整型变量或者一段代码，atomic 和 sync 包里的函数提供了很好的解决方案。下面我们了解一下 atomic 包里的几个函数以及 sync 包里的 mutex 类型。</p>
<h4 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a>原子函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	counter <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Final Counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">		<span class="comment">// 安全地对 counter 加 1</span></span><br><span class="line">    <span class="comment">// 具体方案是：强制同一时刻只能有一个 goroutine 运行并完成这个加法操作</span></span><br><span class="line">    <span class="comment">// 当 goroutine 试图去调用任何原子函数时，这些 goroutine 都会自动根据所引用的变量做同步处理。</span></span><br><span class="line">		atomic.AddInt64(&amp;counter, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		runtime.Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终输出：Final Counter: 4</span></span><br></pre></td></tr></table></figure>



<p>另外两个有用的原子函数是 LoadInt64 和 StoreInt64。这两个函数提供了一种安全地读和写一个整型值的方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// shutdown 是通知正在执行的 goroutine 停止工作的标志</span></span><br><span class="line">	shutdown <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> doWork(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> doWork(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给定 goroutine 执行的时间</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该停止工作了，安全地设置 shutdown 标志</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Shutdown Now&quot;</span>)</span><br><span class="line">	atomic.StoreInt64(&amp;shutdown, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// doWork 用来模拟执行工作的 goroutine，</span></span><br><span class="line"><span class="comment">// 检测之前的 shutdown 标志来决定是否提前终止</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在函数退出时调用 Done 来通知 main 函数工作已经完成</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Doing %s Work\n&quot;</span>, name)</span><br><span class="line">		time.Sleep(<span class="number">250</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 要停止工作了吗？</span></span><br><span class="line">		<span class="keyword">if</span> atomic.LoadInt64(&amp;shutdown) == <span class="number">1</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Shutting %s Down\n&quot;</span>, name)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>互斥锁用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界区代码。</p>
<figure class="highlight go"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// counter 是所有 goroutine 都要增加其值的变量</span></span><br><span class="line">	counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Final Counter: %d\n&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incCounter 使用互斥锁来同步并保证安全访问</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在函数退出时调用 Done 来通知 main 函数工作已经完成</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">		mutex.Lock()</span><br><span class="line">    <span class="comment">// 捕获 counter 的值</span></span><br><span class="line">    value := counter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 goroutine 从线程退出，并放回到队列</span></span><br><span class="line">    <span class="comment">// 强制将当前 goroutine 退出当前线程后，调度器会再次分配这个 goroutine 继续运行。</span></span><br><span class="line">    runtime.Gosched()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加本地 value 变量的值</span></span><br><span class="line">    value++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该值保存回 counter</span></span><br><span class="line">    counter = value</span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们得到正确的值 4</span></span><br></pre></td></tr></table></figure>



<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><ul>
<li>当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。</li>
<li>可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</li>
</ul>
<h4 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h4><p>无缓冲的通道（unbuffered channel）是指在<strong>接收前没有能力保存任何值的通道</strong>。</p>
<p><strong>这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。</strong>如果两个 goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。</p>
<p><img src="/images/image-20210224195942995.png" alt="image-20210224195942995"></p>
<ol>
<li>在第 1 步，两个 goroutine 都到达通道，但哪个都没有开始执行发送或者接收。</li>
<li>在第 2 步，左侧的 goroutine 将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个 <strong>goroutine 会在通道中被锁住，直到交换完成</strong>。</li>
<li>在第 3 步，右侧的 goroutine 将它的手放入通道，这模拟了从通道里接收数据。这个 goroutine 一样也会在通道中被锁住，直到交换完成。</li>
<li>在第 4 步和第 5 步，进行交换，</li>
<li>在第 6 步，两个 goroutine 都将它们的手从通道里拿出来，这模拟了被锁住的 goroutine 得到释放。两个 goroutine 现在都可以去做别的事情了。</li>
</ol>
<p>在网球比赛中，两位选手会把球在两个人之间来回传递。选手总是处在以下两种状态之一：要么在等待接球，要么将球打向对方。</p>
<p>可以使用两个 goroutine 来模拟网球比赛，并使用无缓冲的通道来模拟球的来回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个无缓冲的通道</span></span><br><span class="line">	court := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计数加 2，表示要等待两个 goroutine</span></span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动两个选手</span></span><br><span class="line">	<span class="keyword">go</span> player(<span class="string">&quot;Nadal&quot;</span>, court)</span><br><span class="line">	<span class="keyword">go</span> player(<span class="string">&quot;Djokovic&quot;</span>, court)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发球</span></span><br><span class="line">	court &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// player 模拟一个选手在打网球</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">player</span><span class="params">(name <span class="keyword">string</span>, court <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 等待球被击打过来</span></span><br><span class="line">    <span class="comment">// goroutine 从通道接收数据，用来表示等待接球。这个接收动作会锁住goroutine，直到有数据发送到通道里。</span></span><br><span class="line">		ball, ok := &lt;-court</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Player %s Won\n&quot;</span>, name)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 选随机数，然后用这个数来判断我们是否丢球</span></span><br><span class="line">		n := rand.Intn(<span class="number">100</span>)</span><br><span class="line">		<span class="keyword">if</span> n%<span class="number">13</span> == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Player %s Missed\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">			<span class="built_in">close</span>(court)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示击球数，并将击球数加 1</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Player %s Hit %d\n&quot;</span>, name, ball)</span><br><span class="line">		ball++</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将球打向对手</span></span><br><span class="line">		court &lt;- ball</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在 main 函数的第 18 行，创建了一个 int 类型的无缓冲的通道，让两个 goroutine 在击球时能够互相同步。</li>
<li>之后在第 24 行和第 25 行，创建了参与比赛的两个 goroutine。在这个时候，两个goroutine 都阻塞住等待击球。</li>
<li>在第 28 行，将球发到通道里，程序开始执行这个比赛，直到某个goroutine 输掉比赛。</li>
</ol>
<p>另一个例子，用不同的模式，使用无缓冲的通道，在 goroutine 之间同步数据，来模拟接力比赛。在接力比赛里，4 个跑步者围绕赛道轮流跑）。第二个、第三个和第四个跑步者要接到前一位跑步者的接力棒后才能起跑。比赛中最重要的部分是要传递接力棒，要求同步传递。在同步接力棒的时候，参与接力的两个跑步者必须在同一时刻准备好交接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	baton := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为最后一位跑步者将计数加 1</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一位跑步者持有接力棒</span></span><br><span class="line">	<span class="keyword">go</span> Runner(baton)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始比赛</span></span><br><span class="line">	baton &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待比赛结束.</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runner</span><span class="params">(baton <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newRunner <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待接力棒，一旦chan传出值了，就说明接力棒到新的运动员了</span></span><br><span class="line">	runner := &lt;-baton</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始绕着跑道跑步</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Runner %d Running With Baton\n&quot;</span>, runner)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建下一位跑步者</span></span><br><span class="line">	<span class="keyword">if</span> runner != <span class="number">4</span> &#123;</span><br><span class="line">		newRunner = runner + <span class="number">1</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Runner %d To The Line\n&quot;</span>, newRunner)</span><br><span class="line">		<span class="keyword">go</span> Runner(baton)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 围绕跑道跑</span></span><br><span class="line">	time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 比赛结束了吗？</span></span><br><span class="line">	<span class="keyword">if</span> runner == <span class="number">4</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Runner %d Finished, Race Over\n&quot;</span>, runner)</span><br><span class="line">		wg.Done()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将接力棒交给下一位跑步者</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Runner %d Exchange With Runner %d\n&quot;</span>,</span><br><span class="line">		runner,</span><br><span class="line">		newRunner)</span><br><span class="line"></span><br><span class="line">	baton &lt;- newRunner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接力比赛中，跑第一圈的运动员和跑第二圈的运动员是同类的。</p>
<p>因此，如果我们将Runner作为消耗接力棒chan的goroutine。那么肯定会在goroutine的第一开始获取chan的数据，再在最后将chan的数据进行更新后还给chan</p>
</blockquote>
<h4 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h4><ul>
<li>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并<strong>不强制要求 goroutine 之间必须同时完成发送和接收</strong>。</li>
<li>通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</li>
<li>这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。</li>
</ul>
<p><img src="/images/image-20210224203334053.png" alt="image-20210224203334053"></p>
<h2 id="第七章-并发模式"><a href="#第七章-并发模式" class="headerlink" title="第七章 并发模式"></a>第七章 并发模式</h2><p>学习 3 个可以在实际工程里使用的包，这3 个包分别实现了不同的并发模式。</p>
<h3 id="runner"><a href="#runner" class="headerlink" title="runner"></a>runner</h3><ul>
<li><strong>runner 包管理处理任务的运行和生命周期</strong></li>
<li>runner 包使用通道来监视程序的执行时间，如果程序运行时间太长，也可以用 runner 包来终止程序。当开发需要调度后台处理任务的程序的时候，这种模式会很有用。</li>
<li>这个程序可能会作为 cron 作业执行，或者在基于定时任务的云环境（如 iron.io）里执行。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> runner</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runner 在给定的超时时间内执行一组任务，并且在操作系统发送中断信号时结束这些任务</span></span><br><span class="line"><span class="comment">// 声明了 3 个通道，用来辅助管理程序的生命周期，以及用来表示【顺序执行】的不同任务的函数切片。</span></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// interrupt 通道报告从操作系统发送的信号</span></span><br><span class="line">	interrupt <span class="keyword">chan</span> os.Signal</span><br><span class="line"></span><br><span class="line">	<span class="comment">// complete 通道报告处理任务已经完成</span></span><br><span class="line">	complete <span class="keyword">chan</span> error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// timeout 报告处理任务已经超时</span></span><br><span class="line">	timeout &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tasks 持有一组以索引顺序依次执行的函数</span></span><br><span class="line">	tasks []<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrTimeout 会在任务执行超时时返回</span></span><br><span class="line"><span class="keyword">var</span> ErrTimeout = errors.New(<span class="string">&quot;received timeout&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrInterrupt 会在接收到操作系统的事件时返回</span></span><br><span class="line"><span class="keyword">var</span> ErrInterrupt = errors.New(<span class="string">&quot;received interrupt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 返回一个新的准备使用的 Runner</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(d time.Duration)</span> *<span class="title">Runner</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Runner&#123;</span><br><span class="line">		interrupt: <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>),</span><br><span class="line">		complete:  <span class="built_in">make</span>(<span class="keyword">chan</span> error),</span><br><span class="line">		timeout:   time.After(d),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 将一个任务附加到 Runner 上。这个任务是一个接收一个 int 类型的 ID 作为参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">Add</span><span class="params">(tasks ...<span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">	r.tasks = <span class="built_in">append</span>(r.tasks, tasks...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start 执行所有任务，并监视通道事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们希望接收所有中断信号</span></span><br><span class="line">  <span class="comment">// func Notify(c chan&lt;- os.Signal, sig ...os.Signal): 让signal包将输入信号转发到c。</span></span><br><span class="line">	signal.Notify(r.interrupt, os.Interrupt)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用不同的 goroutine 执行不同的任务</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		r.complete &lt;- r.run()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 当任务处理完成时发出的信号</span></span><br><span class="line">	<span class="keyword">case</span> err := &lt;- r.complete:</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当任务处理程序运行超时时发出的信号</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-r.timeout:</span><br><span class="line">		<span class="keyword">return</span> ErrTimeout</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run 执行每一个已注册的任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> id, task := <span class="keyword">range</span> r.tasks &#123;</span><br><span class="line">		<span class="comment">// 检测操作系统的中断信号</span></span><br><span class="line">		<span class="keyword">if</span> r.gotInterrupt() &#123;</span><br><span class="line">			<span class="keyword">return</span> ErrInterrupt</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行已注册的任务</span></span><br><span class="line">		task(id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gotInterrupt 验证是否接收到了中断信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">gotInterrupt</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 当中断事件被触发时发出的信号</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-r.interrupt:</span><br><span class="line">    <span class="comment">// 停止接收后续的任何信号(不允许继续往r.interrupt中存入内容)</span></span><br><span class="line">		signal.Stop(r.interrupt)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 继续正常运行</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout is the number of second the program has to finish.</span></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">3</span> * time.Second</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := runner.New(timeout)</span><br><span class="line">	r.Add(createTask(), createTask(), createTask())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run the tasks and handle the result.</span></span><br><span class="line">	<span class="keyword">if</span> err := r.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">		<span class="keyword">case</span> runner.ErrTimeout:</span><br><span class="line">			log.Println(<span class="string">&quot;Terminating due to timeout.&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">case</span> runner.ErrInterrupt:</span><br><span class="line">			log.Println(<span class="string">&quot;Terminating due to interrupt.&quot;</span>)</span><br><span class="line">			os.Exit(<span class="number">2</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;Process ended.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTask</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;Processor - Task #%d.&quot;</span>, id)</span><br><span class="line">		time.Sleep(time.Duration(id) * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码展示了依据调度运行的无人值守的<strong>面向任务的程序</strong>，及其所使用的并发模式。在设计上，可支持以下终止点：</p>
<ul>
<li>程序可以在分配的时间内完成工作，正常终止；</li>
<li>程序没有及时完成工作，“自杀”；</li>
<li>接收到操作系统发送的中断事件，程序立刻试图清理状态并停止工作。</li>
</ul>
<blockquote>
<p>Go中的系统Signal处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Notify</span><span class="params">(c <span class="keyword">chan</span>&lt;- os.Signal, sig …os.Signal)</span></span></span><br></pre></td></tr></table></figure>

<p>该函数会<strong>将进程收到的系统Signal</strong>转发给channel c。转发哪些信号由该函数的可变参数决定，如果你没有传入sig参数，那么Notify会将系统收到的所有信号转发给c。</p>
<p>如果你像下面这样调用Notify：</p>
<figure class="highlight go"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal.Notify(c, syscall.SIGINT, syscall.SIGUSR1, syscall.SIGUSR2)</span><br></pre></td></tr></table></figure>

<p>则Go只会关注你传入的Signal类型，其他Signal将会按照默认方式处理，大多都是进程退出。因此你需要在Notify中传入你要关注和处理的Signal类型，也就是拦截它们，提供自定义处理函数来改变它们的行为。</p>
<p>简单使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os/signal&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;syscall&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> signalHandler <span class="function"><span class="keyword">func</span><span class="params">(s os.Signal, arg <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> signalSet <span class="keyword">struct</span> &#123;</span><br><span class="line">	m <span class="keyword">map</span>[os.Signal]signalHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSignalSet</span><span class="params">()</span> *<span class="title">signalSet</span></span> &#123;</span><br><span class="line">	ss := <span class="built_in">new</span>(signalSet)</span><br><span class="line">	ss.m = <span class="built_in">make</span>(<span class="keyword">map</span>[os.Signal]signalHandler)</span><br><span class="line">	<span class="keyword">return</span> ss</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *signalSet)</span> <span class="title">register</span><span class="params">(s os.Signal, handler signalHandler)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, found := set.m[s]; !found &#123;</span><br><span class="line">		set.m[s] = handler</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *signalSet)</span> <span class="title">handle</span><span class="params">(sig os.Signal, arg <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, found := set.m[sig]; found &#123;</span><br><span class="line">		set.m[sig](sig, arg)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;No handler available for signal %v&quot;</span>, sig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> sysSignalHandleDemo()</span><br><span class="line">	time.Sleep(time.Hour) <span class="comment">// make the main goroutine wait!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysSignalHandleDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ss := NewSignalSet()</span><br><span class="line">	handler := <span class="function"><span class="keyword">func</span><span class="params">(s os.Signal, arg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;handle signal: %v\n&quot;</span>, s)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ss.register(syscall.SIGINT, handler)</span><br><span class="line">	ss.register(syscall.SIGUSR1, handler)</span><br><span class="line">	ss.register(syscall.SIGUSR2, handler)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> sigs []os.Signal</span><br><span class="line">		<span class="keyword">for</span> sig := <span class="keyword">range</span> ss.m &#123;</span><br><span class="line">			sigs = <span class="built_in">append</span>(sigs, sig)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		signal.Notify(c)</span><br><span class="line">		sig := &lt;-c</span><br><span class="line"></span><br><span class="line">		err := ss.handle(sig, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;unknown signal received: %v\n&quot;</span>, sig)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><ul>
<li>使用<strong>有缓冲的通道实现资源池</strong>，来管理可以在任意数量的goroutine之间共享及独立使用的资源。</li>
<li>这种模式在需要共享一组静态资源的情况（如共享数据库连接或者内存缓冲区）下非常有用。</li>
<li><strong>如果goroutine需要从池里得到这些资源中的一个，它可以从池里申请，使用完后归还到资源池里。</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pool 管理一组可以安全地在多个 goroutine 间共享的资源。</span></span><br><span class="line"><span class="comment">// resources 用来保存共享的资源</span></span><br><span class="line"><span class="comment">// 被管理的资源必须实现 io.Closer 接口。只要某类资源实现了 io.Closer 接口，就可以用这个资源池来管理。</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 这个互斥锁用来保证在多个 goroutine 访问资源池时，池内的值是安全的。</span></span><br><span class="line">	m         sync.Mutex</span><br><span class="line">	resources <span class="keyword">chan</span> io.Closer</span><br><span class="line">	<span class="comment">// 这个函数的目的是，当池需要一个新资源时，可以用这个函数创建。</span></span><br><span class="line">	factory   <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span></span><br><span class="line">	closed    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrPoolClosed 表示请求（Acquire）了一个已经关闭的池</span></span><br><span class="line"><span class="keyword">var</span> ErrPoolClosed = errors.New(<span class="string">&quot;Pool has been closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建一个用来管理资源的池。</span></span><br><span class="line"><span class="comment">// 这个池需要一个可以分配新资源的函数，并规定池的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="params">(io.Closer, error)</span>, <span class="title">size</span> <span class="title">uint</span>) <span class="params">(*Pool, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Size value too small.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Pool&#123;</span><br><span class="line">		factory:   fn,</span><br><span class="line">		resources: <span class="built_in">make</span>(<span class="keyword">chan</span> io.Closer, size),</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire 从池中获取一个资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Acquire</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 检查是否有空闲的资源</span></span><br><span class="line">	<span class="keyword">case</span> r, ok := &lt;-p.resources:</span><br><span class="line">		log.Println(<span class="string">&quot;Acquire:&quot;</span>, <span class="string">&quot;Shared Resource&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, ErrPoolClosed</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为没有空闲资源可用，所以提供一个新资源</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		log.Println(<span class="string">&quot;Acquire:&quot;</span>, <span class="string">&quot;New Resource&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> p.factory()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release 将一个使用后的资源放回池里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Release</span><span class="params">(r io.Closer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 保证本操作和 Close 操作的安全</span></span><br><span class="line">	p.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果池已经被关闭，销毁这个资源</span></span><br><span class="line">	<span class="keyword">if</span> p.closed &#123;</span><br><span class="line">		r.Close()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 试图将这个资源放入队列</span></span><br><span class="line">	<span class="keyword">case</span> p.resources &lt;- r:</span><br><span class="line">		log.Println(<span class="string">&quot;Release:&quot;</span>, <span class="string">&quot;In Queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果队列已满，则关闭这个资源</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		log.Println(<span class="string">&quot;Release:&quot;</span>, <span class="string">&quot;Closing&quot;</span>)</span><br><span class="line">		r.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 会让资源池停止工作，并关闭所有现有的资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 保证本操作与 Release 操作的安全</span></span><br><span class="line">	p.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 pool 已经被关闭，什么也不做</span></span><br><span class="line">	<span class="keyword">if</span> p.closed &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将池关闭</span></span><br><span class="line">	p.closed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在清空通道里的资源之前，将通道关闭</span></span><br><span class="line">	<span class="comment">// 如果不这样做，会发生死锁</span></span><br><span class="line">	<span class="built_in">close</span>(p.resources)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭资源</span></span><br><span class="line">	<span class="keyword">for</span> r := <span class="keyword">range</span> p.resources &#123;</span><br><span class="line">		r.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	maxGoroutines   = <span class="number">25</span> <span class="comment">// 要使用的 goroutine 的数量</span></span><br><span class="line">	pooledResources = <span class="number">2</span>  <span class="comment">// 池中的资源的数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dbConnection 模拟要共享的资源</span></span><br><span class="line"><span class="keyword">type</span> dbConnection <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 实现了 io.Closer 接口，以便 dbConnection可以被池管理。</span></span><br><span class="line"><span class="comment">// Close 用来完成任意资源的释放管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dbConn *dbConnection)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;Close: Connection&quot;</span>, dbConn.ID)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idCounter 用来给每个连接分配一个独一无二的 id</span></span><br><span class="line"><span class="keyword">var</span> idCounter <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createConnection 是一个工厂函数，当需要一个新连接时，资源池会调用这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createConnection</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span> &#123;</span><br><span class="line">	id := atomic.AddInt32(&amp;idCounter, <span class="number">1</span>)</span><br><span class="line">	log.Println(<span class="string">&quot;Create: New Connection&quot;</span>, id)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;dbConnection&#123;id&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(maxGoroutines)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建用来管理连接的池</span></span><br><span class="line">	p, err := New(createConnection, pooledResources)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用池里的连接来完成查询</span></span><br><span class="line">	<span class="keyword">for</span> query := <span class="number">0</span>; query &lt; maxGoroutines; query++ &#123;</span><br><span class="line">		<span class="comment">// 每个 goroutine 需要自己复制一份要查询值的副本，不然所有的查询会共享同一个查询变量</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			performQueries(q, p)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(query)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待 goroutine 结束</span></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭池</span></span><br><span class="line">	log.Println(<span class="string">&quot;Shutdown Program.&quot;</span>)</span><br><span class="line">	p.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performQueries 用来测试连接的资源池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performQueries</span><span class="params">(query <span class="keyword">int</span>, p *Pool)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从池里请求一个连接</span></span><br><span class="line">	conn, err := p.Acquire()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将该连接释放回池里</span></span><br><span class="line">	<span class="keyword">defer</span> p.Release(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用等待来模拟查询响应</span></span><br><span class="line">	time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">	log.Printf(<span class="string">&quot;Query: QID[%d] CID[%d]\n&quot;</span>, query, conn.(*dbConnection).ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般需要四个属性来实现一个pool</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	m         sync.Mutex</span><br><span class="line">	resources <span class="keyword">chan</span> io.Closer</span><br><span class="line">	factory   <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span></span><br><span class="line">	closed    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当释放一个资源和关闭整个pool的时候需要调用<code>sync.Mutex</code>来保证其他 goroutine 中没有同时执行 Release和Close 方法。</p>
</blockquote>
<h3 id="work"><a href="#work" class="headerlink" title="work"></a>work</h3><p><strong>使用无缓冲的通道来创建一个 goroutine 池，这些 goroutine 执行并控制一组工作，让其并发执行</strong>。</p>
<p>在这种情况下，使用无缓冲的通道要比随意指定一个缓冲区大小的有缓冲的通道好，因为这个情况下既不需要一个工作队列，也不需要一组 goroutine 配合执行。无缓冲的通道保证两个 goroutine 之间的数据交换。这种使用无缓冲的通道的方法允许使用者知道什么时候 goroutine 池正在执行工作，而且如果池里的所有 goroutine 都忙，无法接受新的工作的时候，也能及时通过通道来通知调用者。使用无缓冲的通道不会有工作在队列里丢失或者卡住，所有工作都会被处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// work 包管理一个 goroutine 池来完成工作</span></span><br><span class="line"><span class="keyword">package</span> work</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 必须满足接口类型，才能使用工作池</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Task()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pool 提供一个 goroutine 池，这个池可以完成任何已提交的 Worker 任务</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	work <span class="keyword">chan</span> Worker</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxGoroutines <span class="keyword">int</span>)</span> *<span class="title">Pool</span></span> &#123;</span><br><span class="line">	p := Pool&#123;</span><br><span class="line">		work: <span class="built_in">make</span>(<span class="keyword">chan</span> Worker),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.wg.Add(maxGoroutines)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxGoroutines; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// for range 循环会一直阻塞，直到从 work 通道收到一个 Worker 接口值。</span></span><br><span class="line">			<span class="keyword">for</span> w := <span class="keyword">range</span> p.work &#123;</span><br><span class="line">				w.Task()</span><br><span class="line">			&#125;</span><br><span class="line">			p.wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Run 将工作提交到工作池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Run</span><span class="params">(w Worker)</span></span> &#123;</span><br><span class="line">	p.work &lt;- w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shutdown 等待所有 goroutine 停止工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 关闭work这个chan</span></span><br><span class="line">	<span class="built_in">close</span>(p.work)</span><br><span class="line">	p.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/goinaction/code/chapter7/patterns/work&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// names 提供了一组用来显示的名字</span></span><br><span class="line"><span class="keyword">var</span> names = []<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;steve&quot;</span>,</span><br><span class="line">	<span class="string">&quot;bob&quot;</span>,</span><br><span class="line">	<span class="string">&quot;mary&quot;</span>,</span><br><span class="line">	<span class="string">&quot;therese&quot;</span>,</span><br><span class="line">	<span class="string">&quot;jason&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// namePrinter 使用特定方式打印名字.</span></span><br><span class="line"><span class="keyword">type</span> namePrinter <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 实现 Worker 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *namePrinter)</span> <span class="title">Task</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Println(m.name)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用两个 goroutine 来创建工作池.</span></span><br><span class="line">	p := work.New(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wg用于保证100个的names都能推入p.work</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">100</span> * <span class="built_in">len</span>(names))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">			np := &amp;namePrinter&#123;name: name&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="comment">// 将任务提交执行。当 Run 返回时我们就知道任务已经处理完成</span></span><br><span class="line">				p.Run(np)</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 让工作池停止工作，等待所有现有的工作完成</span></span><br><span class="line">	p.Shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>runner：用于监控一组任务的执行时间，超时就删除</li>
<li>pool：用于共享一组静态的资源</li>
<li>work：用于分发一组任务。</li>
</ul>
<h2 id="第八章-标准库"><a href="#第八章-标准库" class="headerlink" title="第八章 标准库"></a>第八章 标准库</h2><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.SetPrefix(<span class="string">&quot;TRACE: &quot;</span>)</span><br><span class="line">	log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Println writes to the standard logger.</span></span><br><span class="line">	log.Println(<span class="string">&quot;message&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fatalln is Println() followed by a call to os.Exit(1).</span></span><br><span class="line">	log.Fatalln(<span class="string">&quot;fatal message&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Panicln is Println() followed by a call to panic().</span></span><br><span class="line">	log.Panicln(<span class="string">&quot;panic message&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="定制的日志记录器"><a href="#定制的日志记录器" class="headerlink" title="定制的日志记录器"></a>定制的日志记录器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	Trace   *log.Logger <span class="comment">// Just about anything</span></span><br><span class="line">	Info    *log.Logger <span class="comment">// Important information</span></span><br><span class="line">	Warning *log.Logger <span class="comment">// Be concerned</span></span><br><span class="line">	Error   *log.Logger <span class="comment">// Critical problem</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(<span class="string">&quot;errors.txt&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Failed to open error log file:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Trace = log.New(ioutil.Discard,</span><br><span class="line">		<span class="string">&quot;TRACE: &quot;</span>,</span><br><span class="line">		log.Ldate|log.Ltime|log.Lshortfile)</span><br><span class="line"></span><br><span class="line">	Info = log.New(os.Stdout,</span><br><span class="line">		<span class="string">&quot;INFO: &quot;</span>,</span><br><span class="line">		log.Ldate|log.Ltime|log.Lshortfile)</span><br><span class="line"></span><br><span class="line">	Warning = log.New(os.Stdout,</span><br><span class="line">		<span class="string">&quot;WARNING: &quot;</span>,</span><br><span class="line">		log.Ldate|log.Ltime|log.Lshortfile)</span><br><span class="line"></span><br><span class="line">	Error = log.New(io.MultiWriter(file, os.Stderr),</span><br><span class="line">		<span class="string">&quot;ERROR: &quot;</span>,</span><br><span class="line">		log.Ldate|log.Ltime|log.Lshortfile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Trace.Println(<span class="string">&quot;I have something standard to say&quot;</span>)</span><br><span class="line">	Info.Println(<span class="string">&quot;Special Information&quot;</span>)</span><br><span class="line">	Warning.Println(<span class="string">&quot;There is something you need to know about&quot;</span>)</span><br><span class="line">	Error.Println(<span class="string">&quot;Something has failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	<span class="comment">// gResult maps to the result document received from the search.</span></span><br><span class="line">	gResult <span class="keyword">struct</span> &#123;</span><br><span class="line">		GsearchResultClass <span class="keyword">string</span> <span class="string">`json:&quot;GsearchResultClass&quot;`</span></span><br><span class="line">		UnescapedURL       <span class="keyword">string</span> <span class="string">`json:&quot;unescapedUrl&quot;`</span></span><br><span class="line">		URL                <span class="keyword">string</span> <span class="string">`json:&quot;url&quot;`</span></span><br><span class="line">		VisibleURL         <span class="keyword">string</span> <span class="string">`json:&quot;visibleUrl&quot;`</span></span><br><span class="line">		CacheURL           <span class="keyword">string</span> <span class="string">`json:&quot;cacheUrl&quot;`</span></span><br><span class="line">		Title              <span class="keyword">string</span> <span class="string">`json:&quot;title&quot;`</span></span><br><span class="line">		TitleNoFormatting  <span class="keyword">string</span> <span class="string">`json:&quot;titleNoFormatting&quot;`</span></span><br><span class="line">		Content            <span class="keyword">string</span> <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gResponse contains the top level document.</span></span><br><span class="line">	gResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">		ResponseData <span class="keyword">struct</span> &#123;</span><br><span class="line">			Results []gResult <span class="string">`json:&quot;results&quot;`</span></span><br><span class="line">		&#125; <span class="string">`json:&quot;responseData&quot;`</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	uri := <span class="string">&quot;http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;rsz=8&amp;q=golang&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Issue the search against Google.</span></span><br><span class="line">	resp, err := http.Get(uri)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;ERROR:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Decode the JSON response into our struct type.</span></span><br><span class="line">	<span class="keyword">var</span> gr gResponse</span><br><span class="line">	err = json.NewDecoder(resp.Body).Decode(&amp;gr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;ERROR:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(gr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Marshal the struct type into a pretty print</span></span><br><span class="line">	<span class="comment">// version of the JSON document.</span></span><br><span class="line">	pretty, err := json.MarshalIndent(gr, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;ERROR:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(pretty))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有时，无法为 JSON 的格式声明一个结构类型，而是需要更加灵活的方式来处理 JSON 文档。在这种情况下，可以将 JSON 文档解码到一个 map 变量中 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON contains a sample string to unmarshal.</span></span><br><span class="line"><span class="keyword">var</span> JSON = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">	&quot;name&quot;: &quot;Gopher&quot;,</span></span><br><span class="line"><span class="string">	&quot;title&quot;: &quot;programmer&quot;,</span></span><br><span class="line"><span class="string">	&quot;contact&quot;: &#123;</span></span><br><span class="line"><span class="string">		&quot;home&quot;: &quot;415.333.3333&quot;,</span></span><br><span class="line"><span class="string">		&quot;cell&quot;: &quot;415.555.5555&quot;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Unmarshal the JSON string into our map variable.</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err := json.Unmarshal([]<span class="keyword">byte</span>(JSON), &amp;c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;ERROR:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Name:&quot;</span>, c[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;Title:&quot;</span>, c[<span class="string">&quot;title&quot;</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;Contact&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;H:&quot;</span>, c[<span class="string">&quot;contact&quot;</span>].(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;home&quot;</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;C:&quot;</span>, c[<span class="string">&quot;contact&quot;</span>].(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;cell&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="io"><a href="#io" class="headerlink" title="io"></a>io</h3><ul>
<li>类 UNIX 的操作系统如此伟大的一个原因是，一个程序的输出可以是另一个程序的输入这一理念。</li>
<li>依照这个哲学，这类操作系统创建了一系列的简单程序，每个程序只做一件事，并把这件事做得非常好。之后，将这些程序组合在一起，可以创建一些脚本做一些很惊艳的事情。</li>
<li>这些程序使用 stdin 和 stdout 设备作为通道，在进程之间传递数据。</li>
<li>同样的理念扩展到了标准库的 io 包，而且提供的功能很神奇。这个包可以以流的方式高效处理数据，而不用考虑数据是什么，数据来自哪里，以及数据要发送到哪里的问题。与 stdout和 stdin 对应，这个包含有 io.Writer 和 io.Reader 两个接口。<strong>所有实现了这两个接口的类型的值，都可以使用 io 包提供的所有功能</strong>，也可以用于其他包里接受这两个接口的函数以及方法。</li>
</ul>
<h4 id="Writer-和-Reader-接口"><a href="#Writer-和-Reader-接口" class="headerlink" title="Writer 和 Reader 接口"></a>Writer 和 Reader 接口</h4><p>io 包是围绕着实现了 io.Writer 和 io.Reader 接口类型的值而构建的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write 从 p 里向底层的数据流写入 len(p)字节的数据。</span></span><br><span class="line"><span class="comment">// 这个方法返回从 p 里写出的字节数（0 &lt;= n &lt;= len(p)），以及任何可能导致写入提前结束的错误。</span></span><br><span class="line"><span class="comment">// Write 在返回 n &lt; len(p)的时候，必须返回某个非 nil 值的 error。</span></span><br><span class="line"><span class="comment">// Write 绝不能改写切片里的数据，哪怕是临时修改也不行。</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123; </span><br><span class="line">	Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Writer展示了 io.Writer 接口的声明。这个接口声明了唯一一个方法 Write，这个方法接受一个 byte 切片，并返回两个值。第一个值是写入的字节数，第二个值是 error 错误值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) Read 最多读入 len(p)字节，保存到 p。</span></span><br><span class="line"><span class="comment">// 这个方法返回读入的字节数（0 &lt;= n &lt;= len(p)）和任何读取时发生的错误。</span></span><br><span class="line"><span class="comment">// 即便 Read 返回的 n &lt; len(p)，方法也可能使用所有 p 的空间存储临时数据。</span></span><br><span class="line"><span class="comment">// 如果数据可以读取，但是字节长度不足 len(p)，习惯上 Read 会立刻返回可用的数据，而不等待更多的数据。</span></span><br><span class="line"><span class="comment">// (2) 当成功读取 n &gt; 0 字节后，如果遇到错误或者文件读取完成，Read 方法会返回读入的字节数。</span></span><br><span class="line"><span class="comment">// 方法可能会在本次调用返回一个非 nil 的错误，或者在下一次调用时返回错误（同时 n == 0）。</span></span><br><span class="line"><span class="comment">// 这种情况的的一个例子是，在输入的流结束时，Read 会返回非零的读取字节数，可能会返回 err == EOF，也可能会返回 err == nil。</span></span><br><span class="line"><span class="comment">// 无论如何，下一次调用 Read 应该返回 0, EOF。</span></span><br><span class="line"><span class="comment">// (3) 调用者在返回的 n &gt; 0 时，总应该先处理读入的数据，再处理错误 err。这样才能正确操作读取一部分字节后发生的 I/O 错误。EOF 也要这样处理。</span></span><br><span class="line"><span class="comment">// (4) Read 的实现不鼓励返回 0 个读取字节的同时，返回 nil 值的错误。调用者需要将这种返回状态视为没有做任何操作，而不是遇到读取结束。</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123; </span><br><span class="line">	Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>io.Reader 接口声明了一个方法 Read，这个方法接受一个 byte 切片，并返回两个值。第一个值是读入的字节数，第二个值是 error 错误值。</p>
<p>标准库里列出了实现 Read 方法的 4 条规则。</p>
<ul>
<li>第一条规则表明，该实现需要试图读取数据来填满被传入的 byte 切片。允许出现读取的字节数小于 byte 切片的长度，并且如果在读取时已经读到数据但是数据不足以填满 byte 切片时，不应该等待新数据，而是要直接返回已读数据。</li>
<li>第二条规则提供了应该如何处理达到文件末尾（EOF）的情况的指导。当读到最后一个字节时，可以有两种选择。一种是 Read 返回最终读到的字节数，并且返回 EOF 作为错误值，另一种是返回最终读到的字节数，并返回 nil 作为错误值。在后一种情况下，下一次读取的时候，由于没有更多的数据可供读取，需要返回 0 作为读到的字节数，以及 EOF 作为错误值。</li>
<li>第三条规则是给调用 Read 的人的建议。任何时候 Read 返回了读取的字节数，都应该优先处理这些读取到的字节，再去检查 EOF 错误值或者其他错误值。</li>
<li>最终，第四条约束建议 Read 方法的实现永远不要返回 0 个读取字节的同时返回 nil 作为错误值。如果没有读到值，Read 应该总是返回一个错误。</li>
</ul>
<h4 id="整合并完成工作"><a href="#整合并完成工作" class="headerlink" title="整合并完成工作"></a>整合并完成工作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个 Buffer 值，并将一个字符串写入。Buffer使用实现 io.Writer 的 Write 方法</span></span><br><span class="line">	<span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">	b.Write([]<span class="keyword">byte</span>(<span class="string">&quot;Hello &quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 Fprintf 来将一个字符串拼接到 Buffer 里。</span></span><br><span class="line">	fmt.Fprintf(&amp;b, <span class="string">&quot;World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 Buffer 的内容输出到标准输出设备</span></span><br><span class="line">  <span class="comment">// 将 os.File 值的地址作为 io.Writer 类型值传入</span></span><br><span class="line">	b.WriteTo(os.Stdout) <span class="comment">// 输出：Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fprintf 根据格式化说明符来格式写入内容，并输出到 w</span></span><br><span class="line"><span class="comment">// 这个函数返回写入的字节数，以及任何遇到的错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="简单的curl"><a href="#简单的curl" class="headerlink" title="简单的curl"></a>简单的curl</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r, err := http.Get(os.Args[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建文件来保存响应内容</span></span><br><span class="line">	file, err := os.Create(os.Args[<span class="number">2</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 MultiWriter，这样就可以同时向文件和标准输出设备进行写操作</span></span><br><span class="line">  <span class="comment">// 由于有 MultiWriter 函数提供的值的支持，我们可使用一次 Copy 调用，将内容同时写到两个目的地。</span></span><br><span class="line">	dest := io.MultiWriter(os.Stdout, file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读出响应的内容，并写到两个目的地</span></span><br><span class="line">	io.Copy(dest, r.Body)</span><br><span class="line">	<span class="keyword">if</span> err := r.Body.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第-九-章-测试和性能"><a href="#第-九-章-测试和性能" class="headerlink" title="第 九 章 测试和性能"></a>第 九 章 测试和性能</h2><h3 id="基础单元测试"><a href="#基础单元测试" class="headerlink" title="基础单元测试"></a>基础单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listing01</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个常量包含写测试输出时会用到的对号（√）和叉号（×）。</span></span><br><span class="line"><span class="keyword">const</span> checkMark = <span class="string">&quot;\u2713&quot;</span></span><br><span class="line"><span class="keyword">const</span> ballotX = <span class="string">&quot;\u2717&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestDownload validates the http Get function can download content.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDownload</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	url := <span class="string">&quot;http://www.goinggo.net/feeds/posts/default?alt=rss&quot;</span></span><br><span class="line">	statusCode := <span class="number">200</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用方法 t.Log 和 t.Logf来输出测试的消息。</span></span><br><span class="line">	t.Log(<span class="string">&quot;Given the need to test downloading content.&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		t.Logf(<span class="string">&quot;\tWhen checking \&quot;%s\&quot; for status code \&quot;%d\&quot;&quot;</span>,</span><br><span class="line">			url, statusCode)</span><br><span class="line">		&#123;</span><br><span class="line">			resp, err := http.Get(url)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				t.Fatal(<span class="string">&quot;\t\tShould be able to make the Get call.&quot;</span>,</span><br><span class="line">					ballotX, err)</span><br><span class="line">			&#125;</span><br><span class="line">			t.Log(<span class="string">&quot;\t\tShould be able to make the Get call.&quot;</span>,</span><br><span class="line">				checkMark)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> resp.StatusCode == statusCode &#123;</span><br><span class="line">				t.Logf(<span class="string">&quot;\t\tShould receive a \&quot;%d\&quot; status. %v&quot;</span>,</span><br><span class="line">					statusCode, checkMark)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				t.Errorf(<span class="string">&quot;\t\tShould receive a \&quot;%d\&quot; status. %v %v&quot;</span>,</span><br><span class="line">					statusCode, ballotX, resp.StatusCode)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 go test -v 来运行这个测试</p>
<p><img src="/images/image-20210326171853766.png" alt="image-20210326171853766"></p>
<ul>
<li>Go 语言的测试工具只会认为以_test.go 结尾的文件是测试文件。</li>
<li>一个测试函数必须是公开的函数，并且以 Test 单词开头。不但函数名字要以 Test 开头，而且函数的签名必须接收一个指向 testing.T 类型的指针，并且不返回任何值。</li>
<li>如果执行 go test 的时候没有加入冗余选项（-v），除非测试失败，否则我们是看不到任何测试输出的。</li>
</ul>
<h3 id="模仿调用"><a href="#模仿调用" class="headerlink" title="模仿调用"></a>模仿调用</h3><ul>
<li>标准库包含一个名为 httptest 的包，它让开发人员可以模仿基于HTTP 的网络调用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listing12</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http/httptest&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkMark = <span class="string">&quot;\u2713&quot;</span></span><br><span class="line"><span class="keyword">const</span> ballotX = <span class="string">&quot;\u2717&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// feed 模仿了我们期望接收的 XML 文档</span></span><br><span class="line"><span class="keyword">var</span> feed = <span class="string">`&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;rss&gt;</span></span><br><span class="line"><span class="string">&lt;channel&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Going Go Programming&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;description&gt;Golang : https://github.com/goinggo&lt;/description&gt;</span></span><br><span class="line"><span class="string">    &lt;link&gt;http://www.goinggo.net/&lt;/link&gt;</span></span><br><span class="line"><span class="string">    &lt;item&gt;</span></span><br><span class="line"><span class="string">        &lt;pubDate&gt;Sun, 15 Mar 2015 15:04:00 +0000&lt;/pubDate&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;Object Oriented Programming Mechanics&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;description&gt;Go is an object oriented language.&lt;/description&gt;</span></span><br><span class="line"><span class="string">        &lt;link&gt;http://www.goinggo.net/2015/03/object-oriented&lt;/link&gt;</span></span><br><span class="line"><span class="string">    &lt;/item&gt;</span></span><br><span class="line"><span class="string">&lt;/channel&gt;</span></span><br><span class="line"><span class="string">&lt;/rss&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mockServer 返回用来处理请求的服务器的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mockServer</span><span class="params">()</span> *<span class="title">httptest</span>.<span class="title">Server</span></span> &#123;</span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		w.WriteHeader(<span class="number">200</span>)</span><br><span class="line">		w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/xml&quot;</span>)</span><br><span class="line">		fmt.Fprintln(w, feed)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> httptest.NewServer(http.HandlerFunc(f))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>