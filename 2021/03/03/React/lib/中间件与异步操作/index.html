<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;a href=&quot;https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html&quot;&gt;Redux 入门教程（二）：中间件与异步操作&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>中间件与异步操作 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/React/" rel="tag">React</a></div><div class="post-time">2021-03-03</div></div></div><div class="container post-header"><h1>中间件与异步操作</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、中间件的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二、中间件的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81applyMiddlewares"><span class="toc-number">3.</span> <span class="toc-text">三、applyMiddlewares()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">4.</span> <span class="toc-text">四、异步操作的基本思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81redux-thunk-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">五、redux-thunk 中间件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81redux-promise-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">六、redux-promise 中间件</span></a></li></ol></details></div><div class="container post-content"><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">Redux 入门教程（二）：中间件与异步操作</a></p>
<p>异步操作怎么办？</p>
<ul>
<li>Action 发出以后，Reducer 立即算出 State，这叫做同步；</li>
<li>Action 发出以后，过一段时间再执行 Reducer，这就是异步。(比如Action发出后，先去发出Ajax请求后台，拿到数据后再执行Reducer)</li>
<li>怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：<strong>中间件（middleware）</strong>。</li>
</ul>
<p><img src="/images/bg2016092002.jpg" alt="bg2016092002"></p>
<h2 id="一、中间件的概念"><a href="#一、中间件的概念" class="headerlink" title="一、中间件的概念"></a>一、中间件的概念</h2><p>为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？</p>
<ul>
<li>Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</li>
<li>View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</li>
<li>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</li>
</ul>
<p>想来想去，只有发送 Action 的这个步骤，即<code>store.dispatch()</code>方法，可以添加功能。举例来说，要添加日志功能，把 Action 和 State 打印出来，可以对<code>store.dispatch</code>进行如下改造。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;dispatching&#x27;</span>, action);</span><br><span class="line">  next(action);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;next state&#x27;</span>, store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，对<code>store.dispatch</code>进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。</p>
<p>中间件就是一个函数，对<code>store.dispatch</code>方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</p>
<h2 id="二、中间件的用法"><a href="#二、中间件的用法" class="headerlink" title="二、中间件的用法"></a>二、中间件的用法</h2><p>怎么使用中间件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> logger = createLogger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>redux-logger</code>提供一个生成器<code>createLogger</code>，可以生成日志中间件<code>logger</code>。然后，将它放在<code>applyMiddleware</code>方法之中，传入<code>createStore</code>方法，就完成了<code>store.dispatch()</code>的功能增强。</p>
<p>这里有两点需要注意：</p>
<ol>
<li><p><code>createStore</code>方法可以接受整个应用的初始状态作为参数，那样的话，<code>applyMiddleware</code>就是第三个参数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  initial_state,</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>中间件的次序有讲究。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk, promise, logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>面代码中，<code>applyMiddleware</code>方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，<code>logger</code>就一定要放在最后，否则输出结果会不正确。</p>
</li>
</ol>
<h2 id="三、applyMiddlewares"><a href="#三、applyMiddlewares" class="headerlink" title="三、applyMiddlewares()"></a>三、applyMiddlewares()</h2><p>看到这里，你可能会问，<code>applyMiddlewares</code>这个方法到底是干什么的？</p>
<p>它是 Redux 的原生方法，<strong>作用是将所有中间件组成一个数组，依次执行</strong>。下面是它的源码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> <span class="function">(<span class="params">reducer, preloadedState, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);</span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch;</span><br><span class="line">    <span class="keyword">var</span> chain = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      <span class="attr">getState</span>: store.getState,</span><br><span class="line">      <span class="attr">dispatch</span>: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;;</span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;...store, dispatch&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，所有中间件被放进了一个数组<code>chain</code>，然后<strong>嵌套执行</strong>，最后执行<code>store.dispatch</code>。可以看到，中间件内部（<code>middlewareAPI</code>）可以拿到<code>getState</code>和<code>dispatch</code>这两个方法。</p>
<h2 id="四、异步操作的基本思路"><a href="#四、异步操作的基本思路" class="headerlink" title="四、异步操作的基本思路"></a>四、异步操作的基本思路</h2><p>理解了中间件以后，就可以处理异步操作了。同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</p>
<ul>
<li>操作发起时的 Action</li>
<li>操作成功时的 Action</li>
<li>操作失败时的 Action</li>
</ul>
<p>以向服务器取出数据为例，三种 Action 可以有两种不同的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：名称相同，参数不同</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;FETCH_POSTS&#x27;</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;FETCH_POSTS&#x27;</span>, <span class="attr">status</span>: <span class="string">&#x27;error&#x27;</span>, <span class="attr">error</span>: <span class="string">&#x27;Oops&#x27;</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;FETCH_POSTS&#x27;</span>, <span class="attr">status</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">response</span>: &#123; ... &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：名称不同</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;FETCH_POSTS_REQUEST&#x27;</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;FETCH_POSTS_FAILURE&#x27;</span>, <span class="attr">error</span>: <span class="string">&#x27;Oops&#x27;</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;FETCH_POSTS_SUCCESS&#x27;</span>, <span class="attr">response</span>: &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure>



<p>除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = &#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="attr">isFetching</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">didInvalidate</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">lastUpdated</span>: <span class="string">&#x27;xxxxxxx&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，State 的属性<code>isFetching</code>表示是否在抓取数据。<code>didInvalidate</code>表示数据是否过时，<code>lastUpdated</code>表示上一次更新时间。</p>
<p>现在，整个异步操作的思路就很清楚了。</p>
<ul>
<li>操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染</li>
<li>操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染</li>
</ul>
<h2 id="五、redux-thunk-中间件"><a href="#五、redux-thunk-中间件" class="headerlink" title="五、redux-thunk 中间件"></a>五、redux-thunk 中间件</h2><p>异步操作至少要送出两个 Action：</p>
<ul>
<li>用户触发第一个 Action，这个跟同步操作一样，没有问题；</li>
<li>如何才能在操作结束时，系统自动送出第二个 Action 呢？奥妙就在 Action Creator 之中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, selectedPost &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    dispatch(fetchPosts(selectedPost))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>上面代码是一个异步组件的例子。加载成功后（<code>componentDidMount</code>方法），它送出了（<code>dispatch</code>方法）一个 Action，向服务器要求数据 <code>fetchPosts(selectedSubreddit)</code>。这里的<code>fetchPosts</code>就是 Action Creator。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPosts = <span class="function"><span class="params">postTitle</span> =&gt;</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">  dispatch(requestPosts(postTitle));</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`/some/API/<span class="subst">$&#123;postTitle&#125;</span>.json`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">json</span> =&gt;</span> dispatch(receivePosts(postTitle, json)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法一</span></span><br><span class="line">store.dispatch(fetchPosts(<span class="string">&#x27;reactjs&#x27;</span>));</span><br><span class="line"><span class="comment">// 使用方法二</span></span><br><span class="line">store.dispatch(fetchPosts(<span class="string">&#x27;reactjs&#x27;</span>)).then(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>fetchPosts</code>是一个Action Creator（动作生成器），返回一个函数。这个函数执行后，先发出一个Action（<code>requestPosts(postTitle)</code>），然后进行异步操作。拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ <code>receivePosts(postTitle, json)</code>）。</p>
<p>上面代码中，有几个地方需要注意。</p>
<ul>
<li><code>fetchPosts</code>返回了一个函数，而普通的 Action Creator 默认返回一个对象。</li>
<li>返回的函数的参数是<code>dispatch</code>和<code>getState</code>这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。</li>
<li>在返回的函数之中，先发出一个 Action（<code>requestPosts(postTitle)</code>），表示操作开始。</li>
<li>异步操作结束之后，再发出一个 Action（<code>receivePosts(postTitle, json)</code>），表示操作结束。</li>
</ul>
<p>这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由<code>store.dispatch</code>方法发送的。而<code>store.dispatch</code>方法正常情况下，参数只能是对象，不能是函数。</p>
<p>这时，就要使用中间件<a target="_blank" rel="noopener" href="https://github.com/gaearon/redux-thunk"><code>redux-thunk</code></a>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: this API requires redux@&gt;=3.1.0</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>redux-thunk</code>中间件，改造<code>store.dispatch</code>，使得后者可以接受函数作为参数。</p>
<p>因此，异步操作的第一种解决方案就是，<strong>写出一个返回函数的 Action Creator，然后使用<code>redux-thunk</code>中间件改造<code>store.dispatch</code>。</strong></p>
<h2 id="六、redux-promise-中间件"><a href="#六、redux-promise-中间件" class="headerlink" title="六、redux-promise 中间件"></a>六、redux-promise 中间件</h2><p>既然 Action Creator 可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象。</p>
<p>这就需要使用<code>redux-promise</code>中间件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> promiseMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-promise&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(promiseMiddleware)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>这个中间件使得<code>store.dispatch</code>方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。写法一，返回值是一个 Promise 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPosts = </span><br><span class="line">  <span class="function">(<span class="params">dispatch, postTitle</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">     dispatch(requestPosts(postTitle));</span><br><span class="line">     <span class="keyword">return</span> fetch(<span class="string">`/some/API/<span class="subst">$&#123;postTitle&#125;</span>.json`</span>)</span><br><span class="line">       .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="attr">type</span>: <span class="string">&#x27;FETCH_POSTS&#x27;</span>,</span><br><span class="line">         <span class="attr">payload</span>: response.json()</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>写法二，Action 对象的<code>payload</code>属性是一个 Promise 对象。这需要从<a target="_blank" rel="noopener" href="https://github.com/acdlite/redux-actions"><code>redux-actions</code></a>模块引入<code>createAction</code>方法，并且写法也要变成下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createAction &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, selectedPost &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="comment">// 发出同步 Action</span></span><br><span class="line">    dispatch(requestPosts(selectedPost));</span><br><span class="line">    <span class="comment">// 发出异步 Action</span></span><br><span class="line">    dispatch(createAction(</span><br><span class="line">      <span class="string">&#x27;FETCH_POSTS&#x27;</span>, </span><br><span class="line">      fetch(<span class="string">`/some/API/<span class="subst">$&#123;postTitle&#125;</span>.json`</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，第二个<code>dispatch</code>方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出。注意，<code>createAction</code>的第二个参数必须是一个 Promise 对象。</p>
<p>看一下<code>redux-promise</code>的<a target="_blank" rel="noopener" href="https://github.com/acdlite/redux-promise/blob/master/src/index.js">源码</a>，就会明白它内部是怎么操作的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseMiddleware</span>(<span class="params">&#123; dispatch &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFSA(action)) &#123;</span><br><span class="line">      <span class="keyword">return</span> isPromise(action)</span><br><span class="line">        ? action.then(dispatch)</span><br><span class="line">        : next(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isPromise(action.payload)</span><br><span class="line">      ? action.payload.then(</span><br><span class="line">          <span class="function"><span class="params">result</span> =&gt;</span> dispatch(&#123; ...action, <span class="attr">payload</span>: result &#125;),</span><br><span class="line">          <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            dispatch(&#123; ...action, <span class="attr">payload</span>: error, <span class="attr">error</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      : next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，如果 Action 本身是一个 Promise，它 resolve 以后的值应该是一个 Action 对象，会被<code>dispatch</code>方法送出（<code>action.then(dispatch)</code>），但 reject 以后不会有任何动作；如果 Action 对象的<code>payload</code>属性是一个 Promise 对象，那么无论 resolve 和 reject，<code>dispatch</code>方法都会发出 Action。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>