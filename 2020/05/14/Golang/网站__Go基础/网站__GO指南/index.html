<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;GO指南&quot;&gt;&lt;a href=&quot;#GO指南&quot; class=&quot;headerlink&quot; title=&quot;GO指南&quot;&gt;&lt;/a&gt;GO指南&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://go-tour-zh.appspot.com/basics/1&quot;&gt;https://go-tour-zh.appspot.com/basics/1&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>GO指南 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2020-05-14</div></div></div><div class="container post-header"><h1>GO指南</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GO%E6%8C%87%E5%8D%97"><span class="toc-number">1.</span> <span class="toc-text">GO指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84-switch"><span class="toc-number">1.2.</span> <span class="toc-text">没有条件的 switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer"><span class="toc-number">1.3.</span> <span class="toc-text">defer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defer-%E6%A0%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">defer 栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.4.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">1.5.</span> <span class="toc-text">结构体字段与结构体指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%88%AB%E5%90%8D"><span class="toc-number">1.6.</span> <span class="toc-text">函数别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.7.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E8%80%85%E4%B8%BA%E6%8C%87%E9%92%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">接收者为指针的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GO%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">1.9.</span> <span class="toc-text">GO的值传递和引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Func-t-Type-VS-func-Func-t-Type"><span class="toc-number">1.9.1.</span> <span class="toc-text">func Func(t *Type) {} VS func Func(t Type) {}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-Func-t-Type-VS-func-Func-t-Type-1"><span class="toc-number">1.9.2.</span> <span class="toc-text">func Func()(t *Type) {} VS func Func()(t Type) {}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#func-t-Type-Method-VS-func-t-Type-Method"><span class="toc-number">1.9.3.</span> <span class="toc-text">func (t *Type) Method() {} VS func (t Type) Method() {}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%9C%A8%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.4.</span> <span class="toc-text">值接收者和指针接收者在方法调用的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">1.9.5.</span> <span class="toc-text">值接收者和指针接收者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.10.</span> <span class="toc-text">隐式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Py-Java-%E5%92%8C-Go%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AF%B9%E6%AF%94"><span class="toc-number">1.10.1.</span> <span class="toc-text">Py , Java 和 Go的接口对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.</span> <span class="toc-text">常用接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stringer%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.1.</span> <span class="toc-text">Stringer接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.2.</span> <span class="toc-text">error接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.3.</span> <span class="toc-text">Reader 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#goroutine"><span class="toc-number">1.12.</span> <span class="toc-text">goroutine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channel"><span class="toc-number">1.13.</span> <span class="toc-text">channel</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="GO指南"><a href="#GO指南" class="headerlink" title="GO指南"></a>GO指南</h1><p><a target="_blank" rel="noopener" href="https://go-tour-zh.appspot.com/basics/1">https://go-tour-zh.appspot.com/basics/1</a></p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul>
<li>bool</li>
<li>string</li>
<li>int  int8  int16  int32  int64</li>
<li>uint uint8 uint16 uint32 uint64 uintptr</li>
<li>byte  : uint8 的别名</li>
<li>rune :  int32 的别名 , 代表一个Unicode码</li>
<li>float32 float64</li>
<li>complex64 complex128</li>
</ul>
<h2 id="没有条件的-switch"><a href="#没有条件的-switch" class="headerlink" title="没有条件的 switch"></a>没有条件的 switch</h2><ul>
<li>没有条件的 switch 同 <code>switch true</code> 一样。</li>
<li>这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><ul>
<li>defer 语句会<strong>延迟函数的执行直到上层函数返回</strong>。</li>
<li><strong>延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">2</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>



<h3 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a>defer 栈</h3><ul>
<li>defer的函数是以<code>栈</code>的形式存储的</li>
<li>延迟的函数调用被压入一个栈中。当函数返回时， 会按照<strong>后进先出</strong>的顺序调用被延迟的函数调用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// counting</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// 9876543210</span></span><br></pre></td></tr></table></figure>



<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<ul>
<li>变量、指针和地址三者的关系是，<strong>每个变量都拥有地址，指针的值就是地址。</strong></li>
<li>当使用<code>&amp;</code>操作符对变量进行取地址操作并得到变量的指针后，可以对指针使用<code>*</code>操作符，也就是指针取值</li>
<li>取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，**<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。**</li>
</ul>
</blockquote>
<blockquote>
<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>
<ul>
<li>对变量进行取地址操作使用<code>&amp;</code>操作符，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值操作使用<code>*</code>操作符，可以获得指针变量指向的原变量的值。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p><code>*</code>操作符作为右值时，意义是取指针的值，</p>
</li>
<li><p>作为左值时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。</p>
</li>
</ul>
<p>其实归纳起来，<code>*</code>操作符的根本意义就是<strong>操作指针指向的变量</strong>。</p>
<ol>
<li>当操作在右值时，就是取指向变量的值，</li>
<li>当操作在左值时，就是将值设置给指向的变量。</li>
</ol>
</blockquote>
<ul>
<li><p>类型 <code>*T</code> 是指向类型 <code>T</code> 的值的指针。其零值是 <code>nil</code>。</p>
</li>
<li><p><code>&amp;</code> 符号会生成一个指向其作用对象的指针。</p>
</li>
</ul>
<h2 id="结构体字段与结构体指针"><a href="#结构体字段与结构体指针" class="headerlink" title="结构体字段与结构体指针"></a>结构体字段与结构体指针</h2><ul>
<li>结构体字段可以使用<code>点号</code>来访问。</li>
<li>结构体字段可以使用<code>结构体指针</code>来访问。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	v.X = <span class="number">2</span></span><br><span class="line">	v.Y = <span class="number">3</span></span><br><span class="line">	fmt.Println(v) <span class="comment">// &#123;2 3&#125;</span></span><br><span class="line">	fmt.Println(v.X,v.Y) <span class="comment">// 2 3</span></span><br><span class="line"></span><br><span class="line">	p := &amp;v</span><br><span class="line">	p.X = <span class="number">4</span></span><br><span class="line">	p.Y = <span class="number">5</span> </span><br><span class="line">	fmt.Println(v) <span class="comment">// &#123;4 5&#125;</span></span><br><span class="line">	fmt.Println(v.X,v.Y) <span class="comment">// 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数别名"><a href="#函数别名" class="headerlink" title="函数别名"></a>函数别名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(hypot(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos := adder()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(pos(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	slow,fast := <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		slow ,fast = fast,slow+fast</span><br><span class="line">		<span class="keyword">return</span> slow</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>Go 没有类。然而，仍然可以在结构体类型上定义方法。</li>
<li><em>方法接收者</em> 出现在 <code>func</code> 关键字和方法名之间的参数中。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>你可以对包中的 <em>任意</em> 类型定义任意方法，而不仅仅是针对结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := MyFloat(-math.Sqrt2)</span><br><span class="line">	fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不能对来自其他包的类型或基础类型定义方法。</p>
</blockquote>
<h3 id="接收者为指针的方法"><a href="#接收者为指针的方法" class="headerlink" title="接收者为指针的方法"></a>接收者为指针的方法</h3><p>有两个原因需要使用指针接收者。</p>
<ul>
<li>避免在每个方法调用中拷贝值（如果值类型是大的结构体的话会更有效率）。</li>
<li>方法可以修改接收者指向的值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	v.Scale(<span class="number">5</span>)</span><br><span class="line">	fmt.Println(v, v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="GO的值传递和引用传递"><a href="#GO的值传递和引用传递" class="headerlink" title="GO的值传递和引用传递"></a>GO的值传递和引用传递</h2><blockquote>
<ul>
<li>在python中 , 如果是可变对象 , 是引用传递  ; 如果是不可变对象 , 是值传递</li>
<li>默认情况下，Go 不管是什么对象 , 使用的都是值传递。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="left">传递类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/go/go-function-call-by-value.html">值传递</a></td>
<td align="left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/go/go-function-call-by-reference.html">引用传递</a></td>
<td align="left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td>
</tr>
</tbody></table>
<ul>
<li>在Go语言中,默认是按值传递.</li>
<li>当一个变量当作参数传递的时候,会<strong>创建变量的副本</strong>, 然后传递给函数或者方法,你可以看到这个副本的地址和变量的地址是不一样的. </li>
<li>当变量当做指针被传递的时候,<strong>新的指针被创建,它指向变量同样的内存地址</strong>, 所以你可以将这个指针看成原始变量指针的副本.</li>
</ul>
<h3 id="func-Func-t-Type-VS-func-Func-t-Type"><a href="#func-Func-t-Type-VS-func-Func-t-Type" class="headerlink" title="func Func(t *Type) {} VS func Func(t Type) {}"></a><code>func Func(t *Type) &#123;&#125;</code> VS <code>func Func(t Type) &#123;&#125;</code></h3><p>入参是指针,参数值可以在函数内部被修改.</p>
<h3 id="func-Func-t-Type-VS-func-Func-t-Type-1"><a href="#func-Func-t-Type-VS-func-Func-t-Type-1" class="headerlink" title="func Func()(t *Type) {} VS func Func()(t Type) {}"></a><code>func Func()(t *Type) &#123;&#125;</code> VS <code>func Func()(t Type) &#123;&#125;</code></h3><p>返回值类型不同之处在于取值的方式,指针类型需要使用 * 号读取数据. 其次返回值指针判断空值更加容易简洁,<code>t != nil</code>.</p>
<h3 id="func-t-Type-Method-VS-func-t-Type-Method"><a href="#func-t-Type-Method-VS-func-t-Type-Method" class="headerlink" title="func (t *Type) Method() {} VS func (t Type) Method() {}"></a><code>func (t *Type) Method() &#123;&#125;</code> VS <code>func (t Type) Method() &#123;&#125;</code></h3><ul>
<li>如果要在方法中更改receiver的状态,操纵receiver的值,请使用指针receiver. </li>
<li>使用值receiver是不可能的, 它按值复制.对值receiver的任何修改都是该值receiver副本的本地修改.</li>
</ul>
<blockquote>
<p>值receiver在原始类型值的副本上运行. 这意味着涉及成本,特别是如果结构非常大,并且接收的指针更有效. 如果您不需要编辑receiver值,请使用值receiver.</p>
</blockquote>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	v.Scale(<span class="number">5</span>)</span><br><span class="line">	fmt.Println(v, v.Abs()) <span class="comment">// &amp;&#123;15 20&#125; 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	v.X = v.X * f</span><br><span class="line">	v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	v.Scale(<span class="number">5</span>)</span><br><span class="line">	fmt.Println(v, v.Abs()) <span class="comment">// &#123;3 4&#125; 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="值接收者和指针接收者在方法调用的区别"><a href="#值接收者和指针接收者在方法调用的区别" class="headerlink" title="值接收者和指针接收者在方法调用的区别"></a>值接收者和指针接收者在方法调用的区别</h3><ul>
<li>在调用方法的时候，值类型既可以调用<code>值接收者</code>的方法，也可以调用<code>指针接收者</code>的方法；指针类型既可以调用<code>指针接收者</code>的方法，也可以调用<code>值接收者</code>的方法。</li>
<li>也就是说，不管<strong>方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">howOld</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">growUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// qcrao 是值类型</span></span><br><span class="line">	qcrao := Person&#123;age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值类型 调用 接收者是值类型 的方法</span></span><br><span class="line">	fmt.Println(qcrao.howOld()) <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值类型 调用 接收者是指针类型 的方法</span></span><br><span class="line">	qcrao.growUp()</span><br><span class="line">	fmt.Println(qcrao.howOld()) <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// stefno 是指针类型</span></span><br><span class="line">	stefno := &amp;Person&#123;age: <span class="number">100</span>&#125; <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针类型 调用 接收者是值类型 的方法</span></span><br><span class="line">	fmt.Println(stefno.howOld())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针类型 调用 接收者是指针类型 的方法</span></span><br><span class="line">	stefno.growUp()</span><br><span class="line">	fmt.Println(stefno.howOld()) <span class="comment">//101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了 <code>growUp</code> 函数后，不管调用者是值类型还是指针类型，它的 <code>Age</code> 值都改变了。</p>
<p>实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，这里面实际上通过语法糖起作用的。用一个表格来呈现：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>值接收者</th>
<th>指针接收者</th>
</tr>
</thead>
<tbody><tr>
<td>值类型调用者</td>
<td>方法会使用调用者的一个副本，类似于“传值”</td>
<td>使用值的引用来调用方法，上例中，<code>qcrao.growUp()</code> 实际上是 <code>(&amp;qcrao).growUp()</code></td>
</tr>
<tr>
<td>指针类型调用者</td>
<td>指针被解引用为值，上例中，<code>stefno.howOld()</code> 实际上是 <code>(*stefno).howOld()</code></td>
<td>实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td>
</tr>
</tbody></table>
<h3 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h3><p>不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。</p>
<blockquote>
<p><strong>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coder <span class="keyword">interface</span> &#123;</span><br><span class="line">	code()</span><br><span class="line">	debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;</span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Gopher)</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;I am coding %s language\n&quot;</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Gopher)</span> <span class="title">debug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;I am debuging %s language\n&quot;</span>, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c coder = &amp;Gopher&#123;<span class="string">&quot;Go&quot;</span>&#125;</span><br><span class="line">	c.code()</span><br><span class="line">	c.debug()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c coder = Gopher&#123;<span class="string">&quot;Go&quot;</span>&#125;</span><br><span class="line">	c.code()</span><br><span class="line">	c.debug() <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h2><p>在动态语言 python 中，定义一个这样的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>(<span class="params">coder</span>):</span></span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure>

<ul>
<li>当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，运行过程中会出现错误。</li>
<li>而在静态语言如 Java, C++ 中，必须要<strong>显式地声明实现了某个接口</strong>，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。</li>
</ul>
<blockquote>
<ul>
<li>动态语言和静态语言的差别在此就有所体现。<strong>静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。</strong></li>
<li>Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。</li>
<li>Go 采用了折中的做法：<strong>不要求类型显式地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</strong></li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IGreeting <span class="keyword">interface</span> &#123;</span><br><span class="line">	sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Go <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> PHP <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Go)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hi, I am GO!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHP)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hi, I am PHP!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i IGreeting)</span></span> &#123;</span><br><span class="line">	i.sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	golang := Go&#123;&#125;</span><br><span class="line">	php := PHP&#123;&#125;</span><br><span class="line">	f(golang) <span class="comment">// Hi, I am GO!</span></span><br><span class="line">	f(php) <span class="comment">// Hi, I am PHP!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 main 函数中，调用调用 f() 函数时，传入了 <code>golang, php</code> 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。</li>
<li>实际上，编译器在调用 f() 函数时，会隐式地将 <code>golang, php</code> 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</li>
</ul>
<blockquote>
<p>因为GO函数的参数必须传入类型 , 通过GO独有的接口 , 我们就可以通过定义定义f函数来进行<strong>隐式的类型转换</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i IGreeting)</span></span> &#123;</span><br><span class="line">	i.sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">golang := Go&#123;&#125;</span><br><span class="line">php := PHP&#123;&#125;</span><br><span class="line">f(golang) <span class="comment">// Hi, I am GO!</span></span><br><span class="line">f(php) <span class="comment">// Hi, I am PHP!</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Py-Java-和-Go的接口对比"><a href="#Py-Java-和-Go的接口对比" class="headerlink" title="Py , Java 和 Go的接口对比"></a>Py , Java 和 Go的接口对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">instance</span>):</span></span><br><span class="line">	<span class="keyword">return</span> instance.say_hello()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;hello student&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;hello tearcher&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">say_hello(s) <span class="comment"># hello student</span></span><br><span class="line"></span><br><span class="line">t = Teacher()</span><br><span class="line">say_hello(t) <span class="comment"># hello student</span></span><br><span class="line"></span><br><span class="line">e = Engineer()</span><br><span class="line">say_hello(e) <span class="comment"># 因为没有say_hello() , 执行到这里的时候报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码是典型的鸭子类型. 不管是谁 , 要想成功调用say_hello()函数 , 就要传入一个实现了<code>say_hello</code>方法的类实例</li>
<li><code>鸭子类型</code>是动态语言的典型 , 也就是说<strong>逐行执行代码 , 有错就抛出</strong> , 直到23行之前代码都没有错 , 所以say_hello(s)和say_hello(t)都能成功执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MammalInt</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noOfLegs</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      MammalInt m = <span class="keyword">new</span> MammalInt();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义了一个Animal接口 , 这个接口必须实现eat方法和travel方法</li>
<li>定义了一个哺乳动物(MammalInt)类 , <strong>这个类显式继承了Animal接口</strong>( implements Animal) , 并且在接下来具体实现了eat方法和travel方法</li>
<li><code>显式继承接口</code> 是静态语言的典型 . 程序在执行前会进行编译 , 编译过程中就会检查MammalInt类是否具体实现了eat方法和travel方法 , 如果没有则会报错</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span>&#123;</span><br><span class="line">	eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MammalInt <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MammalInt具体实现Animal接口的部分方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MammalInt)</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;MammalInt eating&quot;</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a Animal)</span></span> &#123;</span><br><span class="line">	a.eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := MammalInt&#123;&#125;</span><br><span class="line">	f(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 main 函数中，调用 f() 函数时，传入了 <code>MammalInt</code> 对象，它们并没有显式地声明实现了 Animal 类型(<strong>并没有 implements Animal</strong>)，只是实现了接口所规定的 eat() 函数。</li>
<li>实际上，编译器在调用 f() 函数时，会隐式地将 <code>MammalInt</code> 对象转换成 Animal 类型，这也是静态语言的类型检查功能。</li>
</ul>
<blockquote>
<p>综上所述 : </p>
<ul>
<li>动态语言 : <ul>
<li>好处 : <code>动态绑定</code> , 不需要实现接口 , 容易扩展(新定义的类只要实现say_hello()方法即可)</li>
<li>劣处 : 如果没有实现，运行过程中会出现错误 , 不安全。</li>
</ul>
</li>
<li>静态语言 :<ul>
<li>好处 : <code>显式继承接口</code> , 编译时进行检测 , 如果类没有具体实现接口方法 , 就会报错 , 因而安全</li>
<li>劣处 : 代码量多 , 复杂</li>
</ul>
</li>
<li>GO : 综合静态语言 和 动态语言的好处。<ul>
<li><code>隐式继承接口</code> , 只要实现了接口所规定的函数即可。可拓展</li>
<li>编译时进行检测有没有具体实现接口方法, 因而安全</li>
</ul>
</li>
</ul>
<ul>
<li>鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它<code>当前方法和属性的集合</code>决定。</li>
<li>Go 作为一种静态语言，通过接口实现了 <code>鸭子类型</code>，实际上是 Go 的编译器在其中作了隐匿的转换工作。</li>
</ul>
</blockquote>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="Stringer接口"><a href="#Stringer接口" class="headerlink" title="Stringer接口"></a>Stringer接口</h3><p>一个普遍存在的接口是 <a target="_blank" rel="noopener" href="https://golang.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a target="_blank" rel="noopener" href="https://golang.org/pkg/fmt/#Stringer"><code>Stringer</code></a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于python中的<code>__str__</code>或<code>__repr__</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">	z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">	fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a>error接口</h3><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	When time.Time</span><br><span class="line">	What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">		e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数抛出error , 就会调用Error()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">		time.Now(),</span><br><span class="line">		<span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Reader-接口"><a href="#Reader-接口" class="headerlink" title="Reader 接口"></a>Reader 接口</h3><ul>
<li><code>io</code> 包指定了 <code>io.Reader</code> 接口， 它表示从数据流结尾读取。</li>
<li>Go 标准库包含了这个接口的<a target="_blank" rel="noopener" href="http://golang.org/search?q=Read#Global">许多实现</a>， 包括文件、网络连接、压缩、加密等等。</li>
</ul>
<p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p><code>Read</code> 用数据填充指定的字节 slice，并且返回填充的字节数和错误信息。 在遇到数据流结尾时，返回 <code>io.EOF</code> 错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := r.Read(b)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		fmt.Println(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">	say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><ul>
<li>默认情况下，在另一端准备好之前，发送和接收都会<strong>阻塞</strong>。</li>
<li>这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步。</li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>