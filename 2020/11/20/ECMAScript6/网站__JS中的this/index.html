<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;JS中的this详解&quot;&gt;&lt;a href=&quot;#JS中的this详解&quot; class=&quot;headerlink&quot; title=&quot;JS中的this详解&quot;&gt;&lt;/a&gt;JS中的this详解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;this是使用call方法调用函数时传递的第一个参数，它可以在函数调用时修改，在函数没有调用的时候，this的值是无法确定。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;this&lt;code&gt;是在运行的时候绑定的，不是在编写的时候绑定的，函数调用的方式不同，就可能使&lt;/code&gt;this`所绑定的对象不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;headerlink&quot; title=&quot;快速入门&quot;&gt;&lt;/a&gt;快速入门&lt;/h2&gt;&lt;h3 id=&quot;1-纯粹的函数调用&quot;&gt;&lt;a href=&quot;#1-纯粹的函数调用&quot; class=&quot;headerlink&quot; title=&quot;1. 纯粹的函数调用&quot;&gt;&lt;/a&gt;1. 纯粹的函数调用&lt;/h3&gt;&lt;p&gt;第一种方法最常见，例子如下："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>JS中的this | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/ECMAScript6/" rel="tag">ECMAScript6</a></div><div class="post-time">2020-11-20</div></div></div><div class="container post-header"><h1>JS中的this</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E4%B8%AD%E7%9A%84this%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">JS中的this详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%AF%E7%B2%B9%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 纯粹的函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 对象中函数的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%ADthis"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 构造函数中this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-window-setTimeout-%E5%92%8Cwindow-setInterval-%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. window.setTimeout()和window.setInterval()中函数的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this"><span class="toc-number">1.2.</span> <span class="toc-text">箭头函数中的this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%80%EF%BC%9Athis%E6%98%AF%E7%BB%A7%E6%89%BF%E8%87%AA%E7%88%B6%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84this"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 箭头函数的特性一：this是继承自父执行上下文中的this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7%E4%BA%8C%EF%BC%9A%E4%B8%8D%E8%83%BD%E7%94%A8call%E6%96%B9%E6%B3%95%E4%BF%AE%E6%94%B9%E9%87%8C%E9%9D%A2%E7%9A%84this"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 箭头函数的特性二：不能用call方法修改里面的this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E5%B1%82%E5%AF%B9%E8%B1%A1%E5%B5%8C%E5%A5%97%E9%87%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84this"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 多层对象嵌套里箭头函数的this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">详细说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%A0%E7%A7%8D%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.几种绑定规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1.1.默认绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">1.2.隐式绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">1.3.显式绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-%E7%A1%AC%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">1.3.1.硬绑定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-API%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9Athis"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">1.3.2.API调用参数指定this</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-new%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">1.4.new绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84this"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">1.5.箭头函数的this</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.绑定规则的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 严格模式</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h1 id="JS中的this详解"><a href="#JS中的this详解" class="headerlink" title="JS中的this详解"></a>JS中的this详解</h1><ul>
<li><strong>this是使用call方法调用函数时传递的第一个参数，它可以在函数调用时修改，在函数没有调用的时候，this的值是无法确定。</strong></li>
<li>this<code>是在运行的时候绑定的，不是在编写的时候绑定的，函数调用的方式不同，就可能使</code>this`所绑定的对象不同。</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="1-纯粹的函数调用"><a href="#1-纯粹的函数调用" class="headerlink" title="1. 纯粹的函数调用"></a>1. 纯粹的函数调用</h3><p>第一种方法最常见，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">&#x27;Jerry&#x27;</span>)  <span class="comment">//调用函数</span></span><br></pre></td></tr></table></figure>

<p>这种方法我们使用最多，但是这种函数调用方法只是一种简写，它完整的写法是下面这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">test.call(<span class="literal">undefined</span>, <span class="string">&#x27;Tom&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意到上面调用函数的call方法了吗？<strong>call方法接收的第一个参数就是this，这里我们传了一个undefined</strong>。那么，依据定义，函数执行了之后打出来的this会是undefined吗？也不是。</p>
<blockquote>
<p>如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）。</p>
</blockquote>
<p>所以这里我们打出来的this是Window对象。</p>
<h3 id="2-对象中函数的调用"><a href="#2-对象中函数的调用" class="headerlink" title="2. 对象中函数的调用"></a>2. 对象中函数的调用</h3><p>直接看例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jerry&#x27;</span>,</span><br><span class="line">    <span class="attr">greet</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.greet()  <span class="comment">//第一种调用方法</span></span><br><span class="line">obj.greet.call(obj) <span class="comment">//第二种调用方法</span></span><br></pre></td></tr></table></figure>

<p>例子里第一种调用方法只是第二种调用方法的语法糖，第二种才是完整的调用方法，<strong>而且第二种方法厉害的地方在于它可以手动指定this</strong>。</p>
<p>手动指定this的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Jerry&#x27;</span>,</span><br><span class="line">    <span class="attr">greet</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.greet.call(&#123;<span class="attr">name</span>: <span class="string">&#x27;Spike&#x27;</span>&#125;)  <span class="comment">//打出来的是 Spike</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子我们看到greet函数执行时this，已经被我们改过了。</p>
<h3 id="3-构造函数中this"><a href="#3-构造函数中this" class="headerlink" title="3. 构造函数中this"></a>3. 构造函数中this</h3><p>构造函数里的this稍微有点特殊，每个构造函数在new之后都会返回一个对象，这个对象就是this，也就是context上下文。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Test()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> p)  <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name)    <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure>



<h3 id="4-window-setTimeout-和window-setInterval-中函数的调用"><a href="#4-window-setTimeout-和window-setInterval-中函数的调用" class="headerlink" title="4. window.setTimeout()和window.setInterval()中函数的调用"></a>4. window.setTimeout()和window.setInterval()中函数的调用</h3><p>window.setTimeout()和window.setInterval()的函数中的this有些特殊，里面的this默认是window对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>函数完整的调用方法是使用call方法，包括<code>test.call(context, name)</code>和<code>obj.greet.call(context,name)</code>，这里的context就是函数调用时的上下文，也就是this，只不过这个this是可以通过call方法来修改的；</li>
<li>构造函数稍微特殊一点，它的this直接指向new之后返回的对象；</li>
<li><code>window.setTimeout()</code>和<code>window.setInterval()</code>默认的是this是window对象。</li>
</ul>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>this指向</th>
</tr>
</thead>
<tbody><tr>
<td>普通函数调用</td>
<td>window</td>
</tr>
<tr>
<td>构造函数调用</td>
<td>实例对象，原型对象里面的方法也指向实例对象</td>
</tr>
<tr>
<td>对象方式调用</td>
<td>该方法所属对象</td>
</tr>
<tr>
<td>事件绑定方法</td>
<td>绑定时间对象</td>
</tr>
<tr>
<td>定时器函数</td>
<td>window</td>
</tr>
<tr>
<td>立即执行函数</td>
<td>window</td>
</tr>
</tbody></table>
<h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><h3 id="1-箭头函数的特性一：this是继承自父执行上下文中的this"><a href="#1-箭头函数的特性一：this是继承自父执行上下文中的this" class="headerlink" title="1. 箭头函数的特性一：this是继承自父执行上下文中的this"></a>1. 箭头函数的特性一：this是继承自父执行上下文中的this</h3><ul>
<li>上面提到：<strong>this的值是可以用call方法修改的，而且只有在调用的时候我们才能确定this的值</strong>。</li>
<li>而当我们使用箭头函数的时候，<strong>箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的。</strong></li>
</ul>
<p>不使用箭头函数例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.a()  <span class="comment">//打出的是obj对象</span></span><br></pre></td></tr></table></figure>

<p>使用箭头函数的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a()  <span class="comment">//打出来的是window</span></span><br></pre></td></tr></table></figure>

<p>在使用箭头函数的例子里，<strong>因为箭头函数默认不会使用自己的this，而是会和外层的this保持一致，最外层的this就是window对象。</strong></p>
<blockquote>
<p>箭头函数本身与a平级以key:value的形式，也就是箭头函数本身所在的对象为obj，而obj的父执行上下文就是window，因此这里的this实际上表示的是window。</p>
</blockquote>
<h3 id="2-箭头函数的特性二：不能用call方法修改里面的this"><a href="#2-箭头函数的特性二：不能用call方法修改里面的this" class="headerlink" title="2. 箭头函数的特性二：不能用call方法修改里面的this"></a>2. 箭头函数的特性二：不能用call方法修改里面的this</h3><p>这个也很好理解，我们之前一直在说，函数的this可以用call方法来手动指定，而为了减少this的复杂性，箭头函数无法用call方法来指定this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a.call(<span class="string">&#x27;123&#x27;</span>)  <span class="comment">//打出来的结果依然是window对象</span></span><br></pre></td></tr></table></figure>

<p>因为上文我们说到window.setTimeout()中函数里的this默认是window，我们也可以通过箭头函数使它的this和外层的this保持一致：</p>
<p>window.setTimeout()的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>) </span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a.call(obj)  <span class="comment">//第一个this是obj对象，第二个this还是obj对象</span></span><br></pre></td></tr></table></figure>

<p>想必大家明白了，函数obj.a没有使用箭头函数，因为它的this还是obj，而setTimeout里的函数使用了箭头函数，所以它会和外层的this保持一致，也是obj；如果setTimeout里的函数没有使用箭头函数，那么它打出来的应该是window对象。</p>
<h3 id="3-多层对象嵌套里箭头函数的this"><a href="#3-多层对象嵌套里箭头函数的this" class="headerlink" title="3. 多层对象嵌套里箭头函数的this"></a>3. 多层对象嵌套里箭头函数的this</h3><p>箭头函数里的this是和外层保持一致的，但是如果这个外层有好多层，那它是和哪层保持一致呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">    	<span class="attr">c</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a()  <span class="comment">// 打出的是obj对象, 相当于obj.a.call(obj)</span></span><br><span class="line">obj.b.c() <span class="comment">//打出的是obj.b对象, 相当于obj.b.c.call(obj.b)</span></span><br></pre></td></tr></table></figure>

<p>上面的代码都符合直觉，接下来把obj.b.c对应的函数换成箭头函数，结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">    	<span class="attr">c</span>: <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a()   <span class="comment">//没有使用箭头函数打出的是obj</span></span><br><span class="line">obj.b.c()  <span class="comment">//打出的是window对象！！</span></span><br></pre></td></tr></table></figure>

<p>obj.a调用后打出来的是obj对象，<strong>而obj.b.c调用后打出的是window对象而非obj，这表示多层对象嵌套里箭头函数里this是和最最外层保持一致的。</strong></p>
<h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h3 id="1-几种绑定规则"><a href="#1-几种绑定规则" class="headerlink" title="1.几种绑定规则"></a>1.几种绑定规则</h3><p>函数调用的位置对<code>this</code>的指向有着很大的影响，但却不是完全取决于它。下面是几种<code>this</code>的绑定规则：</p>
<h4 id="1-1-默认绑定"><a href="#1-1-默认绑定" class="headerlink" title="1.1.默认绑定"></a>1.1.默认绑定</h4><p>默认规则的意思就是在一般情况下，如果没有别的规则出现，就<strong>将<code>this</code>绑定到全局对象上</strong>，我们看如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo();                   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这段代码中，<code>this</code>是被默认绑定到了全局对象上，所以<code>this.a</code>得到的是<code>2</code>。我们如何判断这里应用了默认绑定呢？</p>
<p><code>foo</code>在调用的时候直接使用不带任何修饰的函数引用，只能使用默认绑定。有人会误认为结果是<code>3</code>，<code>this</code>常有的几种错误理解之一就是认为<code>this</code>指向当前函数的词法作用域，<code>this</code>与词法作用域以及作用域对象是完全不同的东西，作用域对象是在引擎内部的，<code>js</code>代码是无法访问的。还有本文我们不讨论严格模式下的情况，<strong>严格模式这里的<code>this</code>会绑定到<code>undefined</code>。</strong></p>
<h4 id="1-2-隐式绑定"><a href="#1-2-隐式绑定" class="headerlink" title="1.2.隐式绑定"></a>1.2.隐式绑定</h4><p>如果在调用位置有上下文对象，说简单点就是这个<strong>函数调用时是用一个对象<code>.</code>出来的</strong>。就像下边这样，它就遵循隐式绑定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;opps, gloabl&quot;</span>;  <span class="comment">//全局对象的属性</span></span><br><span class="line">obj.foo();               <span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line">bar();                   <span class="comment">//&quot;opps, gloabl&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第<code>9</code>行代码，就是函数在调用的时候，是用前边的对象加上<code>.</code>操作符调用出来的，此时就用到了隐式绑定规则，隐式绑定规则会将函数调用中的<code>this</code>绑定到这个上下文对象，此时的<code>this.a</code>和<code>obj.a</code>是一样的。</li>
<li>而隐式绑定会出现一个问题，就是<strong>隐式丢失</strong>，上边的第<code>10</code>行代码，是新建一个<code>foo</code>函数的引用，即<code>bar</code>，在最后一行调用的时候，这个函数不具有上下文对象，此时采用默认绑定规则，得到的结果自然是<code>opps, gloabl</code>;</li>
</ul>
<p>绑定丢失也会发生在<strong>函数作为参数传递</strong>的情况下，即传入回调函数时，因为参数传递就是一种隐式赋值，看如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();            <span class="comment">//在此处调用，参数传递是隐式赋值，丢失this绑定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;opps, global&quot;</span>;</span><br><span class="line">doFoo( obj.foo );   <span class="comment">//看似是隐式绑定，输出opps, global</span></span><br></pre></td></tr></table></figure>



<p><code>javascript</code>环境中内置的函数，在具有接受一个函数作为参数的功能的时候，也会发生像上边这种状况。例如<code>setTimeout</code>函数的实现就类似于下边的伪代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//等待delay毫秒</span></span><br><span class="line">    fn();<span class="comment">//在此处调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以回调函数丢失<code>this</code>绑定是非常常见的，后边我们再看如何通过固定<code>this</code>来修复这个问题。</p>
<h4 id="1-3-显式绑定"><a href="#1-3-显式绑定" class="headerlink" title="1.3.显式绑定"></a>1.3.显式绑定</h4><p>在此之前，相信你已经用过很多次<code>apply</code>和<code>call</code>函数了，使用这两个函数可以直接**为你要执行的函数指定<code>this</code>**，所以这种方式称为显式绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;   <span class="comment">//显式绑定this，这种方式依然无法解决绑定丢失的问题</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj );    <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>通过像上边这样调用，我们可以<strong>将<code>foo</code>的<code>this</code>强制绑定到<code>obj</code>上。</strong>如果给<code>call</code>传入的是一个基本类型数据，这个基本类型数据将会被转换成对应的基本包装类型。不过这种方式依然无法解决上边的丢失绑定问题。</p>
<h5 id="1-3-1-硬绑定"><a href="#1-3-1-硬绑定" class="headerlink" title="1.3.1.硬绑定"></a>1.3.1.硬绑定</h5><p>为了解决这个问题，我们可以写像下边这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">//创建一个包裹函数，以确保obj的绑定</span></span><br><span class="line">    foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line">bar();                   <span class="comment">//2</span></span><br><span class="line"><span class="built_in">setTimeout</span>( bar, <span class="number">100</span> );  <span class="comment">//2</span></span><br><span class="line">bar.call( <span class="built_in">window</span> );      <span class="comment">//2</span></span><br></pre></td></tr></table></figure>



<p>上边这样的函数确实解决了绑定丢失的问题，每次调用<code>bar</code>就可以确保<code>obj</code>的绑定，不过还不能为函数传参，而且这种方法复用率低，所以又出现了这样的辅助绑定函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;        <span class="comment">//辅助绑定函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = bind( foo, obj );</span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>

<p>因为这种模式很常用，所以<code>ES5</code>内置了这个方法，就是<code>bind</code>，<code>bind(...)</code>返回一个硬编码的新函数，将你指定的对象绑定到调用它的函数的<code>this</code>上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( obj );  <span class="comment">//bind返回一个绑定到obj上的新函数</span></span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;window&#x27;s a&quot;</span>;</span><br><span class="line">foo(<span class="string">&quot;!&quot;</span>);                       <span class="comment">//对原来的函数不产生影响</span></span><br></pre></td></tr></table></figure>



<h5 id="1-3-2-API调用参数指定this"><a href="#1-3-2-API调用参数指定this" class="headerlink" title="1.3.2.API调用参数指定this"></a>1.3.2.API调用参数指定this</h5><p>许多第三方库里的函数，以及许多语言内置的函数，都提供了一个可选的参数用来指定函数执行的<code>this</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( el, <span class="built_in">this</span>.id );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;awesome&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj );   <span class="comment">//forEach的第二个参数就是用来设置this</span></span><br></pre></td></tr></table></figure>



<h4 id="1-4-new绑定"><a href="#1-4-new绑定" class="headerlink" title="1.4.new绑定"></a>1.4.new绑定</h4><blockquote>
<p><code>js</code>中的所谓的构造函数，其实和一般的普通函数没有什么区别，并不具有特殊性，它们只是被<code>new</code>操作符调用的普通函数而已。实际上并不存在什么构造函数，只存在对于函数的<strong>构造调用</strong></p>
</blockquote>
<p>发生构造函数的调用时，会自动执行下边的操作：</p>
<ol>
<li>创建一个全新的对象。</li>
<li>这个对象会被执行[[Prototype]]连接。</li>
<li>这个新对象会绑定到函数调用的<code>this</code>。</li>
<li>执行这个函数里的代码。</li>
<li>如果函数没有返回其他对象，则自动返回这个新对象。</li>
</ol>
<p>这个在执行<code>new</code>操作的时候对<code>this</code>的绑定就叫做<code>new</code>绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> fun();</span><br><span class="line"><span class="built_in">console</span>.log(instance.a);</span><br></pre></td></tr></table></figure>



<h4 id="1-5-箭头函数的this"><a href="#1-5-箭头函数的this" class="headerlink" title="1.5.箭头函数的this"></a>1.5.箭头函数的this</h4><p><code>ES6</code>中的箭头函数是无法使用以上几种规则的，它是<strong>根据外层的作用域来决定<code>this</code><strong>，即</strong>取决于外层的函数作用域或全局作用域</strong>，而且箭头函数的绑定无法修改，即使是<code>new</code>绑定也不可以。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.apply(obj1);</span><br><span class="line">bar.apply(obj2);    <span class="comment">//2</span></span><br></pre></td></tr></table></figure>



<h3 id="2-绑定规则的优先级"><a href="#2-绑定规则的优先级" class="headerlink" title="2.绑定规则的优先级"></a>2.绑定规则的优先级</h3><p>前边我们已经说了<code>this</code>的几种绑定规则，当函数调用的位置可以使用多条绑定规则的时候，我们就需要确定这几种规则的优先级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line">obj1.foo();   <span class="comment">//2</span></span><br><span class="line">obj2.foo();   <span class="comment">//3</span></span><br><span class="line">obj1.foo.call( obj2 );  <span class="comment">//3</span></span><br><span class="line">obj2.foo.call( obj1 );  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>从上边的代码可以看出来，显式绑定的优先级要高于隐式绑定，下边再看看显式绑定和<code>new</code>绑定的优先级：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind( obj1 );</span><br><span class="line">bar(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log( obj1.a );  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log( obj1.a );  <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log( baz.a ); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>仔细看这段代码，<code>bar</code>是<code>foo</code>绑定到<code>obj1</code>上返回的一个函数，对这个函数进行<code>new</code>操作，并传入新的<code>a</code>值，发现改变的是新对象<code>baz</code>的属性，和<code>obj1</code>已经脱离关系。说明<code>new</code>绑定的优先级高于硬绑定。</p>
<p>综上所述，我们在遇到<code>this</code>时，如果不是箭头函数，就可以以这种顺序判断它的指向：</p>
<ol>
<li>如果函数在<code>new</code>中调用，绑定到新建的对象。</li>
<li>函数通过<code>call</code>或<code>apply</code>或者硬绑定调用，<code>this</code>绑定到指定的对象上。</li>
<li>函数在某个上下文对象中调用，绑定到这个上下文对象上。</li>
<li>采用默认绑定规则。</li>
</ol>
<h3 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3. 严格模式"></a>3. 严格模式</h3><ul>
<li>严格模式下，全局作用域的function中的this是undefined</li>
<li>严格模式下，定时器函数的this还是指向window</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为一般函数fn绑定的this是window，一旦调用fn，sex就赋值给window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(sex) <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.sex) <span class="comment">// male</span></span><br></pre></td></tr></table></figure>

<p>严格模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="comment">// 因为严格模式下，全局作用域的function中的this是undefined，</span></span><br><span class="line"><span class="comment">// 给undefined赋值sex变量，自然报错</span></span><br><span class="line">fn(); </span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure>



































</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>