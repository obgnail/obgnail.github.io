<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;goroutine&quot;&gt;&lt;a href=&quot;#goroutine&quot; class=&quot;headerlink&quot; title=&quot;goroutine&quot;&gt;&lt;/a&gt;goroutine&lt;/h2&gt;&lt;p&gt;Go协程的特点"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>尚硅谷韩顺平Go语言核心编程2 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2020-11-20</div></div></div><div class="container post-header"><h1>尚硅谷韩顺平Go语言核心编程2</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#goroutine"><span class="toc-number">1.</span> <span class="toc-text">goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">goroutine调用说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MPG%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">MPG模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEgolang%E7%A8%8B%E5%BA%8F%E7%9A%84CPU%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">设置golang程序的CPU数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">goroutine可能出现的两个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%981-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%85%88%E4%BA%8Egoroutine%E7%BB%93%E6%9D%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">问题1 : 主线程先于goroutine结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982-goroutine%E8%B5%84%E6%BA%90%E4%BA%89%E6%8A%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">问题2 : goroutine资源争抢</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8Cgoroutine%E8%BF%9B%E8%A1%8C%E9%80%9A%E8%AE%AF"><span class="toc-number">2.</span> <span class="toc-text">不同goroutine进行通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B7%BB%E5%8A%A0%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">全局变量添加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel"><span class="toc-number">2.2.</span> <span class="toc-text">channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chan%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.1.</span> <span class="toc-text">chan操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chan%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">chan使用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chan%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B2"><span class="toc-number">2.2.3.</span> <span class="toc-text">chan使用案例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%8F%AA%E5%86%99%E7%AE%A1%E9%81%93"><span class="toc-number">2.2.4.</span> <span class="toc-text">只读只写管道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select"><span class="toc-number">3.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">4.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect-Kind-%E5%92%8C-reflect-Type%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">reflect.Kind 和 reflect.Type的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface-reflect-Value-%E5%92%8C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC"><span class="toc-number">4.2.</span> <span class="toc-text">interface , reflect.Value 和 变量类型互转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%8F%8D%E5%B0%84%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BF%AE%E6%94%B9int%E5%80%BC"><span class="toc-number">4.3.</span> <span class="toc-text">在反射函数中修改int值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E6%AE%B5-%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95-%E8%8E%B7%E5%8F%96stuct-tag%E5%80%BC"><span class="toc-number">4.4.</span> <span class="toc-text">使用反射遍历结构体的字段,调用结构体方法,获取stuct tag值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">go的适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="toc-number">5.</span> <span class="toc-text">自定义错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DAO"><span class="toc-number">6.</span> <span class="toc-text">DAO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">TCP编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">8.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">8.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">8.2.</span> <span class="toc-text">Redis连接池</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go协程的特点</p>
<ul>
<li>有独立的栈空间</li>
<li>共享程序堆空间</li>
<li>调度由用户控制</li>
</ul>
<blockquote>
<ul>
<li>主线程是一个<strong>物理线程</strong>，直接作用在cpu上的。是重量级的，非常耗费cpu资源。</li>
<li>协程从主线程开启的，是轻量级的线程，是逻辑态。对资源消耗相对小。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGoroutine</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;this is goroutine&quot;</span>, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> testGoroutine()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;this is main string&quot;</span>, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="goroutine调用说明"><a href="#goroutine调用说明" class="headerlink" title="goroutine调用说明"></a>goroutine调用说明</h3><ol>
<li><p>一个线程就是一个<code>栈</code>加<code>堆资源</code>。操作系统一会让cpu跑线程A，一会让cpu跑线程B，<strong>靠A和B的栈来保存A和B的执行状态。</strong>每个线程都有他自己的栈。</p>
</li>
<li><p>但是线程又老贵了，花不起那个钱，所以go发明了 goroutine。大致就是说给每个goroutine弄一个分配在<code>资源堆</code>里面的<code>栈</code>来模拟线程栈。</p>
</li>
<li><p>比方说有3个goroutine,A,B,C，就在<code>资源堆</code>上弄<strong>三</strong>个栈出来。然后Go让一个单线程的scheduler开始跑他们仨。相当于<code>&#123; A(); B(); C() &#125;</code>，连续的，串行的跑。</p>
</li>
<li><p>和操作系统不太一样的是，操作系统可以随时随地把你线程停掉，切换到另一个线程。这个单线程的  scheduler没那个能力啊，他跑着A的时候控制权是在A的代码里面的. A自己不退出谁也没办法。</p>
</li>
<li><p>所以A跑一小段后需要主动说，老大（scheduler），我不想跑了，帮我把我的所有的状态保存在我自己的栈上面，让我歇一会吧。这时候你可以看做A返回了。</p>
</li>
<li><p>A返回了B就可以跑了，然后B跑一小段说，跑够了，保存状态，返回，然后C再跑。C跑一段也返回了。</p>
</li>
<li><p>这样跑完<code>&#123; A(); B(); C() &#125;</code>之后，我们发现，好像他们都只跑了一小段啊。所以外面要包一个循环，大致是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goroutine_list = [A,B,C]</span><br><span class="line"><span class="keyword">while</span> (goroutine_list):</span><br><span class="line">    <span class="keyword">for</span> goroutine <span class="keyword">in</span> goroutine_list:</span><br><span class="line">        r = goroutine()</span><br><span class="line">        <span class="keyword">if</span> r.isFinished():</span><br><span class="line">            goroutine_list.remove(r)</span><br></pre></td></tr></table></figure>

<p>比如跑完一圈A,B,C之后谁也没执行完，那么就在回到A执行一次。由于我们把A的栈保存在了<code>资源堆</code>里，这时候可以把A的栈复制粘贴回系统栈里，然后再调用A，这时候由于A是跑到一半自己说跳出来的，所以会从刚刚跳出来的地方继续执行。</p>
</li>
<li><p>所以你看出来了，关键就在于每个 goroutine跑一跑就要让一让。一般支持这种玩意（叫做 coroutine）的语言都是让每个coroutine自己说，我跑够了，换人。goroutine比较文艺的地方就在于，他可以来帮你判断啥时候“跑够了”。</p>
<p>比如说python , 就需要使用<code>await</code>关键字表明, 该函数跑够了 , 该暂时让出资源了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x) <span class="comment"># 在此处暂停,执行权交给其他函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(x)</span><br></pre></td></tr></table></figure></li>
<li><p>go 是如何做到这一点的呢? go把每一个能异步并发的操作，包成一个同步的“方法” , 但是这个方法里其实会调用“异步并发”的操作.</p>
<p>比如<code>string s = go.file.readFile(&quot;/root&quot;)</code>其实go偷偷在里面执行了操作系统的API asyncReadFIle。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 实际上</span></span><br><span class="line">handler h = OS.asyncReadFile(<span class="string">&quot;/root&quot;</span>) <span class="comment">#很快返回一个handler</span></span><br><span class="line"><span class="keyword">while</span> (!h.finishedAsyncReadFile()): <span class="comment">#很快返回Y/N</span></span><br><span class="line">  go.scheduler.保存现状()</span><br><span class="line">  <span class="keyword">yield</span> go.scheduler.跑够了_换人() <span class="comment"># 相当于return，不过下次会从这里的下一句开始执行</span></span><br><span class="line">string s = h.getResultFromAsyncRead()</span><br></pre></td></tr></table></figure></li>
<li><p>然后scheduler就换下一个goroutine跑了。等下次再<strong>跑回</strong>刚才那个goroutine的时候，他就看看，说那个asyncReadFile到底执行完没有啊，如果没有，就再换个人吧。如果执行完了，那就把结果拿出来，该干嘛干嘛。所以你看似写了个同步的操作，已经被go替换成异步操作了。</p>
</li>
<li><p>还有另外一种情况是，某个goroutine执行了某个<strong>不能异步调用</strong>的 , 会阻塞的系统调用，这个时候goroutine就没法玩那种异步调用的把戏了。他会把你挪到一个真正的线程里让你在那个线程里等着，他接茬去跑别的goroutine。</p>
<p>比如A这么定义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>:</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">  go.os.调用一些真正复杂的会阻塞的函数()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;do something 2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>go会帮你转成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 真实的<span class="title">A</span>:</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">  Thread t = new Thread( () =&gt; &#123;</span><br><span class="line">    go.os.调用一些真正复杂的会阻塞的函数()</span><br><span class="line">  &#125;)</span><br><span class="line">  t.start()</span><br><span class="line">  <span class="keyword">while</span> !t.finished():</span><br><span class="line">    go.scheduler.保存现状</span><br><span class="line">    go.scheduler.跑够了_换人</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;finished&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>所以真实的A还是不会blocking，还是可以跟别的小伙伴(goroutine)愉快地玩耍（轮流往复的被执行），但他其实已经占了一个真实的系统线程了。</p>
</li>
</ol>
<h3 id="MPG模型"><a href="#MPG模型" class="headerlink" title="MPG模型"></a>MPG模型</h3><ul>
<li>M：操作系统的主线程（是物理线程）</li>
<li>P：代表了M所需的上下文环境，<strong>用于协调M和G的执行</strong>，内核线程只有拿到了P才对 goroutine继续调度执行，一般都是通过限定P的个数来控制 galang的并发度</li>
<li>G：协程</li>
</ul>
<p><img src="/images/1591414922123.png" alt="1591414922123"></p>
<ol>
<li>当前程序有三个M，如果三个M都在一个cpu运行，就是并发，如果在不同的cpu运行就是并行</li>
<li><code>M1</code> ,<code> M2</code>，<code>M3</code>正在执行一个G ，M1的协程队列有3个，M2的协程队列有3个，M3协程队列有2个</li>
<li>图中灰色的那些 goroutine并没有运行，而是出于read的就绪态，正在等待被调度。P维护着这个队列（称之为 runqueue）</li>
<li>从上图可以看到：Go的协程是轻量级的线程，是<strong>逻辑态</strong>的，Go可以容易的起上万个协程。其它程序c/java的多线程，往往是内核态的，比较重量级。几千个线程可能耗光CPU。</li>
</ol>
<h3 id="设置golang程序的CPU数量"><a href="#设置golang程序的CPU数量" class="headerlink" title="设置golang程序的CPU数量"></a>设置golang程序的CPU数量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前系统CPU的数量</span></span><br><span class="line">	num := runtime.NumCPU()</span><br><span class="line">	<span class="comment">// 设置程序使用的cpu数量</span></span><br><span class="line">	runtime.GOMAXPROCS(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="goroutine可能出现的两个问题"><a href="#goroutine可能出现的两个问题" class="headerlink" title="goroutine可能出现的两个问题"></a>goroutine可能出现的两个问题</h3><h4 id="问题1-主线程先于goroutine结束"><a href="#问题1-主线程先于goroutine结束" class="headerlink" title="问题1 : 主线程先于goroutine结束"></a>问题1 : 主线程先于goroutine结束</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line">	m[n] = res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Factorial(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出不确定 , 有时输出如下 , 有时没有输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map[5]=120</span><br><span class="line">map[7]=5040</span><br><span class="line">map[10]=3628800</span><br><span class="line">map[1]=1</span><br><span class="line">map[3]=6</span><br><span class="line">map[4]=24</span><br><span class="line">map[9]=362880</span><br><span class="line">map[2]=2</span><br><span class="line">map[6]=720</span><br><span class="line">map[8]=40320</span><br></pre></td></tr></table></figure>

<p>原因很简单 : 有可能主线程先于协程结束 , 有可能主线程慢于协程结束</p>
<h4 id="问题2-goroutine资源争抢"><a href="#问题2-goroutine资源争抢" class="headerlink" title="问题2 : goroutine资源争抢"></a>问题2 : goroutine资源争抢</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line">	m[n] = res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Factorial(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码 把问题1的代码的10次循环改成200 , 并添加<code>time.Sleep</code> , 保证了主线程慢于协程结束</p>
<p>但是依旧会报错 :</p>
<ul>
<li>map由多协程同时读和写就会出现<code>fatal error:concurrent map read and map write</code>的错误</li>
<li>多个协程同时写也会出现<code>fatal error: concurrent map writes</code>的错误</li>
</ul>
<p>原因 : </p>
<ul>
<li>因为map为引用类型，所以即使函数传值调用，参数副本依然指向映射m, 所以多个goroutine并发写同一个映射m， 对于共享变量，资源，并发读写会产生竞争的， 故共享资源遭到破坏</li>
</ul>
<p>我们使用<code>go build -race bbb.go</code> , <code>bbb.exe</code> 查看资源竞争情况 , 发现有2个数据发生争抢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">map[19]=121645100408832000</span><br><span class="line">map[80]=0</span><br><span class="line">map[87]=0</span><br><span class="line">map[185]=0</span><br><span class="line">map[197]=0</span><br><span class="line">Found 2 data race(s)</span><br></pre></td></tr></table></figure>



<h2 id="不同goroutine进行通讯"><a href="#不同goroutine进行通讯" class="headerlink" title="不同goroutine进行通讯"></a>不同goroutine进行通讯</h2><h3 id="全局变量添加锁"><a href="#全局变量添加锁" class="headerlink" title="全局变量添加锁"></a>全局变量添加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个全局的互斥锁</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		res *= i</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Lock() <span class="comment">// 在写入的时候加锁</span></span><br><span class="line">	m[n] = res</span><br><span class="line">	lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Factorial(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	lock.Lock() <span class="comment">// 在读取的时候加锁</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;map[%d]=%d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">	lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>读取为什么需要加互斥锁?</li>
<li>按理说5秒后协程都应该执行完，后面就不应该出现资源竞争的问题了，</li>
<li>但是在实际运行中，还是可能在读取的时候出现竞争问题（运行时增加<code>-race</code>参数确实会发现有资源竞争问题），</li>
<li>因为我们程序从设计上可以知道5秒就执行完所有协程，但是主线程并不知道，因此底层可能仍然岀现资源争夺，因此加入互斥锁即可解决问题</li>
</ul>
</blockquote>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><ul>
<li>本质是<code>队列</code></li>
<li>channel 是有类型的 , string类型就需要放到string类型的channel</li>
<li>当我们给channel写入数据时 , 不能超出channel的容量</li>
<li>在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报告<code>deadlock</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	num := <span class="number">10</span></span><br><span class="line">	intChan &lt;- num</span><br><span class="line">	intChan &lt;- <span class="number">20</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan)) <span class="comment">// 2 3</span></span><br><span class="line">	num2 := &lt;-intChan</span><br><span class="line">	fmt.Println(num2)                       <span class="comment">// 10</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(intChan), <span class="built_in">cap</span>(intChan)) <span class="comment">// 1 3</span></span><br><span class="line"></span><br><span class="line">	mapChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">	mapChan &lt;- <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;heyingliang&quot;</span>: <span class="number">21</span>&#125;</span><br><span class="line">	fmt.Println(&lt;-mapChan) <span class="comment">// map[heyingliang:21]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用空接口作为chan的时候 , 在取出后注意需要进行<code>类型断言</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	allChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">	allChan &lt;- Student&#123;<span class="string">&quot;heyingliang&quot;</span>, <span class="number">21</span>&#125;</span><br><span class="line">	allChan &lt;- <span class="number">12</span></span><br><span class="line">	allChan &lt;- <span class="string">&quot;heyingling&quot;</span></span><br><span class="line">	allChan &lt;- &amp;Student&#123;<span class="string">&quot;123&quot;</span>, <span class="number">123</span>&#125;</span><br><span class="line">	allChan &lt;- <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;heyingliang&quot;</span>: <span class="number">21</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意需要类型断言</span></span><br><span class="line">	fmt.Println((&lt;-allChan).(Student).Name) <span class="comment">// heyingliang</span></span><br><span class="line">	fmt.Println((&lt;-allChan).(<span class="keyword">int</span>) + <span class="number">22</span>) <span class="comment">// 34</span></span><br><span class="line">	fmt.Println((&lt;-allChan).(<span class="keyword">string</span>) + <span class="string">&quot;is sb&quot;</span>) <span class="comment">// heyinglingis sb</span></span><br><span class="line">	fmt.Println((&lt;-allChan).(*Student).Name) <span class="comment">// 123</span></span><br><span class="line">	m := (&lt;-allChan).(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	m[<span class="string">&quot;czj&quot;</span>] = <span class="number">22</span></span><br><span class="line">	fmt.Println(m[<span class="string">&quot;czj&quot;</span>]) <span class="comment">// 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="chan操作"><a href="#chan操作" class="headerlink" title="chan操作"></a>chan操作</h4><ul>
<li><p>关闭 : 关闭后只允许读取 , 不允许写入</p>
<ul>
<li>严格来说 , 应该是 : 在最后发送的值被接收后停止该通道。</li>
</ul>
</li>
<li><p>遍历 : <code>for--range</code></p>
<ul>
<li><p>不能使用<code>for-index,val</code> 原因 : chan取值是<code>弹出操作</code> , 所以每次取值之后,chan的长度会-1 . 这样的话100个数据最后只能拿到50个数据</p>
<blockquote>
<p>这也说明了为什么遍历是<code>for val := range chan</code> ,而不是<code>for idx ,val :=range chan</code> . </p>
<p>因为chan本身就是<code>队列</code> , 没有下标</p>
</blockquote>
</li>
<li><p><strong>在遍历时，如果channe没有关闭，则会出现 deadlock的错误</strong></p>
<blockquote>
<p>为什么会出现<code>deadlock的错误</code>?</p>
<p>因为 : 在没有使用协程的情况下，如果我们的管道数据已经全部取出，再取就会报告<code>deadlock</code></p>
<p>当chan的最后一个值被取出后 , 再取就报错</p>
</blockquote>
</li>
<li><p>在遍历时，如果channel已经关闭，则会正常遍历数据，遍历完后，就会退岀遍历</p>
</li>
</ul>
</li>
<li><p>检查Channel是否已经被关闭了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">	c &lt;- <span class="number">2</span></span><br><span class="line">	c &lt;- <span class="number">3</span></span><br><span class="line">	c &lt;- <span class="number">4</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 关闭管道</span></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">	val, ok := &lt;-c</span><br><span class="line">	fmt.Println(val, ok) <span class="comment">// 1 true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历管道</span></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(v) <span class="comment">// 2 3 4</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="chan使用案例"><a href="#chan使用案例" class="headerlink" title="chan使用案例"></a>chan使用案例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> exitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteData</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;write&quot;</span>, i)</span><br><span class="line">		intChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadData</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		v, ok := &lt;-intChan</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;read&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	exitChan &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="built_in">close</span>(exitChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> WriteData()</span><br><span class="line">	<span class="keyword">go</span> ReadData()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, ok := &lt;-exitChan</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的<code>intChan</code>长度只有10 , 但是写入了50个元素 , 结果没有报错 , 原因 : <code>管道的阻塞机制</code></p>
<ul>
<li>如果编译器发现管道只有写，而没有读，则该管道会发生阻塞 , 报错。</li>
<li>写管道和读管道的频率不一致，一样能运行通过。</li>
</ul>
</blockquote>
<h4 id="chan使用案例2"><a href="#chan使用案例2" class="headerlink" title="chan使用案例2"></a>chan使用案例2</h4><p>求出1-20000中的质数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">var</span> outputChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="keyword">var</span> exitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inputData</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= num; i++ &#123;</span><br><span class="line">		inputChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(inputChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oddNum</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		isOdd := <span class="literal">true</span></span><br><span class="line">		val, ok := &lt;-inputChan</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			exitChan &lt;- <span class="literal">true</span></span><br><span class="line">			fmt.Println(num, <span class="string">&quot;is stopping&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= val/<span class="number">2</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> val%i == <span class="number">0</span> &#123;</span><br><span class="line">				isOdd = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> isOdd &#123;</span><br><span class="line">			outputChan &lt;- val</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> inputData(<span class="number">8000</span>)</span><br><span class="line">	<span class="keyword">go</span> oddNum(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> oddNum(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> oddNum(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">go</span> oddNum(<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(exitChan) == <span class="number">4</span> &#123;</span><br><span class="line">				<span class="built_in">close</span>(outputChan)</span><br><span class="line">				<span class="built_in">close</span>(exitChan)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> val := <span class="keyword">range</span> outputChan &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="只读只写管道"><a href="#只读只写管道" class="headerlink" title="只读只写管道"></a>只读只写管道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认支持读写</span></span><br><span class="line"><span class="comment">// var chan1 chan int</span></span><br><span class="line"><span class="keyword">var</span> chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明只读</span></span><br><span class="line"><span class="keyword">var</span> chan2 = <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明只写</span></span><br><span class="line"><span class="keyword">var</span> chan3 = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<p>用法 : </p>
<p>将函数参数的chan改成<code>只写</code>或<code>只读</code> , 防止误操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeChan</span><span class="params">(intchan <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	intchan &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readChan</span><span class="params">(intchan &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(&lt;-intchan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><ul>
<li><p>select 是 Go 中的一个控制结构，类似于用于<strong>通信的 switch 语句</strong>。</p>
</li>
<li><p>每个 case 必须是一个通信操作，要么是发送要么是接收。</p>
</li>
<li><p>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</p>
<p>(如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。)</p>
</li>
<li><p>一个默认的子句应该总是可运行的。</p>
</li>
</ul>
<blockquote>
<ol>
<li><p>如果有 default 子句，则执行该语句。</p>
</li>
<li><p>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</p>
</li>
</ol>
<p>所以沒有 <code>default</code> 的 select 就會遇到 blocking，假設沒有送 value 進去 Channel 就會造成 panic。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">var</span> stringChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++ &#123;</span><br><span class="line">		intChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++ &#123;</span><br><span class="line">		stringChan &lt;- <span class="string">&quot;hyl&quot;</span> + fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-intChan:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;intChan %d\n&quot;</span>, v)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-stringChan:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;stringChan %s\n&quot;</span>, v)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;默认\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>python中的反射</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">num_arr</span>):</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> val <span class="keyword">in</span> num_arr:</span><br><span class="line">		res += val</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span>(<span class="params">num1,num2</span>):</span></span><br><span class="line">	<span class="keyword">return</span> num1 - num2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bridge</span>(<span class="params">func,*args</span>):</span></span><br><span class="line">	<span class="keyword">return</span> func(*args)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bridge(add,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])) <span class="comment"># 15</span></span><br><span class="line"><span class="built_in">print</span>(bridge(sub,<span class="number">50</span>,<span class="number">10</span>)) <span class="comment"># 40   </span></span><br></pre></td></tr></table></figure>



<ul>
<li>反射可以在<strong>运行时</strong>动态获取变量的各种信息，比如变量的类型（<code>type</code>），类别（<code>kind</code>）</li>
<li>如果是结构体变量，还可以获取到结构体本身的信息（包括结构体的字段、方法）</li>
<li>通过反射，可以修改变量的值，可以调用关联的方法</li>
<li>使用反射，需要<code>import(&quot;reflect&quot;)</code></li>
</ul>
<blockquote>
<ul>
<li>reflect包实现了运行时反射，允许程序操作任意类型的对象，典型用法是用静态类型interface{}保存一个值，</li>
<li><code>reflect.TypeOf(变量名)</code> : 获取变量类型 , 返回reflect.Type类型</li>
<li><code>reflect.ValueOf(变量名)</code> : 获取变量的值 , 返回refulect.Value类型 (refulect.Value是一个结构体类型)</li>
<li><code>reflect.Zero(Type类型变量)</code> : 返回该类型零值的Value类型值</li>
</ul>
</blockquote>
<h3 id="reflect-Kind-和-reflect-Type的区别"><a href="#reflect-Kind-和-reflect-Type的区别" class="headerlink" title="reflect.Kind 和 reflect.Type的区别"></a>reflect.Kind 和 reflect.Type的区别</h3><ul>
<li>Type是类型，Kind是类别，</li>
<li>Type和Kind可能是相同的，也可能是不同<ul>
<li>比如：var num int = 10 , num的Type是int , Kind也是int</li>
<li>比如：var stu Student stu 的Type是pkg1.Student , Kind是 struct </li>
</ul>
</li>
</ul>
<h3 id="interface-reflect-Value-和-变量类型互转"><a href="#interface-reflect-Value-和-变量类型互转" class="headerlink" title="interface , reflect.Value 和 变量类型互转"></a>interface , reflect.Value 和 变量类型互转</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bridge</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    <span class="comment">// interface&#123;&#125; --&gt; reflect.Value</span></span><br><span class="line">    rVal := reflect.ValueOf(b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reflect.Value --&gt; interface&#123;&#125;</span></span><br><span class="line">    iVal := rVal.<span class="keyword">interface</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// interface&#123;&#125; --&gt; 原来的变量类型 , 使用类型断言即可</span></span><br><span class="line">    v := iVal.(Student)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/1591607663510.png" alt="1591607663510"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// interface&#123;&#125;类型转为reflect.Value类型</span></span><br><span class="line">	rValue := reflect.ValueOf(b)</span><br><span class="line">	rType := reflect.TypeOf(b)</span><br><span class="line">	rKind := rValue.Kind()</span><br><span class="line">	fmt.Println(rValue, rType, rKind) <span class="comment">// 25.5 float64 float64</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// reflect.Value类型转为interface&#123;&#125;类型</span></span><br><span class="line">	inf := rValue.Interface()</span><br><span class="line">  <span class="comment">// interface&#123;&#125;类型转为具体变量类型</span></span><br><span class="line">	v := inf.(<span class="keyword">float64</span>)</span><br><span class="line">	fmt.Println(inf, v) <span class="comment">// 25.5 25.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := <span class="number">25.5</span></span><br><span class="line">	reflectTest(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="在反射函数中修改int值"><a href="#在反射函数中修改int值" class="headerlink" title="在反射函数中修改int值"></a>在反射函数中修改int值</h3><ul>
<li>rVal.Elem()：取元素，等效于对指针类型变量做了一个<code>*</code>操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	rVal := reflect.ValueOf(b)</span><br><span class="line">	<span class="comment">// 在反射中修改int值 , 同理有SetString,SetBool等等</span></span><br><span class="line">	rVal.Elem().SetInt(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">	<span class="comment">// 传入int的指针类型</span></span><br><span class="line">	reflectTest(&amp;num)</span><br><span class="line">	fmt.Println(num) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用反射遍历结构体的字段-调用结构体方法-获取stuct-tag值"><a href="#使用反射遍历结构体的字段-调用结构体方法-获取stuct-tag值" class="headerlink" title="使用反射遍历结构体的字段,调用结构体方法,获取stuct tag值"></a>使用反射遍历结构体的字段,调用结构体方法,获取stuct tag值</h3><ul>
<li><p><code>func (v Value) Method(i int ) Value</code> : 获取结构体第i个方法</p>
</li>
<li><p><code>func(v Value) Call(in []Value) []Value</code> : 调用结构体方法</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Age <span class="keyword">int</span> <span class="string">`json:&quot;monster_age&quot;`</span></span><br><span class="line">	Score <span class="keyword">float32</span></span><br><span class="line">	Sex <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Monster)</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Monster)</span> <span class="title">GetSum</span><span class="params">(n1 ,n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n1 +n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Monster)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>,age <span class="keyword">int</span>,socre <span class="keyword">float32</span>,sex <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">	m.Name = name</span><br><span class="line">	m.Age = age</span><br><span class="line">	m.Score = socre</span><br><span class="line">	m.Sex = sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStruct</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	typ := reflect.TypeOf(a)</span><br><span class="line">	val := reflect.ValueOf(a)</span><br><span class="line">	kd := val.Kind()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> kd != reflect.Struct&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;expect struct&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取到该结构体有几个字段</span></span><br><span class="line">	num := val.NumField()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d fields\n&quot;</span>,num) <span class="comment">// struct has 4 fields</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历结构体的所有字段</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;num;i++&#123;</span><br><span class="line">		<span class="comment">// val.Field(i): 返回结构体的第i个字段(Value封装)</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Field %d: 值为=%v\n&quot;</span>,i,val.Field(i))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取到struct标签,注意需要通过reflect.Type来获取tag标签的值</span></span><br><span class="line">		tagVal := typ.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> tagVal != <span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Field %d: tag为=%v\n&quot;</span>,i,tagVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取到该结构体有几个方法</span></span><br><span class="line">	numOfMethod := val.NumMethod()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;struct has %d methods\n&quot;</span>,numOfMethod) <span class="comment">// struct has 3 methods</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先对方法按照ascii码进行排序,然后调用第2个方法(从0开始)</span></span><br><span class="line">	val.Method(<span class="number">1</span>).Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明函数参数的切片</span></span><br><span class="line">	<span class="keyword">var</span> params []reflect.Value</span><br><span class="line">	params = <span class="built_in">append</span>(params,reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params,reflect.ValueOf(<span class="number">40</span>))</span><br><span class="line">	<span class="comment">// 调用结构体的第一个方法:Method(0)</span></span><br><span class="line">	res := val.Method(<span class="number">0</span>).Call(params) <span class="comment">// 传入参数是 []reflect.Value</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>,res[<span class="number">0</span>].Int()) <span class="comment">// 返回结果,返回的结果是 []reflect.Value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m Monster = Monster&#123;</span><br><span class="line">		Name:<span class="string">&quot;heyingliang&quot;</span>,</span><br><span class="line">		Age:<span class="number">400</span>,</span><br><span class="line">		Score:<span class="number">30.8</span>,</span><br><span class="line">		Sex:<span class="string">&quot;男&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	TestStruct(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct has 4 fields</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field 0: 值为=heyingliang</span></span><br><span class="line"><span class="comment">// Field 0: tag为=name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field 1: 值为=400</span></span><br><span class="line"><span class="comment">// Field 1: tag为=monster_age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field 2: 值为=30.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field 3: 值为=男</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct has 3 methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;heyingliang 400 30.8 男&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// res= 50</span></span><br></pre></td></tr></table></figure>



<h3 id="go的适配器"><a href="#go的适配器" class="headerlink" title="go的适配器"></a>go的适配器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(num1 + num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(num1 <span class="keyword">int</span>, num2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(num1 - num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bridge</span><span class="params">(call <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 将args转为reflect.Value类型</span></span><br><span class="line">	n := <span class="built_in">len</span>(args)</span><br><span class="line">	inValue := <span class="built_in">make</span>([]reflect.Value,n)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++&#123;</span><br><span class="line">		inValue[i] = reflect.ValueOf(args[i])</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 将call转为reflect.Value类型</span></span><br><span class="line">	function := reflect.ValueOf(call)</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">	function.Call(inValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bridge(add, <span class="number">100</span>,<span class="number">200</span>) <span class="comment">// 300</span></span><br><span class="line">	bridge(sub,<span class="number">100</span>,<span class="number">200</span>)  <span class="comment">// -100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ERROR_USER_NOTEXISTS = errors.New(<span class="string">&quot;用户不存在&quot;</span>)</span><br><span class="line">	ERROR_USER_EXISTS = errors.New(<span class="string">&quot;用户已经存在&quot;</span>)</span><br><span class="line">	ERROR_USER_PWD = errors.New(<span class="string">&quot;密码不正确&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserDao <span class="keyword">struct</span> &#123;</span><br><span class="line">	pool *redis.Pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserDao</span><span class="params">(pool *redis.Pool)</span> <span class="params">(userDao *UserDao)</span></span> &#123;</span><br><span class="line">	UserDao = &amp;UserDao&#123; pool &#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UserDao)</span> <span class="title">getUserByID</span><span class="params">(conn redis.Conn, id <span class="keyword">int</span>)</span> <span class="params">(user *User, err error)</span></span> &#123;</span><br><span class="line">	res, err := redis.String(conn.Do(<span class="string">&quot;HGet&quot;</span>,<span class="string">&quot;users&quot;</span>,id))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 在users的哈希中,没有找到对应id</span></span><br><span class="line">		<span class="keyword">if</span> err == redis.ErrNil &#123;</span><br><span class="line">			err = ERROR_USER_NOTEXISTS</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	user = &amp;User&#123;&#125;</span><br><span class="line">	err = json.Umarshal([]<span class="keyword">byte</span>(res), User)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json.Umarshal err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *UserDao)</span> <span class="title">Login</span><span class="params">(userId <span class="keyword">int</span>, UserPwd <span class="keyword">string</span>)</span> <span class="params">(user *User, err error)</span></span>&#123;</span><br><span class="line">	conn := this.pool.Get()</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	user, err = this.getUserByID(conn, userId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> user.UserPwd != userPwd &#123;</span><br><span class="line">		err = ERROR_USER_PWD</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><ul>
<li>端口监听到一个请求时 , 其他语言都会创建一个线程/进程/协程来处理该请求 , go就可以使用<code>goroutine</code>来解决</li>
<li><code>net包</code>包含<code>网络socket开发</code>需要所有的方法和函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span>&#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">		<span class="comment">// 如果客户端没有write,那么协程就会阻塞在在这里</span></span><br><span class="line">		n,err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端已退出&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;0.0.0.0:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;listen err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;等待客户端连接&quot;</span>)</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Accept() err=&quot;</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Accept() suc con=%v\n&quot;</span>, conn)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 在此处准备协程,为客户端服务</span></span><br><span class="line">		<span class="keyword">go</span> process(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// net.Dial: 和服务器建立连接</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;192.168.20.253:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;client dial err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;conn 成功=&quot;</span>, conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 客户端发送单行数据,然后退出</span></span><br><span class="line">	reader := bufio.NewReader(os.Studin)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line,err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;readString err=&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> line == <span class="string">&quot;exit&quot;</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;客户端退出&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		n, err := conn.Write([]<span class="keyword">byte</span>(line))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;conn.Write err=&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;客户端发送了 %d 字节的数据,并退出&quot;</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/garyburd/redigo/redis&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := redis.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;redis.Dial err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	_, err := conn.Do(<span class="string">&quot;Set&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;heyingliang&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;set err=&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;set succ&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// conn.Do(&quot;Get&quot;,&quot;name&quot;) 返回的r是interface&#123;&#125;,所以需要强转</span></span><br><span class="line">	r, err := redis.String(conn.Do(<span class="string">&quot;Get&quot;</span>,<span class="string">&quot;name&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;get err&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(r)</span><br><span class="line"></span><br><span class="line">	_,err = conn.Do(<span class="string">&quot;HMSet&quot;</span>,<span class="string">&quot;user&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;heyingliang&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>)</span><br><span class="line">	<span class="comment">// 注意这里是redis.Strings(复数)</span></span><br><span class="line">	r,err = redis.Strings(conn.Do(<span class="string">&quot;HMSet&quot;</span>,<span class="string">&quot;user&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i,v := <span class="keyword">range</span> r &#123;</span><br><span class="line">		fmt.Println(i,v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Redis连接池"><a href="#Redis连接池" class="headerlink" title="Redis连接池"></a>Redis连接池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/garyburd/redigo/redis&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> poll *redis.Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	pool = &amp;redis.Pool&#123;</span><br><span class="line">		<span class="comment">// 最大空闲连接数</span></span><br><span class="line">		MaxIdle: <span class="number">8</span>, </span><br><span class="line">		<span class="comment">// 数据库最大连接数,0表示无限制</span></span><br><span class="line">		MaxActive: <span class="number">0</span>,</span><br><span class="line">		<span class="comment">// 最大空闲时间</span></span><br><span class="line">		IdleTimeout: <span class="number">100</span>,</span><br><span class="line">		<span class="comment">// 初始化连接代码</span></span><br><span class="line">		Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> redis.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;localhost:6379&quot;</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn := pool.Get()</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	</span><br><span class="line">	_,err := conn.Do(<span class="string">&quot;Set&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hyl&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>