<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第四章-变量作用域&quot;&gt;&lt;a href=&quot;#第四章-变量作用域&quot; class=&quot;headerlink&quot; title=&quot;第四章 变量作用域&quot;&gt;&lt;/a&gt;第四章 变量作用域&lt;/h2&gt;&lt;h3 id=&quot;变量在哪里声明，这个变量的作用域就在哪里&quot;&gt;&lt;a href=&quot;#变量在哪里声明，这个变量的作用域就在哪里&quot; class=&quot;headerlink&quot; title=&quot;变量在哪里声明，这个变量的作用域就在哪里&quot;&gt;&lt;/a&gt;变量在哪里声明，这个变量的作用域就在哪里&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;声明变量的位置，决定了变量所处的作用域："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>GO语言趣味指南 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2020-11-21</div></div></div><div class="container post-header"><h1>GO语言趣味指南</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text">第四章 变量作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%9C%A8%E5%93%AA%E9%87%8C%E5%A3%B0%E6%98%8E%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B0%B1%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">1.1.</span> <span class="toc-text">变量在哪里声明，这个变量的作用域就在哪里</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AE%9E%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">第六章 实数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC%E6%9D%A5%E5%88%A4%E6%96%AD%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">使用两个数的差的绝对值来判断浮点数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%A4%A7%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">第八章 大数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#big%E5%8C%85%E4%B8%8Econst%E6%97%A0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">big包与const无类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AD%97%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">第九章 字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">第十章 类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">第十四章 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">6.1.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E5%88%87%E7%89%87"><span class="toc-number">7.</span> <span class="toc-text">第十六章 切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E6%9B%B4%E5%A4%A7%E7%9A%84%E5%88%87%E7%89%87"><span class="toc-number">8.</span> <span class="toc-text">第十八章 更大的切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%B4%A2%E5%BC%95%E5%88%87%E5%88%86"><span class="toc-number">8.1.</span> <span class="toc-text">三索引切分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0-Go%E6%B2%A1%E6%9C%89%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">第二十二章 Go没有类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E5%B8%B8%E9%87%8F%E5%B0%81%E8%A3%85%E6%88%90%E4%B8%80%E4%B8%AAstruct"><span class="toc-number">9.1.</span> <span class="toc-text">把常量封装成一个struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">go的工厂模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0-%E7%BB%84%E5%90%88%E4%B8%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">10.</span> <span class="toc-text">第二十三章 组合与转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B6%E5%B1%82struct%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%90%8C%E5%90%8D%E7%9A%84%E5%91%BD%E5%90%8D%EF%BC%8C%E5%8E%BB%E8%A6%86%E7%9B%96%E6%8E%89%E5%BA%95%E5%B1%82struct%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.1.</span> <span class="toc-text">在顶层struct实现一个同名的命名，去覆盖掉底层struct的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97struct%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.</span> <span class="toc-text">嵌套struct的初始化方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.</span> <span class="toc-text">第二十四章 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%A7%86%E4%B8%BA%E9%99%90%E5%AE%9A%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%B7%E6%9C%89%E5%8F%98%E5%BD%A2%E5%8A%9F%E8%83%BD%E7%9A%84stuct"><span class="toc-number">11.1.</span> <span class="toc-text">把接口类型，视为限定条件的具有变形功能的stuct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A5%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">11.2.</span> <span class="toc-text">接口类型作为函数的入参和返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%87%BD%E6%95%B0%E7%9A%84struct%E5%85%A5%E5%8F%82%E6%94%B9%E6%88%90interface"><span class="toc-number">11.3.</span> <span class="toc-text">将函数的struct入参改成interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface-%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.4.</span> <span class="toc-text">interface{} 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-interface"><span class="toc-number">11.5.</span> <span class="toc-text">理解[]interface{}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%BD%AC%E4%B8%BA%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">11.6.</span> <span class="toc-text">接口转为具体类型：类型断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%8C%87%E9%92%88"><span class="toc-number">12.</span> <span class="toc-text">第二十六章 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E9%97%B4%E6%8E%A5%E6%94%B9%E5%8F%98%E5%80%BC"><span class="toc-number">12.1.</span> <span class="toc-text">解引用间接改变值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%92%8C%E5%88%87%E7%89%87%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E6%8C%87%E9%92%88"><span class="toc-number">12.2.</span> <span class="toc-text">映射和切片本身就是指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%BB%A1%E8%B6%B3%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.3.</span> <span class="toc-text">指针满足接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E7%AB%A0-nil"><span class="toc-number">13.</span> <span class="toc-text">第二十七章 nil</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nil%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.1.</span> <span class="toc-text">nil接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-error"><span class="toc-number">14.</span> <span class="toc-text">第二十八章 error</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#panic"><span class="toc-number">14.1.</span> <span class="toc-text">panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer%E6%B3%A8%E6%84%8F"><span class="toc-number">14.2.</span> <span class="toc-text">defer注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9Aerrors-are-values-%E5%88%9B%E9%80%A0%E6%80%A7%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">14.3.</span> <span class="toc-text">重点：errors are values 创造性的错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="toc-number">14.4.</span> <span class="toc-text">常用的自定义错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E7%AB%A0-goroutine%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">15.</span> <span class="toc-text">第三十章 goroutine和并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chan%E5%AE%8C%E6%95%B4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A4%BA%E4%BE%8B"><span class="toc-number">15.1.</span> <span class="toc-text">chan完整流水线示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%8A%B6%E6%80%81"><span class="toc-number">16.</span> <span class="toc-text">第三十一章 并发状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%EF%BC%9A%E5%B0%86%E4%BA%92%E6%96%A5%E9%94%81%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%B1%9E%E6%80%A7"><span class="toc-number">16.1.</span> <span class="toc-text">重要：将互斥锁作为结构体属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84groutine%E7%A4%BA%E4%BE%8B"><span class="toc-number">16.2.</span> <span class="toc-text">一个完整的groutine示例</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="第四章-变量作用域"><a href="#第四章-变量作用域" class="headerlink" title="第四章 变量作用域"></a>第四章 变量作用域</h2><h3 id="变量在哪里声明，这个变量的作用域就在哪里"><a href="#变量在哪里声明，这个变量的作用域就在哪里" class="headerlink" title="变量在哪里声明，这个变量的作用域就在哪里"></a>变量在哪里声明，这个变量的作用域就在哪里</h3><blockquote>
<p>声明变量的位置，决定了变量所处的作用域：</p>
<p>也就是说，<strong>变量在哪里声明，这个变量的作用域就在哪里。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> count &lt; <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">    fmt.Println(num)</span><br><span class="line">    count++</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fmt.Println(count) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，因为count在main函数中定义，所以能打印10</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> count := <span class="number">0</span>; count &lt;= <span class="number">10</span>; count++ &#123;</span><br><span class="line">    fmt.Println(count)</span><br><span class="line">  &#125;	</span><br><span class="line"></span><br><span class="line">  fmt.Println(count) <span class="comment">// error: undefined:count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for count := 0; count &lt;= 10; count++ &#123;&#125;</code>这段代码，属于<strong>在for循环中</strong>定义变量count，也就是说，count变量的定义位置不是在main函数中，所以打印失败。</p>
<p>同理<strong>在if中定义变量err</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := someFuncReturnBool(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(err) <span class="comment">// error</span></span><br></pre></td></tr></table></figure>



<h2 id="第六章-实数"><a href="#第六章-实数" class="headerlink" title="第六章 实数"></a>第六章 实数</h2><h3 id="使用两个数的差的绝对值来判断浮点数"><a href="#使用两个数的差的绝对值来判断浮点数" class="headerlink" title="使用两个数的差的绝对值来判断浮点数"></a>使用两个数的差的绝对值来判断浮点数</h3><p>因为浮点数计算有误差，我们一般不会直接判断两个浮点数是否相等来判断，而是使用<strong>两个数的差的绝对值来进行判断</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">0.1</span></span><br><span class="line">b := <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a+b == <span class="number">0.3</span>) <span class="comment">// false</span></span><br><span class="line">fmt.Println(math.Abs(a+b<span class="number">-0.3</span>) &lt; <span class="number">0.000001</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="第八章-大数"><a href="#第八章-大数" class="headerlink" title="第八章 大数"></a>第八章 大数</h2><p>整数和浮点数的优缺点</p>
<ul>
<li>浮点数可以存储任意大小的数字，但是不精确</li>
<li>整数可以存储精确的数字，但是有取值范围，超出取值范围就会出现<code>整数回绕</code></li>
</ul>
<h3 id="big包与const无类型"><a href="#big包与const无类型" class="headerlink" title="big包与const无类型"></a>big包与const无类型</h3><p>big包：提供<strong>巨大且精确的数字</strong></p>
<ul>
<li>big.Int</li>
<li>big.Float</li>
<li>big.Rat：分数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := big.NewInt(<span class="number">123123131</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过string来设置</span></span><br><span class="line">a := <span class="built_in">new</span>(big.Int)</span><br><span class="line">a.SetString(<span class="string">&quot;1098766666666666&quot;</span>,<span class="number">10</span>) <span class="comment">// a为：十进制的1098766666666666</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>编译器在编译const时，不会推断类型，所以const是<strong>无类型</strong>的，所以const能暂时保持精度。</p>
</li>
<li><p>为什么const不会推断类型，是无类型的？</p>
<blockquote>
<p>因为编译器就是使用GO写的，而编译器在底层对const定义的变量使用了big.Int作为支持。也就是说const在编译期间其实就是big.Int类型。</p>
<p>因为big.Int的速度比较慢，这也就解释了为什么GO编译比较慢。</p>
</blockquote>
</li>
<li><p>无类型常量在被用作函数参数的时候，必须转换为有类型常量。</p>
</li>
</ul>
<h2 id="第九章-字符"><a href="#第九章-字符" class="headerlink" title="第九章 字符"></a>第九章 字符</h2><ul>
<li>rune：字符</li>
<li>string：字符串</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&#x27;A&#x27;</span> <span class="comment">// A被推断为rune</span></span><br><span class="line">b := <span class="string">&quot;A&quot;</span> <span class="comment">// A被推断为string</span></span><br></pre></td></tr></table></figure>



<p>RuneCountInString能以符文而不是以字节为单位返回字符串的长度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length := utf8.RuneCountInString(<span class="string">&quot;何应良&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>也就是说，range迭代string其实就是<strong>一边迭代一边解码utf8</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, char := <span class="keyword">range</span> <span class="string">&quot;何应良&quot;</span> &#123;</span><br><span class="line">  fmt.Println(char) <span class="comment">// 何 应 良</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第十章-类型转换"><a href="#第十章-类型转换" class="headerlink" title="第十章 类型转换"></a>第十章 类型转换</h2><p>num转为string：</p>
<ul>
<li>使用Itoa</li>
<li>使用Sprintf</li>
</ul>
<blockquote>
<p>Itoa：是<code>integer to ascii</code>的缩写</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countdown := <span class="number">10</span></span><br><span class="line">str1 := strconv.Itoa(countdown) <span class="comment">// &quot;10&quot;</span></span><br><span class="line">str2 := fmt.Sprintf(<span class="string">&quot;v&quot;</span>,countdown)</span><br></pre></td></tr></table></figure>



<p>string转为num：</p>
<ul>
<li>使用Atoi</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countdown, err := strconv.Atoi(<span class="string">&quot;10&quot;</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>strconv这个包就是用于string的类型转换：其他类型转为string，或者string转为其他类型</p>
</blockquote>
<h2 id="第十四章-函数"><a href="#第十四章-函数" class="headerlink" title="第十四章 函数"></a>第十四章 函数</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>闭包：匿名函数<strong>封闭并包围</strong>作用域中的变量</li>
<li>闭包保留的是周围变量的<strong>引用</strong>而不是副本值</li>
</ul>
<blockquote>
<p>简单来讲，闭包就是：一个函数<strong>引用</strong>了函数外部的变量（注意这里是<strong>引用</strong>，不是副本值）</p>
</blockquote>
<h2 id="第十六章-切片"><a href="#第十六章-切片" class="headerlink" title="第十六章 切片"></a>第十六章 切片</h2><p>简单来讲：</p>
<ul>
<li><p><strong>go的可变对象有：指针、slice切片、map、管道chan、interface</strong></p>
</li>
<li><p>改变切片的某个索引的数据值 , 本质就是<code>通过指针强制修改底层数组的值</code></p>
</li>
<li><p>string和slice的关系：string底层是一个数组</p>
</li>
</ul>
<p>两种初始化并赋值slice的方式</p>
<ul>
<li>定义nil slice</li>
<li>使用make定义空slice</li>
</ul>
<figure class="highlight go"><figcaption><span>p</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr1 []<span class="keyword">string</span></span><br><span class="line">	arr1 = <span class="built_in">append</span>(arr1, <span class="string">&quot;qwe&quot;</span>)</span><br><span class="line">	fmt.Println(arr1)</span><br><span class="line"></span><br><span class="line">	arr2 := <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">1</span>)</span><br><span class="line">	arr2[<span class="number">0</span>] = <span class="string">&quot;qwe&quot;</span></span><br><span class="line">	fmt.Println(arr2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>make的作用：用于为变量分配内存空间</p>
</blockquote>
<h2 id="第十八章-更大的切片"><a href="#第十八章-更大的切片" class="headerlink" title="第十八章 更大的切片"></a>第十八章 更大的切片</h2><h3 id="三索引切分"><a href="#三索引切分" class="headerlink" title="三索引切分"></a>三索引切分</h3><blockquote>
<p>目的不是增加容量，而是要限制容量</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(newSlice)      <span class="comment">// [3]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(newSlice)) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(newSlice)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>第一个值是开始的索引位置。开始索引位置+希望包括的元素个数，得到第二个值(2+1=3)</li>
<li>第三个值是希望容量包含的元素个数(2+2=4)，所以这个切片的长度是1，容量是2.(简单来说<code>第三个值减去第一个值</code>就是容量)</li>
</ul>
<blockquote>
<p>除非特意要覆盖底层数组，那么一般都要使用<code>三索引切分</code></p>
</blockquote>
<h2 id="第二十二章-Go没有类"><a href="#第二十二章-Go没有类" class="headerlink" title="第二十二章 Go没有类"></a>第二十二章 Go没有类</h2><h3 id="把常量封装成一个struct"><a href="#把常量封装成一个struct" class="headerlink" title="把常量封装成一个struct"></a>把常量封装成一个struct</h3><ul>
<li>go其实很少使用常量，特别是全局的变量/变量，一般都会把这些常量封装成一个struct</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般都不会单独定义</span></span><br><span class="line"><span class="keyword">const</span> marsRadius = <span class="number">3389.5</span> <span class="comment">// 定义火星半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般都会定义成一个struct</span></span><br><span class="line"><span class="keyword">type</span> World <span class="keyword">struct</span> &#123;</span><br><span class="line">  redius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mars = World&#123;radius:<span class="number">3389.5</span>&#125;</span><br><span class="line">fmt.Println(mars.redius)</span><br></pre></td></tr></table></figure>



<h3 id="go的工厂模式"><a href="#go的工厂模式" class="headerlink" title="go的工厂模式"></a>go的工厂模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Student&#123;name, age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	s.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := NewStudent(<span class="string">&quot;heyingliang&quot;</span>, <span class="number">21</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第二十三章-组合与转发"><a href="#第二十三章-组合与转发" class="headerlink" title="第二十三章 组合与转发"></a>第二十三章 组合与转发</h2><h3 id="在顶层struct实现一个同名的命名，去覆盖掉底层struct的实现"><a href="#在顶层struct实现一个同名的命名，去覆盖掉底层struct的实现" class="headerlink" title="在顶层struct实现一个同名的命名，去覆盖掉底层struct的实现"></a>在顶层struct实现一个同名的命名，去覆盖掉底层struct的实现</h3><p>当struct内部嵌套的子struct们发生命名冲突的时候，可以<strong>在顶层struct实现一个同名的命名，去覆盖掉底层struct的实现</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span> <span class="title">getName</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">getName</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> b.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">  A</span><br><span class="line">  B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖底层struct实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *C)</span> <span class="title">getName</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c.A.getName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="嵌套struct的初始化方法"><a href="#嵌套struct的初始化方法" class="headerlink" title="嵌套struct的初始化方法"></a>嵌套struct的初始化方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHuman</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Human</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Human&#123;name, age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">GetHumanName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SetHumanName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	h.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello , my name is&quot;</span>, h.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖Human的sayHello方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello222 , my name is&quot;</span>, s.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意: 不可使用s := &amp;Student&#123;&quot;heyingliang&quot;,21&#125;</span></span><br><span class="line">	s := &amp;Student&#123;&#125;</span><br><span class="line">	s.SetHumanName(<span class="string">&quot;heyingliang&quot;</span>)</span><br><span class="line">	s.Age = <span class="number">21</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	s.sayHello()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在创建结构体变量（实例）时，直接指定各个匿名结构体字段的值</span></span><br><span class="line">  s2 := &amp;Student&#123;Human&#123;Name: <span class="string">&quot;heyingliang&quot;</span>, Age: <span class="number">21</span>&#125;&#125;</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第二十四章-接口"><a href="#第二十四章-接口" class="headerlink" title="第二十四章 接口"></a>第二十四章 接口</h2><h3 id="把接口类型，视为限定条件的具有变形功能的stuct"><a href="#把接口类型，视为限定条件的具有变形功能的stuct" class="headerlink" title="把接口类型，视为限定条件的具有变形功能的stuct"></a>把接口类型，视为限定条件的具有变形功能的stuct</h3><blockquote>
<p>最重要的一点：把接口视为struct</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Animal 为任何具有 Speak 方法的类型。</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>var是定义变量</li>
<li>type是定义类型</li>
</ul>
<p><code>var S Student</code>和<code>type S Student</code>的区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义变量：定一个student类型的变量，其结果是S</span></span><br><span class="line"><span class="keyword">var</span> S Student</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类型：给Student这个struct取一个别名，其结果是S</span></span><br><span class="line"><span class="keyword">type</span> S Student</span><br></pre></td></tr></table></figure>

<p><code>var t interface&#123;&#125;</code>和<code>type t interface</code>的区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变量：定一个interface&#123;talk() string&#125;类型的变量，其结果是t1</span></span><br><span class="line"><span class="comment">// 从结论上说：t1就是一个限定条件的具有变换类型功能的变量（任何只要是实现了talk()的变量，都可以赋值给t1）</span></span><br><span class="line"><span class="keyword">var</span> t1 <span class="keyword">interface</span> &#123;</span><br><span class="line">  talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类型：给 interface&#123;talk() string&#125; 这个struct取一个别名，其结果是t2</span></span><br><span class="line"><span class="comment">// 从结论上说：t2就是一个限定条件的具有变换类型功能的类型（任何只要是实现了talk()的类型，都可以赋值给t2）</span></span><br><span class="line"><span class="keyword">type</span> t2 <span class="keyword">interface</span> &#123;</span><br><span class="line">  talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t是就是一个具备变形功能的变量</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span> &#123;</span><br><span class="line">  talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>任何类型的任何值，只要是实现了talk()，那么<strong>他就可以是变量t的值</strong>，也就是说他可以被赋值给变量t。</li>
<li>所以说，<strong>变量t具备变形功能</strong>。接口通过多态让变量t具备了多种形态。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>因为任何类型的任何值，都实现了无函数，所以他可以是变量a的值。因为变量a其实就是interface{}，所以任何东西都可以是<code>变量interface&#123;&#125;的值</code></p>
<p>为了复用，一般我们都把接口定义成类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类型: talker</span></span><br><span class="line"><span class="comment">// 接口一般以`-er`结尾，如`talker`，`writer`</span></span><br><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">	talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> martian <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *martian)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hyl&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// martian&#123;&#125;可以被赋值给变量t</span></span><br><span class="line">t = martian&#123;&#125;</span><br><span class="line">fmt.Println(t.talk())</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：</p>
<p>对于接口类型talker</p>
<ul>
<li><p>只要是实现了talk方法的任何值，都可以被赋予类型talker。</p>
</li>
<li><p>interface{}类型其实就是一个struct类型，空接口<code>interface&#123;&#125;</code> 没有任何方法 , 所以所有类型都实现了空接口 , 即<strong>我们可以把任何一个变量赋给空接口</strong></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">	talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要是实现了talk方法的任何值V，都可以被赋值给变量t</span></span><br><span class="line"><span class="comment">// 因此t可以作为shout的形参，用于接收V</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">  louder := <span class="keyword">string</span>.ToUpper(t.talk())</span><br><span class="line">  fmt.Println(louder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结论：</p>
<p>就像下面的talker接口类型，我们可以<strong>把接口类型，视为限定条件的具有变形功能的stuct</strong>。这里的<code>限定条件</code>就是这个struct必须实现对应的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">	talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="接口类型作为函数的入参和返回值"><a href="#接口类型作为函数的入参和返回值" class="headerlink" title="接口类型作为函数的入参和返回值"></a>接口类型作为函数的入参和返回值</h3><p>既然接口类型是stuct，那么就可以作为函数的形参传入，也可以作为函数的返回值返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// working方法的形参是usb接口类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Usb接口声明了两个没有实现的方法</span></span><br><span class="line">	start()</span><br><span class="line">	stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// Phone实现了Usb接口的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机接入usb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;手机拔出usb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Camera)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机接入usb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Camera)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;相机拔出usb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// working方法接收一个Usb接口类型变量</span></span><br><span class="line"><span class="comment">// 所谓的思想Usb接口,就是指 实现了Usb接口的所有方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Computer)</span> <span class="title">working</span><span class="params">(usb Usb)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;== start ==&quot;</span>)</span><br><span class="line">	usb.start() <span class="comment">// 通过Usb接口变量来调用Start和Stop方法</span></span><br><span class="line">	usb.stop()</span><br><span class="line">	fmt.Println(<span class="string">&quot;== stop ==&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	computer := &amp;Computer&#123;&#125;</span><br><span class="line">	phone := &amp;Phone&#123;&#125;</span><br><span class="line">	camera := &amp;Camera&#123;&#125;</span><br><span class="line">	computer.working(phone)</span><br><span class="line">	computer.working(camera)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类型作为函数的返回值返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">	area() <span class="keyword">float64</span></span><br><span class="line">	circumference() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体正方形，属性边长</span></span><br><span class="line"><span class="keyword">type</span> square <span class="keyword">struct</span> &#123;</span><br><span class="line">	length <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法area，由正方形结构体实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *square)</span> <span class="title">area</span><span class="params">()</span>  <span class="title">float64</span></span> &#123;</span><br><span class="line">	sarea := s.length * s.length</span><br><span class="line">	<span class="keyword">return</span> sarea</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法circumference，由正方形结构体实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *square)</span> <span class="title">circumference</span><span class="params">()</span>  <span class="title">float64</span></span> &#123;</span><br><span class="line">	scircumference := s.length * <span class="number">4</span></span><br><span class="line">	<span class="keyword">return</span> scircumference</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getarea</span><span class="params">(<span class="built_in">len</span> <span class="keyword">float64</span>)</span> <span class="title">Shape</span></span> &#123;</span><br><span class="line">	s := &amp;square&#123;</span><br><span class="line">		length:<span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;正方形的面积为：&quot;</span>,s.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;正方形的周长为：&quot;</span>,s.circumference())</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="将函数的struct入参改成interface"><a href="#将函数的struct入参改成interface" class="headerlink" title="将函数的struct入参改成interface"></a>将函数的struct入参改成interface</h3><p>既然接口类型是struct，那么我们就可以将函数的struct参数改成interface，使得<strong>函数更加通用</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Time这个struct作为函数的入参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StarData</span><span class="params">(t time.Time)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  day := <span class="keyword">float64</span>(t.YesterDay())</span><br><span class="line">  h := <span class="keyword">float64</span>(t.Hour()) / <span class="number">24.0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span> + day + h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span></span> &#123;</span><br><span class="line">  day := time.Date(<span class="number">2020</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,time.UTC)</span><br><span class="line">  fmt.Println(StarData(day))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用接口类型代替其他类型</span></span><br><span class="line"><span class="keyword">type</span> StarDater <span class="keyword">interface</span> &#123;</span><br><span class="line">  YesterDay() <span class="keyword">int</span></span><br><span class="line">  Hour() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅仅只是修改函数的入参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StarData</span><span class="params">(t StarDater)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  day := <span class="keyword">float64</span>(t.YesterDay())</span><br><span class="line">  h := <span class="keyword">float64</span>(t.Hour()) / <span class="number">24.0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span> + day + h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="interface-类型"><a href="#interface-类型" class="headerlink" title="interface{} 类型"></a><code>interface&#123;&#125;</code> 类型</h3><p><code>interface&#123;&#125;</code> 类型，<strong>空接口</strong>，是导致很多混淆的根源。<code>interface&#123;&#125;</code> 类型是没有方法的接口。由于没有 <code>implements</code> 关键字，所以所有类型都至少实现了 0 个方法，所以 <strong>所有类型都实现了空接口</strong>。这意味着，如果您编写一个函数以 <code>interface&#123;&#125;</code> 值作为参数，那么您可以为该函数提供任何值。</p>
<p>先来看这个玩意：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Llama <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Llama)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;?????&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> JavaProgrammer <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j JavaProgrammer)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Design patterns!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInterface</span><span class="params">(animals []Animal)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 不管你传入的是Dog，Cat，Llama还是JavaProgrammer，a都是animal类型</span></span><br><span class="line">  <span class="comment">// animals的元素都是 Animal 类型，但是他们的底层类型却不相同。</span></span><br><span class="line">	<span class="keyword">for</span> _, a := <span class="keyword">range</span> animals &#123;</span><br><span class="line">		fmt.Println(a.Speak())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;, Llama&#123;&#125;, JavaProgrammer&#123;&#125;&#125;</span><br><span class="line">	test_go.TestInterface(animals)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 <code>DoSomething</code> 函数内部，<code>v</code> 的类型是什么？<strong>新手们会认为 <code>v</code> 是任意类型的，但这是错误的。<code>v</code> 是 <code>interface&#123;&#125;</code> 类型。</strong></p>
</li>
<li><p>当将值传递给<code>DoSomething</code> 函数时，<strong>Go 运行时将执行类型转换(如果需要)，并将值转换为 <code>interface&#123;&#125;</code> 类型的值。</strong>所有值在运行时只有一个类型，而 <code>v</code> 的一个静态类型是 <code>interface&#123;&#125;</code> 。</p>
<blockquote>
<p>一个接口值由两个字（32 位机器一个字是 32 bits，64 位机器一个字是 64 bits）组成；</p>
<p>一个字用于指向该值底层类型的方法表，另一个字用于指向实际数据。</p>
</blockquote>
</li>
</ul>
<h3 id="理解-interface"><a href="#理解-interface" class="headerlink" title="理解[]interface{}"></a>理解[]interface{}</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintAll</span><span class="params">(vals []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        fmt.Println(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    names := []<span class="keyword">string</span>&#123;<span class="string">&quot;stanley&quot;</span>, <span class="string">&quot;david&quot;</span>, <span class="string">&quot;oscar&quot;</span>&#125;</span><br><span class="line">    PrintAll(names) <span class="comment">// error：cannot use names (type []string) as type []interface &#123;&#125; in argument to PrintAll</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个错误说明 go 没有帮助我们自动把 string的slice 转换成 <code>interface&#123;&#125;</code> 类型的 slice，所以出错了。</li>
<li>go 不会对 类型是<code>interface&#123;&#125;</code> 的 slice 进行转换 。为什么 go 不帮我们自动转换，在 go 的 wiki 中找到了答案 <a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/InterfaceSlice">https://github.com/golang/go/wiki/InterfaceSlice</a> </li>
<li>大意是 <code>interface&#123;&#125;</code> 会占用两个字长的存储空间，一个是自身的 methods 数据，一个是指向其存储值的指针，也就是 interface 变量存储的值，因而 **slice []interface{} 其长度是固定的<code>N*2</code>**，但是 []MyType的长度是<code>N*sizeof(MyType)</code>，两种 slice 实际存储值的大小是有区别的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []<span class="keyword">int</span> = foo()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接口转为具体类型：类型断言"><a href="#接口转为具体类型：类型断言" class="headerlink" title="接口转为具体类型：类型断言"></a>接口转为具体类型：类型断言</h3><ul>
<li>由于接口是一般类型，不知道具体类型，如果要<strong>将一般类型转成具体类型</strong>，就需要使用类型断言</li>
<li><code>x.(T)</code> 检查x的动态类型是否是T，其中x必须是接口值。</li>
<li>类型断言的本质，跟类型转换类似，都是类型之间进行转换，不同之处在于，<strong>类型断言是在接口之间进行</strong></li>
</ul>
<h2 id="第二十六章-指针"><a href="#第二十六章-指针" class="headerlink" title="第二十六章 指针"></a>第二十六章 指针</h2><p>指针配合数组和结构体最为有用。</p>
<h3 id="解引用间接改变值"><a href="#解引用间接改变值" class="headerlink" title="解引用间接改变值"></a>解引用间接改变值</h3><p>警戒这种<strong>指针取值出现在等号左边的情况</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> admin *<span class="keyword">string</span></span><br><span class="line">	name := <span class="string">&quot;hyl&quot;</span></span><br><span class="line">	admin = &amp;name</span><br><span class="line">	fmt.Println(*admin) <span class="comment">// hyl</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// *admin表示：指针取值</span></span><br><span class="line">	*admin = <span class="string">&quot;asd&quot;</span></span><br><span class="line">	fmt.Println(name) <span class="comment">// asd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="映射和切片本身就是指针"><a href="#映射和切片本身就是指针" class="headerlink" title="映射和切片本身就是指针"></a>映射和切片本身就是指针</h3><ul>
<li>映射的键可能是指针，值可能是指针</li>
<li>但是映射本身不需要使用指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(m *<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为映射本身就是指针,并不需要对映射本身使用*</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，一般我们都不会给切片添加指针</span></span><br><span class="line"><span class="comment">// 除非你想修改的是切片本身</span></span><br></pre></td></tr></table></figure>



<h3 id="指针满足接口"><a href="#指针满足接口" class="headerlink" title="指针满足接口"></a>指针满足接口</h3><p>如果类型的非指针版本满足接口，那么他的指针版本也能满足</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> talker <span class="keyword">interface</span> &#123;</span><br><span class="line">  talk() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shout</span><span class="params">(t talker)</span></span> &#123;</span><br><span class="line">  louder := strings.ToUpper(t.talk())</span><br><span class="line">  fmt.Println(louder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> laser <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(l *laser)</span> <span class="title">talk</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> strings.Repeat(<span class="string">&quot;pew&quot;</span>, <span class="keyword">int</span>(*l))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pew := laser(<span class="number">2</span>)</span><br><span class="line">  shout(&amp;pew) <span class="comment">// PEW PEW</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第二十七章-nil"><a href="#第二十七章-nil" class="headerlink" title="第二十七章 nil"></a>第二十七章 nil</h2><h3 id="nil接口"><a href="#nil接口" class="headerlink" title="nil接口"></a>nil接口</h3><p><strong>接口类型的变量只有在类型和值都为nil的时候才等于nil</strong>，所以，即使接口变量的值为nil，但是他的类型不为nil，则该变量就不等于nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v值为nil，类型不为nil</span></span><br><span class="line"><span class="comment">// v始终不为nil</span></span><br><span class="line">fmt.Println(v == <span class="literal">nil</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<h2 id="第二十八章-error"><a href="#第二十八章-error" class="headerlink" title="第二十八章 error"></a>第二十八章 error</h2><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><ul>
<li>go在编译期间会检查很多种错误，但是有些错误是在运行时检查的，如数组越界，空指针引用。这些错误就会引发panic异常。</li>
<li>也就是说，除非程序员手动引发panic异常，其他的<strong>panic异常都是运行时错误</strong>。</li>
</ul>
<h3 id="defer注意"><a href="#defer注意" class="headerlink" title="defer注意"></a>defer注意</h3><ul>
<li>defer的执行时机：<strong>函数返回前执行</strong></li>
<li>defer函数的参数会立马确定。即defer函数的参数是传入值，不是传入引用。</li>
</ul>
<h3 id="重点：errors-are-values-创造性的错误处理"><a href="#重点：errors-are-values-创造性的错误处理" class="headerlink" title="重点：errors are values 创造性的错误处理"></a>重点：errors are values 创造性的错误处理</h3><p><strong>将err作为struct的字段</strong></p>
<p>经常用于<code>会重复调用的函数</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> safeWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">  w io.Writer</span><br><span class="line">  err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sw *safeWriter)</span> <span class="title">Writeln</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> sw.err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  _, sw.err = fmt.Fprintln(sw.w, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myWriter</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  f, err := os.Create(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  sw := safeWriter&#123;w: f&#125;</span><br><span class="line">  sw.Writeln(<span class="string">&quot;11111&quot;</span>)</span><br><span class="line">  sw.Writeln(<span class="string">&quot;22222&quot;</span>) <span class="comment">//若sw.err != nil,下面全部的sw.Writenln都会直接return，直到最后myWriter的return</span></span><br><span class="line">  sw.Writeln(<span class="string">&quot;33333&quot;</span>)</span><br><span class="line">  sw.Writeln(<span class="string">&quot;44444&quot;</span>)</span><br><span class="line">  <span class="comment">// 如果有错误，将其返回</span></span><br><span class="line">  <span class="keyword">return</span> sw.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常用的自定义错误"><a href="#常用的自定义错误" class="headerlink" title="常用的自定义错误"></a>常用的自定义错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  ErrBounds = errors.<span class="built_in">new</span>(<span class="string">&quot;out of bounds&quot;</span>)</span><br><span class="line">  ErrDigit = errors.New(<span class="string">&quot;invalid digit&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>全局常量/变量定义使用大驼峰，而不是python的大写加下划线</li>
<li>一般都以Err开头</li>
</ul>
<h2 id="第三十章-goroutine和并发"><a href="#第三十章-goroutine和并发" class="headerlink" title="第三十章 goroutine和并发"></a>第三十章 goroutine和并发</h2><h3 id="chan完整流水线示例"><a href="#chan完整流水线示例" class="headerlink" title="chan完整流水线示例"></a>chan完整流水线示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">source</span><span class="params">(downsteam <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">string</span>&#123;<span class="string">&quot;q&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		downsteam &lt;- v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(downsteam)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(upsteam, downstream <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// range命令会一直执行，直到upsteam被关闭</span></span><br><span class="line">	<span class="keyword">for</span> item := <span class="keyword">range</span> upsteam &#123;</span><br><span class="line">		<span class="keyword">if</span> item != <span class="string">&quot;w&quot;</span> &#123;</span><br><span class="line">			downstream &lt;- item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="built_in">close</span>(downstream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(upsteam <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> upsteam &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c0 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> source(c0)</span><br><span class="line">	<span class="keyword">go</span> filter(c0, c1)</span><br><span class="line">	<span class="built_in">print</span>(c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第三十一章-并发状态"><a href="#第三十一章-并发状态" class="headerlink" title="第三十一章 并发状态"></a>第三十一章 并发状态</h2><h3 id="重要：将互斥锁作为结构体属性"><a href="#重要：将互斥锁作为结构体属性" class="headerlink" title="重要：将互斥锁作为结构体属性"></a>重要：将互斥锁作为结构体属性</h3><p>一般使用互斥锁是作为全局变量，不太好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般使用互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  <span class="comment">// 其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将互斥锁作为结构体属性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Visited <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line">  <span class="comment">// mu用于保护map</span></span><br><span class="line">  visited <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(v *Visited)</span> <span class="title">VisiteLink</span><span class="params">(url <span class="keyword">string</span>)</span><span class="title">int</span></span> &#123;</span><br><span class="line">  v.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> v.mu.Unlock()</span><br><span class="line">  <span class="comment">// 其他操作，比如操作map:</span></span><br><span class="line">  v.visited[<span class="string">&quot;count&quot;</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一个完整的groutine示例"><a href="#一个完整的groutine示例" class="headerlink" title="一个完整的groutine示例"></a>一个完整的groutine示例</h3><p>使用goroutine的for select循环代替python中的事件循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> command <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  right = command(<span class="number">0</span>)</span><br><span class="line">  left = command(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RoverDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">  command <span class="keyword">chan</span> command</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRoverDriver</span><span class="params">()</span> *<span class="title">RoverDriver</span></span> &#123;</span><br><span class="line">  r := &amp;RoverDriver&#123;</span><br><span class="line">    command: <span class="built_in">make</span>(<span class="keyword">chan</span> command),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">go</span> r.drive()</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">drive</span><span class="params">()</span></span> &#123;</span><br><span class="line">  updateInterval := <span class="number">250</span> * time.Millsecond</span><br><span class="line">  nextMove := time.After(updateInterval)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> c := &lt;- r.command:</span><br><span class="line">        <span class="keyword">switch</span> c &#123;</span><br><span class="line">          <span class="keyword">case</span> right:</span><br><span class="line">          	<span class="comment">// 向右转</span></span><br><span class="line">          <span class="keyword">case</span> left :</span><br><span class="line">          	<span class="comment">// 向左转</span></span><br><span class="line">          &#125;</span><br><span class="line">      <span class="keyword">case</span> &lt;- nextMove:</span><br><span class="line">        <span class="comment">// 向前走</span></span><br><span class="line">        nextMove = time.After(updateInterval)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Left</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r.command &lt;- left</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RoverDriver)</span> <span class="title">Right</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r.command &lt;- right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r := NewRoverDriver()</span><br><span class="line">  r.Left()</span><br><span class="line">  r.Right()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>