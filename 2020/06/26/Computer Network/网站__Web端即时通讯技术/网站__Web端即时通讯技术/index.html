<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="地址"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Web端即时通讯技术 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Computer-Network/" rel="tag">Computer Network</a></div><div class="post-time">2020-06-26</div></div></div><div class="container post-header"><h1>Web端即时通讯技术</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Web%E7%AB%AF%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF%E7%9B%98%E7%82%B9%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81Comet%E3%80%81Websocket%E3%80%81SSE"><span class="toc-number">1.</span> <span class="toc-text">Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax%E7%9F%AD%E8%BD%AE%E8%AF%A2%EF%BC%9A%E8%84%9A%E6%9C%AC%E5%8F%91%E9%80%81%E7%9A%84http%E8%AF%B7%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">Ajax短轮询：脚本发送的http请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comet%EF%BC%9A%E4%B8%80%E7%A7%8Dhack%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.</span> <span class="toc-text">Comet：一种hack技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAjax%E7%9A%84%E9%95%BF%E8%BD%AE%E8%AF%A2%EF%BC%88long-polling%EF%BC%89%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">基于Ajax的长轮询（long-polling）方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-Iframe-%E5%8F%8A-htmlfile-%E7%9A%84%E6%B5%81%EF%BC%88http-streaming%EF%BC%89%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">基于 Iframe 及 htmlfile 的流（http streaming）方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Websocket%EF%BC%9A%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881"><span class="toc-number">1.3.</span> <span class="toc-text">Websocket：未来的解决方案1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSE%EF%BC%9A%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882"><span class="toc-number">1.4.</span> <span class="toc-text">SSE：未来的解决方案2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SSE%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%B8%80%E7%A7%8D%E5%85%A8%E6%96%B0%E7%9A%84HTML5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E4%BA%8B%E4%BB%B6%E6%8A%80%E6%9C%AF"><span class="toc-number">2.</span> <span class="toc-text">SSE技术详解：一种全新的HTML5服务器推送事件技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">2.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.</span> <span class="toc-text">四种技术的基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8EWebSocket%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.4.</span> <span class="toc-text">与WebSocket的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSE%EF%BC%88Server-sent-Events%EF%BC%89%E5%9C%A8HTML-5%E4%B8%AD%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-number">2.5.</span> <span class="toc-text">SSE（Server-sent Events）在HTML 5中的技术规范和定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSE%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.</span> <span class="toc-text">SSE实战示例：服务器端和浏览器端实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text">技术参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF%E8%B5%84%E6%96%99%E5%88%86%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">即时通讯技术资料分类</span></a></li></ol></details></div><div class="container post-content"><p>地址</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/leftJS/p/11041410.html"><strong>SSE技术详解：一种全新的HTML5服务器推送事件技术</strong></a></p>
<p><strong>Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE</strong></p>
<h1 id="Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE"><a href="#Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE" class="headerlink" title="Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE"></a>Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE</h1><p>HTML5时代，为Web端即时通讯的实现带来了WebSocket和SSE（Server-sent Events）两种技术方案。</p>
<h2 id="Ajax短轮询：脚本发送的http请求"><a href="#Ajax短轮询：脚本发送的http请求" class="headerlink" title="Ajax短轮询：脚本发送的http请求"></a>Ajax短轮询：脚本发送的http请求</h2><ul>
<li>传统的web应用要想与服务器交互，必须提交一个表单（form），服务器接收并处理传来的表单，然后返回全新的页面，因为前后两个页面的数据大部分都是相同的，这个过程传输了很多冗余的数据、浪费了带宽。于是Ajax技术便应运而生。</li>
<li>Ajax是Asynchronous JavaScript and XML的简称，由Jesse James Garrett 首先提出。这种技术开创性地允许浏览器脚本（JS）发送http请求。</li>
<li>Ajax的出现使客户端与服务器端传输数据少了很多，也快了很多，也满足了以丰富用户体验为特点的web2.0时代初期发展的需要，但是慢慢地也暴露了他的弊端。比如无法满足即时通信等富交互式应用的实时更新数据的要求。这种浏览器端的小技术毕竟还是基于http协议，http协议要求的请求/响应的模式也是无法改变的，除非http协议本身有所改变。  </li>
</ul>
<h2 id="Comet：一种hack技术"><a href="#Comet：一种hack技术" class="headerlink" title="Comet：一种hack技术"></a>Comet：一种hack技术</h2><ul>
<li>基于<code>http长连接</code>的<code>服务器推</code>技术便被hack出来。这种技术被命名为<code>Comet</code></li>
<li>以下是典型的Ajax和Comet数据传输方式的对比，区别简单明了<ul>
<li>典型的Ajax通信方式也是http协议的经典使用方式，要想取得数据，必须首先发送请求。在低延迟要求比较高的web应用中，只能增加服务器请求的频率。</li>
<li>Comet则不同，客户端与服务器端保持一个长连接，只有客户端需要的数据更新时，服务器才主动将数据推送给客户端。  </li>
</ul>
</li>
</ul>
<p><img src="/images/145630p29lk0c9lgf32320.jpg" alt="Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE_2.jpg"></p>
<p>Comet的实现主要有两种方式</p>
<ul>
<li>基于Ajax的长轮询（long-polling）方式</li>
<li>基于 Iframe 及 htmlfile 的流（http streaming）方式。</li>
</ul>
<h3 id="基于Ajax的长轮询（long-polling）方式"><a href="#基于Ajax的长轮询（long-polling）方式" class="headerlink" title="基于Ajax的长轮询（long-polling）方式"></a>基于Ajax的长轮询（long-polling）方式</h3><p>浏览器发出XMLHttpRequest 请求，服务器端接收到请求后，会阻塞请求直到有数据或者超时才返回，浏览器JS在处理请求返回信息（超时或有效数据）后再次发出请求，重新建立连接。在此期间服务器端可能已经有新的数据到达，服务器会选择把数据保存，直到重新建立连接，浏览器会把所有数据一次性取回。</p>
<p><img src="/images/145816g98sb33ceq2669my.jpg" alt="Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE_3.jpg"></p>
<h3 id="基于-Iframe-及-htmlfile-的流（http-streaming）方式"><a href="#基于-Iframe-及-htmlfile-的流（http-streaming）方式" class="headerlink" title="基于 Iframe 及 htmlfile 的流（http streaming）方式"></a>基于 Iframe 及 htmlfile 的流（http streaming）方式</h3><ul>
<li>Iframe是html标记，这个标记的src属性会保持对指定服务器的长连接请求，服务器端则可以不停地返回数据，相对于第一种方式，这种方式跟传统的服务器推则更接近。</li>
<li>在第一种方式中，浏览器在收到数据后会直接调用JS回调函数，但是这种方式该如何响应数据呢？可以通过在返回数据中嵌入JS脚本的方式，如<code>&lt;script type=&quot;text/javascript&quot;&gt;js_func(“data from server ”)&lt;/script&gt;</code>，服务器端将返回的数据作为回调函数的参数，浏览器在收到数据后就会执行这段JS脚本。  </li>
</ul>
<p><img src="/images/145819wllzzlwr5ee5oq0v.jpg" alt="Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE_4.jpg"></p>
<h2 id="Websocket：未来的解决方案1"><a href="#Websocket：未来的解决方案1" class="headerlink" title="Websocket：未来的解决方案1"></a>Websocket：未来的解决方案1</h2><p>如果说Ajax的出现是互联网发展的必然，那么Comet技术的出现则更多透露出一种无奈，仅仅作为一种hack技术，因为没有更好的解决方案。Comet解决的问题应该由谁来解决才是合理的呢？浏览器，html标准，还是http标准？主角应该是谁呢？本质上讲，这涉及到数据传输方式，http协议应该是首选，是时候改变一下这个懒惰的协议的请求/响应模式了。</p>
<p>W3C给出了答案，在新一代html标准html5中提供了一种浏览器和服务器间进行全双工通讯的网络技术Websocket。从Websocket草案得知，Websocket是一个全新的、独立的协议，基于TCP协议，与http协议兼容、却不会融入http协议，仅仅作为html5的一部分。于是乎脚本又被赋予了另一种能力：发起websocket请求。这种方式我们应该很熟悉，因为Ajax就是这么做的，所不同的是，Ajax发起的是http请求而已。</p>
<p>与http协议不同的请求/响应模式不同，Websocket在建立连接之前有一个Handshake（Opening Handshake）过程，在关闭连接前也有一个Handshake（Closing Handshake）过程，建立连接之后，双方即可双向通信。</p>
<h2 id="SSE：未来的解决方案2"><a href="#SSE：未来的解决方案2" class="headerlink" title="SSE：未来的解决方案2"></a>SSE：未来的解决方案2</h2><p>SSE（Server-Sent Event，服务端推送事件）是一种允许服务端向客户端推送新数据的HTML5技术。与由客户端每隔几秒从服务端轮询拉取新数据相比，这是一种更优的解决方案。</p>
<p>与WebSocket相比，SSE有一些显著的优势。个人认为它最大的优势就是<strong>便利</strong>：不需要添加任何新组件，用任何你习惯的后端语言和框架就能继续使用。你不用为新建虚拟机、弄一个新的IP或新的端口号而劳神，就像在现有网站中新增一个页面那样简单。我喜欢把这称为既存基础设施优势。</p>
<p>SSE的第二个优势是服务端的<strong>简洁</strong>。相对而言，WebSocket则很复杂，不借助辅助类库基本搞不定。</p>
<p>SSE还有一个优势：它是一种<strong>文本协议</strong>，脚本调试非常容易。</p>
<p>不过，这就引出了WebSocket相较SSE的一个潜在优势：WebSocket是二进制协议，而SSE是文本协议（通常使用UTF-8编码）。当然，我们可以通过SSE连接传输二进制数据：在SSE中，只有两个具有特殊意义的字符，它们是CR和LF，而对它们进行转码并不难。但用SSE传输二进制数据时数据会变大，如果需要从服务端到客户端传输大量的二进制数据，最好还是用WebSocket。</p>
<p>WebSocket相较SSE最大的优势在于它是双向交流的，这意味向服务端发送数据就像从服务端接收数据一样简单。用SSE时，一般通过一个独立的Ajax请求从客户端向服务端传送数据。相对于WebSocket，这样使用Ajax会增加开销。</p>
<p>从服务端向客户端传输数据的性能如何？如果是文本数据而非二进制数据，SSE和WebSocket没什么区别。它们都用TCP/IP套接字，都是轻量级协议。延迟、带宽、服务器负载等都没有区别</p>
<h1 id="SSE技术详解：一种全新的HTML5服务器推送事件技术"><a href="#SSE技术详解：一种全新的HTML5服务器推送事件技术" class="headerlink" title="SSE技术详解：一种全新的HTML5服务器推送事件技术"></a>SSE技术详解：一种全新的HTML5服务器推送事件技术</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>一般来说，Web端即时通讯技术因受限于浏览器的设计限制，一直以来实现起来并不容易，主流的Web端即时通讯方案大致有4种：<code>传统Ajax短轮询</code>、<code>Comet技术</code>、<code>WebSocket技术</code>、<code>SSE（Server-sent Events）</code>。</li>
<li>关于这4种技术方式的优缺点，请参考《<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.52im.net/thread-336-1-1.html">Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE</a>》。</li>
<li>服务器推送事件（Server-sent Events），简称SSE，是 HTML 5 规范中的一个组成部分，可以用来<strong>从服务端实时推送数据到浏览器端</strong>。</li>
<li>相对于与之类似的 COMET 和 WebSocket 技术来说，服务器推送事件的使用更简单，对服务器端的改动也比较小。</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>由 XMLHttpRequest 对象来发出请求，得到服务器响应之后进行页面的局部更新。这种方式的不足之处在于：<strong>服务器端产生的数据变化不能及时地通知浏览器，而是需要等到下次请求发出时才能被浏览器获取</strong>。对于某些对数据实时性要求很高的应用来说，这种延迟是不能接受的。</li>
<li>为了满足这类应用的需求，就需要有某种方式能够从服务器端推送数据给浏览器，以保证服务器端的数据变化可以在第一时间通知给用户。</li>
<li>目前常见的解决办法有不少，主要可以分成两类。这两类方法的区别在于<strong>是否基于 HTTP 协议来实现</strong>。<ul>
<li>不使用 HTTP 协议的做法是使用 HTML 5 新增的 WebSocket 规范，</li>
<li>使用 HTTP 协议的做法则包括<code>简易轮询</code>、<code>COMET 技术</code>和<code>HTML 5 服务器推送事件</code>。</li>
</ul>
</li>
</ul>
<h2 id="四种技术的基本介绍"><a href="#四种技术的基本介绍" class="headerlink" title="四种技术的基本介绍"></a>四种技术的基本介绍</h2><p>在介绍 HTML 5 服务器推送事件（SSE技术）之前，首先介绍一些上面提到的几种服务器端数据推送技术。</p>
<ul>
<li><p>一种是 WebSocket。</p>
<ul>
<li>正如名称所表示的一样，WebSocket 使用的是<code>套接字连接</code>，<strong>基于 TCP 协议</strong>。</li>
<li>使用 WebSocket 之后，实际上<strong>在服务器端和浏览器之间建立一个套接字连接，可以进行双向的数据传输</strong>。</li>
<li>WebSocket 的功能是很强大的，使用起来也灵活，可以适用于不同的场景。</li>
<li>不过 WebSocket 技术也比较复杂，包括服务器端和浏览器端的实现都不同于一般的 Web 应用。而且更不幸的是WebSocket像其它较新的Web端技术一样存在浏览器兼容性问题，好在已经比较成熟的封装方案来解决这种技术限制，比如：开源的Socket.io，详见《<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.52im.net/thread-190-1-1.html">Socket.IO介绍：支持WebSocket、用于WEB端的即时通讯的框架</a>》。</li>
</ul>
</li>
<li><p>简易轮询</p>
<ul>
<li>即浏览器端定时向服务器端发出请求，来查询是否有数据更新。</li>
<li>这种做法比较简单，可以在一定程度上解决问题。不过对于轮询的时间间隔需要进行仔细考虑。轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担。</li>
</ul>
</li>
<li><p>Comet 技术</p>
<ul>
<li>改进了简易轮询的缺点（详见：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.52im.net/thread-334-1-1.html">Comet技术详解：基于HTTP长连接的Web端实时通信技术</a>），</li>
<li>使用的是<code>长轮询</code>。<strong>长轮询的方式在每次请求时，服务器端会保持该连接在一段时间内处于打开状态，而不是在响应完成之后就立即关闭</strong>。</li>
<li>这样做的好处是在连接处于打开状态的时间段内，服务器端产生的数据更新可以被及时地返回给浏览器。</li>
<li>当上一个长连接关闭之后，浏览器会立即打开一个新的长连接来继续请求。不过 COMET 技术的实现在服务器端和浏览器端都需要第三方库的支持。</li>
</ul>
</li>
</ul>
<p>综合比较上面提到的 4 种不同的技术</p>
<ul>
<li>简易轮询由于其本身的缺陷，并不推荐使用。</li>
<li>Comet 技术并不是 HTML 5 标准的一部分，从兼容标准的角度出发，也不推荐使用。</li>
<li>WebSocket 规范和服务器推送技术都是 HTML 5 标准的组成部分，在主流浏览器上都提供了原生的支持，是推荐使用的。不过 WebSocket 规范更加复杂一些，适用于需要进行复杂双向数据通讯的场景。对于简单的服务器数据推送的场景，使用服务器推送（SSE技术）事件就足够了。</li>
<li>SSE技术，服务器推送事件（SSE技术）已经在除 IE 外的大部分桌面和移动浏览器上得到了支持。</li>
</ul>
<h2 id="与WebSocket的比较"><a href="#与WebSocket的比较" class="headerlink" title="与WebSocket的比较"></a>与WebSocket的比较</h2><ul>
<li>SSE适用于更新频繁、低延迟并且数据都是从服务端到客户端。</li>
<li>它和WebSocket的区别：<ul>
<li><strong>便利</strong>，不需要添加任何新组件，用任何习惯的后端语言和框架就能继续使用，不用为新建虚拟机弄一个新的IP或新的端口号而劳神。</li>
<li><strong>服务器端的简洁</strong>。因为SSE能在现有的HTTP/HTTPS协议上运作，所以它能够直接运行于现有的代理服务器和认证技术。</li>
</ul>
</li>
</ul>
<p>WebSocket相较SSE最大的优势在于它是双向交流的，这意味着服务器发送数据就像从服务器接受数据一样简单，而SSE一般<strong>通过一个独立的Ajax请求从客户端向服务端传送数据</strong>，因此相对于WebSocket使用Ajax会增加开销。因此，如果需要以每秒一次或者更快的频率向服务端传输数据，就应该用WebSocket。</p>
<h2 id="SSE（Server-sent-Events）在HTML-5中的技术规范和定义"><a href="#SSE（Server-sent-Events）在HTML-5中的技术规范和定义" class="headerlink" title="SSE（Server-sent Events）在HTML 5中的技术规范和定义"></a>SSE（Server-sent Events）在HTML 5中的技术规范和定义</h2><ul>
<li>Server-sent Events 规范比较简单，主要由两个部分组成：第一个部分是服务器端与浏览器端之间的通讯协议。第二部分则是在浏览器端可供 JavaScript 使用的 EventSource 对象。</li>
<li>通讯协议是基于<strong>纯文本的简单协议</strong>。</li>
<li>服务器端的响应的内容类型是“text/event-stream”。响应文本的内容可以看成是一个事件流，由不同的事件所组成。</li>
<li>每个事件由类型和数据两部分组成，同时每个事件可以有一个可选的标识符</li>
<li>不同事件的内容之间通过仅包含回车符和换行符的空行（“\r\n”）来分隔。每个事件的数据可能由多行组成。</li>
</ul>
<p>服务器端响应的示例 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: first event</span><br><span class="line"> </span><br><span class="line">data: second event</span><br><span class="line">id: 100</span><br><span class="line"> </span><br><span class="line">event: myevent</span><br><span class="line">data: third event</span><br><span class="line">id: 101</span><br><span class="line"> </span><br><span class="line">: this is a comment</span><br><span class="line">data: fourth event</span><br><span class="line">data: fourth event continue</span><br></pre></td></tr></table></figure>

<ul>
<li>每个事件之间通过空行来分隔。</li>
<li>对于每一行来说，冒号（“:”）前面表示的是该行的类型，冒号后面则是对应的值。可能的类型包括：<ul>
<li>类型为空白，表示该行是注释，会在处理时被忽略。</li>
<li>类型为 data，表示该行包含的是数据。以 data 开头的行可以出现多次。所有这些行都是该事件的数据。</li>
<li>类型为 event，表示该行用来声明事件的类型。浏览器在收到数据时，会产生对应类型的事件。</li>
<li>类型为 id，表示该行用来声明事件的标识符。</li>
<li>类型为 retry，表示该行用来声明浏览器在连接断开之后进行再次连接之前的等待时间。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在代码清单 1 中，</p>
<ol>
<li>第一个事件只包含数据“first event”，会产生默认的事件；</li>
<li>第二个事件的标识符是 100，数据为“second event”；</li>
<li>第三个事件会产生类型为“myevent”的事件；</li>
<li>最后一个事件的数据为“fourth event\nfourth event continue”。当有多行数据时，实际的数据由每行数据以换行符连接而成。</li>
</ol>
</blockquote>
<ul>
<li>如果服务器端返回的数据中包含了事件的标识符，浏览器会记录最近一次接收到的事件的标识符。<ul>
<li>如果与服务器端的连接中断，当浏览器端再次进行连接时，会通过 HTTP 头“Last-Event-ID”来声明最后一次接收到的事件的标识符。</li>
<li>服务器端可以通过浏览器端发送的事件标识符来确定从哪个事件开始来继续连接。</li>
</ul>
</li>
<li>对于服务器端返回的响应，浏览器端需要在 JavaScript 中使用 EventSource 对象来进行处理。<ul>
<li>EventSource 使用的是标准的事件监听器方式，只需要在对象上添加相应的事件处理方法即可。</li>
</ul>
</li>
</ul>
<p>EventSource 提供了三个标准事件，</p>
<p><img src="/images/142133vvw4t8t94znc4woo.png" alt="SSE技术详解：一种全新的HTML5服务器推送事件技术_QQ20160526-0.png"></p>
<p>如之前所述，服务器端可以返回自定义类型的事件。对于这些事件，可以使用 addEventListener 方法来添加相应的事件处理方法。</p>
<p><strong>EventSource 对象的使用示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es = <span class="keyword">new</span> EventSource(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line">es.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">es.addEventListener(<span class="string">&#x27;myevent&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>在指定 URL 创建出 EventSource 对象之后，可以通过 onmessage 和 addEventListener 方法来添加事件处理方法。</li>
<li>当服务器端有新的事件产生，相应的事件处理方法会被调用。</li>
<li>EventSource 对象的 onmessage 属性的作用类似于 addEventListener( ‘ message ’ )，不过 onmessage 属性只支持一个事件处理方法。</li>
</ul>
<h2 id="SSE实战示例：服务器端和浏览器端实现"><a href="#SSE实战示例：服务器端和浏览器端实现" class="headerlink" title="SSE实战示例：服务器端和浏览器端实现"></a>SSE实战示例：服务器端和浏览器端实现</h2><ul>
<li>服务器端推送事件是一个比较简单的协议。服务器端的实现也相对比较简单，只需要按照协议规定的格式，返回响应内容即可。</li>
<li>本文使用 Java 作为服务器端的实现语言。相应的实现基于开源的 jetty-eventsource-servlet 项目。示例用来模拟一个物体在某个限定空间中的随机移动。该物体从一个随机位置开始，然后从上、下、左和右四个方向中随机选择一个方向，并在该方向上移动随机的距离。服务器端不断改变该物体的位置，并把位置信息推送给浏览器，由浏览器来显示。</li>
</ul>
<p>EventSource 接口的实现类 MovementEventSource：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovementEventSource</span> <span class="keyword">implements</span> <span class="title">EventSource</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> width = <span class="number">800</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> height = <span class="number">600</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> stepMax = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">private</span> Logger logger = Logger.getLogger(getClass().getName());</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MovementEventSource</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> stepMax)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.width = width;</span><br><span class="line">                <span class="keyword">this</span>.height = height;</span><br><span class="line">                <span class="keyword">this</span>.stepMax = stepMax;</span><br><span class="line">                <span class="keyword">this</span>.x = random.nextInt(width);</span><br><span class="line">                <span class="keyword">this</span>.y = random.nextInt(height);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Emitter emitter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                query(emitter); <span class="comment">//开始生成位置信息</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">(Emitter emitter, String lastEventId)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                updatePosition(lastEventId); <span class="comment">//更新起始位置</span></span><br><span class="line">                query(emitter);  <span class="comment">//开始生成位置信息</span></span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//根据Last-Event-Id来更新起始位置</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePosition</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        String[] pos = id.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (pos.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="keyword">int</span> xPos = -<span class="number">1</span>, yPos = -<span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                        xPos = Integer.parseInt(pos[<span class="number">0</span>], <span class="number">10</span>);</span><br><span class="line">                                        yPos = Integer.parseInt(pos[<span class="number">1</span>], <span class="number">10</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                                         </span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (isValidMove(xPos, yPos)) &#123;</span><br><span class="line">                                        x = xPos;</span><br><span class="line">                                        y = yPos;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(Emitter emitter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                emitter.comment(<span class="string">&quot;Start sending movement information.&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                        emitter.comment(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                        move(); <span class="comment">//移动位置</span></span><br><span class="line">                        String id = String.format(<span class="string">&quot;%s,%s&quot;</span>, x, y);</span><br><span class="line">                        emitter.id(id); <span class="comment">//根据位置生成事件标识符</span></span><br><span class="line">                        emitter.data(id); <span class="comment">//发送位置信息数据</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                logger.log(Level.WARNING, \</span><br><span class="line">               <span class="string">&quot;Movement query thread interrupted. Close the connection.&quot;</span>, e);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                emitter.close(); <span class="comment">//当循环终止时，关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取下一个合法的移动位置</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span>[] move = getMove();</span><br><span class="line">                        <span class="keyword">int</span> xNext = x + move[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> yNext = y + move[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (isValidMove(xNext, yNext)) &#123;</span><br><span class="line">                                x = xNext;</span><br><span class="line">                                y = yNext;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//判断当前的移动位置是否合法</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidMove</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= width &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; y &lt;= height;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//随机生成下一个移动位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] getMove() &#123;</span><br><span class="line">                <span class="keyword">int</span>[] xDir = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span>[] yDir = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> dir = random.nextInt(<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;xDir[dir] * random.nextInt(stepMax), \</span><br><span class="line">                   yDir[dir] * random.nextInt(stepMax)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类 MovementEventSource 需要实现 EventSource 接口的 onOpen、onResume 和 onClose 方法，<ul>
<li>onOpen 方法在浏览器端的连接打开的时候被调用，</li>
<li>onResume 方法在浏览器端重新建立连接时被调用，</li>
<li>onClose 方法则在浏览器关闭连接的时候被调用。</li>
<li>onOpen 和 onResume 方法都有一个 EventSource.Emitter 接口类型的参数，可以用来发送数据。</li>
</ul>
</li>
<li>EventSource.Emitter 接口中包含的方法包括 data、event、comment、id 和 close 等，分别对应于通讯协议中各种不同类型的事件。而 onResume 方法还额外包含一个参数 lastEventId，表示通过 Last-Event-ID 头发送过来的最近一次事件的标识符。</li>
</ul>
<blockquote>
<p>MovementEventSource 类中事件生成的主要逻辑在 query 方法中。该方法中包含一个无限循环，每隔 2 秒钟改变一次位置，同时把更新之后的位置通过 EventSource.Emitter 接口的 data 方法发送给浏览器端。每个事件都有对应的标识符，而标识符的值就是位置本身。如果连接断开之后，浏览器重新进行连接，可以从上一次的位置开始继续移动该物体。</p>
</blockquote>
<p>servlet 实现类 MovementServlet比较简单，只需要继承自 EventSourceServlet 类并覆写 newEventSource 方法即可。在 newEventSource 方法的实现中，需要返回一个 MovementEventSource 类的对象。每当浏览器端建立连接时，该 servlet 会创建一个新的 MovementEventSource 类的对象来处理该请求。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovementServlet</span> <span class="keyword">extends</span> <span class="title">EventSourceServlet</span> </span>&#123; </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> EventSource <span class="title">newEventSource</span><span class="params">(HttpServletRequest request, String clientId)</span> </span>&#123; </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> MovementEventSource(<span class="number">800</span>, <span class="number">600</span>, <span class="number">20</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>浏览器端实现</p>
<p>浏览器端的实现也比较简单，只需要创建出 EventSource 对象，并添加相应的事件处理方法即可。</p>
<blockquote>
<p>代码如下。在页面中使用一个方块表示物体。当接收到新的事件时，根据事件数据中给出的坐标信息，更新方块在页面上的位置。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es = <span class="keyword">new</span> EventSource(<span class="string">&#x27;sse/movement&#x27;</span>); </span><br><span class="line">es.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> pos = e.data.split(<span class="string">&#x27;,&#x27;</span>), x = pos[<span class="number">0</span>], y = pos[<span class="number">1</span>]; </span><br><span class="line">    $(<span class="string">&#x27;#box&#x27;</span>).css(&#123; </span><br><span class="line">        <span class="attr">left</span> : x + <span class="string">&#x27;px&#x27;</span>, </span><br><span class="line">        <span class="attr">top</span> : y + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h1 id="技术参考"><a href="#技术参考" class="headerlink" title="技术参考"></a>技术参考</h1><p><strong>关于Ajax短轮询：</strong><br>找这方面的资料没什么意义，除非忽悠客户，否则请考虑其它3种方案即可。</p>
<p><strong>有关Comet技术的详细介绍请参见：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-334-1-1.html">Comet技术详解：基于HTTP长连接的Web端实时通信技术</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-224-1-1.html">WEB端即时通讯：HTTP长连接、长轮询（long polling）详解</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-296-1-1.html">WEB端即时通讯：不用WebSocket也一样能搞定消息的即时性</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-330-1-1.html">开源Comet服务器iComet：支持百万并发的Web端即时通讯方案</a>》</p>
<p><strong>有关WebSocket的详细介绍请参见：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-331-1-1.html">WebSocket详解（一）：初步认识WebSocket技术</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-326-1-1.html">WebSocket详解（二）：技术原理、代码演示和应用案例</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-332-1-1.html">WebSocket详解（三）：深入WebSocket通信协议细节</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1258-1-1.html">WebSocket详解（四）：刨根问底HTTP与WebSocket的关系(上篇)</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1266-1-1.html">WebSocket详解（五）：刨根问底HTTP与WebSocket的关系(下篇)</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1273-1-1.html">WebSocket详解（六）：刨根问底WebSocket与Socket的关系</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1341-1-1.html">理论联系实际：从零理解WebSocket的通信原理、协议格式、安全性</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-2488-1-1.html">八问WebSocket协议：为你快速解答WebSocket热门疑问</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/forum.php?mod=viewthread&tid=190&ctid=15">Socket.IO介绍：支持WebSocket、用于WEB端的即时通讯的框架</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/forum.php?mod=viewthread&tid=189&ctid=15">socket.io和websocket 之间是什么关系？有什么区别？</a>》</p>
<p><strong>有关SSE的详细介绍文章请参见：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-335-1-1.html">SSE技术详解：一种全新的HTML5服务器推送事件技术</a>》  </p>
<h1 id="即时通讯技术资料分类"><a href="#即时通讯技术资料分类" class="headerlink" title="即时通讯技术资料分类"></a>即时通讯技术资料分类</h1><p><strong>[1] 网络编程基础资料：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html">TCP/IP详解</a> - <a target="_blank" rel="noopener" href="http://docs.52im.net/extend/docs/book/tcpip/vol1/11/">第11章·UDP：用户数据报协议</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html">TCP/IP详解</a> - <a target="_blank" rel="noopener" href="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/">第17章·TCP：传输控制协议</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html">TCP/IP详解</a> - <a target="_blank" rel="noopener" href="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/">第18章·TCP连接的建立与终止</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html">TCP/IP详解</a> - <a target="_blank" rel="noopener" href="http://docs.52im.net/extend/docs/book/tcpip/vol1/21/">第21章·TCP的超时与重传</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-258-1-1.html">理论经典：TCP协议的3次握手与4次挥手过程详解</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-275-1-1.html">理论联系实际：Wireshark抓包分析TCP 3次握手、4次挥手过程</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-180-1-1.html">计算机网络通讯协议关系图（中文珍藏版）</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-50-1-1.html">NAT详解：基本原理、穿越技术(P2P打洞)、端口老化等</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-29-1-1.html">UDP中一个包的大小最大能多大？</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-306-1-1.html">Java新一代网络编程模型AIO原理及Linux系统AIO介绍</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-378-1-1.html">NIO框架入门(三)：iOS与MINA2、Netty4的跨平台UDP双向通信实战</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-388-1-1.html">NIO框架入门(四)：Android与MINA2、Netty4的跨平台UDP双向通信实战</a>》</p>
<p><strong>[2] 有关IM/推送的通信格式、协议的选择：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-279-1-1.html">为什么QQ用的是UDP协议而不是TCP协议？</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-33-1-1.html">移动端即时通讯协议选择：UDP还是TCP？</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-276-1-1.html">如何选择即时通讯应用的数据传输格式</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-277-1-1.html">强列建议将Protobuf作为你的即时通讯应用数据传输格式</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-133-1-1.html">移动端IM开发需要面对的技术问题（含通信协议选择）</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-289-1-1.html">简述移动端IM开发的那些坑：架构设计、通信协议和客户端</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-283-1-1.html">理论联系实际：一套典型的IM通信协议设计详解</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-298-1-1.html">58到家实时消息系统的协议设计等技术实践分享</a>》</p>
<p><strong>[3] 有关IM/推送的心跳保活处理：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-438-1-1.html">Android进程保活详解：一篇文章解决你的所有疑问</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-341-1-1.html">Android端消息推送总结：实现原理、心跳保活、遇到的问题等</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-281-1-1.html">为何基于TCP协议的移动端IM仍然需要心跳保活机制？</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-210-1-1.html">微信团队原创分享：Android版微信后台保活实战分享(进程保活篇)</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-209-1-1.html">微信团队原创分享：Android版微信后台保活实战分享(网络保活篇)</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-120-1-1.html">移动端IM实践：实现Android版微信的智能心跳机制</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-121-1-1.html">移动端IM实践：WhatsApp、Line、微信的心跳策略分析</a>》</p>
<p><strong>[4] 有关WEB端即时通讯开发：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-338-1-1.html">新手入门贴：史上最全Web端即时通讯技术原理详解</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-336-1-1.html">Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-335-1-1.html">SSE技术详解：一种全新的HTML5服务器推送事件技术</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-334-1-1.html">Comet技术详解：基于HTTP长连接的Web端实时通信技术</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-331-1-1.html">WebSocket详解（一）：初步认识WebSocket技术</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-188-1-1.html">socket.io实现消息推送的一点实践及思路</a>》</p>
<p><strong>[5] 有关IM架构设计：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-307-1-1.html">浅谈IM系统的架构设计</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-289-1-1.html">简述移动端IM开发的那些坑：架构设计、通信协议和客户端</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-151-1-1.html">一套原创分布式即时通讯(IM)系统理论架构方案</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-152-1-1.html">从零到卓越：京东客服即时通讯系统的技术架构演进历程</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-31-1-1.html">蘑菇街即时通讯/IM服务器开发之架构选择</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-158-1-1.html">腾讯QQ1.4亿在线用户的技术挑战和架构演进之路PPT</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-200-1-1.html">微信技术总监谈架构：微信之道——大道至简(演讲全文)</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-201-1-1.html">如何解读《微信技术总监谈架构：微信之道——大道至简》</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-168-1-1.html">快速裂变：见证微信强大后台架构从0到1的演进历程（一）</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-159-1-1.html">17年的实践：腾讯海量产品的技术方法论</a>》</p>
<p><strong>[6] 有关IM安全的文章：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-216-1-1.html">即时通讯安全篇（一）：正确地理解和使用Android端加密算法</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-217-1-1.html">即时通讯安全篇（二）：探讨组合加密算法在IM中的应用</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-219-1-1.html">即时通讯安全篇（三）：常用加解密算法与通讯安全讲解</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-312-1-1.html">即时通讯安全篇（四）：实例分析Android中密钥硬编码的风险</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-327-1-1.html">传输层安全协议SSL/TLS的Java平台实现简介和Demo演示</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-283-1-1.html">理论联系实际：一套典型的IM通信协议设计详解（含安全层设计）</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-310-1-1.html">微信新一代通信安全解决方案：基于TLS1.3的MMTLS详解</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-215-1-1.html">来自阿里OpenIM：打造安全可靠即时通讯服务的技术实践分享</a>》</p>
<p><strong>[7] 有关实时音视频开发：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-228-1-1.html">即时通讯音视频开发（一）：视频编解码之理论概述</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-229-1-1.html">即时通讯音视频开发（二）：视频编解码之数字视频介绍</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-232-1-1.html">即时通讯音视频开发（三）：视频编解码之编码基础</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-235-1-1.html">即时通讯音视频开发（四）：视频编解码之预测技术介绍</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-237-1-1.html">即时通讯音视频开发（五）：认识主流视频编码技术H.264</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-241-1-1.html">即时通讯音视频开发（六）：如何开始音频编解码技术的学习</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-242-1-1.html">即时通讯音视频开发（七）：音频基础及编码原理入门</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-243-1-1.html">即时通讯音视频开发（八）：常见的实时语音通讯编码标准</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-247-1-1.html">即时通讯音视频开发（九）：实时语音通讯的回音及回音消除概述</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-250-1-1.html">即时通讯音视频开发（十）：实时语音通讯的回音消除技术详解</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-251-1-1.html">即时通讯音视频开发（十一）：实时语音通讯丢包补偿技术详解</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-253-1-1.html">即时通讯音视频开发（十二）：多人实时音视频聊天架构探讨</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-266-1-1.html">即时通讯音视频开发（十三）：实时视频编码H.264的特点与优势</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-267-1-1.html">即时通讯音视频开发（十四）：实时音视频数据传输协议介绍</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-269-1-1.html">即时通讯音视频开发（十五）：聊聊P2P与实时音视频的应用情况</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-270-1-1.html">即时通讯音视频开发（十六）：移动端实时音视频开发的几个建议</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-274-1-1.html">即时通讯音视频开发（十七）：视频编码H.264、V8的前世今生</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-225-1-1.html">简述开源实时音视频技术WebRTC的优缺点</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-265-1-1.html">良心分享：WebRTC 零基础开发者教程（中文）</a>》</p>
<p><strong>[8] IM开发综合文章：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-133-1-1.html">移动端IM开发需要面对的技术问题</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-150-1-1.html">开发IM是自己设计协议用字节流好还是字符流好？</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-175-1-1.html">请问有人知道语音留言聊天的主流实现方式吗？</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-294-1-1.html">IM系统中如何保证消息的可靠投递（即QoS机制）</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-282-1-1.html">谈谈移动端 IM 开发中登录请求的优化</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-280-1-1.html">完全自已开发的IM该如何设计“失败重试”机制？</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-195-1-1.html">微信对网络影响的技术试验及分析（论文全文）</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-218-1-1.html">即时通讯系统的原理、技术和应用（技术论文）</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-447-1-1.html">开源IM工程“蘑菇街TeamTalk”的现状：一场有始无终的开源秀</a>》</p>
<p><strong>[9] 开源移动端IM技术框架资料：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-52-1-1.html">开源移动端IM技术框架MobileIMSDK：快速入门</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-60-1-1.html">开源移动端IM技术框架MobileIMSDK：常见问题解答</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-57-1-1.html">开源移动端IM技术框架MobileIMSDK：压力测试报告</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-55-1-1.html">开源移动端IM技术框架MobileIMSDK：Android版Demo使用帮助</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-56-1-1.html">开源移动端IM技术框架MobileIMSDK：Java版Demo使用帮助</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-54-1-1.html">开源移动端IM技术框架MobileIMSDK：iOS版Demo使用帮助</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-61-1-1.html">开源移动端IM技术框架MobileIMSDK：Android客户端开发指南</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-59-1-1.html">开源移动端IM技术框架MobileIMSDK：Java客户端开发指南</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-62-1-1.html">开源移动端IM技术框架MobileIMSDK：iOS客户端开发指南</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-63-1-1.html">开源移动端IM技术框架MobileIMSDK：Server端开发指南</a>》</p>
<p><strong>[10] 有关推送技术的文章：</strong><br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-345-1-1.html">iOS的推送服务APNs详解：设计思路、技术原理及缺陷等</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-341-1-1.html">Android端消息推送总结：实现原理、心跳保活、遇到的问题等</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-318-1-1.html">扫盲贴：认识MQTT通信协议</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-315-1-1.html">一个基于MQTT通信协议的完整Android推送Demo</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-314-1-1.html">求教android消息推送：GCM、XMPP、MQTT三种方案的优劣</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-288-1-1.html">移动端实时消息推送技术浅析</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-286-1-1.html">扫盲贴：浅谈iOS和Android后台实时消息推送的原理和区别</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-166-1-1.html">绝对干货：基于Netty实现海量接入的推送服务技术要点</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-122-1-1.html">移动端IM实践：谷歌消息推送服务(GCM)研究（来自微信）</a>》<br>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-117-1-1.html">为何微信、QQ这样的IM工具不使用GCM服务推送消息？</a>》</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>