<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;稀疏数组&quot;&gt;&lt;a href=&quot;#稀疏数组&quot; class=&quot;headerlink&quot; title=&quot;稀疏数组&quot;&gt;&lt;/a&gt;稀疏数组&lt;/h2&gt;&lt;p&gt;当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>尚硅谷韩顺平Go语言核心编程3 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2020-06-11</div></div></div><div class="container post-header"><h1>尚硅谷韩顺平Go语言核心编程3</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">稀疏数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">环形队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="toc-number">2.1.</span> <span class="toc-text">数组模拟环形队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">环形单向链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">插入排序</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是：</p>
<ul>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li>
</ul>
<p><img src="/images/1591848896140.png" alt="1591848896140"></p>
<blockquote>
<p>简单来说 , 就是<strong>将无用的数据扔掉 , 进而无损压缩数据</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ValNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	row <span class="keyword">int</span></span><br><span class="line">	col <span class="keyword">int</span></span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> chessMap [<span class="number">11</span>][<span class="number">11</span>]<span class="keyword">int</span></span><br><span class="line">	chessMap[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">	chessMap[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> _, v1 := <span class="keyword">range</span> chessMap &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d\t&quot;</span>,v2)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sparseArr []ValNode</span><br><span class="line">	<span class="comment">// 标准的稀疏数组需要一个 `记录二维数组的规模(行和列)`</span></span><br><span class="line">	head := ValNode&#123;</span><br><span class="line">		row:<span class="number">11</span>,</span><br><span class="line">		col:<span class="number">11</span>,</span><br><span class="line">		val:<span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	sparseArr = <span class="built_in">append</span>(sparseArr,head)</span><br><span class="line">	<span class="comment">// 储存稀疏数组</span></span><br><span class="line">	<span class="keyword">for</span> i, v1 := <span class="keyword">range</span> chessMap &#123;</span><br><span class="line">		<span class="keyword">for</span> j, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">			<span class="keyword">if</span> v2 != <span class="number">0</span> &#123;</span><br><span class="line">				valNode := ValNode&#123;</span><br><span class="line">					row:i,</span><br><span class="line">					col:j,</span><br><span class="line">					val:v2,</span><br><span class="line">				&#125;</span><br><span class="line">				sparseArr = <span class="built_in">append</span>(sparseArr,valNode)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出稀疏数组</span></span><br><span class="line">	<span class="keyword">for</span> i,valNode := <span class="keyword">range</span> sparseArr &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d:%d %d %d\n&quot;</span>,i,valNode.row,valNode.col,valNode.val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><h3 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h3><ul>
<li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下其中 maxsize是该队列的最大容量。</p>
<p><img src="/images/1591860031681.png" alt="1591860031681"></p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输岀而改变，而rear则是随着数据输入而改变，</p>
</li>
<li><p>一般约定 , 当rear距离front只有一个空位的时候为<code>对满</code> (也就是说,队尾差一位就能追上对首)</p>
<ul>
<li>所以就是判断 : <code>(rear + 1) % maxSize == head</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>总结 :</p>
<ul>
<li>初始化 : <code>rear == head == 0</code></li>
<li>对空 : <code>rear == head</code></li>
<li>对满 : <code>(rear + 1) % maxSize == head</code></li>
<li>队列的元素个数 : <code>(rear + maxSize - head) % maxSize</code> (为了保证不出现负数 , 要加一个maxSize)</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CircleQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	maxSize <span class="keyword">int</span></span><br><span class="line">	array [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">	front <span class="keyword">int</span> <span class="comment">// 队首指针</span></span><br><span class="line">	rear <span class="keyword">int</span> <span class="comment">// 队尾部指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">IsFull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (this.rear + <span class="number">1</span>) % this.maxSize == this.front</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.front == this.rear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (this.rear + this.maxSize - this.front) % this.maxSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先判断队列是否已满</span></span><br><span class="line">	<span class="keyword">if</span> this.IsFull() &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;queue full&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	this.rear++ <span class="comment">// 后移</span></span><br><span class="line">	this.array[this.rear] =val</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(val <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> , errors.New(<span class="string">&quot;queue empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	this.front = (this.front + <span class="number">1</span>) % this.maxSize</span><br><span class="line">	val = this.array[this.front]</span><br><span class="line">	<span class="keyword">return</span> val ,err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CircleQueue)</span> <span class="title">List</span><span class="params">()</span></span> &#123;</span><br><span class="line">	size := this.Size()</span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Queue Empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	dummy := this.front</span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;arr[%d]=%d\t&quot;</span>, dummy, this.array[dummy])</span><br><span class="line">		dummy = (dummy +<span class="number">1</span>) % this.maxSize</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	queue := &amp;CircleQueue&#123;</span><br><span class="line">		maxSize :<span class="number">4</span>,</span><br><span class="line">		front :<span class="number">0</span>,</span><br><span class="line">		rear :<span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err := queue.Push(<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	queue.Push(<span class="number">200</span>)</span><br><span class="line">	queue.Push(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">	queue.List() <span class="comment">// array[0]=100    array[1]=200    array[2]=300</span></span><br><span class="line"></span><br><span class="line">	res,err := queue.Pop()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(res) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="环形单向链表"><a href="#环形单向链表" class="headerlink" title="环形单向链表"></a>环形单向链表</h3><p>环形单向链表一般也拥有<code>dummyHead</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CricleNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">	next *CricleNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *CricleNode)</span> <span class="title">append</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	pre := n</span><br><span class="line">	realHead := pre.next</span><br><span class="line"></span><br><span class="line">	<span class="comment">// realHead是空</span></span><br><span class="line">	<span class="keyword">if</span> pre.next == <span class="literal">nil</span> &#123;</span><br><span class="line">		newNode := &amp;CricleNode&#123;val:val&#125;</span><br><span class="line">		pre.next = newNode</span><br><span class="line">		newNode.next = newNode</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pre = realHead</span><br><span class="line">		<span class="keyword">for</span> pre.next != realHead&#123;</span><br><span class="line">			pre = pre.next</span><br><span class="line">		&#125;</span><br><span class="line">		newNode := &amp;CricleNode&#123;</span><br><span class="line">			val:val,</span><br><span class="line">			next:realHead,</span><br><span class="line">		&#125;</span><br><span class="line">		pre.next = newNode</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *CricleNode)</span> <span class="title">List</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n.next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	pre := n.next</span><br><span class="line">	realHead := pre</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(pre.val)</span><br><span class="line">		pre = pre.next</span><br><span class="line">		<span class="keyword">if</span> pre == realHead &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	DummyHead := &amp;CricleNode&#123;&#125;</span><br><span class="line">	DummyHead.<span class="built_in">append</span>(<span class="number">100</span>)</span><br><span class="line">	DummyHead.<span class="built_in">append</span>(<span class="number">200</span>)</span><br><span class="line">	DummyHead.<span class="built_in">append</span>(<span class="number">300</span>)</span><br><span class="line">	DummyHead.List()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>对比单向链表的优势 :</p>
<ul>
<li>支持向前查找</li>
<li>单向链表不支持<code>自我删除</code> , 必须依赖其他辅助节点 , 而双向链表支持<code>自我删除</code></li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	Len := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=Len <span class="number">-1</span>; i++ &#123;</span><br><span class="line">		maxIdx := i</span><br><span class="line">		<span class="keyword">for</span> j:=i; j&lt;=Len <span class="number">-1</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &lt; arr[maxIdx] &#123;</span><br><span class="line">				maxIdx = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[i],arr[maxIdx] = arr[maxIdx],arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>&#125;</span><br><span class="line">	res := SelectSort(arr)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertSort</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	Len := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;= Len<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> idx := i; idx &gt; <span class="number">0</span>;idx--&#123;</span><br><span class="line">			<span class="keyword">if</span> arr[idx] &lt; arr[idx<span class="number">-1</span>] &#123;</span><br><span class="line">				arr[idx], arr[idx<span class="number">-1</span>] = arr[idx<span class="number">-1</span>], arr[idx]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>&#125;</span><br><span class="line">	res := InsertSort(arr)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>