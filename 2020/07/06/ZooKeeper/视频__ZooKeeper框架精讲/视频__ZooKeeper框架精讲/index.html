<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="地址 : &lt;a href=&quot;https://www.bilibili.com/video/BV1PW411r7iP&quot;&gt;https://www.bilibili.com/video/BV1PW411r7iP&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>ZooKeeper框架精讲 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/ZooKeeper/" rel="tag">ZooKeeper</a></div><div class="post-time">2020-07-06</div></div></div><div class="container post-header"><h1>ZooKeeper框架精讲</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">Zookeeper入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.1.</span> <span class="toc-text">统一命名服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">统一配置管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.3.</span> <span class="toc-text">统一集群管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E6%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF"><span class="toc-number">1.4.4.</span> <span class="toc-text">服务器动态上下线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.4.5.</span> <span class="toc-text">软负载均衡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%A7%A3%E8%AF%BB"><span class="toc-number">2.</span> <span class="toc-text">配置参数解读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">内部原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">选举机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">节点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stat%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.3.</span> <span class="toc-text">Stat结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">监听器原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">写数据流程</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>地址 : <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PW411r7iP">https://www.bilibili.com/video/BV1PW411r7iP</a></p>
<h2 id="Zookeeper入门"><a href="#Zookeeper入门" class="headerlink" title="Zookeeper入门"></a>Zookeeper入门</h2><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在 Zookeeper上注册的那些观察者做出相应的反应。</p>
<p><img src="/images/1593951954322.png" alt="1593951954322"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><img src="/images/1593952140891.png" alt="1593952140891"></p>
<ol>
<li>一个领导者 , 多个跟随者组成的集群</li>
<li>集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。</li>
<li>全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Sever数据都是一致的</li>
<li>更新请求顺序进行，来自同一个Client的更新请求按其发送顺序依次执行</li>
<li>数据更新原子性，一次数据更新要么成功，要么失败</li>
<li>实时性，在一定时间范围内，Client能读到最新数据。</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一颗树，每个节点称做一个 ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以<strong>通过其路径唯一标识</strong></p>
<p><img src="/images/1593952527864.png" alt="1593952527864"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>统一命名服务、</li>
<li>统一配置管理、</li>
<li>统一集群管理、</li>
<li>服务器节点动态上下线、</li>
<li>软负载均衡</li>
</ul>
<h4 id="统一命名服务"><a href="#统一命名服务" class="headerlink" title="统一命名服务"></a>统一命名服务</h4><p>在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如：IP不容易记住，而域名容易记住。</p>
<p><img src="/images/1593952836442.png" alt="1593952836442"></p>
<h4 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h4><ol>
<li><p>分布式环境下，配置文件同步非常常见。</p>
<ol>
<li>一般要求一个集群中，所有节点的配置信息是一致的，比如 Kafka集群。</li>
<li>对配置文件修改后，希望能够快速同步到各个节点上。</li>
</ol>
</li>
<li><p>配置管理可交由 ZooKeeper实现。</p>
<ol>
<li>可将配置信息写入 ZooKeeper上的一个 Znode</li>
<li>各个客户端服务器监听这个 Znode</li>
<li>一旦Znode中的数据被修改，ZooKeeper将通知各个客户端服务器。</li>
</ol>
</li>
</ol>
<p><img src="/images/1593953021892.png" alt="1593953021892"></p>
<h4 id="统一集群管理"><a href="#统一集群管理" class="headerlink" title="统一集群管理"></a>统一集群管理</h4><ol>
<li><p>分布式环境中，实时掌握每个节点的状态是必要的。</p>
<ol>
<li>可根据节点实时状态做出一些调整。</li>
</ol>
</li>
<li><p>ZooKeeper可以实现实时监控节点状态变化</p>
<ol>
<li>可将节点信息写入 ZooKeeper上的一个  ZNode</li>
<li>监听这个ZNode可获取它的实时状态变化</li>
</ol>
</li>
</ol>
<p><img src="/images/1593953312502.png" alt="1593953312502"></p>
<h4 id="服务器动态上下线"><a href="#服务器动态上下线" class="headerlink" title="服务器动态上下线"></a>服务器动态上下线</h4><p>客户端能实时洞察到服务器上下线的变化</p>
<p><img src="/images/1593953470174.png" alt="1593953470174"></p>
<h4 id="软负载均衡"><a href="#软负载均衡" class="headerlink" title="软负载均衡"></a>软负载均衡</h4><p>在 Zookeeper中记录每台服务器的访数，让访可数最少的服务器去处理最新的客户端请求</p>
<p><img src="/images/1593953609294.png" alt="1593953609294"></p>
<h2 id="配置参数解读"><a href="#配置参数解读" class="headerlink" title="配置参数解读"></a>配置参数解读</h2><p>Zookeeper中的配置文件zoo.cfg中参数含义解读如下：</p>
<ol>
<li><p>tickTime =2000：通信心跳数，Zookeeper服务器与客户端心跳时间，单位毫秒Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒。</p>
<p>它用于心跳机制，并且设置最小的session超时时间为两倍心跳时间。(session的最小超时时间是2*tickTime)</p>
</li>
<li><p>initLimit =10：LF初始通信时限</p>
<p>集群中的Follower跟随者服务器与Leader领导者服务器之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限。</p>
</li>
<li><p>syncLimit =5：LF同步通信时限</p>
<p>集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer。</p>
</li>
<li><p>dataDir：数据文件目录+数据持久化路径</p>
<p>主要用于保存Zookeeper中的数据。</p>
</li>
<li><p>clientPort =2181：客户端连接端口</p>
<p>监听客户端连接的端口。</p>
</li>
</ol>
<h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><ul>
<li>半数机制：<strong>集群中半数以上机器存活，集群可用</strong>。所以Zookeeper适合安装奇数台服务器。</li>
<li>Zookeeper虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。</li>
</ul>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li>持久（Persistent）：客户端和服务器端断开连接后，创建的节点不删除</li>
<li>短暂（Ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除</li>
</ul>
<ul>
<li><p>顺序节点：创建znde时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护</p>
<blockquote>
<p>注意：在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序</p>
</blockquote>
</li>
</ul>
<h3 id="Stat结构体"><a href="#Stat结构体" class="headerlink" title="Stat结构体"></a>Stat结构体</h3><ol>
<li><p>czxid-创建节点的事务zxid</p>
<p>每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。</p>
<blockquote>
<p>事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。</p>
</blockquote>
</li>
<li><p>ctime - znode被创建的毫秒数(从1970年开始)</p>
</li>
<li><p>mzxid - znode最后更新的事务zxid</p>
</li>
<li><p>mtime - znode最后修改的毫秒数(从1970年开始)</p>
</li>
<li><p>pZxid-znode最后更新的子节点zxid</p>
</li>
<li><p>cversion - znode子节点变化号，znode子节点修改次数</p>
</li>
<li><p>dataversion - znode数据变化号</p>
</li>
<li><p>aclVersion - znode访问控制列表的变化号</p>
</li>
<li><p>ephemeralOwner- 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</p>
</li>
<li><p>dataLength- znode的数据长度</p>
</li>
<li><p>numChildren - znode子节点数量</p>
</li>
</ol>
<h3 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h3><ol>
<li>首先要有一个main()线程</li>
<li>在main线程中创建Zookeeper客户端，这时就会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）</li>
<li>通过connect线程将注册的监听事件发送给Zookeeper。</li>
<li>在 Zookeeper的注册监听列表中将注册的监听事件添到列表中。</li>
<li>Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程</li>
<li>listener线程内部调用了process()方法。</li>
</ol>
<p><img src="/images/1594003453668.png" alt="1594003453668"></p>
<p>常见的监听</p>
<ol>
<li>监听节点数据的变化</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get path [watch]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>监听子节点增减的变化</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls pathh [watch]</span><br></pre></td></tr></table></figure>



<h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p><img src="/images/1594003701405.png" alt="1594003701405"></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>