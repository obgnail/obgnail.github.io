<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;探讨npm依赖管理之peerDependencies&quot;&gt;&lt;a href=&quot;#探讨npm依赖管理之peerDependencies&quot; class=&quot;headerlink&quot; title=&quot;探讨npm依赖管理之peerDependencies&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/wonyun/p/9692476.html&quot;&gt;探讨npm依赖管理之peerDependencies&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;想必前端同学对npm的devDependencies和dependencies都比较熟悉，但是对peerDependencies可能就有点陌生，尤其是没有写过npm包插件的同学，比如之前使用grunt自动化工具的相关插件（如grunt-contrib-jasmine等）或者目前基于某个框架的ui组件库等等，这些都是需要对peerDependencies有一定了解的。下面我们就来说说peerDependencies。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>peerDependencies | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Node-Package-Manager/" rel="tag">Node Package Manager</a></div><div class="post-time">2020-08-03</div></div></div><div class="container post-header"><h1>peerDependencies</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A2%E8%AE%A8npm%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B9%8BpeerDependencies"><span class="toc-number">1.</span> <span class="toc-text">探讨npm依赖管理之peerDependencies</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm2%E4%B8%ADdependencies%E4%B8%8EpeerDependencies%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">npm2中dependencies与peerDependencies区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#peerDependencies%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">1.3.</span> <span class="toc-text">peerDependencies的引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm2%E5%92%8Cnpm3%E4%B8%ADpeerDependencies%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">npm2和npm3中peerDependencies的区别</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="探讨npm依赖管理之peerDependencies"><a href="#探讨npm依赖管理之peerDependencies" class="headerlink" title="探讨npm依赖管理之peerDependencies"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wonyun/p/9692476.html">探讨npm依赖管理之peerDependencies</a></h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>想必前端同学对npm的devDependencies和dependencies都比较熟悉，但是对peerDependencies可能就有点陌生，尤其是没有写过npm包插件的同学，比如之前使用grunt自动化工具的相关插件（如grunt-contrib-jasmine等）或者目前基于某个框架的ui组件库等等，这些都是需要对peerDependencies有一定了解的。下面我们就来说说peerDependencies。</p>
<h2 id="npm2中dependencies与peerDependencies区别"><a href="#npm2中dependencies与peerDependencies区别" class="headerlink" title="npm2中dependencies与peerDependencies区别"></a>npm2中dependencies与peerDependencies区别</h2><p>假设我们当前的项目是MyProject，项目中有一些依赖，比方其中有一个依赖包<strong>PackageA</strong>，该包的<strong>package.json</strong>文件指定了对<strong>PackageB</strong>的依赖：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;PackageB&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在我们的MyProject项目中执行<code>npm install PackageA</code>, 我们会发现我们项目的目录结构会是如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyProject</span><br><span class="line">|- node_modules</span><br><span class="line">   |- PackageA</span><br><span class="line">      |- node_modules</span><br><span class="line">         |- PackageB</span><br></pre></td></tr></table></figure>

<p>那么在我们的项目中，我们能通过下面语句引入”PackageA”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> packageA = <span class="built_in">require</span>(<span class="string">&#x27;PackageA&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>但是，如果你想在项目中直接引用PackageB:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> packageA = <span class="built_in">require</span>(<span class="string">&#x27;PackageA&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> packageB = <span class="built_in">require</span>(<span class="string">&#x27;PackageB&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这是不行的，即使PackageB被安装过；因为Node只会在“MyProject/node_modules”目录下查找PackageB，它不会在进入PackageA模块下的node_modules下查找。</p>
<p>所以，为了解决这个问题，<strong>在MyProject项目package.json中我们必须直接声明对PackageB的依赖并安装。</strong></p>
<p>但是，有时我们不用在当前项目中声明对PackageB的依赖就可以直接引用，尤其是，PackageA是一个类似于<strong>grunt</strong>的插件，例如grunt-contrib-jshint。</p>
<p>为什么在项目中不用声明就可以直接使用呢？这就不得不说说peerDependencies的作用了。</p>
<h2 id="peerDependencies的引入"><a href="#peerDependencies的引入" class="headerlink" title="peerDependencies的引入"></a>peerDependencies的引入</h2><p>为了解决这种问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你安装我，那么你最好也安装X,Y和Z.</span><br></pre></td></tr></table></figure>

<p>于是<code>peerDependencies</code>就被引入了。例如上面PackageA的<strong>package.json</strong>文件如果是下面这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;PackageB&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，它会告诉npm：如果某个package把我列为依赖的话，那么那个package也必需应该有对PackageB的依赖。</p>
<p>也就是说，如果你<code>npm install PackageA</code>，你将会得到下面的如下的目录结构：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyProject</span><br><span class="line">|- node_modules</span><br><span class="line">   |- PackageA</span><br><span class="line">   |- PackageB</span><br></pre></td></tr></table></figure>

<p>你可能注意到：</p>
<blockquote>
<p>在npm2中，即使当前项目MyProject中没有直接依赖PackageB，该PackageB包依然会安装到当前项目的node_modules文件夹中。</p>
</blockquote>
<p>下面的代码现在可以正常工作了，因为两个包在”MyProject/node_modules”中被安装了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> packageA = <span class="built_in">require</span>(<span class="string">&#x27;PackageA&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> packageB = <span class="built_in">require</span>(<span class="string">&#x27;PackageB&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>总结一句话，<code>peerDependencies</code>的具体作用：</p>
<blockquote>
<p><code>peerDependencies</code>的目的是提示宿主环境去安装满足插件peerDependencies所指定依赖的包，然后在插件import或者require所依赖的包的时候，永远都是引用宿主环境统一安装的npm包，最终解决插件与所依赖包不一致的问题。</p>
</blockquote>
<p>举个例子，就拿目前基于react的ui组件库<strong><a href="mailto:&#x61;&#x6e;&#x74;&#x2d;&#100;&#x65;&#x73;&#105;&#x67;&#110;&#x40;&#51;&#46;&#120;">&#x61;&#x6e;&#x74;&#x2d;&#100;&#x65;&#x73;&#105;&#x67;&#110;&#x40;&#51;&#46;&#120;</a></strong>来说，因该ui组件库只是提供一套react组件库，它要求宿主环境需要安装指定的react版本。具体可以看它<a target="_blank" rel="noopener" href="https://github.com/ant-design/ant-design/blob/master/package.json#L37">package.json</a>中的配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;&gt;=16.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;&gt;=16.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它要求宿主环境安装react@&gt;=16.0.0和react-dom@&gt;=16.0.0的版本，而在每个antd组件的定义文件顶部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>组件中引入的react和react-dom包其实都是宿主环境提供的依赖包。</p>
<h2 id="npm2和npm3中peerDependencies的区别"><a href="#npm2和npm3中peerDependencies的区别" class="headerlink" title="npm2和npm3中peerDependencies的区别"></a>npm2和npm3中peerDependencies的区别</h2><p>正如上一节谈论的，在npm2中，PackageA包中<code>peerDependencies</code>所指定的依赖会随着<code>npm install PackageA</code>一起被强制安装，所以不需要在宿主环境的package.json文件中指定对PackageA中<code>peerDependencies</code>内容的依赖。</p>
<p>但是在npm3中，<code>peerDependencies</code>的表现与npm2不同：</p>
<blockquote>
<p>npm3中不会再要求peerDependencies所指定的依赖包被强制安装，相反npm3会在安装结束后检查本次安装是否正确，如果不正确会给用户打印警告提示。</p>
</blockquote>
<p>就拿上面的例子来说，如果我们npm install PackageA安装PackageA时，你会得到一个警告提示说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PackageB是一个需要的依赖，但是没有被安装。 </span><br></pre></td></tr></table></figure>

<p>这时，你需要手动的在MyProject项目的package.json文件指定PackageB的依赖。</p>
<p>另外，在npm3的项目中，可能存在一个问题就是你所依赖的一个package包更新了它peerDependencies的版本，那么你可能也需要在项目的package.json文件中手动更新到正确的版本。否则会出现类似下图所示的警告信息：</p>
<p><img src="/images/408483-20180923150858602-1272873115.jpg" alt="img"></p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>