<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.sqlalchemy.org/en/11/orm/query.html#sqlalchemy.orm.query.Query.join&quot;&gt;Query API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.xncoding.com/2016/03/07/python/sqlalchemy02.html&quot;&gt;SQLAlchemy进阶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/chenmozhe22/article/details/95763090&quot;&gt;relationship的参数backref和back_populates的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;建表&quot;&gt;&lt;a href=&quot;#建表&quot; class=&quot;headerlink&quot; title=&quot;建表&quot;&gt;&lt;/a&gt;建表&lt;/h2&gt;&lt;h3 id=&quot;Many-to-Many&quot;&gt;&lt;a href=&quot;#Many-to-Many&quot; class=&quot;headerlink&quot; title=&quot;Many to Many&quot;&gt;&lt;/a&gt;Many to Many&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;多对多添加了两个类之间的关联表。关联表由的&lt;a href=&quot;https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary&quot;&gt;&lt;code&gt;secondary&lt;/code&gt;&lt;/a&gt;参数表示 &lt;a href=&quot;https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship&quot;&gt;&lt;code&gt;relationship()&lt;/code&gt;&lt;/a&gt;。通常，&lt;a href=&quot;https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.Table&quot;&gt;&lt;code&gt;Table&lt;/code&gt;&lt;/a&gt;会使用&lt;a href=&quot;https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData&quot;&gt;&lt;code&gt;MetaData&lt;/code&gt;&lt;/a&gt; ，以便&lt;a href=&quot;https://docs.sqlalchemy.org/en/13/core/constraints.html#sqlalchemy.schema.ForeignKey&quot;&gt;&lt;code&gt;ForeignKey&lt;/code&gt;&lt;/a&gt; 指令可以找到要链接的远程表：&lt;/li&gt;
&lt;li&gt;对于双向关系，关系的双方都包含一个集合。使用指定&lt;a href=&quot;https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates&quot;&gt;&lt;code&gt;relationship.back_populates&lt;/code&gt;&lt;/a&gt;，并为每个&lt;a href=&quot;https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship&quot;&gt;&lt;code&gt;relationship()&lt;/code&gt;&lt;/a&gt;指定通用关联表：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;association_table = Table(&lt;span class=&quot;string&quot;&gt;&amp;#x27;association&amp;#x27;&lt;/span&gt;, Base.metadata,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Column(&lt;span class=&quot;string&quot;&gt;&amp;#x27;left_id&amp;#x27;&lt;/span&gt;, Integer, ForeignKey(&lt;span class=&quot;string&quot;&gt;&amp;#x27;left.id&amp;#x27;&lt;/span&gt;)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Column(&lt;span class=&quot;string&quot;&gt;&amp;#x27;right_id&amp;#x27;&lt;/span&gt;, Integer, ForeignKey(&lt;span class=&quot;string&quot;&gt;&amp;#x27;right.id&amp;#x27;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;Base&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __tablename__ = &lt;span class=&quot;string&quot;&gt;&amp;#x27;left&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;id&lt;/span&gt; = Column(Integer, primary_key=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    children = relationship(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&amp;quot;Child&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        secondary=association_table,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        back_populates=&lt;span class=&quot;string&quot;&gt;&amp;quot;parents&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;Base&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __tablename__ = &lt;span class=&quot;string&quot;&gt;&amp;#x27;right&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;id&lt;/span&gt; = Column(Integer, primary_key=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    parents = relationship(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&amp;quot;Parent&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        secondary=association_table,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        back_populates=&lt;span class=&quot;string&quot;&gt;&amp;quot;children&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多对多需要一个联系表association_table , 这张联系表其实是一张虚拟表 ."><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>SQLAlchemy进阶 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2020-04-20</div></div></div><div class="container post-header"><h1>SQLAlchemy进阶</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">建表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Many-to-Many"><span class="toc-number">1.1.1.</span> <span class="toc-text">Many to Many</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#One-to-Many"><span class="toc-number">1.1.2.</span> <span class="toc-text">One to Many</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Many-to-One"><span class="toc-number">1.1.3.</span> <span class="toc-text">Many to One</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#One-to-One"><span class="toc-number">1.1.4.</span> <span class="toc-text">One to One</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8session%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">对象在session中的四种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.</span> <span class="toc-text">关联查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#back-populates%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">back_populates参数的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#relationship%E7%9A%84%E5%8F%82%E6%95%B0backref%E5%92%8Cback-populates%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">relationship的参数backref和back_populates的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#remote-side-%E5%A4%96%E9%94%AE%E5%BC%95%E7%94%A8%E7%9A%84%E6%98%AF%E8%87%AA%E8%BA%AB"><span class="toc-number">1.6.</span> <span class="toc-text">remote_side : 外键引用的是自身</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/11/orm/query.html#sqlalchemy.orm.query.Query.join">Query API</a></li>
<li><a target="_blank" rel="noopener" href="https://www.xncoding.com/2016/03/07/python/sqlalchemy02.html">SQLAlchemy进阶</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenmozhe22/article/details/95763090">relationship的参数backref和back_populates的区别</a></li>
</ul>
<h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><h3 id="Many-to-Many"><a href="#Many-to-Many" class="headerlink" title="Many to Many"></a>Many to Many</h3><ul>
<li>多对多添加了两个类之间的关联表。关联表由的<a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary"><code>secondary</code></a>参数表示 <a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship"><code>relationship()</code></a>。通常，<a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.Table"><code>Table</code></a>会使用<a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData"><code>MetaData</code></a> ，以便<a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/core/constraints.html#sqlalchemy.schema.ForeignKey"><code>ForeignKey</code></a> 指令可以找到要链接的远程表：</li>
<li>对于双向关系，关系的双方都包含一个集合。使用指定<a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates"><code>relationship.back_populates</code></a>，并为每个<a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship"><code>relationship()</code></a>指定通用关联表：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">association_table = Table(<span class="string">&#x27;association&#x27;</span>, Base.metadata,</span><br><span class="line">    Column(<span class="string">&#x27;left_id&#x27;</span>, Integer, ForeignKey(<span class="string">&#x27;left.id&#x27;</span>)),</span><br><span class="line">    Column(<span class="string">&#x27;right_id&#x27;</span>, Integer, ForeignKey(<span class="string">&#x27;right.id&#x27;</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;left&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    children = relationship(</span><br><span class="line">        <span class="string">&quot;Child&quot;</span>,</span><br><span class="line">        secondary=association_table,</span><br><span class="line">        back_populates=<span class="string">&quot;parents&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;right&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parents = relationship(</span><br><span class="line">        <span class="string">&quot;Parent&quot;</span>,</span><br><span class="line">        secondary=association_table,</span><br><span class="line">        back_populates=<span class="string">&quot;children&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>多对多需要一个联系表association_table , 这张联系表其实是一张虚拟表 .</p>
<blockquote>
<p> secondary: 多对多指定中间表关键字</p>
<p>backref:  在一对多或多对一之间建立双向关系</p>
</blockquote>
</li>
<li><p><code>children = relationship(&quot;Child&quot;,secondary=association_table,back_populates=&quot;parents&quot;)</code> : Parent表的children字段通过association_table联系表 , 链接到Child表的parents字段</p>
<p>这样,Parent表就可以通过<code>Parent.children.id </code>获取到孩子的id了</p>
</li>
<li><p>同理<code>parents = relationship(&quot;Parent&quot;,secondary=association_table,back_populates=&quot;children&quot;)</code> : Child表的parents字段通过association_table联系表 , 链接到Parent表的children字段. 这样,Child表就可以通过<code>Child.parents.id</code>获取到父母的id了</p>
</li>
</ol>
<blockquote>
<p>结论 : <code>children = relationship(&quot;Child&quot;,secondary=association_table,back_populates=&quot;parents&quot;)</code>的直接作用就是说 : 使得Child表成为Parent表的children字段 , 也就是说,通过Parent表的children字段就可以获取到Child表</p>
</blockquote>
<p>当使用<a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref"><code>backref</code></a>参数代替时 <a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates"><code>relationship.back_populates</code></a>，backref将自动<a target="_blank" rel="noopener" href="https://docs.sqlalchemy.org/en/13/orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary"><code>secondary</code></a>为反向关系使用相同的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">association_table = Table(<span class="string">&#x27;association&#x27;</span>, Base.metadata,</span><br><span class="line">    Column(<span class="string">&#x27;left_id&#x27;</span>, Integer, ForeignKey(<span class="string">&#x27;left.id&#x27;</span>)),</span><br><span class="line">    Column(<span class="string">&#x27;right_id&#x27;</span>, Integer, ForeignKey(<span class="string">&#x27;right.id&#x27;</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;left&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    children = relationship(<span class="string">&quot;Child&quot;</span>,</span><br><span class="line">                    secondary=association_table,</span><br><span class="line">                    backref=<span class="string">&quot;parents&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;right&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h3 id="One-to-Many"><a href="#One-to-Many" class="headerlink" title="One to Many"></a>One to Many</h3><p>表示一对多的关系时，在子表类中通过 foreign key引用父表类。然后，在父表类中通过 relationship() 方法来引用子表的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    children = relationship(<span class="string">&quot;Child&quot;</span>)</span><br><span class="line">    <span class="comment"># 在父表类中通过 relationship() 方法来引用子表的类集合</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;parent.id&#x27;</span>))</span><br><span class="line">    <span class="comment"># 在子表类中通过 foreign key (外键)引用父表的参考字段</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Parent表通过<code>Parent.children</code>获取Child表</li>
<li>Child表通过<code>Child.parent_id</code>获取Parent表的children字段</li>
</ul>
<blockquote>
<p><code>relationship</code>和<code> foreign key</code>总结:</p>
<ol>
<li>父表类中通过 relationship() 方法来引用<code>子表的类集合</code></li>
<li>子表类中通过 foreign key引用父表的参考<code>字段</code></li>
</ol>
<p>也就是说 , <strong>外键就只是<code>约束</code>而已</strong>,relationship可以获取子表的集合</p>
</blockquote>
<h3 id="Many-to-One"><a href="#Many-to-One" class="headerlink" title="Many to One"></a>Many to One</h3><p>在一对多的关系中建立双向的关系，这样的话在对方看来这就是一个多对一的关系， 在子表类中附加一个<code>relationship()</code>方法，并且在双方的<code>relationship()</code>方法中使用<code>relationship.back_populates</code>方法参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    children = relationship(<span class="string">&quot;Child&quot;</span>, back_populates=<span class="string">&quot;parent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;parent.id&#x27;</span>))</span><br><span class="line">    parent = relationship(<span class="string">&quot;Parent&quot;</span>, back_populates=<span class="string">&quot;children&quot;</span>)</span><br><span class="line">    <span class="comment"># 子表类中附加一个 relationship() 方法</span></span><br><span class="line">    <span class="comment"># 并且在(父)子表类的 relationship() 方法中使用 relationship.back_populates 参数</span></span><br></pre></td></tr></table></figure>

<p>这样的话子表将会在多对一的关系中获得父表的属性</p>
<p>或者，可以在单一的<code>relationship()</code>方法中使用<code>backref</code>参数来代替<code>back_populates</code>参数， 推荐使用这种方式，可以少些几句话。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    children = relationship(<span class="string">&quot;Child&quot;</span>, backref=<span class="string">&quot;parent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;parent.id&#x27;</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用backref , 对方就不必再写一个relationship了</p>
</blockquote>
<h3 id="One-to-One"><a href="#One-to-One" class="headerlink" title="One to One"></a>One to One</h3><p>一对一就是多对一和一对多的一个特例,只需在relationship加上一个参数uselist=False替换多的一端就是一对一</p>
<p>从一对多转换到一对一 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    child = relationship(<span class="string">&quot;Child&quot;</span>, uselist=<span class="literal">False</span>, backref=<span class="string">&quot;parent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;parent.id&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>从多对一转换到一对一 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    child_id = Column(Integer, ForeignKey(<span class="string">&#x27;child.id&#x27;</span>))</span><br><span class="line">    child = relationship(<span class="string">&quot;Child&quot;</span>, backref=backref(<span class="string">&quot;parent&quot;</span>, uselist=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h2 id="对象在session中的四种状态"><a href="#对象在session中的四种状态" class="headerlink" title="对象在session中的四种状态"></a>对象在session中的四种状态</h2><ul>
<li>Transient：实例还不在session中，还没有保存到数据库中去，没有数据库身份，想刚创建出来的对象比如User()，仅仅只有mapper()与之关联</li>
<li>Pending：用add()一个transient对象后，就变成了一个pending对象，这时候仍然没有flushed到数据库中去，直到flush发生。</li>
<li>Persistent：实例出现在session中而且在数据库中也有记录了，通常是通过flush一个pending实例变成Persistent或者从数据库中querying一个已经存在的实例。</li>
<li>Detached：一个对象它有记录在数据库中，但是不在任何session中，</li>
</ul>
<h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><p>外键查询</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.query(User).join(Address).<span class="built_in">filter</span>(Address.email==<span class="string">&#x27;lzjun@qq.com&#x27;</span>).<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure>

<p>指定ON字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = session.query(User).join(Address, User.<span class="built_in">id</span>==Address.user_id)</span><br></pre></td></tr></table></figure>

<p>多个join :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q = session.query(User).join(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;items&quot;</span>, <span class="string">&quot;keywords&quot;</span>)</span><br><span class="line">q = session.query(User).join(User.orders).join(Order.items).join(Item.keywords)</span><br></pre></td></tr></table></figure>

<p>子查询JOIN：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address_subq = session.query(Address).<span class="built_in">filter</span>(Address.email_address == <span class="string">&#x27;ed@foo.com&#x27;</span>).subquery()</span><br><span class="line">q = session.query(User).join(address_subq, User.addresses)</span><br></pre></td></tr></table></figure>

<p>join from:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = session.query(Address).select_from(User).join(User.addresses).<span class="built_in">filter</span>(User.name == <span class="string">&#x27;ed&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和下面的SQL等价：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> address.<span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line"><span class="keyword">user</span> <span class="keyword">JOIN</span> address <span class="keyword">ON</span> user.id<span class="operator">=</span>address.user_id </span><br><span class="line"><span class="keyword">WHERE</span> user.name <span class="operator">=</span> :name_1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>左外连接，指定<code>isouter=True</code>，等价于<code>Query.outerjoin()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = session.query(Node).join(<span class="string">&quot;children&quot;</span>, <span class="string">&quot;children&quot;</span>, aliased=<span class="literal">True</span>, isouter=<span class="literal">True</span>).<span class="built_in">filter</span>(Node.name == <span class="string">&#x27;grandchild 1&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="back-populates参数的作用"><a href="#back-populates参数的作用" class="headerlink" title="back_populates参数的作用"></a>back_populates参数的作用</h2><p>back_populates , 顾名思义, 就是向后填充数据的意思</p>
<p>简单来说 : 就是提供双向绑定 , <strong>当一方修改的时候通知另一方进行修改</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    children = relationship(<span class="string">&quot;Child&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;parent.id&#x27;</span>))</span><br><span class="line">    parent = relationship(<span class="string">&quot;Parent&quot;</span>)</span><br></pre></td></tr></table></figure>

<p> 如果没有提供back_populates参数 , 在修改Child实例的parent属性后 , <strong>并不会修改Parent实例的child属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parent = Parent()</span><br><span class="line">&gt;&gt;&gt; child = Child()</span><br><span class="line">&gt;&gt;&gt; child.parent = parent</span><br><span class="line">&gt;&gt;&gt; print parent.children</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>现在看看添加了back_populates参数 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    children = relationship(<span class="string">&quot;Child&quot;</span>, back_populates=<span class="string">&quot;parent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;parent.id&#x27;</span>))</span><br><span class="line">    parent = relationship(<span class="string">&quot;Parent&quot;</span>, back_populates=<span class="string">&quot;children&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parent = Parent()</span><br><span class="line">&gt;&gt;&gt; child = Child()</span><br><span class="line">&gt;&gt;&gt; child.parent = parent</span><br><span class="line">&gt;&gt;&gt; print parent.children</span><br><span class="line">[Child(...)]</span><br></pre></td></tr></table></figure>

<p>也就是说 , back_populates的值一定是另一个Class的属性值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span>:</span></span><br><span class="line">	attr1 = relationship(<span class="string">&quot;class2&quot;</span>, back_populates=<span class="string">&quot;attr2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class2</span>:</span></span><br><span class="line">	attr2 = relationship(<span class="string">&quot;class1&quot;</span>, back_populates=<span class="string">&quot;attr1&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="relationship的参数backref和back-populates的区别"><a href="#relationship的参数backref和back-populates的区别" class="headerlink" title="relationship的参数backref和back_populates的区别"></a>relationship的参数backref和back_populates的区别</h2><ol>
<li>有关backref和back_populates的作用，都是<strong>在一对多或多对多查询的时候。设置一个值，这个值用来从一个表格对象指向到另一个对象</strong>，只是用法稍微有点差别。</li>
<li>backref是新式的方法，back_populates是老式的方法，但是目前都可以使用</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">from</span> APP.app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line">association_table = db.Table(<span class="string">&#x27;association&#x27;</span>,</span><br><span class="line">                             db.Column(<span class="string">&#x27;id&#x27;</span>, db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>),</span><br><span class="line">                             db.Column(<span class="string">&#x27;customer_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="string">&#x27;customer.id&#x27;</span>)),</span><br><span class="line">                             db.Column(<span class="string">&#x27;product_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="string">&#x27;product.id&#x27;</span>))</span><br><span class="line">                             )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;customer&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">10</span>))</span><br><span class="line">    work = db.Column(db.String(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    customer_to_product = db.relationship(<span class="string">&#x27;Product&#x27;</span>, secondary=association_table,</span><br><span class="line">                                          back_populates=<span class="string">&#x27;product_to_customer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;name：&#123;name&#125; work：&#123;work&#125;&#x27;</span>.<span class="built_in">format</span>(name=self.name, work=self.work)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;product&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">10</span>))</span><br><span class="line">    price = db.Column(db.Float)</span><br><span class="line"></span><br><span class="line">    product_to_customer = db.relationship(<span class="string">&#x27;Customer&#x27;</span>, secondary=association_table,</span><br><span class="line">                                          back_populates=<span class="string">&#x27;customer_to_product&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;name：&#123;name&#125; price：&#123;price&#125;&#x27;</span>.<span class="built_in">format</span>(name=self.name, price=self.price)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = <span class="string">&#x27;司马老板&#x27;</span></span><br><span class="line">ct = Customer.query.filter_by(name=key).first()</span><br><span class="line"><span class="built_in">print</span>(ct, <span class="built_in">type</span>(ct))</span><br><span class="line"></span><br><span class="line">p = ct.customer_to_product</span><br><span class="line"><span class="built_in">print</span>(p, <span class="built_in">type</span>(p))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">    <span class="built_in">print</span>(i.name, i.price)</span><br></pre></td></tr></table></figure>

<ul>
<li>在多对多的关系中，需要在2个表格里面，如果使用back_populates，需要2个类里面同时使用关系指向。</li>
<li>2个类里面的关系指向，字段名称一致,例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如，在Customer类里面</span></span><br><span class="line">customer_to_product = db.relationship(<span class="string">&#x27;Product&#x27;</span>, secondary=association_table,</span><br><span class="line">                                          back_populates=<span class="string">&#x27;product_to_customer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如，在Product类里面</span></span><br><span class="line">product_to_customer = db.relationship(<span class="string">&#x27;Customer&#x27;</span>, secondary=association_table,</span><br><span class="line">                                          back_populates=<span class="string">&#x27;customer_to_product&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="remote-side-外键引用的是自身"><a href="#remote-side-外键引用的是自身" class="headerlink" title="remote_side : 外键引用的是自身"></a>remote_side : 外键引用的是自身</h2><p><code>remote_side</code> : 表中的外键引用的是自身时,如Node类,如果想表示多对一的关系,那么就可以使用remote_side</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;node.id&#x27;</span>))</span><br><span class="line">    data = Column(String(<span class="number">50</span>))</span><br><span class="line">    parent = relationship(<span class="string">&quot;Node&quot;</span>, remote_side=[<span class="built_in">id</span>])</span><br></pre></td></tr></table></figure>

<p>如果是想建立一种双向的关系,那么还是结合backref:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">&#x27;node.id&#x27;</span>))</span><br><span class="line">    data = Column(String(<span class="number">50</span>))</span><br><span class="line">    children = relationship(</span><br><span class="line">        <span class="string">&quot;Node&quot;</span>,</span><br><span class="line">                backref=backref(<span class="string">&#x27;parent&#x27;</span>, remote_side=[<span class="built_in">id</span>])</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>