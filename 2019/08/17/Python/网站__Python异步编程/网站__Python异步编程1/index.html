<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="网址"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Python异步编程1 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2019-08-17</div></div></div><div class="container post-header"><h1>Python异步编程1</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD"><span class="toc-number">1.</span> <span class="toc-text">线程的状态判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%B5%8C%E5%A5%97%E4%B8%8E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-Rlock"><span class="toc-number">2.</span> <span class="toc-text">锁嵌套与可重入锁(Rlock)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%AD%BB%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">防止死锁的加锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ThreadLocal%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">使用ThreadLocal对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E6%9D%A5%E5%AF%B9%E9%94%81%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">辅助函数来对锁进行排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E4%BB%BB%E5%8A%A1%E5%8D%8F%E8%B0%83"><span class="toc-number">4.</span> <span class="toc-text">线程消息通信机制任务协调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Event%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">Event事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition"><span class="toc-number">4.2.</span> <span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue%E9%98%9F%E5%88%97"><span class="toc-number">4.3.</span> <span class="toc-text">Queue队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA"><span class="toc-number">4.3.2.</span> <span class="toc-text">消息队列的先进先出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E9%9A%94%E7%A6%BB"><span class="toc-number">5.</span> <span class="toc-text">线程中的信息隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">创建线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8map%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">使用map方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8submit%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">使用submit方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.3.</span> <span class="toc-text">自定义线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">迭代器和可迭代对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%B4%BE%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">委派生成器的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asyncio%E6%A1%86%E6%9E%B6"><span class="toc-number">9.</span> <span class="toc-text">asyncio框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#await%E5%92%8Cyield-from%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.</span> <span class="toc-text">await和yield from的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gather%E4%B8%8Ewait%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">9.2.</span> <span class="toc-text">gather与wait的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.1.</span> <span class="toc-text">接收参数方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait%E6%9C%89%E6%8E%A7%E5%88%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">9.2.2.</span> <span class="toc-text">wait有控制功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%8D%8F%E7%A8%8B"><span class="toc-number">9.3.</span> <span class="toc-text">动态添加协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%EF%BC%9A%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1"><span class="toc-number">9.4.</span> <span class="toc-text">实战：利用redis实现动态添加任务</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>网址</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wongbingming/p/9028851.html4">https://www.cnblogs.com/wongbingming/p/9028851.html4</a></p>
<h2 id="线程的状态判断"><a href="#线程的状态判断" class="headerlink" title="线程的状态判断"></a>线程的状态判断</h2><p>使用<code>t.is_alive()</code>判断线程的状态</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>():</span></span><br><span class="line">    time.sleep(<span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;this is in printer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t = Thread(target=printer)</span><br><span class="line"><span class="built_in">print</span>(t.is_alive())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">t.start()</span><br><span class="line"><span class="built_in">print</span>(t.is_alive())  <span class="comment"># True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="锁嵌套与可重入锁-Rlock"><a href="#锁嵌套与可重入锁-Rlock" class="headerlink" title="锁嵌套与可重入锁(Rlock)"></a>锁嵌套与可重入锁(Rlock)</h2><p>有时候在同一个线程中，我们可能会多次请求同一资源（就是，获取同一锁钥匙），俗称<code>锁嵌套</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=main)</span><br><span class="line">t1.start()</span><br></pre></td></tr></table></figure>

<p>因为第二次获取锁时，发现锁已经被同一线程的人拿走了。自己也就理所当然，拿不到锁，程序就卡住了。<br><code>threading</code>模块除了提供<code>Lock</code>锁之外，还提供了一种可重入锁<code>RLock</code>，专门来处理这个问题。</p>
<blockquote>
<p>线程A获得可以重用锁，并<strong>可以多次成功获取，不会阻塞</strong>。<br>最后要在线程A中<strong>acquire次数要和release相同</strong>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 生成可重入锁对象</span></span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=main)</span><br><span class="line">t1.start()</span><br><span class="line"><span class="comment"># 1 2 3 4 5 6 8 9 10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可重入锁，<strong>只在同一线程里</strong>，放松对锁钥匙的获取，其他与<code>Lock</code>并无二致。</p>
</blockquote>
<h2 id="防止死锁的加锁机制"><a href="#防止死锁的加锁机制" class="headerlink" title="防止死锁的加锁机制"></a>防止死锁的加锁机制</h2><p>死锁通常以下两种:</p>
<ol>
<li>同一线程，嵌套获取同把锁。</li>
<li>多个线程，不按顺序同时获取多个锁。</li>
</ol>
<h3 id="使用ThreadLocal对象"><a href="#使用ThreadLocal对象" class="headerlink" title="使用ThreadLocal对象"></a>使用ThreadLocal对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x += n</span><br><span class="line">    x -= n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 给local对象增加一个x属性</span></span><br><span class="line">    <span class="comment"># 每个线程都有local.x,就是线程的局部变量</span></span><br><span class="line">    local.x = num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        run(local.x,n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread().name&#125;</span>------<span class="subst">&#123;local.x&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个全局的ThreadLocal对象</span></span><br><span class="line">    <span class="comment"># 每个线程有独立的存储空间</span></span><br><span class="line">    <span class="comment"># 每个线程对ThreadLocal对象都可以读写,但是互不影响</span></span><br><span class="line">    <span class="comment"># 简单来说,就像进程一样,让不同的线程备份一个一模一样的变量</span></span><br><span class="line">    local = threading.local()</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    t1 = threading.Thread(target=func,args=(<span class="number">6</span>,))</span><br><span class="line">    t2 = threading.Thread(target=func,args=(<span class="number">9</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Thread-2------0</span></span><br><span class="line"><span class="comment"># Thread-1------0</span></span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用诀窍 : 只要<strong>修改线程对应的函数里需要锁定的变量</strong>即可</p>
</blockquote>
<blockquote>
<p>只要两个（或多个）线程获取嵌套锁时，按照固定顺序就能保证程序不会进入死锁状态。</p>
</blockquote>
<h3 id="辅助函数来对锁进行排序"><a href="#辅助函数来对锁进行排序" class="headerlink" title="辅助函数来对锁进行排序"></a>辅助函数来对锁进行排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_local = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire</span>(<span class="params">*locks</span>):</span></span><br><span class="line">    <span class="comment"># 按对象标识符对锁排序</span></span><br><span class="line">    locks = <span class="built_in">sorted</span>(locks, key=<span class="keyword">lambda</span> x: <span class="built_in">id</span>(x))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保不违反 以前获取的锁的顺序</span></span><br><span class="line">    acquired = <span class="built_in">getattr</span>(_local,<span class="string">&#x27;acquired&#x27;</span>,[])</span><br><span class="line">    <span class="keyword">if</span> acquired <span class="keyword">and</span> <span class="built_in">max</span>(<span class="built_in">id</span>(lock) <span class="keyword">for</span> lock <span class="keyword">in</span> acquired) &gt;= <span class="built_in">id</span>(locks[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;锁定顺序冲突&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取所有锁</span></span><br><span class="line">    acquired.extend(locks)</span><br><span class="line">    _local.acquired = acquired</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> lock <span class="keyword">in</span> locks:</span><br><span class="line">            lock.acquire()</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 按采集的相反顺序释放锁</span></span><br><span class="line">        <span class="keyword">for</span> lock <span class="keyword">in</span> <span class="built_in">reversed</span>(locks):</span><br><span class="line">            lock.release()</span><br><span class="line">        <span class="keyword">del</span> acquired[-<span class="built_in">len</span>(locks):]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	x_lock = threading.Lock()</span><br><span class="line">	y_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">thread_1</span>():</span></span><br><span class="line">	    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	        <span class="keyword">with</span> acquire(x_lock):</span><br><span class="line">	            <span class="keyword">with</span> acquire(y_lock):</span><br><span class="line">	                <span class="built_in">print</span>(<span class="string">&#x27;Thread-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">thread_2</span>():</span></span><br><span class="line">	    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	        <span class="keyword">with</span> acquire(y_lock):</span><br><span class="line">	            <span class="keyword">with</span> acquire(x_lock):</span><br><span class="line">	                <span class="built_in">print</span>(<span class="string">&#x27;Thread-2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	t1 = threading.Thread(target=thread_1)</span><br><span class="line">	t1.daemon = <span class="literal">True</span></span><br><span class="line">	t1.start()</span><br><span class="line"></span><br><span class="line">	t2 = threading.Thread(target=thread_2)</span><br><span class="line">	t2.daemon = <span class="literal">True</span></span><br><span class="line">	t2.start()</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>表面上<code>thread_1</code>的先获取锁x，再获取锁<code>y</code>，而<code>thread_2</code>是先获取锁<code>y</code>，再获取<code>x</code>。</li>
<li>实际上，<code>acquire</code>函数，已经对<code>x</code>，<code>y</code>两个锁进行了排序。</li>
<li>所以<code>thread_1</code>，<code>hread_2</code>都是以同一顺序来获取锁的，是不是造成死锁的。</li>
</ul>
</blockquote>
<h2 id="线程消息通信机制任务协调"><a href="#线程消息通信机制任务协调" class="headerlink" title="线程消息通信机制任务协调"></a>线程消息通信机制任务协调</h2><p>要实现对多个线程进行控制，其实本质上就是消息通信机制在起作用，利用这个机制发送指令，告诉线程，什么时候可以执行，什么时候不可以执行，执行什么内容。</p>
<p>线程中通信方法大致有如下三种：</p>
<ul>
<li>threading.Event</li>
<li>threading.Condition</li>
<li>queue.Queue</li>
</ul>
<h3 id="Event事件"><a href="#Event事件" class="headerlink" title="Event事件"></a>Event事件</h3><ul>
<li>Python提供了非常简单的通信机制 <code>Threading.Event</code>，通用的条件变量。</li>
<li>多个线程可以<code>等待某个事件的发生</code>，在事件发生后，<code>所有的线程</code>都会被<code>激活</code>。</li>
</ul>
<p>Event的三个函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置event，使得所有该event事件都处于待命状态</span></span><br><span class="line">event.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待接收event的指令，决定是否阻塞程序执行</span></span><br><span class="line">event.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送event指令，使所有设置该event事件的线程执行</span></span><br><span class="line">event.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单来说就是:</p>
<ol>
<li>event.clear() : 重置event</li>
<li>event.wait() : 阻塞线程</li>
<li>event.set() : 解阻塞线程</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, event</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">        self.event = event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Thread: &#123;&#125; start at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name, time.ctime(time.time())))</span><br><span class="line">        <span class="comment"># 等待event.set()后，才能往下执行</span></span><br><span class="line">        self.event.wait()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Thread: &#123;&#125; finish at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name, time.ctime(time.time())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义五个线程</span></span><br><span class="line">[threads.append(MyThread(<span class="built_in">str</span>(i), event)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置event，使得event.wait()起到阻塞作用</span></span><br><span class="line">event.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动所有线程</span></span><br><span class="line">[t.start() <span class="keyword">for</span> t <span class="keyword">in</span> threads]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;等待5s...&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;唤醒所有线程...&#x27;</span>)</span><br><span class="line">event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Thread: 1 start at Fri Jul 12 20:50:33 2019</span></span><br><span class="line"><span class="comment"># Thread: 2 start at Fri Jul 12 20:50:33 2019</span></span><br><span class="line"><span class="comment"># Thread: 3 start at Fri Jul 12 20:50:33 2019</span></span><br><span class="line"><span class="comment"># Thread: 4 start at Fri Jul 12 20:50:33 2019</span></span><br><span class="line"><span class="comment"># 等待5s...</span></span><br><span class="line"><span class="comment"># 唤醒所有线程...</span></span><br><span class="line"><span class="comment"># Thread: 1 finish at Fri Jul 12 20:50:38 2019</span></span><br><span class="line"><span class="comment"># Thread: 2 finish at Fri Jul 12 20:50:38 2019</span></span><br><span class="line"><span class="comment"># Thread: 3 finish at Fri Jul 12 20:50:38 2019</span></span><br><span class="line"><span class="comment"># Thread: 4 finish at Fri Jul 12 20:50:38 2019</span></span><br></pre></td></tr></table></figure>



<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>Condition和Event 是类似的，并没有多大区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cond = threading.Condition()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似lock.acquire()</span></span><br><span class="line">cond.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似lock.release()</span></span><br><span class="line">cond.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待指定触发，同时会解锁,直到被notify才重新占有锁。</span></span><br><span class="line"><span class="comment"># 线程挂起，直到收到一个notify通知才会被唤醒继续运行</span></span><br><span class="line">cond.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送指定，触发执行</span></span><br><span class="line"><span class="comment"># 通知其他线程执行代码，那些挂起的线程接到这个通知之后会开始运行</span></span><br><span class="line">cond.notify()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果wait状态线程比较多，notifyAll的作用就是通知所有线程</span></span><br><span class="line">cond.notifyAll()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hider</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cond, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Hider, self).__init__()</span><br><span class="line">        self.cond = cond</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment">#确保先运行Seeker中的方法</span></span><br><span class="line">        self.cond.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 我已经把眼睛蒙上了&#x27;</span>)</span><br><span class="line">        self.cond.notify()</span><br><span class="line">        self.cond.wait()</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 我找到你了哦 ~_~&#x27;</span>)</span><br><span class="line">        self.cond.notify() </span><br><span class="line"></span><br><span class="line">        self.cond.release()</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 我赢了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seeker</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cond, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Seeker, self).__init__()</span><br><span class="line">        self.cond = cond</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.cond.acquire()</span><br><span class="line">        self.cond.wait()</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 我已经藏好了，你快来找我吧&#x27;</span>)</span><br><span class="line">        self.cond.notify()</span><br><span class="line">        self.cond.wait()</span><br><span class="line">        self.cond.release()</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 被你找到了，哎~~~&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cond = threading.Condition()</span><br><span class="line">seeker = Seeker(cond, <span class="string">&#x27;seeker&#x27;</span>)</span><br><span class="line">hider = Hider(cond, <span class="string">&#x27;hider&#x27;</span>)</span><br><span class="line">seeker.start()</span><br><span class="line">hider.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># hider: 我已经把眼睛蒙上了</span></span><br><span class="line"><span class="comment"># seeker: 我已经藏好了，你快来找我吧</span></span><br><span class="line"><span class="comment"># hider: 我找到你了哦 ~_~</span></span><br><span class="line"><span class="comment"># hider: 我赢了</span></span><br><span class="line"><span class="comment"># seeker: 被你找到了，哎~~~</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<ol>
<li>必须先要获取锁<code>self.cond.acquire()</code>后,才能使用<code>self.cond.wait()</code>和<code>self.cond.notify()</code>.而且,最后还要解开锁<code>self.cond.release()</code></li>
<li>所以,我们一样可以使用上下文管理器<code>with cond</code></li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">with</span> cond:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;hello1&#x27;</span>)</span><br><span class="line">			cond.notify()</span><br><span class="line">			cond.wait()</span><br><span class="line">			<span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">with</span> cond:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">			cond.wait()</span><br><span class="line">			cond.notify()</span><br><span class="line">			<span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	cond = threading.Condition()</span><br><span class="line">	You().start()</span><br><span class="line">	Me().start()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<strong>两个线程的启动顺序一定不能颠倒</strong><br>因为先启动的线程可能直到发完notify通知了，另一个线程才开始启动，一直处于状态，造成的结果就是<strong>2根线程就一直在那挂起</strong>.</p>
</blockquote>
<h3 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h3><p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 queue 库中的队列了。创建一个被多个线程共享的 Queue 对象，这些线程通过使用<code>put()</code> 和 <code>get()</code> 操作来向队列中添加或者删除元素。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="comment"># maxsize默认为0，不受限</span></span><br><span class="line"><span class="comment"># 一旦&gt;0，而消息数又达到限制，q.put()也将阻塞</span></span><br><span class="line">q = Queue(maxsize=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞程序，等待队列消息。</span></span><br><span class="line">q.get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取消息，设置超时时间</span></span><br><span class="line">q.get(timeout=<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">q.put()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有的消息都被消费完</span></span><br><span class="line">q.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下三个方法，知道就好，代码中不要使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询当前队列的消息个数</span></span><br><span class="line">q.qsize()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列消息是否都被消费完，True/False</span></span><br><span class="line">q.empty()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测队列里消息是否已满</span></span><br><span class="line">q.full()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, queue</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">        self.queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 阻塞程序，时刻监听老师，接收消息</span></span><br><span class="line">            msg = self.queue.get()</span><br><span class="line">            <span class="comment"># 一旦发现点到自己名字，就赶紧答到</span></span><br><span class="line">            <span class="keyword">if</span> msg == self.name:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;：到！&quot;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, queue</span>):</span></span><br><span class="line">        self.queue=queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, student_name</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;老师：&#123;&#125;来了没？&quot;</span>.<span class="built_in">format</span>(student_name))</span><br><span class="line">        <span class="comment"># 发送消息，要点谁的名</span></span><br><span class="line">        self.queue.put(student_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue = Queue()</span><br><span class="line">teacher = Teacher(queue=queue)</span><br><span class="line">s1 = Student(name=<span class="string">&quot;小明&quot;</span>, queue=queue).start()</span><br><span class="line">s2 = Student(name=<span class="string">&quot;小亮&quot;</span>, queue=queue).start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;开始点名~&#x27;</span>)</span><br><span class="line">teacher.call(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">teacher.call(<span class="string">&#x27;小亮&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始点名~</span></span><br><span class="line"><span class="comment"># 老师：小明来了没？</span></span><br><span class="line"><span class="comment"># 小明：到！</span></span><br><span class="line"><span class="comment"># 老师：小亮来了没？</span></span><br><span class="line"><span class="comment"># 小亮：到！</span></span><br></pre></td></tr></table></figure>

<h4 id="消息队列的先进先出"><a href="#消息队列的先进先出" class="headerlink" title="消息队列的先进先出"></a>消息队列的先进先出</h4><p>消息队列不只有<code>queue.Queue</code>这一个类，还有<code>queue.LifoQueue</code>和<code>queue.PriorityQueue</code>这两个类</p>
<blockquote>
<p><code>queue.Queue</code>：先进先出队列 : 先进入队列的消息，将优先被消费。<br><code>queue.LifoQueue</code>：后进先出队列<br><code>queue.PriorityQueue</code>：优先级队列</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    <span class="built_in">print</span>(q.get())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.LifoQueue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    <span class="built_in">print</span> q.get()</span><br></pre></td></tr></table></figure>









<h2 id="线程中的信息隔离"><a href="#线程中的信息隔离" class="headerlink" title="线程中的信息隔离"></a>线程中的信息隔离</h2><blockquote>
<p><code>信息隔离</code> : 有两个线程，线程A里的变量，和线程B里的变量值不能共享。</p>
<p>使用<code>threading.local</code>类，可以很方便的控制变量的隔离，即使是同一个变量，在不同的线程中，其值也是不能共享的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> local, Thread, currentThread</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;赋值前-子线程：&quot;</span>, currentThread(),local_data.__dict__)</span><br><span class="line">        <span class="comment"># 在子线程中存入name这个变量</span></span><br><span class="line">        local_data.name = self.getName()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;赋值后-子线程：&quot;</span>,currentThread(), local_data.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	<span class="comment"># 定义一个local实例</span></span><br><span class="line">	local_data = local()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;开始前-主线程：&quot;</span>,local_data.__dict__)</span><br><span class="line"></span><br><span class="line">	t1 = MyThread()</span><br><span class="line">	t1.start()</span><br><span class="line">	t1.join()</span><br><span class="line"></span><br><span class="line">	t2 = MyThread()</span><br><span class="line">	t2.start()</span><br><span class="line">	t2.join()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;结束后-主线程：&quot;</span>,local_data.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始前-主线程： &#123;&#125;</span></span><br><span class="line"><span class="comment"># 赋值前-子线程： &lt;MyThread(Thread-1, started 10008)&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment"># 赋值后-子线程： &lt;MyThread(Thread-1, started 10008)&gt; &#123;&#x27;name&#x27;: &#x27;Thread-1&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 赋值前-子线程： &lt;MyThread(Thread-2, started 8100)&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment"># 赋值后-子线程： &lt;MyThread(Thread-2, started 8100)&gt; &#123;&#x27;name&#x27;: &#x27;Thread-2&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 结束后-主线程： &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>local</code>实际是一个<code>字典型</code>的对象，其内部可以以<code>key-value</code>的形式存入你要做信息隔离的变量。</li>
<li>local实例可以是<code>全局唯一</code>的，只有一个。因为你在给local存入或访问变量时，它会根据当前的线程的不同从不同的<code>存储空间</code>存入或获取。</li>
</ul>
</blockquote>
<blockquote>
<p>得出以下三点结论：</p>
<ol>
<li>主线程中的变量，不会因为其是全局变量，而被子线程获取到；</li>
<li>主线程也不能获取到子线程中的变量；</li>
<li>子线程与子线程之间的变量也不能互相访问。</li>
</ol>
<p>简单来说 : <strong>主线程和多个子线程之间两两不互通</strong>.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, address, family=AF_INET, <span class="built_in">type</span>=SOCK_STREAM</span>):</span></span><br><span class="line">        self.address = address</span><br><span class="line">        self.family = AF_INET</span><br><span class="line">        self.<span class="built_in">type</span> = SOCK_STREAM</span><br><span class="line">        self.local = threading.local()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(self.local, <span class="string">&#x27;sock&#x27;</span>):</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Already connected&#x27;</span>)</span><br><span class="line">        <span class="comment"># 把socket连接存入local中</span></span><br><span class="line">        self.local.sock = socket(self.family, self.<span class="built_in">type</span>)</span><br><span class="line">        self.local.sock.connect(self.address)</span><br><span class="line">        <span class="keyword">return</span> self.local.sock</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_ty, exc_val, tb</span>):</span></span><br><span class="line">        self.local.sock.close()</span><br><span class="line">        <span class="keyword">del</span> self.local.sock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spider</span>(<span class="params">conn, website</span>):</span></span><br><span class="line">    <span class="keyword">with</span> conn <span class="keyword">as</span> s:</span><br><span class="line">        header = <span class="string">&#x27;GET / HTTP/1.1\r\nHost: &#123;&#125;\r\nConnection: close\r\n\r\n&#x27;</span>.<span class="built_in">format</span>(website)</span><br><span class="line">        s.send(header.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">        resp = <span class="string">b&#x27;&#x27;</span>.join(<span class="built_in">iter</span>(partial(s.recv, <span class="number">100000</span>), <span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Got &#123;&#125; bytes&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(resp)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 建立一个TCP连接</span></span><br><span class="line">    conn = LazyConnection((<span class="string">&#x27;www.sina.com.cn&#x27;</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬取两个页面</span></span><br><span class="line">    t1 = threading.Thread(target=spider, args=(conn,<span class="string">&quot;news.sina.com.cn&quot;</span>))</span><br><span class="line">    t2 = threading.Thread(target=spider, args=(conn,<span class="string">&quot;blog.sina.com.cn&quot;</span>))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure>



<h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>创建线程池是通过<code>concurrent.futures</code>函数库中的<code>ThreadPoolExecutor</code>类来实现的。</p>
<h3 id="使用map方法"><a href="#使用map方法" class="headerlink" title="使用map方法"></a>使用map方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">		num += <span class="number">1</span></span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">5</span>) <span class="keyword">as</span> exe:</span><br><span class="line">	res = exe.<span class="built_in">map</span>(target,<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> res:</span><br><span class="line">	<span class="built_in">print</span>(each)</span><br><span class="line"><span class="comment"># 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>

<h3 id="使用submit方法"><a href="#使用submit方法" class="headerlink" title="使用submit方法"></a>使用submit方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;running thread-&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(threading.get_ident(), i))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#: 生成线程池最大线程为5个</span></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    pool.submit(target) <span class="comment"># 往线程中提交，并运行</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    	<span class="comment"># 阻塞,等待queue.put(&quot;start&quot;)的执行</span></span><br><span class="line">        msg = q.get()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;running thread-&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(threading.get_ident(), i))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool</span>(<span class="params">workers,queue</span>):</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(workers):</span><br><span class="line">        t = threading.Thread(target=target, args=(queue,))</span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	queue = Queue()</span><br><span class="line">	<span class="comment"># 创建一个线程池：并设置线程数为5</span></span><br><span class="line">	pool(<span class="number">5</span>, queue)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">	    queue.put(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 消息都被消费才能结束</span></span><br><span class="line">	queue.join()</span><br></pre></td></tr></table></figure>



<h2 id="迭代器和可迭代对象"><a href="#迭代器和可迭代对象" class="headerlink" title="迭代器和可迭代对象"></a>迭代器和可迭代对象</h2><p>从代码本质来看:</p>
<ol>
<li>可迭代对象就是实现了<code>__iter__</code>方法</li>
<li>迭代器就是实现了<code>__iter__</code>和<code>__next__</code>方法</li>
</ol>
<p>所以造成了可迭代对象和迭代器功能上最大的区别:</p>
<blockquote>
<p>迭代器可以不使用<code>for</code>循环来间断获取元素值。<strong>可以直接使用next()方法来实现</strong>。</p>
</blockquote>
<h2 id="委派生成器的作用"><a href="#委派生成器的作用" class="headerlink" title="委派生成器的作用"></a>委派生成器的作用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average_gen</span>():</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        new_num = <span class="keyword">yield</span> average</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_num</span><br><span class="line">        average = total/count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 委托生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proxy_gen</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> average_gen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    calc_average = proxy_gen()</span><br><span class="line">    <span class="built_in">next</span>(calc_average)            <span class="comment"># 预激下生成器</span></span><br><span class="line">    <span class="built_in">print</span>(calc_average.send(<span class="number">10</span>))  <span class="comment"># 打印：10.0</span></span><br><span class="line">    <span class="built_in">print</span>(calc_average.send(<span class="number">20</span>))  <span class="comment"># 打印：15.0</span></span><br><span class="line">    <span class="built_in">print</span>(calc_average.send(<span class="number">30</span>))  <span class="comment"># 打印：20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>上面的委派生成器只是起到了<code>双向通道</code>的作用.<br>我们使用的yield from本身也是一个双向通道,但是<code>yield from</code>帮我们做了很多的异常处理，而且全面，而这些如果我们要自己去实现的话，一个是编写代码难度增加，写出来的代码可读性极差</p>
<h2 id="asyncio框架"><a href="#asyncio框架" class="headerlink" title="asyncio框架"></a>asyncio框架</h2><h3 id="await和yield-from的区别"><a href="#await和yield-from的区别" class="headerlink" title="await和yield from的区别"></a>await和yield from的区别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只要在一个生成器函数头部用上 @asyncio.coroutine 装饰器就能将这个函数对象，<code>标记</code>为协程对象。实际上，它的本质还是一个生成器。标记后，它实际上已经可以当成协程使用。</p>
</blockquote>
<p><code>await</code>用于挂起阻塞的异步调用接口。其作用在一定程度上类似于yield。</p>
<blockquote>
<p>注意:<code>一定程度上</code>意思是效果上一样（都能实现暂停的效果），但是<strong>功能上却不兼容</strong>。就是:</p>
<ul>
<li>不能在生成器中使用<code>await</code></li>
<li>不能在 async 定义的协程中使用<code>yield</code></li>
</ul>
<p>在使用方面:</p>
<ul>
<li><code>yield from</code> 后面可接 <code>可迭代对象</code>，也可接<code>future对象</code>/协程对象；</li>
<li><code>await</code> 后面必须要接 <code>future对象</code>/<code>协程对象</code></li>
</ul>
</blockquote>
<h3 id="gather与wait的异同"><a href="#gather与wait的异同" class="headerlink" title="gather与wait的异同"></a>gather与wait的异同</h3><p>把多个协程注册进一个事件循环中有两种方法:</p>
<ul>
<li><code>loop.run_until_complete(asyncio.wait(tasks))</code></li>
<li><code>loop.run_until_complete(asyncio.gather(*tasks))</code></li>
</ul>
<h4 id="接收参数方式"><a href="#接收参数方式" class="headerlink" title="接收参数方式"></a>接收参数方式</h4><ul>
<li><p>asyncio.wait接收的tasks，必须是一个list对象，这个list对象里，存放多个的task。<br>list对象也可以存放协程对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tasks=[</span><br><span class="line">       asyncio.ensure_future(func(<span class="string">&quot;A&quot;</span>, <span class="number">2</span>)),</span><br><span class="line">       asyncio.ensure_future(func(<span class="string">&quot;B&quot;</span>, <span class="number">3</span>)),</span><br><span class="line">       asyncio.ensure_future(func(<span class="string">&quot;C&quot;</span>, <span class="number">4</span>))</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tasks=[</span><br><span class="line">       func(<span class="string">&quot;A&quot;</span>, <span class="number">2</span>),</span><br><span class="line">       func(<span class="string">&quot;B&quot;</span>, <span class="number">3</span>),</span><br><span class="line">       func(<span class="string">&quot;C&quot;</span>, <span class="number">4</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure></li>
<li><p>```python<br>group1 = asyncio.gather(<em>[func(“A” ,i) for i in range(1, 3)])<br>group2 = asyncio.gather(</em>[func(“B”, i) for i in range(1, 5)])<br>group3 = asyncio.gather(*[func(“B”, i) for i in range(1, 7)])</p>
<p>loop = asyncio.get_event_loop()<br>loop.run_until_complete(asyncio.gather(group1, group2, group3))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### 返回结果不同</span><br><span class="line"></span><br><span class="line">- `asyncio.wait` 返回`dones`和`pendings`</span><br><span class="line"></span><br><span class="line">  &gt;- `dones`：表示已经完成的**任务**</span><br><span class="line">  &gt;- `pendings`：表示未完成的**任务**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;所以，如果我们需要获取**任务的运行结果**，需要使用`result`手工去收集获取。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;```python</span><br><span class="line">  &gt;dones, pendings = await asyncio.wait(tasks)</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;for task in dones:</span><br><span class="line">  &gt;    print(&#x27;Task ret: &#x27;, task.result())</span><br></pre></td></tr></table></figure></li>
<li><p><code>asyncio.gather</code> 直接返回任务的运行结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task ret: &#x27;</span>, result)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="wait有控制功能"><a href="#wait有控制功能" class="headerlink" title="wait有控制功能"></a>wait有控制功能</h4><ol>
<li>使用<code>return_when</code>参数</li>
<li>使用<code>timeout</code>参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro</span>(<span class="params">tag</span>):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(random.uniform(<span class="number">0.5</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">tasks = [coro(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【控制运行任务数】：运行第一个任务就返回</span></span><br><span class="line"><span class="comment"># FIRST_COMPLETED ：第一个任务完全返回</span></span><br><span class="line"><span class="comment"># FIRST_EXCEPTION：产生第一个异常返回</span></span><br><span class="line"><span class="comment"># ALL_COMPLETED：所有任务完成返回 （默认选项）</span></span><br><span class="line">dones, pendings = loop.run_until_complete(</span><br><span class="line">    asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一次完成的任务数:&quot;</span>, <span class="built_in">len</span>(dones))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【控制时间】：运行一秒后，就返回</span></span><br><span class="line">dones2, pendings2 = loop.run_until_complete(</span><br><span class="line">    asyncio.wait(pendings, timeout=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二次完成的任务数:&quot;</span>, <span class="built_in">len</span>(dones2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【默认】：所有任务完成后返回</span></span><br><span class="line">dones3, pendings3 = loop.run_until_complete(asyncio.wait(pendings2))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第三次完成的任务数:&quot;</span>, <span class="built_in">len</span>(dones3))</span><br><span class="line"></span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>



<h3 id="动态添加协程"><a href="#动态添加协程" class="headerlink" title="动态添加协程"></a>动态添加协程</h3><p>asyncio中将协程态添加到事件循环中的两种方法:</p>
<ul>
<li>主线程是<code>同步</code>的</li>
<li>主线程是<code>异步</code>的</li>
</ul>
<p>主线程是同步的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span>(<span class="params">loop</span>):</span></span><br><span class="line">    <span class="comment"># 一个在后台永远运行的事件循环</span></span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_sleep</span>(<span class="params">x, queue, msg=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    time.sleep(x)</span><br><span class="line">    queue.put(msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line"></span><br><span class="line">    new_loop = asyncio.new_event_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个线程，并传入一个事件循环对象</span></span><br><span class="line">    t = Thread(target=start_loop, args=(new_loop,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.ctime())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 动态添加两个协程</span></span><br><span class="line">    <span class="comment"># 这种方法，在主线程是同步的</span></span><br><span class="line">    new_loop.call_soon_threadsafe(do_sleep, <span class="number">6</span>, queue, <span class="string">&quot;第一个&quot;</span>)</span><br><span class="line">    new_loop.call_soon_threadsafe(do_sleep, <span class="number">3</span>, queue, <span class="string">&quot;第二个&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = queue.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; 协程运行完..&quot;</span>.<span class="built_in">format</span>(msg))</span><br><span class="line">        <span class="built_in">print</span>(time.ctime())</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Sat Jul 13 10:15:28 2019</span></span><br><span class="line"><span class="comment"># 第一个 协程运行完..</span></span><br><span class="line"><span class="comment"># Sat Jul 13 10:15:34 2019</span></span><br><span class="line"><span class="comment"># 第二个 协程运行完..</span></span><br><span class="line"><span class="comment"># Sat Jul 13 10:15:37 2019    </span></span><br></pre></td></tr></table></figure>

<p>由于是同步的，所以总共耗时6+3=9秒.</p>
<p>主线程是异步的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span>(<span class="params">loop</span>):</span></span><br><span class="line">    <span class="comment"># 一个在后台永远运行的事件循环</span></span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_sleep</span>(<span class="params">x, queue, msg=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    queue.put(msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	queue = Queue()</span><br><span class="line"></span><br><span class="line">	new_loop = asyncio.new_event_loop()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 定义一个线程，并传入一个事件循环对象</span></span><br><span class="line">	t = Thread(target=start_loop, args=(new_loop,))</span><br><span class="line">	t.start()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(time.ctime())</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 动态添加两个协程</span></span><br><span class="line">	<span class="comment"># 这种方法，在主线程是异步的</span></span><br><span class="line">	asyncio.run_coroutine_threadsafe(do_sleep(<span class="number">6</span>, queue, <span class="string">&quot;第一个&quot;</span>), new_loop)</span><br><span class="line">	asyncio.run_coroutine_threadsafe(do_sleep(<span class="number">3</span>, queue, <span class="string">&quot;第二个&quot;</span>), new_loop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	    msg = queue.get()</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; 协程运行完..&quot;</span>.<span class="built_in">format</span>(msg))</span><br><span class="line">	    <span class="built_in">print</span>(time.ctime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sat Jul 13 10:39:27 2019</span></span><br><span class="line"><span class="comment"># 第二个 协程运行完..</span></span><br><span class="line"><span class="comment"># Sat Jul 13 10:39:30 2019</span></span><br><span class="line"><span class="comment"># 第一个 协程运行完..</span></span><br><span class="line"><span class="comment"># Sat Jul 13 10:39:33 2019</span></span><br></pre></td></tr></table></figure>

<p>由于是同步的，所以总共耗时max(6, 3)=6秒</p>
<h3 id="实战：利用redis实现动态添加任务"><a href="#实战：利用redis实现动态添加任务" class="headerlink" title="实战：利用redis实现动态添加任务"></a>实战：利用redis实现动态添加任务</h3><p>对于并发任务，通常是用生成消费模型，对队列的处理可以使用类似master-worker的方式，master主要用户获取队列的msg，worker用户处理消息。</p>
<p>为了简单起见，并且协程更适合单线程的方式，我们的主线程用来监听队列，子线程用于处理队列。这里使用redis的队列。主线程中有一个是无限循环，用户消费队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_redis</span>():</span></span><br><span class="line">    connection_pool = redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, db=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> redis.Redis(connection_pool=connection_pool)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span>(<span class="params">loop</span>):</span></span><br><span class="line">    <span class="comment"># 一个在后台永远运行的事件循环</span></span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_sleep</span>(<span class="params">x, queue</span>):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    queue.put(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        task = rcon.rpop(<span class="string">&quot;queue&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> task:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        asyncio.run_coroutine_threadsafe(do_sleep(<span class="built_in">int</span>(task), queue), new_loop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(time.ctime())</span><br><span class="line">    new_loop = asyncio.new_event_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个线程，运行一个事件循环对象，用于实时接收新任务</span></span><br><span class="line">    loop_thread = Thread(target=start_loop, args=(new_loop,))</span><br><span class="line">    loop_thread.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    loop_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建redis连接</span></span><br><span class="line">    rcon = get_redis()</span><br><span class="line"></span><br><span class="line">    queue = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 子线程：实时接收来自Redis的消息队列，并实时往事件对象容器中添加新任务。</span></span><br><span class="line">    consumer_thread = Thread(target=consumer)</span><br><span class="line">    consumer_thread.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    consumer_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = queue.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;协程运行完..&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前时间：&quot;</span>, time.ctime())</span><br></pre></td></tr></table></figure>




</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>