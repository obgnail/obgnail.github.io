<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;网址&quot;&gt;&lt;a href=&quot;#网址&quot; class=&quot;headerlink&quot; title=&quot;网址&quot;&gt;&lt;/a&gt;网址&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.shiyanlou.com/courses/1278&quot;&gt;实验楼_python异步编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/SL_World/article/details/86597738&quot;&gt;Python异步IO之协程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/b5e347b3a17c&quot;&gt;Python黑魔法 — 异步IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mozillazg.com/2017/08/python-asyncio-note-coroutines-base-usage.html&quot;&gt;asyncio 学习笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/tinyzhao/article/details/52684473&quot;&gt;async with 和 async for&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-GIL&quot;&gt;&lt;a href=&quot;#1-GIL&quot; class=&quot;headerlink&quot; title=&quot;1.GIL&quot;&gt;&lt;/a&gt;1.GIL&lt;/h2&gt;&lt;p&gt;线程资源共用,所以容易造成预想不到的效果,也就是说线程是不安全的.&lt;br&gt;如何解决线程安全问题？"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Python异步编程2 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2019-08-18</div></div></div><div class="container post-header"><h1>Python异步编程2</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E5%9D%80"><span class="toc-number">1.</span> <span class="toc-text">网址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-GIL"><span class="toc-number">2.</span> <span class="toc-text">1.GIL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%82%E6%AD%A5"><span class="toc-number">3.</span> <span class="toc-text">2.异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%8F%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">3.协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%9F%E6%88%90%E5%99%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.</span> <span class="toc-text">4.生成器注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-yield-from"><span class="toc-number">6.</span> <span class="toc-text">5.yield from</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.</span> <span class="toc-text">6.线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%94%AF%E6%8C%81%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">7.支持获取返回值的线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8threading%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text">使用threading自定义一个类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8threaing%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%9B%B4%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">使用threaing指定一个更抽象的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8future-ThreadPoolExecutor%E7%9A%84map"><span class="toc-number">8.3.</span> <span class="toc-text">使用future.ThreadPoolExecutor的map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text">守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.5.</span> <span class="toc-text">守护线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-asyncio%E6%A8%A1%E5%9D%97"><span class="toc-number">9.</span> <span class="toc-text">8.asyncio模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%B0%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">9.2.</span> <span class="toc-text">走个流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8asyncio-coroutine%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">9.3.</span> <span class="toc-text">使用asyncio.coroutine装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8async%E5%92%8Cawait%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B"><span class="toc-number">9.4.</span> <span class="toc-text">使用async和await实现协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B"><span class="toc-number">9.4.1.</span> <span class="toc-text">1.定义一个协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAtask"><span class="toc-number">9.4.2.</span> <span class="toc-text">2.创建一个task</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%91%E5%AE%9A%E5%9B%9E%E8%B0%83"><span class="toc-number">9.4.3.</span> <span class="toc-text">3.绑定回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-future-%E4%B8%8E-result"><span class="toc-number">9.4.4.</span> <span class="toc-text">4.future 与 result</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%98%BB%E5%A1%9E%E5%92%8Cawait"><span class="toc-number">9.4.5.</span> <span class="toc-text">5.阻塞和await</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">9.4.6.</span> <span class="toc-text">6.并发和并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%8D%8F%E7%A8%8B%E5%B5%8C%E5%A5%97"><span class="toc-number">9.4.7.</span> <span class="toc-text">7.协程嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%8D%8F%E7%A8%8B%E5%81%9C%E6%AD%A2"><span class="toc-number">9.4.8.</span> <span class="toc-text">8.协程停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.4.9.</span> <span class="toc-text">9.不同线程的事件循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-with-%E5%92%8Casync-for-%E7%94%A8%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="toc-number">9.5.</span> <span class="toc-text">async with 和async for 用法说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#async-with"><span class="toc-number">9.5.1.</span> <span class="toc-text">async with</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-for"><span class="toc-number">9.5.2.</span> <span class="toc-text">async for</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">10.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">10.1.</span> <span class="toc-text">1.基础知识补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">10.2.</span> <span class="toc-text">2.全流程解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%98%AF%E5%90%A6%E8%A6%81%E5%85%B3%E9%97%AD%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.3.</span> <span class="toc-text">3.是否要关闭事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-asyncio-gather-%E5%92%8C-asyncio-wait-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">10.4.</span> <span class="toc-text">4.asyncio.gather 和 asyncio.wait  的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%96%E6%B6%88%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">10.5.</span> <span class="toc-text">5.取消任务的两种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loop-stop"><span class="toc-number">10.5.1.</span> <span class="toc-text">loop.stop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#task-cancel"><span class="toc-number">10.5.2.</span> <span class="toc-text">task.cancel</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-loop-run-forever-%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.6.</span> <span class="toc-text">6.loop.run_forever 无限循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%AE%9A%E4%BB%BB%E5%8A%A1"><span class="toc-number">10.6.1.</span> <span class="toc-text">排定任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%8D%8F%E7%A8%8B%E5%86%85%E9%83%A8%E6%89%A7%E8%A1%8Cloop-stop%E6%96%B9%E6%B3%95%E5%81%9C%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.6.2.</span> <span class="toc-text">在协程内部执行loop.stop方法停止事件循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C-loop-stop-%E5%81%9C%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.6.3.</span> <span class="toc-text">使用回调函数执行 loop.stop 停止事件循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%B0%86%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E4%BB%BB%E5%8A%A1%E6%B3%A8%E5%85%A5%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">10.7.</span> <span class="toc-text">7.将普通函数作为任务注入事件循环的三种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loop-call-soon"><span class="toc-number">10.7.1.</span> <span class="toc-text">loop.call_soon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loop-call-later"><span class="toc-number">10.7.2.</span> <span class="toc-text">loop.call_later</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loop-call-at-amp-loop-time"><span class="toc-number">10.7.3.</span> <span class="toc-text">loop.call_at &amp; loop.time</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E6%B3%95"><span class="toc-number">10.8.</span> <span class="toc-text">8.协程的通讯方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-lock"><span class="toc-number">10.8.1.</span> <span class="toc-text">asyncio.lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-Event"><span class="toc-number">10.8.2.</span> <span class="toc-text">asyncio.Event</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-condition"><span class="toc-number">10.8.3.</span> <span class="toc-text">asyncio.condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-Queue"><span class="toc-number">10.8.4.</span> <span class="toc-text">asyncio.Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%8E%B7%E5%8F%96%E5%8D%8F%E7%A8%8B%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.9.</span> <span class="toc-text">9.获取协程返回值的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B%E4%B8%ADawait%E4%BA%86%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%8D%8F%E7%A8%8B"><span class="toc-number">10.9.1.</span> <span class="toc-text">一个协程中await了另外一个协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-gather%E5%88%9B%E5%BB%BA%E5%8D%8F%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.9.2.</span> <span class="toc-text">asyncio.gather创建协程对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run-until-complete%E8%BF%94%E5%9B%9E%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">10.9.3.</span> <span class="toc-text">run_until_complete返回协程的结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio%E7%9A%84as-completed%E6%96%B9%E6%B3%95"><span class="toc-number">10.9.4.</span> <span class="toc-text">asyncio的as_completed方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-asyncio%E7%9A%84futrue%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.10.</span> <span class="toc-text">10.asyncio的futrue对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB-Protocol-%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5-I-O"><span class="toc-number">10.11.</span> <span class="toc-text">11.使用抽象类 Protocol 实现异步 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">10.11.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">10.11.2.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">10.11.3.</span> <span class="toc-text">完整代码</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.shiyanlou.com/courses/1278">实验楼_python异步编程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/SL_World/article/details/86597738">Python异步IO之协程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b5e347b3a17c">Python黑魔法 — 异步IO</a></li>
<li><a target="_blank" rel="noopener" href="https://mozillazg.com/2017/08/python-asyncio-note-coroutines-base-usage.html">asyncio 学习笔记</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/tinyzhao/article/details/52684473">async with 和 async for</a></li>
</ol>
<h2 id="1-GIL"><a href="#1-GIL" class="headerlink" title="1.GIL"></a>1.GIL</h2><p>线程资源共用,所以容易造成预想不到的效果,也就是说线程是不安全的.<br>如何解决线程安全问题？</p>
<p>CPython解释器使用了加锁的方法。每个进程有一把锁，<strong>启动线程先加锁，结束线程释放锁</strong>。</p>
<blockquote>
<p>打个比方，进程是一个厂房，厂房大门是开着的，门内有锁，工人进入大门后可以在内部上锁。厂房里面有10个车间对应10个线程，每个CPU就是一个工人。</p>
<p>进程 – 厂房</p>
<p>线程 – 车间</p>
<p>CPU – 工人</p>
<p>GIL（Global Interpreter  Lock）全局锁就相当于厂房规定：工人要到车间工作，从厂房大门进去后要在里面反锁，完成工作后开锁出门，下一个工人再进门上锁。也就是说，任意时刻厂房里只能有一个工人，但这样就保证了工作的安全性，这就是GIL的原理。</p>
</blockquote>
<p>当然了，GIL的存在有很多其它益处，包括简化  CPython 解释器和大量扩展的实现。</p>
<h2 id="2-异步"><a href="#2-异步" class="headerlink" title="2.异步"></a>2.异步</h2><p>所谓的异步，就是CPU在当前线程阻塞时可以去其它线程中工作，<strong>不管怎么设计，在一个线程内部代码都是顺序执行的</strong>，遇到IO都得阻塞，所谓的非阻塞，是遇到当前线程阻塞时，CPU去其它线程工作</p>
<ol>
<li>异步：多任务，==多个任务之间执行没有先后顺序==，可以同时运行，执行的先后顺序不会有什么影响，存在的多条运行主线</li>
<li>同步：多任务，==多个任务之间执行的时候要求有先后顺序==，必须一个先执行完成之后，另一个才能继续执行，只有一个主线</li>
<li>阻塞：从调用者的角度出发，如果在调用的时候，被卡住，不能再继续向下运行，需要等待，就说是阻塞。</li>
<li>非阻塞：从调用者的角度出发，如果在调用的时候，没有被卡住，能够继续向下运行，无需等待，就说是非阻塞。</li>
</ol>
<p>同异步与阻塞的区别：</p>
<ul>
<li>同步和异步关注的是消息通信机制；</li>
<li>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</li>
</ul>
<h2 id="3-协程"><a href="#3-协程" class="headerlink" title="3.协程"></a>3.协程</h2><p>协程是在线程的基础上编写,由程序员决定代码执行顺序、可以互相影响的高耦合度代码的一种高级程序设计模式。</p>
<p>生成器函数的执行结果是生成器，注意这里所讲的“执行结果”不是函数的 return值。生成器终止时必定抛出 Stoplteration异常，for循环可以捕获此异常，异常的 value 属性值为生成器函数的 return值。</p>
<blockquote>
<p>生成器会在yield语句处暂停，这是至关重要的，未来协程中的IO阻塞就出现在这里.</p>
</blockquote>
<p>协程有四种存在状态:</p>
<ol>
<li>GEN_CREATED<br>创建完成,等待执行</li>
<li>GEN _RUNNING<br>解释器正在执行(这个状态在下面的示例程序中无法看到)</li>
<li>GEN_SUSPENDED<br>在yield表达式处暂停</li>
<li>GEN_CLOSE<br>执行结束,生成器停止</li>
</ol>
<p>预先激活生成器（或协程）可以使用next方法，也可以使用生成器的send方法发送None值：g.send（None）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预激生成器装饰器</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">	@wraps(<span class="params">func</span>)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kw</span>):</span></span><br><span class="line">		g = func(*args,**kw)</span><br><span class="line">		<span class="built_in">next</span>(g)</span><br><span class="line">		<span class="keyword">return</span> g</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    i = <span class="string">&#x27;hyl&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;over&#x27;</span>)</span><br><span class="line">        i = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(inspect.getgeneratorstate(g))</span><br></pre></td></tr></table></figure>

<p>前文提到<strong>Stoplteration异常的value属性值为生成器（协程）函数的 return 值</strong>，我们可以在使用协程时捕获异常并得到这个值。举例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">	@wraps(<span class="params">func</span>)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kw</span>):</span></span><br><span class="line">		g = func(*args,**kw)</span><br><span class="line">		<span class="built_in">next</span>(g)</span><br><span class="line">		<span class="keyword">return</span> g</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    i = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> value == <span class="string">&#x27;close&#x27;</span>:</span><br><span class="line">        	<span class="keyword">break</span></span><br><span class="line">        i.append(value)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line">g.send(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">g.send(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">g.send(<span class="string">&#x27;close&#x27;</span>)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;D:\trainingfile\training2.py&quot;, line 27, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     g.send(&#x27;close&#x27;)</span></span><br><span class="line"><span class="comment"># StopIteration: [&#x27;hello&#x27;, &#x27;123&#x27;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">	@wraps(<span class="params">func</span>)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kw</span>):</span></span><br><span class="line">		g = func(*args,**kw)</span><br><span class="line">		<span class="built_in">next</span>(g)</span><br><span class="line">		<span class="keyword">return</span> g</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    i = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> value == <span class="string">&#x27;close&#x27;</span>:</span><br><span class="line">        	<span class="keyword">break</span></span><br><span class="line">        i.append(value)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = gen()</span><br><span class="line">g.send(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">g.send(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	g.send(<span class="string">&#x27;close&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(e.value)</span><br><span class="line"><span class="comment"># [&#x27;hello&#x27;, &#x27;123&#x27;]</span></span><br></pre></td></tr></table></figure>



<h2 id="4-生成器注意事项"><a href="#4-生成器注意事项" class="headerlink" title="4.生成器注意事项"></a>4.生成器注意事项</h2><ol>
<li>当一个生成器对象被销毁时，或者主程序结束的时候会抛出一个GeneratorExit异常。</li>
<li>GeneratorExit异常的产生意味着生成器对象的生命周期已经结束。因此，一旦产生了GeneratorExit异常，生成器方法后续执行的语句中，不能再有yield语句，否则会产生RuntimeError。</li>
<li>throw：用来向生成器函数送入一个异常，如果生成器处理了这个异常，代码会向前执行到下一个yield，产生的值成为调用throw方法的返回值。</li>
<li>close方法会在生成器对象方法的挂起处抛出一个GeneratorExit异常 。</li>
</ol>
<h2 id="5-yield-from"><a href="#5-yield-from" class="headerlink" title="5.yield from"></a>5.yield from</h2><p>yield from的两大优势</p>
<ol>
<li>避免嵌套循环</li>
<li>转移控制权</li>
</ol>
<p>yield from语句可以替代for循环,避免了嵌套循环.同yield一样,有 yield from语句的函数叫做协程函数或生成器函数. </p>
<p>yield from后面接收一个可迭代对象,在协程中,==可迭代对象往往是协程对象,这样就形成了嵌套协程==.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">yield</span> <span class="keyword">from</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> func():</span><br><span class="line">	<span class="built_in">print</span>(each)</span><br></pre></td></tr></table></figure>



<p>yield from允许子生成器直接从调用者接收其发送的信息或者抛出调用时遇到的异常，并且返回给委派生产器一个值。</p>
<p>所谓<code>转移控制权</code>就是 yield from语法可以==将子生成器的控制权交给调用方main函数==,<strong>在main函数内部创建父生成器C,控制 c.send方法传值给子生成器</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> faker <span class="keyword">import</span> Faker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预激协程装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        g = func(*args, **kw)</span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器函数，这个生成器是真正做事的生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_coro</span>():</span></span><br><span class="line">    l = [] </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        value = <span class="keyword">yield</span>           </span><br><span class="line">        <span class="keyword">if</span> value == <span class="string">&#x27;CLOSE&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        l.append(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用预激协程装饰器</span></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="comment"># 带有 yield from 语句的父生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele_coro</span>():</span></span><br><span class="line">    <span class="comment"># while True 可以多次循环，每次循环会创建一个新的子生成器 sub_coro()</span></span><br><span class="line">    <span class="comment"># 这里 while 只循环一次，这是由调用方，也就是 main 函数决定的</span></span><br><span class="line">    <span class="comment"># while 循环可以捕获函数本身创建的父生成器终止时触发的 StopIteration 异常</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># yield from 会自动预激子生成器 sub_coro()</span></span><br><span class="line">        <span class="comment"># 所以 sub_coro 在定义时不可以使用预激协程装饰器</span></span><br><span class="line">        <span class="comment"># yield from 将捕获子生成器终止时触发的 StopIteration 异常</span></span><br><span class="line">        <span class="comment"># 并将异常的 value 属性值赋值给等号前面的变量 l</span></span><br><span class="line">        <span class="comment"># 也就是 l 变量的值等于 sub_coro 函数的 return 值</span></span><br><span class="line">        <span class="comment"># yield from 还实现了一个重要功能</span></span><br><span class="line">        <span class="comment"># 就是父生成器的 send 方法将发送值给子生成器</span></span><br><span class="line">        <span class="comment"># 并赋值给子生成器中 yield 语句等号前面的变量 value</span></span><br><span class="line">        l = <span class="keyword">yield</span> <span class="keyword">from</span> sub_coro()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;排序后的列表：&#x27;</span>, l)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用父生成器的函数，也叫调用方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 生成随机国家代号的方法</span></span><br><span class="line">    fake = Faker().country_code</span><br><span class="line">    <span class="comment"># 嵌套列表，每个子列表中有三个随机国家代号(字符串)</span></span><br><span class="line">    nest_country_list = [[fake() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> country_list <span class="keyword">in</span> nest_country_list:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;国家代号列表：&#x27;</span>, country_list)</span><br><span class="line">        c = dele_coro()      <span class="comment"># 创建父生成器</span></span><br><span class="line">        <span class="keyword">for</span> country <span class="keyword">in</span> country_list:</span><br><span class="line">            c.send(country)  <span class="comment"># 父生成器的 send 方法将国家代号发送给子生成器</span></span><br><span class="line">        <span class="comment"># CLOSE 将终止子生成器中的 while 循环</span></span><br><span class="line">        <span class="comment"># 子生成器的 return 值赋值给父生成器 yield from 语句中等号前面的变量 l</span></span><br><span class="line">        c.send(<span class="string">&#x27;CLOSE&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 国家代号列表： [&#x27;SA&#x27;, &#x27;FJ&#x27;, &#x27;PK&#x27;]</span></span><br><span class="line"><span class="comment"># 排序后的列表： [&#x27;FJ&#x27;, &#x27;PK&#x27;, &#x27;SA&#x27;]</span></span><br><span class="line"><span class="comment"># ------------------</span></span><br><span class="line"><span class="comment"># 国家代号列表： [&#x27;VA&#x27;, &#x27;KP&#x27;, &#x27;MW&#x27;]</span></span><br><span class="line"><span class="comment"># 排序后的列表： [&#x27;KP&#x27;, &#x27;MW&#x27;, &#x27;VA&#x27;]</span></span><br><span class="line"><span class="comment"># ------------------</span></span><br><span class="line"><span class="comment"># 国家代号列表： [&#x27;ZW&#x27;, &#x27;UA&#x27;, &#x27;BD&#x27;]</span></span><br><span class="line"><span class="comment"># 排序后的列表： [&#x27;BD&#x27;, &#x27;UA&#x27;, &#x27;ZW&#x27;]</span></span><br><span class="line"><span class="comment"># ------------------</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<ol>
<li>yield from 会自动预激<strong>子</strong>生成器</li>
<li>父生成器的<code>l = yield from sub_coro()</code>中的<code>l</code>就会接受子生成器的return值.<br>也就是说,==l只有在子生成器结束的时候才会被赋值==.</li>
<li>父生成器就是一个通道而已,在上面代码中,通道没有做任何额外的事情</li>
</ol>
</blockquote>
<p>使用通道:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        g = func(*args, **kw)</span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		i = <span class="keyword">yield</span> </span><br><span class="line">		<span class="keyword">if</span> i == <span class="string">&#x27;close&#x27;</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res += i</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		a = <span class="keyword">yield</span> <span class="keyword">from</span> add()</span><br><span class="line">		<span class="keyword">return</span> a   <span class="comment"># 这行只执行了一次,就是在最后的时候</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	gen = parent()</span><br><span class="line">	gen.send(<span class="number">1</span>)</span><br><span class="line">	gen.send(<span class="number">2</span>)</span><br><span class="line">	gen.send(<span class="number">3</span>)</span><br><span class="line">	gen.send(<span class="number">4</span>)</span><br><span class="line">	x = gen.send(<span class="string">&#x27;close&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	main()</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(e)  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>

<p>不使用通道:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        g = func(*args, **kw)</span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		i = <span class="keyword">yield</span> </span><br><span class="line">		<span class="keyword">if</span> i == <span class="string">&#x27;close&#x27;</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res += i</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	gen = add()</span><br><span class="line">	gen.send(<span class="number">1</span>)</span><br><span class="line">	gen.send(<span class="number">2</span>)</span><br><span class="line">	gen.send(<span class="number">3</span>)</span><br><span class="line">	gen.send(<span class="number">4</span>)</span><br><span class="line">	x = gen.send(<span class="string">&#x27;close&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	main()</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(e)  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        g = func(*args, **kw)</span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_list</span>():</span></span><br><span class="line">	res = []</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		i = <span class="keyword">yield</span></span><br><span class="line">		<span class="keyword">if</span> i != <span class="string">&#x27;close&#x27;</span>:</span><br><span class="line">			res.append(i)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sorted</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		a = <span class="keyword">yield</span> <span class="keyword">from</span> sort_list()</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	g = parent()</span><br><span class="line">	g.send(<span class="number">1</span>)</span><br><span class="line">	g.send(<span class="number">5</span>)</span><br><span class="line">	g.send(<span class="number">59</span>)</span><br><span class="line">	g.send(<span class="number">7</span>)</span><br><span class="line">	g.send(<span class="string">&#x27;close&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	main()</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(e)  <span class="comment"># [1, 5, 7, 59]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">avg</span>():</span></span><br><span class="line">	tot = <span class="number">0</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		a = <span class="keyword">yield</span></span><br><span class="line">		<span class="keyword">if</span> a != <span class="literal">None</span>:</span><br><span class="line">			tot += a</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> tot/count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proxies</span>(<span class="params">aDict,key</span>):</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		aDict[key] = <span class="keyword">yield</span> <span class="keyword">from</span> avg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	data = &#123;<span class="string">&#x27;hyl&#x27;</span>:[<span class="number">95</span>,<span class="number">96</span>,<span class="number">97</span>],<span class="string">&#x27;dsz&#x27;</span>:[<span class="number">88</span>,<span class="number">90</span>]&#125;</span><br><span class="line">	res = &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> person,score <span class="keyword">in</span> data.items():</span><br><span class="line">		gen = proxies(res,person)</span><br><span class="line">		<span class="built_in">next</span>(gen)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> each <span class="keyword">in</span> score:</span><br><span class="line">			gen.send(each)</span><br><span class="line">		gen.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main() <span class="comment"># &#123;&#x27;hyl&#x27;: 96.0, &#x27;dsz&#x27;: 89.0&#125;</span></span><br></pre></td></tr></table></figure>

<p>而yield from功能还不止于此，它还有一个主要的功能是<strong>省去了很多异常的处理</strong>，不再需要我们手动编写，其内部已经实现大部分异常处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_1</span>():</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = <span class="keyword">yield</span> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;加&#x27;</span>,x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += x</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_2</span>():</span> <span class="comment"># 委托生成器</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        total = <span class="keyword">yield</span> <span class="keyword">from</span> generator_1() <span class="comment"># 子生成器</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;加和总数是:&#x27;</span>,total)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span> <span class="comment"># 调用方</span></span><br><span class="line">    g1 = generator_1()</span><br><span class="line">    g1.send(<span class="literal">None</span>)</span><br><span class="line">    g1.send(<span class="number">2</span>)</span><br><span class="line">    g1.send(<span class="number">3</span>)</span><br><span class="line">    g1.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"><span class="comment"># 加 2</span></span><br><span class="line"><span class="comment"># 加 3</span></span><br><span class="line"><span class="comment"># 加 None</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;D:\trainingfile\training4.py&quot;, line 23, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     main()</span></span><br><span class="line"><span class="comment">#   File &quot;D:\trainingfile\training4.py&quot;, line 21, in main</span></span><br><span class="line"><span class="comment">#     g1.send(None)</span></span><br><span class="line"><span class="comment"># StopIteration: 5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_1</span>():</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = <span class="keyword">yield</span> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;加&#x27;</span>,x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += x</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_2</span>():</span> <span class="comment"># 委托生成器</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        total = <span class="keyword">yield</span> <span class="keyword">from</span> generator_1() <span class="comment"># 子生成器</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;加和总数是:&#x27;</span>,total)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span> <span class="comment"># 调用方</span></span><br><span class="line">    g2 = generator_2()</span><br><span class="line">    g2.send(<span class="literal">None</span>)</span><br><span class="line">    g2.send(<span class="number">2</span>)</span><br><span class="line">    g2.send(<span class="number">3</span>)</span><br><span class="line">    g2.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"><span class="comment"># 加 2</span></span><br><span class="line"><span class="comment"># 加 3</span></span><br><span class="line"><span class="comment"># 加 None</span></span><br><span class="line"><span class="comment"># 加和总数是: 5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见yield from封装了处理常见异常的代码。对于g2即便传入None也不报异常，其中<code>total = yield from generator_1()</code>返回给total的值是generator_1()最终的return total</p>
</blockquote>
<blockquote>
<p>概念：</p>
<ol>
<li>子生成器：yield from后的generator_1()生成器函数是子生成器</li>
<li>委托生成器：generator_2()是程序中的委托生成器，它负责委托子生成器完成具体任务。</li>
<li>调用方：main()是程序中的调用方，负责调用委托生成器。</li>
</ol>
<p>yield from在其中的作用是：建立调用方和子生成器的通道</p>
<ol>
<li>在上述代码中main()每一次在调用send(value)时，value不是传递给了委托生成器generator_2()，而是借助yield from传递给了子生成器generator_1()中的yield</li>
<li>同理，子生成器中的数据也是通过yield直接发送到调用方main()中。</li>
</ol>
</blockquote>
<h2 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6.线程池"></a>6.线程池</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">num</span>):</span></span><br><span class="line">	time.sleep(<span class="number">1</span>)</span><br><span class="line">	<span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	<span class="keyword">with</span> futures.ThreadPoolExecutor(<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">		executor.<span class="built_in">map</span>(printer,<span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<code>executor.map(printer,range(4))</code>是将range(4)迭代出来的元素作为printer的参数.并不是整个range(4)作为priner的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">num</span>):</span></span><br><span class="line">	time.sleep(<span class="number">1</span>)</span><br><span class="line">	<span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	<span class="keyword">with</span> futures.ThreadPoolExecutor(<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">		executor.<span class="built_in">map</span>(printer,((<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main()</span><br><span class="line"><span class="comment"># (3, 4)</span></span><br><span class="line"><span class="comment"># (1, 2)</span></span><br><span class="line"><span class="comment"># (7, 8)</span></span><br><span class="line"><span class="comment"># (5, 6)</span></span><br><span class="line"><span class="comment"># (9, 10)</span></span><br></pre></td></tr></table></figure>

<p>executor.__exit__方法会调用<code>executor.shutdown(wait=True)</code>方法,等待所有线程都执行完毕后关闭线程池</p>
</blockquote>
<p>future 是一种对象，表示<code>异步执行的操作</code>。Future封装待完成的操作</p>
<h2 id="7-支持获取返回值的线程"><a href="#7-支持获取返回值的线程" class="headerlink" title="7.支持获取返回值的线程"></a>7.支持获取返回值的线程</h2><h3 id="使用threading自定义一个类"><a href="#使用threading自定义一个类" class="headerlink" title="使用threading自定义一个类"></a>使用threading自定义一个类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> random.randint(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._<span class="keyword">return</span> = self.foo()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1 = Test()</span><br><span class="line">test2 = Test()</span><br><span class="line">test1.start()</span><br><span class="line">test2.start()</span><br><span class="line"></span><br><span class="line">test1.join()</span><br><span class="line">test2.join()</span><br><span class="line"><span class="built_in">print</span>(test1.get_result())</span><br><span class="line"><span class="built_in">print</span>(test2.get_result())</span><br></pre></td></tr></table></figure>

<h3 id="使用threaing指定一个更抽象的类"><a href="#使用threaing指定一个更抽象的类" class="headerlink" title="使用threaing指定一个更抽象的类"></a>使用threaing指定一个更抽象的类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithReturnValue</span>(<span class="params">Thread</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">if</span> self._target:</span><br><span class="line">			self._<span class="keyword">return</span> = self._target(*self._args, **self._kwargs)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_result</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self._<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">test = ThreadWithReturnValue(target=printer,args=(<span class="number">2</span>,))</span><br><span class="line">test.start()</span><br></pre></td></tr></table></figure>

<h3 id="使用future-ThreadPoolExecutor的map"><a href="#使用future-ThreadPoolExecutor的map" class="headerlink" title="使用future.ThreadPoolExecutor的map"></a>使用future.ThreadPoolExecutor的map</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;---hyl&#x27;</span>)</span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">&#x27;this is return&#x27;</span>,num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> futures.ThreadPoolExecutor(<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">	result = executor.<span class="built_in">map</span>(func,<span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line">	<span class="built_in">print</span>(result)</span><br><span class="line">	<span class="comment"># result 存储了所有future的返回值,是一个生成器</span></span><br><span class="line">	<span class="comment"># &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x00000170C562C9A8&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代这个生成器,获得返回值</span></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> result:</span><br><span class="line">	<span class="built_in">print</span>(each)</span><br><span class="line">	</span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># &lt;generator object Executor.map.&lt;locals&gt;.result_iterator at 0x000001E855EAD9A8&gt;</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 0)</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 1)</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 2)</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 3)</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 4)</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 5)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>发现(‘this is return’, 0)都是最后才打印的,说明:<br>使用<code>with</code>语句就能起到<code>join()</code>的阻塞作用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;---hyl&#x27;</span>)</span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> (<span class="string">&#x27;this is return&#x27;</span>,num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = futures.ThreadPoolExecutor(<span class="number">3</span>)</span><br><span class="line">result = executor.<span class="built_in">map</span>(func,<span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代这个生成器,获得返回值</span></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> result:</span><br><span class="line">	<span class="built_in">print</span>(each)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;**************************&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># *------------(等待2秒后执行下面代码)</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 0)</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 1)</span></span><br><span class="line"><span class="comment"># ---hyl</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 2)</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 3)</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 4)</span></span><br><span class="line"><span class="comment"># (&#x27;this is return&#x27;, 5)(等待20秒后执行下面代码)</span></span><br><span class="line"><span class="comment"># **************************</span></span><br></pre></td></tr></table></figure>

<p>发现<code>print(&#39;**************************&#39;)</code>是最后执行的,这说明<strong>for循环阻塞了</strong></p>
<p>说明必须等到result这个生成器所有之填充完毕后才会退出for循环</p>
<p>总结:</p>
<ol>
<li><code>with</code>能够阻塞,必须等待<code>result = executor.map(func,range(6))</code>才能退出with语句</li>
<li><code>result</code>也能阻塞,必须等待result这个生成器有值才会向下执行代码</li>
</ol>
<p>Executor.map还有个特性比较有用，那就是这个函数返回==结果的顺序于调用开始的顺序是一致的==。如果第一个调用生成结果用时10秒，其他调用只用1秒，代码会阻塞10秒，获取map方法返回的生成器产出的第一个结果。</p>
</blockquote>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul>
<li>一般创建了子进程，主线程都会等子进程完全执行完，主进程才会结束</li>
<li>守护线程就是主线程不等子进程，主线程做完程序立马结束。</li>
</ul>
<blockquote>
<p>设置守护进程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意一定要把daemon设置在 start 之前设置</span></span><br><span class="line">p=Process(target=func)</span><br><span class="line"> p.daemon=<span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;*****&#x27;</span>)</span><br><span class="line">	time.sleep(<span class="number">10</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;我还活着&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	p = Process(target=func)</span><br><span class="line">	p.daemon = <span class="literal">True</span></span><br><span class="line">	p.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;-----------&#x27;</span>)</span><br><span class="line">	main()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># end</span></span><br></pre></td></tr></table></figure>

<p>还可以使用join():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;*****&#x27;</span>)</span><br><span class="line">	time.sleep(<span class="number">10</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;我还活着&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;-----------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	p = Process(target=func)</span><br><span class="line">	p.daemon = <span class="literal">True</span></span><br><span class="line">	p.start()</span><br><span class="line">	p.join()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># *****</span></span><br><span class="line"><span class="comment"># 我还活着</span></span><br><span class="line"><span class="comment"># end</span></span><br></pre></td></tr></table></figure>

<p>守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p>
</blockquote>
<p>守护子进程和非守护子进程可以并存</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end456&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = Process(target=foo)</span><br><span class="line">    p2 = Process(target=bar)</span><br><span class="line"></span><br><span class="line">    p1.daemon=<span class="literal">True</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main-------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main-------</span></span><br><span class="line"><span class="comment"># 456</span></span><br><span class="line"><span class="comment"># end456</span></span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ol>
<li><p><strong>主进程在其代码结束后就已经算运行完毕了</strong>（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，</p>
</li>
<li><p><strong>主线程在其他非守护线程运行完毕后才算运行完毕</strong>（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    	<span class="built_in">print</span>(each)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is done&#x27;</span> %os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=task)</span><br><span class="line">    t.daemon = <span class="literal">True</span></span><br><span class="line">    t.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 主</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>守护子线程非守护子进程并存</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end456&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=foo)</span><br><span class="line">    t2 = Thread(target=bar)</span><br><span class="line"></span><br><span class="line">    t1.daemon=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main-------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 456</span></span><br><span class="line"><span class="comment"># main-------</span></span><br><span class="line"><span class="comment"># end456</span></span><br></pre></td></tr></table></figure>

<p>注意:</p>
<blockquote>
<ul>
<li>主线程在其他非守护线程运行完毕后才算运行完毕</li>
<li>可能发生<strong>其他非守护线程过晚结束,守护线程执行完毕</strong>的现象</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end456&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=foo)</span><br><span class="line">    t2 = Thread(target=bar)</span><br><span class="line"></span><br><span class="line">    t1.daemon=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main-------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程的结束是指:所有非守护线程的结束</span></span><br><span class="line"><span class="comment"># 这里的非守护线程过晚结束了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 456</span></span><br><span class="line"><span class="comment"># main-------</span></span><br><span class="line"><span class="comment"># end123</span></span><br><span class="line"><span class="comment"># end456</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="8-asyncio模块"><a href="#8-asyncio模块" class="headerlink" title="8.asyncio模块"></a>8.asyncio模块</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><code>@asyncio.coroutine</code>：asyncio模块中的装饰器，用于将一个生成器声明为协程。</p>
<p>yield from 其实就是等待另外一个协程的返回。</p>
<blockquote>
<p>简单来说:<br>@asyncio.coroutine装饰器是协程函数的标志，我们需要在每一个任务函数前加这个装饰器，并在函数中使用yield from。</p>
<p>==在协程中yield from后面必须是子生成器函数==</p>
</blockquote>
<blockquote>
<p>在Python 3.5开始引入了新的语法async和await，以简化并更好地标识异步IO。</p>
<ul>
<li>使用<code>async</code>代替<code>@asyncio.coroutine</code></li>
<li>使用<code>await</code>代替<code>yield from</code></li>
</ul>
</blockquote>
<blockquote>
<p>我们可以使用async修饰将普通函数和生成器函数包装成异步函数和异步生成器。</p>
<ul>
<li><p>异步函数（协程）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_function</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>异步生成器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_generator</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以,函数可以分成四种:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(function) <span class="keyword">is</span> types.FunctionType)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(generator()) <span class="keyword">is</span> types.GeneratorType)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(async_function()) <span class="keyword">is</span> types.CoroutineType)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(async_generator()) <span class="keyword">is</span> types.AsyncGeneratorType)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在协程函数中，可以通过await语法来挂起自身的协程，并等待另一个协程完成直到返回结果：<br><strong>await后面的对象需要是一个Awaitable</strong>。<strong>await的目的是等待协程控制流的返回</strong>，而实现暂停并挂起函数的操作是yield</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">async_function</span>():</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">await_coroutine</span>():</span></span><br><span class="line">       result = <span class="keyword">await</span> async_function()</span><br><span class="line">       <span class="built_in">print</span>(result)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">coroutine</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        coroutine.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> e.value</span><br><span class="line">        </span><br><span class="line">run(await_coroutine())</span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>event_loop 事件循环：<br>程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。</li>
<li>coroutine 协程：<br>协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</li>
<li>task  任务：<br>一个协程对象就是一个原生可以挂起的函数，<strong>任务则是对协程进一步封装</strong>，其中包含任务的各种状态。</li>
<li>future：<br>代表将来执行或没有执行的任务的结果。它和task上没有本质的区别<br>(task对象是Future类的子类)</li>
<li>async/await 关键字：<br>python3.5 用于定义协程的关键字，<strong>async定义一个协程，await用于挂起阻塞的异步调用接口</strong>。</li>
</ul>
<h3 id="走个流程"><a href="#走个流程" class="headerlink" title="走个流程"></a>走个流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用同步方式编写异步功能</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">taskIO_1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始运行IO任务1...&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 假设该任务耗时2s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;IO任务1已完成，耗时2s&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> taskIO_1.__name__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">taskIO_2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始运行IO任务2...&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 假设该任务耗时3s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;IO任务2已完成，耗时3s&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> taskIO_2.__name__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span> <span class="comment"># 调用方</span></span><br><span class="line">    tasks = [taskIO_1(), taskIO_2()]  <span class="comment"># 把所有任务添加到task中</span></span><br><span class="line">    done,pending = <span class="keyword">await</span> asyncio.wait(tasks) <span class="comment"># 子生成器</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> done: <span class="comment"># done和pending都是一个任务，所以返回结果需要逐个调用result()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;协程无序返回值：&#x27;</span>+r.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop() <span class="comment"># 创建一个事件循环对象loop</span></span><br><span class="line">    loop.run_until_complete(main()) <span class="comment"># 完成事件循环，直到最后一个任务结束</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;所有IO任务总耗时%.5f秒&#x27;</span> % <span class="built_in">float</span>(time.time()-start))</span><br><span class="line"><span class="comment"># 开始运行IO任务1...</span></span><br><span class="line"><span class="comment"># 开始运行IO任务2...</span></span><br><span class="line"><span class="comment"># IO任务1已完成，耗时2s</span></span><br><span class="line"><span class="comment"># IO任务2已完成，耗时3s</span></span><br><span class="line"><span class="comment"># 协程无序返回值：taskIO_1</span></span><br><span class="line"><span class="comment"># 协程无序返回值：taskIO_2</span></span><br><span class="line"><span class="comment"># 所有IO任务总耗时3.00328秒</span></span><br></pre></td></tr></table></figure>



<h3 id="使用asyncio-coroutine装饰器"><a href="#使用asyncio-coroutine装饰器" class="headerlink" title="使用asyncio.coroutine装饰器"></a>使用asyncio.coroutine装饰器</h3><p>Python3.3的yield from语法可以把生成器的操作委托给另一个生成器，生成器的调用方可以直接与子生成器进行通信：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_gen</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> sub_gen())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> gen():</span><br><span class="line">        <span class="built_in">print</span>(val)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p>利用这一特性，使用yield from能够编写出类似协程效果的函数调用，在3.5之前，asyncio正是使用@asyncio.coroutine和yield from语法来创建协程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Compute %s + %s ...&quot;</span> % (x, y))</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> compute(x, y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s + %s = %s&quot;</span> % (x, y, result))</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>然而，用yield from容易在表示协程和生成器中混淆，没有良好的语义性，所以在Python 3.5推出了更新的async/await表达式来作为协程的语法。</p>
<p>因此类似以下的调用是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> lock:</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> lock):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> coro())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">await</span> coro())</span><br></pre></td></tr></table></figure>

<p>初步使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">future = asyncio.Future()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--- coro1 ---&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">.1</span>)</span><br><span class="line">    future.set_result(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--- coro2 ---&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> future)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait([</span><br><span class="line">    coro1(), </span><br><span class="line">    coro2(),</span><br><span class="line">]))</span><br><span class="line">loop.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># data</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个协程在在事件循环中，协程coro1在执行第一句后挂起自身切到asyncio.sleep，而协程coro2一直等待future的结果，让出事件循环，计时器结束后coro1执行了第二句设置了future的值，被挂起的coro2恢复执行，打印出future的结果’data’。</p>
<p>future可以被await证明了<strong>future对象是一个Awaitable</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用同步方式编写异步功能</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine </span><span class="comment"># 标志协程的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taskIO_1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始运行IO任务1...&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 假设该任务耗时2s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;IO任务1已完成，耗时2s&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> taskIO_1.__name__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine </span><span class="comment"># 标志协程的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taskIO_2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始运行IO任务2...&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 假设该任务耗时3s</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;IO任务2已完成，耗时3s&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> taskIO_2.__name__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine </span><span class="comment"># 标志协程的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span> <span class="comment"># 调用方</span></span><br><span class="line">    tasks = [taskIO_1(), taskIO_2()]  <span class="comment"># 把所有任务添加到task中</span></span><br><span class="line">    done,pending = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.wait(tasks) <span class="comment"># 子生成器</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> done: <span class="comment"># done和pending都是一个任务，所以返回结果需要逐个调用result()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;协程无序返回值：&#x27;</span>+r.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    loop = asyncio.get_event_loop() <span class="comment"># 创建一个事件循环对象loop</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_until_complete(main()) <span class="comment"># 完成事件循环，直到最后一个任务结束</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        loop.close() <span class="comment"># 结束事件循环</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;所有IO任务总耗时%.5f秒&#x27;</span> % <span class="built_in">float</span>(time.time()-start))</span><br><span class="line"><span class="comment"># 开始运行IO任务1...</span></span><br><span class="line"><span class="comment"># 开始运行IO任务2...</span></span><br><span class="line"><span class="comment"># IO任务1已完成，耗时2s</span></span><br><span class="line"><span class="comment"># IO任务2已完成，耗时3s</span></span><br><span class="line"><span class="comment"># 协程无序返回值：taskIO_1</span></span><br><span class="line"><span class="comment"># 协程无序返回值：taskIO_2</span></span><br><span class="line"><span class="comment"># 所有IO任务总耗时3.00328秒</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>上面代码先通过get_event_loop()获取了一个标准事件循环loop(因为是一个，所以协程是单线程)</p>
</li>
<li><p>然后，我们通过run_until_complete(main())来运行协程(此处把调用方协程main()作为参数，调用方负责调用其他委托生成器)，run_until_complete的特点就像该函数的名字，直到循环事件的所有事件都处理完才能完整结束。</p>
</li>
<li><p>进入调用方协程，我们把多个任务[taskIO_1()和taskIO_2()]放到一个task列表中，可理解为打包任务。</p>
</li>
<li><p>使用==asyncio.wait(tasks)来获取一个awaitable objects==,即<strong>可等待对象的集合</strong>(此处的aws是协程的列表)，并发运行传入的aws，同时通过yield from返回一个包含(done, pending)的元组，done表示已完成的任务列表，pending表示未完成的任务列表；</p>
<blockquote>
<ul>
<li>如果使asyncio.as_completed(tasks)则会按完成顺序生成协程的迭代器(常用于for循环中)，因此当你用它迭代时，会尽快得到每个可用的结果。</li>
<li>此外，当轮询到某个事件时(如taskIO_1())，直到遇到该任务中的yield from中断，开始处理下一个事件(如taskIO_2()))，当yield from后面的子生成器完成任务时，该事件才再次被唤醒</li>
</ul>
</blockquote>
</li>
<li><p>因为done里面有我们需要的返回结果，但它目前还是个任务列表，所以要取出返回的结果值，我们遍历它并逐个调用result()取出结果即可。</p>
<blockquote>
<p>(注：对于asyncio.wait()和asyncio.as_completed()返回的结果均是先完成的任务结果排在前面，所以此时打印出的结果不一定和原始顺序相同，但使用gather()的话可以得到原始顺序的结果集) </p>
</blockquote>
</li>
<li><p>最后我们通过loop.close()关闭事件循环。</p>
</li>
</ol>
<h3 id="使用async和await实现协程"><a href="#使用async和await实现协程" class="headerlink" title="使用async和await实现协程"></a>使用async和await实现协程</h3><p>asyncio的使用可分三步走：</p>
<ol>
<li>创建事件循环</li>
<li>指定循环模式并运行</li>
<li>关闭循环</li>
</ol>
<p>简单来说就是:</p>
<ol>
<li>将协程对象转为task任务对象</li>
<li>定义一个事件循环对象容器用来存放task</li>
<li>将task任务扔进事件循环对象中并触发</li>
</ol>
<h4 id="1-定义一个协程"><a href="#1-定义一个协程" class="headerlink" title="1.定义一个协程"></a>1.定义一个协程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting: &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">coroutine = do_some_work(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># coroutine是协程,不是函数,所以do_some_work(2)返回的是协程对象</span></span><br><span class="line"><span class="built_in">print</span>(coroutine)</span><br><span class="line"><span class="comment"># &lt;coroutine object do_some_work at 0x0000020BDB2EAAC8&gt;</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TIME: &#x27;</span>, time.time() - start)</span><br><span class="line"><span class="comment"># Waiting:  2</span></span><br><span class="line"><span class="comment"># TIME:  0.0010001659393310547</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过async关键字定义一个协程（coroutine），协程也是一种对象。协程不能直接运行，需要把协程加入到事件循环（loop），事件循环在适当的时候调用协程。</li>
<li><code>asyncio.get_event_loop</code>方法可以创建一个事件循环，然后使用run_until_complete将协程注册到事件循环，并启动事件循环。</li>
</ul>
<h4 id="2-创建一个task"><a href="#2-创建一个task" class="headerlink" title="2.创建一个task"></a>2.创建一个task</h4><p>在注册事件循环的时候，其实是run_until_complete方法将<strong>协程包装成为了一个任务（task）对象</strong>。</p>
<blockquote>
<p>==task对象是Future类的子类==。保存了协程运行后的状态，用于未来获取协程的结果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting: &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">coroutine = do_some_work(<span class="number">2</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># task = asyncio.ensure_future(coroutine)</span></span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line"><span class="built_in">print</span>(task)</span><br><span class="line"><span class="comment"># &lt;Task pending coro=&lt;do_some_work() running at D:\trainingfile\training6.py:5&gt;&gt;</span></span><br><span class="line"><span class="comment"># 创建task后，task在加入事件循环之前是pending状态</span></span><br><span class="line"></span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(task)</span><br><span class="line"><span class="comment"># &lt;Task finished coro=&lt;do_some_work() done, defined at D:\trainingfile\training6.py:5&gt; result=None&gt;</span></span><br><span class="line"><span class="comment"># 打印finished状态。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TIME: &#x27;</span>, time.time() - start)</span><br><span class="line"><span class="comment"># TIME:  0.0019979476928710938</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>asyncio.ensure_future(coroutine) 和 loop.create_task(coroutine)都可以创建一个task</li>
<li>run_until_complete的参数是一个futrue对象。<br>当传入一个协程，其内部会自动封装成task，==task是Future的子类==。<code>isinstance(task, asyncio.Future)</code>将会输出True。</li>
</ul>
</blockquote>
<h4 id="3-绑定回调"><a href="#3-绑定回调" class="headerlink" title="3.绑定回调"></a>3.绑定回调</h4><p>绑定回调，在task执行完毕的时候可以获取执行的结果，回调的最后一个参数是future对象，通过该对象可以获取协程返回值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting: &#x27;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">future</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Callback: &#x27;</span>, future.result())</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">coroutine = do_some_work(<span class="number">2</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">task = asyncio.ensure_future(coroutine)</span><br><span class="line"><span class="built_in">print</span>(task)</span><br><span class="line"></span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TIME: &#x27;</span>, time.time() - start)</span><br><span class="line"><span class="built_in">print</span>(task)</span><br><span class="line"><span class="comment"># &lt;Task pending coro=&lt;do_some_work() running at D:\trainingfile\training5.py:4&gt;&gt;</span></span><br><span class="line"><span class="comment"># Waiting:  2</span></span><br><span class="line"><span class="comment"># Callback:  Done after 2s</span></span><br><span class="line"><span class="comment"># TIME:  0.0010004043579101562</span></span><br><span class="line"><span class="comment"># &lt;Task finished coro=&lt;do_some_work() done, defined at D:\trainingfile\training5.py:4&gt; result=&#x27;Done after 2s&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果回调需要多个参数，可以通过偏函数导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting: &#x27;</span>, x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">t, future</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Callback:&#x27;</span>, t, future.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">coroutine = do_some_work(<span class="number">2</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">task = asyncio.ensure_future(coroutine)</span><br><span class="line"><span class="built_in">print</span>(task)</span><br><span class="line"></span><br><span class="line">task.add_done_callback(functools.partial(callback, <span class="string">&#x27;hyl&#x27;</span>))</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TIME: &#x27;</span>, time.time() - start)</span><br><span class="line"><span class="built_in">print</span>(task)</span><br><span class="line"><span class="comment"># &lt;Task pending coro=&lt;do_some_work() running at D:\trainingfile\training1.py:5&gt;&gt;</span></span><br><span class="line"><span class="comment"># Waiting:  2</span></span><br><span class="line"><span class="comment"># Callback: hyl Done after 2s</span></span><br><span class="line"><span class="comment"># TIME:  0.00099945068359375</span></span><br><span class="line"><span class="comment"># &lt;Task finished coro=&lt;do_some_work() done, defined at D:\trainingfile\training1.py:5&gt; result=&#x27;Done after 2s&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>coroutine执行结束时候会调用回调函数。并通过参数future获取协程执行的结果。<br>我们创建的task和回调里的future对象，实际上是同一个对象。</p>
</blockquote>
<h4 id="4-future-与-result"><a href="#4-future-与-result" class="headerlink" title="4.future 与 result"></a>4.future 与 result</h4><blockquote>
<ul>
<li>前面不绑定回调的例子中，我们可以看到task有fiinished状态。</li>
<li>当task处于fiinished状态，我们可以直接使用task的result方法获取返回值。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">coroutine = do_some_work(<span class="number">2</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">task = asyncio.ensure_future(coroutine)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task ret: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(task.result()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TIME: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))</span><br><span class="line"><span class="comment"># Waiting 2</span></span><br><span class="line"><span class="comment"># Task ret: Done after 2s</span></span><br><span class="line"><span class="comment"># TIME: 0.0009996891021728516</span></span><br></pre></td></tr></table></figure>



<h4 id="5-阻塞和await"><a href="#5-阻塞和await" class="headerlink" title="5.阻塞和await"></a>5.阻塞和await</h4><blockquote>
<ul>
<li>使用async可以定义协程对象</li>
<li>使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。</li>
<li>协程遇到await，==事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行==。</li>
</ul>
</blockquote>
<p>我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting: &#x27;</span>, x)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">coroutine = do_some_work(<span class="number">2</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">task = asyncio.ensure_future(coroutine)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task ret: &#x27;</span>, task.result())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TIME: &#x27;</span>, time.time() - start)</span><br><span class="line"><span class="comment"># Waiting:  2</span></span><br><span class="line"><span class="comment"># Task ret:  Done after 2s</span></span><br><span class="line"><span class="comment"># TIME:  2.001849412918091</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在 asyncio.sleep的时候，使用await让出控制权。</li>
<li>即当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出，以便loop调用其他的协程。现在我们的例子就用耗时的阻塞操作了。</li>
</ul>
</blockquote>
<h4 id="6-并发和并行"><a href="#6-并发和并行" class="headerlink" title="6.并发和并行"></a>6.并发和并行</h4><p>asyncio实现并发，就需要多个协程来完成任务，每当有任务阻塞的时候就await，然后其他协程继续工作。创建多个协程的列表，然后将这些协程注册到事件循环中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting: &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">coroutine3 = do_some_work(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务列表</span></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(coroutine1),</span><br><span class="line">    asyncio.ensure_future(coroutine2),</span><br><span class="line">    asyncio.ensure_future(coroutine3)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># wait 会分别把各个协程包装进一个 Task 对象</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task ret: &#x27;</span>, task.result())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TIME: &#x27;</span>, time.time() - start)</span><br><span class="line"><span class="comment"># Waiting:  1</span></span><br><span class="line"><span class="comment"># Waiting:  2</span></span><br><span class="line"><span class="comment"># Waiting:  4</span></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="comment"># Task ret:  Done after 1s</span></span><br><span class="line"><span class="comment"># Task ret:  Done after 2s</span></span><br><span class="line"><span class="comment"># Task ret:  Done after 4s</span></span><br><span class="line"><span class="comment"># TIME:  4.002715826034546</span></span><br></pre></td></tr></table></figure>

<ul>
<li>总时间为4s左右。4s的阻塞时间，足够前面两个协程执行完毕。如果是同步顺序的任务，那么至少需要7s。此时我们使用了aysncio实现了并发。</li>
<li><code>asyncio.wait(tasks) </code>也可以使用 <code>asyncio.gather(*tasks)</code> ,前者接受一个task列表，后者接收一堆task。</li>
</ul>
<blockquote>
<p>wait()官方文档用法如下：</p>
<p><code>done, pending = await asyncio.wait(aws)</code></p>
</blockquote>
<h4 id="7-协程嵌套"><a href="#7-协程嵌套" class="headerlink" title="7.协程嵌套"></a>7.协程嵌套</h4><p>嵌套的协程，即一个协程中await了另外一个协程，如此连接起来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting: &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.ensure_future(coroutine1),</span><br><span class="line">        asyncio.ensure_future(coroutine2),</span><br><span class="line">        asyncio.ensure_future(coroutine3)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    dones, pendings = <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> dones:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Task ret: &#x27;</span>, task.result())</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	start = time.time()</span><br><span class="line"></span><br><span class="line">	loop = asyncio.get_event_loop()</span><br><span class="line">	loop.run_until_complete(main())</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;TIME: &#x27;</span>, time.time() - start)</span><br><span class="line"><span class="comment"># Waiting:  1</span></span><br><span class="line"><span class="comment"># Waiting:  2</span></span><br><span class="line"><span class="comment"># Waiting:  4</span></span><br><span class="line"><span class="comment"># Task ret:  Done after 1s</span></span><br><span class="line"><span class="comment"># Task ret:  Done after 2s</span></span><br><span class="line"><span class="comment"># Task ret:  Done after 4s</span></span><br><span class="line"><span class="comment"># TIME:  4.001962423324585</span></span><br></pre></td></tr></table></figure>



<h4 id="8-协程停止"><a href="#8-协程停止" class="headerlink" title="8.协程停止"></a>8.协程停止</h4><p>future对象有几个状态：</p>
<ul>
<li><p>Pending</p>
<p>创建future的时候，task为pending</p>
</li>
<li><p>Running</p>
<p>事件循环调用执行的时候就是running</p>
</li>
<li><p>Done</p>
<p>调用完毕是done</p>
</li>
<li><p>Cancelled</p>
<p>如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting: &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line">coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">coroutine3 = do_some_work(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(coroutine1),</span><br><span class="line">    asyncio.ensure_future(coroutine2),</span><br><span class="line">    asyncio.ensure_future(coroutine3)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(asyncio.Task.all_tasks())</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.Task.all_tasks():</span><br><span class="line">        <span class="built_in">print</span>(task.cancel())</span><br><span class="line">    loop.stop()</span><br><span class="line">    loop.run_forever()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TIME: &#x27;</span>, time.time() - start)</span><br></pre></td></tr></table></figure>

<p>启动事件循环之后，马上ctrl+c，会触发run_until_complete的执行异常 KeyBorardInterrupt。然后通过循环asyncio.Task取消future。可以看到输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Waiting:  1</span><br><span class="line">Waiting:  2</span><br><span class="line">Waiting:  2</span><br><span class="line">&#123;&lt;Task pending coro=&lt;do_some_work() running at /Users/ghost/Rsj217/python3.6/async/async-main.py:18&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x101230648&gt;()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/tasks.py:374]&gt;, &lt;Task pending coro=&lt;do_some_work() running at /Users/ghost/Rsj217/python3.6/async/async-main.py:18&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x1032b10a8&gt;()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/tasks.py:374]&gt;, &lt;Task pending coro=&lt;wait() running at /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/tasks.py:307&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x103317d38&gt;()]&gt; cb=[_run_until_complete_cb() at /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/base_events.py:176]&gt;, &lt;Task pending coro=&lt;do_some_work() running at /Users/ghost/Rsj217/python3.6/async/async-main.py:18&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x103317be8&gt;()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/tasks.py:374]&gt;&#125;</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">TIME:  0.8858370780944824</span><br></pre></td></tr></table></figure>

<p>True表示cannel成功</p>
<h4 id="9-不同线程的事件循环"><a href="#9-不同线程的事件循环" class="headerlink" title="9.不同线程的事件循环"></a>9.不同线程的事件循环</h4><ul>
<li>很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。</li>
<li>当前线程创建一个事件循环，然后再新建一个线程，在新线程中启动事件循环。当前线程不会被block。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span>(<span class="params">loop</span>):</span></span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_forever()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_work</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;More work &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    time.sleep(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Finished more work &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">new_loop = asyncio.new_event_loop()</span><br><span class="line">t = Thread(target=start_loop, args=(new_loop,))</span><br><span class="line">t.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TIME: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.time() - start))</span><br><span class="line"></span><br><span class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">6</span>)</span><br><span class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TIME: 0.0019989013671875</span></span><br><span class="line"><span class="comment"># More work 6</span></span><br><span class="line"><span class="comment"># Finished more work 6</span></span><br><span class="line"><span class="comment"># More work 3</span></span><br><span class="line"><span class="comment"># Finished more work 3</span></span><br></pre></td></tr></table></figure>



<h3 id="async-with-和async-for-用法说明"><a href="#async-with-和async-for-用法说明" class="headerlink" title="async with 和async for 用法说明"></a>async with 和async for 用法说明</h3><h4 id="async-with"><a href="#async-with" class="headerlink" title="async with"></a>async with</h4><p>异步上下文管理器指的是<strong>在enter和exit方法处能够暂停执行的上下文管理器</strong>。</p>
<blockquote>
<p>为了实现这样的功能，需要加入两个新的方法：__aenter__ 和__aexit__。这两个方法都要返回一个 awaitable类型的值。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncContextManager</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aenter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">await</span> log(<span class="string">&#x27;entering context&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aexit__</span>(<span class="params">self, exc_type, exc, tb</span>):</span></span><br><span class="line">        <span class="keyword">await</span> log(<span class="string">&#x27;exiting context&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:</span><br><span class="line">    BLOCK</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 上面代码等同于下面:</span></span><br><span class="line">mgr = (EXPR)</span><br><span class="line">aexit = <span class="built_in">type</span>(mgr).__aexit__</span><br><span class="line">aenter = <span class="built_in">type</span>(mgr).__aenter__(mgr)</span><br><span class="line">exc = <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">VAR = <span class="keyword">await</span> aenter</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    BLOCK</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">await</span> aexit(mgr, *sys.exc_info()):</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">await</span> aexit(mgr, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>



<h4 id="async-for"><a href="#async-for" class="headerlink" title="async for"></a>async for</h4><ul>
<li>异步迭代器就是<strong>能够在next方法中调用异步代码</strong>。</li>
<li>一个异步可迭代对象（asynchronous iterable）<strong>能够在迭代过程中调用异步代码</strong></li>
</ul>
<blockquote>
<p>为了支持异步迭代：</p>
<ol>
<li>一个对象必须实现__aiter__方法，该方法返回一个异步迭代器（asynchronous iterator）对象。 </li>
<li>一个异步迭代器对象必须实现__anext__方法，该方法返回一个awaitable类型的值。 </li>
<li>为了停止迭代，__anext__必须抛出一个StopAsyncIteration异常。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncIterable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__aiter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__anext__</span>(<span class="params">self</span>):</span></span><br><span class="line">        data = <span class="keyword">await</span> self.fetch_data()</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> TARGET <span class="keyword">in</span> ITER:</span><br><span class="line">    BLOCK</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    BLOCK2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 上面代码等同于下面:</span></span><br><span class="line"><span class="built_in">iter</span> = (ITER)</span><br><span class="line"><span class="built_in">iter</span> = <span class="built_in">type</span>(<span class="built_in">iter</span>).__aiter__(<span class="built_in">iter</span>)</span><br><span class="line">running = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> running:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        TARGET = <span class="keyword">await</span> <span class="built_in">type</span>(<span class="built_in">iter</span>).__anext__(<span class="built_in">iter</span>)</span><br><span class="line">    <span class="keyword">except</span> StopAsyncIteration:</span><br><span class="line">        running = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        BLOCK</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    BLOCK2</span><br></pre></td></tr></table></figure>





<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="1-基础知识补充"><a href="#1-基础知识补充" class="headerlink" title="1.基础知识补充"></a>1.基础知识补充</h3><ul>
<li><p><code>loop = asyncio.get_event_loop()</code>:<br>每个线程中只能有一个事件循环，get_event_loop 方法会获取当前已经存在的事件循环，如果当前线程中没有，就会新建一个</p>
</li>
<li><p><code>loop.run_until_complete(coroutine)</code>:</p>
<p>将协程对象注入到事件循环，协程的运行由事件循环控制。</p>
<blockquote>
<ul>
<li>事件循环的 run_until_complete 方法会阻塞运行，直到任务全部完成。</li>
<li>协程对象作为 run_until_complete 方法的参数，loop 会自动将协程对象包装成任务来运行。</li>
<li>任务对象保存了协程运行后的状态，用于未来获取协程的结果。</li>
<li>为什么要使用协程对象创建任务？<br>因为在这个过程中 asyncio.Task 做了一些工作，包括预激协程、协程运行中遇到某些异常时的处理</li>
</ul>
</blockquote>
</li>
<li><p><strong>协程对象不能直接运行，必须放入事件循环中或者由 yield from 语句调用</strong>。</p>
</li>
<li><p><strong>回调函数的最后一个参数是 future 或 task 对象</strong>，通过该对象可以获取协程返回值。如果回调需要多个参数，可以通过偏函数导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">name, task</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;[callback] Hello &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;[callback] coroutine state: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(task._state))</span><br><span class="line">    </span><br><span class="line">    task = loop.create_task(coroutine)</span><br><span class="line">    task.add_done_callback(functools.partial(callback, <span class="string">&#x27;hyl&#x27;</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实多数情况下无需调用 task 的 add_done_callback 方法，可以直接把回调函数中的代码写入 await 语句后面</p>
</blockquote>
</li>
<li><p>asyncio.sleep 与 time.sleep 是不同的</p>
<ul>
<li><p><code>asyncio.sleep</code>阻塞当前协程，即 corowork 函数的运行</p>
<blockquote>
<p>阻塞当前协程，CPU 可以在线程内的其它协程中执行</p>
</blockquote>
</li>
<li><p><code>time.sleep</code>会阻塞整个线程</p>
</li>
</ul>
</li>
<li><p>实际项目中，往往有多个协程创建多个任务对象，同时在一个 loop 里运行。<br>为了把多个协程交给 loop，需要借助 asyncio.gather 方法。</p>
<blockquote>
<ul>
<li><strong>asyncio.gather 方法中参数的顺序决定了协程的运行顺序</strong>(asyncio.wait也是按顺序执行)</li>
<li>使用 asyncio.gather 方法,任务的 result 方法可以获得对应的协程函数的 return 值。 </li>
</ul>
</blockquote>
<blockquote>
<p>多数情况下同样无需调用 task 的 result 方法获取协程函数的 return 值，因为事件循环的 run_until_complete 方法的返回值就是协程函数的 return 值</p>
</blockquote>
</li>
</ul>
<h3 id="2-全流程解析"><a href="#2-全流程解析" class="headerlink" title="2.全流程解析"></a>2.全流程解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">four</span>():</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">corowork</span>(<span class="params">name, t</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[corowork] Start coroutine&#x27;</span>, name)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(t)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[corowork] Stop coroutine&#x27;</span>, name)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Coroutine &#123;&#125; OK&#x27;</span>.<span class="built_in">format</span>(name)  </span><br><span class="line"></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    coroutine1 = corowork(<span class="string">&#x27;ONE&#x27;</span>, <span class="number">3</span>) </span><br><span class="line">    coroutine2 = corowork(<span class="string">&#x27;TWO&#x27;</span>, <span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">    task1 = loop.create_task(coroutine1)  </span><br><span class="line">    task2 = loop.create_task(coroutine2)     </span><br><span class="line"></span><br><span class="line">    gather = asyncio.gather(task1, task2)  </span><br><span class="line">    loop.run_until_complete(gather)        </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[task1] &#x27;</span>, task1.result())      </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[task2] &#x27;</span>, task2.result())      </span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;运行耗时：&#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line"></span><br><span class="line">four()</span><br><span class="line"><span class="comment"># [corowork] Start coroutine ONE</span></span><br><span class="line"><span class="comment"># [corowork] Start coroutine TWO</span></span><br><span class="line"><span class="comment"># [corowork] Stop coroutine TWO</span></span><br><span class="line"><span class="comment"># [corowork] Stop coroutine ONE</span></span><br><span class="line"><span class="comment"># [task1]  Coroutine ONE OK</span></span><br><span class="line"><span class="comment"># [task2]  Coroutine TWO OK</span></span><br><span class="line"><span class="comment"># 运行耗时：3.0175</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>首先运行 task1</li>
<li>打印 [corowork] Start coroutine ONE</li>
<li>遇到 asyncio.sleep 阻塞</li>
<li>释放 CPU 转到 task2 中执行</li>
<li>打印 [corowork] Start coroutine TWO</li>
<li>再次遇到 asyncio.sleep 阻塞</li>
<li><strong>这次没有其它协程可以运行了，只能等阻塞结束</strong></li>
<li>task2 的阻塞时间较短，阻塞 1 秒后先结束，打印 [corowork] Stop coroutine TWO</li>
<li>又过了 2 秒，阻塞 3 秒的 task1 也结束了阻塞，打印 [corowork] Stop coroutine ONE</li>
<li>至此两个任务全部完成，事件循环停止</li>
<li>打印两个任务的 result</li>
<li>打印程序运行时间</li>
<li>程序全部结束</li>
</ol>
</blockquote>
<h3 id="3-是否要关闭事件循环"><a href="#3-是否要关闭事件循环" class="headerlink" title="3.是否要关闭事件循环"></a>3.是否要关闭事件循环</h3><p>事件循环有一个 stop 方法用来停止循环和一个 close 方法用来关闭循环。以上示例中都没有调用 loop.close 方法，似乎并没有什么问题。所以到底要不要调用 loop.close 呢？</p>
<blockquote>
<p>简单来说，loop 只要不关闭，就还可以再次运行 run_until_complete 方法，关闭后则不可运行。有人会建议调用 loop.close，彻底清理 loop 对象防止误用，其实多数情况下根本没有这个必要。</p>
</blockquote>
<h3 id="4-asyncio-gather-和-asyncio-wait-的异同"><a href="#4-asyncio-gather-和-asyncio-wait-的异同" class="headerlink" title="4.asyncio.gather 和 asyncio.wait  的异同"></a>4.asyncio.gather 和 asyncio.wait  的异同</h3><ul>
<li><p>两者作用相同，都是将协程任务按顺序排定，再将返回值作为参数加入到事件循环中。</p>
</li>
<li><p>asyncio.wait 可以获取任务的执行状态（PENING &amp; FINISHED），当有一些特别的需求例如在某些情况下取消任务，可以使用 asyncio.wait 方法。</p>
</li>
</ul>
<h3 id="5-取消任务的两种方法"><a href="#5-取消任务的两种方法" class="headerlink" title="5.取消任务的两种方法"></a>5.取消任务的两种方法</h3><ul>
<li>loop.stop() : 事件循环的 stop 方法<strong>取消所有任务</strong>，停止事件循环</li>
<li>任务的 cancel 方法也可以取消任务，而 asyncio.Task.all_tasks 方法可以获得事件循环中的全部任务</li>
</ul>
<h4 id="loop-stop"><a href="#loop-stop" class="headerlink" title="loop.stop"></a>loop.stop</h4><p>PENDING 状态的任务才能被取消，FINISHED 状态的任务已经完成，不能取消</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params"><span class="built_in">id</span>, t</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Wroking...&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(t)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Work &#123;&#125; done&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    coroutines = [work(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_until_complete(asyncio.gather(*coroutines)) </span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="comment"># 事件循环的 stop 方法取消所有任务，停止事件循环</span></span><br><span class="line">        loop.stop()    </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        loop.close()  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Wroking...</span></span><br><span class="line"><span class="comment"># Wroking...</span></span><br><span class="line"><span class="comment"># Wroking...</span></span><br><span class="line"><span class="comment"># Work 1 done</span></span><br><span class="line"><span class="comment"># ^C%</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>首先，id 为 1 的协程先启动运行</li>
<li>打印 Working…</li>
<li>遇到 IO 阻塞，释放 CPU ，CPU 去到 id 为 2 的协程中运行</li>
<li>同样首先打印 Working…</li>
<li>遇到 IO 阻塞，同样释放 CPU ，第三个协程开始运行，打印 Working…</li>
<li><strong>以上步骤瞬间完成，这时候的 loop 中全部协程处于阻塞状态</strong></li>
<li>一秒钟后，id 为 1 的协程结束阻塞</li>
<li>打印 Work 1 done</li>
<li>然后手动按下快捷键 Ctrl + C ，触发 KeyboardInterrupt 异常</li>
<li>try except 语句捕获异常，执行 # 3 和 # 4</li>
<li>程序运行完毕</li>
</ol>
</blockquote>
<h4 id="task-cancel"><a href="#task-cancel" class="headerlink" title="task.cancel"></a>task.cancel</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params"><span class="built_in">id</span>, t</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Wroking...&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(t)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Work &#123;&#125; done&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    coroutines = [work(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>)]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        loop.run_until_complete(asyncio.gather(*coroutines))</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        <span class="comment"># 每个线程里只能有一个事件循环</span></span><br><span class="line">        <span class="comment"># 此方法可以获得事件循环中的所有任务的集合</span></span><br><span class="line">        <span class="comment"># 任务的状态有 PENDING 和 FINISHED 两种</span></span><br><span class="line">        tasks = asyncio.Task.all_tasks()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tasks:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;取消任务：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="comment"># 任务的 cancel 方法可以取消未完成的任务</span></span><br><span class="line">            <span class="comment"># 取消成功返回 True ，已完成的任务取消失败返回 False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;取消状态：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i.cancel()))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        loop.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"><span class="comment"># Wroking...</span></span><br><span class="line"><span class="comment"># Wroking...</span></span><br><span class="line"><span class="comment"># Wroking...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消任务：&lt;Task pending coro=&lt;work() running at training1.py:5&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x0000026ED0CA3BE8&gt;()]&gt; cb=[gather.&lt;locals&gt;._done_callback() at F:\Anaconda3\lib\asyncio\tasks.py:660]&gt;</span></span><br><span class="line"><span class="comment"># 取消状态：True</span></span><br><span class="line"><span class="comment"># 取消任务：&lt;Task pending coro=&lt;work() running at training1.py:5&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x0000026ED0CA3B88&gt;()]&gt; cb=[gather.&lt;locals&gt;._done_callback() at F:\Anaconda3\lib\asyncio\tasks.py:660]&gt;</span></span><br><span class="line"><span class="comment"># 取消状态：True</span></span><br><span class="line"><span class="comment"># 取消任务：&lt;Task pending coro=&lt;work() running at training1.py:5&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x0000026ED0CA3C48&gt;()]&gt; cb=[gather.&lt;locals&gt;._done_callback() at F:\Anaconda3\lib\asyncio\tasks.py:660]&gt;</span></span><br><span class="line"><span class="comment"># 取消状态：True</span></span><br></pre></td></tr></table></figure>



<h3 id="6-loop-run-forever-无限循环"><a href="#6-loop-run-forever-无限循环" class="headerlink" title="6.loop.run_forever 无限循环"></a>6.loop.run_forever 无限循环</h3><h4 id="排定任务"><a href="#排定任务" class="headerlink" title="排定任务"></a>排定任务</h4><p>排定 task / future 在事件循环中的执行顺序，也就是对应的协程先执行哪个，遇到 IO 阻塞时，CPU 转而运行哪个任务，这是我们在进行异步编程时的一个需求。</p>
<blockquote>
<p>前文所示的多任务程序中，事件循环里的任务的执行顺序由 asyncio.ensure_future / loop.create_task 和 asyncio.gather 排定。 </p>
</blockquote>
<blockquote>
<p>run_forever 方法为无限运行事件循环，需要自定义 loop.stop 方法并执行之才会停止。</p>
</blockquote>
<blockquote>
<p>有两种执行loop.stop的方法:</p>
<ol>
<li>单任务事件循环，将 loop 作为参数传入协程函数创建协程，在协程内部执行 loop.stop 方法停止事件循环。</li>
<li>多任务事件循环，使用回调函数执行 loop.stop 停止事件循环</li>
</ol>
</blockquote>
<h4 id="在协程内部执行loop-stop方法停止事件循环"><a href="#在协程内部执行loop-stop方法停止事件循环" class="headerlink" title="在协程内部执行loop.stop方法停止事件循环"></a>在协程内部执行loop.stop方法停止事件循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">loop, t</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(t) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;after &#123;&#125;s stop&#x27;</span>.<span class="built_in">format</span>(t))</span><br><span class="line">    loop.stop()             <span class="comment"># 停止事件循环，stop 后仍可重新运行</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = asyncio.ensure_future(work(loop, <span class="number">1</span>))</span><br><span class="line">loop.run_forever()  <span class="comment"># 无限运行事件循环，直至 loop.stop 停止</span></span><br><span class="line">loop.close()        <span class="comment"># 关闭事件循环，只有 loop 处于停止状态才会执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start</span></span><br><span class="line"><span class="comment"># after 1s stop</span></span><br></pre></td></tr></table></figure>

<h4 id="使用回调函数执行-loop-stop-停止事件循环"><a href="#使用回调函数执行-loop-stop-停止事件循环" class="headerlink" title="使用回调函数执行 loop.stop 停止事件循环"></a>使用回调函数执行 loop.stop 停止事件循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_stop</span>(<span class="params">loop, future</span>):</span>    <span class="comment"># 函数的最后一个参数须为 future / task</span></span><br><span class="line">    loop.stop()                 <span class="comment"># 停止事件循环，stop 后仍可重新运行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">t</span>):</span>              <span class="comment"># 协程函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(t)      <span class="comment"># 模拟 IO 操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;after &#123;&#125;s stop&#x27;</span>.<span class="built_in">format</span>(t))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 创建任务收集器，参数为任意数量的协程，任务收集器本身也是 task / future 对象</span></span><br><span class="line">    tasks = asyncio.gather(work(<span class="number">1</span>), work(<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># 任务收集器的 add_done_callback 方法添加回调函数</span></span><br><span class="line">    <span class="comment"># 当所有任务完成后，自动运行此回调函数</span></span><br><span class="line">    <span class="comment"># 注意 add_done_callback 方法的参数是回调函数</span></span><br><span class="line">    <span class="comment"># 这里使用 functools.partial 方法创建偏函数以便将 loop 作为参数加入</span></span><br><span class="line">    tasks.add_done_callback(functools.partial(loop_stop, loop))</span><br><span class="line">    loop.run_forever()  <span class="comment"># 无限运行事件循环，直至 loop.stop 停止</span></span><br><span class="line">    loop.close()        <span class="comment"># 关闭事件循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    main()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;耗时：&#123;:.4f&#125;s&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br></pre></td></tr></table></figure>



<h3 id="7-将普通函数作为任务注入事件循环的三种方法"><a href="#7-将普通函数作为任务注入事件循环的三种方法" class="headerlink" title="7.将普通函数作为任务注入事件循环的三种方法"></a>7.将普通函数作为任务注入事件循环的三种方法</h3><ul>
<li>loop.call_soon</li>
<li>loop.call_later</li>
<li>loop.call_at &amp; loop.time</li>
</ul>
<p>这三个 call_xxx 方法的作用都是将<strong>普通函数</strong>作为任务排定到事件循环中，返回值都是 asyncio.events.TimerHandle 实例</p>
<blockquote>
<p>注意:它们不是协程任务 ，不能作为 loop.run_until_complete 的参数。 </p>
</blockquote>
<h4 id="loop-call-soon"><a href="#loop-call-soon" class="headerlink" title="loop.call_soon"></a>loop.call_soon</h4><p>事件循环的 call_soon 方法可以将普通函数作为任务加入到事件循环并立即排定任务的执行顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name</span>):</span>          <span class="comment"># 普通函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[hello] Hello, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">t, name</span>):</span>  <span class="comment"># 协程函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[work ] start&#x27;</span>, name)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(t)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[work ] &#123;&#125; after &#123;&#125;s stop&#x27;</span>.<span class="built_in">format</span>(name, t))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    loop = asyncio.get_event_loop() </span><br><span class="line">    <span class="comment"># 向事件循环中添加任务</span></span><br><span class="line">    asyncio.ensure_future(work(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>))     <span class="comment"># 第 1 个执行</span></span><br><span class="line">    <span class="comment"># call_soon 将普通函数当作 task 加入到事件循环并排定执行顺序</span></span><br><span class="line">    <span class="comment"># 该方法的第一个参数为普通函数名字，普通函数的参数写在后面</span></span><br><span class="line">    loop.call_soon(hello, <span class="string">&#x27;Tom&#x27;</span>)            <span class="comment"># 第 2 个执行</span></span><br><span class="line">    <span class="comment"># 向事件循环中添加任务</span></span><br><span class="line">    loop.create_task(work(<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>))          <span class="comment"># 第 3 个执行</span></span><br><span class="line">    <span class="comment"># 阻塞启动事件循环，顺便再添加一个任务  </span></span><br><span class="line">    loop.run_until_complete(work(<span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>))   <span class="comment"># 第 4 个执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># [work ] start A</span></span><br><span class="line"><span class="comment"># [hello] Hello, Tom</span></span><br><span class="line"><span class="comment"># [work ] start B</span></span><br><span class="line"><span class="comment"># [work ] start C</span></span><br><span class="line"><span class="comment"># [work ] A after 1s stop</span></span><br><span class="line"><span class="comment"># [work ] B after 2s stop</span></span><br><span class="line"><span class="comment"># [work ] C after 3s stop</span></span><br></pre></td></tr></table></figure>



<h4 id="loop-call-later"><a href="#loop-call-later" class="headerlink" title="loop.call_later"></a>loop.call_later</h4><p>此方法同 loop.call_soon 一样，可将普通函数作为任务放到事件循环里，不同之处在于此方法<strong>可延时执行，第一个参数为延时时间</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name</span>):</span>            <span class="comment"># 普通函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[hello]  Hello, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">t, name</span>):</span>    <span class="comment"># 协程函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[work&#123;&#125;]  start&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(t)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[work&#123;&#125;]  stop&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    asyncio.ensure_future(work(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>))         <span class="comment"># 任务 1</span></span><br><span class="line">    loop.call_later(<span class="number">1.2</span>, hello, <span class="string">&#x27;Tom&#x27;</span>)          <span class="comment"># 任务 2</span></span><br><span class="line">    loop.call_soon(hello, <span class="string">&#x27;Kitty&#x27;</span>)              <span class="comment"># 任务 3</span></span><br><span class="line">    task4 = loop.create_task(work(<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>))      <span class="comment"># 任务 4</span></span><br><span class="line">    loop.call_later(<span class="number">1</span>, hello, <span class="string">&#x27;Jerry&#x27;</span>)          <span class="comment"># 任务 5</span></span><br><span class="line">    loop.run_until_complete(task4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># [workA]  start</span></span><br><span class="line"><span class="comment"># [hello]  Hello, Kitty</span></span><br><span class="line"><span class="comment"># [workB]  start</span></span><br><span class="line"><span class="comment"># [hello]  Hello, Jerry</span></span><br><span class="line"><span class="comment"># [workA]  stop</span></span><br><span class="line"><span class="comment"># [hello]  Hello, Tom</span></span><br><span class="line"><span class="comment"># [workB]  stop</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>毫无疑问，这五个任务在一个事件循环里是顺序执行，遇到阻塞执行下一个，程序执行顺序如下：</p>
<ol>
<li><p>首先执行任务一，打印一行后阻塞 1 秒，执行任务二</p>
</li>
<li><p><strong>任务二是 call_later 1.2 秒，就相当于一个 1.2 秒的 asyncio.sleep</strong></p>
<p>==注意，call_later 这个延时 1.2 秒是事件循环启动时就开始计时的<br>(所以任务二阻塞，执行任务三)==</p>
</li>
<li><p>因为任务二阻塞，执行任务三，</p>
</li>
<li><p>接着执行任务四，打印一行后阻塞 2 秒</p>
</li>
<li><p>接着执行任务五，因为 call_later 1 秒，发生阻塞,第一轮结束.</p>
</li>
</ol>
<p>以上是五个任务第一轮的执行情况,<br>第二轮开始前,<strong>此时所有的任务(任务1,任务2,任务4.任务5)都在阻塞中,所以CPU 一直候着</strong></p>
<ol>
<li><p>第一个发出执行信号的是任务五，它只阻塞 1 秒<br>(上面已经说了，这个 1 秒是从事件循环启动时开始算,所以这个阻塞肯定比任务一的阻塞 1 秒先结束)</p>
</li>
<li><p>CPU 执行完任务五，任务一也阻塞结束了，执行任务一</p>
</li>
<li><p>然后是任务二，最后是任务四</p>
</li>
<li><p>第二轮打印了 4 行，全部任务完成，停止事件循环</p>
</li>
</ol>
<p>总结 :</p>
<ol>
<li>第一轮 : 任务1 - 任务3 - 任务4</li>
<li>第二轮 : 任务5 - 任务1 - 任务2 - 任务4</li>
</ol>
</blockquote>
<blockquote>
<p>我们可以总结事件循环的执行顺序:</p>
<ul>
<li>首先按顺序执行各个任务,一旦任务阻塞,就跳转到下一个任务,直到第一轮结束</li>
<li>接下来,看哪个任务准备好了,就执行哪个任务<br>(如果都准备好了就执行前面的任务)</li>
</ul>
</blockquote>
<h4 id="loop-call-at-amp-loop-time"><a href="#loop-call-at-amp-loop-time" class="headerlink" title="loop.call_at &amp; loop.time"></a>loop.call_at &amp; loop.time</h4><ul>
<li>call_soon 立刻执行</li>
<li>call_later 延时执行</li>
<li>call_at 在某时刻执行</li>
</ul>
<p>loop.time 就是事件循环内部的一个计时方法，返回值是时刻，数据类型是 float</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name</span>):</span>            <span class="comment"># 普通函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[hello]  Hello, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">t, name</span>):</span>    <span class="comment"># 协程函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[work&#123;&#125;]  start&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(t)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[work&#123;&#125;]  stop&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    start = loop.time()                         <span class="comment"># 事件循环内部时刻</span></span><br><span class="line">    asyncio.ensure_future(work(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>))         <span class="comment"># 任务 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># loop.call_later(1.2, hello, &#x27;Tom&#x27;)</span></span><br><span class="line">    <span class="comment"># 上面注释这行等同于下面这行</span></span><br><span class="line">    loop.call_at(start+<span class="number">1.2</span>, hello, <span class="string">&#x27;Tom&#x27;</span>)       <span class="comment"># 任务 2</span></span><br><span class="line"></span><br><span class="line">    loop.call_soon(hello, <span class="string">&#x27;Kitty&#x27;</span>)              <span class="comment"># 任务 3</span></span><br><span class="line">    </span><br><span class="line">    task4 = loop.create_task(work(<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>))      <span class="comment"># 任务 4</span></span><br><span class="line">    <span class="comment"># loop.call_later(1, hello, &#x27;Jerry&#x27;)</span></span><br><span class="line">    <span class="comment"># 上面注释这行等同于下面这行</span></span><br><span class="line">    loop.call_at(start+<span class="number">1</span>, hello, <span class="string">&#x27;Jerry&#x27;</span>)       <span class="comment"># 任务 5</span></span><br><span class="line"></span><br><span class="line">    loop.run_until_complete(task4)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"><span class="comment"># [workA]  start</span></span><br><span class="line"><span class="comment"># [hello]  Hello, Kitty</span></span><br><span class="line"><span class="comment"># [workB]  start</span></span><br><span class="line"><span class="comment"># [hello]  Hello, Jerry</span></span><br><span class="line"><span class="comment"># [workA]  stop</span></span><br><span class="line"><span class="comment"># [hello]  Hello, Tom</span></span><br><span class="line"><span class="comment"># [workB]  stop</span></span><br></pre></td></tr></table></figure>



<h3 id="8-协程的通讯方法"><a href="#8-协程的通讯方法" class="headerlink" title="8.协程的通讯方法"></a>8.协程的通讯方法</h3><h4 id="asyncio-lock"><a href="#asyncio-lock" class="headerlink" title="asyncio.lock"></a>asyncio.lock</h4><p>协程锁:<br>asyncio.lock 应该叫做异步 IO 锁，之所以叫协程锁，是因为它通常使用在子协程中，其作用是将协程内部的一段代码锁住，直到这段代码运行完毕解锁。</p>
<blockquote>
<p>协程锁的固定用法是<strong>使用 async with 创建协程锁的上下文环境</strong>，将代码块写入其中。 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line">lock = asyncio.Lock()   <span class="comment"># 协程锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">r&#x27;\\\\\\\\\\\\&#x27;</span>,name)     <span class="comment"># 打印此信息是为了测试协程锁的控制范围</span></span><br><span class="line">    <span class="comment"># 这里加个锁，第一次调用该协程，运行到这个语句块，上锁</span></span><br><span class="line">    <span class="comment"># 当语句块结束后解锁，开锁前该语句块不可被运行第二次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果上锁后有其它任务调用了这个协程函数，运行到这步会被阻塞，直至解锁</span></span><br><span class="line">    <span class="comment"># with 是普通上下文管理器关键字，async with 是异步上下文管理器关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 能够使用 with 关键字的对象须有 __enter__ 和 __exit__ 方法</span></span><br><span class="line">    <span class="comment"># 能够使用 async with 关键字的对象须有 __aenter__ 和 __aexit__ 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># async with 会自动运行 lock 的 __aenter__ 方法，该方法会调用 acquire 方法上锁</span></span><br><span class="line">    <span class="comment"># 在语句块结束时自动运行 __aexit__ 方法，该方法会调用 release 方法解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这和 with 一样，都是简化 try ... finally 语句</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; start&#x27;</span>.<span class="built_in">format</span>(name))  <span class="comment"># 头一次运行该协程时打印</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> l:                    <span class="comment"># 如果判断成功</span></span><br><span class="line">            <span class="keyword">return</span> name                 <span class="comment"># 直接返回结束协程，不再向下执行</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;++++++++++&#x27;</span>,name)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0</span>)          <span class="comment"># asyncio.sleep(0) 一样也会切换协程</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;----------&#x27;</span>,name)  </span><br><span class="line">        l.append(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; end&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">one</span>():</span></span><br><span class="line">	name = <span class="keyword">await</span> work(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; ok&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">two</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;///////////&#x27;</span>)</span><br><span class="line">	name = <span class="keyword">await</span> work(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; ok&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = asyncio.wait([one(), two()])</span><br><span class="line">    loop.run_until_complete(tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># \\\\\\\\\\\\ one</span></span><br><span class="line"><span class="comment"># one start</span></span><br><span class="line"><span class="comment"># ++++++++++ one</span></span><br><span class="line"><span class="comment"># ///////////</span></span><br><span class="line"><span class="comment"># \\\\\\\\\\\\ two</span></span><br><span class="line"><span class="comment"># ---------- one</span></span><br><span class="line"><span class="comment"># one end</span></span><br><span class="line"><span class="comment"># one ok</span></span><br><span class="line"><span class="comment"># two start</span></span><br><span class="line"><span class="comment"># two ok</span></span><br></pre></td></tr></table></figure>

<p>执行步骤解析:</p>
<ol>
<li>协程one当执行到<code>++++++++++ one</code>后执行<code>await asyncio.sleep(0)</code>,此时lock并没有解开,就切换协程two了</li>
<li>协程two开始执行,打印<code>///////////</code></li>
<li>协程two执行完<code>\\\\\\\\\\\\ two</code>,后执行<code>async with lock</code>,但是此时lock并没有解开.切换到协程one</li>
<li>协程one恢复执行<code>---------- one</code>.当执行完<code>return name</code>后lock解开.</li>
<li>协程one执行完<code>one ok</code>,协程one执行完毕,开始执行协程two</li>
<li>执行协程two</li>
</ol>
<p>示例二</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unlock</span>(<span class="params">lock</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;callback releasing lock&#x27;</span>)</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro1</span>(<span class="params">lock</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro1 wating for the lock&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">await</span> lock:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;coro1 acquired lock&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro1 released lock&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro2</span>(<span class="params">lock</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro2 wating for the lock&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> lock</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;coro2 acquired lock&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;coro2 released lock&#x27;</span>)</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">loop</span>):</span></span><br><span class="line">    lock = asyncio.Lock()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;acquiring the lock before starting coroutines&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> lock.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;lock acquired: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(lock.locked()))</span><br><span class="line"></span><br><span class="line">    loop.call_later(<span class="number">0.1</span>, functools.partial(unlock, lock))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting for coroutines&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait([coro1(lock), coro2(lock)])</span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    event_loop.run_until_complete(main(event_loop))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    event_loop.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># acquiring the lock before starting coroutines</span></span><br><span class="line"><span class="comment"># lock acquired: True</span></span><br><span class="line"><span class="comment"># waiting for coroutines</span></span><br><span class="line"><span class="comment"># coro1 wating for the lock</span></span><br><span class="line"><span class="comment"># coro2 wating for the lock</span></span><br><span class="line"><span class="comment"># callback releasing lock</span></span><br><span class="line"><span class="comment"># coro1 acquired lock</span></span><br><span class="line"><span class="comment"># coro1 released lock</span></span><br><span class="line"><span class="comment"># coro2 acquired lock</span></span><br><span class="line"><span class="comment"># coro2 released lock</span></span><br></pre></td></tr></table></figure>



<h4 id="asyncio-Event"><a href="#asyncio-Event" class="headerlink" title="asyncio.Event"></a>asyncio.Event</h4><p><code>asyncio.Event</code> 类似 <code>threading.Event</code> 用来<strong>允许多个消费者等待某个事情发生，不用通过监听一个特殊的值的来说实现类似通知</strong>的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_event</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;setting event in callback&#x27;</span>)</span><br><span class="line">    event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro1</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro1 waiting for event&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> event.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro1 triggered&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro2</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro2 waiting for event&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> event.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro2 triggered&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">loop</span>):</span></span><br><span class="line">    event = asyncio.Event()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;event start state: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(event.is_set()))</span><br><span class="line">    loop.call_later(</span><br><span class="line">        <span class="number">0.1</span>, functools.partial(set_event, event)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait([coro1(event), coro2(event)])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;event end state: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(event.is_set()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    event_loop.run_until_complete(main(event_loop))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    event_loop.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># event start state: False</span></span><br><span class="line"><span class="comment"># coro1 waiting for event</span></span><br><span class="line"><span class="comment"># coro2 waiting for event</span></span><br><span class="line"><span class="comment"># setting event in callback</span></span><br><span class="line"><span class="comment"># coro1 triggered</span></span><br><span class="line"><span class="comment"># coro2 triggered</span></span><br><span class="line"><span class="comment"># event end state: True</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>和 <code>Lock</code> 一样，<code>coro1()</code> 和 <code>coro2()</code> 都在等待 event 被设置。</p>
<p>不同的是它们都在 event 状态一发生变化的时候就启动了，它们不需要对 event 对象获取一个唯一的所有权。</p>
<p>简单来说 : <strong>event 能唤醒所有等待中的 coroutine</strong></p>
</blockquote>
<h4 id="asyncio-condition"><a href="#asyncio-condition" class="headerlink" title="asyncio.condition"></a>asyncio.condition</h4><p><code>Condition</code> 的效果类似 <code>Event</code>，不同的是它不是唤醒所有等待中的 coroutine, 而是通过 <code>notify()</code> 唤醒指定数量的待唤醒 coroutine。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">condition, n</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">await</span> condition:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;consumer &#123;&#125; is waiting&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">        <span class="keyword">await</span> condition.wait()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;consumer &#123;&#125; triggered&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ending consumer &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">manipulate_condition</span>(<span class="params">condition</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;starting manipulate_condition&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="keyword">await</span> condition:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;notifying &#123;&#125; consumers&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            condition.notify(n=i)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="keyword">await</span> condition:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;notifying remaining consumers&#x27;</span>)</span><br><span class="line">        condition.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ending manipulate_condition&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">loop</span>):</span></span><br><span class="line">    condition = asyncio.Condition()</span><br><span class="line"></span><br><span class="line">    consumers = [</span><br><span class="line">        consumer(condition, i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">    ]</span><br><span class="line">    loop.create_task(manipulate_condition(condition))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(consumers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = event_loop.run_until_complete(main(event_loop))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    event_loop.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># starting manipulate_condition</span></span><br><span class="line"><span class="comment"># consumer 0 is waiting</span></span><br><span class="line"><span class="comment"># consumer 4 is waiting</span></span><br><span class="line"><span class="comment"># consumer 1 is waiting</span></span><br><span class="line"><span class="comment"># consumer 2 is waiting</span></span><br><span class="line"><span class="comment"># consumer 3 is waiting</span></span><br><span class="line"><span class="comment"># notifying 1 consumers</span></span><br><span class="line"><span class="comment"># consumer 0 triggered</span></span><br><span class="line"><span class="comment"># ending consumer 0</span></span><br><span class="line"><span class="comment"># notifying 2 consumers</span></span><br><span class="line"><span class="comment"># consumer 4 triggered</span></span><br><span class="line"><span class="comment"># ending consumer 4</span></span><br><span class="line"><span class="comment"># consumer 1 triggered</span></span><br><span class="line"><span class="comment"># ending consumer 1</span></span><br><span class="line"><span class="comment"># notifying remaining consumers</span></span><br><span class="line"><span class="comment"># ending manipulate_condition</span></span><br><span class="line"><span class="comment"># consumer 2 triggered</span></span><br><span class="line"><span class="comment"># ending consumer 2</span></span><br><span class="line"><span class="comment"># consumer 3 triggered</span></span><br><span class="line"><span class="comment"># ending consumer 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动了五个 Condition 的消费者，每个都使用 <code>wait()</code> 方法来等待它们可以继续处理的通知。</li>
<li><code>manipulate_condition()</code> 首先通知了一个消费者，然后又通知了两个消费者，最后通知剩下的所有消费者。</li>
</ul>
<blockquote>
<p>在线程中使用condition需要注意:<br>必须<strong>每个线程先获取condition<code>cond.acquire()</code>,最后必须释放<code>cond.release()</code></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hider</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cond, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Hider, self).__init__()</span><br><span class="line">        self.cond = cond</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment">#确保先运行Seeker中的方法</span></span><br><span class="line">        self.cond.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 我已经把眼睛蒙上了&#x27;</span>)</span><br><span class="line">        self.cond.notify()</span><br><span class="line">        self.cond.wait()</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 我找到你了哦 ~_~&#x27;</span>)</span><br><span class="line">        self.cond.notify() </span><br><span class="line"></span><br><span class="line">        self.cond.release()</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 我赢了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seeker</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cond, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Seeker, self).__init__()</span><br><span class="line">        self.cond = cond</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.cond.acquire()</span><br><span class="line">        self.cond.wait()</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 我已经藏好了，你快来找我吧&#x27;</span>)</span><br><span class="line">        self.cond.notify()</span><br><span class="line">        self.cond.wait()</span><br><span class="line">        self.cond.release()</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;: 被你找到了，哎~~~&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cond = threading.Condition()</span><br><span class="line">seeker = Seeker(cond, <span class="string">&#x27;seeker&#x27;</span>)</span><br><span class="line">hider = Hider(cond, <span class="string">&#x27;hider&#x27;</span>)</span><br><span class="line">seeker.start()</span><br><span class="line">hider.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># hider: 我已经把眼睛蒙上了</span></span><br><span class="line"><span class="comment"># seeker: 我已经藏好了，你快来找我吧</span></span><br><span class="line"><span class="comment"># hider: 我找到你了哦 ~_~</span></span><br><span class="line"><span class="comment"># hider: 我赢了</span></span><br><span class="line"><span class="comment"># seeker: 被你找到了，哎~~~</span></span><br></pre></td></tr></table></figure>

<p>在协程里也一样,<strong>每个协程函数都必须先获取condition,最后释放</strong>.这里我们使用了with自动获取和释放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">await</span> condition:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;consumer &#123;&#125; is waiting&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">    <span class="keyword">await</span> condition.wait()</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>注意:<br>为了更明显设置了新特性:<br><code>with await</code>要改为<code>async with</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">await</span> condition:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;consumer &#123;&#125; is waiting&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> condition:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;consumer &#123;&#125; is waiting&#x27;</span>.<span class="built_in">format</span>(n))</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="asyncio-Queue"><a href="#asyncio-Queue" class="headerlink" title="asyncio.Queue"></a>asyncio.Queue</h4><p><code>asyncio.Queue</code> 为 coroutines 实现了一个先进先出的数据结构，类似多线程中的 <code>queue.Queue</code> ，多进程中的 <code>multiprocessing.Queue</code></p>
<blockquote>
<p><code>queue.Queue</code>的queue.task_done()的功能 :<br>每task_done一次 就从队列里删掉一个元素，这样在最后queue.join()的时候根据队列长度是否为零来判断队列是否结束</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">n, q</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;consumer &#123;&#125;: waiting for item&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;consumer &#123;&#125;: waiting for item&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">        item = <span class="keyword">await</span> q.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;consumer &#123;&#125;: has item &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n, item))</span><br><span class="line">        <span class="comment"># 在这个程序中 None 是个特殊的值，表示终止信号</span></span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            q.task_done()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0.01</span> * item)</span><br><span class="line">            q.task_done()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;consumer &#123;&#125;: ending&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">q, num_workers</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;producer: starting&#x27;</span>)</span><br><span class="line">    <span class="comment"># 向队列中添加一些数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_workers * <span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 因为Queue长度为2,所以,当第三次的时候,就会await了(前两次不会)</span></span><br><span class="line">        <span class="keyword">await</span> q.put(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;producer: added task &#123;&#125; to the queue&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过 None 这个特殊值来通知消费者退出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;producer: adding stop signals to the queue&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_workers):</span><br><span class="line">        <span class="keyword">await</span> q.put(<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;producer: waiting for queue to empty&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> q.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;producer: ending&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">loop, num_consumers</span>):</span></span><br><span class="line">    <span class="comment"># 创建指定大小的队列，这样的话生产者将会阻塞</span></span><br><span class="line">    <span class="comment"># 直到有消费者获取数据</span></span><br><span class="line">    q = asyncio.Queue(maxsize=num_consumers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调度消费者</span></span><br><span class="line">    consumers = [</span><br><span class="line">        loop.create_task(consumer(i, q))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_consumers)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调度生产者</span></span><br><span class="line">    prod = loop.create_task(producer(q, num_consumers))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有 coroutines 都完成</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(consumers + [prod])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    event_loop.run_until_complete(main(event_loop, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    event_loop.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># consumer 0: waiting for item</span></span><br><span class="line"><span class="comment"># consumer 0: waiting for item</span></span><br><span class="line"><span class="comment"># consumer 1: waiting for item</span></span><br><span class="line"><span class="comment"># consumer 1: waiting for item</span></span><br><span class="line"><span class="comment"># producer: starting</span></span><br><span class="line"><span class="comment"># producer: added task 0 to the queue</span></span><br><span class="line"><span class="comment"># producer: added task 1 to the queue</span></span><br><span class="line"><span class="comment"># consumer 0: has item 0</span></span><br><span class="line"><span class="comment"># consumer 1: has item 1</span></span><br><span class="line"><span class="comment"># producer: added task 2 to the queue</span></span><br><span class="line"><span class="comment"># producer: added task 3 to the queue</span></span><br><span class="line"><span class="comment"># consumer 0: waiting for item</span></span><br><span class="line"><span class="comment"># consumer 0: has item 2</span></span><br><span class="line"><span class="comment"># producer: added task 4 to the queue</span></span><br><span class="line"><span class="comment"># consumer 1: waiting for item</span></span><br><span class="line"><span class="comment"># consumer 1: has item 3</span></span><br><span class="line"><span class="comment"># producer: added task 5 to the queue</span></span><br><span class="line"><span class="comment"># producer: adding stop signals to the queue</span></span><br><span class="line"><span class="comment"># consumer 0: waiting for item</span></span><br><span class="line"><span class="comment"># consumer 0: has item 4</span></span><br><span class="line"><span class="comment"># consumer 1: waiting for item</span></span><br><span class="line"><span class="comment"># consumer 1: has item 5</span></span><br><span class="line"><span class="comment"># producer: waiting for queue to empty</span></span><br><span class="line"><span class="comment"># consumer 0: waiting for item</span></span><br><span class="line"><span class="comment"># consumer 0: has item None</span></span><br><span class="line"><span class="comment"># consumer 0: ending</span></span><br><span class="line"><span class="comment"># consumer 1: waiting for item</span></span><br><span class="line"><span class="comment"># consumer 1: has item None</span></span><br><span class="line"><span class="comment"># consumer 1: ending</span></span><br><span class="line"><span class="comment"># producer: ending </span></span><br></pre></td></tr></table></figure>



<h3 id="9-获取协程返回值的方法"><a href="#9-获取协程返回值的方法" class="headerlink" title="9.获取协程返回值的方法"></a>9.获取协程返回值的方法</h3><h4 id="一个协程中await了另外一个协程"><a href="#一个协程中await了另外一个协程" class="headerlink" title="一个协程中await了另外一个协程"></a>一个协程中await了另外一个协程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(coroutine1),</span><br><span class="line">    asyncio.ensure_future(coroutine2),</span><br><span class="line">    asyncio.ensure_future(coroutine3)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">dones, pendings = <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> dones:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task ret: &#x27;</span>, task.result())</span><br></pre></td></tr></table></figure>

<h4 id="asyncio-gather创建协程对象"><a href="#asyncio-gather创建协程对象" class="headerlink" title="asyncio.gather创建协程对象"></a>asyncio.gather创建协程对象</h4><blockquote>
<p>如果使用的是 asyncio.gather创建协程对象，那么await的返回值就是协程运行的结果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(coroutine1),</span><br><span class="line">    asyncio.ensure_future(coroutine2),</span><br><span class="line">    asyncio.ensure_future(coroutine3)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task ret: &#x27;</span>, result)</span><br></pre></td></tr></table></figure>

<h4 id="run-until-complete返回协程的结果"><a href="#run-until-complete返回协程的结果" class="headerlink" title="run_until_complete返回协程的结果"></a>run_until_complete返回协程的结果</h4><p>在函数里<code>return await asyncio.gather(*tasks)</code>后就可以使用<code>results = loop.run_until_complete(main())</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">    coroutine3 = do_some_work(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.ensure_future(coroutine1),</span><br><span class="line">        asyncio.ensure_future(coroutine2),</span><br><span class="line">        asyncio.ensure_future(coroutine3)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">results = loop.run_until_complete(main())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task ret: &#x27;</span>, result)</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>return await asyncio.wait(tasks)</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.ensure_future(coroutine1),</span><br><span class="line">        asyncio.ensure_future(coroutine2),</span><br><span class="line">        asyncio.ensure_future(coroutine3)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">start = now()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">done, pending = loop.run_until_complete(main())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> done:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task ret: &#x27;</span>, task.result())</span><br></pre></td></tr></table></figure>

<h4 id="asyncio的as-completed方法"><a href="#asyncio的as-completed方法" class="headerlink" title="asyncio的as_completed方法"></a>asyncio的as_completed方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</span><br><span class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</span><br><span class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.ensure_future(coroutine1),</span><br><span class="line">        asyncio.ensure_future(coroutine2),</span><br><span class="line">        asyncio.ensure_future(coroutine3)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">        result = <span class="keyword">await</span> task   <span class="comment"># 注意这里有一个await</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">done = loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p><code>as_completed</code>最常使用的形式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">    result = <span class="keyword">await</span> task</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<code>result = await task</code>中有一个await</p>
</blockquote>
<h3 id="10-asyncio的futrue对象"><a href="#10-asyncio的futrue对象" class="headerlink" title="10.asyncio的futrue对象"></a>10.asyncio的futrue对象</h3><blockquote>
<p><code>Future</code> 对象表示一个还未完成的工作，<strong>事件循环可以监视 <code>Future</code> 对象的状态直至它变成 done</strong>，这将运行程序的一部分等待另一部分完成一些工作。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mark_done</span>(<span class="params">future, result</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;setting future result to &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(result))</span><br><span class="line">    <span class="comment"># 为future对象设置值</span></span><br><span class="line">    future.set_result(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line">all_done = asyncio.Future()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;scheduling make_done&#x27;</span>)</span><br><span class="line">    event_loop.call_soon(mark_done, all_done, <span class="string">&#x27;the result&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;entering event loop&#x27;</span>)</span><br><span class="line">    <span class="comment"># await all_done这个future对象返回结果</span></span><br><span class="line">    result = event_loop.run_until_complete(all_done)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;returned result: &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(result))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;closing event loop&#x27;</span>)</span><br><span class="line">    event_loop.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;future result: &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(all_done.result()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># scheduling make_done</span></span><br><span class="line"><span class="comment"># entering event loop</span></span><br><span class="line"><span class="comment"># setting future result to &#x27;the result&#x27;</span></span><br><span class="line"><span class="comment"># returned result: &#x27;the result&#x27;</span></span><br><span class="line"><span class="comment"># closing event loop</span></span><br><span class="line"><span class="comment"># future result: &#x27;the result&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<br><code>event_loop.run_until_complete(all_done)</code>的意思是将all_done放入事件循环,然后开始时间循环的意思.(也就是说,这个<strong>事件循环可能存在已经注册了的task</strong>)<br>简单来说就是 : ==启动事件循环，顺便再添加一个任务==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    loop = asyncio.get_event_loop() </span><br><span class="line">    <span class="comment"># 向事件循环中添加任务</span></span><br><span class="line">    asyncio.ensure_future(work(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>))     <span class="comment"># 第 1 个执行</span></span><br><span class="line">    <span class="comment"># call_soon 将普通函数当作 task 加入到事件循环并排定执行顺序</span></span><br><span class="line">    <span class="comment"># 该方法的第一个参数为普通函数名字，普通函数的参数写在后面</span></span><br><span class="line">    loop.call_soon(hello, <span class="string">&#x27;Tom&#x27;</span>)            <span class="comment"># 第 2 个执行</span></span><br><span class="line">    <span class="comment"># 向事件循环中添加任务</span></span><br><span class="line">    loop.create_task(work(<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>))          <span class="comment"># 第 3 个执行</span></span><br><span class="line">    <span class="comment"># 阻塞启动事件循环，顺便再添加一个任务  </span></span><br><span class="line">    loop.run_until_complete(work(<span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>))   <span class="comment"># 第 4 个执行</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>当调用 <code>set_result</code> 方法后，<code>Future</code> 对象的状态会被修改为 done, 同时 <code>Future</code> 实例也会保存设置的结果值，供随后使用</p>
</blockquote>
<h3 id="11-使用抽象类-Protocol-实现异步-I-O"><a href="#11-使用抽象类-Protocol-实现异步-I-O" class="headerlink" title="11.使用抽象类 Protocol 实现异步 I/O"></a>11.使用抽象类 Protocol 实现异步 I/O</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul>
<li><p>EchoServer继承 <code>asyncio.Protocol</code> ，用来处理与客户端的通信。</p>
<blockquote>
<p><code>protocol</code> 的方法是基于服务端 socket 事件来触发的。</p>
</blockquote>
</li>
<li><p>每当有一个新的客户端连接的时候，就会触发调用 <code>connection_made()</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connection_made</span>(<span class="params">self, transport</span>):</span></span><br><span class="line">    self.transport = transport</span><br><span class="line">    self.address = transport.get_extra_info(<span class="string">&#x27;peername&#x27;</span>)</span><br><span class="line">    self.log = logging.getLogger(</span><br><span class="line">        <span class="string">&#x27;EchoServer_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*self.address)</span><br><span class="line">    )</span><br><span class="line">    self.log.debug(<span class="string">&#x27;connection accepted&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p><code>transport</code> 参数是一个 <code>asyncio.Transport</code> 实例对象，这个对象抽象了一系列使用 socket 进行异步 I/O 操作的方法。</p>
</li>
<li><p>不同的通信协议提供了不同的 transport 实现，但是它们都有同样的 API.</p>
<p>(比如，有一些 transport 类用来与 socket 通信，有些用来跟子进程通过管道通信)</p>
</li>
<li><p>可以通过 <code>get_extra_info()</code> 获取进来的客户端的地址信息。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>连接建立以后，当有数据从客户端发到服务端的时候会使用传输过来的数据调用 <code>data_received()</code> 方法。<br>这里我们记录一下收到的数据，然后立即发收到的数据通过 <code>transport.write()</code> 发回客户端。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_received</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.log.debug(<span class="string">&#x27;received &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">        self.transport.write(data)</span><br><span class="line">        self.log.debug(<span class="string">&#x27;sent &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(data))</span><br></pre></td></tr></table></figure></li>
<li><p>一些 transport 支持一个特殊的 end-of-file 标识符(<code>EOF</code>)。当遇到一个 <code>EOF</code> 的时候，<code>eof_received()</code> 方法会被调用。<br>在本次实现中，<code>EOF</code> 会被发送会客户端，表示这个信号已经被收到。因为不是所有的 transport 都支持这个 <code>EOF</code> ，这个协议会首先询问 transport 是否可以安全的发送 <code>EOF</code> .</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eof_received</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.log.debug(<span class="string">&#x27;received EOF&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> self.transport.can_write_eof():</span><br><span class="line">        self.transport.write_eof()</span><br></pre></td></tr></table></figure></li>
<li><p>当一个连接被关闭的时候，无论是正常关闭还是因为一个错误导致的关闭，协议的 <code>connection_lost()</code> 方法都会被调用，如果是因为出错，参数中会包含一个相关的异常对象，否则这个对象就是 <code>None</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connection_lost</span>(<span class="params">self, error</span>):</span></span><br><span class="line">    <span class="keyword">if</span> error:</span><br><span class="line">        self.log.error(<span class="string">&#x27;ERROR: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(error))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.log.debug(<span class="string">&#x27;closing&#x27;</span>)</span><br><span class="line">    <span class="built_in">super</span>().connection_lost(error)</span><br></pre></td></tr></table></figure></li>
<li><p>需要两步来启动这个服务器。</p>
<ol>
<li><p>首先，应用告诉事件循环创建使用 protocol 类和 hostname 以及 socket 监听的端口信息来创建一个新的 server 对象。 </p>
<blockquote>
<p><code>create_server()</code> 方法是一个 coroutine, 所以它的结果必须通过事件循环来处理这样才能真正的启动服务器。</p>
<p>这个 coroutine 完成的时候会返回一个 与事件循环相关联的 <code>asyncio.Server</code> 实例.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factory = event_loop.create_server(EchoServer, *SERVER_ADDRESS)</span><br><span class="line">server = event_loop.run_until_complete(factory)</span><br><span class="line">log.debug(<span class="string">&#x27;starting up on &#123;&#125; port &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*SERVER_ADDRESS))</span><br></pre></td></tr></table></figure></li>
<li><p>然后这个事件循环需要被运行，以便接收客户端请求以及处理相关事件。</p>
<p>对于一个长时间运行的服务器程序来说， <code>run_forever()</code> 方法是最简便的实现这个功能的方法。</p>
<p>当事件循环被停止的时候，无论是通过应用程序代码还是通过进程信号停止的，server 都可以被关闭以便能够正确的清理 socket 资源</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    event_loop.run_forever()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    log.debug(<span class="string">&#x27;closing server&#x27;</span>)</span><br><span class="line">    server.close()</span><br><span class="line">    event_loop.run_until_complete(server.wait_closed())</span><br><span class="line">    log.debug(<span class="string">&#x27;closing event loop&#x27;</span>)</span><br><span class="line">    event_loop.close()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul>
<li><p>使用 protocol 类实现一个客户端的代码跟实现一个服务器端非常的相似.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">MESSAGES = [</span><br><span class="line">    <span class="string">b&#x27;This is the message. &#x27;</span>,</span><br><span class="line">    <span class="string">b&#x27;It will be sent &#x27;</span>,</span><br><span class="line">    <span class="string">b&#x27;in parts.&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">SERVER_ADDRESS = (<span class="string">&#x27;localhost&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(name)s: %(message)s&#x27;</span>,</span><br><span class="line">    stream=sys.stderr,</span><br><span class="line">)</span><br><span class="line">log = logging.getLogger(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br></pre></td></tr></table></figure></li>
<li><p>客户端 protocol 类定义了跟服务器端相同的方法，但是是不同的实现。</p>
<p><code>future</code> 参数是一个 <code>Future</code> 实例，用来作为<strong>客户端已经完成了一次接收来自服务端数据操作</strong>的信号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span>(<span class="params">asyncio.Protocol</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, messages, future</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.messages = messages</span><br><span class="line">        self.log = logging.getLogger(<span class="string">&#x27;EchoClient&#x27;</span>)</span><br><span class="line">        self.f = future</span><br></pre></td></tr></table></figure></li>
<li><p>当客户端成功连接到服务器时，会立即开始通信。客户端一次发送了一堆数据，因为网络等原因可能会把多个消息合并到一个消息中。当所有消息都送达的时候，将发送一个 <code>EOF</code>。</p>
<p>虽然看起你所有的数据都立即被发送了，事实上 transport 对象会缓冲发出去的数据并且会设置一个回调来传输最终的数据，当 socket 的缓冲区准备好可以发送的时候会调用这个回调。这些都是由 transport 来实现的，所以应用代码可以按照 I/O 操作就像看起来那么发生的样子来实现.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connection_made</span>(<span class="params">self, transport</span>):</span></span><br><span class="line">    self.transport = transport</span><br><span class="line">    self.address = transport.get_extra_info(<span class="string">&#x27;peername&#x27;</span>)</span><br><span class="line">    self.log.debug(</span><br><span class="line">        <span class="string">&#x27;connectiong to &#123;&#125; port &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*self.address)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 也可以使用 transport.writelines()</span></span><br><span class="line">    <span class="comment"># 这里使用 transport.write() 是为了方便</span></span><br><span class="line">    <span class="comment"># 记录发送的每一行内容</span></span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> self.messages:</span><br><span class="line">        transport.write(msg)</span><br><span class="line">        self.log.debug(<span class="string">&#x27;sending &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(msg))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> transport.can_write_eof():</span><br><span class="line">        transport.write_eof()</span><br></pre></td></tr></table></figure></li>
<li><p>当接收到来着服务器端的响应时，将会把这个响应记录下来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_received</span>(<span class="params">self, data</span>):</span></span><br><span class="line">    self.log.debug(<span class="string">&#x27;received &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(data))</span><br></pre></td></tr></table></figure></li>
<li><p>无论是收到 end-of-file 标记还是服务器端断开了连接，本地 transport 对象都将关闭并且 future 对象都会被通过设置一个结果值的方式标记为已完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eof_received</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.log.debug(<span class="string">&#x27;received EOF&#x27;</span>)</span><br><span class="line">    self.transport.close()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.f.done():</span><br><span class="line">        self.f.set_result(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connnection_lost</span>(<span class="params">self, exc</span>):</span></span><br><span class="line">    self.log.debug(<span class="string">&#x27;server closed connection&#x27;</span>)</span><br><span class="line">    self.transport.close()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.f.done():</span><br><span class="line">        self.f.set_result(<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">super</span>().connectiong_lost(exc)</span><br></pre></td></tr></table></figure></li>
<li><p>然后创建所需的 future, 以及客户端 coroutine</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">client_completed = asyncio.Future()</span><br><span class="line">client_factory = functools.partial(</span><br><span class="line">    EchoClient,</span><br><span class="line">    messages=MESSAGES,</span><br><span class="line">    future=client_completed</span><br><span class="line">)</span><br><span class="line">factory_coroutine = event_loop.create_connection(</span><br><span class="line">    client_factory,</span><br><span class="line">    *SERVER_ADDRESS,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>然后使用两次 wait 来处理客户端发送完成并退出的操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">og.debug(<span class="string">&#x27;waiting for client to complete&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    event_loop.run_until_complete(factory_coroutine)</span><br><span class="line">    event_loop.run_until_complete(client_completed)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    log.debug(<span class="string">&#x27;closing event loop&#x27;</span>)</span><br><span class="line">    event_loop.close()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># asyncio_echo_server_protocol.py</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SERVER_ADDRESS = (<span class="string">&#x27;localhost&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(name)s: %(message)s&#x27;</span>,</span><br><span class="line">    stream=sys.stderr,</span><br><span class="line">)</span><br><span class="line">log = logging.getLogger(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># EchoServer用来处理与客户端的通信。</span></span><br><span class="line"><span class="comment"># protocol 的方法是基于服务端 socket 事件来触发的。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span>(<span class="params">asyncio.Protocol</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connection_made</span>(<span class="params">self, transport</span>):</span></span><br><span class="line">        self.transport = transport</span><br><span class="line">        self.address = transport.get_extra_info(<span class="string">&#x27;peername&#x27;</span>)</span><br><span class="line">        self.log = logging.getLogger(</span><br><span class="line">            <span class="string">&#x27;EchoServer_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*self.address)</span><br><span class="line">        )</span><br><span class="line">        self.log.debug(<span class="string">&#x27;connection accepted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_received</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.log.debug(<span class="string">&#x27;received &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">        self.transport.write(data)</span><br><span class="line">        self.log.debug(<span class="string">&#x27;sent &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(data))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eof_received</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.log.debug(<span class="string">&#x27;received EOF&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.transport.can_write_eof():</span><br><span class="line">            self.transport.write_eof()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connection_lost</span>(<span class="params">self, error</span>):</span></span><br><span class="line">        <span class="keyword">if</span> error:</span><br><span class="line">            self.log.error(<span class="string">&#x27;ERROR: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(error))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.log.debug(<span class="string">&#x27;closing&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>().connection_lost(error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">factory = event_loop.create_server(EchoServer, *SERVER_ADDRESS)</span><br><span class="line">server = event_loop.run_until_complete(factory)</span><br><span class="line">log.debug(<span class="string">&#x27;starting up on &#123;&#125; port &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*SERVER_ADDRESS))</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    event_loop.run_forever()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    log.debug(<span class="string">&#x27;closing server&#x27;</span>)</span><br><span class="line">    server.close()</span><br><span class="line">    event_loop.run_until_complete(server.wait_closed())</span><br><span class="line">    log.debug(<span class="string">&#x27;closing event loop&#x27;</span>)</span><br><span class="line">    event_loop.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># asyncio_echo_client_protocol.py</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">MESSAGES = [</span><br><span class="line">    <span class="string">b&#x27;This is the message. &#x27;</span>,</span><br><span class="line">    <span class="string">b&#x27;It will be sent &#x27;</span>,</span><br><span class="line">    <span class="string">b&#x27;in parts.&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">SERVER_ADDRESS = (<span class="string">&#x27;localhost&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(name)s: %(message)s&#x27;</span>,</span><br><span class="line">    stream=sys.stderr,</span><br><span class="line">)</span><br><span class="line">log = logging.getLogger(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span>(<span class="params">asyncio.Protocol</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, messages, future</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.messages = messages</span><br><span class="line">        self.log = logging.getLogger(<span class="string">&#x27;EchoClient&#x27;</span>)</span><br><span class="line">        self.f = future</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connection_made</span>(<span class="params">self, transport</span>):</span></span><br><span class="line">        self.transport = transport</span><br><span class="line">        self.address = transport.get_extra_info(<span class="string">&#x27;peername&#x27;</span>)</span><br><span class="line">        self.log.debug(</span><br><span class="line">            <span class="string">&#x27;connectiong to &#123;&#125; port &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*self.address)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 也可以使用 transport.writelines()</span></span><br><span class="line">        <span class="comment"># 这里使用 transport.write() 是为了方便</span></span><br><span class="line">        <span class="comment"># 记录发送的每一行内容</span></span><br><span class="line">        <span class="keyword">for</span> msg <span class="keyword">in</span> self.messages:</span><br><span class="line">            transport.write(msg)</span><br><span class="line">            self.log.debug(<span class="string">&#x27;sending &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(msg))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> transport.can_write_eof():</span><br><span class="line">            transport.write_eof()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">data_received</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.log.debug(<span class="string">&#x27;received &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(data))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eof_received</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.log.debug(<span class="string">&#x27;received EOF&#x27;</span>)</span><br><span class="line">        self.transport.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.f.done():</span><br><span class="line">            self.f.set_result(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connnection_lost</span>(<span class="params">self, exc</span>):</span></span><br><span class="line">        self.log.debug(<span class="string">&#x27;server closed connection&#x27;</span>)</span><br><span class="line">        self.transport.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.f.done():</span><br><span class="line">            self.f.set_result(<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">super</span>().connectiong_lost(exc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client_completed = asyncio.Future()</span><br><span class="line">client_factory = functools.partial(</span><br><span class="line">    EchoClient,</span><br><span class="line">    messages=MESSAGES,</span><br><span class="line">    future=client_completed</span><br><span class="line">)</span><br><span class="line">factory_coroutine = event_loop.create_connection(</span><br><span class="line">    client_factory,</span><br><span class="line">    *SERVER_ADDRESS,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&#x27;waiting for client to complete&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    event_loop.run_until_complete(factory_coroutine)</span><br><span class="line">    event_loop.run_until_complete(client_completed)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    log.debug(<span class="string">&#x27;closing event loop&#x27;</span>)</span><br><span class="line">    event_loop.close()</span><br></pre></td></tr></table></figure>











</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>