<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;注意空间换时间&quot;&gt;&lt;a href=&quot;#注意空间换时间&quot; class=&quot;headerlink&quot; title=&quot;注意空间换时间&quot;&gt;&lt;/a&gt;注意空间换时间&lt;/h3&gt;&lt;p&gt;当复杂度太高的时候,总是应该考虑&lt;strong&gt;以空间换时间&lt;/strong&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>经验 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></div><div class="post-time">2019-08-09</div></div></div><div class="container post-header"><h1>经验</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="toc-number">1.</span> <span class="toc-text">注意空间换时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%A4%9A%E4%B8%AA%E5%BA%8F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">比较多个序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%8E%B7%E5%8F%96idx%E5%90%8E%E6%88%AA%E5%8F%96-%E5%92%8C-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">先获取idx后截取 和 滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%BD%8D%E7%9A%84%E7%9B%B8%E5%8A%A0%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">进位的相加问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">链表的常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">6.</span> <span class="toc-text">使用动态规划的思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E9%81%8D%E5%8E%86%E4%B8%A4%E6%A3%B5%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">同时遍历两棵树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%8C%89%E5%B1%82%E6%AC%A1%E7%B4%A2%E5%BC%95"><span class="toc-number">8.</span> <span class="toc-text">树的按层次索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E9%80%92%E5%BD%92%E7%9A%84%E5%9F%BA%E7%BA%BF%E6%9D%A1%E4%BB%B6%E8%A6%81%E4%BB%8E%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E8%80%83%E8%99%91"><span class="toc-number">9.</span> <span class="toc-text">寻找递归的基线条件要从传入的参数考虑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%BF%AD%E4%BB%A3%E5%A4%9A%E4%B8%AA%E5%BA%8F%E5%88%97%E8%A6%81%E4%BD%BF%E7%94%A8zip"><span class="toc-number">10.</span> <span class="toc-text">同时迭代多个序列要使用zip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">摩尔投票算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E9%9C%80%E8%A6%81%E7%BB%B4%E6%8A%A4%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">12.</span> <span class="toc-text">反转链表需要维护三个变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">13.</span> <span class="toc-text">二叉树的搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E6%8C%89%E5%BA%8F%E7%A7%BB%E5%8A%A8"><span class="toc-number">14.</span> <span class="toc-text">列表的按序移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8"><span class="toc-number">15.</span> <span class="toc-text">反转列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">16.</span> <span class="toc-text">使用字典计数的最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%89%BE%E5%94%AF%E4%B8%80%E5%85%83%E7%B4%A0%E6%97%B6%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%BC%82%E6%88%96"><span class="toc-number">17.</span> <span class="toc-text">要找唯一元素时应该考虑异或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%B7%A6%E5%AD%90%E6%A0%91"><span class="toc-number">18.</span> <span class="toc-text">判断左子树</span></a></li></ol></details></div><div class="container post-content"><h3 id="注意空间换时间"><a href="#注意空间换时间" class="headerlink" title="注意空间换时间"></a>注意空间换时间</h3><p>当复杂度太高的时候,总是应该考虑<strong>以空间换时间</strong></p>
<h3 id="比较多个序列"><a href="#比较多个序列" class="headerlink" title="比较多个序列"></a>比较多个序列</h3><p>如果比较数组for循环的两个each,可以考虑是不是只需比较最长和最短的两个.<br>如果是在不行,可以取出数组的第一个值,然后使用for循环.</p>
<h3 id="先获取idx后截取-和-滑动窗口"><a href="#先获取idx后截取-和-滑动窗口" class="headerlink" title="先获取idx后截取 和 滑动窗口"></a>先获取idx后截取 和 滑动窗口</h3><p>模仿find函数可以使用类似于滑动窗口的设计</p>
<blockquote>
<p>也就是说,对于序列,我们不一定要当场截取,可以获取需要的idx,最后再来截取:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个仅包含大小写字母和空格 &#x27; &#x27; 的字符串，返回其最后一个单词的长度。</span></span><br><span class="line"><span class="comment"># 如果不存在最后一个单词，请返回 0 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        tail = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> tail &gt;= <span class="number">0</span> <span class="keyword">and</span> s[tail] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            tail -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        head = tail</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head &gt;= <span class="number">0</span> <span class="keyword">and</span> s[head] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            head -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tail - head</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="进位的相加问题"><a href="#进位的相加问题" class="headerlink" title="进位的相加问题"></a>进位的相加问题</h3><p>相加问题都要想到设置进位变量up,并且在最后出了循环后还要检查up</p>
<blockquote>
<p>正常操作是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits</span>):</span></span><br><span class="line">        up = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            up,digits[idx] = <span class="built_in">divmod</span>(digits[idx] + up,<span class="number">10</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> up != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> up == <span class="number">1</span>:</span><br><span class="line">            digits.insert(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>quo,remain = divmod((string1[idx] + string2[idx] + up) ,进制)</code>一样可以用于进制转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up,num = <span class="built_in">divmod</span>(<span class="built_in">int</span>(a[idx]) + <span class="built_in">int</span>(b[idx]) + up,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h3 id="链表的常用操作"><a href="#链表的常用操作" class="headerlink" title="链表的常用操作"></a>链表的常用操作</h3><p>新建链表的时候都要设置dummyHead,然后最后return dummyHead.next</p>
<blockquote>
<p>链表遍历最常使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(pre <span class="keyword">and</span> pre.<span class="built_in">next</span>)</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        pre = head</span><br><span class="line">        <span class="comment"># 使用while pre</span></span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            <span class="comment"># 使用pre.next</span></span><br><span class="line">            <span class="keyword">if</span> pre.<span class="built_in">next</span> <span class="keyword">and</span> pre.<span class="built_in">next</span>.val == val:</span><br><span class="line">                pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 处理头节点</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">and</span> head.val == val:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="number">7</span>  <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="使用动态规划的思路"><a href="#使用动态规划的思路" class="headerlink" title="使用动态规划的思路"></a>使用动态规划的思路</h3><p>使用动态规划要确保每走一步都要调整状态转移方程.<br><strong>前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"># 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        min_p = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 求出前i天最低价</span></span><br><span class="line">            min_p = <span class="built_in">min</span>(min_p, prices[i])：</span><br><span class="line">            <span class="comment"># 前i天的最高收益</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - min_p)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.maxProfit([<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]))  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p>做动态规划题,总是要想到前一位的情况证明解,或者左边的情况怎么解</p>
<blockquote>
<p>动态规划的设计思路:</p>
<ol>
<li>首先，把我们面对的<strong>局面</strong>表示为x。这一步称为<strong>设计状态</strong>。</li>
<li>对于状态x，记我们要求出的答案(e.g. 最小费用)为f(x).我们的目标是求出f(T).<br><strong>找出f(x)与哪些局面有关（记为p）</strong>，</li>
<li>写出一个式子（称为<strong>状态转移方程</strong>），通过f(p)来推出f(x).</li>
</ol>
</blockquote>
<p>动态规划:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 阶段性求和</span></span><br><span class="line">        tot = <span class="number">0</span></span><br><span class="line">        result = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            tot += num</span><br><span class="line">            result = <span class="built_in">max</span>(result,tot)</span><br><span class="line">            tot = <span class="built_in">max</span>(tot,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用形式就是:</p>
<ul>
<li>tot阶段性状态</li>
<li>result最终状态</li>
<li>我们就是在一系列阶段性状态中选出最终状态</li>
</ul>
</blockquote>
<h3 id="同时遍历两棵树"><a href="#同时遍历两棵树" class="headerlink" title="同时遍历两棵树"></a>同时遍历两棵树</h3><p>同时遍历两颗树,那么这个函数就要接受两个参数,两个参数分别传入两个左子树和两个右子树</p>
<blockquote>
<p>判断两棵树相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">       <span class="comment"># 如果不存在p,q(基线条件1)</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">       <span class="comment"># 如果pq都存在(递归条件)</span></span><br><span class="line">       <span class="keyword">elif</span> p <span class="keyword">and</span> q :</span><br><span class="line">           <span class="comment"># 如果子树的根节点相同,就判断左右子树是否相同</span></span><br><span class="line">           <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">               <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">       <span class="comment"># pq其中一者存在(基线条件2)</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="树的按层次索引"><a href="#树的按层次索引" class="headerlink" title="树的按层次索引"></a>树的按层次索引</h3><p>树的按层次索引类似于广度优先遍历 : 不需要使用递归</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要思路:将每层的节点倒序填充进res,然后将下一次要迭代的节点放入stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span>   </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用stack存放每层节点</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="comment"># 将来会倒序填充res</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 使用tmp存放每层节点的左右子节点</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="comment"># res_each用于存放每一层的元素</span></span><br><span class="line">            res_each = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="comment"># 将节点的值放入res_each中</span></span><br><span class="line">                res_each.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    tmp.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    tmp.append(i.right)</span><br><span class="line">            <span class="comment"># 将下次要迭代的节点放入stack</span></span><br><span class="line">            stack = tmp</span><br><span class="line">            <span class="comment"># 每次都在res头部添加</span></span><br><span class="line">            res.insert(<span class="number">0</span>,res_each)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="寻找递归的基线条件要从传入的参数考虑"><a href="#寻找递归的基线条件要从传入的参数考虑" class="headerlink" title="寻找递归的基线条件要从传入的参数考虑"></a>寻找递归的基线条件要从传入的参数考虑</h3><p>寻找递归的基线条件要从传入的参数考虑</p>
<h3 id="同时迭代多个序列要使用zip"><a href="#同时迭代多个序列要使用zip" class="headerlink" title="同时迭代多个序列要使用zip"></a>同时迭代多个序列要使用zip</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span>(<span class="params">self, rowIndex</span>):</span></span><br><span class="line">        <span class="keyword">if</span> rowIndex == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        temp = [<span class="number">1</span>]</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> count != rowIndex:</span><br><span class="line">            temp = [<span class="number">1</span>] + [a+b <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">zip</span>(temp[<span class="number">1</span>:],temp[:-<span class="number">1</span>])] + [<span class="number">1</span>]</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.generate(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>



<h3 id="摩尔投票算法"><a href="#摩尔投票算法" class="headerlink" title="摩尔投票算法"></a>摩尔投票算法</h3><blockquote>
<p>该算法用于解决寻找一个含有$n$个元素的数列${an}$中出现<strong>超过$\frac{1}{K}$</strong>(即大于$\frac{n}{K}$次)的元素（假设满足要求的元素存在）。满足要求的元素最多有$(k−1)$个。</p>
<p>摩尔投票算法可以快速的计算出一个数组中出现次数过半的数即<strong>大多数（majority）</strong>，算法核心思想是<code>同加，异减</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的众数是指在数组中出现次数大于n/2的元素。</span></span><br><span class="line"><span class="comment"># 从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，</span></span><br><span class="line"><span class="comment"># 减到0就重新换个数开始计数，总能找到最多的那个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        count = result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># count等于零就换人</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                result = num</span><br><span class="line">	<span class="comment"># 与result不相等就count-1,相等就count+1</span></span><br><span class="line">            <span class="keyword">if</span> result != num:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.majorityElement([<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]))        </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="反转链表需要维护三个变量"><a href="#反转链表需要维护三个变量" class="headerlink" title="反转链表需要维护三个变量"></a>反转链表需要维护三个变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        p = head</span><br><span class="line">        s = head.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> s:    </span><br><span class="line">            head = s</span><br><span class="line">            s = s.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = p</span><br><span class="line">            p = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的搜索"><a href="#二叉树的搜索" class="headerlink" title="二叉树的搜索"></a>二叉树的搜索</h3><ol>
<li>递归条件是<strong>从根节点开始,大了往左走,小了往右走</strong></li>
<li>注意 : 因为是从根节点开始走的,所以第一个节点一定就是父节点</li>
</ol>
<h3 id="列表的按序移动"><a href="#列表的按序移动" class="headerlink" title="列表的按序移动"></a>列表的按序移动</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过遍历nums数组，<strong>将不为0的元素依次复制到nums的前面，并且记录我们复制了多少个元素</strong>，对len(nums)-k的元素置0即可。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        search_idx = <span class="number">0</span></span><br><span class="line">        insert_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> search_idx &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[search_idx] != <span class="number">0</span>:</span><br><span class="line">                nums[insert_idx] = nums[search_idx] </span><br><span class="line">                insert_idx += <span class="number">1</span></span><br><span class="line">            search_idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(insert_idx,<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.moveZeroes([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]))</span><br></pre></td></tr></table></figure>



<h3 id="反转列表"><a href="#反转列表" class="headerlink" title="反转列表"></a>反转列表</h3><p>使用双指针:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left],s[right] = s[right],s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>



<h3 id="使用字典计数的最佳实践"><a href="#使用字典计数的最佳实践" class="headerlink" title="使用字典计数的最佳实践"></a>使用字典计数的最佳实践</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> alist:</span><br><span class="line">    adict[each] = adict.get(each,<span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h3 id="要找唯一元素时应该考虑异或"><a href="#要找唯一元素时应该考虑异或" class="headerlink" title="要找唯一元素时应该考虑异或"></a>要找唯一元素时应该考虑异或</h3><p>字符串 <strong>t</strong> 由字符串 <strong>s</strong> 随机重排，然后在随机位置添加一个字母。请找出在 <em><strong>t</strong></em> 中被添加的字母。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheDifference</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s + t:</span><br><span class="line">            ret ^= <span class="built_in">ord</span>(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chr</span>(ret)</span><br></pre></td></tr></table></figure>



<h3 id="判断左子树"><a href="#判断左子树" class="headerlink" title="判断左子树"></a>判断左子树</h3><p>root.left存在,root.left不存在左右节点,说明root.left就是左叶子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left) <span class="keyword">and</span> (<span class="keyword">not</span> root.left.left) <span class="keyword">and</span> (<span class="keyword">not</span> root.left.right):</span><br></pre></td></tr></table></figure>





































<blockquote>
<p>122</p>
</blockquote>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>