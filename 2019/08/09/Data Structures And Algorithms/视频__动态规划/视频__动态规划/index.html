<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av16544031&quot;&gt;第一讲&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>动态规划 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Data-Structures-And-Algorithms/" rel="tag">Data Structures And Algorithms</a></div><div class="post-time">2019-08-09</div></div></div><div class="container post-header"><h1>动态规划</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80"><span class="toc-number">1.</span> <span class="toc-text">地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.</span> <span class="toc-text">什么时候使用动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E9%80%89%E5%92%8C%E4%B8%8D%E9%80%89"><span class="toc-number">3.</span> <span class="toc-text">解决方法 : 选和不选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%B3%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%92%8C%E8%87%B3%E4%B8%8B%E8%80%8C%E4%B8%8A"><span class="toc-number">4.</span> <span class="toc-text">至上而下和至下而上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83"><span class="toc-number">5.</span> <span class="toc-text">训练</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">最大值问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#subset%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">subset问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">5.3.</span> <span class="toc-text">最大子序列和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">5.4.</span> <span class="toc-text">买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">5.5.</span> <span class="toc-text">使用最小花费爬楼梯</span></a></li></ol></li></ol></details></div><div class="container post-content"><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av16544031">第一讲</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av18512769/">第二讲</a></p>
<h3 id="什么时候使用动态规划"><a href="#什么时候使用动态规划" class="headerlink" title="什么时候使用动态规划"></a>什么时候使用动态规划</h3><ol>
<li>存在递归关系</li>
<li>存在重叠子问题</li>
</ol>
<h3 id="解决方法-选和不选"><a href="#解决方法-选和不选" class="headerlink" title="解决方法 : 选和不选"></a>解决方法 : 选和不选</h3><p>动态规划有一个非常经典的解法 : <code>选,或者不选</code></p>
<blockquote>
<p>就是说,考虑<strong>最后一个状态可不可以拆分成选和不选的两个子问题</strong>.</p>
</blockquote>
<p>一个工人一天工作11小时,现在有8个任务可以选,每个任务赚5,1,8,4,6….,求今天最多赚多少钱</p>
<p><img src="/images/1564836987936.png" alt="1564836987936"></p>
<ol>
<li><p>设函数OPT(i),其中i为一共有几个任务,OPT(i)表示最多赚多少钱<br>(也就是说OPT(8)表示,<strong>如果有8个任务可以选,那么他的最好结果就是OPT(8)</strong>)</p>
</li>
<li><p>也就是求OPT(8)的值.也就是说当有8个任务可以选的时候该如何选?</p>
<p>我们可以将问题分成两个子问题:</p>
<ul>
<li><p>当我们做第8个任务时最多赚多少钱?</p>
<blockquote>
<p>当我们做第8个任务时,第6和7个任务做不了,第8任务赚4块.<br>所以值为4 + OPT(5)<br>(4块钱+前面五个任务的最大值)</p>
</blockquote>
</li>
<li><p>当我们不做第8个任务时最多赚多少钱?</p>
<blockquote>
<p>不做第8个任务,那就是OPT(7)</p>
</blockquote>
</li>
</ul>
</li>
<li><p>得出递归式:</p>
<p><img src="/images/1564837587143.png" alt="1564837587143"></p>
<p>其中prev(8)=5,prev(7)=3,prev(6)=2….prev(2)=0</p>
<p><img src="/images/1564837717716.png" alt="1564837717716"></p>
<p><img src="/images/1564837862341.png" alt="1564837862341"></p>
<p><img src="/images/1564838082629.png" alt="1564838082629"></p>
</li>
</ol>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxIncome</span>():</span></span><br><span class="line">    tast_incomes = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>] <span class="comment"># 每项任务的收入</span></span><br><span class="line">    <span class="comment"># 根据时间段的重合情况计算，如果选择当前任务的话，前面的离得最近的可以做的任务</span></span><br><span class="line">    prev = [-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]  <span class="comment"># -1代表如果选择当前任务的话，之前没有可选的任务</span></span><br><span class="line">    <span class="comment"># 在面临每项任务时，选择或者不选择的最大收益</span></span><br><span class="line">    result = [tast_incomes[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> prev[i] == -<span class="number">1</span>:</span><br><span class="line">            result.append(<span class="built_in">max</span>(tast_incomes[i]+<span class="number">0</span>,result[i-<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(<span class="built_in">max</span>(tast_incomes[i]+result[prev[i]],result[i-<span class="number">1</span>]))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(result)</span><br></pre></td></tr></table></figure>



<h3 id="至上而下和至下而上"><a href="#至上而下和至下而上" class="headerlink" title="至上而下和至下而上"></a>至上而下和至下而上</h3><p>下面回顾这张图</p>
<p><img src="/images/2fa4020c-1564837862341.png" alt="1564837862341"></p>
<p>要求OPT(8),那么可以至上而下,也可以至下而上</p>
<blockquote>
<p>不管是至上而下,还是至下而上都需要先找出递归出口</p>
</blockquote>
<p>步骤:</p>
<ol>
<li>制作一个数组</li>
<li>在数组中填好递归出口</li>
<li>遍历数组,不断填写数组</li>
</ol>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><h4 id="最大值问题"><a href="#最大值问题" class="headerlink" title="最大值问题"></a>最大值问题</h4><p>给出一个整数数组,相邻的两个数组不能选,求所能选出的数字的和的最大值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">arr</span>):</span></span><br><span class="line">	opt = [<span class="number">0</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">	opt[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	opt[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">		A = arr[idx] + opt[idx-<span class="number">2</span>]</span><br><span class="line">		B = opt[idx-<span class="number">1</span>]</span><br><span class="line">		opt[idx] = <span class="built_in">max</span>(A,B)</span><br><span class="line">	<span class="keyword">return</span> opt[<span class="built_in">len</span>(arr)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>



<h4 id="subset问题"><a href="#subset问题" class="headerlink" title="subset问题"></a>subset问题</h4><p>递归解法:</p>
<p>给定一个集合,给定一个target,问能否从集合中选出一堆数字,数字的和等于target</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span>(<span class="params">arr,cur,target</span>):</span></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	思路 : 当前元素cur选或不选?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	arr : 列表</span></span><br><span class="line"><span class="string">	cur : 列表的当前元素idx</span></span><br><span class="line"><span class="string">	target : 目标值</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">	<span class="keyword">elif</span> cur == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> arr[<span class="number">0</span>] == target</span><br><span class="line">	<span class="comment"># 如果当前元素大于target,那么肯定不选</span></span><br><span class="line">	<span class="keyword">elif</span> arr[cur] &gt; target:</span><br><span class="line">		<span class="keyword">return</span> recursion(arr,cur-<span class="number">1</span>,target)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="comment"># 选择当前元素</span></span><br><span class="line">		A = recursion(arr,cur-<span class="number">1</span>,target-arr[cur])</span><br><span class="line">		<span class="comment"># 不选当前元素</span></span><br><span class="line">		B = recursion(arr,cur-<span class="number">1</span>,target)</span><br><span class="line">		<span class="keyword">return</span> A <span class="keyword">or</span> B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>,<span class="number">34</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(recursion(arr,<span class="built_in">len</span>(arr)-<span class="number">1</span>,<span class="number">9</span>))</span><br></pre></td></tr></table></figure>

<p>动态规划写法:</p>
<blockquote>
<p>subset问题维护两个变量 :</p>
<ul>
<li>数组当前元素</li>
<li>目标值</li>
</ul>
</blockquote>
<blockquote>
<p>步骤:</p>
<ol>
<li>考虑最终状态怎么形成子问题.<br>这里就是subset(arr[5],9)</li>
</ol>
<p><img src="/images/1565332621335.png" alt="1565332621335"></p>
<p><img src="/images/1565332650969.png" alt="1565332650969"></p>
<ol start="2">
<li><p>寻找递归的出口</p>
<p><img src="/images/1565332745445.png" alt="1565332745445"></p>
</li>
<li><p>得出状态转移方程</p>
<p><img src="/images/1565332931309.png" alt="1565332931309"></p>
</li>
<li><p>列出列表<br>要充分理解这张图 : 图中的单元格subset[3,5]表示:<br><strong>子集长度为5(3,34,4,12,5,2),能不能拼凑成3这个目标值</strong></p>
<p><img src="/images/1565333261051.png" alt="1565333261051"></p>
</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp_subset</span>(<span class="params">arr,target</span>):</span></span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	arr : 数组</span></span><br><span class="line"><span class="string">	target : 目标值</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span></span><br><span class="line">	subset = np.zeros((<span class="built_in">len</span>(arr),target+<span class="number">1</span>),dtype=<span class="built_in">bool</span>)</span><br><span class="line">	subset[<span class="number">0</span>,:] = <span class="literal">False</span></span><br><span class="line">	subset[:,<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">	subset[<span class="number">0</span>,arr[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">	<span class="comment"># cur数组的元素idx</span></span><br><span class="line">	<span class="comment"># t : target</span></span><br><span class="line">	<span class="keyword">for</span> cur <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">		<span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):</span><br><span class="line">			<span class="keyword">if</span> arr[cur] &gt; t:</span><br><span class="line">				<span class="keyword">return</span> subset[cur-<span class="number">1</span>,t]</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				A = subset[cur-<span class="number">1</span>,t]</span><br><span class="line">				B = subset[cur-<span class="number">1</span>,t-arr[cur]]</span><br><span class="line">				subset = A <span class="keyword">or</span> B</span><br><span class="line"></span><br><span class="line">	r,c = subset.shape</span><br><span class="line">	<span class="keyword">return</span> subset[r-<span class="number">1</span>,c-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>,<span class="number">34</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(dp_subset(arr,<span class="number">9</span>))<span class="number">22</span></span><br></pre></td></tr></table></figure>

<h4 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h4><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>这个最大和的连续序列只有一个元素，以A[i]开始，A[i]结尾</li>
<li>这个最大和的连续序列多个元素，从前面A[p]开始（p&lt;i),一直到A[i]结束。</li>
<li>对于第一种情况，最大和就是A[i]本身。 第二张，最大和是<code>dp[i-1]+A[i]</code>。</li>
<li>于是得到方程：<strong>dp[i]=max(dp[i-1]+A[i],A[i])。</strong> 边界dp[0]=nums[0].</li>
<li>于是从小到大输出dp数组，找到他的最大值，即为最大子序列和。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        opt = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        opt[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            A = nums[idx]</span><br><span class="line">            B = opt[idx-<span class="number">1</span>] + nums[idx]</span><br><span class="line">            opt[idx] = <span class="built_in">max</span>(A,B)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(opt)</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.maxSubArray([-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]))  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<p>因为是求最大值,我们还可以改造为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        opt = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        res = opt[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            A = nums[idx]</span><br><span class="line">            B = opt[idx-<span class="number">1</span>] + nums[idx]</span><br><span class="line">            opt[idx] = <span class="built_in">max</span>(A,B)</span><br><span class="line">            </span><br><span class="line">            res = <span class="built_in">max</span>(opt[idx],res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.maxSubArray([-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]))  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>



<h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 考虑最终状态怎么形成子问题.</span></span><br><span class="line"><span class="comment"># 寻找递归的出口</span></span><br><span class="line"><span class="comment"># 得出状态转移方程</span></span><br><span class="line"><span class="comment"># 列出列表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">    	min_num = prices[<span class="number">0</span>]</span><br><span class="line">    	res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">    		min_num = <span class="built_in">min</span>(min_num,prices[idx]) </span><br><span class="line">    		res = <span class="built_in">max</span>(res,prices[idx] - min_num)</span><br><span class="line">    	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.maxProfit([<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>



<h4 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h4><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="%E7%B4%A2%E5%BC%95%E4%BB%8E0%E5%BC%80%E5%A7%8B">i</a>。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<p>示例 1:</p>
<p>输入: cost = [10, 15, 20]<br>输出: 15<br>解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。<br> 示例 2:</p>
<p>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出: 6<br>解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。<br>注意：</p>
<p>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在首尾都加一个0</span><br><span class="line">分别代表地面，和楼顶</span><br><span class="line">数组的每一个数字代表从当前楼梯迈出所需要耗费的体力</span><br><span class="line">从地面开始，第一步可以选择第0阶或者第1阶，都不费力</span><br><span class="line">最终要求到达最后一个0（楼顶）所耗费的体力最少。</span><br></pre></td></tr></table></figure>

<p>也可以修改成:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    	cost.append(<span class="number">0</span>)</span><br><span class="line">    	step_1 = step_2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(cost)):</span><br><span class="line">    		A = step_1 + cost[idx-<span class="number">1</span>]</span><br><span class="line">    		B = step_2 + cost[idx-<span class="number">2</span>]</span><br><span class="line">    		step_2 = step_1</span><br><span class="line">    		step_1 = <span class="built_in">min</span>(A,B)</span><br><span class="line">    	<span class="keyword">return</span> step_1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.minCostClimbingStairs([<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>]))</span><br></pre></td></tr></table></figure>
















































































</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>