<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h3 id=&quot;Python有哪些特点和优点&quot;&gt;&lt;a href=&quot;#Python有哪些特点和优点&quot; class=&quot;headerlink&quot; title=&quot;Python有哪些特点和优点&quot;&gt;&lt;/a&gt;Python有哪些特点和优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可解释&lt;/li&gt;
&lt;li&gt;具有动态特性&lt;/li&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;简明简单&lt;/li&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;具有强大的社区支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;python2和python3区别&quot;&gt;&lt;a href=&quot;#python2和python3区别&quot; class=&quot;headerlink&quot; title=&quot;python2和python3区别&quot;&gt;&lt;/a&gt;python2和python3区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Python3 使用 print &lt;/li&gt;
&lt;li&gt;python2 range(1,10)返回列表，python3中返回迭代器，节约内存&lt;/li&gt;
&lt;li&gt;python2中使用ascii编码，python中使用utf-8编码&lt;/li&gt;
&lt;li&gt;python2中unicode表示字符串序列，str表示字节序列,python3中str表示字符串序列，byte表示字节序列&lt;/li&gt;
&lt;li&gt;python2中为正常显示中文，引入coding声明，python3中不需要&lt;/li&gt;
&lt;li&gt;python2中是raw_input()函数，python3中是input()函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h3&gt;&lt;p&gt;基本数据类型 : 整型,浮点型,字符串,布尔型&lt;br&gt;容器类型 : 列表,元组,集合,字典"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>面试问题总结1_python基础篇 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Interview/" rel="tag">Interview</a></div><div class="post-time">2019-08-29</div></div></div><div class="container post-header"><h1>面试问题总结1_python基础篇</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">Python有哪些特点和优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python2%E5%92%8Cpython3%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">python2和python3区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">Python中有多少种运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%B8%AD%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%E9%95%BF%E5%BA%A6%E8%83%BD%E6%9C%89%E5%A4%9A%E9%95%BF%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">Python中的标识符长度能有多长？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Python%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">在Python中如何使用多进制数字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA5%E4%B8%AA%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">1.7.</span> <span class="toc-text">列出5个标准库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E8%A3%85"><span class="toc-number">1.8.</span> <span class="toc-text">什么是封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGIL"><span class="toc-number">1.9.</span> <span class="toc-text">什么是GIL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">1.10.</span> <span class="toc-text">什么是闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-dict"><span class="toc-number">1.11.</span> <span class="toc-text">什么是__dict__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.12.</span> <span class="toc-text">什么是装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E8%AF%AD%E8%A8%80%E8%83%BD%E5%A4%9F%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.13.</span> <span class="toc-text">什么样的语言能够用装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.14.</span> <span class="toc-text">什么是协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.15.</span> <span class="toc-text">什么是哈希函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81"><span class="toc-number">1.16.</span> <span class="toc-text">什么是猴子补丁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.17.</span> <span class="toc-text">什么是内存溢出,内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89"><span class="toc-number">1.18.</span> <span class="toc-text">什么是多线程竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%EF%BC%8C%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81"><span class="toc-number">1.19.</span> <span class="toc-text">什么是锁，有哪几种锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-number">1.20.</span> <span class="toc-text">什么是死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.21.</span> <span class="toc-text">什么是同步，异步，阻塞，非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%EF%BC%9F%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.22.</span> <span class="toc-text">什么是僵尸进程和孤儿进程？怎么避免僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E4%B8%AD%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.23.</span> <span class="toc-text">python中进程与线程的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84"><span class="toc-number">1.24.</span> <span class="toc-text">回调函数是如何通信的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">1.25.</span> <span class="toc-text">Python什么时候会造成内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84"><span class="toc-number">1.26.</span> <span class="toc-text">Python是如何管理内存的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84%E8%B0%83%E4%BC%98%E6%89%8B%E6%AE%B5"><span class="toc-number">1.27.</span> <span class="toc-text">Python的调优手段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.28.</span> <span class="toc-text">Python中变量的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.29.</span> <span class="toc-text">可变对象和不可变对象的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is%E5%92%8C-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.30.</span> <span class="toc-text">is和&#x3D;&#x3D;区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import-M%E5%92%8Cfrom-A-import-B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.31.</span> <span class="toc-text">import M和from A import B区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%92%8C-init-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.32.</span> <span class="toc-text">__new__和__init__区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy%E5%92%8Cdeepcopy%E5%8C%BA%E5%88%AB"><span class="toc-number">1.33.</span> <span class="toc-text">copy和deepcopy区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BC%8F%E7%B1%BB%E5%92%8C%E7%BB%8F%E5%85%B8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.34.</span> <span class="toc-text">新式类和经典类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.35.</span> <span class="toc-text">生成器，迭代器的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">1.36.</span> <span class="toc-text">抽象类和接口类的区别和联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8CCPU%E5%AF%86%E9%9B%86%E5%9E%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.37.</span> <span class="toc-text">IO密集型和CPU密集型区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C-parallel-%E5%92%8C%E5%B9%B6%E5%8F%91%EF%BC%88concurrency-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.38.</span> <span class="toc-text">并行(parallel)和并发（concurrency)的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.39.</span> <span class="toc-text">简述继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0dir-%E5%87%BD%E6%95%B0"><span class="toc-number">1.40.</span> <span class="toc-text">简述dir() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%BD%BF%E7%94%A8-args%E5%92%8C-kwargs%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">1.41.</span> <span class="toc-text">简述使用*args和**kwargs的含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.42.</span> <span class="toc-text">简述函数重载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.43.</span> <span class="toc-text">简述多线程、多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Python%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.44.</span> <span class="toc-text">简述Python的线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.45.</span> <span class="toc-text">简述垃圾回收机制(引用计数机制)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.46.</span> <span class="toc-text">简述设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.47.</span> <span class="toc-text">单例模式的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Python%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-number">1.48.</span> <span class="toc-text">简述Python如何管理内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E9%A1%B9%E7%9B%AE%E6%98%AF%E5%90%A6%E7%94%A8"><span class="toc-number">1.49.</span> <span class="toc-text">谈谈你对多进程，多线程，以及协程的理解，项目是否用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E9%80%80%E5%87%BAPython%E6%97%B6%EF%BC%8C%E6%98%AF%E5%90%A6%E9%87%8A%E6%94%BE%E5%85%A8%E9%83%A8%E5%86%85%E5%AD%98"><span class="toc-number">1.50.</span> <span class="toc-text">当退出Python时，是否释放全部内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E6%95%B0%E5%AD%97%E9%97%AD%E7%8E%AF"><span class="toc-number">1.51.</span> <span class="toc-text">如何让数字闭环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.52.</span> <span class="toc-text">谈谈你对面向对象的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">1.53.</span> <span class="toc-text">面向对象中怎么实现只读属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">1.54.</span> <span class="toc-text">函数调用参数的传递方式是值传递还是引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E4%BA%92%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BA%86%E5%B0%B1%E4%B8%8D%E8%AE%BF%E9%97%AE%E4%BA%86%EF%BC%9F"><span class="toc-number">1.55.</span> <span class="toc-text">多线程交互访问数据，如果访问到了就不访问了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.56.</span> <span class="toc-text">解决哈希冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-number">1.57.</span> <span class="toc-text">尾递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E9%97%AD%E5%8C%85%E7%9A%84%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A"><span class="toc-number">1.58.</span> <span class="toc-text">python闭包的延迟绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-asyncio%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.59.</span> <span class="toc-text">python asyncio的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">2.6.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8headqp%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.</span> <span class="toc-text">利用headqp模块实现堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">2.8.</span> <span class="toc-text">冒泡排序的基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">2.9.</span> <span class="toc-text">快速排序的基本思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">3.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">3.1.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.2.</span> <span class="toc-text">二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">4.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">5.1.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%A0%91"><span class="toc-number">5.1.1.</span> <span class="toc-text">模拟树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">5.1.2.</span> <span class="toc-text">树的构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.1.3.</span> <span class="toc-text">树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.1.4.</span> <span class="toc-text">完整二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-number">5.1.5.</span> <span class="toc-text">最小二叉堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">5.1.6.</span> <span class="toc-text">二叉查找树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">5.2.</span> <span class="toc-text">广度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMD5%E5%8A%A0%E5%AF%86%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">5.2.1.</span> <span class="toc-text">什么是MD5加密，有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">什么是对称加密和非对称加密</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Python有哪些特点和优点"><a href="#Python有哪些特点和优点" class="headerlink" title="Python有哪些特点和优点"></a>Python有哪些特点和优点</h3><ul>
<li>可解释</li>
<li>具有动态特性</li>
<li>面向对象</li>
<li>简明简单</li>
<li>开源</li>
<li>具有强大的社区支持</li>
</ul>
<h3 id="python2和python3区别"><a href="#python2和python3区别" class="headerlink" title="python2和python3区别"></a>python2和python3区别</h3><ul>
<li>Python3 使用 print </li>
<li>python2 range(1,10)返回列表，python3中返回迭代器，节约内存</li>
<li>python2中使用ascii编码，python中使用utf-8编码</li>
<li>python2中unicode表示字符串序列，str表示字节序列,python3中str表示字符串序列，byte表示字节序列</li>
<li>python2中为正常显示中文，引入coding声明，python3中不需要</li>
<li>python2中是raw_input()函数，python3中是input()函数</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>基本数据类型 : 整型,浮点型,字符串,布尔型<br>容器类型 : 列表,元组,集合,字典</p>
<h3 id="Python中有多少种运算符"><a href="#Python中有多少种运算符" class="headerlink" title="Python中有多少种运算符"></a>Python中有多少种运算符</h3><p>7种运算符：算术运算符、关系运算符、赋值运算符、逻辑运算符、位运算符、成员运算符、身份运算符。</p>
<p>身份运算符:通过身份运算符‘is’和‘is not’，我们可以确认两个值是否相同。</p>
<h3 id="Python中的标识符长度能有多长？"><a href="#Python中的标识符长度能有多长？" class="headerlink" title="Python中的标识符长度能有多长？"></a>Python中的标识符长度能有多长？</h3><p><strong>标识符可以是任意长度</strong>。此外，我们在命名标识符时还必须遵守以下规则：</p>
<ol>
<li>只能以下划线或者 A-Z/a-z 中的字母开头</li>
<li>其余部分可以使用 A-Z/a-z/0-9</li>
<li>区分大小写</li>
<li>关键字不能作为标识符</li>
</ol>
<h3 id="在Python中如何使用多进制数字？"><a href="#在Python中如何使用多进制数字？" class="headerlink" title="在Python中如何使用多进制数字？"></a>在Python中如何使用多进制数字？</h3><ul>
<li>二进制数字由0和1组成，我们使用 0b 或 0B 前缀表示二进制数。</li>
<li>八进制数由数字 0-7 组成，用前缀 0o 或 0O 表示 8 进制数。</li>
<li>十六进数由数字 0-15 组成，用前缀 0x 或者 0X 表示 16 进制数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="number">0b1010</span>)</span><br><span class="line">x = <span class="built_in">int</span>(<span class="number">0o1010</span>)</span><br><span class="line">x = <span class="built_in">int</span>(<span class="number">0x1010</span>)</span><br></pre></td></tr></table></figure>





<h3 id="列出5个标准库"><a href="#列出5个标准库" class="headerlink" title="列出5个标准库"></a>列出5个标准库</h3><p>os<br>re<br>math<br>readom<br>asyncio<br>datetime<br>collections<br>functools<br>copy<br>urllib<br>pickle<br>itertools</p>
<h3 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h3><p>封装可以分成两种:</p>
<ol>
<li><p>对同一类方法封装到类中</p>
<blockquote>
<p>比如将数据库的增删改查封装成class DB类</p>
</blockquote>
</li>
<li><p>将数据封装到对象中</p>
<blockquote>
<p>比如将age,name属性封装到Person对象中</p>
</blockquote>
</li>
</ol>
<h3 id="什么是GIL"><a href="#什么是GIL" class="headerlink" title="什么是GIL"></a>什么是GIL</h3><p>全局解释器锁</p>
<blockquote>
<ul>
<li><p>同一进程中有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。</p>
</li>
<li><p>如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</p>
</li>
<li><p>多进程中因为每个进程都能被系统分配资源，相当于<strong>每个进程有了一个python解释器</strong>，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大</p>
</li>
</ul>
</blockquote>
<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p><strong>嵌套函数在其外部区域引用了一个值</strong>时，该嵌套函数就是一个闭包。其意义就是会记录这个值。</p>
<h3 id="什么是-dict"><a href="#什么是-dict" class="headerlink" title="什么是__dict__"></a>什么是__dict__</h3><ul>
<li><p>类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类<code>__dict__</code>里的。对象的<code>__dict__</code>中存储了一些<strong>self.xxx</strong>的一些东西</p>
</li>
<li><p>一个实例的<code>__dict__</code>属性仅仅是那个实例的实例属性的集合，并不包含该实例的所有有效属性。</p>
</li>
<li><p>dir()函数会自动寻找一个对象的所有属性，包括<code>__dict__</code>中的属性。</p>
<p><code>__dict__</code>是dir()的子集，dir()包含<code>__dict__</code>中的属性。</p>
</li>
</ul>
<h3 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h3><ol>
<li>装饰器本质上是一个callable object ，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。</li>
<li>装饰器本质上是⼀个python函数，这个函数的特点是可以接受其它的函数当作它的参数，并将其替换成一个新的函数,它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能；</li>
<li>装饰器的返回值也是⼀个函数的对象</li>
<li>用于插入日志、性能测试、事务处理、缓存、权限校验等场景。有了装饰器，就可以抽离出大量<strong>与函数功能本身无关</strong>的雷同代码并继续重用。</li>
</ol>
<h3 id="什么样的语言能够用装饰器"><a href="#什么样的语言能够用装饰器" class="headerlink" title="什么样的语言能够用装饰器"></a>什么样的语言能够用装饰器</h3><p>函数可以作为参数传递的语言，可以使用装饰器</p>
<h3 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h3><p>协程：是一种用户态的轻量级线程，协程的调度完全由用户控制</p>
<p>协程主要解决的还是并发的问题，以及python GIL带来的并行处理能力。</p>
<h3 id="什么是哈希函数"><a href="#什么是哈希函数" class="headerlink" title="什么是哈希函数"></a>什么是哈希函数</h3><p>散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。创建一个叫做<code>散列值</code>的指纹</p>
<h3 id="什么是猴子补丁"><a href="#什么是猴子补丁" class="headerlink" title="什么是猴子补丁"></a>什么是猴子补丁</h3><p>在运行期间动态修改一个类或模块。</p>
<h3 id="什么是内存溢出-内存泄漏"><a href="#什么是内存溢出-内存泄漏" class="headerlink" title="什么是内存溢出,内存泄漏"></a>什么是内存溢出,内存泄漏</h3><ul>
<li><p>内存泄漏<code>memory leak</code> :<br>是指程序在申请内存后，<strong>无法释放已申请的内存空间</strong>，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 </p>
<blockquote>
<ul>
<li>有<code>__del__()</code>函数的<strong>对象间的循环引用</strong>是导致内存泄露的主凶。</li>
<li>不使用一个对象时<strong>使用 del object 来删除一个对象</strong>的引用计数就可以有效防止内存泄露问题。</li>
</ul>
</blockquote>
</li>
<li><p>内存溢出 <code>out of memory</code> :<br>指程序申请内存时，<strong>没有足够的内存供申请者使用</strong>，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错,即所谓的内存溢出。   </p>
</li>
</ul>
<blockquote>
<ul>
<li>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。</li>
<li>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问，而系统也不能再次将它分配给需要的程序。  </li>
</ul>
</blockquote>
<h3 id="什么是多线程竞争"><a href="#什么是多线程竞争" class="headerlink" title="什么是多线程竞争"></a>什么是多线程竞争</h3><ul>
<li>线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态,即：数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全</li>
<li>怎么解决多线程竞争问题？ 锁</li>
<li>锁的好处： 确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。</li>
<li>锁的坏处： 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li>
<li>锁的致命问题: 死锁</li>
</ul>
<h3 id="什么是锁，有哪几种锁"><a href="#什么是锁，有哪几种锁" class="headerlink" title="什么是锁，有哪几种锁"></a>什么是锁，有哪几种锁</h3><ul>
<li>锁(Lock)是python提供的对线程控制的对象。</li>
<li>互斥锁，可重入锁，死锁。</li>
</ul>
<h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><ul>
<li><p>若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。</p>
</li>
<li><p>GIL锁 全局解释器锁<br>作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！</p>
</li>
<li><p>所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。<br><strong>进程和线程的切换时由系统决定，而协程由我们程序员自己决定</strong>，而模块gevent下切换是遇到了耗时操作时才会切换。<br>三者的关系：进程里有线程，线程里有协程。</p>
</li>
</ul>
<h3 id="什么是同步，异步，阻塞，非阻塞"><a href="#什么是同步，异步，阻塞，非阻塞" class="headerlink" title="什么是同步，异步，阻塞，非阻塞"></a>什么是同步，异步，阻塞，非阻塞</h3><ul>
<li>同步： <strong>多个任务之间有先后顺序执行</strong>，一个执行完下个才能执行。</li>
<li>异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！</li>
<li>阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。</li>
<li>非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。</li>
</ul>
<blockquote>
<p>同步异步相对于<strong>多任务</strong>而言，阻塞非阻塞相对于<strong>代码执行</strong>而言。</p>
</blockquote>
<h3 id="什么是僵尸进程和孤儿进程？怎么避免僵尸进程"><a href="#什么是僵尸进程和孤儿进程？怎么避免僵尸进程" class="headerlink" title="什么是僵尸进程和孤儿进程？怎么避免僵尸进程"></a>什么是僵尸进程和孤儿进程？怎么避免僵尸进程</h3><ul>
<li><p>孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init 进程（进程号为1）所收养，并由init 进程对他们完成状态收集工作。</p>
</li>
<li><p>僵尸进程： 进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用wait 获取waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。</p>
<blockquote>
<ul>
<li><p>启动一个程序，开始我们的任务，然后等任务结束了，我们就停止这个进程。 进程停止后， 该进程就会从进程表中移除。但是，有时候有些程序即使执行完了也依然留在进程表中。那么，这些完成了生命周期但却依然留在进程表中的进程，我们称之为 “僵尸进程”。</p>
</li>
<li><p>当你运行一个程序时，它会产生一个父进程以及很多子进程。 所有这些子进程都会消耗内核分配给它们的内存和 CPU 资源。</p>
<p>这些子进程完成执行后会发送一个 Exit 信号然后死掉。这个 Exit 信号需要被父进程所读取。父进程需要随后调用 <code>wait</code> 命令来读取子进程的退出状态，并将子进程从进程表中移除。</p>
<p>若父进程正确第读取了子进程的 Exit 信号，则子进程会从进程表中删掉。</p>
<p>但若父进程未能读取到子进程的 Exit 信号，则这个子进程虽然完成执行处于死亡的状态，但也不会从进程表中删掉。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>避免僵尸进程的方法：</p>
<ol>
<li>fork 两次用孙子进程去完成子进程的任务</li>
<li>用wait()函数使父进程阻塞</li>
<li>使用信号量，在signal handler 中调用waitpid,这样父进程不用阻塞</li>
</ol>
</li>
</ul>
<h3 id="python中进程与线程的使用场景"><a href="#python中进程与线程的使用场景" class="headerlink" title="python中进程与线程的使用场景"></a>python中进程与线程的使用场景</h3><p>多进程适合在CPU密集操作（cpu操作指令比较多，如位多的的浮点运算）。</p>
<p>多线程适合在IO密性型操作（读写数据操作比多的的，比如爬虫）</p>
<h3 id="回调函数是如何通信的"><a href="#回调函数是如何通信的" class="headerlink" title="回调函数是如何通信的"></a>回调函数是如何通信的</h3><p>回调函数是把函数的指针(地址)作为参数传递给另一个函数，<strong>将整个函数当作一个对象，赋值给调用的函数</strong>。</p>
<h3 id="Python什么时候会造成内存溢出"><a href="#Python什么时候会造成内存溢出" class="headerlink" title="Python什么时候会造成内存溢出"></a>Python什么时候会造成内存溢出</h3><ol>
<li>一次性加载过大的文件</li>
<li>滥用<code>__del__</code>方法</li>
<li>关闭了垃圾回收或者将垃圾回收的阈值调得太高</li>
</ol>
<h3 id="Python是如何管理内存的"><a href="#Python是如何管理内存的" class="headerlink" title="Python是如何管理内存的"></a>Python是如何管理内存的</h3><p>Python有一个<strong>私有堆空间</strong>来保存所有的对象和数据结构。</p>
<ul>
<li>计数引用</li>
<li>垃圾回收</li>
<li>内存池机制</li>
</ul>
<h3 id="Python的调优手段"><a href="#Python的调优手段" class="headerlink" title="Python的调优手段"></a>Python的调优手段</h3><ol>
<li><p>手动垃圾回收</p>
</li>
<li><p>调高垃圾回收阈值</p>
</li>
<li><p>避免循环引用</p>
</li>
</ol>
<h3 id="Python中变量的作用域"><a href="#Python中变量的作用域" class="headerlink" title="Python中变量的作用域"></a>Python中变量的作用域</h3><p>LEGB顺序</p>
<ul>
<li>L： local 函数内部作用域</li>
<li>E： <strong>enclosing 函数内部与内嵌函数之间</strong></li>
<li>G： global 全局作用域</li>
<li>B： build-in 内置作用</li>
</ul>
<h3 id="可变对象和不可变对象的区别"><a href="#可变对象和不可变对象的区别" class="headerlink" title="可变对象和不可变对象的区别"></a>可变对象和不可变对象的区别</h3><ul>
<li>可变对象：对象存放在地址中的值不会被改变<br>（所谓的改变是创建了一块新的地址并把新的对象的值放在新地址中原来的对象并没有发生变化）</li>
<li>不可变对象：对象存放在地址中的值会原地改变</li>
</ul>
<h3 id="is和-区别"><a href="#is和-区别" class="headerlink" title="is和==区别"></a>is和==区别</h3><ul>
<li>is：比较的是两个对象的id值是否相等，也就是<strong>比较俩对象是否为同一个实例对象</strong>。是否指向同一个内存地址</li>
<li>== ： 比较的两个对象的内容/值是否相等，默认<strong>会调用对象的eq()方法</strong>。</li>
</ul>
<h3 id="import-M和from-A-import-B区别"><a href="#import-M和from-A-import-B区别" class="headerlink" title="import M和from A import B区别"></a>import M和from A import B区别</h3><ul>
<li><p>在底层执行机制都会执行三步走,并没有没有谁比谁更节省内存之说</p>
<blockquote>
<ul>
<li>在自己的命名空间执行被导入模块中的所有代码；</li>
<li>以模块名为名称创建一个模块对象，并将模块中所有的顶级变量（包括变量和函数）以属性的形式绑定在该模块对象上；</li>
<li>在import位置引入该对象名称到当前命名空间。</li>
</ul>
</blockquote>
</li>
<li><p>区别在于 : <strong>拿被导入模块中的哪些部分到当前命名空间中进行使用</strong></p>
</li>
</ul>
<h3 id="new-和-init-区别"><a href="#new-和-init-区别" class="headerlink" title="__new__和__init__区别"></a>__new__和__init__区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__init__ 方法为初始化方法, __new__方法才是真正的构造函数。</span><br><span class="line">__new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别,返回实例化出来的实例</span><br><span class="line">如果__new__创建的是当前类的实例，会自动调用__init__函数</span><br><span class="line">__init__有一个参数self，就是这个__new__返回的实例</span><br></pre></td></tr></table></figure>



<h3 id="copy和deepcopy区别"><a href="#copy和deepcopy区别" class="headerlink" title="copy和deepcopy区别"></a>copy和deepcopy区别</h3><blockquote>
<ol>
<li>copy.copy <strong>浅拷贝 只拷贝父对象，不会拷贝对象的内部的子对象。</strong></li>
<li>copy.deepcopy <strong>深拷贝 拷贝对象及其子对象</strong></li>
</ol>
</blockquote>
<h3 id="新式类和经典类的区别"><a href="#新式类和经典类的区别" class="headerlink" title="新式类和经典类的区别"></a>新式类和经典类的区别</h3><ul>
<li>经典类在加载的时候采用的是深度优先算法，新式类采用的是广度优先算法</li>
<li>新式类增加了__slots__内置属性, 可以把实例属性的种类锁定到__slots__规定的范围之中。</li>
<li>新式类增加了__getattribute__方法</li>
<li>新式类内置有__new__方法而经典类没有__new__方法而只有__init__方法</li>
<li>Python 2中默认都是经典类，只有显式继承了object才是新式类</li>
</ul>
<h3 id="生成器，迭代器的区别"><a href="#生成器，迭代器的区别" class="headerlink" title="生成器，迭代器的区别"></a>生成器，迭代器的区别</h3><ul>
<li>迭代器是遵循迭代协议的对象。需要对象实现<code>__iter__</code>和<code>__next__</code>方法,我们可以使用iter函数将序列改造成一个迭代器。当没有元素时，迭代器引发 StopIteration 。</li>
<li><strong>生成器只是在需要返回数据的时候使用yield语句</strong>。被next()调用时,生成器就会挂起。</li>
<li>区别： 生成器能做到迭代器能做的所有事，而且因为自动创建iter()和next()方法，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。</li>
</ul>
<h3 id="抽象类和接口类的区别和联系"><a href="#抽象类和接口类的区别和联系" class="headerlink" title="抽象类和接口类的区别和联系"></a>抽象类和接口类的区别和联系</h3><ol>
<li><p>抽象类： </p>
<ul>
<li>规定了一系列的方法，并规定了必须由继承类实现的方法。</li>
<li>由于有抽象方法的存在，所以抽象类不能实例化。</li>
<li>可以将抽象类理解为毛坯房，门窗，墙面的样式由你自己来定，所以抽象类与作为基类的普通类的区别在于约束性更强</li>
</ul>
</li>
<li><p>接口类：</p>
<ul>
<li>与抽象类很相似，表现在接口中定义的方法，必须由引用类实现，但他与抽象类的根本区别在于用途：<strong>与不同个体间沟通的规则</strong>，</li>
<li>你要进宿舍需要有钥匙，这个钥匙就是你与宿舍的接口，你的舍友也有这个接口，所以他也能进入宿舍，你用手机通话，那么手机就是你与他人交流的接口</li>
</ul>
</li>
<li><p>区别和关联：</p>
<ul>
<li>接口是抽象类的变体，接口中所有的方法都是抽象的，而抽象类中可以有非抽象方法，抽象类是声明方法的存在而不去实现它的类</li>
<li>接口可以继承，抽象类不行</li>
<li>接口定义方法，没有实现的代码，而抽象类可以实现部分方法</li>
<li>接口中基本数据类型为static而抽象类不是</li>
</ul>
</li>
</ol>
<h3 id="IO密集型和CPU密集型区别"><a href="#IO密集型和CPU密集型区别" class="headerlink" title="IO密集型和CPU密集型区别"></a>IO密集型和CPU密集型区别</h3><p>IO密集型： 系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写</p>
<p>CPU密集型： 大部分时间用来做计算，逻辑判断等CPU动作的程序称之CPU密集型。</p>
<h3 id="并行-parallel-和并发（concurrency-的区别"><a href="#并行-parallel-和并发（concurrency-的区别" class="headerlink" title="并行(parallel)和并发（concurrency)的区别"></a>并行(parallel)和并发（concurrency)的区别</h3><ul>
<li>并行： 同一时刻多个任务同时在运行<br>并发： 不会在同一时刻同时运行，存在交替执行的情况。</li>
<li>实现并行的库有： multiprocessing<br>实现并发的库有:  threading</li>
<li>程序需要执行较多的读写、请求和回复任务的需要大量的IO操作，IO密集型操作使用并发更好。</li>
<li>CPU运算量大的程序，使用并行会更好</li>
</ul>
<h3 id="简述继承"><a href="#简述继承" class="headerlink" title="简述继承"></a>简述继承</h3><p>当一个类继承自另一个类，它就被称为一个子类/派生类，继承自父类/基类/超类。它会继承/获取所有类成员（属性和方法）。</p>
<h3 id="简述dir-函数"><a href="#简述dir-函数" class="headerlink" title="简述dir() 函数"></a>简述dir() 函数</h3><ul>
<li>不带参数时，返回当前范围内的变量、方法和定义的类型列表；</li>
<li>带参数时，返回参数的属性、方法的列表。</li>
</ul>
<blockquote>
<p>简单来说 : 返回内建方法</p>
</blockquote>
<h3 id="简述使用-args和-kwargs的含义"><a href="#简述使用-args和-kwargs的含义" class="headerlink" title="简述使用*args和**kwargs的含义"></a>简述使用*args和**kwargs的含义</h3><ul>
<li>当我们不知道向函数传递多少参数时，比如我们向传递一个列表或元组，我们就使用*args。</li>
<li>在我们不知道该传递多少关键字参数时，使用**kwargs来收集关键字参数。</li>
</ul>
<h3 id="简述函数重载机制"><a href="#简述函数重载机制" class="headerlink" title="简述函数重载机制"></a>简述函数重载机制</h3><p>函数重载主要是为了解决两个问题。</p>
<ol>
<li>可变参数类型。</li>
<li>可变参数个数。</li>
</ol>
<p>一个基本的设计原则是，</p>
<ul>
<li>仅仅当两个函数功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</li>
<li>如果函数功能相同，但是参数类型不同。python本身就是动态语言,变量并没有数据类型,可以接受任何类型的参数</li>
<li>如果函数功能相同，但参数个数不同。python可以使用缺省参数</li>
<li>如果真的要显式的使用重载,可以使用functools里面的singledispatch函数</li>
</ul>
<h3 id="简述多线程、多进程"><a href="#简述多线程、多进程" class="headerlink" title="简述多线程、多进程"></a>简述多线程、多进程</h3><p>进程：</p>
<ol>
<li>操作系统进行资源分配和调度的基本单位，多个进程之间相互独立</li>
<li>稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制</li>
</ol>
<p>线程：</p>
<ol>
<li>CPU进行资源分配和调度的基本单位，线程是进程的一部分</li>
<li>如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃</li>
</ol>
<h3 id="简述Python的线程同步"><a href="#简述Python的线程同步" class="headerlink" title="简述Python的线程同步"></a>简述Python的线程同步</h3><ol>
<li>setDaemon(False)<br>主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。</li>
<li>setDaemon(True)<br>主线程一旦执行结束，则全部子线程被强制终止。</li>
<li>join(线程同步)<br>join 所完成的工作就是线程同步，即主线程任务结束以后，进入堵塞状态，一直等待所有的子线程结束以后，主线程再终止。</li>
</ol>
<h3 id="简述垃圾回收机制-引用计数机制"><a href="#简述垃圾回收机制-引用计数机制" class="headerlink" title="简述垃圾回收机制(引用计数机制)"></a>简述垃圾回收机制(引用计数机制)</h3><ul>
<li>以引用计数为主，标记-清除和分代清除为辅</li>
<li>标记-清除和分代回收主要是为了处理循环引用的难题。</li>
</ul>
<h3 id="简述设计模式"><a href="#简述设计模式" class="headerlink" title="简述设计模式"></a>简述设计模式</h3><ul>
<li>设计模式是经过总结，优化的，对我们经常会碰到的一些编程问题的可重用解决方案。</li>
<li>一个设计模式并不像一个类或一个库那样能够直接作用于我们的代码，反之，设计模式更为高级，它是一种必须在特定情形下实现的一种方法模板。</li>
<li>常见的是<code>工厂模式</code>和<code>单例模式</code></li>
</ul>
<h3 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h3><ul>
<li><strong>资源共享</strong>的情况下，==避免由于资源操作时导致的性能或损耗==等，如<code>日志文件</code>，<code>应用配置</code>。</li>
<li><strong>控制资源</strong>的情况下，==方便资源之间的互相通信==。如线程池等，<ol>
<li>网站的计数器 </li>
<li>应用配置 </li>
<li>多线程池 </li>
<li>数据库配置 数据库连接池 </li>
<li>应用程序的日志应用</li>
<li>…</li>
</ol>
</li>
</ul>
<h3 id="简述Python如何管理内存"><a href="#简述Python如何管理内存" class="headerlink" title="简述Python如何管理内存"></a>简述Python如何管理内存</h3><ul>
<li>Python有一个<strong>私有堆空间</strong>来保存所有的对象和数据结构。</li>
<li>作为开发者，我们无法访问它，是解释器在管理它。但是有了核心API后，我们可以访问一些工具。Python内存管理器控制内存分配。</li>
<li>另外，内置垃圾回收器会回收使用所有的未使用内存，所以使其适用于堆空间。</li>
</ul>
<h3 id="谈谈你对多进程，多线程，以及协程的理解，项目是否用"><a href="#谈谈你对多进程，多线程，以及协程的理解，项目是否用" class="headerlink" title="谈谈你对多进程，多线程，以及协程的理解，项目是否用"></a>谈谈你对多进程，多线程，以及协程的理解，项目是否用</h3><ul>
<li>进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。</li>
<li>线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程，而多个线程共享内存（数据共享，共享全局变量),从而极大地提高了程序的运行效率。</li>
<li>协程: 是一种<strong>用户态的轻量级线程，协程的调度完全由用户控制</strong>。协程拥有自己的<strong>寄存器上下文和栈</strong>。协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</li>
</ul>
<h3 id="当退出Python时，是否释放全部内存"><a href="#当退出Python时，是否释放全部内存" class="headerlink" title="当退出Python时，是否释放全部内存"></a>当退出Python时，是否释放全部内存</h3><ul>
<li>No。循环引用其它对象或引用自全局命名空间的对象的模块，在Python退出时并非完全释放。</li>
<li>另外，也不会释放C库保留的内存部分</li>
</ul>
<h3 id="如何让数字闭环"><a href="#如何让数字闭环" class="headerlink" title="如何让数字闭环"></a>如何让数字闭环</h3><ul>
<li>输入0到11正常显示</li>
<li>输入12,返回0.输入13返回1,实现数字的闭环</li>
</ul>
<p><strong>使用求余</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num % <span class="number">12</span></span><br></pre></td></tr></table></figure>



<h3 id="谈谈你对面向对象的理解"><a href="#谈谈你对面向对象的理解" class="headerlink" title="谈谈你对面向对象的理解"></a>谈谈你对面向对象的理解</h3><p>面向对象有三大特性：<code>封装</code>、<code>继承</code>、<code>多态</code>。</p>
<p>面向对象是相当于面向过程而言的，面向过程语言是一种基于功能分析的，以算法为中心的程序设计方法，而面向对象是一种基于结构分析的，以数据为中心的程序设计思想。在面向对象语言中有一个很重要的东西，叫做类。</p>
<blockquote>
<p>多态 :</p>
<ul>
<li>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，</li>
<li>这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</li>
</ul>
<p>对扩展开放：允许新增<code>Animal</code>子类；</p>
<p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p>
</blockquote>
<h3 id="面向对象中怎么实现只读属性"><a href="#面向对象中怎么实现只读属性" class="headerlink" title="面向对象中怎么实现只读属性"></a>面向对象中怎么实现只读属性</h3><ul>
<li>添加单个或两个下划线,将对象私有化</li>
<li>使用特性,或者使用描述符</li>
</ul>
<h3 id="函数调用参数的传递方式是值传递还是引用传递"><a href="#函数调用参数的传递方式是值传递还是引用传递" class="headerlink" title="函数调用参数的传递方式是值传递还是引用传递"></a>函数调用参数的传递方式是值传递还是引用传递</h3><ul>
<li>不可变参数用值传递：像整数和字符串这样的不可变对象，是通过拷贝进行传递的，<strong>因为你无论如何都不可能在原处改变不可变对象</strong>。 </li>
<li>可变参数是引用传递：比如像列表，字典这样的对象是通过引用传递。</li>
</ul>
<h3 id="多线程交互访问数据，如果访问到了就不访问了？"><a href="#多线程交互访问数据，如果访问到了就不访问了？" class="headerlink" title="多线程交互访问数据，如果访问到了就不访问了？"></a>多线程交互访问数据，如果访问到了就不访问了？</h3><p>怎么避免重读？</p>
<p>创建一个<strong>已访问数据列表，用于存储已经访问过的数据</strong>，并加上互斥锁，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。</p>
<h3 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h3><ul>
<li>开放寻址</li>
<li>拉链法</li>
</ul>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>尾递归，比线性递归多一个参数，这个参数是上一次调用函数得到的结果；<br>所以，关键点在于，尾递归每次调用都在收集结果，避免了线性递归不收集结果只能依次展开消耗内存的坏处。</p>
<h3 id="python闭包的延迟绑定"><a href="#python闭包的延迟绑定" class="headerlink" title="python闭包的延迟绑定"></a>python闭包的延迟绑定</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multipliers</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">lambda</span> x: i *x <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"><span class="built_in">print</span>([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multipliers()])  <span class="comment"># [6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure>

<p>内部函数被调用时，参数的值在闭包内进行查找。因此，当任何由multipliers()返回的函数被调用时,i的值将在附近的范围进行查找。那时，不管返回的函数是否被调用，for循环已经完成，i被赋予了最终的值3.</p>
<p>解决方式:<br>使用生成器,每次返回一个新的lambda表达式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multipliers</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">lambda</span> x: i *x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multipliers()])   <span class="comment"># [0, 2, 4, 6]</span></span><br></pre></td></tr></table></figure>



<h3 id="python-asyncio的原理"><a href="#python-asyncio的原理" class="headerlink" title="python asyncio的原理"></a>python asyncio的原理</h3><ul>
<li>使用python的yield这个可以打断保存当前函数的上下文的机制，</li>
<li> 封装好了 selector 摆脱掉了复杂的回调关系</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>在遍历时寻找最大的值，并在完成遍历后，将其放置在正确的位置。</p>
<p>遍历，每次取最高项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="comment"># 注意这里range需要倒置</span></span><br><span class="line">    <span class="keyword">for</span> idx1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        max_idx = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意这里从1开始到idx1(含)</span></span><br><span class="line">        <span class="keyword">for</span> idx2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,idx1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[max_idx] &lt; arr[idx2]:</span><br><span class="line">                max_idx = idx2</span><br><span class="line">        arr[max_idx],arr[idx2] = arr[idx2],arr[max_idx]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    testlist = [<span class="number">17</span>, <span class="number">23</span>, <span class="number">20</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">81</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">    <span class="built_in">print</span>(selection_sort(testlist))</span><br></pre></td></tr></table></figure>

<p>选择排序不稳定</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序选择一个值来拆分列表，该值称为枢轴值。</p>
<blockquote>
<p>注意：枢轴值属于最终排序列表（通常称为拆分点）的实际位置。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">array</span>):</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(array) &lt; <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> array</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		pivot = array[<span class="number">0</span>]</span><br><span class="line">		less    = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">		greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> quick_sort(less) + [pivot] + quick_sort(greater)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(quick_sort([<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>]))</span><br></pre></td></tr></table></figure>

<p>注意这里的len(array)可能等于0,可能等于1</p>
<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(alist) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = alist[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(alist) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> alist[right] &gt; pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            alist[left] = alist[right]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> alist[left] &lt;= pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            alist[right] = alist[left]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quick_sort(alist[:left]) + [pivot] + quick_sort(alist[left+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(quick_sort(alist))</span><br></pre></td></tr></table></figure>

<p>快速排序不稳定</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">	<span class="keyword">for</span> idx1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">for</span> idx2 <span class="keyword">in</span> <span class="built_in">range</span>(idx1):</span><br><span class="line">			<span class="keyword">if</span> alist[idx1] &lt; alist[idx2]:</span><br><span class="line">				alist[idx1],alist[idx2] = alist[idx2],alist[idx1]</span><br><span class="line">	<span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(bubble_sort(alist))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这里的两个for.第一个for是倒置的range</p>
</blockquote>
<p>短冒泡排序:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">short_bubble_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">	idx1 = <span class="built_in">len</span>(alist) -<span class="number">1</span></span><br><span class="line">	exchange = <span class="literal">True</span></span><br><span class="line">	<span class="keyword">while</span> idx1 != <span class="number">0</span> <span class="keyword">and</span> exchange:</span><br><span class="line">		exchange = <span class="literal">False</span></span><br><span class="line">		<span class="keyword">for</span> idx2 <span class="keyword">in</span> <span class="built_in">range</span>(idx1):</span><br><span class="line">			<span class="keyword">if</span> alist[idx2] &gt; alist[idx2+<span class="number">1</span>]:</span><br><span class="line">				exchange = <span class="literal">True</span></span><br><span class="line">				alist[idx2],alist[idx2+<span class="number">1</span>] = alist[idx2+<span class="number">1</span>],alist[idx2]</span><br><span class="line">		idx1 -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> alist</span><br><span class="line">	</span><br><span class="line">alist = [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(short_bubble_sort(alist))</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">short_bubble_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">for</span> idx1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx2 <span class="keyword">in</span> <span class="built_in">range</span>(idx1):</span><br><span class="line">            <span class="keyword">if</span> alist[idx1] &lt; alist[idx2]:</span><br><span class="line">                alist[idx1],alist[idx2] = alist[idx2],alist[idx1]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果alist是已经排序完成的话，就不会进行下一次遍历，可以直接退出了。</p>
</blockquote>
<p>冒泡排序稳定</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(alist)):</span><br><span class="line">        <span class="keyword">while</span> alist[idx-<span class="number">1</span>] &gt; alist[idx] <span class="keyword">and</span> idx != <span class="number">0</span>:</span><br><span class="line">            alist[idx-<span class="number">1</span>],alist[idx] = alist[idx],alist[idx-<span class="number">1</span>]</span><br><span class="line">            idx -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">31</span>,<span class="number">20</span>]</span><br><span class="line"><span class="built_in">print</span>(insertion_sort(alist))</span><br></pre></td></tr></table></figure>

<p>插入排序稳定</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>(递减递增排序)(分组插入排序)</p>
<p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">core</span>(<span class="params">alist,gap</span>):</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(gap,<span class="built_in">len</span>(alist),gap):</span><br><span class="line">            <span class="keyword">while</span> idx - gap &gt;= <span class="number">0</span> <span class="keyword">and</span> alist[idx-gap] &gt; alist[idx]:</span><br><span class="line">                alist[idx-gap],alist[idx] = alist[idx],alist[idx-gap]</span><br><span class="line">                idx -= gap</span><br><span class="line"></span><br><span class="line">    leng = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="keyword">while</span> leng != <span class="number">1</span>:</span><br><span class="line">        leng //= <span class="number">2</span></span><br><span class="line">        core(alist,leng)</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">444</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(shell_sort(alist))</span><br></pre></td></tr></table></figure>

<p>希尔排序不稳定</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是一种递归算法，将数据进行两两分组，每组之间进行排序，每小组排序完成后，再见这些有序的小组之间进行合并排序，知道最后合并完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(alist) &gt; <span class="number">1</span>:</span><br><span class="line">		mid = <span class="built_in">len</span>(alist) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">		left = alist[:mid]</span><br><span class="line">		right = alist[mid:]</span><br><span class="line"></span><br><span class="line">		merge_sort(left)</span><br><span class="line">		merge_sort(right)</span><br><span class="line"></span><br><span class="line">		i,j,k = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">			<span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">				alist[k] = left[i]</span><br><span class="line">				i += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				alist[k] = right[j]</span><br><span class="line">				j += <span class="number">1</span></span><br><span class="line">			k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left):</span><br><span class="line">			alist[k] = left[i]</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">			alist[k] = right[j]</span><br><span class="line">			j += <span class="number">1</span></span><br><span class="line">			k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">444</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(merge_sort(alist))</span><br></pre></td></tr></table></figure>

<p>上面代码有三个while，第一个while处理了90%的工作，但是把alist的最后一个元素弄丢了。所以需要后面两个while来处理。（两个while只会触发一个）</p>
<blockquote>
<p>较好理解版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guibing</span>(<span class="params">alist</span>):</span></span><br><span class="line">    lenght = <span class="built_in">len</span>(alist) </span><br><span class="line">    <span class="keyword">if</span> lenght &gt; <span class="number">1</span>:</span><br><span class="line">        left_list = guibing(alist[:lenght//<span class="number">2</span>])</span><br><span class="line">        right_list = guibing(alist[lenght//<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        idx, left_idx, right_idx = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left_idx &lt; <span class="built_in">len</span>(left_list) <span class="keyword">and</span> right_idx &lt; <span class="built_in">len</span>(right_list):</span><br><span class="line">            <span class="keyword">if</span> left_list[left_idx] &lt; right_list[right_idx]:</span><br><span class="line">                alist[idx] = left_list[left_idx]</span><br><span class="line">                left_idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                alist[idx] = right_list[right_idx]</span><br><span class="line">                right_idx += <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left_idx &lt; <span class="built_in">len</span>(left_list):</span><br><span class="line">            alist[idx] = left_list[left_idx]</span><br><span class="line">            left_idx += <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right_idx &lt; <span class="built_in">len</span>(right_list):</span><br><span class="line">            alist[idx] = right_list[right_idx]</span><br><span class="line">            right_idx += <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(guibing(alist))</span><br></pre></td></tr></table></figure>
</blockquote>
<p>归并排序稳定</p>
<h3 id="利用headqp模块实现堆排序"><a href="#利用headqp模块实现堆排序" class="headerlink" title="利用headqp模块实现堆排序"></a>利用headqp模块实现堆排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> alist:</span><br><span class="line">        heapq.heappush(h,val)</span><br><span class="line">    <span class="keyword">return</span> [heapq.heappop(h) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(h))]</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(heap_sort(x))  <span class="comment"># [1, 2, 3, 6, 7, 8, 9, 9, 9, 9, 9, 45]</span></span><br></pre></td></tr></table></figure>



<h3 id="冒泡排序的基本思想"><a href="#冒泡排序的基本思想" class="headerlink" title="冒泡排序的基本思想"></a>冒泡排序的基本思想</h3><p>对所有相邻记录的关键字值进行比效，如果是逆顺（a[j]&gt;a[j+1]），则将其交换，最终达到有序化;</p>
<h3 id="快速排序的基本思想"><a href="#快速排序的基本思想" class="headerlink" title="快速排序的基本思想"></a>快速排序的基本思想</h3><p>分治法</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>顾名思义,就是按顺序的查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squential_search</span>(<span class="params">alist,item</span>):</span></span><br><span class="line">	idx = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(alist):</span><br><span class="line">		<span class="keyword">if</span> alist[idx] != item:</span><br><span class="line">			idx += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> idx</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">	item = <span class="number">2</span></span><br><span class="line">	<span class="built_in">print</span>(squential_search(alist,item))</span><br></pre></td></tr></table></figure>



<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">alist,item</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(alist)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> alist[mid] &gt; item:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> alist[mid] &lt; item:</span><br><span class="line">            left = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">    item = <span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search(alist,item))</span><br><span class="line"></span><br><span class="line">    alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">    item = <span class="number">5</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search(alist,item))</span><br></pre></td></tr></table></figure>

<ol>
<li>使用==high=mid,low=mid+1==,这样<strong>while low&lt;high退出的时机一定是low=high</strong>.不要再使用high=mid-1,low=mid+1,这样很不好控制.</li>
<li>==使用左闭右开的区间==用于查找.这样的好处是，<strong>当while loop终止时</strong>(提前break出来的不算)，left、right、mid三个索引取值全相同</li>
<li>使用==mid = low + (high - low) // 2==,这样就保证了left、right一致.</li>
</ol>
<p>递归版:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">alist,item</span>):</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(alist) == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">	mid = <span class="built_in">len</span>(alist) // <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> alist[mid] == item:</span><br><span class="line">		<span class="keyword">return</span> mid</span><br><span class="line">	<span class="keyword">elif</span> alist[mid] &gt; item:</span><br><span class="line">		<span class="keyword">return</span> binary_search(alist[:mid],item)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> mid + <span class="number">1</span> + binary_search(alist[mid + <span class="number">1</span>:],item)</span><br><span class="line">    		</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">    item = <span class="number">11</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search(alist,item))</span><br><span class="line"></span><br><span class="line">    alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">    item = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(binary_search(alist,item))</span><br></pre></td></tr></table></figure>







<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ol>
<li><p>使用递归的思路:</p>
<blockquote>
<ol>
<li>找出简单的基线条件</li>
<li>每次递归都必须缩小问题的规模，<strong>使其符合基线条件</strong></li>
<li>假设递归可用</li>
</ol>
</blockquote>
</li>
<li><p>有1680*640的矩形，要将矩形均匀分成正方形，且正方形尽可能大，求分割方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a,b</span>):</span></span><br><span class="line">	lenght = <span class="built_in">max</span>(a,b)</span><br><span class="line">	width = <span class="built_in">min</span>(a,b)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> lenght % width == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> width</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		lenght -= width</span><br><span class="line">		<span class="keyword">return</span> func(lenght,width)</span><br><span class="line"></span><br><span class="line">a = <span class="number">1680</span></span><br><span class="line">b = <span class="number">640</span></span><br><span class="line"><span class="built_in">print</span>(func(a,b))</span><br></pre></td></tr></table></figure></li>
<li><p>碾平列表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flat</span>(<span class="params">alist</span>):</span></span><br><span class="line">	x = []</span><br><span class="line">	<span class="keyword">for</span> each <span class="keyword">in</span> alist:</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(each,<span class="built_in">list</span>):</span><br><span class="line">			x.append(each)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			x.extend(flat(each))</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,[<span class="number">9</span>,<span class="number">10</span>,[<span class="number">11</span>]]]]]</span><br><span class="line"><span class="built_in">print</span>(flat(a))</span><br></pre></td></tr></table></figure>

<p>注意,这使用list的做法可以总结出<code>获取递归数据列表</code>的方法</p>
</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol>
<li><p>散列表性能决定因素:</p>
<blockquote>
<ol>
<li>较低的填装因子</li>
<li>良好的散列函数</li>
</ol>
</blockquote>
<blockquote>
<p>所谓的填装因子，其实就是数据的密度</p>
</blockquote>
<p>在调整长度之后，所有的元素都要重新插入到新的散列表中</p>
</li>
<li><p>广度优先搜索回答两种问题：</p>
<blockquote>
<ol>
<li>从节点A出发，有前往节点B的路径吗？</li>
<li>从节点A出发，前往节点B的哪条路径最短？</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="模拟树"><a href="#模拟树" class="headerlink" title="模拟树"></a>模拟树</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,rootval</span>):</span></span><br><span class="line">        self.root = rootval</span><br><span class="line">        self.left == <span class="literal">None</span></span><br><span class="line">        self.right == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_left</span>(<span class="params">self,new_node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.left:</span><br><span class="line">            self.left = BinaryTree(new_node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tree = BinaryTree(new_node)</span><br><span class="line">            tree.left = self.left</span><br><span class="line">            self.left = tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_right</span>(<span class="params">self,new_node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.right:</span><br><span class="line">            self.right = BinaryTree(new_node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tree = BinaryTree(new_node)</span><br><span class="line">            tree.right = self.right</span><br><span class="line">            self.right = tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_right</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.right</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_left</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_root_val</span>(<span class="params">self,rootval</span>):</span></span><br><span class="line">        self.root = rootval</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_root_val</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.root</span><br></pre></td></tr></table></figure>

<h4 id="树的构建"><a href="#树的构建" class="headerlink" title="树的构建"></a>树的构建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> digits</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul,add,isub,itruediv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</span><br><span class="line"><span class="keyword">from</span> pythonds.trees.binaryTree <span class="keyword">import</span> BinaryTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_parse_tree</span>(<span class="params">exp</span>):</span></span><br><span class="line">    exp_list = exp.split()</span><br><span class="line">    stack = Stack()</span><br><span class="line">    root_tree = BinaryTree(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    stack.push(root_tree)</span><br><span class="line">    current_tree = root_tree</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> exp_list:</span><br><span class="line">        <span class="keyword">if</span> char == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            current_tree.insertLeft(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            stack.push(current_tree)</span><br><span class="line">            current_tree = current_tree.getLeftChild()</span><br><span class="line">        <span class="keyword">elif</span> char <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;*&#x27;</span>]:</span><br><span class="line">            current_tree.setRootVal(char)</span><br><span class="line">            current_tree.insertRight(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            stack.push(current_tree)</span><br><span class="line">            current_tree = current_tree.getRightChild()</span><br><span class="line">        <span class="keyword">elif</span> char <span class="keyword">in</span> digits:</span><br><span class="line">            current_tree.setRootVal(<span class="built_in">int</span>(char))</span><br><span class="line">            parent = stack.pop()</span><br><span class="line">            current_tree = parent</span><br><span class="line">        <span class="keyword">elif</span> char == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            current_tree = stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line">    <span class="keyword">return</span> root_tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse2int</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">tree</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> tree.getLeftChild()) <span class="keyword">and</span> (<span class="keyword">not</span> tree.getRightChild()):</span><br><span class="line">            <span class="keyword">yield</span> tree.getRootVal()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> back(tree.getLeftChild())</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> back(tree.getRightChild())</span><br><span class="line">            <span class="keyword">yield</span> tree.getRootVal()</span><br><span class="line"></span><br><span class="line">    mapping = &#123;<span class="string">&#x27;+&#x27;</span>:add,<span class="string">&#x27;-&#x27;</span>:isub,<span class="string">&#x27;*&#x27;</span>:mul,<span class="string">&#x27;/&#x27;</span>:itruediv&#125;</span><br><span class="line">    stack = Stack()</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> back(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>(char) <span class="keyword">in</span> digits:</span><br><span class="line">            stack.push(char)</span><br><span class="line">        <span class="keyword">elif</span> char <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;*&#x27;</span>]:</span><br><span class="line">            num1 = stack.pop()</span><br><span class="line">            num2 = stack.pop()</span><br><span class="line">            stack.push(mapping[char](<span class="built_in">int</span>(num2),<span class="built_in">int</span>(num1)))</span><br><span class="line">    <span class="keyword">return</span> stack.pop()</span><br><span class="line"></span><br><span class="line">root_tree = build_parse_tree(<span class="string">&#x27;( 3 + ( 4 * 5 ) )&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(root_tree)</span><br><span class="line"><span class="comment"># &lt;pythonds.trees.binaryTree.BinaryTree object at 0x000002B90CE3AFD0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(parse2int(root_tree))</span><br><span class="line"><span class="comment"># 23</span></span><br></pre></td></tr></table></figure>



<h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">front</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> tree.getLeftChild()) <span class="keyword">and</span> (<span class="keyword">not</span> tree.getRightChild()):</span><br><span class="line">        <span class="keyword">yield</span> tree.getRootVal()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">yield</span> tree.getRootVal()</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> front(tree.getLeftChild())</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> front(tree.getRightChild())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">middle</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> tree.getLeftChild()) <span class="keyword">and</span> (<span class="keyword">not</span> tree.getRightChild()):</span><br><span class="line">        <span class="keyword">yield</span> tree.getRootVal()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> middle(tree.getLeftChild())</span><br><span class="line">        <span class="keyword">yield</span> tree.getRootVal()</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> middle(tree.getRightChild())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">tree</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> tree.getLeftChild()) <span class="keyword">and</span> (<span class="keyword">not</span> tree.getRightChild()):</span><br><span class="line">        <span class="keyword">yield</span> tree.getRootVal()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> back(tree.getLeftChild())</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> back(tree.getRightChild())</span><br><span class="line">        <span class="keyword">yield</span> tree.getRootVal()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> back(root_tree):</span><br><span class="line">	<span class="built_in">print</span>(node)</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">front</span>(<span class="params">tree</span>):</span></span><br><span class="line">	<span class="keyword">if</span> tree:</span><br><span class="line">		<span class="built_in">print</span>(tree.getRootVal())</span><br><span class="line">		front(tree.getLeftChild())</span><br><span class="line">		front(tree.getRightChild())</span><br></pre></td></tr></table></figure>



<h4 id="完整二叉树"><a href="#完整二叉树" class="headerlink" title="完整二叉树"></a>完整二叉树</h4><p>父节点的左子节点（在位置p处）(从1开始)是在列表中位置2p中找到的节点。<br>父节点的右子节点在列表中的位置2p+1.</p>
<blockquote>
<p>所以 idx // 2 即为父节点的位置</p>
</blockquote>
<h4 id="最小二叉堆"><a href="#最小二叉堆" class="headerlink" title="最小二叉堆"></a>最小二叉堆</h4><blockquote>
<p>利用性质 :</p>
<ul>
<li>父节点的左子节点（在位置p处）是在列表中位置2p中找到的节点。</li>
<li>父节点的右子节点在列表中的位置2p+1。</li>
</ul>
</blockquote>
<blockquote>
<p>在堆中，对于父p的每个节点x，<strong>p中的键小于或等于x中的键</strong>。</p>
<p>得出:</p>
<ul>
<li>二叉堆insert需要实现的逻辑 ：<br>比较新添加的项与其父项，如果新添加的项小于其父项，则将项与其父项交换。</li>
<li>delMin弹出根节点 : <ol>
<li>将列表中的最后一个项移动到根位置来恢复根项，保持我们的堆结构属性</li>
<li>我们通过将新的根节点沿着树向下推到其正确位置来恢复堆顺序属性。</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 使用列表来模拟二叉堆</span></span><br><span class="line">        <span class="comment"># 堆的运算从1开始.所以添加一个[0],方便以后使用整数除法</span></span><br><span class="line">        self.heap_list = [<span class="number">0</span>]</span><br><span class="line">        self.current_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_child2parent</span>(<span class="params">self,idx</span>):</span></span><br><span class="line">        <span class="comment"># idx表示当前待移动节点的索引</span></span><br><span class="line">        <span class="keyword">while</span> idx &gt; <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果子节点的值小于父节点的值</span></span><br><span class="line">            <span class="keyword">if</span> self.heap_list[idx] &lt; self.heap_list[idx//<span class="number">2</span>]:</span><br><span class="line">                <span class="comment"># 交换子节点和父节点的值</span></span><br><span class="line">                self.heap_list[idx],self.heap_list[idx//<span class="number">2</span>] = self.heap_list[idx//<span class="number">2</span>],self.heap_list[idx]</span><br><span class="line">            idx //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 比较新添加的项和父项,如果新添加的项小于父项,则将该项和父项交换</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,val</span>):</span></span><br><span class="line">        <span class="comment"># 先在列表的最后添加</span></span><br><span class="line">        self.heap_list.append(val)</span><br><span class="line">        self.current_size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 然后再移动位置</span></span><br><span class="line">        self.change_child2parent(self.current_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回 min(节点的右孩子,左孩子)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_min_idx</span>(<span class="params">self,idx</span>):</span></span><br><span class="line">        <span class="comment"># 堆是从左向右排序,左孩子一定有,右孩子不一定有</span></span><br><span class="line">        <span class="comment"># 外层的if用来保证内层的的self.heap_list[2*idx+1]不会出错</span></span><br><span class="line">        <span class="keyword">if</span>  self.current_size &lt; <span class="number">2</span> * idx + <span class="number">1</span>:</span><br><span class="line">            min_idx = <span class="number">2</span> * idx</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.heap_list[<span class="number">2</span>*idx] &gt; self.heap_list[<span class="number">2</span>*idx+<span class="number">1</span>]:</span><br><span class="line">                min_idx = <span class="number">2</span> * idx + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                min_idx = <span class="number">2</span> * idx           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_parent2child</span>(<span class="params">self,idx</span>):</span></span><br><span class="line">        <span class="comment"># idx代表了刚从最后一层提到第一层的元素</span></span><br><span class="line">        <span class="comment"># idx = min_idx不断获取子节点</span></span><br><span class="line">        <span class="comment"># while保证了self.heap_list[idx*2]不会出错</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">2</span> * idx &lt;= self.current_size:</span><br><span class="line">            <span class="comment"># 获取当前节点的最小的孩子</span></span><br><span class="line">            min_idx = self.get_min_idx(idx)</span><br><span class="line">            <span class="comment"># 如果节点的值大于孩子的值</span></span><br><span class="line">            <span class="keyword">if</span> self.heap_list[idx] &gt; self.heap_list[min_idx]:</span><br><span class="line">                self.heap_list[idx],self.heap_list[min_idx] = self.heap_list[min_idx],self.heap_list[idx]</span><br><span class="line">            idx = min_idx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 首先返回第一个元素</span></span><br><span class="line">        return_val =  self.heap_list.pop(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 将最后一个元素移动到第一个位置</span></span><br><span class="line">        self.heap_list[<span class="number">1</span>] = self.heap_list.pop()</span><br><span class="line">        self.current_size -= <span class="number">1</span></span><br><span class="line">        self.change_parent2child(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> return_val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_from_list</span>(<span class="params">self,alist</span>):</span></span><br><span class="line">        self.current_size = <span class="built_in">len</span>(alist)</span><br><span class="line">        <span class="comment"># 因为是使用列表来模拟二叉堆.直接插入即可</span></span><br><span class="line">        self.heap_list = [<span class="number">0</span>] + alist[:]</span><br><span class="line">        <span class="comment"># i为最后一个有孩子的节点</span></span><br><span class="line">        i = <span class="built_in">len</span>(alist) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            self.change_parent2child(i)</span><br><span class="line">            i -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>二叉树创建堆的复杂度：O(n)<br>二叉树堆排序的复杂度：O(logN)</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>一种映射类型，能从键映射到值。二叉查找树也可以做到类似于map一样的映射功能。</p>
<blockquote>
<p>二叉搜索树:左子树的键小于父节点的键，并且在右子树的键大于父节点的键。</p>
</blockquote>
<blockquote>
<p>_put根据以下算法搜索树：</p>
<ol>
<li>从根节点开始，搜索二叉树，将新键与当前节点的键比较。若新键小于当前节点，则搜索左子树。若新键大于当前节点，则搜索右子树。</li>
<li>当没有左（或右）孩子时，我们在树中找到应该建立新节点的位置。</li>
<li>要向树中添加节点，请创建一个新的TreeNode对象，并将对象插入到上一步发现的节点。</li>
</ol>
</blockquote>
<blockquote>
<p>get:<br>递归地搜索树，直到它到达不匹配的叶节点或找到匹配的键。</p>
</blockquote>
<blockquote>
<p>delete:<br>第一个任务使用_get方法搜索以找到需要删除的TreeNode。如果未找到键，del操作符将引发错误</p>
<ol>
<li>待删除节点没有子节点 :<br>直接删除即可</li>
<li>待删除节点只有一个子节点 :<br>子取代父</li>
<li>待删除节点有两个子节点 :<ul>
<li>在树中搜索可用于替换被调度删除的节点的节点。这个节点称为后继节点（Successor）。是树中具有次最大键的节点。<br>  <code>后继结点：在二叉树中中序遍历的序列中，某个节点紧随的那个节点。</code></li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,key,val,left=<span class="literal">None</span>,right=<span class="literal">None</span>,parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.payload = val</span><br><span class="line">        self.left_child = left</span><br><span class="line">        self.right_child = right</span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_left_child</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.left_child</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_right_child</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.right_child</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_root</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_leaf</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (slef.left_child <span class="keyword">or</span> self.right_child)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_left_child</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.left_child == self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_right_child</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.parent <span class="keyword">and</span> self.parent.right_child == self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_any_children</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.right_child <span class="keyword">or</span> self.left_child</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_both_children</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.right_child <span class="keyword">and</span> self.left_child</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace_node_data</span>(<span class="params">self,key,val,left_child,right_child</span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.payload = val</span><br><span class="line"></span><br><span class="line">        self.left_child = left_child</span><br><span class="line">        self.right_child = right_child</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.has_left_child():</span><br><span class="line">            self.left_child.parent = self</span><br><span class="line">        <span class="keyword">if</span> self.has_right_child():</span><br><span class="line">            self.right_child.parent = self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_put</span>(<span class="params">self,key,val,current_node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> current_node.key &gt; key:</span><br><span class="line">            <span class="keyword">if</span> current_node.has_left_child():</span><br><span class="line">                self._put(key,val,current_node.left_child)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_node.left_child = TreeNode(key,val,parent=current_node)</span><br><span class="line">        <span class="keyword">elif</span> current_node.key == key:</span><br><span class="line">            current_node.payload = val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> current_node.has_right_child():</span><br><span class="line">                self._put(key,val,current_node.right_child)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_node.right_child = TreeNode(key,val,parent=current_node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self,key,val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">            self.root = TreeNode(key=key,val=val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._put(key,val,self.root)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get</span>(<span class="params">self,key,current_node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> current_node.key &gt; key:</span><br><span class="line">            <span class="keyword">if</span> current_node.has_left_child():</span><br><span class="line">                <span class="keyword">return</span> self._get(key,current_node.left_child)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> current_node.key &lt; key:</span><br><span class="line">            <span class="keyword">if</span> current_node.has_right_child():</span><br><span class="line">                <span class="keyword">return</span> self._get(key,current_node.right_child)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> current_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.root:</span><br><span class="line">            <span class="keyword">return</span> self._get(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用中序遍历yeild出所有节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minddle</span>(<span class="params">self,current_node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> current_node:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self.minddle(current_node.left_child)</span><br><span class="line">            <span class="keyword">yield</span> current_node</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> self.minddle(current_node.right_child)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找出后继</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_successor</span>(<span class="params">self,current_node</span>):</span></span><br><span class="line">        gen = self.minddle(self.root)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> gen:</span><br><span class="line">            <span class="keyword">if</span> node == current_node:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">next</span>(gen)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splice_out</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.is_leaf():</span><br><span class="line">            <span class="keyword">if</span> self.is_left_child():</span><br><span class="line">                self.parent.left_child = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.parent.right_child = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.has_any_children():</span><br><span class="line">            <span class="keyword">if</span> self.has_left_child():</span><br><span class="line">                <span class="keyword">if</span> self.is_left_child():</span><br><span class="line">                    self.parent.left_child = self.left_child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.parent.right_child = self.left_child</span><br><span class="line">                    self.left_child.parent = self.parent</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.is_left_child():</span><br><span class="line">                    self.parent.left_child = self.right_child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.parent.right_child = self.right_child</span><br><span class="line">                    self.right_child.parent = self.parent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        node = self.get(key)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">&#x27;404 not found&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 无子节点</span></span><br><span class="line">            <span class="keyword">if</span> node.is_leaf():</span><br><span class="line">                <span class="keyword">if</span> node.parent.left_child == node:</span><br><span class="line">                    node.parent.left_child == <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.parent.right_child == <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 拥有两个子节点</span></span><br><span class="line">            <span class="keyword">elif</span> node.has_both_children():</span><br><span class="line">                seccessor = self.find_successor(node)</span><br><span class="line">                self.splice_out(self)</span><br><span class="line">            <span class="comment"># 拥有一个子节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                son = node.left_child <span class="keyword">or</span> node.right_child</span><br><span class="line">                son.parent = node.parent</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.parent.left_child == node:</span><br><span class="line">                    node.parent.left_child = son</span><br><span class="line">                <span class="keyword">elif</span> node.parent.right_child == node:</span><br><span class="line">                    node.parent.right_child = son</span><br><span class="line">                <span class="comment"># 根节点</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.replace_node_data(son.key,payload,self.left_child,self.right_child,son.parent)</span><br><span class="line"></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self,key,val</span>):</span></span><br><span class="line">        self.put(k,v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.get(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.get(key):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><ul>
<li>广度优先搜索先从其他起始顶点开始添加它的所有子节点，然后再添加其子节点的子节点。</li>
<li>广度优先搜索算法就像在建一棵树，一次建一层。</li>
</ul>
<blockquote>
<ol>
<li>当图被构造时，所有顶点被初始化为白色。白色顶点是未发现的顶点。</li>
<li>当一个顶点最初被发现时它变成灰色的<br> (下次别的点搜索到这个点时，发现是灰色就说明已经被发现了，就不会再进行搜索了)，</li>
<li>当BFS完全探索完一个顶点时，它被染成黑色。这意味着一旦顶点变黑色，就没有与它相邻的白色顶点。另一方面，如果一个顶点被标识为了灰色，这就意味着其附近可能还存在着未探索的顶点(白色顶点)等待被探索。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">name</span>):</span></span><br><span class="line">    search_queue = deque()</span><br><span class="line">    search_queue += graph[name]</span><br><span class="line">    searched = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> search_queue:</span><br><span class="line">        person = search_queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line">            <span class="keyword">if</span> is_willing(person):</span><br><span class="line">                <span class="built_in">print</span>(person + <span class="string">&#x27;is willing&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                search_queue += graph[person]</span><br><span class="line">                searched.append(person)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p> <strong>search_queue对应灰色,searched对应黑色</strong></p>
</blockquote>
<blockquote>
<p>BFS算法使用Vertex类的扩展版本。这个新的顶点类添加了三个新的实例变量：</p>
<ul>
<li>distance（距离），</li>
<li>predecessor（前导）（父顶点）</li>
<li>color（颜色）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pythonds.graphs <span class="keyword">import</span> Graph,Vertex</span><br><span class="line"><span class="keyword">from</span> pythonds.basic <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">start</span>):</span></span><br><span class="line">	q = Queue()</span><br><span class="line">	start.setDistance(<span class="number">0</span>)</span><br><span class="line">	start.setPared(<span class="literal">None</span>)</span><br><span class="line">	q.enqueue(start)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> q.size() &gt; <span class="number">0</span>:</span><br><span class="line">		current_vert = q.dequeue()</span><br><span class="line">		<span class="keyword">for</span> nbr <span class="keyword">in</span> current_vert.getConnections():</span><br><span class="line">			<span class="keyword">if</span> nbr.getColor() == <span class="string">&#x27;white&#x27;</span>:</span><br><span class="line">				nbr.setColor(<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">				nbr.setDistance(current_vert.getDistance() +<span class="number">1</span> )</span><br><span class="line">				nbr.setPared(current_vert)</span><br><span class="line">				q.enqueue(nbr)</span><br><span class="line"></span><br><span class="line">		current_vert.setColor(<span class="string">&#x27;black&#x27;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="什么是MD5加密，有什么特点？"><a href="#什么是MD5加密，有什么特点？" class="headerlink" title="什么是MD5加密，有什么特点？"></a>什么是MD5加密，有什么特点？</h4><p>对输入信息生成唯一的128位散列值（32个字符）</p>
<ol>
<li>md5加密不可逆，所以它的安全度比较高</li>
<li>不管多大的字符串，它都能生成32位字符串</li>
</ol>
<h4 id="什么是对称加密和非对称加密"><a href="#什么是对称加密和非对称加密" class="headerlink" title="什么是对称加密和非对称加密"></a>什么是对称加密和非对称加密</h4><ol>
<li><p>加密和解密过程不同<br><strong>对称加密过程和解密过程使用的同一个密钥</strong>，加密过程相当于用原文+密钥可以传输出密文，同时解密过程用密文-密钥可以推导出原文。但非对称加密采用了两个密钥，一般使用公钥进行加密，使用私钥进行解密。</p>
</li>
<li><p>加密解密速度不同<br>对称加密解密的速度比较快，适合数据比较长时的使用。非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用。</p>
</li>
<li><p>传输的安全性不同对称加密的过程中无法确保密钥被安全传递，密文在传输过程中是可能被第三方截获的，如果密码本也被第三方截获，则传输的密码信息将被第三方破获，安全性相对较低。</p>
<p>非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。所以安全性较高。</p>
</li>
</ol>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>