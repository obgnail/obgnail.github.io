<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h2&gt;&lt;h3 id=&quot;介绍一下MongoDB&quot;&gt;&lt;a href=&quot;#介绍一下MongoDB&quot; class=&quot;headerlink&quot; title=&quot;介绍一下MongoDB&quot;&gt;&lt;/a&gt;介绍一下MongoDB&lt;/h3&gt;&lt;p&gt;MongoDB 是一个高性能，开源，无模式的&lt;code&gt;文档型数据库&lt;/code&gt;，开发语言是C++。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>面试问题总结5_数据库 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Interview/" rel="tag">Interview</a></div><div class="post-time">2019-08-15</div></div></div><div class="container post-header"><h1>面试问题总结5_数据库</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MongoDB"><span class="toc-number">1.</span> <span class="toc-text">MongoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BMongoDB"><span class="toc-number">1.1.</span> <span class="toc-text">介绍一下MongoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.2.</span> <span class="toc-text">基本术语</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-number">2.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE-%E8%B6%85%E9%94%AE-%E5%80%99%E9%80%89%E9%94%AE-%E5%A4%96%E9%94%AE"><span class="toc-number">2.1.</span> <span class="toc-text">主键 超键 候选键 外键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E4%B8%8E-InnoDB-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">MyISAM 与 InnoDB 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E5%8F%8A%E6%AF%94%E8%BE%83%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">MySQL常见数据库引擎及比较？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E6%80%8E%E4%B9%88%E9%99%90%E5%88%B6IP%E8%AE%BF%E9%97%AE"><span class="toc-number">2.4.</span> <span class="toc-text">Mysql怎么限制IP访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9FMySQL%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">什么是事务？MySQL如何支持事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.6.</span> <span class="toc-text">事务的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text">数据库三范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%94%E5%A4%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.8.</span> <span class="toc-text">数据库五大约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">简述触发器、函数、视图、存储过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E8%A7%86%E5%9B%BE%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E4%B9%88"><span class="toc-number">2.10.</span> <span class="toc-text">视图的作用，视图可以更改么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E7%A7%8D%E7%B1%BB"><span class="toc-number">2.11.</span> <span class="toc-text">MySQL索引种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%81%B5%E5%BE%AA%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">索引在什么情况下遵循最左前缀的规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E4%B8%BE%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E4%BD%86%E6%98%AF%E6%97%A0%E6%B3%95%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%848%E7%A7%8D%E6%83%85%E5%86%B5%E3%80%82"><span class="toc-number">2.13.</span> <span class="toc-text">列举创建索引但是无法命中索引的8种情况。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drop-delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.14.</span> <span class="toc-text">drop,delete与truncate的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%95%86%E5%9F%8E%E5%95%86%E5%93%81%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">如何基于数据库实现商城商品计数器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.16.</span> <span class="toc-text">简述乐观锁和悲观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">3.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BRedis"><span class="toc-number">3.1.</span> <span class="toc-text">介绍一下Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">Redis五大数据类型</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="介绍一下MongoDB"><a href="#介绍一下MongoDB" class="headerlink" title="介绍一下MongoDB"></a>介绍一下MongoDB</h3><p>MongoDB 是一个高性能，开源，无模式的<code>文档型数据库</code>，开发语言是C++。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式。</p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><table>
<thead>
<tr>
<th>SQL术语</th>
<th>MongoDB术语</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collecion</td>
<td>数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段/域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table joins</td>
<td></td>
<td>表连接MongoDB不支持</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键,MongoDB自动将_id设置为主键</td>
</tr>
</tbody></table>
<p>将文档类比成数据库中的行，那么集合就可以类比成数据库的表</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="主键-超键-候选键-外键"><a href="#主键-超键-候选键-外键" class="headerlink" title="主键 超键 候选键 外键"></a>主键 超键 候选键 外键</h3><p>主键：数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值(Null).</p>
<blockquote>
<p>主键 : 表中每一行中可以唯一标识自己的一列（或一组列）。</p>
</blockquote>
<p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p>
<p>候选键：是最小超键，即没有冗余元素的超键。</p>
<p>外键：在一个表中存在的另一个表的主键称此表的外键。</p>
<h3 id="MyISAM-与-InnoDB-区别"><a href="#MyISAM-与-InnoDB-区别" class="headerlink" title="MyISAM 与 InnoDB 区别"></a>MyISAM 与 InnoDB 区别</h3><ol>
<li><strong>InnoDB 支持事务</strong>，MyISAM 不支持，这一点是非常之重要。</li>
<li>MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用；</li>
<li>InnoDB 支持外键，MyISAM 不支持；</li>
<li>对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM表中可以和其他字段一起建立联合索引；</li>
<li>清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重建表；</li>
</ol>
<h3 id="MySQL常见数据库引擎及比较？"><a href="#MySQL常见数据库引擎及比较？" class="headerlink" title="MySQL常见数据库引擎及比较？"></a>MySQL常见数据库引擎及比较？</h3><ul>
<li>InnoDB<br>支持事务、支持表锁、行锁（for update）<br>表锁：select * from tb for update<br>行锁：select id,name from tb where id=2 for update</li>
<li>MyISAM<br>查询速度快、全文索引、支持表锁<br>表锁：select * from tb for update</li>
<li>NDB<br>高可用、 高性能、高可扩展性的数据库集群系统</li>
<li>Memory<br>默认使用的是哈希索引</li>
</ul>
<h3 id="Mysql怎么限制IP访问"><a href="#Mysql怎么限制IP访问" class="headerlink" title="Mysql怎么限制IP访问"></a>Mysql怎么限制IP访问</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on . to &quot;数据库中用户名“ @&quot;ip地址&quot; identified by &quot;数据库密码&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="什么是事务？MySQL如何支持事务？"><a href="#什么是事务？MySQL如何支持事务？" class="headerlink" title="什么是事务？MySQL如何支持事务？"></a>什么是事务？MySQL如何支持事务？</h3><p>数据库事务 ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</p>
<p>Mysql实现事务<br>InnoDB支持事务，MyISAM不支持</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># start transaction 手动开启事务</span><br><span class="line"># commit 手动关闭事务</span><br><span class="line"></span><br><span class="line">start transaction；</span><br><span class="line">update from account set money=money-100 where name=&#x27;a&#x27;;</span><br><span class="line">update from account set money=money+100 where name=&#x27;b&#x27;;</span><br><span class="line">commit；</span><br></pre></td></tr></table></figure>



<h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ol>
<li>原子性<br>事务中的全部操作在数据库中是不分隔的，要么全部完成，要么均不执行</li>
<li>隔离型<br>事务的执行不受其他事务的干扰。</li>
<li>持久性<br>一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li>
<li>一致性<br>事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是<strong>数据库中的数据应满足完整性约束</strong>。</li>
</ol>
<h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><ol>
<li>第一范式，基本上所有数据库的范式都是符合第一范式的，符合第一范式的表具有以下几个特点：<br><strong>数据库表中的所有字段都只具有单一属性</strong>，单一属性的列是由基本的数据类型（整型，浮点型，字符型等）所构成的设计出来的表都是简单的二比表</li>
<li>第二范式，要求一个表中<strong>只具有一个业务主键</strong>，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系</li>
<li>第三范式，指每一个非主属性既不部分依赖与也不传递依赖于业务主键，也就是第二范式的基础上<strong>消除了非主属性对主键的传递依赖</strong></li>
</ol>
<ol>
<li>每列保持原子性</li>
<li>表中的每列都是和主键相关</li>
<li>每列都和主键直接相关，而不是间接相关</li>
</ol>
<h3 id="数据库五大约束"><a href="#数据库五大约束" class="headerlink" title="数据库五大约束"></a>数据库五大约束</h3><ol>
<li><p>primary key：设置主键约束；</p>
</li>
<li><p>unique：设置唯一性约束，不能有重复值；</p>
</li>
<li><p>default：默认值约束 </p>
</li>
<li><p>not null：设置非空约束，该字段不能为空；</p>
</li>
<li><p>foreign key：设置外键约束。</p>
</li>
</ol>
<h3 id="简述触发器、函数、视图、存储过程？"><a href="#简述触发器、函数、视图、存储过程？" class="headerlink" title="简述触发器、函数、视图、存储过程？"></a>简述触发器、函数、视图、存储过程？</h3><ul>
<li><p>触发器：<br>对数据库某张表的<code>增加</code>、<code>删除</code>，<code>修改</code>前后定义一些操作</p>
</li>
<li><p>函数：(触发函数是通过select)<br>聚合函数：max/sum/min/avg<br>时间格式化：date_format<br>字符串拼接：concat</p>
</li>
<li><p>存储过程：</p>
<ul>
<li>一组为了完成特定功能的SQL语句集，<strong>经编译后</strong>存储在数据库。</li>
<li>用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</li>
<li>存储过程在创建时即在服务器上进行编译，所以执行起来比单个SQL语句快，因为调用存储过程比直接向服务端发送大量SQL语句在执行速度快。</li>
<li> 参数类型：</li>
</ul>
<ol>
<li>in    只将参数传进去</li>
<li>out   只拿结果</li>
<li>inout 既可以传，可以取</li>
</ol>
</li>
<li><p>函数与存储过程区别：本质上没区别。</p>
<ul>
<li>函数只能返回一个变量。而存储过程可以返回多个。</li>
<li>函数是可以嵌入在sql中使用的,可以在select中调用，而存储过程不行。</li>
<li>存储过程可以调用函数。但函数不能调用存储过程。</li>
</ul>
</li>
<li><p>视图：<br>视图是一个虚拟表，不是真实存在的（只能查，不能改）</p>
</li>
</ul>
<h3 id="视图的作用，视图可以更改么"><a href="#视图的作用，视图可以更改么" class="headerlink" title="视图的作用，视图可以更改么"></a>视图的作用，视图可以更改么</h3><ul>
<li>视图是虚拟的表，视图只包含使用时动态检索数据的查询;<strong>不包含任何列或数据</strong>。</li>
<li>使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据;</li>
<li>视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</li>
</ul>
<h3 id="MySQL索引种类"><a href="#MySQL索引种类" class="headerlink" title="MySQL索引种类"></a>MySQL索引种类</h3><ol>
<li>普通索引 : 加速查找</li>
<li>唯一索引 : 加速查找 + 约束(不能重复)</li>
<li>主键索引 : 加速查找 + 约束(不能重复 +  不能为空)</li>
<li>组合索引 : 多个列创建索引</li>
<li>全文索引 : 查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎</li>
</ol>
<h3 id="索引在什么情况下遵循最左前缀的规则？"><a href="#索引在什么情况下遵循最左前缀的规则？" class="headerlink" title="索引在什么情况下遵循最左前缀的规则？"></a>索引在什么情况下遵循最左前缀的规则？</h3><p>组合索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</span><br></pre></td></tr></table></figure>

<p>最左前缀：顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了<code>(lname)</code>单列索引，<code>(lname,fname)</code>组合索引以及<code>(lname,fname,age)</code>组合索引。</p>
<p>所以在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</p>
<h3 id="列举创建索引但是无法命中索引的8种情况。"><a href="#列举创建索引但是无法命中索引的8种情况。" class="headerlink" title="列举创建索引但是无法命中索引的8种情况。"></a>列举创建索引但是无法命中索引的8种情况。</h3><ul>
<li><p>like ‘%xx’</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where name like &#x27;%cn&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用函数</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where reverse(name) = &#x27;wupeiqi&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>or</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where nid = 1 or email = &#x27;seven@live.com&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别的：当or条件中有未建立索引的列才失效，以下会走索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where nid = 1 or name = &#x27;seven&#x27;;</span><br><span class="line">select * from tb1 where nid = 1 or email = &#x27;seven@live.com&#x27; and name = &#x27;alex&#x27;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>类型不一致<br>  如果列是字符串类型，传入条件是必须用引号引起来，不然…</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where name = 999;</span><br></pre></td></tr></table></figure></li>
<li><p>!=</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where name != &#x27;alex&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别的：如果是主键，则还是会走索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where nid != 123</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>&gt;</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where name &gt; &#x27;alex&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别的：如果是主键或索引是整数类型，则还是会走索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where nid &gt; 123</span><br><span class="line">select * from tb1 where num &gt; 123</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>order by</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select email from tb1 order by name desc;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别的：当根据索引排序时候，选择的映射如果不是索引，则不走索引<br>特别的：如果对主键排序，则还是走索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 order by nid desc;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h3><ul>
<li>drop直接删掉表，</li>
<li>truncate删除表中数据，再插入时自增长id又从1开始，</li>
<li>delete删除表中数据，可以加where字句。</li>
</ul>
<h3 id="如何基于数据库实现商城商品计数器？"><a href="#如何基于数据库实现商城商品计数器？" class="headerlink" title="如何基于数据库实现商城商品计数器？"></a>如何基于数据库实现商城商品计数器？</h3><p>假设有一个计数器表，只有一行数据，记录网站的点击次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE hit_counter( cnt  int unsigned not null ) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>网站的每次点击都会导致对计数器的更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE hit_counter SET cnt = cnt + 1;</span><br></pre></td></tr></table></figure>

<p>那么问题出现了，对于任何想要更新这一行的事务来说，这条记录上都有全局的互斥锁。这会使得这些事务只能串行执行。</p>
<p><strong>将计数其保存在多行中，每次随机选择一行进行更新</strong>，这样需要对计数器表作如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE hit_counter(</span><br><span class="line">    slot tinyint unsigned not null primary key,</span><br><span class="line">    cnt int unsigned not null</span><br><span class="line">) ENGINE = InnoDB;</span><br></pre></td></tr></table></figure>

<p>然后在这张数据表中增加100条数据。现在选择一个随机的槽（slot）进行更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE hit_counter SET cnt = cnt + 1 where slot = RAND() * 100;</span><br></pre></td></tr></table></figure>

<p>要获得统计结果，使用具和函数sum()进行查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM( cnt ) FROM hit_counter;</span><br></pre></td></tr></table></figure>



<h3 id="简述乐观锁和悲观锁"><a href="#简述乐观锁和悲观锁" class="headerlink" title="简述乐观锁和悲观锁"></a>简述乐观锁和悲观锁</h3><ol>
<li>悲观锁, 就是很悲观，<strong>每次去拿数据的时候都认为别人会修改</strong>，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<br>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>乐观锁，就是很乐观，<strong>每次去拿数据的时候都认为别人不会修改</strong>，<strong>所以不会上锁</strong>，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="介绍一下Redis"><a href="#介绍一下Redis" class="headerlink" title="介绍一下Redis"></a>介绍一下Redis</h3><p>Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<h3 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h3><ul>
<li>字符串String</li>
<li>列表List</li>
<li>集合Set</li>
<li>哈希Hash</li>
<li>有序集合Zset(sorted set)</li>
</ul>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>