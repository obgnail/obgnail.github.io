<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;知识点复习&quot;&gt;&lt;a href=&quot;#知识点复习&quot; class=&quot;headerlink&quot; title=&quot;知识点复习&quot;&gt;&lt;/a&gt;知识点复习&lt;/h2&gt;&lt;h3 id=&quot;1-父子进程的先后顺序&quot;&gt;&lt;a href=&quot;#1-父子进程的先后顺序&quot; class=&quot;headerlink&quot; title=&quot;1.父子进程的先后顺序&quot;&gt;&lt;/a&gt;1.父子进程的先后顺序&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;父进程就是这个模块执行的进程&lt;br&gt;&lt;code&gt;p = Process(target=run)&lt;/code&gt;创建的是一个子进程"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>python多任务 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2019-08-15</div></div></div><div class="container post-header"><h1>python多任务</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">知识点复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.父子进程的先后顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.父进程等待子进程结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E5%87%BA%E7%8E%B0%E6%B7%B7%E4%B9%B1"><span class="toc-number">1.3.</span> <span class="toc-text">3.线程数据共享出现混乱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E6%B7%B7%E4%B9%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">4.线程数据混乱解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E9%94%81%E6%9D%A5%E8%A7%A3%E5%86%B3"><span class="toc-number">1.4.1.</span> <span class="toc-text">使用线程锁来解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ThreadLocal"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="toc-number">1.5.</span> <span class="toc-text">5.信号量控制线程数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%87%91%E5%A4%9F%E4%B8%80%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%89%8D%E8%83%BD%E6%89%A7%E8%A1%8C"><span class="toc-number">1.6.</span> <span class="toc-text">6.凑够一定数量的线程才能执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">7.定时线程:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF"><span class="toc-number">1.8.</span> <span class="toc-text">8.线程通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.9.</span> <span class="toc-text">9.生产者和消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.10.</span> <span class="toc-text">10.线程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BD%A2%E8%B1%A1%E6%AF%94%E5%96%BB"><span class="toc-number">1.11.</span> <span class="toc-text">11.进程和线程的形象比喻</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.12.</span> <span class="toc-text">12.异步与同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.13.</span> <span class="toc-text">13.协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">新知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%88%B6%E7%BA%BF%E7%A8%8B%E8%B0%81%E5%85%88%E7%BB%93%E6%9D%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E9%87%8A-%E8%BF%9B%E7%A8%8B%E5%90%8C%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">1.子线程和父线程谁先结束问题的解释(进程同理)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.使用类来创建子线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%BB%E9%94%81"><span class="toc-number">2.3.</span> <span class="toc-text">3.死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text">4.避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">银行家算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%89%88UDP%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">2.5.</span> <span class="toc-text">5.多任务版UDP聊天室</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">6.进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">2.7.</span> <span class="toc-text">7.进程与线程对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.8.</span> <span class="toc-text">8.进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Queue"><span class="toc-number">2.9.</span> <span class="toc-text">9.Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.10.</span> <span class="toc-text">10.进程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%A1%88%E4%BE%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">2.11.</span> <span class="toc-text">11.案例:多进程复制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.12.</span> <span class="toc-text">12.协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.12.1.</span> <span class="toc-text">使用生成器实现多任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BD%BF%E7%94%A8greenlet"><span class="toc-number">2.13.</span> <span class="toc-text">13.使用greenlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BD%BF%E7%94%A8gevent"><span class="toc-number">2.14.</span> <span class="toc-text">14.使用gevent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93"><span class="toc-number">2.15.</span> <span class="toc-text">15.简单总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80"><span class="toc-number">3.</span> <span class="toc-text">视频地址</span></a></li></ol></details></div><div class="container post-content"><h2 id="知识点复习"><a href="#知识点复习" class="headerlink" title="知识点复习"></a>知识点复习</h2><h3 id="1-父子进程的先后顺序"><a href="#1-父子进程的先后顺序" class="headerlink" title="1.父子进程的先后顺序"></a>1.父子进程的先后顺序</h3><blockquote>
<p>父进程就是这个模块执行的进程<br><code>p = Process(target=run)</code>创建的是一个子进程</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程启动&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程启动&#x27;</span>)</span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父进程启动</span></span><br><span class="line"><span class="comment"># 父进程结束</span></span><br><span class="line"><span class="comment"># 子进程启动</span></span><br><span class="line"><span class="comment"># 子进程结束</span></span><br></pre></td></tr></table></figure>

<p>父进程并没有等着子进程结束.<br>也就是说:<strong>父进程的结束不能影响子进程</strong>.</p>
<h3 id="2-父进程等待子进程结束"><a href="#2-父进程等待子进程结束" class="headerlink" title="2.父进程等待子进程结束"></a>2.父进程等待子进程结束</h3><p>如果要让父进程等待子进程结束:使用p.join()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程启动&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程启动&#x27;</span>)</span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="comment"># 添加这句</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父进程启动</span></span><br><span class="line"><span class="comment"># 子进程启动</span></span><br><span class="line"><span class="comment"># 子进程结束</span></span><br><span class="line"><span class="comment"># 父进程结束</span></span><br></pre></td></tr></table></figure>

<p>所以一般我们设计的时候就是在一个父进程里创建多个子进程,子进程同时运行.<br>然后父进程等所有子进程完成后在关闭.</p>
<blockquote>
<ul>
<li>进程是系统在<code>程序执行</code>和 <code>资源分配</code>的基本单位.<br>每个进程都有自己的数据段,代码段和堆栈段</li>
<li>线程是最小的执行单元,而进程由至少一个线程组成,<br>如何调用进程和线程,完全由操作系统决定,程序自己不能决定.</li>
</ul>
</blockquote>
<h3 id="3-线程数据共享出现混乱"><a href="#3-线程数据共享出现混乱" class="headerlink" title="3.线程数据共享出现混乱"></a>3.线程数据共享出现混乱</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        num += n</span><br><span class="line">        num -= n</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=run,args=(<span class="number">6</span>,))</span><br><span class="line">    t2 = threading.Thread(target=run,args=(<span class="number">9</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(num)  <span class="comment"># -48</span></span><br></pre></td></tr></table></figure>



<h3 id="4-线程数据混乱解决方法"><a href="#4-线程数据混乱解决方法" class="headerlink" title="4.线程数据混乱解决方法"></a>4.线程数据混乱解决方法</h3><p>线程共享数据容易造成混乱,解决方法:</p>
<ul>
<li>线程锁</li>
<li>使用ThreadLocal</li>
</ul>
<h4 id="使用线程锁来解决"><a href="#使用线程锁来解决" class="headerlink" title="使用线程锁来解决"></a>使用线程锁来解决</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定</span></span><br><span class="line">mutex.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="comment"># 上锁</span></span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">      <span class="comment"># 解锁</span></span><br><span class="line">    mutex.release()</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;--- end ---&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="comment"># 上锁</span></span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">      <span class="comment"># 解锁</span></span><br><span class="line">    mutex.release()</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;--- end ---&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>mutex.acquire()</code>,如果此时的mutex没有上锁,那么此时就上锁成功</p>
<p>==如果上锁之前已经被上锁了,没有此时就会阻塞在这里,直到这个锁被解开为止==</p>
<p>为什么会阻塞也很简单,在上面代码中,如果两个线程分别执行test1和test2,那么就会同时执行这两个函数,上锁就失去了意义了</p>
</blockquote>
<p>使用互斥锁有一个优化方法:<br>==互斥锁的范围越小越好==<br>将上面代码改为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">      mutex.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">      num += <span class="number">1</span></span><br><span class="line">      mutex.release()  <span class="comment"># 解锁</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;--- end ---&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">      mutex.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">      num += <span class="number">1</span></span><br><span class="line">      mutex.release()  <span class="comment"># 解锁</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--- end ---&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用with来自动上锁与解锁:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"><span class="comment"># 锁对象</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        <span class="comment"># 自动上锁与解锁</span></span><br><span class="line">        <span class="keyword">with</span> lock:</span><br><span class="line">            num += n</span><br><span class="line">            num -= n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=run,args=(<span class="number">6</span>,))</span><br><span class="line">    t2 = threading.Thread(target=run,args=(<span class="number">9</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(num)  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>



<h4 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个全局的ThreadLocal对象</span></span><br><span class="line"><span class="comment"># 每个线程有独立的存储空间</span></span><br><span class="line"><span class="comment"># 每个线程对ThreadLocal对象都可以读写,但是互不影响</span></span><br><span class="line"><span class="comment"># 简单来说,就像进程一样,让不同的线程备份一个一模一样的变量</span></span><br><span class="line">local = threading.local()</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x += n</span><br><span class="line">    x -= n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 给local对象增加一个x属性</span></span><br><span class="line">    <span class="comment"># 每个线程都有local.x,就是线程的局部变量</span></span><br><span class="line">    local.x = num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        run(local.x,n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread().name&#125;</span>------<span class="subst">&#123;local.x&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=func,args=(<span class="number">6</span>,))</span><br><span class="line">    t2 = threading.Thread(target=func,args=(<span class="number">9</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Thread-2------0</span></span><br><span class="line"><span class="comment"># Thread-1------0</span></span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>



<h3 id="5-信号量控制线程数量"><a href="#5-信号量控制线程数量" class="headerlink" title="5.信号量控制线程数量"></a>5.信号量控制线程数量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制同时执行的线程数量</span></span><br><span class="line">sem = threading.Semaphore(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread().name&#125;</span>---<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        threading.Thread(target=run).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Thread-1---0</span></span><br><span class="line"><span class="comment"># Thread-2---0</span></span><br><span class="line"><span class="comment"># Thread-3---0</span></span><br><span class="line"><span class="comment"># Thread-3---1</span></span><br><span class="line"><span class="comment"># Thread-2---1</span></span><br><span class="line"><span class="comment"># Thread-1---1</span></span><br><span class="line"><span class="comment"># Thread-3---2</span></span><br><span class="line"><span class="comment"># Thread-2---2</span></span><br><span class="line"><span class="comment"># Thread-1---2</span></span><br><span class="line"><span class="comment"># Thread-2---3</span></span><br><span class="line"><span class="comment"># Thread-3---3</span></span><br><span class="line"><span class="comment"># Thread-1---3</span></span><br><span class="line"><span class="comment"># Thread-4---0</span></span><br><span class="line"><span class="comment"># Thread-5---0</span></span><br><span class="line"><span class="comment"># Thread-4---1</span></span><br><span class="line"><span class="comment"># Thread-5---1</span></span><br><span class="line"><span class="comment"># Thread-4---2</span></span><br><span class="line"><span class="comment"># Thread-5---2</span></span><br><span class="line"><span class="comment"># Thread-4---3</span></span><br><span class="line"><span class="comment"># Thread-5---3</span></span><br></pre></td></tr></table></figure>

<p><code>sem = threading.Semaphore(3)</code>限定了同时最多只有3个线程.所以这段代码会先执行3个线程,然后在执行2个线程.(每个线程打印0-3)</p>
<h3 id="6-凑够一定数量的线程才能执行"><a href="#6-凑够一定数量的线程才能执行" class="headerlink" title="6.凑够一定数量的线程才能执行"></a>6.凑够一定数量的线程才能执行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 凑够一定数量的线程才能执行</span></span><br><span class="line">bar = threading.Barrier(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread().name&#125;</span>---start&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 在这里等待,直到够4个才能执行下面代码</span></span><br><span class="line">    bar.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread().name&#125;</span>---end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        threading.Thread(target=run).start()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Thread-1---start</span></span><br><span class="line"><span class="comment"># Thread-2---start</span></span><br><span class="line"><span class="comment"># Thread-3---start</span></span><br><span class="line"><span class="comment"># Thread-4---start</span></span><br><span class="line"><span class="comment"># Thread-5---start</span></span><br><span class="line"><span class="comment"># Thread-6---start</span></span><br><span class="line"><span class="comment"># Thread-6---end</span></span><br><span class="line"><span class="comment"># Thread-2---end</span></span><br><span class="line"><span class="comment"># Thread-3---end</span></span><br><span class="line"><span class="comment"># Thread-1---end</span></span><br></pre></td></tr></table></figure>



<h3 id="7-定时线程"><a href="#7-定时线程" class="headerlink" title="7.定时线程:"></a>7.定时线程:</h3><p>(启动了线程,但是要等5秒后才能执行)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 使用Timer,而不是Thread</span></span><br><span class="line">    t = threading.Timer(<span class="number">5</span>,run)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父线程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (等待5秒后)</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># 父线程结束</span></span><br></pre></td></tr></table></figure>



<h3 id="8-线程通讯"><a href="#8-线程通讯" class="headerlink" title="8.线程通讯"></a>8.线程通讯</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="comment"># 创建事件对象</span></span><br><span class="line">    event = threading.Event()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="comment"># 阻塞,等待事件的触发</span></span><br><span class="line">            event.wait()</span><br><span class="line">            <span class="comment"># 重置堵塞(去掉这行则只会重置一次)</span></span><br><span class="line">            event.clear()</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            </span><br><span class="line">    threading.Thread(target=run).start()</span><br><span class="line">    <span class="keyword">return</span> event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    e = func()</span><br><span class="line">    <span class="comment"># 触发事件</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        e.<span class="built_in">set</span>()</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印0,1,2,3,4(每2秒打印一个数字)</span></span><br></pre></td></tr></table></figure>

<p>当执行<code>e = func()</code>的时候就已经启动线程了,但是执行到<code>event.wait()</code>的时候线程被挂起.<br>之后执行<code>e.set()</code>的时候线程恢复.</p>
<p>如果去掉<code>event.clear()</code>,则是等待2秒后直接打印0,1,2,3,4</p>
<blockquote>
<p> 其实wait和clear和e.set()只是设置一个标志符而已:</p>
<ol>
<li>执行<code>event.wait()</code>则把flag位置为False(False就是阻塞),</li>
<li>遇到<code>e.set()</code>就把flag设置为True.</li>
<li><code>event.clear()</code>再次把flag设置为True.</li>
</ol>
</blockquote>
<h3 id="9-生产者和消费者"><a href="#9-生产者和消费者" class="headerlink" title="9.生产者和消费者"></a>9.生产者和消费者</h3><p><strong>回忆进程间通讯</strong><br>生产者就是生产数据的,<br>消费者就是处理数据的</p>
<p><img src="/images/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85.jpg" alt="生产者与消费者"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time,queue,random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params"><span class="built_in">id</span>,q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        num = random.randint(<span class="number">0</span>,<span class="number">1000</span>)</span><br><span class="line">        q.put(num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;生产者<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>生产了<span class="subst">&#123;num&#125;</span>数据放入了队列&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 任务完成(生产者结束生产数据)</span></span><br><span class="line">    q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customer</span>(<span class="params"><span class="built_in">id</span>,q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;消费者<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>消费了<span class="subst">&#123;item&#125;</span>数据&#x27;</span>)      </span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 任务完成(消费者结束消费数据)</span></span><br><span class="line">    q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 消息队列</span></span><br><span class="line">    q = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动生产者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        threading.Thread(target=product,args=(i,q)).start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动消费者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        threading.Thread(target=customer,args=(i,q)).start()</span><br></pre></td></tr></table></figure>



<h3 id="10-线程调度"><a href="#10-线程调度" class="headerlink" title="10.线程调度"></a>10.线程调度</h3><p>现在有两个线程:</p>
<ol>
<li>线程1打印0,2,4,6,8</li>
<li>线程2打印1,3,5,7,9</li>
</ol>
<p>现在想设计一段程序按序打印0-9</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程条件变量</span></span><br><span class="line">cond = threading.Condition()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run1</span>():</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name,i)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            cond.wait()</span><br><span class="line">            <span class="comment"># 唤醒指令:用于唤醒其他线程</span></span><br><span class="line">            cond.notify()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run2</span>():</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name,i)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            cond.notify()</span><br><span class="line">            cond.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    threading.Thread(target=run1).start()</span><br><span class="line">    threading.Thread(target=run2).start()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释:<br>run1在执行wait后阻塞线程,然后执行notify唤醒run2</p>
<p>注意run1和run2的<code>wait</code>和<code>notify</code>顺序不可改变</p>
</blockquote>
<h3 id="11-进程和线程的形象比喻"><a href="#11-进程和线程的形象比喻" class="headerlink" title="11.进程和线程的形象比喻"></a>11.进程和线程的形象比喻</h3><ol>
<li>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</li>
<li>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。</li>
<li>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</li>
<li>一个车间里，可以有很多工人。他们协同完成一个任务。线程就好比车间里的工人。一个进程可以包括多个线程。</li>
<li>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li>
<li>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81">“互斥锁”</a>（Mutual exclusion，缩写Mutex），防止多个线程同时读写某一块内存区域。</li>
<li>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</li>
<li>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。<br>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</li>
</ol>
<blockquote>
<p>操作系统的设计，因此可以归结为三点：</p>
<ol>
<li>以多进程形式，允许多个任务同时运行；</li>
<li>以多线程形式，允许单个任务分成不同的部分运行；</li>
<li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li>
</ol>
</blockquote>
<h3 id="12-异步与同步"><a href="#12-异步与同步" class="headerlink" title="12.异步与同步"></a>12.异步与同步</h3><ol>
<li>异步：多任务，多个任务之间执行没有先后顺序，可以同时运行，执行的先后顺序不会有什么影响，存在的多条运行主线</li>
<li>同步：多任务，多个任务之间执行的时候要求有先后顺序，必须一个先执行完成之后，另一个才能继续执行，只有一个主线</li>
<li>阻塞：从调用者的角度出发，如果在调用的时候，被卡住，不能再继续向下运行，需要等待，就说是阻塞。</li>
<li>非阻塞：从调用者的角度出发，如果在调用的时候，没有被卡住，能够继续向下运行，无需等待，就说是非阻塞。</li>
</ol>
<h3 id="13-协程"><a href="#13-协程" class="headerlink" title="13.协程"></a>13.协程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 对于协程,上面两个函数可以按序打印出1,2,x,y,z,3</span></span><br><span class="line"><span class="comment"># 执行出这个结果,但是A中是没有B的调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;---生产者生产数据<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        r = c.send(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;***消费者消费数据<span class="subst">&#123;r&#125;</span>&#x27;</span>)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customer</span>():</span></span><br><span class="line">    data = <span class="number">1000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> data</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;+++消费者消费数据<span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line">        data += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建协程</span></span><br><span class="line">c = customer()</span><br><span class="line">product(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---生产者生产数据0</span></span><br><span class="line"><span class="comment"># +++消费者消费数据0</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1001</span></span><br><span class="line"><span class="comment"># ---生产者生产数据1</span></span><br><span class="line"><span class="comment"># +++消费者消费数据1</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1002</span></span><br><span class="line"><span class="comment"># ---生产者生产数据2</span></span><br><span class="line"><span class="comment"># +++消费者消费数据2</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1003</span></span><br><span class="line"><span class="comment"># ---生产者生产数据3</span></span><br><span class="line"><span class="comment"># +++消费者消费数据3</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1004</span></span><br><span class="line"><span class="comment"># ---生产者生产数据4</span></span><br><span class="line"><span class="comment"># +++消费者消费数据4</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1005</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>协程需要<code>__next__函数</code>或者<code>c.send(None)</code>才能激活,所以<code>c = customer()</code>只是创建了一个协程,必不会执行任何程序</p>
</blockquote>
<h2 id="新知识"><a href="#新知识" class="headerlink" title="新知识"></a>新知识</h2><p>CPU这种不同进程依次执行极短时间的方法被称为<code>时间片轮转</code></p>
<h3 id="1-子线程和父线程谁先结束问题的解释-进程同理"><a href="#1-子线程和父线程谁先结束问题的解释-进程同理" class="headerlink" title="1.子线程和父线程谁先结束问题的解释(进程同理)"></a>1.子线程和父线程谁先结束问题的解释(进程同理)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程启动&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程启动&#x27;</span>)</span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父进程启动</span></span><br><span class="line"><span class="comment"># 父进程结束</span></span><br><span class="line"><span class="comment"># 子进程启动</span></span><br><span class="line"><span class="comment"># 子进程结束</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解析:</p>
<ol>
<li>执行到<code>p = Process(target=run)</code>时创建一个子进程对象</li>
<li>执行到<code>p.start()</code>时启动子进程,此时的子进程去执行run函数</li>
<li>然后父进程继续执行<code>print(&#39;父进程结束&#39;)</code></li>
<li>然后父进程继续执行,发现已经没有代码了,于是父进程阻塞.等待子进程的结束</li>
<li>当子进程结束后,父进程结束运行.</li>
</ol>
</blockquote>
<p>enumerate获取当前线程数 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;test1&#x27;</span>)</span><br><span class="line">		time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;test2&#x27;</span>)</span><br><span class="line">		time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	threading.Thread(target=test1,name=<span class="string">&#x27;test1&#x27;</span>).start()</span><br><span class="line">	threading.Thread(target=test2,name=<span class="string">&#x27;test2&#x27;</span>).start()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">	<span class="comment"># [&lt;_MainThread(MainThread, started 35004)&gt;, &lt;Thread(test1, started 6804)&gt;, &lt;Thread(test2, started 4256)&gt;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>t = threading.Thread(target=test1,name=&#39;test1&#39;)</code>:创建一个子线程对象,<br>注意:<strong>只是创建子线程对象,而不是创建子线程</strong></li>
<li><code>t.start()</code>:根据子线程对象创建子线程并且执行这个子线程</li>
<li>==test1函数结束,就意味着该子线程结束==</li>
<li>所以说:<br>当执行<code>t = threading.Thread(target=test1,name=&#39;test1&#39;)</code>后,<code>threading.enumerate()</code>的值并不会增加,它捕获的是<code>t.start()</code></li>
</ul>
</blockquote>
<h3 id="2-使用类来创建子线程"><a href="#2-使用类来创建子线程" class="headerlink" title="2.使用类来创建子线程"></a>2.使用类来创建子线程</h3><p><code>t = threading.Thread(target=test1,name=&#39;test1&#39;)</code>需要指定一个函数,但是如果函数太长,需要封装成一个类,我们就可以自己继承threading.Thread类,并且重写run方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mythread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">random_num</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> random.randint(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">return_10_random_num</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">			x = self.random_num()</span><br><span class="line">			<span class="built_in">print</span>(x)</span><br><span class="line">			time.sleep(<span class="number">2</span>)</span><br><span class="line">			<span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;--- start ---&#x27;</span>)</span><br><span class="line">		self.return_10_random_num()</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;-- end --&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	x = mythread()</span><br><span class="line">	x.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>继承threading.Thread</li>
<li>重写run方法</li>
<li>执行start方法</li>
</ul>
<h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h3><p>由于代码设计出错带来的死锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;acquire mutexA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;acquire mutexB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        mutexB.release()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;release mutexB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        mutexA.release()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;release mutexA&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;acquire mutexB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;acquire mutexA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        mutexA.release()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;release mutexA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        mutexB.release()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;release mutexB&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mutexA = threading.Lock()</span><br><span class="line">    mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line">    MyThread1().start()</span><br><span class="line">    MyThread2().start()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释:</p>
<ol>
<li>在上面代码中,两个类同时运行,都会第一行(也就是说同时执行了<code>mutexA.acquire()</code>和<code>mutexB.acquire()</code>)</li>
<li>myhreading1之后需要执行<code>mutexB.acquire()</code>,但是此时的mutexB已经上锁,阻塞等待<br>myhreading2之后需要执行<code>mutexA.acquire()</code>,但是此时的mutexA已经上锁,阻塞等待</li>
<li>双方互相等待,造成死锁</li>
</ol>
</blockquote>
<h3 id="4-避免死锁"><a href="#4-避免死锁" class="headerlink" title="4.避免死锁"></a>4.避免死锁</h3><ul>
<li>设计代码时尽量避免(银行家算法)</li>
<li>添加超时时间</li>
</ul>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>有三个客户c1，c2，c3，向银行家借款，该银行家的资金总额为10万，其中C1客户要借9万，c2客户要借3万，C3客户要借8万，总计20万。某一时刻的状态如图所示</p>
<p><img src="/images/1562221891690.png" alt="1562221891690"></p>
<p>银行家算法:</p>
<blockquote>
<p>从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部货款，再进而检查下一个能完成工作的客户，……·如果所有客户都能完成工作，则找到个安全序列，银行家才是安全的</p>
</blockquote>
<h3 id="5-多任务版UDP聊天室"><a href="#5-多任务版UDP聊天室" class="headerlink" title="5.多任务版UDP聊天室"></a>5.多任务版UDP聊天室</h3><p><img src="/images/1562222147482.png" alt="1562222147482"></p>
<p>设计</p>
<blockquote>
<ul>
<li>需要两个线程</li>
<li>线程一用来接收数据,然后显示</li>
<li>线程二用来检测键盘数据,然后通过UDP发送数据</li>
</ul>
</blockquote>
<h3 id="6-进程"><a href="#6-进程" class="headerlink" title="6.进程"></a>6.进程</h3><p>进程和普通的EXE文件(程序)的区别:</p>
<blockquote>
<p>在windows里,<strong>进程就是运行起来的程序</strong>.</p>
<ul>
<li>程序是静态的.</li>
<li>进程还拥有资源</li>
</ul>
<p>所以,进程=程序+资源</p>
</blockquote>
<p>一个程序制作多个进程:</p>
<ul>
<li>Chrome每个标签页都是一个进程</li>
<li>一个QQ程序,登录两个QQ,就有两个进程</li>
</ul>
<p>进程的状态:</p>
<p><img src="/images/1562288328286.png" alt="1562288328286"></p>
<p>多进程与多线程:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="number">456</span>)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	a = multiprocessing.Process(target=test1)</span><br><span class="line">	b = multiprocessing.Process(target=test2)</span><br><span class="line"></span><br><span class="line">	a.start()</span><br><span class="line">	b.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="number">456</span>)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	a = threading.Thread(target=test1)</span><br><span class="line">	b = threading.Thread(target=test2)</span><br><span class="line"></span><br><span class="line">	a.start()</span><br><span class="line">	b.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 可以发现,二者的API一模一样.</p>
</blockquote>
<h3 id="7-进程与线程对比"><a href="#7-进程与线程对比" class="headerlink" title="7.进程与线程对比"></a>7.进程与线程对比</h3><blockquote>
<ul>
<li>进程一般是同功能集群代码<br>(如QQ双开,两个QQ完成的是相同的工作)</li>
<li>线程一般是协同完成工作的代码<br>(如QQ的发送和接受代码,两段代码协同工作)</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>进程和线程都可以实现多任务</li>
<li>父进程拥有的资源,子进程都拥有.<br>(也就是说,子进程会把父进程的==内存==全部复制一遍)<br>父线程拥有的资源,子线程不一定拥有</li>
<li>==所以进程一般消耗的资源比线程大==</li>
</ul>
</blockquote>
<blockquote>
<p>进程是<code>写时拷贝</code>.</p>
<ul>
<li>一般来说,两个进程的代码是完全一致的</li>
<li>进程 = 代码 + 资源(内存)</li>
<li>既然代码是一致的,那么我们就只需要复制内存就可以了.代码是共享的</li>
<li>如果代码执行过程中通过特殊手段修改代码,那么就会在读写代码的时候拷贝一份新的代码</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>进程是资源分配的单位</p>
</li>
<li><p>但是实际工作的是线程.<br>(进程会创建一个主线程.主线程使用进程的资源去工作)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">multiprocessing.Process(target=test1).start()</span><br></pre></td></tr></table></figure>

<p>上面代码中:</p>
<ol>
<li>进程创建一个主线程</li>
<li>主线程去扫描代码,工作</li>
<li>当扫描到<code>multiprocessing.Process(target=test1).start()</code>去调用函数</li>
<li>这个函数就是创建进程函数,会复制一份资源去执行同一份代码</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">threading.Thread(target=test1).start()</span><br></pre></td></tr></table></figure>

<p>上面代码中:</p>
<ol>
<li>进程创建一个主线程</li>
<li>当扫描到<code>threading.Thread(target=test1).start()</code>去调用函数</li>
<li>这个函数就是创建线程函数,该线程直接使用主线程的资源(并没有复制)去执行test1函数</li>
</ol>
</blockquote>
<blockquote>
<p> 程和进程在使用上各有优缺点∶<br>线程执行开销小,但不利于资源的管理和保护；而进程正相反</p>
</blockquote>
<h3 id="8-进程间通信"><a href="#8-进程间通信" class="headerlink" title="8.进程间通信"></a>8.进程间通信</h3><p>进程间通信:</p>
<p><img src="/images/1562293499248.png" alt="1562293499248"></p>
<p>线程间通信:</p>
<p><img src="/images/1562293665790.png" alt="1562293665790"></p>
<h3 id="9-Queue"><a href="#9-Queue" class="headerlink" title="9.Queue"></a>9.Queue</h3><p><code>q = Queue()</code>中<code>get()</code>和<code>get_nowait()</code>的区别:</p>
<ol>
<li>当Queue为空的时候,使用<code>q.get()</code>会阻塞,等待新的数据</li>
<li>当Queue为空的时候,使用<code>q.get_nowait()</code>直接报错</li>
</ol>
<p><code>q = Queue(3)</code>中<code>put()</code>和<code>put_nowait()</code>的区别同理:</p>
<ol>
<li>当Queue满的时候,使用<code>q.put()</code>会阻塞,等待数据被弹出</li>
<li>当Queue满的时候,使用<code>q.put_nowait()</code>直接报错</li>
</ol>
<blockquote>
<p>使用<code>q.full()</code>和<code>q.empty()</code>判断是否为满/空</p>
</blockquote>
<p>Queue的简单使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">q</span>):</span></span><br><span class="line">	alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> each <span class="keyword">in</span> alist:</span><br><span class="line">		q.put(each)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">q</span>):</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">			data = q.get()</span><br><span class="line">			<span class="built_in">print</span>(data)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	q = Queue()</span><br><span class="line">	Process(target=download,args=(q,)).start()</span><br><span class="line">	Process(target=parse,args=(q,)).start()</span><br></pre></td></tr></table></figure>



<h3 id="10-进程池"><a href="#10-进程池" class="headerlink" title="10.进程池"></a>10.进程池</h3><p>当需要创建的子进程数量不多时，可以直接利用 multiprocessing 中的<br>Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到 multiprocessing模块提供的Poo方法</p>
<p>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Poo中时，</p>
<ul>
<li>如果池还没有满,那么就会创建一个新的进程用来执行该请求</li>
<li>如果池中的进程数已经达到指定的最大值,那么该请求就会等待，直到池中有进程结束,才会用之前的进程来执行新的任务</li>
</ul>
<blockquote>
<p>注意:</p>
<ul>
<li>使用Processing创建的子进程中,父进程会等待子进程结束</li>
<li>但是使用进程池创建的子进程中,父进程不会等待子进程结束</li>
<li>所以必须显式调用<code>pool.join()</code></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>pool.close()</code>:关闭进程池，关闭后pool不再接收新的请求</li>
<li>所以<code>pool.close()</code>必须在<code>pool.join()</code>前面</li>
</ul>
</blockquote>
<blockquote>
<p>注意:在windown里的进程池有一个很荒诞的错误:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;---- <span class="subst">&#123;num&#125;</span> ----&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    p = Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p.apply_async(test,(i,))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--- start ---&#x27;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--- end ---&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&#x27;---- <span class="subst">&#123;num&#125;</span> ----&#x27;</span>)</span><br><span class="line">	time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	p = Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">		p.apply_async(test,(i,))</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- start ---&#x27;</span>)</span><br><span class="line">	p.close()</span><br><span class="line">	p.join()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- end ---&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<ul>
<li>上面两段代码唯一的区别就是添加一个<code>if __name__ == &#39;__main__&#39;:</code></li>
<li>如果不加<code>if __name__ == &#39;__main__&#39;:</code>,就会报错<code>RuntimeError:</code></li>
<li>原因:<br>在windows中, 创建进程由于没有folk创建进程, 所以是通过重载自身模块来创建的, 如果Pool放在if <strong>name</strong> == “<strong>main</strong>“外部, 就会进行无线递归模块</li>
</ul>
</blockquote>
<h3 id="11-案例-多进程复制文件"><a href="#11-案例-多进程复制文件" class="headerlink" title="11.案例:多进程复制文件"></a>11.案例:多进程复制文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_file</span>(<span class="params">old_file_name,old_folder_name,new_folder_name</span>):</span></span><br><span class="line">	old_file_route = <span class="string">f&#x27;<span class="subst">&#123;old_folder_name&#125;</span>\\<span class="subst">&#123;old_file_name&#125;</span>&#x27;</span></span><br><span class="line">	new_file_route = <span class="string">f&#x27;<span class="subst">&#123;new_folder_name&#125;</span>\\<span class="subst">&#123;old_file_name&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(old_file_route,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> old_f ,<span class="built_in">open</span>(new_file_route,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> new_f:</span><br><span class="line">		new_f.write(old_f.read())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">old_folder_name</span>):</span></span><br><span class="line">	<span class="comment"># 创建新文件夹</span></span><br><span class="line">	new_folder_name = <span class="string">f&#x27;<span class="subst">&#123;old_folder_name&#125;</span> [复件]&#x27;</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		os.mkdir(new_folder_name)</span><br><span class="line">	<span class="keyword">except</span> FileExistsError:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	file_list = os.listdir(old_folder_name)</span><br><span class="line"></span><br><span class="line">	p = Pool()</span><br><span class="line">	<span class="keyword">for</span> file <span class="keyword">in</span> file_list:</span><br><span class="line">		p.apply_async(copy_file,(file,old_folder_name,new_folder_name))</span><br><span class="line"></span><br><span class="line">	p.close()</span><br><span class="line">	p.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main(<span class="string">r&#x27;D:\note\Python\视频__python多任务\trainingfile&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>我们还可以让他显示复制的进度</p>
<blockquote>
<ul>
<li>需要适宜哦那个进程间通讯</li>
<li>但是不使用<code>form mutilprocessing import Queue</code>,而是使用<code>mutilprocessing.Manager().Queue()</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool,Manager</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_file</span>(<span class="params">queue,old_file_name,old_folder_name,new_folder_name</span>):</span></span><br><span class="line">    old_file_route = <span class="string">f&#x27;<span class="subst">&#123;old_folder_name&#125;</span>\\<span class="subst">&#123;old_file_name&#125;</span>&#x27;</span></span><br><span class="line">    new_file_route = <span class="string">f&#x27;<span class="subst">&#123;new_folder_name&#125;</span>\\<span class="subst">&#123;old_file_name&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(old_file_route,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> old_f ,<span class="built_in">open</span>(new_file_route,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> new_f:</span><br><span class="line">        <span class="comment"># 正在复制</span></span><br><span class="line">        queue.put(old_file_name)</span><br><span class="line">        new_f.write(old_f.read())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">old_folder_name</span>):</span></span><br><span class="line">    <span class="comment"># 创建新文件夹</span></span><br><span class="line">    new_folder_name = <span class="string">f&#x27;<span class="subst">&#123;old_folder_name&#125;</span> [复件]&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.mkdir(new_folder_name)</span><br><span class="line">    <span class="keyword">except</span> FileExistsError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取当前目录下的所有文件</span></span><br><span class="line">    file_list = os.listdir(old_folder_name)</span><br><span class="line">    files_num = <span class="built_in">len</span>(file_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;--------- 一共<span class="subst">&#123;files_num&#125;</span>个文件 ---------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建队列</span></span><br><span class="line">    queue = Manager().Queue()</span><br><span class="line"></span><br><span class="line">    p = Pool()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> file_list:</span><br><span class="line">        p.apply_async(copy_file,(queue,file,old_folder_name,new_folder_name))</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line">    fin_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        file_name = queue.get()</span><br><span class="line">        fin_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回退光标</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;\r当前进度<span class="subst">&#123;(fin_num/files_num)*<span class="number">100</span>  :<span class="number">.2</span>f&#125;</span>%,正在复制:<span class="subst">&#123;file_name&#125;</span>&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> fin_num == files_num:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(<span class="string">r&#x27;D:\note\Python\视频__python多任务\trainingfile&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="12-协程"><a href="#12-协程" class="headerlink" title="12.协程"></a>12.协程</h3><p>简单的的无限生成器:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Febo</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.num1 = <span class="number">1</span></span><br><span class="line">		self.num2 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">			<span class="keyword">yield</span> <span class="keyword">from</span> (self.num1,self.num2)</span><br><span class="line">			self.num1 += self.num2</span><br><span class="line">			self.num2 += self.num1</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> Febo():</span><br><span class="line">	<span class="built_in">print</span>(each)</span><br></pre></td></tr></table></figure>

<h4 id="使用生成器实现多任务"><a href="#使用生成器实现多任务" class="headerlink" title="使用生成器实现多任务"></a>使用生成器实现多任务</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;----- test1 -----&#x27;</span>)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;----- test2 -----&#x27;</span>)</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	t1 = test1()</span><br><span class="line">	t2 = test2()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="built_in">next</span>(t1)</span><br><span class="line">		<span class="built_in">next</span>(t2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>



<h3 id="13-使用greenlet"><a href="#13-使用greenlet" class="headerlink" title="13.使用greenlet"></a>13.使用greenlet</h3><p>上面的协程代码其实接口不是很好,这时我们就可以使用<code>greenlet</code></p>
<blockquote>
<p>pip install greenlet</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;---- 1 ----&#x27;</span>)</span><br><span class="line">        gr2.switch()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;---- 2 ----&#x27;</span>)</span><br><span class="line">        gr1.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    gr1 = greenlet(test1)</span><br><span class="line">    gr2 = greenlet(test2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 切换到gr1中运行</span></span><br><span class="line">    gr1.switch()</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code> gr1 = greenlet(test1)</code>中的gr1就类似于生成器对象,但是这个对象封装了一些方法</li>
<li><code>gr1.switch()</code>:切换到gr1中运行</li>
</ul>
</blockquote>
<h3 id="14-使用gevent"><a href="#14-使用gevent" class="headerlink" title="14.使用gevent"></a>14.使用gevent</h3><p>确实greenlet比较方便,但是还有更加方便的gevent </p>
<blockquote>
<p>pip install gevent</p>
</blockquote>
<p>其原理是当一个 greenlet 遇到IO操作(指的是 input output输入输出·比如网络文件操作等）时，就自动切换到其他的 greenlet 等到IO操作完成，再在适当的时候切换回来继续执行,由于IO操作非常耗时经常使程序处于等待状态，有了 gevent 为我们<strong>自动切换协程</strong>就保证总有 greenlet在运行而不是等待IO</p>
<blockquote>
<ul>
<li>简单来说,当遇到延时操作时,<code>gevent</code>会自动切换协程</li>
<li><code>genvent.sleep()</code>:延时</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(gevent.getcurrent(),i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的g1就是一个greenlet</span></span><br><span class="line">g1 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line">g2 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line">g3 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞g1</span></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x1d18d7ecae8: f(5)&gt; 0</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x1d18d7ecae8: f(5)&gt; 1</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x1d18d7ecae8: f(5)&gt; 2</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x1d18d7ecae8: f(5)&gt; 3</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x1d18d7ecae8: f(5)&gt; 4</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x1d18d7ec9d8: f(5)&gt; 0</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x1d18d7ec9d8: f(5)&gt; 1</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x1d18d7ec9d8: f(5)&gt; 2</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x1d18d7ec9d8: f(5)&gt; 3</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x1d18d7ec9d8: f(5)&gt; 4</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x1d18d7ecbf8: f(5)&gt; 0</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x1d18d7ecbf8: f(5)&gt; 1</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x1d18d7ecbf8: f(5)&gt; 2</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x1d18d7ecbf8: f(5)&gt; 3</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x1d18d7ecbf8: f(5)&gt; 4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(gevent.getcurrent(),i)</span><br><span class="line">        gevent.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的g1就是一个greenlet</span></span><br><span class="line">g1 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line">g2 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line">g3 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x232f5f8cae8: f(5)&gt; 0</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x232f5f8c9d8: f(5)&gt; 0</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x232f5f8cbf8: f(5)&gt; 0</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x232f5f8cae8: f(5)&gt; 1</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x232f5f8c9d8: f(5)&gt; 1</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x232f5f8cbf8: f(5)&gt; 1</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x232f5f8cae8: f(5)&gt; 2</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x232f5f8c9d8: f(5)&gt; 2</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x232f5f8cbf8: f(5)&gt; 2</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x232f5f8cae8: f(5)&gt; 3</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x232f5f8c9d8: f(5)&gt; 3</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x232f5f8cbf8: f(5)&gt; 3</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x232f5f8cae8: f(5)&gt; 4</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x232f5f8c9d8: f(5)&gt; 4</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x232f5f8cbf8: f(5)&gt; 4</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<ul>
<li><p>gevent只能识别自己的<code>gevent.sleep()</code>这个延时操作,不能识别<code>time.sleep()</code>的操作</p>
</li>
<li><p>如果要识别<code>time.sleep()</code>,需要添加一个<code>monkey.patch_all()</code><br><strong>将程序中用到的耗时操作的代码，换为 gevent中自己实现的模块</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(gevent.getcurrent(),i)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的g1就是一个greenlet</span></span><br><span class="line">g1 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line">g2 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line">g3 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x2058b7a0598: f(5)&gt; 0</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x2058b7a08c8: f(5)&gt; 0</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x2058b7a07b8: f(5)&gt; 0</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x2058b7a0598: f(5)&gt; 1</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x2058b7a08c8: f(5)&gt; 1</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x2058b7a07b8: f(5)&gt; 1</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x2058b7a0598: f(5)&gt; 2</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x2058b7a08c8: f(5)&gt; 2</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x2058b7a07b8: f(5)&gt; 2</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x2058b7a0598: f(5)&gt; 3</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x2058b7a08c8: f(5)&gt; 3</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x2058b7a07b8: f(5)&gt; 3</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-0&quot; at 0x2058b7a0598: f(5)&gt; 4</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-1&quot; at 0x2058b7a08c8: f(5)&gt; 4</span></span><br><span class="line"><span class="comment"># &lt;Greenlet &quot;Greenlet-2&quot; at 0x2058b7a07b8: f(5)&gt; 4</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p>gevent还有一个<code>joinall()</code>函数:<br>等待所有的spawn完成:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(myfunc1),</span><br><span class="line">    gevent.spawn(myfunc2),</span><br><span class="line">    gevent.spawn(myfunc3),</span><br><span class="line">    gevent.spawn(myfunc4),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>



<h3 id="15-简单总结"><a href="#15-简单总结" class="headerlink" title="15.简单总结"></a>15.简单总结</h3><ol>
<li>进程是资源分配的单位</li>
<li>线程是操作系统调度的单位</li>
<li>进程切换需要的资源很大,效率很低</li>
<li>线程切换需要的资源一般，效率一般(当然了在不考虑GIL的情况下)</li>
<li>协程切换任务资源很小,效率高</li>
<li>多进程,多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中所以是并发</li>
</ol>
<h2 id="视频地址"><a href="#视频地址" class="headerlink" title="视频地址"></a>视频地址</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av56898207">https://www.bilibili.com/video/av56898207</a></p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>