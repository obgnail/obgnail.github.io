<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av20982396&quot;&gt;python数据结构与算法系列课程1&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>python数据结构与算法系列课程 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Data-Structures-And-Algorithms/" rel="tag">Data Structures And Algorithms</a></div><div class="post-time">2019-08-05</div></div></div><div class="container post-header"><h1>python数据结构与算法系列课程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80"><span class="toc-number">1.</span> <span class="toc-text">地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.</span> <span class="toc-text">内存和数据类型本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">顺序表的两种基本实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">循环单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">队列的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-number">6.</span> <span class="toc-text">栈的应用 : 迷宫问题(深度探索)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98-%E5%B9%BF%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-number">7.</span> <span class="toc-text">队列的应用 : 迷宫问题(广度探索)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">8.</span> <span class="toc-text">排序算法的稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">排序算法总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86"><span class="toc-number">11.</span> <span class="toc-text">树的广度遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86-1"><span class="toc-number">12.</span> <span class="toc-text">树的广度遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98"><span class="toc-number">13.</span> <span class="toc-text">算法习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">13.1.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TOP10-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">13.2.</span> <span class="toc-text">TOP10(优先队列)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8D%E4%BD%9C%E4%BF%AE%E6%94%B9%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">13.3.</span> <span class="toc-text">稍作修改的二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Two-Sum"><span class="toc-number">13.4.</span> <span class="toc-text">Two-Sum</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av20982396">python数据结构与算法系列课程1</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av21540971/">python数据结构与算法系列课程2</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av20777855/?p=1">Python3.5 算法</a></p>
</li>
</ol>
<h2 id="内存和数据类型本质"><a href="#内存和数据类型本质" class="headerlink" title="内存和数据类型本质"></a>内存和数据类型本质</h2><ul>
<li>计算机的最小寻址为字节.每字节8位.</li>
<li>我们在存储数据的时候 : 跟计算机请求空间,然后填入二进制数</li>
<li>数据类型就是告诉计算机我们填入的二进制数该怎么解析,有的解析成数字,有的解析成字符</li>
</ul>
<p><img src="/images/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F.png" alt="顺序表的两种基本形式"></p>
<p>实际上,list的元素都是内存地址,这些内存地址再去引用真正的数据,这种做法称为<code>元素外置</code></p>
<blockquote>
<p>为什么要元素外置?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="string">&#x27;hyl&#x27;</span>,<span class="literal">None</span>,<span class="string">&#x27;asda&#x27;</span>,&#123;<span class="string">&#x27;asd&#x27;</span>:<span class="number">8</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>因为list的元素大小不一,为了实现顺序存储只能用地址来作为list的元素了</p>
<p><img src="/images/1564847632555.png" alt="1564847632555"></p>
</blockquote>
<h2 id="顺序表的两种基本实现方式"><a href="#顺序表的两种基本实现方式" class="headerlink" title="顺序表的两种基本实现方式"></a>顺序表的两种基本实现方式</h2><p><img src="/images/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png" alt="顺序表的实现方式"></p>
<p>分离式结构的好处是 : 当数组需要扩充的时候,创建新的数组后修改指针即可.这样<strong>数组的内存id不会改变</strong></p>
<h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><p>插入头部:</p>
<p><strong>直接尾部插入，head指向插入节点</strong>就行了</p>
<blockquote>
<p>也就是说:<br>对于循环单链表,<strong>头插和尾插元素顺序没区别,只是要改下head的地址</strong></p>
</blockquote>
<h2 id="队列的实现原理"><a href="#队列的实现原理" class="headerlink" title="队列的实现原理"></a>队列的实现原理</h2><p>环形队列</p>
<p><img src="/images/1564993854169.png" alt="1564993854169"></p>
<blockquote>
<ul>
<li>列表+两个下标指针创建一个列表和两个变量,front变量指向队首,rear变量指向队尾.</li>
<li>初始时,front和rear都为0进队操作:元素写到li[rear]的位置,rear自增1.  </li>
<li>出队操作:返回[front]的元素,front自减1.</li>
</ul>
</blockquote>
<p>如何实现环形?<br>环形队列:当队尾指针 front== Maxsize+1时,再前进个位置就自动到0.<br>就是说,11过完应该是12,怎么将其改为0</p>
<blockquote>
<p><strong>使用求余</strong></p>
<ul>
<li>队首指针前进1 : front=(font+1)%Maxsize</li>
<li>队尾指针前进1 : rear=(rear+1)%Maxsize</li>
<li>队空条件 : rear == front</li>
<li>队满条件 : (rear+1)%Maxsize== front</li>
</ul>
</blockquote>
<h2 id="栈的应用-迷宫问题-深度探索"><a href="#栈的应用-迷宫问题-深度探索" class="headerlink" title="栈的应用 : 迷宫问题(深度探索)"></a>栈的应用 : 迷宫问题(深度探索)</h2><p>给一个二维列表，表示迷宫（0表示通道，1表示围墙）给出算法，求一条走出迷宫的路径。</p>
<p><img src="/images/1564995436811.png" alt="1564995436811"></p>
<blockquote>
<p>解决思路 :</p>
<ul>
<li>在一个迷宫节点(x,y)上,可以进行四个方向的探查 :  <ul>
<li><code>maze[x-1][y]</code></li>
<li><code>maze[x+1][y]</code></li>
<li><code>maze[x][y-1]</code></li>
<li><code>maze[x][y+1]</code></li>
</ul>
</li>
<li>思路：<strong>从一个节点开始，任意找下一个能走的点，当找不到能走的点时，退回上一个点寻找是否有其他方向的点</strong></li>
<li>方法：<ol>
<li>创建一个空栈，首先将入口位置进栈。</li>
<li>当栈不空时循环：获取栈顶元素，寻找下一个可走的相邻方块。如果找不到可走的相邻方块，说明当前位置是死胡同，进行回溯（就是将当前位置出栈，看前面的点是否还有别的出路）</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">maze = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_way</span>(<span class="params">start_x,start_y,end_x,end_y</span>):</span></span><br><span class="line">    dirs = [</span><br><span class="line">        <span class="keyword">lambda</span> x,y:(x+<span class="number">1</span>,y),</span><br><span class="line">        <span class="keyword">lambda</span> x,y:(x-<span class="number">1</span>,y),</span><br><span class="line">        <span class="keyword">lambda</span> x,y:(x,y-<span class="number">1</span>),</span><br><span class="line">        <span class="keyword">lambda</span> x,y:(x,y+<span class="number">1</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># 存储经过的点</span></span><br><span class="line">    stack = []</span><br><span class="line">    stack.append((start_x,start_y))</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        cur_node = stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> cur_node[<span class="number">0</span>] == end_x <span class="keyword">and</span> cur_node[<span class="number">1</span>] == end_y:</span><br><span class="line">            <span class="comment"># 到达终点</span></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="built_in">print</span>(p)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> dirs:</span><br><span class="line">            next_node = <span class="built_in">dir</span>(*cur_node)</span><br><span class="line">            <span class="keyword">if</span> maze[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 找到下一个</span></span><br><span class="line">                stack.append(next_node)</span><br><span class="line">                <span class="comment"># 将经过的点标记为-1,防止死循环</span></span><br><span class="line">                maze[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]]= -<span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 四个方向都没有找到</span></span><br><span class="line">            maze[cur_node[<span class="number">0</span>]][cur_node[<span class="number">1</span>]] = -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;没有路&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">find_way(<span class="number">1</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure>



<h2 id="队列的应用-迷宫问题-广度探索"><a href="#队列的应用-迷宫问题-广度探索" class="headerlink" title="队列的应用 : 迷宫问题(广度探索)"></a>队列的应用 : 迷宫问题(广度探索)</h2><blockquote>
<ul>
<li>思路：从一个节点开始，寻找所有下面能继续走的点。继续寻找，直到找到出口。</li>
<li>方法：<ol>
<li>创建一个空队列，将起点位置进队。</li>
<li>在队列不为空时循环 :<ul>
<li>出队一次,如果当前位置为出口,则算法结束;</li>
<li>否则找出当前方块的4个相邻方块中可走的方块，全部进队。</li>
</ul>
</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">maze = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_way</span>(<span class="params">start_x,start_y,end_x,end_y</span>):</span></span><br><span class="line">    dirs = [</span><br><span class="line">        <span class="keyword">lambda</span> x,y:(x+<span class="number">1</span>,y),</span><br><span class="line">        <span class="keyword">lambda</span> x,y:(x-<span class="number">1</span>,y),</span><br><span class="line">        <span class="keyword">lambda</span> x,y:(x,y-<span class="number">1</span>),</span><br><span class="line">        <span class="keyword">lambda</span> x,y:(x,y+<span class="number">1</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    queue = deque()</span><br><span class="line">    path = []</span><br><span class="line">    queue.append((start_x,start_y,-<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        cur_node = queue.popleft()</span><br><span class="line">        path.append(cur_node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur_node[<span class="number">0</span>] == end_x <span class="keyword">and</span> cur_node[<span class="number">1</span>] == end_y:</span><br><span class="line">            <span class="comment"># 到达终点</span></span><br><span class="line">            <span class="built_in">print</span>(path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> dirs:</span><br><span class="line">            next_node = <span class="built_in">dir</span>(cur_node[<span class="number">0</span>],cur_node[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 找到下一个方块</span></span><br><span class="line">            <span class="keyword">if</span> maze[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]] == <span class="number">0</span>:</span><br><span class="line">                queue.append((*next_node,<span class="built_in">len</span>(path)-<span class="number">1</span>))</span><br><span class="line">                <span class="comment"># 标记为已经走过</span></span><br><span class="line">                maze[next_node[<span class="number">0</span>]][next_node[<span class="number">1</span>]] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">find_way(<span class="number">1</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure>





<h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p>对于两个相等的值,在排序后他们的顺序没有改变,那么这种算法就是稳定的</p>
<blockquote>
<p>简单来说:<br>不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。</p>
</blockquote>
<ul>
<li>冒泡排序稳定</li>
<li>选择排序不稳定</li>
<li>插入排序稳定</li>
<li>希尔排序不稳定</li>
<li>归并排序稳定</li>
<li>快速排序不稳定</li>
</ul>
<p><img src="/images/1564914467878.png" alt="1564914467878"></p>
<h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2><ol>
<li><p>lowB三人组 : 冒泡排序, 选择排序, 插入排序</p>
<ul>
<li>复杂度都是O(n^2)</li>
<li>这三个排序都有一个关键点:<code>有序区和无序区</code>.<strong>有序区不断变大,无序区不断变小</strong></li>
</ul>
</li>
<li><p>快速三人组 : 快速排序 , 堆排序 , 归并排序</p>
<ul>
<li><p>复杂度都是O(nlogn)</p>
</li>
<li><p>一般情况 : 快速排序 &lt; 归并排序 &lt; 堆排序</p>
</li>
<li><p>三种排序的缺点:</p>
<p>快速排序：极端情况下排序效率低.</p>
<p>归并排序：需要额外的内存开销.</p>
<p>堆排序：在快的排序算法中相对较慢.</p>
</li>
</ul>
</li>
<li><p>奇葩排序 : 希尔排序</p>
<ul>
<li>复杂度 : O(n^1.3)</li>
</ul>
</li>
</ol>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>性质1：在二叉树的第层上至多有2^(i-1）个结点（i&gt;0）</li>
<li>性质2：深度为k的二又树至多有2^k-1个结点（k&gt;0）</li>
<li>性质3：对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则NO=N2+1</li>
<li>性质4：具有n个结点的完全二叉树的深度必为log2(n+1）</li>
<li>性质5：<strong>对完全二叉树，若从上至下、从左至右编号，则编号为的结点，其左孩子编号必为2，其右孩子编号必为2i+1：其双亲的编号必为i/2（i=1时为根除外）</strong></li>
</ul>
<h2 id="树的广度遍历"><a href="#树的广度遍历" class="headerlink" title="树的广度遍历"></a>树的广度遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadth_tralvel</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    queue = [self.root]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">yield</span> cur_node.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur_node.lchild:</span><br><span class="line">            queue.append(cur_node.lchild)</span><br><span class="line">        <span class="keyword">if</span> cur_node.rchild:</span><br><span class="line">            queue.append(cur_node.rchild)</span><br></pre></td></tr></table></figure>



<h2 id="树的广度遍历-1"><a href="#树的广度遍历-1" class="headerlink" title="树的广度遍历"></a>树的广度遍历</h2><p>实际上,只要给出树的两种遍历(其一必须是<strong>中序遍历</strong>)就可以画出这棵树.</p>
<blockquote>
<p>因为中序遍历将左子树和右子树划分开来了</p>
</blockquote>
<h2 id="算法习题"><a href="#算法习题" class="headerlink" title="算法习题"></a>算法习题</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>有一个列表，列表中的数范围都在0到100之间，列表长度大约为100万。设计算法在O（n）时间复杂度内将列表进行排序。</p>
<blockquote>
<p>解题思路:</p>
<ul>
<li>创建一个字典,键为0-100,值为该数出现的次数</li>
<li>或者使用两个列表(甚至一个列表)</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    count_list = [<span class="number">0</span>] * <span class="number">101</span></span><br><span class="line">    <span class="comment"># 计算出现次数</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> alist:</span><br><span class="line">        count_list[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># idx就是数字,count_list[idx]就是出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">        <span class="keyword">if</span> count_list[idx]:</span><br><span class="line">            <span class="keyword">for</span> count <span class="keyword">in</span> <span class="built_in">range</span>(count_list[idx]):</span><br><span class="line">                <span class="keyword">yield</span> idx</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> sort([<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>]):</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<p>这种排序的限制:</p>
<blockquote>
<p>待排的数必须有范围(这里就是0-100)</p>
</blockquote>
<h3 id="TOP10-优先队列"><a href="#TOP10-优先队列" class="headerlink" title="TOP10(优先队列)"></a>TOP10(优先队列)</h3><p>现在有n个数（n&gt;10000），设计算法，按大小顺序得到前10大的数。</p>
<p>应用场景：榜单TOP10</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topk</span>(<span class="params">alist,k</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bin_insert</span>(<span class="params">val</span>):</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(top_k)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> top_k[mid] &gt; val:</span><br><span class="line">                left  = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> top_k[mid] &lt; val:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        top_k.insert(left,val)</span><br><span class="line">        top_k.pop()</span><br><span class="line"></span><br><span class="line">    top_k = <span class="built_in">sorted</span>(alist[:k],reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> alist[k:]:</span><br><span class="line">        <span class="keyword">if</span> num &gt; top_k[-<span class="number">1</span>]:</span><br><span class="line">            bin_insert(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top_k</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>]</span><br><span class="line">    <span class="built_in">print</span>(topk(x,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>当然也可以将<code>二分插入</code>改为<code>插入排序</code></p>
<blockquote>
<p>更好的方法是使用最小堆</p>
<p>解决思路：</p>
<ul>
<li>取列表前10个元素建立一个小根堆。堆顶就是目前第10大的数。</li>
<li>依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整</li>
<li>遍历列表所有元素后，倒序弹出堆顶</li>
</ul>
</blockquote>
<p>优先队列：<strong>一些元素的集合，POP操作每次执行都会从优先队列中弹出最大（或最小）的元素</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> nlargest</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>]</span><br><span class="line">x = nlargest(<span class="number">5</span>,alist)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># [45, 9, 9, 9, 9]</span></span><br></pre></td></tr></table></figure>



<h3 id="稍作修改的二分查找"><a href="#稍作修改的二分查找" class="headerlink" title="稍作修改的二分查找"></a>稍作修改的二分查找</h3><p>给定一个升序列表和一个整数，返回该整数在列表中的下标.<br>例如：列表[1，2，3，3，3，4，4，5]，若查找3，则返回(2,4).若查找1，则返回[0,0]</p>
<blockquote>
<p>只要找到之后,往左看看再往右看看即可.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_num</span>(<span class="params">alist,num</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(alist)</span><br><span class="line"></span><br><span class="line">    Found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> alist[mid] &gt; num:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> alist[mid] &lt; num:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> Found:</span><br><span class="line">        left = right = mid</span><br><span class="line">        <span class="keyword">while</span> left-<span class="number">1</span> &gt;=<span class="number">0</span> <span class="keyword">and</span> alist[left-<span class="number">1</span>] == num:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right+<span class="number">1</span> &lt;= <span class="built_in">len</span>(alist) <span class="keyword">and</span> alist[right+<span class="number">1</span>] == num:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (left,right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(find_num([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two-Sum"></a>Two-Sum</h3><p>给定一个列表和一个整数，设计算法找到两个数的下标，使得两个数之和为给定的整数。保证肯定仅有一个结果.<br>例如，列表[1，2，54] 与目标整数3，1+2=3，结果为(0,1)</p>
<blockquote>
<ul>
<li>使用字典储存即可</li>
<li><strong>使用字典解决了<code>计数排序</code>的”待排的数必须有范围”的问题</strong></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span>(<span class="params">alist,target</span>):</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)):</span><br><span class="line">        other_num = target - alist[idx]</span><br><span class="line">        <span class="keyword">if</span> other_num <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">            d[alist[idx]] = idx</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (d[other_num],idx)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(two_sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">25</span>],<span class="number">3</span>))</span><br></pre></td></tr></table></figure>











</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>