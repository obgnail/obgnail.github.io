<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;&gt;&lt;/a&gt;服务端&lt;/h2&gt;&lt;p&gt;用aiohttp构建我们的第一个应用程序"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>aiohttp中文文档2_服务端 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2019-08-21</div></div></div><div class="container post-header"><h1>aiohttp中文文档2_服务端</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="toc-number">1.1.</span> <span class="toc-text">快速开始</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%B0%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">走个流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">创建应用程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE"><span class="toc-number">1.1.3.</span> <span class="toc-text">创建视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1-url%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">创建路由(url分发器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%91%E5%AE%9Aroutes%E5%92%8Cviews"><span class="toc-number">1.1.5.</span> <span class="toc-text">绑定routes和views</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.6.</span> <span class="toc-text">构建数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.7.</span> <span class="toc-text">关闭数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.1.8.</span> <span class="toc-text">使用模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.9.</span> <span class="toc-text">静态文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.1.10.</span> <span class="toc-text">使用中间件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">启动一个简单的Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A5%E5%8F%A3%EF%BC%88CLI%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">使用命令行接口（CLI）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90%E5%92%8C%E8%B7%AF%E7%94%B1"><span class="toc-number">1.2.3.</span> <span class="toc-text">使用资源和路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B7%AF%E5%BE%84%E9%80%9A%E9%85%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用路径通配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#url%E7%9A%84%E5%8F%8D%E5%90%91%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.5.</span> <span class="toc-text">url的反向解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%A4%84%E7%90%86%E5%99%A8%E6%94%BE%E5%88%B0%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">将处理器放到类中使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%A7%86%E5%9B%BE"><span class="toc-number">1.2.7.</span> <span class="toc-text">资源视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.8.</span> <span class="toc-text">其他注册路由的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web-%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84%E5%8F%96%E6%B6%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.9.</span> <span class="toc-text">Web 处理器中的取消操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E5%87%86%E5%88%99"><span class="toc-number">1.2.10.</span> <span class="toc-text">自定义路由准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.2.11.</span> <span class="toc-text">静态文件的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.12.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9EJSON-%E5%93%8D%E5%BA%94"><span class="toc-number">1.2.13.</span> <span class="toc-text">返回JSON 响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.2.14.</span> <span class="toc-text">处理用户会话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86HTTP%E8%A1%A8%E5%8D%95"><span class="toc-number">1.2.15.</span> <span class="toc-text">处理HTTP表单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">1.2.16.</span> <span class="toc-text">文件上传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8WebSockets"><span class="toc-number">1.2.17.</span> <span class="toc-text">使用WebSockets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.2.18.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.19.</span> <span class="toc-text">数据共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.2.20.</span> <span class="toc-text">中间件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.2.21.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.22.</span> <span class="toc-text">嵌套应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.23.</span> <span class="toc-text">流控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Expect%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">1.2.24.</span> <span class="toc-text">使用Expect请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD"><span class="toc-number">1.2.25.</span> <span class="toc-text">优雅地关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.2.26.</span> <span class="toc-text">后台任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">底层服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APIs"><span class="toc-number">3.</span> <span class="toc-text">APIs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">请求类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%B7%E6%B1%82-BaseRequest"><span class="toc-number">3.1.1.</span> <span class="toc-text">基础请求(BaseRequest)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82-Request"><span class="toc-number">3.1.2.</span> <span class="toc-text">请求(Request)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">响应类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StreamResponse"><span class="toc-number">3.2.1.</span> <span class="toc-text">StreamResponse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Response"><span class="toc-number">3.2.2.</span> <span class="toc-text">Response</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocketResponse"><span class="toc-number">3.2.3.</span> <span class="toc-text">WebSocketResponse</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WebSocketReady"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">WebSocketReady</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#json-response"><span class="toc-number">3.2.4.</span> <span class="toc-text">json_response</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">应用类和路由器类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Application"><span class="toc-number">3.3.1.</span> <span class="toc-text">Application</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Server"><span class="toc-number">3.3.2.</span> <span class="toc-text">Server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Router"><span class="toc-number">3.3.3.</span> <span class="toc-text">Router</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource"><span class="toc-number">3.3.4.</span> <span class="toc-text">Resource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Route"><span class="toc-number">3.3.5.</span> <span class="toc-text">Route</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">4.</span> <span class="toc-text">问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%96%9C%E6%9D%A0%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">路由斜杠问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text">其他工具包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80"><span class="toc-number">6.</span> <span class="toc-text">参考网址</span></a></li></ol></details></div><div class="container post-content"><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>用aiohttp构建我们的第一个应用程序</p>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="走个流程"><a href="#走个流程" class="headerlink" title="走个流程"></a>走个流程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建app</span></span><br><span class="line">app = web.Application()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建视图函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">	<span class="keyword">return</span> web.Response(text=<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定url到视图函数</span></span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>,index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行app</span></span><br><span class="line">web.run_app(app, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<p><strong>创建app – 绑定路由 – 路由绑定视图函数 – 最后运行app</strong></p>
<h4 id="创建应用程序"><a href="#创建应用程序" class="headerlink" title="创建应用程序"></a>创建应用程序</h4><p>aiohttp的服务端程序都是 <code>aiohttp.web.Application</code>实例对象,也就是<strong>app对象</strong>。用于创建信号，连接路由等。</p>
<p>目录结构:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">polls_app</span><br><span class="line">    ├── main.py</span><br><span class="line">    ├── routes.py</span><br><span class="line">    └── views.py</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls_app/main.py</span></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建app</span></span><br><span class="line">app = web.Application()</span><br><span class="line">web.run_app(app, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls_app/views.py</span></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&#x27;Hello Aiohttp!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="创建路由-url分发器"><a href="#创建路由-url分发器" class="headerlink" title="创建路由(url分发器)"></a>创建路由(url分发器)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls_app/routes.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 就像Django中一样,要将视图函数导入urls.py</span></span><br><span class="line"><span class="keyword">from</span> views <span class="keyword">import</span> index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_routes</span>(<span class="params">app</span>):</span></span><br><span class="line">    app.router.add_get(<span class="string">&#x27;/&#x27;</span>, index)</span><br></pre></td></tr></table></figure>

<h4 id="绑定routes和views"><a href="#绑定routes和views" class="headerlink" title="绑定routes和views"></a>绑定routes和views</h4><p>在Django中,Django会帮我们自动绑定urls.py和views.py.<br>现在我们需要手动绑定,<strong>将路由连接到视图函数上</strong>.</p>
<p><strong>在main.py中调用routes.py里的setup_routes函数</strong>。将main函数修改为 : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># polls_app/main.py</span></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">from</span> routes <span class="keyword">import</span> setup_routes</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line"><span class="comment"># 给app绑定一个url</span></span><br><span class="line">setup_routes(app)</span><br><span class="line">web.run_app(app, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<p>流程分析:</p>
<ul>
<li><p>创建app</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = web.Application()</span><br></pre></td></tr></table></figure></li>
<li><p>为这个app绑定一个url,并且调用视图函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, index)</span><br></pre></td></tr></table></figure></li>
<li><p>这个视图函数返回一个Response对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&#x27;Hello Aiohttp!&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>运行这个app:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web.run_app(app, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="构建数据库"><a href="#构建数据库" class="headerlink" title="构建数据库"></a>构建数据库</h4><p>使用<code>SQLAlchemy</code>来写数据库架构</p>
<p>新增一个db.py(相当于Django里的Model.py)<br>当前目录结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">polls_app</span><br><span class="line">    ├── main.py</span><br><span class="line">    ├── db.py</span><br><span class="line">    ├── routes.py</span><br><span class="line">    └── views.py</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># db.py</span></span><br><span class="line"><span class="keyword">import</span> sqlalchemy <span class="keyword">as</span> sa </span><br><span class="line"><span class="keyword">import</span> aiopg</span><br><span class="line"></span><br><span class="line">meta = sa.MetaData()</span><br><span class="line"></span><br><span class="line">question = sa.Table(</span><br><span class="line">    <span class="string">&#x27;question&#x27;</span>, meta,</span><br><span class="line">    sa.Column(<span class="string">&#x27;id&#x27;</span>, sa.Integer, nullable=<span class="literal">False</span>),</span><br><span class="line">    sa.Column(<span class="string">&#x27;question_text&#x27;</span>, sa.String(<span class="number">200</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">    sa.Column(<span class="string">&#x27;pub_date&#x27;</span>, sa.Date, nullable=<span class="literal">False</span>),</span><br><span class="line">    <span class="comment"># Indexes </span></span><br><span class="line">    sa.PrimaryKeyConstraint(<span class="string">&#x27;id&#x27;</span>, name=<span class="string">&#x27;question_id_pkey&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">choice = sa.Table(</span><br><span class="line">    <span class="string">&#x27;choice&#x27;</span>, meta,</span><br><span class="line">    sa.Column(<span class="string">&#x27;id&#x27;</span>, sa.Integer, nullable=<span class="literal">False</span>),</span><br><span class="line">    sa.Column(<span class="string">&#x27;question_id&#x27;</span>, sa.Integer, nullable=<span class="literal">False</span>),</span><br><span class="line">    sa.Column(<span class="string">&#x27;choice_text&#x27;</span>, sa.String(<span class="number">200</span>), nullable=<span class="literal">False</span>),</span><br><span class="line">    sa.Column(<span class="string">&#x27;votes&#x27;</span>, server_default=<span class="string">&quot;0&quot;</span>, nullable=<span class="literal">False</span>),</span><br><span class="line">    <span class="comment"># Indexes #</span></span><br><span class="line">    sa.PrimayKeyConstraint(<span class="string">&#x27;id&#x27;</span>, name=<span class="string">&#x27;choice_id_pkey&#x27;</span>),</span><br><span class="line">    sa.ForeignKeyContraint([<span class="string">&#x27;question_id&#x27;</span>], [question.c.<span class="built_in">id</span>],</span><br><span class="line">                            name=<span class="string">&#x27;choice_question_id_fkey&#x27;</span>,</span><br><span class="line">                            ondelete=<span class="string">&#x27;CASCADE&#x27;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init_pg</span>(<span class="params">app</span>):</span></span><br><span class="line">    conf = app[<span class="string">&#x27;config&#x27;</span>]</span><br><span class="line">    engine = <span class="keyword">await</span> aiopg.sa.create_engine(</span><br><span class="line">        database=conf[<span class="string">&#x27;database&#x27;</span>],</span><br><span class="line">        user=conf[<span class="string">&#x27;user&#x27;</span>],</span><br><span class="line">        password=conf[<span class="string">&#x27;password&#x27;</span>],</span><br><span class="line">        host=conf[<span class="string">&#x27;host&#x27;</span>],</span><br><span class="line">        port=conf[<span class="string">&#x27;host&#x27;</span>],</span><br><span class="line">        minsize=conf[<span class="string">&#x27;minsize&#x27;</span>],</span><br><span class="line">        maxsize=conf[<span class="string">&#x27;maxsize&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    app[<span class="string">&#x27;db&#x27;</span>] = engine</span><br></pre></td></tr></table></figure>



<h4 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h4><p>程序退出时一块关闭所有的资源接口是一个很好的做法。<br><strong>使用on_cleanup信号来关闭数据库接口</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">close_pg</span>(<span class="params">app</span>):</span></span><br><span class="line">    app[<span class="string">&#x27;db&#x27;</span>].close()</span><br><span class="line">    <span class="keyword">await</span> app[<span class="string">&#x27;db&#x27;</span>].wait_closed()</span><br><span class="line"></span><br><span class="line">app.on_cleanup.append(close_pg)</span><br></pre></td></tr></table></figure>



<h4 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@aiohttp_jinja2.template(<span class="params"><span class="string">&#x27;detail.html&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">poll</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> request[<span class="string">&#x27;db&#x27;</span>].acquire() <span class="keyword">as</span> conn:</span><br><span class="line">        question_id = request.match_info[<span class="string">&#x27;question_id&#x27;</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            question, choices = <span class="keyword">await</span> db.get_question(conn,question_id)</span><br><span class="line">        <span class="keyword">except</span> db.RecordNotFound <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> web.HTTPNotFound(text=<span class="built_in">str</span>(e))</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;question&#x27;</span>: question,</span><br><span class="line">            <span class="string">&#x27;choices&#x27;</span>: choices</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>之后还要注册模板</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp_jinja2</span><br><span class="line"><span class="keyword">import</span> jinja2</span><br><span class="line"></span><br><span class="line">aiohttp_jinja2.setup(app, loader=jinja2.PackageLoader(<span class="string">&#x27;aiohttpdemo_polls&#x27;</span>, <span class="string">&#x27;templates&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_static(<span class="string">&#x27;/static/&#x27;</span>,</span><br><span class="line">                      path=<span class="built_in">str</span>(project_root / <span class="string">&#x27;static&#x27;</span>),</span><br><span class="line">                      name=<span class="string">&#x27;static&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="使用中间件"><a href="#使用中间件" class="headerlink" title="使用中间件"></a>使用中间件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_middlewares</span>(<span class="params">app</span>):</span></span><br><span class="line">    error_middleware = error_pages(&#123;<span class="number">404</span>: handle_404,</span><br><span class="line">                                    <span class="number">500</span>: handle_500&#125;)</span><br><span class="line">    app.middlewares.append(error_middleware)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_pages</span>(<span class="params">overrides</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">middleware</span>(<span class="params">app, handler</span>):</span></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">middleware_handler</span>(<span class="params">request</span>):</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                response = <span class="keyword">await</span> handler(request)</span><br><span class="line">                override = overrides.get(response.status)</span><br><span class="line">                <span class="keyword">if</span> override <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> response</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">await</span> override(request, response)</span><br><span class="line">            <span class="keyword">except</span> web.HTTPException <span class="keyword">as</span> ex:</span><br><span class="line">                override = overrides.get(ex.status)</span><br><span class="line">                <span class="keyword">if</span> override <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">raise</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">await</span> override(request, ex)</span><br><span class="line">        <span class="keyword">return</span> middleware_handler</span><br><span class="line">    <span class="keyword">return</span> middleware</span><br></pre></td></tr></table></figure>

<p>这些<code>overrides（handle_404和handle_500）</code>只是简单的用<code>Jinja2</code>模板渲染:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_404</span>(<span class="params">request, response</span>):</span></span><br><span class="line">    response = aiohttp_jinja2.render_template(<span class="string">&#x27;404.html&#x27;</span>,request,&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_500</span>(<span class="params">request, response</span>):</span></span><br><span class="line">    response = aiohttp_jinja2.render_template(<span class="string">&#x27;500.html&#x27;</span>,request,&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>



<h3 id="启动一个简单的Web服务器"><a href="#启动一个简单的Web服务器" class="headerlink" title="启动一个简单的Web服务器"></a>启动一个简单的Web服务器</h3><p>部署web服务器首先要创建一个 请求处理器（request handler）。<br>请求处理器可以是协程方法也可以是普通方法，它只有一个用于接受<code>Request</code>实例对象的参数，之后会返回<code>Response</code>实例对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&quot;Hello, world&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>hello(request)</code>这个协程就像是Django中的<strong>视图函数</strong>,在这里被称为<code>请求处理器</code></p>
</blockquote>
<p>创建应用（Appliaction）并将请求处理器配置到应用的路由</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = web.Application()</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, hello)</span><br></pre></td></tr></table></figure>

<p>调用<code>run_app()</code>来启动应用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web.run_app(app)</span><br></pre></td></tr></table></figure>



<h4 id="使用命令行接口（CLI）"><a href="#使用命令行接口（CLI）" class="headerlink" title="使用命令行接口（CLI）"></a>使用命令行接口（CLI）</h4><p><code>aiohttp.web</code>带有一个基于TCP/IP的基本命令行接口，用于<strong>快速启动一个应用</strong>(Application)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m aiohttp.web -H localhost -P 8080 package.module:init_func</span><br></pre></td></tr></table></figure>

<p><code>package.module:init_func</code>应是一个可导入，调用的对象，有一个接受包含命令行参数列表的参数，配置好之后返回<code>Application</code>对象</p>
<blockquote>
<p>简单来说,有两种启动服务器方式:</p>
<ul>
<li><p>使用命令行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">	<span class="keyword">return</span> web.Response(text=<span class="string">&#x27;hello world2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_func</span>(<span class="params">argv</span>):</span></span><br><span class="line">    app = web.Application()</span><br><span class="line">    app.router.add_get(<span class="string">&quot;/&quot;</span>, index)</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>

<p>执行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m aiohttp.web -H localhost -P <span class="number">8081</span> test:init_func</span><br></pre></td></tr></table></figure></li>
<li><p>使用python模块:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建app</span></span><br><span class="line">app = web.Application()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建视图函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">	<span class="keyword">return</span> web.Response(text=<span class="string">&#x27;hello world2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定url到视图函数</span></span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>,index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行app</span></span><br><span class="line">web.run_app(app, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<p>之后执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tesy.py</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="使用处理器"><a href="#使用处理器" class="headerlink" title="使用处理器"></a>使用处理器</h4><p>就像前面说的,aiohttp的处理器就像是Django里的视图函数.</p>
<p>处理器对象可以被任意调用，它只接受<code>Request</code>实例对象，并且返回<code>StreamResponse</code>的派生对象实例（如<code>Response</code>）:</p>
<p>处理器可以是函数也可以是协程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response()</span><br></pre></td></tr></table></figure>

<p>处理器必须被注册在路由上才能使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, handler)</span><br><span class="line">app.router.add_post(<span class="string">&#x27;/post&#x27;</span>, post_handler)</span><br><span class="line">app.router.add_put(<span class="string">&#x27;/put&#x27;</span>, put_handler)</span><br></pre></td></tr></table></figure>

<p><code>add_route()</code>同样支持使用通配符方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_route(<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/path&#x27;</span>, all_handler)</span><br></pre></td></tr></table></figure>

<p>可以使用<code>Request.method</code>来获知请求所使用的HTTP方法。</p>
<h4 id="使用资源和路由"><a href="#使用资源和路由" class="headerlink" title="使用资源和路由"></a>使用资源和路由</h4><ul>
<li><code>app.router.add_get</code>或<code>app.router.add_post</code>其实是<code>app.router.add_route(method, handler)</code>的子类方法</li>
<li>同样,<code>app.router.add_route(method, handler)</code>是<code>app.router..add_resource(path, name=name)</code>的子类方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_get(<span class="string">&#x27;/&#123;name&#125;&#x27;</span>,index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">resource = app.router.add_resource(<span class="string">&#x27;/&#123;name&#125;&#x27;</span>)</span><br><span class="line">resource.add_route(<span class="string">&#x27;GET&#x27;</span>, index)</span><br></pre></td></tr></table></figure>



<h4 id="使用路径通配"><a href="#使用路径通配" class="headerlink" title="使用路径通配"></a>使用路径通配</h4><p>比如，如果某一路径是<code>&#39;/a/&#123;name&#125;/c&#39;</code>，那<code>&#39;/a/b/c&#39;, &#39;/a/1/c&#39;，&#39;/a/etc/c&#39;</code>，这样的路径就都可以匹配到。<br>使用<code>Request.match_info</code>来完成这一操作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建视图函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&quot;Hello, &#123;&#125;&quot;</span>.<span class="built_in">format</span>(request.match_info[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通配</span></span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#123;name&#125;&#x27;</span>,index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行app</span></span><br><span class="line">web.run_app(app, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<p><code>&#123;name&#125;</code>的背后其实就是正则表达式,<br>所以,我们也可以像Django一样,使用自定义正则表达式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_get(<span class="string">r&#x27;/&#123;name:\d+&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="url的反向解析"><a href="#url的反向解析" class="headerlink" title="url的反向解析"></a>url的反向解析</h4><p>和django一样,aiohttp同样支持url反向解析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, name=<span class="string">&#x27;index&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>之后可以访问和构建此资源的URL:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">request</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;***********************************&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(request.app.router[<span class="string">&#x27;info&#x27;</span>])</span><br><span class="line">	<span class="built_in">print</span>(request.app.router[<span class="string">&#x27;info&#x27;</span>].url_for())</span><br><span class="line">	<span class="built_in">print</span>(request.app.router[<span class="string">&#x27;info&#x27;</span>].url_for().with_query(&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>: <span class="string">&quot;d&quot;</span>&#125;))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;***********************************&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> web.Response(text=<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line"></span><br><span class="line">app.router.add_get(<span class="string">r&#x27;/info&#x27;</span>,info,name=<span class="string">&#x27;info&#x27;</span>)</span><br><span class="line">web.run_app(app, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问http://127.0.0.1:8080/info</span></span><br><span class="line"><span class="comment"># ***********************************</span></span><br><span class="line"><span class="comment"># &lt;PlainResource &#x27;info&#x27;  /info&gt;</span></span><br><span class="line"><span class="comment"># /info</span></span><br><span class="line"><span class="comment"># /info?a=b&amp;c=d</span></span><br><span class="line"><span class="comment"># ***********************************</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">request</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;***********************************&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(request.app.router[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">	<span class="built_in">print</span>(request.app.router[<span class="string">&#x27;name&#x27;</span>].url_for(name=<span class="string">&#x27;hyl&#x27;</span>))</span><br><span class="line">	<span class="built_in">print</span>(request.app.router[<span class="string">&#x27;name&#x27;</span>].url_for(name=<span class="string">&#x27;hyl&#x27;</span>).with_query(&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>: <span class="string">&quot;d&quot;</span>&#125;))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;***********************************&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> web.Response(text=<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line"></span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#123;name&#125;&#x27;</span>,info,name=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">web.run_app(app, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问http://127.0.0.1:8080/asdasdada</span></span><br><span class="line"><span class="comment"># ***********************************</span></span><br><span class="line"><span class="comment"># &lt;PlainResource &#x27;name&#x27;  /asdasdada&gt;</span></span><br><span class="line"><span class="comment"># /hyl</span></span><br><span class="line"><span class="comment"># /hyl?a=b&amp;c=d</span></span><br><span class="line"><span class="comment"># ***********************************</span></span><br></pre></td></tr></table></figure>



<h4 id="将处理器放到类中使用"><a href="#将处理器放到类中使用" class="headerlink" title="将处理器放到类中使用"></a>将处理器放到类中使用</h4><p>将具有同样逻辑的一组路由放到类中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, hello)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_intro</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> web.Response(text=<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_greeting</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        name = request.match_info.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&quot;Anonymous&quot;</span>)</span><br><span class="line">        txt = <span class="string">&quot;Hello, &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name)</span><br><span class="line">        <span class="keyword">return</span> web.Response(text=txt)</span><br><span class="line"></span><br><span class="line">handler = Handler()</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/intro&#x27;</span>, handler.handle_intro)</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/greet/&#123;name&#125;&#x27;</span>, handler.handle_greeting)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 :</p>
<ul>
<li>这与Django不太一致,Django的视图类是针对同一个url请求,分成不同的方法(get,post)等等</li>
<li>但是aiohttp已经使用<code>add_get</code>来明确标明请求方法,所以这个类只是<strong>将一些url的处理函数组合起来而已</strong>.</li>
</ul>
<p>但是,如果不使用<code>add_get</code>方法,而是使用<code>add_route</code>,就可以使用类似django风格的基础视图类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span>(<span class="params">web.View</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> get_resp(self.request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> post_resp(self.request)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 第一参数是请求方法,&#x27;*&#x27;表示任何方法都行,第二参数是路径,第三参数是处理器</span></span><br><span class="line">app.router.add_route(<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/path/to&#x27;</span>, MyView)</span><br></pre></td></tr></table></figure>

<p><strong>此时的处理器必须是一个协程方法，且只接受self参数</strong></p>
</blockquote>
<h4 id="资源视图"><a href="#资源视图" class="headerlink" title="资源视图"></a>资源视图</h4><p>所有在路由中注册的资源都可使用<code>UrlDispatcher.routes()</code>查看:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> resource <span class="keyword">in</span> app.router.routes():</span><br><span class="line">    <span class="built_in">print</span>(resource)</span><br></pre></td></tr></table></figure>

<p>有<code>name</code>的资源可以用<code>UrlDispatcher.named_routes()</code>来查看:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, resource <span class="keyword">in</span> app.router.named_routes().items():</span><br><span class="line">    <span class="built_in">print</span>(name, resource)</span><br></pre></td></tr></table></figure>



<h4 id="其他注册路由的方式"><a href="#其他注册路由的方式" class="headerlink" title="其他注册路由的方式"></a>其他注册路由的方式</h4><ul>
<li>路由表<br>(Django风格)</li>
<li>路由装饰器<br>(Flask风格)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路由表</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_get</span>(<span class="params">request</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_post</span>(<span class="params">request</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">app.router.add_routes([web.get(<span class="string">&#x27;/echo&#x27;</span>, handle_get),</span><br><span class="line">                       web.post(<span class="string">&#x27;/&#123;name&#125;&#x27;</span>, handle_post),</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line">routes = web.RouteTableDef()</span><br><span class="line"></span><br><span class="line"><span class="meta">@routes.get(<span class="params"><span class="string">&#x27;/get&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_get</span>(<span class="params">request</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@routes.post(<span class="params"><span class="string">&#x27;/post&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_post</span>(<span class="params">request</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">app.router.add_routes(routes)</span><br></pre></td></tr></table></figure>



<h4 id="Web-处理器中的取消操作"><a href="#Web-处理器中的取消操作" class="headerlink" title="Web 处理器中的取消操作"></a>Web 处理器中的取消操作</h4><p>web处理器中<strong>每一条await语句都可被取消</strong>，这种情况一般发生在客户端还没有完全读取响应体然后中断了连接。<br>与著名WSGI架构 如Flask和Django在这点上有所不同。</p>
<blockquote>
<ul>
<li>在处理GET请求时，代码可能会从数据库或其他web资源中获取数据，这些查询可能很慢。 </li>
<li>这时候取消查询是最好的: 该连接已经被抛弃了，没有理由再浪费时间和资源(内存等)进行查询，已经没有机会响应了。</li>
</ul>
</blockquote>
<p>为了预防被取消掉,生成一个新的任务不靠谱，这样不能等待:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    request.loop.create_task(write_to_redis(request))</span><br><span class="line">    <span class="keyword">return</span> web.Response(<span class="string">&#x27;OK&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>预防被取消掉可以用下列几种方法:</p>
<ul>
<li>使用 <code>asyncio.shield()</code> 来进行存进数据库的处理。</li>
<li>开启一个存入数据库的协程任务。</li>
<li>使用<code>aiojobs</code>或其他第三方库。</li>
</ul>
<p><code>asyncio.shield()</code> 挺不错的，保护协同程序不会被退出。唯一的缺点是你需要分清哪些是需要得到保护的代码哪些不是。</p>
<p>使用<code>@atomic</code>装饰器可以使整个处理器都防止有取消操作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiojobs.aiohttp <span class="keyword">import</span> atomic</span><br><span class="line"></span><br><span class="line"><span class="meta">@atomic</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">await</span> write_to_db()</span><br><span class="line">    <span class="keyword">return</span> web.Response()</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">setup(app)</span><br><span class="line">app.router.add_post(<span class="string">&#x27;/&#x27;</span>, handler)</span><br></pre></td></tr></table></figure>



<h4 id="自定义路由准则"><a href="#自定义路由准则" class="headerlink" title="自定义路由准则"></a>自定义路由准则</h4><p>下面代码就是:<br>对应首页网址,只接受请求头的accept为<code>&#39;application/json&#39;</code>或<code>&#39;application/xml&#39;</code>的请求</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcceptChooser</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._accepts = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_route</span>(<span class="params">self, request</span>):</span></span><br><span class="line">    	<span class="comment"># 获取accept请求头的参数</span></span><br><span class="line">        <span class="keyword">for</span> accept <span class="keyword">in</span> request.headers.getall(<span class="string">&#x27;ACCEPT&#x27;</span>, []):</span><br><span class="line">            <span class="comment"># 获取处理器</span></span><br><span class="line">            acceptor = self._accepts.get(accept)</span><br><span class="line">            <span class="comment"># 如果存在该处理器</span></span><br><span class="line">            <span class="keyword">if</span> acceptor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">await</span> acceptor(request))</span><br><span class="line">        <span class="keyword">raise</span> HTTPNotAcceptable()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reg_acceptor</span>(<span class="params">self, accept, handler</span>):</span></span><br><span class="line">        self._accepts[accept] = handler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_json</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># do json handling</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle_xml</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># do xml handling</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">chooser = AcceptChooser()</span><br><span class="line"></span><br><span class="line">chooser.reg_acceptor(<span class="string">&#x27;application/json&#x27;</span>, handle_json)</span><br><span class="line">chooser.reg_acceptor(<span class="string">&#x27;application/xml&#x27;</span>, handle_xml)</span><br><span class="line"></span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, chooser.do_route)</span><br></pre></td></tr></table></figure>



<h4 id="静态文件的处理"><a href="#静态文件的处理" class="headerlink" title="静态文件的处理"></a>静态文件的处理</h4><p>处理静态文件( 图片，JavaScripts, CSS文件等)最好的方法是使用反向代理，像是nginx或CDN服务。</p>
<ul>
<li><p>通过 <code>UrlDispatcher.add_static()</code>注册个新的静态路由:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_static(<span class="string">&#x27;/prefix&#x27;</span>, path_to_static_folder)</span><br></pre></td></tr></table></figure></li>
<li><p>当访问静态文件的目录时，默认服务器会返回 HTTP/403 Forbidden。<br>使用<code>show_index</code>并将其设置为<code>True</code>可以显示出索引:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_static(<span class="string">&#x27;/prefix&#x27;</span>, path_to_static_folder, show_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>当从静态文件目录访问一个符号链接（软链接）时，默认服务器会响应 HTTP/404 Not Found(未找到)。<br>使用<code>follow_symlinks</code>并将其设置为<code>True</code>可以让服务器使用符号链接:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_static(<span class="string">&#x27;/prefix&#x27;</span>, path_to_static_folder, follow_symlinks=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>如果你想允许缓存清除，使用<code>append_version</code>并设为<code>True</code>。</p>
<blockquote>
<p>缓存清除会对资源文件像JavaScript 和 CSS文件等的文件名上添加一个<strong>hash后的版本</strong>。这样的好处是我们可以让浏览器无限期缓存这些文件而不用担心这些文件是否发布了新版本。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.router.add_static(<span class="string">&#x27;/prefix&#x27;</span>, path_to_static_folder, append_version=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>使用第三方库 <code>aiohttp_jinja2</code></p>
<p>首先我们用<code>aiohttp_jinja2.setup()</code>来设置下<code>jinja2</code>环境:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp_jinja2</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">aiohttp_jinja2.setup(app,loader=jinja2.FileSystemLoader(<span class="string">&#x27;/path/to/templates/folder&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>然后将模板引擎应用到处理器中。最简单的方式是使用<code>aiohttp_jinja2.templates()</code>装饰器:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@aiohttp_jinja2.template(<span class="params"><span class="string">&#x27;tmpl.jinja2&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;surname&#x27;</span>: <span class="string">&#x27;Svetlov&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>



<h4 id="返回JSON-响应"><a href="#返回JSON-响应" class="headerlink" title="返回JSON 响应"></a>返回JSON 响应</h4><p>使用 aiohttp.web.json_response()可以返回JSON响应:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;some&#x27;</span>: <span class="string">&#x27;data&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> web.json_response(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类似于Django的<code>return JsonResponse(&#123;...&#125;, safe=False)</code></p>
<p>这个方法返回的是<code>aiohttp.web.Response</code>实例对象，所以你可以做些其他的事，比如设置cookies。</p>
</blockquote>
<h4 id="处理用户会话"><a href="#处理用户会话" class="headerlink" title="处理用户会话"></a>处理用户会话</h4><p>通过请求存储用户数据的仓库。一般简称为会话。</p>
<p><code>aiohttp.web</code>没有内置会话，不过你可以使用第三方库<code>aiohttp_session</code>来提供会话支持:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> cryptography <span class="keyword">import</span> fernet</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">from</span> aiohttp_session <span class="keyword">import</span> setup, get_session, session_middleware</span><br><span class="line"><span class="keyword">from</span> aiohttp_session.cookie_storage <span class="keyword">import</span> EncryptedCookieStorage</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">	<span class="comment"># 获取session</span></span><br><span class="line">    session = <span class="keyword">await</span> get_session(request)</span><br><span class="line">    last_visit = session[<span class="string">&#x27;last_visit&#x27;</span>] <span class="keyword">if</span> <span class="string">&#x27;last_visit&#x27;</span> <span class="keyword">in</span> session <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    text = <span class="string">&#x27;Last visited: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(last_visit)</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span>():</span></span><br><span class="line">    app = web.Application()</span><br><span class="line">    <span class="comment"># 设置secret_key</span></span><br><span class="line">    fernet_key = fernet.Fernet.generate_key()</span><br><span class="line">    <span class="comment"># secret_key必须是32位的url安全的经过base64编码的字节</span></span><br><span class="line">    secret_key = base64.urlsafe_b64decode(fernet_key)</span><br><span class="line"></span><br><span class="line">    setup(app, EncryptedCookieStorage(secret_key))</span><br><span class="line"></span><br><span class="line">    app.router.add_route(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, handler)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line">web.run_app(make_app())</span><br></pre></td></tr></table></figure>



<h4 id="处理HTTP表单"><a href="#处理HTTP表单" class="headerlink" title="处理HTTP表单"></a>处理HTTP表单</h4><ul>
<li><p>如果表单的方法是 “GET”，要使用<code>Request.query</code>获取数据。</p>
</li>
<li><p>如果是“POST”则用<code>Request.post()</code>或 <code>Request.multipart()</code> 获取数据。</p>
<blockquote>
<ul>
<li><code>Request.post()</code>接受标明为<code>&#39;application/x-www-form-urlencoded&#39;</code>和<code>&#39;multipart/form-data&#39;</code> 的数据（）。</li>
<li>它会将数据存进一个临时字典中。如果指定了<code>client_max_size</code>，超出了的话会抛出<code>ValueError</code>异常，</li>
<li>这时使用<code>Request.multipart()</code>是更好的选择，尤其是在上传大文件时。</li>
</ul>
</blockquote>
</li>
</ul>
<p>由以下表单发送的数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/login&quot;</span> method=<span class="string">&quot;post&quot;</span> accept-charset=<span class="string">&quot;utf-8&quot;</span></span><br><span class="line">      enctype=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;login&quot;</span>&gt;Login&lt;/label&gt;</span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">id</span>=<span class="string">&quot;login&quot;</span> name=<span class="string">&quot;login&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;&quot;</span> autofocus/&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;password&quot;</span>&gt;Password&lt;/label&gt;</span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">id</span>=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;login&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>可以用以下方法获取:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_login</span>(<span class="params">request</span>):</span></span><br><span class="line">    data = <span class="keyword">await</span> request.post()</span><br><span class="line">    login = data[<span class="string">&#x27;login&#x27;</span>]</span><br><span class="line">    password = data[<span class="string">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>首先呢我们要确保标签的有<code>enctype</code>元素并且设置为了<code>&quot;multipart/form-data&quot;</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/store/mp3&quot;</span> method=<span class="string">&quot;post&quot;</span> accept-charset=<span class="string">&quot;utf-8&quot;</span></span><br><span class="line">      enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;mp3&quot;</span>&gt;Mp3&lt;/label&gt;</span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">id</span>=<span class="string">&quot;mp3&quot;</span> name=<span class="string">&quot;mp3&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;file&quot;</span> value=<span class="string">&quot;&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>请求处理器中接受这个文件，它变成了一个<code>FileField</code>实例对象。</p>
<blockquote>
<ul>
<li><code>Reuest.post()</code>会把所有数据读到内容</li>
<li>用<code>Request.multipart()</code>返回的是<code>multipart</code>读取器。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">store_mp3_handler</span>(<span class="params">request</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意，如果是个很大的文件不要用这种方法。</span></span><br><span class="line">    data = <span class="keyword">await</span> request.post()</span><br><span class="line"></span><br><span class="line">    mp3 = data[<span class="string">&#x27;mp3&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># .filename 包含该文件的名称，是个字符串。</span></span><br><span class="line">    filename = mp3.filename</span><br><span class="line"></span><br><span class="line">    <span class="comment"># .file 包含该文件的内容。</span></span><br><span class="line">    mp3_file = data[<span class="string">&#x27;mp3&#x27;</span>].file</span><br><span class="line"></span><br><span class="line">    content = mp3_file.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> web.Response(body=content,</span><br><span class="line">                        <span class="comment"># mp3_file是一个二进制文件,使用MultiDict</span></span><br><span class="line">                        headers=MultiDict(</span><br><span class="line">                            &#123;<span class="string">&#x27;CONTENT-DISPOSITION&#x27;</span>: mp3_file&#125;))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">store_mp3_handler</span>(<span class="params">request</span>):</span></span><br><span class="line"></span><br><span class="line">    reader = <span class="keyword">await</span> request.multipart()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 激活生成器</span></span><br><span class="line">    mp3 = <span class="keyword">await</span> reader.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">    filename = mp3.filename</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是分块传输的，别用Content-Length做判断。</span></span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(<span class="string">&#x27;/spool/yarrr-media/mp3/&#x27;</span>, filename), <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            chunk = <span class="keyword">await</span> mp3.read_chunk()  <span class="comment"># 默认是8192个字节。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            size += <span class="built_in">len</span>(chunk)</span><br><span class="line">            f.write(chunk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&#x27;&#123;&#125; sized of &#123;&#125; successfully stored&#x27;</span></span><br><span class="line">                             <span class="string">&#x27;&#x27;</span>.<span class="built_in">format</span>(filename, size))</span><br></pre></td></tr></table></figure>



<h4 id="使用WebSockets"><a href="#使用WebSockets" class="headerlink" title="使用WebSockets"></a>使用WebSockets</h4><p>在处理器中创建一个<code>WebSocketResponse</code>对象即可设置<code>WebSocket</code>，之后即可进行通信:</p>
<p>websocket使用GET方法注册</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用HTTP GET方法注册</span></span><br><span class="line">app.router.add_get(<span class="string">&#x27;/ws&#x27;</span>, websocket_handler)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">websocket_handler</span>(<span class="params">request</span>):</span></span><br><span class="line"></span><br><span class="line">    ws = web.WebSocketResponse()</span><br><span class="line">    <span class="keyword">await</span> ws.prepare(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> msg <span class="keyword">in</span> ws:</span><br><span class="line">        <span class="keyword">if</span> msg.<span class="built_in">type</span> == aiohttp.WSMsgType.TEXT:</span><br><span class="line">            <span class="keyword">if</span> msg.data == <span class="string">&#x27;close&#x27;</span>:</span><br><span class="line">                <span class="keyword">await</span> ws.close()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">await</span> ws.send_str(msg.data + <span class="string">&#x27;/answer&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">elif</span> msg.<span class="built_in">type</span> == aiohttp.WSMsgType.ERROR:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;ws connection closed with exception %s&#x27;</span> %ws.exception())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;websocket connection closed&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ws</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>从<code>WebSocket</code>中读取数据（<code>await ws.receive()</code>）必须在请求处理器内部完成，</li>
<li>不过写数据（<code>ws.send_str(...)</code>），关闭（<code>await ws.close()</code>）和取消操作可以在其他任务中完成。</li>
</ul>
</blockquote>
<blockquote>
<p>注意 : </p>
<p>不要从websocket中并行地读取数据，aiohttp.web.WebSocketResponse.receive()不能在分布在两个任务中同时调用。</p>
</blockquote>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li><code>aiohttp.web</code>定义了所有HTTP状态码的异常。</li>
<li>每个异常都是<code>HTTPException</code>的子类，同样还都是<code>Response</code>的子类</li>
<li>所以就允许你在请求处理器中返回或抛出它们。 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> aiohttp.web.HTTPFound(<span class="string">&#x27;/redirect&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>异常等级图:</p>
<blockquote>
<p>HTTPException<br>    HTTPSuccessful<br>      * 200 - HTTPOk<br>            * 201 - HTTPCreated<br>            * 202 - HTTPAccepted<br>                  * 203 - HTTPNonAuthoritativeInformation<br>                  * 204 - HTTPNoContent<br>                        * 205 - HTTPResetContent<br>                        * 206 - HTTPPartialContent<br>                    HTTPRedirection<br>                              * 300 - HTTPMultipleChoices<br>                                    * 301 - HTTPMovedPermanently<br>                                    * 302 - HTTPFound<br>                                          * 303 - HTTPSeeOther<br>                                          * 304 - HTTPNotModified<br>                                                * 305 - HTTPUseProxy<br>                                                * 307 - HTTPTemporaryRedirect<br>                                                      * 308 - HTTPPermanentRedirect<br>                                    HTTPError<br>                                                      HTTPClientError<br>        * 400 - HTTPBadRequest<br>        * 401 - HTTPUnauthorized<br>        * 402 - HTTPPaymentRequired<br>        * 403 - HTTPForbidden<br>        * 404 - HTTPNotFound<br>        * 405 - HTTPMethodNotAllowed<br>        * 406 - HTTPNotAcceptable<br>        * 407 - HTTPProxyAuthenticationRequired<br>        * 408 - HTTPRequestTimeout<br>        * 409 - HTTPConflict<br>        * 410 - HTTPGone<br>        * 411 - HTTPLengthRequired<br>        * 412 - HTTPPreconditionFailed<br>        * 413 - HTTPRequestEntityTooLarge<br>        * 414 - HTTPRequestURITooLong<br>        * 415 - HTTPUnsupportedMediaType<br>        * 416 - HTTPRequestRangeNotSatisfiable<br>        * 417 - HTTPExpectationFailed<br>        * 421 - HTTPMisdirectedRequest<br>        * 422 - HTTPUnprocessableEntity<br>        * 424 - HTTPFailedDependency<br>        * 426 - HTTPUpgradeRequired<br>        * 428 - HTTPPreconditionRequired<br>        * 429 - HTTPTooManyRequests<br>        * 431 - HTTPRequestHeaderFieldsTooLarge<br>        * 451 - HTTPUnavailableForLegalReasons<br>            HTTPServerError<br>        * 500 - HTTPInternalServerError<br>        * 501 - HTTPNotImplemented<br>        * 502 - HTTPBadGateway<br>        * 503 - HTTPServiceUnavailable<br>        * 504 - HTTPGatewayTimeout<br>        * 505 - HTTPVersionNotSupported<br>        * 506 - HTTPVariantAlsoNegotiates<br>        * 507 - HTTPInsufficientStorage<br>        * 510 - HTTPNotExtended<br>        * 511 - HTTPNetworkAuthenticationRequired</p>
</blockquote>
<p>所有的异常都拥有相同的结构:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPNotFound(*, headers=<span class="literal">None</span>, reason=<span class="literal">None</span>,body=<span class="literal">None</span>, text=<span class="literal">None</span>, content_type=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果没有指定headers，默认是响应中的headers。 </p>
</li>
<li><p>其中<code>HTTPMultipleChoices, HTTPMovedPermanently, HTTPFound, HTTPSeeOther, HTTPUseProxy, HTTPTemporaryRedirect</code>的结构是下面这样的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPFound(location, *, headers=<span class="literal">None</span>, reason=<span class="literal">None</span>,body=<span class="literal">None</span>, text=<span class="literal">None</span>, content_type=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>location参数的值会写入到HTTP头部的Location中。</p>
</li>
<li><p><code>HTTPMethodNotAllowed</code>的结构是这样的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPMethodNotAllowed(method, allowed_methods, *,headers=<span class="literal">None</span>, reason=<span class="literal">None</span>,body=<span class="literal">None</span>, text=<span class="literal">None</span>, content_type=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>method是不支持的那个方法，allowed_methods是所支持的方法。</p>
</li>
</ul>
<h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><ul>
<li><p>aiohttp.web<strong>不推荐使用全局变量进行数据共享</strong>。每个变量应在自己的上下文中而不是全局可用的。</p>
</li>
<li><p><code>aiohttp.web.Application</code>和<code>aiohttp.web.Request</code>提供<code>collections.abc.MutableMapping(类字典对象)</code>来存储数据。</p>
<blockquote>
<p>将<strong>类全局变量存储到Application实例对象中</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app[<span class="string">&#x27;my_private_key&#x27;</span>] = data</span><br></pre></td></tr></table></figure>

<p>之后就可以在web处理器中获取出来:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    data = request.app[<span class="string">&#x27;my_private_key&#x27;</span>]</span><br></pre></td></tr></table></figure>



<p>如果变量的生命周期是一次请求，可以存储在请求中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">  request[<span class="string">&#x27;my_private_key&#x27;</span>] = <span class="string">&quot;data&quot;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>中间件是一个协程程序帮助<strong>修正请求和响应</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp.web <span class="keyword">import</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在响应中添加&#x27;wink&#x27;字符串:</span></span><br><span class="line"><span class="meta">@middleware</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">middleware</span>(<span class="params">request, handler</span>):</span></span><br><span class="line">    resp = <span class="keyword">await</span> handler(request)</span><br><span class="line">    resp.text = resp.text + <span class="string">&#x27; wink&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于流式响应和websockets该例子不起作用</p>
</blockquote>
<blockquote>
<p>每个中间件需要接受两个参数，一个是请求实例另一个是处理器，中间件需要返回响应内容。</p>
</blockquote>
<p>创建<code>Application</code>时，可以通过<code>middlewares</code>参数传递中间件过去:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = web.Application(middlewares=[middleware_1, middleware_2])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>中间件写法有点像python里的上下文管理器context manager装饰器的写法,<br>一个函数同时处理<code>__enter__</code>和<code>__exit__</code>事件.<br>web.middleware也一样,<strong>一个函数同时处理request和response</strong>.</p>
<ul>
<li>contextlib.contextmanager使用yield分开两个事件</li>
<li>web.middleware使用await分开request和response的处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createContextManager</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;__enter__ %s&#x27;</span> %  name</span><br><span class="line">    <span class="keyword">yield</span> name</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;__exit__ %s&#x27;</span> % name</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">@web.middleware</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">middleware1</span>(<span class="params">request, handler</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Middleware 1 called&#x27;</span>)</span><br><span class="line">    response = <span class="keyword">await</span> handler(request)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Middleware 1 finished&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></li>
<li><p>和Django,Scrapy的中间件一样,<strong>正序处理request,逆序处理response</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Handler function called&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@web.middleware</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">middleware1</span>(<span class="params">request, handler</span>):</span></span><br><span class="line">    <span class="comment"># 处理request</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Middleware 1 called&#x27;</span>)</span><br><span class="line">    response = <span class="keyword">await</span> handler(request)</span><br><span class="line">    <span class="comment"># 处理response</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Middleware 1 finished&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="meta">@web.middleware</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">middleware2</span>(<span class="params">request, handler</span>):</span></span><br><span class="line">    <span class="comment"># 处理request</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Middleware 2 called&#x27;</span>)</span><br><span class="line">    response = <span class="keyword">await</span> handler(request)</span><br><span class="line">    <span class="comment"># 处理response</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Middleware 2 finished&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = web.Application(middlewares=[middleware1, middleware2])</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, test)</span><br><span class="line">web.run_app(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Middleware 1 called</span></span><br><span class="line"><span class="comment"># Middleware 2 called</span></span><br><span class="line"><span class="comment"># Handler function called</span></span><br><span class="line"><span class="comment"># Middleware 2 finished</span></span><br><span class="line"><span class="comment"># Middleware 1 finished</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>Django的中间件除了处理request和response,还可以处理error.<br>aiohttp也可以</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_error</span>(<span class="params">message</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(</span><br><span class="line">        body=json.dumps(&#123;<span class="string">&#x27;error&#x27;</span>: message&#125;).encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">        content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@web.middleware</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">error_middleware</span>(<span class="params">request, handler</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = <span class="keyword">await</span> handler(request)</span><br><span class="line">        <span class="keyword">if</span> response.status == <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> json_error(response.message)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">except</span> web.HTTPException <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="keyword">if</span> ex.status == <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> json_error(ex.reason)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">app = web.Application(middlewares=[error_middleware])</span><br></pre></td></tr></table></figure>



<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>尽管中间件可以自定义之前和之后的处理行为，但并不能自定义响应中的行为。所以信号量由此而生。</p>
<blockquote>
<p>比如，中间件只能改变没有预定义HTTP头的响应的HTTP 头（看<code>on_prepare()</code>），但有时我们需要一个可以改变流式响应和<em>WebSockets HTTP头</em>的钩子。所以我们可以用<code>on_response_prepare</code>信号来充当这个钩子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">on_prepare</span>(<span class="params">request, response</span>):</span></span><br><span class="line">    response.headers[<span class="string">&#x27;My-Header&#x27;</span>] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line"></span><br><span class="line">app.on_response_prepare.append(on_prepare)</span><br></pre></td></tr></table></figure>

<p>简单来说就是,<strong>每当response准备好的时候就会触发on_prepare</strong></p>
</blockquote>
<p>此外，你也可以用<code>on_startup</code>和<code>on_cleanup</code>信号来捕获应用开启和释放时的状态。<br>解释说,每当app运行和结束前会执行create_aiopg和dispose_aiopg函数.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiopg.sa <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_aiopg</span>(<span class="params">app</span>):</span></span><br><span class="line">    app[<span class="string">&#x27;pg_engine&#x27;</span>] = <span class="keyword">await</span> create_engine(</span><br><span class="line">        user=<span class="string">&#x27;postgre&#x27;</span>,</span><br><span class="line">        database=<span class="string">&#x27;postgre&#x27;</span>,</span><br><span class="line">        host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">        port=<span class="number">5432</span>,</span><br><span class="line">        password=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">dispose_aiopg</span>(<span class="params">app</span>):</span></span><br><span class="line">    app[<span class="string">&#x27;pg_engine&#x27;</span>].close()</span><br><span class="line">    <span class="keyword">await</span> app[<span class="string">&#x27;pg_engine&#x27;</span>].wait_closed()</span><br><span class="line"></span><br><span class="line">app.on_startup.append(create_aiopg)</span><br><span class="line">app.on_cleanup.append(dispose_aiopg)</span><br></pre></td></tr></table></figure>



<h4 id="嵌套应用"><a href="#嵌套应用" class="headerlink" title="嵌套应用"></a>嵌套应用</h4><p>就像Django有很多app一样,aiohttp也支持多个app.</p>
<p>创建名为 admin 的子应用，我们可以用<code>add_subapp()</code>来完成:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admin = web.Application()</span><br><span class="line"><span class="comment"># setup admin routes, signals and middlewares</span></span><br><span class="line"></span><br><span class="line">app.add_subapp(<span class="string">&#x27;/admin/&#x27;</span>, admin)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>主应用和子应用间的中间件和信号是一个环一样的结构。 </p>
</li>
<li><p>也就是说如果请求<code>&#39;/admin/something&#39;</code>会<strong>先调用主应用的中间件然后在调用子应用（<code>admin.middlewares</code>）的中间件。</strong> 信号也同样。</p>
</li>
<li><p>所有注册的基础信号如<code>on_startup，on_shutdown，on_cleanup</code>都会给子应用也注册一份。只不过传递的参数是子应用。 </p>
</li>
<li><p>子应用也可以嵌套子应用。 子应用也可以使用Url反向引用，只不过会带上前缀:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">admin = web.Application()</span><br><span class="line">admin.router.add_get(<span class="string">&#x27;/resource&#x27;</span>, handler, name=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.add_subapp(<span class="string">&#x27;/admin/&#x27;</span>, admin)</span><br><span class="line"></span><br><span class="line">url = admin.router[<span class="string">&#x27;name&#x27;</span>].url_for()   <span class="comment"># url为&#x27;/admin/resource&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果<strong>主应用想得到子应用</strong>的Url反向引用，可以给主app注册一个变量指向子app:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">admin = web.Application()</span><br><span class="line">admin.router.add_get(<span class="string">&#x27;/resource&#x27;</span>, handler, name=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.add_subapp(<span class="string">&#x27;/admin/&#x27;</span>, admin)</span><br><span class="line"><span class="comment"># 给主app注册一个变量指向子app</span></span><br><span class="line">app[<span class="string">&#x27;admin&#x27;</span>] = admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span>  <span class="comment"># main application&#x27;s handler</span></span><br><span class="line">    admin = request.app[<span class="string">&#x27;admin&#x27;</span>]</span><br><span class="line">    url = admin.router[<span class="string">&#x27;name&#x27;</span>].url_for()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h4><p><code>aiohttp.web</code>有复杂的流控制机制来应对底层TCP套接字写入缓存。<br>问题是: 默认情况下TCP套接字使用Nagle算法来输出缓存，但这种算法对于流式数据协议如HTTP不是很理想。</p>
<p>Web服务器的响应是以下几种状态其中一个:</p>
<ol>
<li>CORK（tcp_cork设置为True）。这个选项不会发送一部分TCP/IP帧。当这个选项被（再次）清除时会发送所有已经在队列中的片段帧。因为会把各种小帧聚合起来发送，所以这种方式对发送大量片段数据非常理想。 如果操作系统不支持CORK模式（不管是socket.TCP_CORK还是socket.TCP_NOPUSH）那该模式与Nagle模式一样。一般来说是windows系统不支持此模式。</li>
<li>NODELAY（tcp_nodelay设置为True）。这个选项会禁用Nagle算法。选用这个那么无论数据多小都会尽快发出去，即使是很小的数据。该模式对发送少量数据非常理想。</li>
<li>Nagle算法（tcp_cork和tcp_nodelay都为False）。该模式会先缓存数据，直到达到预定的数据大小后再一起发送。如果要发送HTTP数据应该避免使用这个模式除非你确定要使用它。</li>
</ol>
<p>默认情况下，<em>流数据</em>（<code>StreamResponse</code>）,<em>标准响应</em>（<code>Response</code>和http异常及其派生类）和<em>websockets</em>（<code>WebSocketResponse</code>）使用NODELAY模式，静态文件处理器使用CORK模式。</p>
<p>可以使用<code>set_tcp_cork(</code>)方法和<code>set_tcp_nodelay()</code>方法手动切换。</p>
<h4 id="使用Expect请求头"><a href="#使用Expect请求头" class="headerlink" title="使用Expect请求头"></a>使用Expect请求头</h4><blockquote>
<p>Expect是一个请求消息头,包含一个期望条件,表示服务器只有在满足此期望条件的情况下才能妥善地处理请求。</p>
</blockquote>
<ul>
<li>aiohttp.web支持使用Expect头。默认是HTTP/1.1 100 Continue，如果Expect头不是<code>&quot;100-continue&quot;</code>则抛出<code>HTTPExpectationFailed</code>异常。</li>
<li>你可以自定义<code>Expect头</code>处理器。如果<code>Expect头</code>存在的话则会调用<code>Expect处理器</code>，<code>Expect处理器</code>会先于中间件和路由处理器被调用。</li>
<li><code>Expect处理器</code>的返回值 :<ol>
<li>可以返回<code>None</code>，返回<code>None</code>则会继续执行（调用中间件和路由处理器）。</li>
<li>如果返回的是<code>StreamResponse</code>实例对象，之后请求处理器则使用该返回对象作为响应内容。</li>
<li>也可以抛出<code>HTTPException</code>的子类对象。抛出错误的时候之后的处理将不会进行，客户端将会接受一个适当的http响应。</li>
</ol>
</li>
</ul>
<p>自定义expect请求处理器:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">check_auth</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.version != aiohttp.HttpVersion11:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.headers.get(<span class="string">&#x27;EXPECT&#x27;</span>) != <span class="string">&#x27;100-continue&#x27;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPExpectationFailed(text=<span class="string">&quot;Unknown Expect: %s&quot;</span> % expect)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.headers.get(<span class="string">&#x27;AUTHORIZATION&#x27;</span>) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPForbidden()</span><br><span class="line"></span><br><span class="line">    request.transport.write(<span class="string">b&quot;HTTP/1.1 100 Continue\r\n\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(body=<span class="string">b&quot;Hello, world&quot;</span>)</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line"><span class="comment"># 设置expect请求的处理器</span></span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, hello, expect_handler=check_auth)</span><br></pre></td></tr></table></figure>



<h4 id="优雅地关闭"><a href="#优雅地关闭" class="headerlink" title="优雅地关闭"></a>优雅地关闭</h4><ul>
<li>停止<code>aiohttp web</code>服务器时只关闭打开的连接时不够的。 因为可能会有一些<code>websockets</code>或流，在服务器关闭时这些连接还是打开状态。 </li>
<li>开发者可以使用<code>Applicaiton.on_shutdown</code>信号来完善这一功能。</li>
</ul>
<p>关闭websocket处理器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭websocket处理器</span></span><br><span class="line">app = web.Application()</span><br><span class="line">app[<span class="string">&#x27;websockets&#x27;</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">websocket_handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    ws = web.WebSocketResponse()</span><br><span class="line">    <span class="keyword">await</span> ws.prepare(request)</span><br><span class="line"></span><br><span class="line">    request.app[<span class="string">&#x27;websockets&#x27;</span>].append(ws)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> msg <span class="keyword">in</span> ws:</span><br><span class="line">            ...</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        request.app[<span class="string">&#x27;websockets&#x27;</span>].remove(ws)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号处理器：</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">on_shutdown</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="keyword">for</span> ws <span class="keyword">in</span> app[<span class="string">&#x27;websockets&#x27;</span>]:</span><br><span class="line">        <span class="keyword">await</span> ws.close(code=WSCloseCode.GOING_AWAY,</span><br><span class="line">                       message=<span class="string">&#x27;Server shutdown&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.on_shutdown.append(on_shutdown)</span><br></pre></td></tr></table></figure>



<p>合适的关闭程序要注意以下:</p>
<ol>
<li>不再接受新的连接。注意调用<code>asyncio.Server.close()</code>和<code>asyncio.Server.wait_closed()</code>来关闭。</li>
<li>解除<code>Application.shutdown()</code>事件。</li>
<li>在一小段延迟后调用<code>Server.shutdown()</code>关闭已经开启的连接。</li>
<li>发出<code>Application.cleanup()</code>信号。</li>
</ol>
<p>下列代码演示从开始到结束：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">handler = app.make_handler()</span><br><span class="line"></span><br><span class="line">f = loop.create_server(handler, <span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">8080</span>)</span><br><span class="line">srv = loop.run_until_complete(f)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;serving on&#x27;</span>, srv.sockets[<span class="number">0</span>].getsockname())</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    loop.run_forever()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    srv.close()</span><br><span class="line">    loop.run_until_complete(srv.wait_closed())</span><br><span class="line">    loop.run_until_complete(app.shutdown())</span><br><span class="line">    loop.run_until_complete(handler.shutdown(<span class="number">60.0</span>))</span><br><span class="line">    loop.run_until_complete(app.cleanup())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>



<h4 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h4><ul>
<li>例如创建一个后台任务，用于在zmq.SUB套接字上监听ZeroMQ，然后通过<code>WebSocket（app[&#39;websockets&#39;]）</code>处理并转发接收到的消息给客户端。 </li>
<li>使用<code>Application.on_startup</code>信号注册的后台任务可以让这些任务在应用的请求处理器执行时一并执行。 比如我们需要一个一次性的任务和两个常驻任务。最好的方法是通过信号注册：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">listen_to_redis</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sub = <span class="keyword">await</span> aioredis.create_redis((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">6379</span>), loop=app.loop)</span><br><span class="line">        ch, *_ = <span class="keyword">await</span> sub.subscribe(<span class="string">&#x27;news&#x27;</span>)</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> msg <span class="keyword">in</span> ch.<span class="built_in">iter</span>(encoding=<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">            <span class="comment"># Forward message to all connected websockets:</span></span><br><span class="line">            <span class="keyword">for</span> ws <span class="keyword">in</span> app[<span class="string">&#x27;websockets&#x27;</span>]:</span><br><span class="line">                ws.send_str(<span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(ch.name, msg))</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">await</span> sub.unsubscribe(ch.name)</span><br><span class="line">        <span class="keyword">await</span> sub.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">start_background_tasks</span>(<span class="params">app</span>):</span></span><br><span class="line">    app[<span class="string">&#x27;redis_listener&#x27;</span>] = app.loop.create_task(listen_to_redis(app))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cleanup_background_tasks</span>(<span class="params">app</span>):</span></span><br><span class="line">    app[<span class="string">&#x27;redis_listener&#x27;</span>].cancel()</span><br><span class="line">    <span class="keyword">await</span> app[<span class="string">&#x27;redis_listener&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">app.on_startup.append(start_background_tasks)</span><br><span class="line">app.on_cleanup.append(cleanup_background_tasks)</span><br><span class="line">web.run_app(app)</span><br></pre></td></tr></table></figure>

<p><code>listen_to_redis()</code>将会一直运行下去。当关闭时发出的<code>on_cleanup</code>信号会调用关闭处理器以关闭它。</p>
<h2 id="底层服务器"><a href="#底层服务器" class="headerlink" title="底层服务器"></a>底层服务器</h2><ul>
<li>有时候用户不需要更高级的封装，像是 application，routers和signals。 只是需要一个支持异步调用并且是接受请求返回响应对象的东西。</li>
<li>在aiohttp.web.Server类中有介绍过一个服务协议工厂——<code>asyncio.AbstractEventLoop.create_server()</code>，</li>
<li>他可以将数据流<strong>桥接到web处理器</strong>以及反馈结果。 底层web处理器应该接收单个<code>BaseRequest</code>参数并且执行下列中的其中一个:<ol>
<li>返回一个包含HTTP响应体的响应对象。</li>
<li>创建一个<code>StreamResponse</code>对象，然后可以调用<code>StreamResponse.prepare()</code>发送头信息，调用<code>StreamResponse.write() / StreamResponse.drain()</code>发送数据块，最后结束响应。</li>
<li>抛出<code>HTTPException</code>派生的异常（看<a target="_blank" rel="noopener" href="https://github.com/HuberTRoy/aiohttp-chinese-document/blob/master/aiohttp%E6%96%87%E6%A1%A3/ServerUsage.md#%E5%BC%82%E5%B8%B8">Exception</a>部分）。</li>
<li>使用<code>WebSocketResponse</code>发起/处理Web-Socket连接。</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">loop</span>):</span></span><br><span class="line">    server = web.Server(handler)</span><br><span class="line">    <span class="keyword">await</span> loop.create_server(server, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;======= Serving on http://127.0.0.1:8080/ ======&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pause here for very long time by serving HTTP requests and</span></span><br><span class="line">    <span class="comment"># waiting for keyboard interruption</span></span><br><span class="line">    <span class="comment"># 通过提供HTTP请求并等待键盘中断，在此暂停很长时间</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>*<span class="number">3600</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    loop.run_until_complete(main(loop))</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>这个处理器可以接受所有的请求: 不论<code>GET, POST, Web-Socket</code>都可以，无论哪一个路径的访问也都同样由其处理。 不过也同样很基础: 无论如何处理器都只返回<code>200 OK</code>。实际生活中所产生的状态要复杂的多。</p>
<h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><h3 id="请求类"><a href="#请求类" class="headerlink" title="请求类"></a>请求类</h3><h4 id="基础请求-BaseRequest"><a href="#基础请求-BaseRequest" class="headerlink" title="基础请求(BaseRequest)"></a>基础请求(BaseRequest)</h4><ul>
<li>Request 对象中包含所有的HTTP请求信息。<br>Request对象拥有Request.app和Request.match_info属性。</li>
<li>BaseRequest 用在底层服务器中（底层服务器没有应用，路由，信号和中间件）。</li>
<li>BaseRequest和Reuqest都是类字典对象，以便在中间件和信号处理器中共享数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">BaseRequest</span></span></span><br></pre></td></tr></table></figure>

<p>属性:</p>
<ul>
<li><p>version :  发起请求的HTTP版本，该属性只读。</p>
</li>
<li><p>method : 发起请求的HTTP方法，该属性只读。</p>
</li>
<li><p>url : 包含资源的绝对路径的URL实例对象。</p>
</li>
<li><p>rel_url : 包含资源的相对路径的URL实例对象。与.url.relative()相同。</p>
</li>
<li><p>host : 主机名</p>
</li>
<li><p>remote : 初始化HTTP请求的IP地址。</p>
</li>
<li><p>path_qs : 包含路径信息和查询字符串的URL（如<code>/app/blog?id=10</code>）</p>
</li>
<li><p>path : 包含路径信息但不含有主机（host）或协议（scheme）的URL（/app/blog）。路径是URL解码（URL-unquoted）后的。</p>
</li>
<li><p>raw_path : 同 path ,路径是没有经过URL解码的。(如<code>/my%2Fpath%7Cwith%21some%25strange%24characters</code>)</p>
</li>
<li><p>query : 带有查询字符串的并联字典。</p>
</li>
<li><p>headers : 请求头</p>
</li>
<li><p>transport :  用于处理请求的传输端口，该属性只读。<br>该属性可以被用在获取客户端 peer的IP地址时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peername = request.transport.get_extra_info(<span class="string">&#x27;peername&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> peername <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    host, port = peername</span><br></pre></td></tr></table></figure></li>
<li><p>cookies</p>
</li>
<li><p>content : StreamReader实例对象，用于读取请求的主体（BODY）的输入流。</p>
</li>
<li><p>content_type : 返回Content-Type头信息的内容，该属性只读。类型是str，如’text/html’。<br>同理还有<code>charset</code>,<code>content_length</code>,<code>http_range</code></p>
</li>
</ul>
<p>方法 :</p>
<ul>
<li><p>clone(*, method=…, rel_url=…, headers=…)<br>克隆自己，并将相应的值替换。</p>
<blockquote>
<p>创建并返回一个新Request实例对象。如果没有传递任何参数，将会复制一份一模一样的。如果没有传递某一个参数，那个值与原值一样。</p>
</blockquote>
</li>
<li><p>coroutine json(*, loads=json.loads)<br>读取请求主体，以JSON形式返回。</p>
</li>
<li><p>coroutine multipart(*, reader=aiohttp.multipart.MultipartReader)<br>返回一个用于处理即将到来的multipart请求的<code>aiohttp.multipart.MultipartReader</code>对象。</p>
</li>
</ul>
<h4 id="请求-Request"><a href="#请求-Request" class="headerlink" title="请求(Request)"></a>请求(Request)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">Request</span></span></span><br></pre></td></tr></table></figure>

<p>在web处理器中接受请求信息的Request类。<br>所有的处理器的第一个参数都要接受Request类的实例对象。<br><strong>该类派生于BaseRequest</strong>，支持父类中所有的方法和属性。还有几个额外的：</p>
<ul>
<li>match_info : 返回AbstractMatchInfo实例对象，内容是路由解析的结果，该属性只读。</li>
<li>app : 返回一个用于调用请求处理器的应用（Application）实例对象。</li>
</ul>
<h3 id="响应类"><a href="#响应类" class="headerlink" title="响应类"></a>响应类</h3><p>aiohttp.web提供三个不同的响应类: <code>StreamResponse</code>, <code>Response</code>和<code>FileResponse</code>。</p>
<p><code>StreamResponse</code>用于流数据，<code>Response</code>的父类是<code>StreamResponse</code>。</p>
<h4 id="StreamResponse"><a href="#StreamResponse" class="headerlink" title="StreamResponse"></a>StreamResponse</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">StreamResponse</span>(<span class="params">*, header,status=<span class="number">200</span>, reason=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>参数 :</p>
<ul>
<li>status (int)</li>
<li>reason (int)</li>
<li>task : 一个承载请求处理的任务。在关闭服务器时对于那些需要长时间运行的请求（流内容，长轮询或web-socket）非常有用。</li>
<li>chunked : 指代是否使用了分块编码，该属性只读。可以通过调用enable_chunked_encoding()开启分块编码。</li>
<li>cookies</li>
<li>content_length , 同理还有 content_type charset last_modified</li>
</ul>
<p>方法 :</p>
<ul>
<li><p>set_cookie(name, value, *, path=’/‘, expires=None, domain=None, max_age=None, secure=None, httponly=None, version=None)</p>
<blockquote>
<ul>
<li>name (str) - cookie名称。</li>
<li>value (str) - cookie值（如果是其他类型的话会尝试转换为str类型）</li>
<li>expires - 过期时间（可选）。</li>
<li>domain (str) - cookie主域（可选）。</li>
<li>max_age (int) - 定义cookie的生命时长，以秒为单位。该参数为非负整数。在经过这些秒后，客户端会抛弃该cookie。如果设置为0则表示立即抛弃。</li>
<li>path (str) - 设置该cookie应用在哪个路径上（可选，默认是’/‘）。</li>
<li>secure (bool) - 该属性（没有任何值）会让用户代理使用安全协议。用户代理（或许会在用户控制之下）需要决定安全等级，在适当的时候考虑使用“安全”cookie。是不是要使用“安全”要考虑从服务器到用户代理的这段历程，“安全”协议的目的是保证会话在安全情况下进行（可选）。</li>
<li>httponly (bool) - 如果要设置为HTTP only则为True（可选）。</li>
<li>version (int) - 一个十进制数，表示使用哪个版本的cookie管理（可选，默认为1）。</li>
</ul>
</blockquote>
<blockquote>
<p>expires 和 max_age 功能一致.但是建议使用max_age</p>
</blockquote>
</li>
<li><p>del_cookie(name, *, path=’/‘. domain=None)<br>删除某cookie。</p>
</li>
<li><p>corotine prepare(request)<br>发送HTTP头信息出去。<br>在调用了该方法之后你就不要在修改任何头信息的数据了。该方法同时会调用on_response_prepare信号所连接的处理器。</p>
</li>
<li><p>write(data)<br>发送byte-ish数据，该数据作为响应主体的一部分。<br>需要在此之前调用<code>prepare()</code>。</p>
</li>
<li><p>coroutine write_eof()<br>一个可以作为HTTP响应结束标志的协程方法。<br>如果需要的话，<strong>内部会在完成请求处理后调用这个方法</strong>。<br>调用write_eof()后，任何对响应对象的操作都是禁止的。</p>
</li>
</ul>
<h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">Response</span>(<span class="params">*, body=<span class="literal">None</span>, status=<span class="number">200</span>, reason=<span class="literal">None</span>, text=<span class="literal">None</span>, headers=<span class="literal">None</span>, content_type=<span class="literal">None</span>, charset=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>最常用的响应类，继承于<code>StreamResponse</code>。StreamResponse的参数和方法不赘述。</p>
<p>参数 :</p>
<ul>
<li>body(bytes)  : 响应主体。类型为bytes。</li>
<li>text(str) : 响应主体。类型为str。</li>
<li>status </li>
<li>headers </li>
<li>content_type(str) : 响应的内容类型。</li>
</ul>
<h4 id="WebSocketResponse"><a href="#WebSocketResponse" class="headerlink" title="WebSocketResponse"></a>WebSocketResponse</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">WebSocketResponse</span>(<span class="params">\, timeout=<span class="number">10.0</span>, receive_timeout=<span class="literal">None</span>, autoclose=<span class="literal">True</span>, autoping=<span class="literal">True</span>, heartbeat=<span class="literal">None</span>, protocols=(<span class="params"></span>), compress=<span class="literal">True</span></span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用于进行服务端处理websockets的类。</li>
<li>调用prepare()后你就不能在使用write()方法了，但你仍然可以与websocket客户端通过send_str(), receive()等方法沟通。</li>
</ul>
<blockquote>
<p>为什么websocket的相关方法必须是协程?</p>
<p>为了支持缓慢的websockets所带来的背压现象（back-pressure，服务器达到可连接的上限，而这时又有新的客户端请求连接就会出现背压)</p>
</blockquote>
<p>参数:</p>
<ul>
<li><p>autoping (bool) - 自动向发送了PING消息的客户端发送PONG消息，以及自动处理客户端的PONG响应。需要注意的是该方法不会自动向客户端发送PING消息，你需要自己调用ping()方法实现。</p>
</li>
<li><p>heartbeat (float) - 每一次心跳都发送ping消息并等待pong消息，如果没有接收到pong响应则关闭连接。</p>
</li>
<li><p>receive_timeout (float) - 接收操作的超时时间。默认是None也就是不限时间。</p>
</li>
<li><p>compress (bool) - 允许每一次消息都使用deflate扩展。传入False禁止此功能。默认是True。</p>
<blockquote>
<p>该类支持<code>async for</code>语句来<strong>对即将到来的消息进行迭代</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws = web.WebSocketResponse()</span><br><span class="line"><span class="keyword">await</span> ws.prepare(request)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> msg <span class="keyword">in</span> ws:</span><br><span class="line">    <span class="built_in">print</span>(msg.data)</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>方法:</p>
<ul>
<li>coroutine prepare(request)<br>开启websocket。调用此方法后你就可以使用其他的websockets方法了。</li>
<li>coroutine send_str(data)<br>向peer发送TEXT(文本)消息。</li>
<li>coroutine send_bytes(data)<br>向peer发送BINARY(二进制)消息。</li>
<li>corotine close(*, code=1000, message=b’’)<br>一个初始化关闭握手消息的协程方法。5不同任务中的close()调用会被保留。</li>
<li>coroutine receive(timeout=None)<br>等待peer即将发来的数据消息并返回它的协程方法。<br>该方法在PING，PONG和CLOSE处理时都有调用，但并不返回。<br>该方法在内部会执行ping-pong游戏和closing握手。</li>
<li>coroutine receive_str(*, timeout=None)<br>调用receive()方法，并判断其消息类型是否为TEXT(文本)。</li>
<li>coroutine receive_bytes(*, timeout=None)<br>调用receive()方法，并判断其消息类型是否为BINARY(二进制)。</li>
<li>coroutine receive_json(*, loads=json.loads,timeout=None)<br>调用receive_str()方法，并将JSON字符串转换为Python字典（dict）。</li>
</ul>
<h5 id="WebSocketReady"><a href="#WebSocketReady" class="headerlink" title="WebSocketReady"></a>WebSocketReady</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">WebSocketReady</span></span></span><br></pre></td></tr></table></figure>

<p><code>WebSocketResponse.can_prepare()</code>所返回的对象。可使用bool类型判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">await</span> ws.can_prepare(...):</span><br><span class="line">    cannot_start_websocket()</span><br></pre></td></tr></table></figure>



<h4 id="json-response"><a href="#json-response" class="headerlink" title="json_response"></a>json_response</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aiohttp.web.json_response([data, ]*, text=<span class="literal">None</span>, body=<span class="literal">None</span>, status=<span class="number">200</span>, reason=<span class="literal">None</span>, headers=<span class="literal">None</span>, content_type=<span class="string">&#x27;application/json&#x27;</span>, dumps=json.dumps)</span><br></pre></td></tr></table></figure>

<p>返回内容为JSON数据（默认由json.dumps()转换），并带有’application/json’信息的响应对象。</p>
<h3 id="应用类和路由器类"><a href="#应用类和路由器类" class="headerlink" title="应用类和路由器类"></a>应用类和路由器类</h3><h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p>应用（Application）是web服务器的代名词。</p>
<blockquote>
<p>要得到完整地可工作例子，你必须创建应用（Application）和路由器（Router）并且使用<code>Server</code>创建服务器套接字作为协议工厂。<em>Server</em>可以使用<code>Application.make_handler()</code>来创建。</p>
</blockquote>
<p>应用(Application)还是一个类字典对象，所以你可以用它作为全局共享数据容器，你可以在处理器中使用Request.app来访问它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app = Application()</span><br><span class="line">app[<span class="string">&#x27;database&#x27;</span>] = <span class="keyword">await</span> aiopg.create_engine(**db_config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handler</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">with</span> (<span class="keyword">await</span> request.app[<span class="string">&#x27;database&#x27;</span>]) <span class="keyword">as</span> conn:</span><br><span class="line">        conn.execute(<span class="string">&quot;DELETE * FROM table&quot;</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">Application</span>(<span class="params">*, logger= , router=<span class="literal">None</span>, middlewares=(<span class="params"></span>), handler_args=<span class="literal">None</span>, client_max_size=<span class="number">1024</span>**<span class="number">2</span>, loop=<span class="literal">None</span>, debug=...</span>) </span></span><br></pre></td></tr></table></figure>

<p><strong>Application类继承于dict</strong>。</p>
<ul>
<li>logger - logging.Logger实例对象，用于存储应用程序的日志。默认值为<code>logging.getLogger(&quot;aiohttp.web&quot;)</code></li>
<li>router - aiohttp.abc.AbstractRouter实例对象，如果是None则默认创建<code>UrlDispatcher</code>。</li>
<li>middlewares - 存放中间件工厂的列表。</li>
<li>handler_args - 类字典对象，用于覆盖<code>Application.make_handler()</code>中的关键字参数。</li>
<li>client_max_size - 客户端请求中携带的数据的最大大小。如果POST请求超过这个值，将会抛出<code>HTTPRequestEntityTooLarge</code>异常。</li>
<li>loop - 事件循环。自2.0版本后不再赞成使用：在冻结阶段Loop会被自动设置。</li>
<li>debug - 调试组件。</li>
</ul>
<p>信号:</p>
<ul>
<li><p>on_response_prepare<br>一个在<code>StreamResponse.prepare()</code>执行时发送的信号，触发信号时将请求（request）和响应（response）对象作为参数传递。在某些情况下很有用，比如说，你想为每个响应都添加一个自定义头信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">on_prepare</span>(<span class="params">request, response</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
<li><p>on_startup<br>一个在应用程序开启时触发的信号。我们可以捕获这个信号来做一些后台任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">on_startup</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
<li><p>on_shutdown<br>一个在应用程序关闭时触发的信号。我们可以捕获这个信号来做一些对于需要长时间运行的连接的清理工作（websockets和数据流之类的）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">on_shutdown</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
<li><p>on_cleanup<br>一个在应用程序执行清理时发送的信号。我们可以捕获这个信号来优雅的关闭数据库服务器之类的连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">on_cleanup</span>(<span class="params">app</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>方法:</p>
<ul>
<li><p>make_handler(loop=None, **kwargs)<br>创建一个处理请求的HTTP协议工厂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">app = Application()</span><br><span class="line"></span><br><span class="line"><span class="comment"># setup route table</span></span><br><span class="line"><span class="comment"># app.router.add_route(...)</span></span><br><span class="line"><span class="keyword">await</span> loop.create_server(app.make_handler(), <span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">8080</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>coroutine startup()<br>一个会与应用程序的请求处理器一起调用的协程方法。<br>该方法的目的是调用on_startup信号所连接的处理器。</p>
</li>
<li><p>coroutine shutdown()<br>该方法应该在服务器正在停止且在（要）调用cleanup()前调用。<br>该方法会调用on_shutdown信号所连接的处理器。</p>
</li>
<li><p>coroutine cleanup()<br>该方法应该在服务器正在停止且在（要）调用shutdown()后调用。<br>该方法会调用on_cleanup信号所连接的处理器。</p>
</li>
</ul>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>一个与<code>create_server()</code>兼容的协议工厂。</p>
<p>class aiohttp.web.Server<br>该类用于创建处理HTTP连接的HTTP协议对象。</p>
<p>Server.connections<br>一个包含当前已开启的连接的列表。</p>
<p>aiohttp.web.request_count<br>已处理请求的总数。</p>
<p>coroutine Server.shutdown(timeout)<br>一个用于关闭所有已开启连接的协程方法。</p>
<h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>用于将分发URL到特定的处理器，aiohttp.web使用路由来建立联系。<br>路由可以是任何部署了<code>AbstractRouter</code>接口的对象。<br>aiohttp.web提供的部署方式为<code>UrlDispatcher</code>。<br><code>Application</code>也使用<code>UrlDispatcher</code>作为<code>router()</code>的默认返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">UrlDispatcher</span></span></span><br></pre></td></tr></table></figure>

<p>最直接地url匹配型路由，同时具有<code>collections.abc.Mapping</code>的功能，可以用于访问已命名的路由。</p>
<ul>
<li><p>add_resource(path, *, name=None)<br>添加一个资源到路由表尾部。<br>path可以只是字符串’/a/b/c’，也可以带变量’/a/{var}’。</p>
</li>
<li><p>add_route(method, path, handler, *, name=None, expect_handler=None)<br>添加一个处理器到路由表尾部。<br>path可以只是字符串’/a/b/c’，也可以带变量’/a/{var}’。</p>
<blockquote>
<p>注意: 如果处理器是一个普通函数，aiohttp会在内部将其转换为协程函数。</p>
</blockquote>
</li>
<li><p>add_routes(routes_table)<br>从路由表（routes_table）中注册路由。<br>路由表（routes_table）需要是包含RouteDef组件或RouteTableDef的列表。</p>
</li>
<li><p>add_get(path, handler, *, name=None, allow_head=True, **kwargs)<br>添加GET方法路由的快捷方式。等价于调用add_route(method=’GET’)。</p>
<blockquote>
<p>同理:<br>add_post(path, handler, **kwargs)</p>
<p>add_put(path, handler, **kwargs)</p>
<p>add_patch(path, handler, **kwargs)</p>
<p>add_delete(path, handler, **kwargs)</p>
</blockquote>
</li>
<li><p>add_static(prefix, path, <em>, name=None, expect_handler=None, chunk_size=256</em>1024, response_factory=StreamResponse, show_index=False, follow_symlinks=False, append_version=False)<br><strong>添加一个用于返回静态文件的路由和处理器</strong>。对于获取图片，js和css等文件非常有用。</p>
<blockquote>
<p>add_static()仅用于开发。生存环境中，静态文件功能应由wbe服务器（比如nginx,apache）提供。</p>
</blockquote>
</li>
<li><p>add_subapp(prefix, subapp)<br>在给定路径前缀下注册一个嵌套子应用。<br>以定前缀开始的请求会交由subapp处理。</p>
</li>
</ul>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>资源是路由表中的一个含有路径，独特的名字和至少有一条路由的组件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">AbstractResource</span></span></span><br></pre></td></tr></table></figure>

<p>所有资源的基类。继承自<code>collections.abc.Sized</code>和<code>collections.abc.Iterable</code>。<br><code>len(resource)</code>会返回属于该资源的路由总数，也允许进行迭代<code>for route in resource</code>。</p>
<ul>
<li>get_info()<br>返回资源的描述。如<code>&#123;&#39;path&#39;: &#39;/path/to&#39;&#125;, &#123;&#39;formatter&#39;: &#39;/path/&#123;to&#125;&#39;, &#39;pattern&#39;: re.compile(r&#39;^/path/(?P&lt;to&gt;[a-zA-Z][_a-zA-Z0-9]+)$)</code>。</li>
<li>url_for(*args, **kwargs)<br>构建一个该路由的URL（可附带额外参数）。<br>args和kwargs依赖继承于资源类的可接受参数列表。<strong>返回URL实例对象</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">web</span>.<span class="title">Resource</span></span></span><br></pre></td></tr></table></figure>

<p>新类型资源的基类，继承于<code>AbstractResource</code>。</p>
<p>add_route(method, handler, *, expect_handler=None)<br>添加一个web处理器到资源中。</p>
<h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><p>路由（Route）具有HTTP方法（通配符’*’是可以用的），web处理器和异常处理器（可选）。每个路由都可属于多个资源。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="路由斜杠问题"><a href="#路由斜杠问题" class="headerlink" title="路由斜杠问题"></a>路由斜杠问题</h3><ol>
<li><code>app.router.add_get(&#39;/chat/&#39;, chat)</code>和<code>app.router.add_get(&#39;/chat&#39;, chat)</code>是不一样的.<br>他们都是正确的,分别响应127.0.0.1:8080/chat/ 和127.0.0.1:8080/chat</li>
<li>这个问题很容易出现在websocket里.因为websocket默认就是<code>ws://127.0.0.1:8080/chat/ </code>多了一个斜杠.我们在写路由的时候很可能会少写这个斜杠</li>
</ol>
<h2 id="其他工具包"><a href="#其他工具包" class="headerlink" title="其他工具包"></a>其他工具包</h2><p>略</p>
<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><ol>
<li><a target="_blank" rel="noopener" href="https://hubertroy.gitbooks.io/aiohttp-chinese-documentation/content/">aiohttp 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/kuangshp128/article/details/61618519">sqlalchemy中多对多的关系</a></li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>