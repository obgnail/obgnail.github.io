<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第五章：文件与-IO&quot;&gt;&lt;a href=&quot;#第五章：文件与-IO&quot; class=&quot;headerlink&quot; title=&quot;第五章：文件与 IO&quot;&gt;&lt;/a&gt;第五章：文件与 IO&lt;/h2&gt;&lt;h3 id=&quot;5-1-读写文本数据&quot;&gt;&lt;a href=&quot;#5-1-读写文本数据&quot; class=&quot;headerlink&quot; title=&quot;5.1 读写文本数据&quot;&gt;&lt;/a&gt;5.1 读写文本数据&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;文本文件中的 回车 在不同操作系统中所用的字符表示有所不同。 "><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>python-cookbook5_第五章_文件与IO | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2019-08-14</div></div></div><div class="container post-header"><h1>python-cookbook5_第五章_文件与IO</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8E-IO"><span class="toc-number">1.</span> <span class="toc-text">第五章：文件与 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.</span> <span class="toc-text">5.1 读写文本数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA%E8%87%B3%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">1.2.</span> <span class="toc-text">5.2 打印输出至文件中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E5%88%86%E9%9A%94%E7%AC%A6%E6%88%96%E8%A1%8C%E7%BB%88%E6%AD%A2%E7%AC%A6%E6%89%93%E5%8D%B0"><span class="toc-number">1.3.</span> <span class="toc-text">5.3 使用其他分隔符或行终止符打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E8%AF%BB%E5%86%99%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.</span> <span class="toc-text">5.4 读写字节数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%96%87%E4%BB%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%89%8D%E8%83%BD%E5%86%99%E5%85%A5"><span class="toc-number">1.5.</span> <span class="toc-text">5.5 文件不存在才能写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84-I-O-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.</span> <span class="toc-text">5.6 字符串的 I&#x2F;O 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E8%AF%BB%E5%86%99%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.</span> <span class="toc-text">5.7 读写压缩文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E8%AE%B0%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.8.</span> <span class="toc-text">5.8 固定大小记录的文件迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-%E8%AF%BB%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E5%88%B0%E5%8F%AF%E5%8F%98%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD"><span class="toc-number">1.9.</span> <span class="toc-text">5.9 读取二进制数据到可变缓冲区中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.</span> <span class="toc-text">5.10 内存映射的二进制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-11-%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%90%8D%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.</span> <span class="toc-text">5.11 文件路径名的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-12-%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">1.12.</span> <span class="toc-text">5.12 测试文件是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-13-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8"><span class="toc-number">1.13.</span> <span class="toc-text">5.13 获取文件夹中的文件列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-14-%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%90%8D%E7%BC%96%E7%A0%81"><span class="toc-number">1.14.</span> <span class="toc-text">5.14 忽略文件名编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-15-%E6%89%93%E5%8D%B0%E4%B8%8D%E5%90%88%E6%B3%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">1.15.</span> <span class="toc-text">5.15 打印不合法的文件名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-16-%E5%A2%9E%E5%8A%A0%E6%88%96%E6%94%B9%E5%8F%98%E5%B7%B2%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-number">1.16.</span> <span class="toc-text">5.16 增加或改变已打开文件的编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-17-%E5%B0%86%E5%AD%97%E8%8A%82%E5%86%99%E5%85%A5%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">1.17.</span> <span class="toc-text">5.17 将字节写入文本文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-18-%E5%B0%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8C%85%E8%A3%85%E6%88%90%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.18.</span> <span class="toc-text">5.18 将文件描述符包装成文件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-19-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">1.19.</span> <span class="toc-text">5.19 创建临时文件和文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-20-%E4%B8%8E%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1"><span class="toc-number">1.20.</span> <span class="toc-text">5.20 与串行端口的数据通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-21-%E5%BA%8F%E5%88%97%E5%8C%96-Python-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.21.</span> <span class="toc-text">5.21 序列化 Python 对象</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="第五章：文件与-IO"><a href="#第五章：文件与-IO" class="headerlink" title="第五章：文件与 IO"></a>第五章：文件与 IO</h2><h3 id="5-1-读写文本数据"><a href="#5-1-读写文本数据" class="headerlink" title="5.1 读写文本数据"></a>5.1 读写文本数据</h3><blockquote>
<p>文本文件中的 回车 在不同操作系统中所用的字符表示有所不同。 </p>
<ul>
<li>Windows :  \r\n </li>
<li>Linux/Unix : \n </li>
<li>Mac OS : \r</li>
</ul>
</blockquote>
<p>rt模式下，python在读取文本时会自动把\r\n转换成\n.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;somefile.txt&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	data = f.read()</span><br><span class="line">	<span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实python默认就会将这些文件的换行符全部统一成<code>\n</code><br>如果不想使用默认,可以使用open函数的<code>newline</code>参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;somefile.txt&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>print语句有一个file参数,用于重定向数据流</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(line1, file=f)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>当读取一个未知编码的文本时使用 latin-1 编码永远不会产生解码错误。</li>
<li>使用latin-1 编码读取一个文件的时候也许不能产生完全正确的文本解码数据，但是它也能从中提取出足够多的有用数据。</li>
</ul>
</blockquote>
<h3 id="5-2-打印输出至文件中"><a href="#5-2-打印输出至文件中" class="headerlink" title="5.2 打印输出至文件中"></a>5.2 打印输出至文件中</h3><p>print() 函数的file 关键字参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;d:/work/test.txt&#x27;</span>, <span class="string">&#x27;wt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>, file=f)</span><br></pre></td></tr></table></figure>



<h3 id="5-3-使用其他分隔符或行终止符打印"><a href="#5-3-使用其他分隔符或行终止符打印" class="headerlink" title="5.3 使用其他分隔符或行终止符打印"></a>5.3 使用其他分隔符或行终止符打印</h3><p>print() 函数中使用 sep 和 end 关键字参数</p>
<h3 id="5-4-读写字节数据"><a href="#5-4-读写字节数据" class="headerlink" title="5.4 读写字节数据"></a>5.4 读写字节数据</h3><p>用模式为 rb 或 wb 的 open() 函数</p>
<h3 id="5-5-文件不存在才能写入"><a href="#5-5-文件不存在才能写入" class="headerlink" title="5.5 文件不存在才能写入"></a>5.5 文件不存在才能写入</h3><p>你想像一个文件中写入数据，但是前提必须是这个文件在文件系统上不存在。也就是不允许覆盖已存在的文件内容。</p>
<p> <strong>open() 函数中使用 x 模式</strong>来代替 w 模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;xt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>, file=f)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果存在,就会报FileExistsError</span></span><br><span class="line"><span class="comment"># FileExistsError: [Errno 17] File exists: &#x27;test.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当然也可以自己实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;somefile&#x27;</span>):</span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;somefile&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">		f.write(<span class="string">&#x27;hello\n&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;file already exists&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>如果文件是二进制的，使用 xb</strong></p>
<h3 id="5-6-字符串的-I-O-操作"><a href="#5-6-字符串的-I-O-操作" class="headerlink" title="5.6 字符串的 I/O 操作"></a>5.6 字符串的 I/O 操作</h3><p>操作<code>类文件对象</code>的程序来操作文本或二进制字符串。</p>
<blockquote>
<p>使用 io.StringIO() 和 io.BytesIO() 类来创建类文件对象操作字符串数据。</p>
</blockquote>
<blockquote>
<ul>
<li>StringIO的行为与file对象非常像，但它不是磁盘上文件，而是一个<strong>内存里的“文件”</strong>，我们可以像操作磁盘文件那样来操作StringIO。</li>
<li>StringIO模块，主要用于在内存缓冲区中读写数据。</li>
</ul>
</blockquote>
<ul>
<li>数据读写不一定是文件，也可以在内存中进行。</li>
<li>StringIO 顾名思义就是<strong>在内存中以 io 流的方式读写 str</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">f = StringIO()</span><br><span class="line">f.write(<span class="string">&#x27;hello&#x27;</span>) <span class="comment"># 返回 5，也即写入的字符数目</span></span><br><span class="line">f.write(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;world!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.getvalue() )  <span class="comment"># hello world!</span></span><br></pre></td></tr></table></figure>



<ol>
<li><p>s=io.StringIO([buf])</p>
<ul>
<li><p>此实例<strong>类似于open方法</strong>，不同的是==它并不会在硬盘中生成文件，而只寄存在缓冲区==；</p>
</li>
<li><p>可选参数buf是一个str或unicode类型。它将会与其他后续写入的数据存放在一起</p>
<blockquote>
<p>（注意，若要在初始化数据之后继续写入数据，则在写入数据之前，应先将读写位置移动到结尾，然后再写入，否则，初始化数据会被覆盖掉，因为读写位置默认是0）。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>s.read([n])</p>
<ul>
<li>参数n限定读取长度，int类型；</li>
<li>缺省状态为从当前读写位置读取对象s中存储的所有数据。</li>
<li><strong>读取结束后，读写位置被移动</strong>。</li>
</ul>
</li>
<li><p>s.readline([length])</p>
<ul>
<li>参数length限定读取的结束位置，int类型，</li>
<li>缺省状态为None：从当前读写位置读取至下一个以“\n”为结束符的当前行。</li>
<li>读写位置被移动。</li>
</ul>
</li>
<li><p>s.readlines([sizehint])</p>
<ul>
<li>参数sizehint为int类型，</li>
<li>缺省状态为读取所有行并作为列表返回，如果不使用缺省值从当前读写位置读取至下一个以“\n”为结束符的当前行。</li>
<li>读写位置被移动。</li>
</ul>
</li>
<li><p>s.write(s)</p>
<ul>
<li>从读写位置将参数s写入给对象s。</li>
<li>参数s为str或unicode类型。读写位置被移动</li>
</ul>
</li>
<li><p>s.writelines(list)</p>
<ul>
<li>从读写位置将list写入给对象s。参数list为一个列表，列表的成员为str或unicode类型。</li>
<li>读写位置被移动。</li>
</ul>
</li>
<li><p><strong>s.getvalue()</strong><br>此函数没有参数，无论读写位置在哪里，都能够返回对象s中的所有数据。</p>
</li>
<li><p>s.truncate([size])</p>
<ul>
<li>如果有size参数 :<br>无论读写位置在哪里，都从起始位置开始，裁剪size字节的数据。</li>
<li>不带size参数<br>将当前读写位置之前的数据，裁剪下来。</li>
</ul>
</li>
<li><p>s.tell()<br>返回当前读写位置。</p>
</li>
<li><p>s.seek(pos[,mode])</p>
<ul>
<li>移动当前读写位置至pos处，</li>
<li>可选参数mode为0时将读写位置移动至pos处，<br>为1时将读写位置从当前位置起向前或向后移动|pos|个长度，<br>为2时将读写位置置于末尾处再向前或向后移动|pos|个长度；<br>mode的默认值为0。</li>
</ul>
</li>
<li><p>s.close()<br>释放缓冲区，执行此函数后，数据将被释放，也不可再进行操作。</p>
</li>
<li><p>s.isatty()<br>此函数总是返回0。</p>
</li>
<li><p>s.flush()<br>刷新内部缓冲区。</p>
</li>
</ol>
<blockquote>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line">s = StringIO(<span class="string">&#x27;python&#x27;</span>)  </span><br><span class="line">s.seek(<span class="number">0</span>,<span class="number">2</span>) <span class="comment">#将读写位置移动到结尾  </span></span><br><span class="line"></span><br><span class="line">s.write(<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">lines = [<span class="string">&#x27;xxxxx&#x27;</span>, <span class="string">&#x27;bbbbbbb&#x27;</span>]  </span><br><span class="line">s.writelines(lines)  </span><br><span class="line">s.write(<span class="string">&quot;ttttttttt&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s.getvalue()) </span><br><span class="line"><span class="comment"># pythonaaaaxxxxxbbbbbbbttttttttt</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>io.StringIO 只能用于文本。如果你要操作二进制数据，要使用 io.BytesIO 类</p>
<blockquote>
<ul>
<li>当你想模拟一个普通的文件的时候 StringIO 和 BytesIO 类是很有用的。</li>
<li>比如，在<strong>单元测试</strong>中，你可以使用 StringIO 来创建一个包含测试数据的类文件对象，这个对象可以被传给某个参数为普通文件对象的函数。</li>
</ul>
</blockquote>
<h3 id="5-7-读写压缩文件"><a href="#5-7-读写压缩文件" class="headerlink" title="5.7 读写压缩文件"></a>5.7 读写压缩文件</h3><p>读写一个 gzip 或 bz2 格式的压缩文件。</p>
<p>使用gzip 和 bz2 模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">with</span> gzip.<span class="built_in">open</span>(<span class="string">&#x27;somfile.gz&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	text = f.read()</span><br><span class="line">	f.write(<span class="string">&#x27;xxxxxx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bz2</span><br><span class="line"><span class="keyword">with</span> bz2.<span class="built_in">open</span>(<span class="string">&#x27;somfile.bz2&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	text = f.read()</span><br><span class="line">	f.write(<span class="string">&#x27;xxxxxx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>gzip.open() 和 bz2.open() 接受跟内置的open() 函数一样的参数，包括 encoding,errors，newline 等等。</p>
<p>当写入压缩数据时，可以使用 compresslevel 这个可选的关键字参数来指定一个压缩级别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> gzip.<span class="built_in">open</span>(<span class="string">&#x27;somefile.gz&#x27;</span>, <span class="string">&#x27;wt&#x27;</span>, compresslevel=<span class="number">5</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.write(text)</span><br></pre></td></tr></table></figure>

<p>默认的等级是 9，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。</p>
<h3 id="5-8-固定大小记录的文件迭代"><a href="#5-8-固定大小记录的文件迭代" class="headerlink" title="5.8 固定大小记录的文件迭代"></a>5.8 固定大小记录的文件迭代</h3><p>在一个固定长度记录或者数据块的集合上迭代，而不是在一个文件中一行一行的迭代。</p>
<p>使用 iter 和 functools.partial() 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">RECORD_SIZE = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;somefile.data&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	records = <span class="built_in">iter</span>(partial(f.read,RECORD_SIZE),<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> r <span class="keyword">in</span> records:</span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>records 对象是一个可迭代对象，它会不断的产生固定大小的数据块，直到文件末尾。</p>
<blockquote>
<p>注意:<br>如果总记录大小不是块大小的整数倍的话，最后一个返回元素的字节数会比期望值少。</p>
</blockquote>
<blockquote>
<p> iter() 函数有一个鲜为人知的特性就是，如果你给它传递一个可调用对象和一个<br>标记值，它会创建一个迭代器。这个迭代器会一直调用传入的可调用对象直到它返回标记值为止，这时候迭代终止。</p>
</blockquote>
<p><code>固定大小记录的文件迭代</code>在<strong>二进制模式</strong>更常见</p>
<h3 id="5-9-读取二进制数据到可变缓冲区中"><a href="#5-9-读取二进制数据到可变缓冲区中" class="headerlink" title="5.9 读取二进制数据到可变缓冲区中"></a>5.9 读取二进制数据到可变缓冲区中</h3><p>为了读取数据到一个可变数组中，使用文件对象的 readinto() 方法。</p>
<blockquote>
<p>file.readinto(buf,size) : <strong>读取size个字节到文件缓冲器中</strong></p>
<ul>
<li>和普通 read() 方法不同的是，==readinto() 填充已存在的缓冲区而不是为新对象重新分配内存再返回它们。==</li>
<li>因此，你可以使用它来避免大量的内存分配操作。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_into_buffer</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="comment"># 新建一个缓冲器</span></span><br><span class="line">	buf = <span class="built_in">bytearray</span>(os.path.getsize(filename))</span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">		<span class="comment"># 将数据填充进缓冲器中</span></span><br><span class="line">		f.readinto(buf)</span><br><span class="line">	<span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line">buf = read_into_buffer(<span class="string">&#x27;sample.bin&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(buf)  <span class="comment"># bytearray(b&#x27;Hello World&#x27;)</span></span><br><span class="line"></span><br><span class="line">buf[<span class="number">0</span>:<span class="number">5</span>] = <span class="string">b&#x27;XXXXX&#x27;</span></span><br><span class="line">pirnt(buf)  <span class="comment"># bytearray(b&#x27;XXXXX World&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>另外有一个有趣特性就是 memoryview ，它可以通过零复制的方式对已存在的缓冲区执行切片操作，甚至还能修改它的内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(buf)  <span class="comment"># bytearray(b&#x27;Hello World&#x27;)</span></span><br><span class="line">buf[<span class="number">0</span>:<span class="number">5</span>] = <span class="string">b&#x27;XXXXX&#x27;</span></span><br><span class="line">pirnt(buf)  <span class="comment"># bytearray(b&#x27;XXXXX World&#x27;)</span></span><br><span class="line"></span><br><span class="line">m1 = <span class="built_in">memoryview</span>(buf)</span><br><span class="line">m2 = m1[-<span class="number">5</span>:]</span><br><span class="line"><span class="built_in">print</span>(m2) <span class="comment"># &lt;memory at 0x100681390&gt;</span></span><br><span class="line"><span class="built_in">print</span>(buf)  <span class="comment"># bytearray(b&#x27;Hello World&#x27;)</span></span><br></pre></td></tr></table></figure>



<h3 id="5-10-内存映射的二进制文件"><a href="#5-10-内存映射的二进制文件" class="headerlink" title="5.10 内存映射的二进制文件"></a>5.10 内存映射的二进制文件</h3><p>内存映射一个二进制文件到一个可变字节数组中，目的可能是为了随机访问它的内容或者是原地做些修改。</p>
<p>使用 mmap 模块来内存映射文件。</p>
<blockquote>
<p>mmap : memory-map打开一个文件并以一种便捷方式内存映射这个文件。</p>
<ul>
<li><p>mmap是一种虚拟内存映射文件的方法，即可以<strong>将一个文件或者其它对象映射到进程的地址空间</strong>，实现==文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。==</p>
</li>
<li><p>普通文件被映射到虚拟地址空间后，程序可以像操作内存一样操作文件，可以提高访问效率，适合处理超大文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 预先准备一个hello.txt文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;Hello Python!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r+b&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 内存映射文件，0表示整个文件</span></span><br><span class="line">    mm = mmap.mmap(f.fileno(), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 通过标准文件方法读取内容</span></span><br><span class="line">    <span class="built_in">print</span>(mm.readline())     <span class="comment"># Hello Python!</span></span><br><span class="line">    <span class="comment"># 通过切片读取内容</span></span><br><span class="line">    <span class="built_in">print</span>(mm[:<span class="number">5</span>])            <span class="comment"># Hello</span></span><br><span class="line">    <span class="comment"># 使用切片更新内容</span></span><br><span class="line">    <span class="comment"># 注意，新内容的大小必须相同</span></span><br><span class="line">    mm[<span class="number">6</span>:] = <span class="string">&quot; world!\n&quot;</span></span><br><span class="line">    <span class="comment"># 使用标准文件方法重新读取</span></span><br><span class="line">    mm.seek(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(mm.readline())      <span class="comment"># Hello  world!</span></span><br><span class="line">    <span class="comment"># 关闭</span></span><br><span class="line">    mm.close()</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memory_map</span>(<span class="params">filename, access=mmap.ACCESS_WRITE</span>):</span></span><br><span class="line">	size = os.path.getsize(filename)</span><br><span class="line">	fd = os.<span class="built_in">open</span>(filename, os.O_RDWR)</span><br><span class="line">	<span class="keyword">return</span> mmap.mmap(fd, size, access=access)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size = <span class="number">1000000</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.seek(size-<span class="number">1</span>)</span><br><span class="line">	f.write(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = memory_map(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(m)) <span class="comment"># 1000000</span></span><br><span class="line"><span class="built_in">print</span>(m[<span class="number">0</span>:<span class="number">10</span>]) <span class="comment"># b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>需要强调的一点是，内存映射一个文件<strong>并不会导致整个文件被读取到内存中</strong>。</li>
<li>也就是说，文件并没有被复制到内存缓存或数组中。相反，操作系统仅仅为文件内容保留了一段虚拟内存。</li>
<li>当你访问文件的不同区域时，这些区域的内容才根据需要被读取并映射到内存区域中。而那些从没被访问到的部分还是留在磁盘上。所有这些过程是透明的，在幕后完成！</li>
</ul>
</blockquote>
<h3 id="5-11-文件路径名的操作"><a href="#5-11-文件路径名的操作" class="headerlink" title="5.11 文件路径名的操作"></a>5.11 文件路径名的操作</h3><p>使用路径名来获取文件名，目录名，绝对路径等等。</p>
<p><strong>使用 os.path 模块中的函数来操作路径名</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;/Users/beazley/Data/data.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.path.basename(path))  <span class="comment"># data.csv</span></span><br><span class="line"><span class="built_in">print</span>(os.path.dirname(path))   <span class="comment"># /Users/beazley/Data</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">&#x27;tmp&#x27;</span>,<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;A.csv&#x27;</span>)) <span class="comment"># tmp\data\A.csv</span></span><br><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">&#x27;tmp&#x27;</span>,<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;.csv&#x27;</span>))  <span class="comment"># tmp\data\.csv</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;~/Data/data.csv&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(os.path.expanduser(path)) <span class="comment"># C:\Users\lenovo/Data/data.csv</span></span><br><span class="line"><span class="built_in">print</span>(os.path.splitext(path))   <span class="comment"># (&#x27;~/Data/data&#x27;, &#x27;.csv&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>os.path 模块知道 Unix 和 Windows 系统之间的差异并且能够可靠地处理类似 Data/data.csv 和Data\data.csv 这样的文件名。</p>
<h3 id="5-12-测试文件是否存在"><a href="#5-12-测试文件是否存在" class="headerlink" title="5.12 测试文件是否存在"></a>5.12 测试文件是否存在</h3><ul>
<li>os.path.exists()</li>
<li>os.path.isdir()</li>
<li>os.path.isfile()</li>
<li>os.path.isllink()</li>
<li>os.path.realpath() : 对于link,找出链接的真正地址</li>
</ul>
<blockquote>
<p>注意:<br><code>os.path.isfile()</code>,<code>os.path.isdir()</code>,<code>os.path.isllink()</code>,是<strong>能否找到</strong>这个文件/目录/链接.不是判断传入的参数是不是文件/目录/链接</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">&#x27;hello.txt&#x27;</span>))<span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isdir(<span class="string">r&#x27;D:\note\Python\没有这个目录&#x27;</span>))<span class="comment"># False</span></span><br></pre></td></tr></table></figure>



<p>获取文件/目录的一些数据</p>
<ul>
<li>os.path.getsize : 获取大小</li>
<li>os.path.getmtime : 获取修改时间</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件大小</span></span><br><span class="line"><span class="built_in">print</span>(os.path.getsize(<span class="string">&#x27;training1.py&#x27;</span>))  <span class="comment"># 1429</span></span><br><span class="line"><span class="comment"># 获取目录大小</span></span><br><span class="line"><span class="built_in">print</span>(os.path.getsize(<span class="string">r&#x27;D:\note\Python&#x27;</span>))  <span class="comment"># 4096</span></span><br></pre></td></tr></table></figure>



<h3 id="5-13-获取文件夹中的文件列表"><a href="#5-13-获取文件夹中的文件列表" class="headerlink" title="5.13 获取文件夹中的文件列表"></a>5.13 获取文件夹中的文件列表</h3><p>获取文件系统中某个目录下的所有文件/目录列表。</p>
<p>os.listdir() 函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.listdir(<span class="string">r&#x27;D:\note\Python\书籍__python-cookbook\trainingfile&#x27;</span>))</span><br><span class="line"><span class="comment"># [&#x27;data&#x27;, &#x27;hello.txt&#x27;, &#x27;setup.py&#x27;, &#x27;somefile.txt&#x27;, &#x27;test.txt&#x27;, &#x27;tests&#x27;, &#x27;training1.py&#x27;, &#x27;training2.py&#x27;, &#x27;training3.py&#x27;, &#x27;training4.py&#x27;, &#x27;training5.py&#x27;, &#x27;training6.py&#x27;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<br>如果trainingfile目录下的,test目录下还有文件.那么这些文件并不能出现在<code>os.listdir</code>里面<br>当然,我们可以自己写一个:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listdirs</span>(<span class="params">path</span>):</span></span><br><span class="line">	<span class="keyword">for</span> f_or_d <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">		<span class="keyword">if</span> os.path.isdir(f_or_d):</span><br><span class="line">			<span class="keyword">yield</span> <span class="keyword">from</span> listdirs(f_or_d)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">yield</span> f_or_d</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">list</span>(listdirs(<span class="string">r&#x27;D:\note\Python\书籍__python-cookbook\trainingfile&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># [&#x27;data&#x27;, &#x27;hello.txt&#x27;, &#x27;setup.py&#x27;, &#x27;somefile.txt&#x27;, &#x27;test.txt&#x27;, &#x27;test_func.py&#x27;, &#x27;__pycache__&#x27;, &#x27;training1.py&#x27;, &#x27;training2.py&#x27;, &#x27;training3.py&#x27;, &#x27;training4.py&#x27;, &#x27;training5.py&#x27;, &#x27;training6.py&#x27;]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 只获取文件</span></span><br><span class="line">names = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">&#x27;somedir&#x27;</span>) <span class="keyword">if</span> os.path.isfile(os.path.join(<span class="string">&#x27;somedir&#x27;</span>, name))]</span><br><span class="line"><span class="comment"># 只获取目录</span></span><br><span class="line">dirnames = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">&#x27;somedir&#x27;</span>) <span class="keyword">if</span> os.path.isdir(os.path.join(<span class="string">&#x27;somedir&#x27;</span>, name))]</span><br></pre></td></tr></table></figure>

<p>也可以使用字符串的 startswith() 和 endswith() 方法过滤目录内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">pyfiles = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">&#x27;somedir&#x27;</span>) <span class="keyword">if</span> name.endswith(<span class="string">&#x27;.py&#x27;</span>)]</span><br></pre></td></tr></table></figure>



<p>使用os.stat() 函数来收集文件数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">pyfiles = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">r&#x27;D:\note\Python\书籍__python-cookbook\trainingfile&#x27;</span>) <span class="keyword">if</span> name.endswith(<span class="string">&#x27;.py&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">file_metadata = [(name,os.stat(name)) <span class="keyword">for</span> name <span class="keyword">in</span> pyfiles]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, meta <span class="keyword">in</span> file_metadata:</span><br><span class="line">    <span class="built_in">print</span>(name, meta.st_size, meta.st_mtime)</span><br><span class="line"><span class="comment"># training1.py 1429 1564105519.7120438</span></span><br><span class="line"><span class="comment"># training2.py 433 1564241227.0905564</span></span><br><span class="line"><span class="comment"># training3.py 278 1564241650.4067366</span></span><br><span class="line"><span class="comment"># training4.py 120 1564240604.8063886</span></span><br><span class="line"><span class="comment"># training5.py 159 1564240853.097712</span></span><br><span class="line"><span class="comment"># training6.py 256 1564240927.5994468</span></span><br></pre></td></tr></table></figure>



<h3 id="5-14-忽略文件名编码"><a href="#5-14-忽略文件名编码" class="headerlink" title="5.14 忽略文件名编码"></a>5.14 忽略文件名编码</h3><p>sys.getfilesystemencoding() 返回的文本编码来编码或解码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getfilesystemencoding()) <span class="comment"># utf-8</span></span><br></pre></td></tr></table></figure>



<h3 id="5-15-打印不合法的文件名"><a href="#5-15-打印不合法的文件名" class="headerlink" title="5.15 打印不合法的文件名"></a>5.15 打印不合法的文件名</h3><p>使用下面的方法可以避免这样的错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bad_filename</span>(<span class="params">filename</span>):</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">repr</span>(filename)[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">	</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="built_in">print</span>(filename)</span><br><span class="line"><span class="keyword">except</span> UnicodeEncodeError:</span><br><span class="line">	<span class="built_in">print</span>(bad_filename(filename))</span><br></pre></td></tr></table></figure>



<h3 id="5-16-增加或改变已打开文件的编码"><a href="#5-16-增加或改变已打开文件的编码" class="headerlink" title="5.16 增加或改变已打开文件的编码"></a>5.16 增加或改变已打开文件的编码</h3><p>在不关闭一个已打开的文件前提下增加或改变它的 Unicode 编码。</p>
<p>给一个以二进制模式打开的文件添加 Unicode 编码/解码方式，可以使用<code>io.TextIOWrapper() </code>对象包装它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;hello.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="comment"># &lt;_io.TextIOWrapper name=&#x27;hello.txt&#x27; mode=&#x27;w&#x27; encoding=&#x27;cp936&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>io.TextIOWrapper 是一个编码和解码 Unicode 的文本处理层，</li>
<li>io.BufferedWriter 是一个处理二进制数据的带缓冲的 I/O 层，</li>
<li>io.FileIO 是一个表示操作系统底层文件描述符的原始文件。</li>
<li>增加或改变文本编码会涉及增加或改变最上面的io.TextIOWrapper 层。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">u = urllib.request.urlopen(<span class="string">&#x27;http://www.python.org&#x27;</span>)</span><br><span class="line">f = io.TextIOWrapper(u,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">text = f.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure>

<p>如果你想修改一个已经打开的文本模式的文件的编码方式，可以先使用 detach()方法移除掉已存在的文本编码层，并使用新的编码方式代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.stdout.encoding)  <span class="comment"># cp936</span></span><br><span class="line">sys.stdout = io.TextIOWrapper(sys.stdout.detach(),encoding=<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sys.stdout.encoding)  <span class="comment"># latin-1</span></span><br><span class="line">sys.stdout = io.TextIOWrapper(sys.stdout.detach(),encoding=<span class="string">&#x27;latin-1&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="5-17-将字节写入文本文件"><a href="#5-17-将字节写入文本文件" class="headerlink" title="5.17 将字节写入文本文件"></a>5.17 将字节写入文本文件</h3><p>在文本模式打开的文件中写入原始的字节数据。</p>
<p>将字节数据直接写入文件的缓冲区</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stdout.buffer.write(<span class="string">b&#x27;Hello\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>类似的，能够通过读取文本文件的 buffer 属性来读取二进制数据</p>
<h3 id="5-18-将文件描述符包装成文件对象"><a href="#5-18-将文件描述符包装成文件对象" class="headerlink" title="5.18 将文件描述符包装成文件对象"></a>5.18 将文件描述符包装成文件对象</h3><p>你有一个对应于操作系统上一个已打开的 I/O 通道 (比如文件、管道、套接字等)的整型文件描述符，你想将它包装成一个更高层的 Python 文件对象。</p>
<p>(看不懂,略)</p>
<h3 id="5-19-创建临时文件和文件夹"><a href="#5-19-创建临时文件和文件夹" class="headerlink" title="5.19 创建临时文件和文件夹"></a>5.19 创建临时文件和文件夹</h3><p>创建一个临时文件或目录，并希望<strong>使用完之后可以自动销毁掉</strong>。</p>
<p>使用tempfile模块</p>
<blockquote>
<p>tempfile.TemporaryFile : </p>
<ul>
<li>创建一个匿名的临时文件</li>
<li>TemporaryFile() 支持跟内置的 open() 函数一样的参数</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryFile</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> TemporaryFile(<span class="string">&#x27;w+t&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.write(<span class="string">&#x27;AAAAAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	f.seek(<span class="number">0</span>)</span><br><span class="line">	data = f.read()</span><br></pre></td></tr></table></figure>

<p>如果要创建一个具名的临时文件,使用NamedTemporaryFile()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> NamedTemporaryFile</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> NamedTemporaryFile(<span class="string">&#x27;w+t&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;filename is&#x27;</span>,f.name)</span><br><span class="line"><span class="comment"># filename is C:\Users\lenovo\AppData\Local\Temp\tmpx0ofhhmn</span></span><br></pre></td></tr></table></figure>

<p>临时文件用完即删,但是也可以不删除,使用<code>delete</code>参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> NamedTemporaryFile(<span class="string">&#x27;w+t&#x27;</span>, delete=<span class="literal">False</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;filename is:&#x27;</span>, f.name)</span><br></pre></td></tr></table></figure>

<p>同理还有临时目录:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">with</span> TemporaryDirectory() <span class="keyword">as</span> dirname:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dirname is:&#x27;</span>, dirname)</span><br></pre></td></tr></table></figure>



<h3 id="5-20-与串行端口的数据通信"><a href="#5-20-与串行端口的数据通信" class="headerlink" title="5.20 与串行端口的数据通信"></a>5.20 与串行端口的数据通信</h3><p>对于串行通信最好的选择是使用 pySerial 包 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> serial</span><br><span class="line">ser = serial.Serial(<span class="string">&#x27;/dev/tty.usbmodem641&#x27;</span>, <span class="comment"># Device name varies</span></span><br><span class="line">	baudrate=<span class="number">9600</span>,</span><br><span class="line">	bytesize=<span class="number">8</span>,</span><br><span class="line">	parity=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">	stopbits=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ser.write(<span class="string">b&#x27;G1 X50 Y50\r\n&#x27;</span>)</span><br><span class="line">resp = ser.readline()</span><br></pre></td></tr></table></figure>



<h3 id="5-21-序列化-Python-对象"><a href="#5-21-序列化-Python-对象" class="headerlink" title="5.21 序列化 Python 对象"></a>5.21 序列化 Python 对象</h3><p>使用 pickle 模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;there is some python object&#x27;</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;somefile&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">pickle.dumps(data,f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restore from a file</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;somefile&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data = pickle.load(f)</span><br><span class="line"><span class="comment"># Restore from a string</span></span><br><span class="line">data = pickle.loads(s)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;somefile&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pickle.dumps([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],f)</span><br><span class="line">pickle.dumps(<span class="string">&#x27;hello&#x27;</span>,f)</span><br><span class="line">pickle.dumps(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;hyl&#x27;</span>&#125;,f)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pickle.load(f)) <span class="comment"># [1,2,3]</span></span><br><span class="line"><span class="built_in">print</span>(pickle.load(f)) <span class="comment"># hello</span></span><br><span class="line"><span class="built_in">print</span>(pickle.load(f)) <span class="comment"># &#123;&#x27;name&#x27;:&#x27;hyl&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>**千万不要对不信任的数据使用 pickle.load()**。<br>pickle 在加载时有一个副作用就是它会自动加载相应模块并构造实例对象。<br>但是某个坏人如果知道 pickle 的工作原理，<br>他就可以创建一个恶意的数据导致 Python 执行随意指定的系统命令。<br>因此，一定要保证 pickle 只在相互之间可以认证对方的解析器的内部使用。</p>
</blockquote>
<blockquote>
<ul>
<li><p>有些类型的对象是不能被序列化的。</p>
</li>
<li><p>这些通常是那些<strong>依赖外部系统状态的对象</strong>，比如打开的文件，网络连接，线程，进程，栈帧等等。</p>
</li>
<li><p>用户自定义类可以通过提供<code>__getstate__() </code>和 <code>__setstate__() </code>方法来绕过这些限制。</p>
</li>
<li><p>如果定义了这两个方法，pickle.dump() 就会调用 <code>__getstate__() </code>获取序列化的对象。类似的，<code>__setstate__()</code>在反序列化时被调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># countdown.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">		self.n = n</span><br><span class="line">		self.thr = threading.Thread(target=self.run)</span><br><span class="line">		self.thr.daemon = <span class="literal">True</span></span><br><span class="line">		<span class="comment"># 实例化就启动线程</span></span><br><span class="line">		self.thr.start()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">while</span> self.n &gt; <span class="number">0</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, self.n)</span><br><span class="line">			self.n -= <span class="number">1</span></span><br><span class="line">			time.sleep(<span class="number">5</span>)</span><br><span class="line">	<span class="comment"># 序列化调用</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> self.n</span><br><span class="line">	<span class="comment"># 反序列化调用</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__setstate__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">		self.__init__(n)</span><br></pre></td></tr></table></figure></li>
<li><p>就像前面说的:<br>==pickle.load()会自动加载相应模块并构造实例对象==,对于Countdown类来说,创建实例对象就触发了<code>self.thr.start()</code>,也就启动了线程</p>
</li>
<li><p>注意这里<code>__getstate__</code>存储的是<code>self.n</code>,而self.n是线程结束的关键.<br>也就是说,存储self.n能存储线程的状态,使用<code>pickle.load()</code>之后能继续执行线程</p>
</li>
</ul>
</blockquote>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>