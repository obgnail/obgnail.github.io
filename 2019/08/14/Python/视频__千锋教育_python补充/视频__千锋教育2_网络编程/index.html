<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h1&gt;&lt;p&gt;网络编程就是如何在程序中实现两台计算机的通信. "><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>千锋教育2_网络编程 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2019-08-14</div></div></div><div class="container post-header"><h1>千锋教育2_网络编程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">网络编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">协程</span></a></li></ol></details></div><div class="container post-content"><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络编程就是如何在程序中实现两台计算机的通信. </p>
<p>用python进行网络编程,就是在python程序本身这个进程内,连接别的服务器进程的通信端口进行通信.</p>
<hr>
<p>TCP编程</p>
<p><img src="/images/006tKfTcgy1fduv967xu3j30l80q6mz1.jpg" alt="006tKfTcgy1fduv967xu3j30l80q6mz1"></p>
<p>服务器</p>
<ol>
<li>socket():创建一个socket.</li>
<li>bind():绑定端口号</li>
<li>listen():监听.(可以设置参数,允许几个客户端连接)</li>
<li>accept():等待客户端的连接</li>
</ol>
<p>客户端:</p>
<ol>
<li>socket():客户端初始化一个Socket</li>
<li>connect():连接服务器</li>
<li>如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据</li>
<li>最后关闭连接，一次交互结束。</li>
</ol>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个socket</span></span><br><span class="line"><span class="comment"># AF_INET:指定的协议.AF_INET为IPv4,IPv6为AF_INET6</span></span><br><span class="line"><span class="comment"># SOCK_STREAM:指定使用面向流的TCP协议</span></span><br><span class="line">sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line"><span class="comment"># 参数是一个元组:第一元素为连接的服务器IP地址,第二为端口号</span></span><br><span class="line">sk.connect((<span class="string">&#x27;www.sina.com.cn&#x27;</span>,<span class="number">80</span>))</span><br><span class="line"><span class="comment"># 发送request请求头</span></span><br><span class="line">sk.send((<span class="string">b&#x27;GET / HTTP/1.1\r\n&#x27;</span></span><br><span class="line">         <span class="string">b&#x27;Host: www.sina.com.cn\r\n&#x27;</span></span><br><span class="line">         <span class="string">b&#x27;Connection: close\r\n\r\n&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待接收数据</span></span><br><span class="line"><span class="comment"># 因为是分组接收,所以使用data来汇总所有数据</span></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># recv:接受数据,每次接收1024字节(1k)</span></span><br><span class="line">    tempData = sk.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> tempData:</span><br><span class="line">        data.append(tempData)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># datStr就是response响应</span></span><br><span class="line">datStr = (<span class="string">b&#x27;&#x27;</span>.join(data)).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断开连接</span></span><br><span class="line">sk.close()</span><br><span class="line"><span class="built_in">print</span>(datStr)</span><br></pre></td></tr></table></figure>

<hr>
<p>服务器与客户端的简单连接:</p>
<p>服务器:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket</span></span><br><span class="line">server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 绑定IP端口</span></span><br><span class="line">server.bind((<span class="string">&#x27;192.168.75.1&#x27;</span>,<span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 监听,允许5个客户端连接</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;服务器启动&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待连接</span></span><br><span class="line">clientSocket,clientAddress = server.accept()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;clientSocket&#125;</span> -- <span class="subst">&#123;clientAddress&#125;</span> 连接成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接受客户端的数据</span></span><br><span class="line">    data = clientSocket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;收到数据: <span class="subst">&#123;data&#125;</span>&#x27;</span>)</span><br><span class="line">    clientSocket.send(<span class="string">&#x27;so do you&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>客户端:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&#x27;192.168.75.1&#x27;</span>,<span class="number">8081</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = <span class="built_in">input</span>(<span class="string">&#x27;请输出给服务器发送的数据: &#x27;</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    client.send(data)</span><br><span class="line">    <span class="comment"># 接受服务器的响应</span></span><br><span class="line">    info = client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;服务器响应为: <span class="subst">&#123;info&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/1556070729261.png" alt="1556070729261"></p>
<p><img src="/images/1556070754982.png" alt="1556070754982"></p>
<p>这里有一个问题,那就是服务器其实只允许一个客户端连接:<br>因为<code>clientSocket,clientAddress = server.accept()</code>只会执行一次,执行完,程序控制权就一直只<code>while True</code>里面了.这样就无法连接其他客户端了.</p>
<p>要想解决这样问题,必须使用多进程/多线程.</p>
<hr>
<p>TCP是建立可靠的连接,并且<strong>通信双方都可以以流的形式发送数据</strong>.<br>UDP优点:</p>
<ol>
<li>读书快</li>
<li>常用于广播</li>
</ol>
<p><img src="/images/1556079579582.png" alt="1556079579582"></p>
<hr>
<p>服务器与客户端的通讯:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">udp_server = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">udp_server.bind((<span class="string">&#x27;192.168.75.1&#x27;</span>,<span class="number">8081</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;服务器启动&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接受数据</span></span><br><span class="line">    data,addr= udp_server.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;客户端响应为: &#x27;</span>,data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    info = <span class="built_in">input</span>(<span class="string">&#x27;请输入数据: &#x27;</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    udp_server.sendto(info,addr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;客户端启动&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = <span class="built_in">input</span>(<span class="string">&#x27;请输入数据:&#x27;</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    client.sendto(data,(<span class="string">&#x27;192.168.75.1&#x27;</span>,<span class="number">8081</span>))</span><br><span class="line">    <span class="comment"># 接受数据</span></span><br><span class="line">    info = client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;服务器响应为: <span class="subst">&#123;info&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>操作系统是如何同时运行多个任务</p>
<p>单核CUP实现多任务原理:<br>操作系统轮流让各个任务交替执行</p>
<p>单核CUP实现多任务原理:<br>真正的并行执行多任务只能在多核CPU上实现,但是由于任务数量远远多于CPU的核心数量.所以操作系统也会自动把很多任务轮流调度到每个核心上执行.</p>
<hr>
<ol>
<li>并发:看上去一起执行,任务数多于CPU核心数</li>
<li>并行:真正的一起执行,任务数不多于CPU核心数</li>
</ol>
<hr>
<p>实现多任务的方式:</p>
<ol>
<li>多进程模式</li>
<li>多线程模式</li>
<li>协程模式</li>
<li>多线程+多进程模式</li>
</ol>
<hr>
<p>对于操作系统而言,==一个任务就是一个进程==.</p>
<p>进程是系统在<code>程序执行</code>和 <code>资源分配</code>的基本单位.每个进程都有自己的数据段,代码段和堆栈段</p>
<ol>
<li><p>单任务与多任务:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">456</span>)</span><br><span class="line">	time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<p>我们看上面的代码,下面的run()永远不会执行.<br>一个任务就是一个进程,所以要想run()能使用必须使用多个进程.</p>
</li>
<li><p>创建==子==进程:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程启动&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建子进程:</span></span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">456</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>注意:<br>==父进程就是这个模块执行的进程.==<br><code>p = Process(target=run)</code>创建的是一个子进程</p>
</li>
</ol>
<hr>
<p>父子进程的先后顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程启动&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程启动&#x27;</span>)</span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父进程启动</span></span><br><span class="line"><span class="comment"># 父进程结束</span></span><br><span class="line"><span class="comment"># 子进程启动</span></span><br><span class="line"><span class="comment"># 子进程结束</span></span><br></pre></td></tr></table></figure>

<p>父进程并没有等着子进程结束.<br>也就是说:<br>==父进程的结束不能影响子进程==.</p>
<p>如果要让父进程等待子进程结束:使用p.join()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程启动&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程启动&#x27;</span>)</span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="comment"># 添加这句</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父进程启动</span></span><br><span class="line"><span class="comment"># 子进程启动</span></span><br><span class="line"><span class="comment"># 子进程结束</span></span><br><span class="line"><span class="comment"># 父进程结束</span></span><br></pre></td></tr></table></figure>

<p>所以一般我们设计的时候就是在一个父进程里创建多个子进程,子进程同时运行.<br>然后父进程等所有子进程完成后在关闭.</p>
<hr>
<p>全局变量在多个进程中不能共享</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程开始&#x27;</span>)</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程结束&#x27;</span>,num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程启动&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建子进程:</span></span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程结束&#x27;</span>,num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父进程启动</span></span><br><span class="line"><span class="comment"># 子进程开始 </span></span><br><span class="line"><span class="comment"># 子进程结束 2</span></span><br><span class="line"><span class="comment"># 父进程结束 1</span></span><br></pre></td></tr></table></figure>

<p>在子进程里修改全局变量对于父进程没有影响<br>也就是说,==在不同的进程中,num已经不是同一个变量了==.</p>
<p>原因:<br>在创建子进程时对全局变量做了一个备份.</p>
<hr>
<p>启动大量子进程:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子进程<span class="subst">&#123;name&#125;</span>启动:<span class="subst">&#123;os.getpid()&#125;</span>&#x27;</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子进程<span class="subst">&#123;name&#125;</span>结束:<span class="subst">&#123;os.getpid()&#125;</span>--<span class="subst">&#123;end-start:<span class="number">.01</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程启动&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建进程池</span></span><br><span class="line">    <span class="comment"># Pool参数表示可以同时执行的进程数量,默认是CPU的核心数</span></span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># 创建进程,放入进程池统一管理</span></span><br><span class="line">        p.apply_async(run, args=(i,))</span><br><span class="line">    <span class="comment"># 在调用join之前必须先调用close,关闭进程池</span></span><br><span class="line">    <span class="comment"># 在调用close之后就不能再继续添加新的进程</span></span><br><span class="line">    p.close()</span><br><span class="line">    <span class="comment"># 进程池对象会等待所有的子进程结束,再去执行父进程</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父进程启动</span></span><br><span class="line"><span class="comment"># 子进程0启动:4008</span></span><br><span class="line"><span class="comment"># 子进程1启动:3852</span></span><br><span class="line"><span class="comment"># 子进程2启动:4012</span></span><br><span class="line"><span class="comment"># 子进程3启动:592</span></span><br><span class="line"><span class="comment"># 子进程1结束:3852--2.0</span></span><br><span class="line"><span class="comment"># 子进程4启动:3852</span></span><br><span class="line"><span class="comment"># 子进程0结束:4008--3.0</span></span><br><span class="line"><span class="comment"># 子进程4结束:3852--2.0</span></span><br><span class="line"><span class="comment"># 子进程2结束:4012--4.0</span></span><br><span class="line"><span class="comment"># 子进程3结束:592--4.0</span></span><br><span class="line"><span class="comment"># 父进程结束</span></span><br></pre></td></tr></table></figure>

<hr>
<p>进程间的通讯:<br>==使用队列==:<br>父进程创建队列,并传递给子进程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;启动写子进程&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 将数据放入Queue中</span></span><br><span class="line">        q.put(each)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结束写子进程&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;启动读子进程&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 从Queue中获取</span></span><br><span class="line">        value = q.get(<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;value= <span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结束读子进程&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程开始&#x27;</span>)</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="comment"># 将队列传进两个进程</span></span><br><span class="line">    pw = Process(target=write,args=(q,))</span><br><span class="line">    pr = Process(target=read,args=(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 结束写子进程</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是一个死循环,无法等待其结束,只能强行结束</span></span><br><span class="line">    <span class="comment"># 简单来说,因为写进程已经结束了,此时读进程就可以结束了,但是因为这是一个死循环,所以只能使用terminate来强制结束</span></span><br><span class="line">    pr.terminate()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动写子进程</span></span><br><span class="line"><span class="comment"># 启动读子进程</span></span><br><span class="line"><span class="comment"># value= a</span></span><br><span class="line"><span class="comment"># value= b</span></span><br><span class="line"><span class="comment"># value= c</span></span><br><span class="line"><span class="comment"># 结束写子进程</span></span><br><span class="line"><span class="comment"># 父进程结束</span></span><br></pre></td></tr></table></figure>

<hr>
<p>在一个进程的内容,要同时干多件事,就需要同时运行多个子任务,我们把进程内的这些子任务叫做线程.</p>
<p>线程是共享内存空间的并发执行的多任务,每一个线程都共享一个进程的资源.</p>
<p>线程是最小的执行单元,而进程由至少一个线程组成,如何调用进程和线程,完全由操作系统决定,程序自己不能决定.</p>
<p>任何进程默认都会启动一个线程,称为主线程.主线程可以启动新的子线程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程<span class="subst">&#123;threading.current_thread().name&#125;</span>启动&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程<span class="subst">&#123;threading.current_thread().name&#125;</span>结束&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># current_thread():返回当前线程的实例</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;主线程<span class="subst">&#123;threading.current_thread().name&#125;</span>启动&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建子线程</span></span><br><span class="line">    t = threading.Thread(target=run,name=<span class="string">&#x27;root_thread&#x27;</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;主线程<span class="subst">&#123;threading.current_thread().name&#125;</span>结束&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 主线程MainThread启动</span></span><br><span class="line"><span class="comment"># 子线程root_thread启动</span></span><br><span class="line"><span class="comment"># 主线程MainThread结束</span></span><br><span class="line"><span class="comment"># 123</span></span><br><span class="line"><span class="comment"># 子线程root_thread结束</span></span><br></pre></td></tr></table></figure>

<p>可以看到,主线程并没有等待子线程结束.<br>等待线程结束一样使用t.join()</p>
<hr>
<p>线程间共享数据,所以会出现数据混乱.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        num += n</span><br><span class="line">        num -= n</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=run,args=(<span class="number">6</span>,))</span><br><span class="line">    t2 = threading.Thread(target=run,args=(<span class="number">9</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(num)  <span class="comment"># -48</span></span><br></pre></td></tr></table></figure>

<p>这时可以使用<strong>线程锁</strong>来解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"><span class="comment"># 锁对象</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        <span class="comment"># 上锁</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            num += n</span><br><span class="line">            num -= n</span><br><span class="line">        <span class="comment"># 保证一定会开锁</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 开锁</span></span><br><span class="line">            lock.release()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=run,args=(<span class="number">6</span>,))</span><br><span class="line">    t2 = threading.Thread(target=run,args=(<span class="number">9</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(num)  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<p>锁阻塞了多线程的并发执行,包含锁的某段代码实际上之恩能够以单线程模式执行,所以效率大大降低了.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 太复杂</span></span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num += n</span><br><span class="line">    num -= n</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    lock.release()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="comment"># 自动上锁与解锁</span></span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">    num += n</span><br><span class="line">    num -= n</span><br></pre></td></tr></table></figure>

<p>由于可以存在多个锁,不同的线程持有不同的锁,并试图获取其他的锁,可能造成死锁,导致多个线程挂起,只能靠操作系统强制终止.</p>
<p>第二种解决方法:使用ThreadLocal:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个全局的ThreadLocal对象</span></span><br><span class="line"><span class="comment"># 每个线程有独立的存储空间</span></span><br><span class="line"><span class="comment"># 每个线程对ThreadLocal对象都可以读写,但是互不影响</span></span><br><span class="line"><span class="comment"># 简单来说,就像进程一样,让不同的线程备份一个一模一样的变量</span></span><br><span class="line">local = threading.local()</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">x,n</span>):</span></span><br><span class="line">    x += n</span><br><span class="line">    x -= n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 给local对象增加一个x属性</span></span><br><span class="line">    <span class="comment"># 每个线程都有local.x,就是线程的局部变量</span></span><br><span class="line">    local.x = num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        run(local.x,n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread().name&#125;</span>------<span class="subst">&#123;local.x&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=func,args=(<span class="number">6</span>,))</span><br><span class="line">    t2 = threading.Thread(target=func,args=(<span class="number">9</span>,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Thread-2------0</span></span><br><span class="line"><span class="comment"># Thread-1------0</span></span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<p>local:<br>为每个线程绑定一个数据库链接,HTTP请求,用户身份信息等.这样一个线程的所有调用到的处理函数都可以非常方便的访问这些资源.</p>
<p>使用进程来实现socket边监听边响应:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器</span></span><br><span class="line"><span class="keyword">import</span> socket,threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 绑定IP端口</span></span><br><span class="line">server.bind((<span class="string">&#x27;192.168.75.1&#x27;</span>, <span class="number">8081</span>))</span><br><span class="line"><span class="comment"># 监听,允许5个客户端连接</span></span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;服务器启动,等待客户端的连接&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">ck</span>):</span></span><br><span class="line">    <span class="comment"># 注意这里需要一个while True来实现持续性的交互</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 接受客户端的数据</span></span><br><span class="line">        data = ck.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;收到数据: <span class="subst">&#123;data&#125;</span>&#x27;</span>)</span><br><span class="line">        sendData = <span class="string">&quot;this is server&#x27;s response&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        ck.send(sendData)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 等待连接</span></span><br><span class="line">    clientSocket, clientAddress = server.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;客户端 <span class="subst">&#123;clientAddress&#125;</span> 连接成功&#x27;</span>)</span><br><span class="line">    t = threading.Thread(target=run,args=(clientSocket,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&#x27;192.168.75.1&#x27;</span>,<span class="number">8081</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = <span class="built_in">input</span>(<span class="string">&#x27;请输出给服务器发送的数据&#x27;</span>).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    client.send(data)</span><br><span class="line">    <span class="comment"># 接受服务器的响应</span></span><br><span class="line">    info = client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;服务器响应为: <span class="subst">&#123;info&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>信号量控制线程数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制同时执行的线程数量</span></span><br><span class="line">sem = threading.Semaphore(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">with</span> sem:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread().name&#125;</span>---<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        threading.Thread(target=run).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Thread-1---0</span></span><br><span class="line"><span class="comment"># Thread-2---0</span></span><br><span class="line"><span class="comment"># Thread-3---0</span></span><br><span class="line"><span class="comment"># Thread-3---1</span></span><br><span class="line"><span class="comment"># Thread-2---1</span></span><br><span class="line"><span class="comment"># Thread-1---1</span></span><br><span class="line"><span class="comment"># Thread-3---2</span></span><br><span class="line"><span class="comment"># Thread-2---2</span></span><br><span class="line"><span class="comment"># Thread-1---2</span></span><br><span class="line"><span class="comment"># Thread-2---3</span></span><br><span class="line"><span class="comment"># Thread-3---3</span></span><br><span class="line"><span class="comment"># Thread-1---3</span></span><br><span class="line"><span class="comment"># Thread-4---0</span></span><br><span class="line"><span class="comment"># Thread-5---0</span></span><br><span class="line"><span class="comment"># Thread-4---1</span></span><br><span class="line"><span class="comment"># Thread-5---1</span></span><br><span class="line"><span class="comment"># Thread-4---2</span></span><br><span class="line"><span class="comment"># Thread-5---2</span></span><br><span class="line"><span class="comment"># Thread-4---3</span></span><br><span class="line"><span class="comment"># Thread-5---3</span></span><br></pre></td></tr></table></figure>

<p>上面代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    threading.Thread(target=run).start()</span><br></pre></td></tr></table></figure>

<p>只有五个线程执行完毕才会结束.<br>但是<code>sem = threading.Semaphore(3)</code>限定了同时最多只有3个线程.所以这段代码会先执行3个线程,然后在执行2个线程.(每个线程打印0-3)</p>
<hr>
<p>凑够一定数量的线程才能执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 凑够一定数量的线程才能执行</span></span><br><span class="line">bar = threading.Barrier(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread().name&#125;</span>---start&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 在这里等待,直到够4个才能执行下面代码</span></span><br><span class="line">    bar.wait()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;threading.current_thread().name&#125;</span>---end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        threading.Thread(target=run).start()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Thread-1---start</span></span><br><span class="line"><span class="comment"># Thread-2---start</span></span><br><span class="line"><span class="comment"># Thread-3---start</span></span><br><span class="line"><span class="comment"># Thread-4---start</span></span><br><span class="line"><span class="comment"># Thread-5---start</span></span><br><span class="line"><span class="comment"># Thread-6---start</span></span><br><span class="line"><span class="comment"># Thread-6---end</span></span><br><span class="line"><span class="comment"># Thread-2---end</span></span><br><span class="line"><span class="comment"># Thread-3---end</span></span><br><span class="line"><span class="comment"># Thread-1---end</span></span><br></pre></td></tr></table></figure>

<p>上面代码,需要执行完6个线程才会结束.<br>一开始,执行六个线程,然后执行到<code>bar.wait()</code>时会等待,凑够4个线程才会执行.</p>
<hr>
<p>定时线程:<br>(启动了线程,但是要等5秒后才能执行)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 使用Timer,而不是Thread</span></span><br><span class="line">    t = threading.Timer(<span class="number">5</span>,run)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父线程结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (等待5秒后)</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"><span class="comment"># 父线程结束</span></span><br></pre></td></tr></table></figure>

<hr>
<p>线程通讯</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="comment"># 创建事件对象</span></span><br><span class="line">    event = threading.Event()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="comment"># 阻塞,等待事件的触发</span></span><br><span class="line">            event.wait()</span><br><span class="line">            <span class="comment"># 重置堵塞(去掉这行则只会重置一次)</span></span><br><span class="line">            event.clear()</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            </span><br><span class="line">    threading.Thread(target=run).start()</span><br><span class="line">    <span class="keyword">return</span> event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    e = func()</span><br><span class="line">    <span class="comment"># 触发事件</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        e.<span class="built_in">set</span>()</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印0,1,2,3,4(每2秒打印一个数字)</span></span><br></pre></td></tr></table></figure>

<p>当执行<code>e = func()</code>的时候就已经启动线程了,但是执行到<code>event.wait()</code>的时候线程被挂起.<br>之后执行<code>e.set()</code>的时候线程恢复.</p>
<p>如果去掉<code>event.clear()</code>,则是等待2秒后直接打印0,1,2,3,4</p>
<p>其实wait和clear和e.set()只是设置一个标志符而已:</p>
<ol>
<li>执行<code>event.wait()</code>则把flag位置为False(False就是阻塞),</li>
<li>遇到<code>e.set()</code>就把flag设置为True.</li>
<li><code>event.clear()</code>再次把flag设置为True.</li>
</ol>
<hr>
<p>生产者和消费者</p>
<p><strong>回忆进程间通讯</strong><br>生产者就是生产数据的,<br>消费者就是处理数据的</p>
<p><img src="/images/113637f1-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85.jpg" alt="生产者与消费者"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time,queue,random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params"><span class="built_in">id</span>,q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        num = random.randint(<span class="number">0</span>,<span class="number">1000</span>)</span><br><span class="line">        q.put(num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;生产者<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>生产了<span class="subst">&#123;num&#125;</span>数据放入了队列&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 任务完成(生产者结束生产数据)</span></span><br><span class="line">    q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customer</span>(<span class="params"><span class="built_in">id</span>,q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;消费者<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>消费了<span class="subst">&#123;item&#125;</span>数据&#x27;</span>)      </span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 任务完成(消费者结束消费数据)</span></span><br><span class="line">    q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 消息队列</span></span><br><span class="line">    q = queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动生产者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        threading.Thread(target=product,args=(i,q)).start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动消费者</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        threading.Thread(target=customer,args=(i,q)).start()</span><br></pre></td></tr></table></figure>

<hr>
<p>线程调度:<br>现在有两个线程:</p>
<ol>
<li>线程1打印0,2,4,6,8</li>
<li>线程2打印1,3,5,7,9</li>
</ol>
<p>现在想设计一段程序按序打印0-9</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程条件变量</span></span><br><span class="line">cond = threading.Condition()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run1</span>():</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name,i)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            cond.wait()</span><br><span class="line">            <span class="comment"># 唤醒指令:用于唤醒其他线程</span></span><br><span class="line">            cond.notify()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run2</span>():</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(threading.current_thread().name,i)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            cond.notify()</span><br><span class="line">            cond.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    threading.Thread(target=run1).start()</span><br><span class="line">    threading.Thread(target=run2).start()</span><br></pre></td></tr></table></figure>

<p>解释:<br>run1在执行wait后阻塞线程,然后执行notify唤醒run2</p>
<p>注意run1和run2的<code>wait</code>和<code>notify</code>顺序不可改变</p>
<hr>
<p>进程与线程:</p>
<ol>
<li>多任务的实现原理:<br>==通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务==，因此，多任务环境下，通常是一个Master,多个Worker</li>
<li>多进程:<ul>
<li>主进程就是Master,其他进程就是Worker</li>
<li>优点:稳定性高:<br>一个子进程崩溃了，不会影响主进程和其他子进程，当然主进程挂掉了,所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低</li>
<li>缺点:<ol>
<li>创建进程的代价大:<br>在Unix/Linux系统下，用fork调用还行，在Window创建进程开销巨大。</li>
<li>操作系统能同时运行的进程数有限:<br>在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题</li>
</ol>
</li>
</ul>
</li>
<li>多线程:<ul>
<li>主线程就是Master，其他线程就是Worker</li>
<li>优点:<ol>
<li>多线程模式通常比多进程快一点，但是也快不到哪去</li>
<li>在Windows下，多线程的效率比多进程要高</li>
</ol>
</li>
<li>缺点:<br>任何一个线程挂掉都可能直接造成整个进程崩溃<br>(所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程)</li>
</ul>
</li>
<li>计算密集型vs IO密集型:<ul>
<li>计算密集型<br>要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，==要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数==。</li>
<li>IO密集型<br>涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，==任务越多，CPU效率越高==，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</li>
</ul>
</li>
</ol>
<hr>
<p>进程和线程的形象比喻：</p>
<ol>
<li>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</li>
<li>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。</li>
<li>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</li>
<li>一个车间里，可以有很多工人。他们协同完成一个任务。线程就好比车间里的工人。一个进程可以包括多个线程。</li>
<li>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li>
<li>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81">“互斥锁”</a>（Mutual exclusion，缩写Mutex），防止多个线程同时读写某一块内存区域。</li>
<li>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</li>
<li>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。<br>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</li>
<li>操作系统的设计，因此可以归结为三点：<br> （1）以多进程形式，允许多个任务同时运行；<br> （2）以多线程形式，允许单个任务分成不同的部分运行；<br> （3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li>
</ol>
<p>通俗点说：<br> 并发就是不同线程同时干一件事情<br> 并行就是不同线程同时干不同的事情</p>
<hr>
<p>异步与同步：</p>
<ol>
<li>异步：多任务，多个任务之间执行没有先后顺序，可以同时运行，执行的先后顺序不会有什么影响，存在的多条运行主线</li>
<li>同步：多任务，多个任务之间执行的时候要求有先后顺序，必须一个先执行完成之后，另一个才能继续执行，只有一个主线</li>
<li>阻塞：从调用者的角度出发，如果在调用的时候，被卡住，不能再继续向下运行，需要等待，就说是阻塞。</li>
<li>非阻塞：从调用者的角度出发，如果在调用的时候，没有被卡住，能够继续向下运行，无需等待，就说是非阻塞。</li>
</ol>
<hr>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>子程序/子函数:<br>在所有语言中都是层级调用，比如A调用B,在B执行的过程中又可以调用c。c执行完毕返回，B执行完毕返回，最后是A执行完毕.<br>整个过程是通过栈实现的,一个线程就是执行一个子程序.子程序调用总是一个入口，一次返回，调用的顺序是明确的</p>
<p>概述:<br>看上去也是子程序，但执行过程中，==在子程序的内部可中断，然后转而执行别的子程序==。不是函数调用，有点类似CPU中断.</p>
<p>eg:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 对于协程,上面两个函数可以按序打印出1,2,x,y,z,3</span></span><br><span class="line"><span class="comment"># 执行出这个结果,但是A中是没有B的调用</span></span><br></pre></td></tr></table></figure>

<p>看起来A.B执行过程有点像线程，但协程的特点在于是一个线程</p>
<p>优点:<br><strong>与线程相比，协程的执行效率极高，因为只有一个线程，也不存在同时写变量的冲突，在协程中共享资源不加锁，只需要判断状态</strong></p>
<p>python对协程的支持是通过generator实现的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最简单的协程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制函数的阶段执行，节约线程或者进程的切换</span></span><br><span class="line">m = run()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(m))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    r = <span class="keyword">yield</span> data</span><br><span class="line">    <span class="built_in">print</span>(r,data)</span><br><span class="line">    r = <span class="keyword">yield</span> data</span><br><span class="line">    <span class="built_in">print</span>(r,data)</span><br><span class="line">    r = <span class="keyword">yield</span> data</span><br><span class="line">    <span class="built_in">print</span>(r,data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    f = func()</span><br><span class="line">    <span class="built_in">print</span>(f.send(<span class="literal">None</span>))</span><br><span class="line">    <span class="built_in">print</span>(f.send(<span class="string">&#x27;hyl&#x27;</span>)) <span class="comment"># hyl</span></span><br><span class="line">    <span class="built_in">print</span>(f.send(<span class="string">&#x27;123&#x27;</span>)) <span class="comment"># 123</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;---生产者生产数据<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        r = c.send(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;***消费者消费数据<span class="subst">&#123;r&#125;</span>&#x27;</span>)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customer</span>():</span></span><br><span class="line">    data = <span class="number">1000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> data</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;+++消费者消费数据<span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line">        data += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">c = customer()</span><br><span class="line">product(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---生产者生产数据0</span></span><br><span class="line"><span class="comment"># +++消费者消费数据0</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1001</span></span><br><span class="line"><span class="comment"># ---生产者生产数据1</span></span><br><span class="line"><span class="comment"># +++消费者消费数据1</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1002</span></span><br><span class="line"><span class="comment"># ---生产者生产数据2</span></span><br><span class="line"><span class="comment"># +++消费者消费数据2</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1003</span></span><br><span class="line"><span class="comment"># ---生产者生产数据3</span></span><br><span class="line"><span class="comment"># +++消费者消费数据3</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1004</span></span><br><span class="line"><span class="comment"># ---生产者生产数据4</span></span><br><span class="line"><span class="comment"># +++消费者消费数据4</span></span><br><span class="line"><span class="comment"># ***消费者消费数据1005</span></span><br></pre></td></tr></table></figure>

<p>注意这两个函数的关系有点像master和worker的关系.<br>product就像是master,customer就像是worker.</p>
<p>customer不断的被挂起,然后又被调用,之后又被挂起.</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>