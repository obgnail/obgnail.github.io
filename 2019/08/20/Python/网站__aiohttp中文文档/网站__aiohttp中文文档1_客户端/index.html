<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;网址&quot;&gt;&lt;a href=&quot;#网址&quot; class=&quot;headerlink&quot; title=&quot;网址&quot;&gt;&lt;/a&gt;网址&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/book/hubertroy/aiohttp-chinese-documentation&quot;&gt;aiohttp中文文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;核心功能&quot;&gt;&lt;a href=&quot;#核心功能&quot; class=&quot;headerlink&quot; title=&quot;核心功能&quot;&gt;&lt;/a&gt;核心功能&lt;/h2&gt;&lt;p&gt;aiohttp是一个基于asyncio,为Python提供异步HTTP 客户端/服务端编程异步库。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>aiohttp中文文档1_客户端 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Python/" rel="tag">Python</a></div><div class="post-time">2019-08-20</div></div></div><div class="container post-header"><h1>aiohttp中文文档1_客户端</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E5%9D%80"><span class="toc-number">1.</span> <span class="toc-text">网址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">核心功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="toc-number">3.</span> <span class="toc-text">快速开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APIs"><span class="toc-number">4.</span> <span class="toc-text">APIs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClientSession%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">ClientSession类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClientResponse%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">ClientResponse类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClientWebSocketResponse%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text">ClientWebSocketResponse类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ws-connect%E7%B1%BB"><span class="toc-number">4.4.</span> <span class="toc-text">ws_connect类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8%E7%B1%BBConnector"><span class="toc-number">4.5.</span> <span class="toc-text">连接器类Connector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BaseConnector"><span class="toc-number">4.5.1.</span> <span class="toc-text">BaseConnector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCPConnector"><span class="toc-number">4.5.2.</span> <span class="toc-text">TCPConnector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UnixConnector"><span class="toc-number">4.5.3.</span> <span class="toc-text">UnixConnector</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CookieJar%E7%B1%BB"><span class="toc-number">4.6.</span> <span class="toc-text">CookieJar类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DummyCookieJar%E7%B1%BB"><span class="toc-number">4.7.</span> <span class="toc-text">DummyCookieJar类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session-request%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.</span> <span class="toc-text">session.request方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session-get-%E5%92%8C-session-post%E6%96%B9%E6%B3%95"><span class="toc-number">4.9.</span> <span class="toc-text">session.get 和 session.post方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82"><span class="toc-number">5.1.</span> <span class="toc-text">发起请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST%E8%AF%B7%E6%B1%82"><span class="toc-number">5.2.</span> <span class="toc-text">POST请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E8%AF%B7%E6%B1%82"><span class="toc-number">5.3.</span> <span class="toc-text">JSON请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92URL%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">传递URL中的请求参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9"><span class="toc-number">5.5.</span> <span class="toc-text">获取响应内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8Cjson%E5%93%8D%E5%BA%94"><span class="toc-number">5.6.</span> <span class="toc-text">获取二进制和json响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94"><span class="toc-number">5.7.</span> <span class="toc-text">获取流式响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Headers"><span class="toc-number">5.8.</span> <span class="toc-text">自定义Headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Cookies"><span class="toc-number">5.9.</span> <span class="toc-text">自定义Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9A%84cookies"><span class="toc-number">5.10.</span> <span class="toc-text">获取当前的cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%A4%9A%E9%83%A8%E5%88%86%E7%BC%96%E7%A0%81%E6%96%87%E4%BB%B6-Multipart-Encoded"><span class="toc-number">5.11.</span> <span class="toc-text">发送多部分编码文件(Multipart-Encoded)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E4%B8%8A%E4%BC%A0"><span class="toc-number">5.12.</span> <span class="toc-text">流式上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E9%A2%84%E5%8E%8B%E7%BC%A9%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">5.13.</span> <span class="toc-text">上传预压缩过的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5-keep-alive-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%92%8Ccookies%E5%85%B1%E4%BA%AB"><span class="toc-number">5.14.</span> <span class="toc-text">持久连接(keep-alive), 连接池和cookies共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8cookies"><span class="toc-number">5.15.</span> <span class="toc-text">安全cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E5%81%87Cookie-Jar"><span class="toc-number">5.16.</span> <span class="toc-text">使用虚假Cookie Jar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E5%99%A8connector"><span class="toc-number">5.17.</span> <span class="toc-text">使用连接器connector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%AE%B9%E9%87%8F"><span class="toc-number">5.18.</span> <span class="toc-text">限制连接池的容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">5.19.</span> <span class="toc-text">使用自定义域名服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BATCP-sockets%E6%B7%BB%E5%8A%A0SSL%E6%8E%A7%E5%88%B6"><span class="toc-number">5.20.</span> <span class="toc-text">为TCP sockets添加SSL控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%94%AF%E6%8C%81"><span class="toc-number">5.21.</span> <span class="toc-text">代理支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">5.22.</span> <span class="toc-text">查看响应状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AETimeout"><span class="toc-number">5.23.</span> <span class="toc-text">设置Timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">5.24.</span> <span class="toc-text">获取响应头信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E5%8E%86%E5%8F%B2"><span class="toc-number">5.25.</span> <span class="toc-text">获取响应历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8WebSockets"><span class="toc-number">5.26.</span> <span class="toc-text">使用WebSockets</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%AD%89%E7%BA%A7%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">异常等级图</span></a></li></ol></details></div><div class="container post-content"><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.gitbook.com/book/hubertroy/aiohttp-chinese-documentation">aiohttp中文文档</a></li>
</ol>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><p>aiohttp是一个基于asyncio,为Python提供异步HTTP 客户端/服务端编程异步库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiohttp</span><br></pre></td></tr></table></figure>

<p>安装更快的<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/glossary.html#term-cchardet">cchardet</a>库来代替<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/glossary.html#term-chardet">chardet</a>进行解码: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install cchardet</span><br></pre></td></tr></table></figure>

<p>更快的客户端API DNS解析方案<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/glossary.html#term-aiodns">aiodns</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiodns</span><br></pre></td></tr></table></figure>



<ul>
<li>同时支持<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/client.html#aiohttp-client">客户端使用</a>和<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/web.html#aiohttp-web">服务端使用</a>。</li>
<li>同时支持<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/web.html#aiohttp-web-websockets">服务端WebSockets组件</a>和<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/client.html#aiohttp-client-websockets">客户端WebSockets组件</a>，开箱即用。</li>
<li>web服务器具有<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/web.html#aiohttp-web-middlewares">中间件</a>，<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/web.html#aiohttp-web-signals">信号组件</a>和可插拔路由的功能。</li>
</ul>
<p>下面两段代码功能是一样的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro</span>(<span class="params">...</span>):</span></span><br><span class="line">    ret = <span class="keyword">await</span> f()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coro</span>(<span class="params">...</span>):</span></span><br><span class="line">   ret = <span class="keyword">yield</span> <span class="keyword">from</span> f()</span><br></pre></td></tr></table></figure>



<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> async_timeout</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">session, url</span>):</span></span><br><span class="line">    <span class="keyword">with</span> async_timeout.timeout(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html = <span class="keyword">await</span> fetch(session, <span class="string">&#x27;http://python.org&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(html)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">request</span>):</span></span><br><span class="line">    name = request.match_info.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&quot;Anonymous&quot;</span>)</span><br><span class="line">    text = <span class="string">&quot;Hello, &quot;</span> + name</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=text)</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#x27;</span>, handle)</span><br><span class="line">app.router.add_get(<span class="string">&#x27;/&#123;name&#125;&#x27;</span>, handle)</span><br><span class="line"></span><br><span class="line">web.run_app(app)</span><br></pre></td></tr></table></figure>



<h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><h3 id="ClientSession类"><a href="#ClientSession类" class="headerlink" title="ClientSession类"></a>ClientSession类</h3><p><strong>ClientSession类用于创建客户端会话以及发起请求</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">ClientSession</span>(<span class="params">*, connector=<span class="literal">None</span>, loop=<span class="literal">None</span>, cookies=<span class="literal">None</span>, headers=<span class="literal">None</span>, skip_auto_headers=<span class="literal">None</span>, auth=<span class="literal">None</span>, json_serialize=json.dumps, version=aiohttp.HttpVersion11, cookie_jar=<span class="literal">None</span>, read_timeout=<span class="literal">None</span>, conn_timeout=<span class="literal">None</span>, raise_for_status=<span class="literal">False</span>, connector_owner=<span class="literal">True</span>, auto_decompress=<span class="literal">True</span>, proxies=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>connector (aiohttp.connector.BaseConnector) :<br>基础连接器(BaseConnector)的子类实例，用于支持连接池。</p>
</li>
<li><p>loop:<br>事件循环,用于处理HTTP请求. 一般用asyncio.get_event_loop()来获取事件循环。   </p>
</li>
<li><p>skip_auto_headers:<br>跳过会自动产生的headers值.</p>
<blockquote>
<ul>
<li>如果没有显式传递，那么aiohttp会自动生成诸如User-Agent或Content-Type。</li>
<li>使用该参数可以指定跳过，但注意Content-Length是不能跳过的。</li>
</ul>
</blockquote>
</li>
<li><p>auth(aiohttp.BasicAuth) :<br>表示<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81"> HTTP基本认证</a>的对象。</p>
</li>
<li><p>cookie_jar:<br>AbstractCookieJar的实例。</p>
<blockquote>
<ul>
<li>默认情况下每个会话实例都有自己的私有cookie jar用于自动处理cookies，</li>
<li>但用户也可使用自己的jar重新定义其行为。</li>
<li>在代理模式下不会处理cookies。</li>
<li>如果不需要cookie处理，可以传递一个aiohttp.helper.DummyCookieJar实例。</li>
</ul>
</blockquote>
</li>
<li><p>json_serialize (可调用对象):<br> 可调用的Json序列化对象，默认是json.dumps()函数。 </p>
</li>
<li><p>raise_for_status (布尔类型):<br>每完成一个响应就自动调用 ClientResponse.raise_for_status(), 默认是False.</p>
</li>
<li><p>read_timeout (浮点数):<br><strong>请求操作</strong>的超时时间。<br>read_timeout是累计自所有的请求操作(请求，重定向，响应，数据处理)。默认情况下是 5分钟。传递None或0来禁用超时检测。</p>
</li>
<li><p>conn_timeout (浮点数):<br> <strong>建立连接</strong>的超时时间(可选)。0或None则禁用超时检测。</p>
</li>
<li><p>connector_owner (布尔类型):<br><strong>会话关闭时一同关闭连接器实例</strong>。<br>传递False让构造器允许在多个会话间共享连接池，不过cookies等信息是不共享的。</p>
</li>
<li><p>auto_decompress (布尔类型):<br>自动解压响应体。 </p>
</li>
<li><p>trust_env(布尔类型):<br>若该参数设置为True则从环境变量HTTP_PROXY / HTTPS_PROXY中获取代理信息。</p>
</li>
</ul>
<h3 id="ClientResponse类"><a href="#ClientResponse类" class="headerlink" title="ClientResponse类"></a>ClientResponse类</h3><p>ClientSession.requests() 及其同类成员的返回对象。</p>
<ul>
<li>version<br>返回响应的版本信息，是HttpVersion实例对象。</li>
<li>status<br>返回响应的HTTP状态码(整数)，比如: 200。</li>
<li>reason<br>返回响应的HTTP叙述(字符串)，比如”OK”。</li>
<li>method<br>返回请求的HTTP方法(字符串)。</li>
<li>url<br>返回请求的URL(URL对象)。</li>
<li>connection<br>返回处理响应的连接。</li>
<li>content<br>包含响应主体(StreamReader)的载体流。支持多种读取方法。服务器使用分块传输编码时同样允许分块接受。<br>读取时可能会抛出aiohttp.ClientPayloadError，这种情况发生在响应对象在接受所有的数据前就关闭了或有任何传输编码相关的错误如错误的压缩数据所造成的不规则分块编码。</li>
<li>cookies<br>响应中的HTTP cookies,(由Set-Cookie HTTP头信息设置, 属于SimpleCookie)</li>
<li>headers<br>返回响应的HTTP头信息，是一个大小写不敏感的并联字典(CIMultiDictProxy)。</li>
<li>raw_headers<br>返回原始HTTP头信息，未经编码，格式是键值对形式。</li>
<li>content_type<br>返回Content-Type头信息的内容。该属性只读。</li>
<li>charset<br>返回请求的主体的编码。<br>该值来自于Content-Type HTTP头信息。<br>返回的值是类似于’utf-8’之类的字符串，如果HTTP头中不含Content-Type或其中没有charset信息则是None。</li>
<li>history<br>返回包含所有的重定向请求(都是ClientResponse对象，最开始的请求在最前面)的序列，如果没用重定向则返回空序列。</li>
</ul>
<h3 id="ClientWebSocketResponse类"><a href="#ClientWebSocketResponse类" class="headerlink" title="ClientWebSocketResponse类"></a>ClientWebSocketResponse类</h3><p>用于处理客户端websockets的类。使用协程方法aiohttp.ws_connect()或aiohttp.ClientSession.ws_connect()连接使用websocket的服务器，不要手动来创建ClientWebSocketResponse。</p>
<p>方法:</p>
<ul>
<li><p>closed:<br>如果close()已经调用过或接受了CLOSE消息则返回True。该属性只读。</p>
</li>
<li><p>protocol:<br>调用start()后选择的websocket协议。<br>如果服务器和客户端所选协议不一致则是None。</p>
</li>
<li><p>get_extra_info(name, default=None)<br>返回从连接的transport中读取到的额外的信息。</p>
</li>
<li><p>exception()<br>如果有错误则返回那个错误，否则返回None。</p>
</li>
<li><p>ping(message=b’’)<br>向服务器发送PING.</p>
<blockquote>
<p>message参数:<br>发送PING时携带的消息，类型是由UTF-8编码的字符串或字节码。(可选)</p>
</blockquote>
</li>
<li><p>coroutine send_str(data)<br>向服务器发送文本消息。</p>
<blockquote>
<p>data参数:<br>字符串, 要发送的消息.如果不是字符串会抛出TypeError错误。</p>
</blockquote>
</li>
<li><p>coroutine send_bytes(data)<br>向服务器发送二进制消息。</p>
<blockquote>
<p>data参数:<br>要发送的消息。如果不是字节码，字节数组或memoryview将抛出TypeError错误。</p>
</blockquote>
</li>
<li><p>coroutine send_json(data, *, dumps=json.dumps)<br>向服务器发送json字符串。</p>
</li>
<li><p>coroutine close(*, code=1000, message=b’’)<br>用于向服务器发起挥手(CLOSE)信息，请求关闭连接。它会等待服务器响应。这是一个异步方法，所以如果要添加超时时间可以用asyncio.wait()或asyncio.wait_for()包裹。</p>
<blockquote>
<p>参数:<br>code (整数) : 关闭状态码。<br>message : pong消息携带的信息，类型是由UTF-8编码的字符串或字节码。</p>
</blockquote>
</li>
<li><p>coroutine receive()<br>等待服务器传回消息并在接受后将其返回。<br>此方法隐式的处理PING, PONG, CLOSE消息。(不会返回这些消息)</p>
<blockquote>
<p>此方法返回WSMessage对象</p>
</blockquote>
</li>
<li><p>coroutine receive_str()<br>调用receive()并判断该消息是否是文本。</p>
<blockquote>
<p>此方法返回服务器传回的内容。 </p>
</blockquote>
</li>
<li><p>coroutine receive_bytes()<br>调用receive()并判断该消息是否是二进制内容。</p>
<blockquote>
<p>此方法返回服务器传回的内容。 </p>
</blockquote>
</li>
<li><p>coroutine receive_json(*, loads=json.loads)<br>调用receive_str()并尝试将JSON字符串转成Python中的dict(字典)。</p>
<blockquote>
<p>此方法返回处理过的JSON内容。 </p>
</blockquote>
</li>
</ul>
<h3 id="ws-connect类"><a href="#ws-connect类" class="headerlink" title="ws_connect类"></a>ws_connect类</h3><p>创建一个websocket连接。返回ClientWebSocketResponse对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ws_connect</span>(<span class="params">url, *, protocols=(<span class="params"></span>), timeout=<span class="number">10.0</span>, receive_timeout=<span class="literal">None</span>, auth=<span class="literal">None</span>, autoclose=<span class="literal">True</span>, autoping=<span class="literal">True</span>, heartbeat=<span class="literal">None</span>, origin=<span class="literal">None</span>, proxy=<span class="literal">None</span>, proxy_auth=<span class="literal">None</span>, verify_ssl=<span class="literal">None</span>, fingerprint=<span class="literal">None</span>, ssl_context=<span class="literal">None</span>, proxy_headers=<span class="literal">None</span>, compress=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li>protocols(元组) :<br>websocket 协议。</li>
<li>timeout(浮点数) :<br><strong>超过超时时间后关闭websocket</strong>。默认是10秒。</li>
<li>receive_timeout(浮点数) :<br>超过超时时间后不再从websocket接受消息。默认是None。</li>
<li>autoclose(布尔类型):<br>默认为True。<strong>从服务器接受完消息后自动关闭websocket</strong>. 如果该参数为False，那么需要手动进行关闭</li>
<li>autoping(布尔类型) :<br>当从服务器收到ping信息后自动回复pong信息。</li>
<li>heartbeat(浮点数) :<br>每到心跳时间则发送ping信息并等待pong信息响应，如果没有收到pong信息则关闭连接。</li>
<li>origin(字符串) :<br>发送到服务器的origin信息。</li>
</ul>
<h3 id="连接器类Connector"><a href="#连接器类Connector" class="headerlink" title="连接器类Connector"></a>连接器类Connector</h3><p>连接器用于<strong>支持aiohttp客户端API传输数据</strong>。<br>这俩是标准连接器:</p>
<ol>
<li>TCPConnector 用于使用TCP连接(包括HTTP和HTTPS连接)。</li>
<li>UnixConnector 用于使用UNIX连接(大多数情况下都用于测试的目的)。<br>所有的连接器都应是BaseConnector的子类。<br>默认情况下所有连接器都支持持久连接(keep-alive)(该行为由force_close参数控制)</li>
</ol>
<h4 id="BaseConnector"><a href="#BaseConnector" class="headerlink" title="BaseConnector"></a>BaseConnector</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">BaseConnector</span>(<span class="params">*, keepalive_timeout=<span class="number">15</span>, force_close=<span class="literal">False</span>, limit=<span class="number">100</span>, limit_per_host=<span class="number">0</span>, enable_cleanup_closed=<span class="literal">False</span>, loop=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>keepalive_timeout(浮点数) :<br>释放后到再次使用的超时时间(可选)。禁用keep-alive可以传入0，或使用force_close=True。</li>
<li>limit(整数) :<br>并发连接的总数。如果为None则不做限制。(默认为100)</li>
<li>limit_per_host :<br>向同一个端点并发连接的总数。同一端点是具有相同 (host, port, is_ssl)信息的玩意 x 3! 如果是0则不做限制。(默认为0)</li>
<li>force_close(布尔类型) :<br>连接释放后关闭底层网络套接字。(该参数可选)</li>
<li>enable_cleanup_closed (布尔类型) :<br>一些SSL服务器可能会没有正确的完成SSL关闭过程，这种时候asyncio会泄露SSL连接。如果设置为True，aiohttp会在两秒后额外执行一次停止。此功能默认不开启。</li>
<li>loop :<br>事件循环(event loop)</li>
</ul>
<h4 id="TCPConnector"><a href="#TCPConnector" class="headerlink" title="TCPConnector"></a>TCPConnector</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">TCPConnector</span>(<span class="params">*, verify_ssl=<span class="literal">True</span>, fingerprint=<span class="literal">None</span>, use_dns_cache=<span class="literal">True</span>, ttl_dns_cache=<span class="number">10</span>, family=<span class="number">0</span>, ssl_context=<span class="literal">None</span>, local_addr=<span class="literal">None</span>, resolver=<span class="literal">None</span>, keepalive_timeout=sentinel, force_close=<span class="literal">False</span>, limit=<span class="number">100</span>, limit_per_host=<span class="number">0</span>, enable_cleanup_closed=<span class="literal">False</span>, loop=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>用于使用TCP处理HTTP和HTTPS的连接器。<br>TCPConnector继承于BaseConnector.<br>接受BaseConnector所需的所有参数和几个额外的TCP需要的参数。</p>
<h4 id="UnixConnector"><a href="#UnixConnector" class="headerlink" title="UnixConnector"></a>UnixConnector</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">UnixConnector</span>(<span class="params">path, , conn_timeout=<span class="literal">None</span>, keepalive_timeout=<span class="number">30</span>, limit=<span class="number">100</span>, force_close=<span class="literal">False</span>, loop=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>Unix 套接字连接器。<br>UnixConnector继承于BaseConnector。<br>使用UnixConnector发送HTTP/HTTPS请求。底层通过UNIX套接字传输。<br>UNIX套接字对于测试并快速在同一个主机上的进程间建立连接非常方便。</p>
<h3 id="CookieJar类"><a href="#CookieJar类" class="headerlink" title="CookieJar类"></a>CookieJar类</h3><p>cookie jar实例对象可用在ClientSession.cookie_jar中。<br>jar对象包含用来存储内部cookie数据的Morsel组件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">CookieJar</span>(<span class="params">*, unsafe=<span class="literal">False</span>, loop=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>unsafe (布尔类型) – (可选)是否可从IP(的HTTP请求)中接受cookies。</li>
<li>loop (布尔类型) – 一个事件循环实例。</li>
</ul>
<ol>
<li><p>查看保存的cookies数量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(session.cookie_jar)</span><br></pre></td></tr></table></figure></li>
<li><p>被迭代:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> session.cookie_jar:</span><br><span class="line">    <span class="built_in">print</span>(cookie.key)</span><br><span class="line">    <span class="built_in">print</span>(cookie[<span class="string">&quot;domain&quot;</span>])</span><br></pre></td></tr></table></figure></li>
</ol>
<p>方法:</p>
<ol>
<li><p>update_cookies(cookies, response_url=None)<br>从服务器返回的Set-Cookie信息中更新cookies。</p>
<blockquote>
<ul>
<li>cookies – 需要collections.abc.Mapping对象(如dict, SimpleCookie) 或包含cookies的可迭代键值对对象。</li>
<li>response_url (字符串) – cookies所属的URL，如果要共享cookies则不要填。标准的cookies应是与服务器URL成对出现，只在向该服务器请求时被发送出去，如果是共享的则会发送给所有的服务器。</li>
</ul>
</blockquote>
</li>
<li><p>filter_cookies(request_url)<br>筛选cookies,返回与request_url相匹配的cookies，和能给这个URL携带的cookie(一般是设置为None也就是共享的cookie)。</p>
<blockquote>
<ul>
<li>response_url (字符串) – 需要筛选的URL。</li>
<li>返回带有给定URL cookies的http.cookies.SimpleCookie。</li>
</ul>
</blockquote>
</li>
<li><p>save(file_path)<br>   以pickle形式将cookies信息写入指定路径。</p>
<blockquote>
<p>file_path – 要写入的路径。字符串或pathlib.Path实例对象。</p>
</blockquote>
</li>
<li><p>load(file_path)<br>   从给定路径读取被pickle的cookies信息。</p>
<blockquote>
<p>file_path – 要导入的路径, 字符串或pathlib.Path实例对象。</p>
</blockquote>
</li>
</ol>
<h3 id="DummyCookieJar类"><a href="#DummyCookieJar类" class="headerlink" title="DummyCookieJar类"></a>DummyCookieJar类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">aiohttp</span>.<span class="title">DummyCookieJar</span>(<span class="params">*, loop=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>假人cookie jar，用于忽略cookie。在一些情况下是很有用的: 比如写爬虫时不需要保存cookies信息，只要一直下载内容就好了。</p>
<blockquote>
<p>将它的实例对象传入即可使用: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jar = aiohttp.DummyCookieJar()</span><br><span class="line">session = aiohttp.ClientSession(cookie_jar=DummyCookieJar())</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="session-request方法"><a href="#session-request方法" class="headerlink" title="session.request方法"></a>session.request方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">session</span>.<span class="title">request</span>(<span class="params">method, url, *, params=<span class="literal">None</span>, data=<span class="literal">None</span>, json=<span class="literal">None</span>, headers=<span class="literal">None</span>, skip_auto_headers=<span class="literal">None</span>, auth=<span class="literal">None</span>, allow_redirects=<span class="literal">True</span>, max_redirects=<span class="number">10</span>, compress=<span class="literal">None</span>, chunked=<span class="literal">None</span>, expect100=<span class="literal">False</span>, read_until_eof=<span class="literal">True</span>, proxy=<span class="literal">None</span>, proxy_auth=<span class="literal">None</span>, timeout=<span class="number">5</span>*<span class="number">60</span>, verify_ssl=<span class="literal">None</span>, fingerprint=<span class="literal">None</span>, ssl_context=<span class="literal">None</span>, proxy_headers=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>params :<br>可传入Maaping对象，有键值对的元组或字符串，会在发送新请求时作为查询字符串发送。<strong>不会对之后的重定向请求也传入查询字符串</strong>。</p>
</li>
<li><p>json:<br>任何可被json解码的python对象。</p>
<blockquote>
<p>注: json不能与data参数同时使用。</p>
</blockquote>
</li>
<li><p>skip_auto_headers :<br>跳过会自动生成的headers信息。</p>
</li>
<li><p>allow_redirects(布尔类型) :<br>如果设为False，则不允许重定向。默认是True。</p>
</li>
<li><p>compress (布尔类型) :<br>默认是None。如果请求内容要进行deflate编码压缩可以设为True。</p>
<blockquote>
<p>如果设置了Content-Encoding和Content-Length则不要使用这个参数。</p>
</blockquote>
</li>
<li><p>chunked (整数) :<br>默认为None。允许使用分块编码传输。开发者想使用分块数据流时，用它就没错啦。</p>
<blockquote>
<p>如果是允许的，aiohttp将会设置为”Transfer-encoding:chunked”，这时不要在设置Transfer-encoding和content-length这两个headers了。</p>
</blockquote>
</li>
<li><p>expect100(布尔类型) :<br>默认是False。服务器返回100时将等待响应(返回100表示服务器正在处理数据)。</p>
</li>
<li><p>read_until_eof (布尔类型) :<br>如果响应不含Content-Length头信息将会一直读取响应内容直到无内容可读。默认是True。</p>
</li>
<li><p>proxy_auth(aiohttp.BaicAuth) :<br>传入表示HTTP代理基础认证的对象。</p>
</li>
<li><p>erify_ssl(布尔类型) :<br>默认是True。对HTTPS请求验证SSL证书。</p>
</li>
<li><p>fringerprint (字节):<br>传递想要验证的证书(使用DER编码的证书)的SHA256值来验证服务器是否可以成功匹配。对证书固定非常有用。</p>
<blockquote>
<p>警告: 不赞成使用不安全的MD5和SHA1哈希值。</p>
</blockquote>
</li>
<li><p>proxy_headers(abc.Mapping) :<br>如果该参数有提供内容，则会将其做为HTTP headers发送给代理。</p>
</li>
</ul>
<h3 id="session-get-和-session-post方法"><a href="#session-get-和-session-post方法" class="headerlink" title="session.get 和 session.post方法"></a>session.get 和 session.post方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">session</span>.<span class="title">get</span>(<span class="params">url, *, allow_redirects=<span class="literal">True</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">session</span>.<span class="title">post</span>(<span class="params">url, *, data=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>





<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="comment"># ClientSession() 创建 会话(session)对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="comment"># 会话对象发情get请求</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;https://api.github.com/events&#x27;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="built_in">print</span>(resp.status)</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">await</span> resp.text())</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(session))   <span class="comment"># &lt;class &#x27;aiohttp.client.ClientSession&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(resp))   <span class="comment"># &lt;class &#x27;aiohttp.client_reqrep.ClientResponse&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">session.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, data=<span class="string">b&#x27;data&#x27;</span>)</span><br><span class="line"></span><br><span class="line">session.put(<span class="string">&#x27;http://httpbin.org/put&#x27;</span>, data=<span class="string">b&#x27;data&#x27;</span>)</span><br><span class="line">session.delete(<span class="string">&#x27;http://httpbin.org/delete&#x27;</span>)</span><br><span class="line">session.head(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line">session.options(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line">session.patch(<span class="string">&#x27;http://httpbin.org/patch&#x27;</span>, data=<span class="string">b&#x27;data&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="JSON请求"><a href="#JSON请求" class="headerlink" title="JSON请求"></a>JSON请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.post(json=&#123;<span class="string">&#x27;test&#x27;</span>: <span class="string">&#x27;object&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="传递URL中的请求参数"><a href="#传递URL中的请求参数" class="headerlink" title="传递URL中的请求参数"></a>传递URL中的请求参数</h3><ul>
<li>使用字典</li>
<li>使用元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>,params=params) <span class="keyword">as</span> resp:</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">str</span>(resp.url) == <span class="string">&#x27;http://httpbin.org/get?key2=value2&amp;key1=value1&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">params = [(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>), (<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>)]</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>,params=params) <span class="keyword">as</span> r:</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">str</span>(r.url) == <span class="string">&#x27;http://httpbin.org/get?key=value2&amp;key=value1&#x27;</span></span><br></pre></td></tr></table></figure>



<p>默认url会被编码</p>
<blockquote>
<p>比如:<code>URL(&#39;http://example.com/путь%30?a=%31&#39;)</code> 会被转化为<code>URL(&#39;http://example.com/%D0%BF%D1%83%D1%82%D1%8C/0?a=1&#39;)</code></p>
</blockquote>
<p>如果想取消编码，使用encoded参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> session.get(URL(<span class="string">&#x27;http://example.com/%30&#x27;</span>, encoded=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告:<br><strong>传递params时不要用encode=True，这俩参数不能同时使用</strong>。</p>
</blockquote>
<h3 id="获取响应内容"><a href="#获取响应内容" class="headerlink" title="获取响应内容"></a>获取响应内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;https://api.github.com/events&#x27;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> resp.text())</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> resp.text(encoding=<span class="string">&#x27;windows-1251&#x27;</span>)) <span class="comment"># 修改编码</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
<p>因为是异步请求,所以<code>await resp.text()</code>要使用await</p>
<p>但是<code>resp.status</code>不能使用await</p>
</blockquote>
<h3 id="获取二进制和json响应"><a href="#获取二进制和json响应" class="headerlink" title="获取二进制和json响应"></a>获取二进制和json响应</h3><ul>
<li>和requests一样,<code>await resp.read()</code>是获取二进制响应</li>
<li>和requests一样,<code>await resp.json()</code>是获取json响应</li>
</ul>
<h3 id="获取流式响应"><a href="#获取流式响应" class="headerlink" title="获取流式响应"></a>获取流式响应</h3><blockquote>
<p>read(), json(), text()等方法<strong>会将所有的响应内容加载到内存</strong>。</p>
</blockquote>
<p>获取流式响应非常简单,只要使用<strong>content</strong>属性 : <code>resp.content.read(10)</code>即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;https://api.github.com/events&#x27;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">    <span class="keyword">await</span> resp.content.read(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义Headers"><a href="#自定义Headers" class="headerlink" title="自定义Headers"></a>自定义Headers</h3><p>和requests一样,使用header参数和data参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">&#x27;https://api.github.com/some/endpoint&#x27;</span></span><br><span class="line">payload = &#123;<span class="string">&#x27;some&#x27;</span>: <span class="string">&#x27;data&#x27;</span>&#125;</span><br><span class="line">headers = &#123;<span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> session.post(url,data=json.dumps(payload),headers=headers)</span><br></pre></td></tr></table></figure>

<h3 id="自定义Cookies"><a href="#自定义Cookies" class="headerlink" title="自定义Cookies"></a>自定义Cookies</h3><p>为<strong>ClientSession</strong>对象指定cookies参数:</p>
<p>使用<code>ClientSession(cookies=cookies)</code>将字典转为ClientSession对象,此时这个session自动就有了cookies值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://httpbin.org/cookies&#x27;</span></span><br><span class="line">cookies = &#123;<span class="string">&#x27;cookies_are&#x27;</span>: <span class="string">&#x27;working&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> ClientSession(cookies=cookies) <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">await</span> resp.json() == &#123;<span class="string">&quot;cookies&quot;</span>: &#123;<span class="string">&quot;cookies_are&quot;</span>: <span class="string">&quot;working&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取当前的cookies"><a href="#获取当前的cookies" class="headerlink" title="获取当前的cookies"></a>获取当前的cookies</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">    <span class="built_in">print</span>(resp.cookies)</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://example.com/some/cookie/setting/url&#x27;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">    <span class="built_in">print</span>(resp.cookies[<span class="string">&#x27;example_cookie_name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>响应中的cookies只包含重定向链中最后一个请求中的<code>Set-Cookies</code>头信息设置的值。<br>如果每一次重定向请求都收集一次cookies请使用<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/client.html#aiohttp-client-session"> aiohttp.ClientSession</a>对象.</p>
</blockquote>
<h3 id="发送多部分编码文件-Multipart-Encoded"><a href="#发送多部分编码文件-Multipart-Encoded" class="headerlink" title="发送多部分编码文件(Multipart-Encoded)"></a>发送多部分编码文件(Multipart-Encoded)</h3><p>上传多部分编码文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> session.post(url, data=files)</span><br></pre></td></tr></table></figure>

<p>也可以显式地设置文件名，文件类型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">data = FormData()</span><br><span class="line">data.add_field(<span class="string">&#x27;file&#x27;</span>,</span><br><span class="line">               <span class="built_in">open</span>(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>),</span><br><span class="line">               filename=<span class="string">&#x27;report.xls&#x27;</span>,</span><br><span class="line">               content_type=<span class="string">&#x27;application/vnd.ms-excel&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> session.post(url, data=data)</span><br></pre></td></tr></table></figure>

<p>把一个文件对象传递给data参数，aiohttp会自动将其以流的形式上传。</p>
<h3 id="流式上传"><a href="#流式上传" class="headerlink" title="流式上传"></a>流式上传</h3><p>aiohttp 支持多种形式的流式上传，允许你<strong>直接发送大文件而不必读到内存</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;massive-body&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   <span class="keyword">await</span> session.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, data=f)</span><br></pre></td></tr></table></figure>

<p>使用aiohttp.streamer对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@aiohttp.streamer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_sender</span>(<span class="params">writer, file_name=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        chunk = f.read(<span class="number">2</span>**<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">while</span> chunk:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> writer.write(chunk)</span><br><span class="line">            chunk = f.read(<span class="number">2</span>**<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后你可以使用&quot;file_sender&quot;传递给data:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>,data=file_sender(file_name=<span class="string">&#x27;huge_file&#x27;</span>)) <span class="keyword">as</span> resp:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> resp.text())</span><br></pre></td></tr></table></figure>



<h3 id="上传预压缩过的数据"><a href="#上传预压缩过的数据" class="headerlink" title="上传预压缩过的数据"></a>上传预压缩过的数据</h3><p>上传一个已经压缩过的数据，需要为Headers中的<code>Content-Encoding</code>指定算法名(通常是deflate或者是zlib).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">my_coroutine</span>(<span class="params">session, headers, my_data</span>):</span></span><br><span class="line">    data = zlib.compress(my_data)</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-Encoding&#x27;</span>: <span class="string">&#x27;deflate&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>,data=data,headers=headers)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<h3 id="持久连接-keep-alive-连接池和cookies共享"><a href="#持久连接-keep-alive-连接池和cookies共享" class="headerlink" title="持久连接(keep-alive), 连接池和cookies共享"></a>持久连接(keep-alive), 连接池和cookies共享</h3><p><strong>ClientSession</strong>可以在多个请求之间共享cookies:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">	<span class="comment"># 设置cookies</span></span><br><span class="line">    <span class="keyword">await</span> session.get(<span class="string">&#x27;http://httpbin.org/cookies/set?my_cookie=my_value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 筛选cookies</span></span><br><span class="line">    filtered = session.cookie_jar.filter_cookies(<span class="string">&#x27;http://httpbin.org&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> filtered[<span class="string">&#x27;my_cookie&#x27;</span>].value == <span class="string">&#x27;my_value&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">        json_body = <span class="keyword">await</span> resp.json()</span><br><span class="line">        <span class="keyword">assert</span> json_body[<span class="string">&#x27;cookies&#x27;</span>][<span class="string">&#x27;my_cookie&#x27;</span>] == <span class="string">&#x27;my_value&#x27;</span></span><br></pre></td></tr></table></figure>

<p>你也可以为所有的会话请求设置headers:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(headers=&#123;<span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Basic bG9naW46cGFzcw==&quot;</span>&#125;) <span class="keyword">as</span> session:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&quot;http://httpbin.org/headers&quot;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">        json_body = <span class="keyword">await</span> resp.json()</span><br><span class="line">        <span class="keyword">assert</span> json_body[<span class="string">&#x27;headers&#x27;</span>][<span class="string">&#x27;Authorization&#x27;</span>] == <span class="string">&#x27;Basic bG9naW46cGFzcw==&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>ClientSession</strong>支持持久连接和连接池，可直接使用，不需要额外操作。</p>
</blockquote>
<h3 id="安全cookies"><a href="#安全cookies" class="headerlink" title="安全cookies"></a>安全cookies</h3><p><strong>ClientSession</strong>中的默认的<strong>aiohttp.CookiesJar</strong>使用的是严苛模式，<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2109.html">RFC 2109</a>明确禁止使用ip地址形式的URL携带cookies信息。比如: <em><a target="_blank" rel="noopener" href="http://127.0.0.1/cookie">http://127.0.0.1:80/cookie</a></em> .<br>这样很好，不过有些时候我们测试时需要允许携带cookies。在<strong>aiohttp.CookiesJar</strong>中传递<em>unsafe=True</em>来实现这一效果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jar = aiohttp.CookieJar(unsafe=<span class="literal">True</span>)</span><br><span class="line">session = aiohttp.ClientSession(cookie_jar=jar)</span><br></pre></td></tr></table></figure>



<h3 id="使用虚假Cookie-Jar"><a href="#使用虚假Cookie-Jar" class="headerlink" title="使用虚假Cookie Jar"></a>使用虚假Cookie Jar</h3><p>有时不想处理cookie。这时可以在会话中使用<strong>aiohttp.DummyCookieJar</strong>来达到目的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jar = aiohttp.DummyCookieJar()</span><br><span class="line">session = aiohttp.ClientSession(cookie_jar=jar)</span><br></pre></td></tr></table></figure>



<h3 id="使用连接器connector"><a href="#使用连接器connector" class="headerlink" title="使用连接器connector"></a>使用连接器connector</h3><p>想要调整请求的传输层你可以为<strong>ClientSession</strong>及其同类组件传递自定义的连接器。例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn = aiohttp.TCPConnector()</span><br><span class="line">session = aiohttp.ClientSession(connector=conn)</span><br></pre></td></tr></table></figure>



<h3 id="限制连接池的容量"><a href="#限制连接池的容量" class="headerlink" title="限制连接池的容量"></a>限制连接池的容量</h3><p>限制同一时间打开的连接数可以传递limit参数:<br>所以<strong>可以用它来限制同时请求数量</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn = aiohttp.TCPConnector(limit=<span class="number">30</span>)</span><br><span class="line">session = aiohttp.ClientSession(connector=conn)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>默认情况下是100.</li>
<li>为0则不作限制</li>
</ul>
</blockquote>
<p>限制同一时间在同一个端点((<code>host</code>, <code>port</code>, <code>is_ssl</code>) 3者都一样的情况)打开的连接数可指定limit_per_host参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn = aiohttp.TCPConnector(limit_per_host=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>



<h3 id="使用自定义域名服务器"><a href="#使用自定义域名服务器" class="headerlink" title="使用自定义域名服务器"></a>使用自定义域名服务器</h3><p>底层需要aiodns支持:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp.resolver <span class="keyword">import</span> AsyncResolver</span><br><span class="line"></span><br><span class="line">resolver = AsyncResolver(nameservers=[<span class="string">&quot;8.8.8.8&quot;</span>, <span class="string">&quot;8.8.4.4&quot;</span>])</span><br><span class="line">conn = aiohttp.TCPConnector(resolver=resolver)</span><br></pre></td></tr></table></figure>



<h3 id="为TCP-sockets添加SSL控制"><a href="#为TCP-sockets添加SSL控制" class="headerlink" title="为TCP sockets添加SSL控制"></a>为TCP sockets添加SSL控制</h3><p>默认情况下aiohttp总会对使用了HTTPS协议(的URL请求)查验其身份。但也可将<em>verify_ssl</em>设置为<code>False</code>让其不检查:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="keyword">await</span> session.get(<span class="string">&#x27;https://example.com&#x27;</span>, verify_ssl=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>如果你需要设置自定义SSL信息(比如使用自己的证书文件)你可以创建一个<strong>ssl.SSLContext</strong>实例并传递到<strong>ClientSession</strong>中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sslcontext = ssl.create_default_context(cafile=<span class="string">&#x27;/path/to/ca-bundle.crt&#x27;</span>)</span><br><span class="line">r = <span class="keyword">await</span> session.get(<span class="string">&#x27;https://example.com&#x27;</span>, ssl_context=sslcontext)</span><br></pre></td></tr></table></figure>



<h3 id="代理支持"><a href="#代理支持" class="headerlink" title="代理支持"></a>代理支持</h3><p>aiohttp 支持 HTTP/HTTPS形式的代理。你需要使用<code>proxy</code>参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&quot;http://python.org&quot;</span>,proxy=<span class="string">&quot;http://some.proxy.com&quot;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="built_in">print</span>(resp.status)</span><br></pre></td></tr></table></figure>

<p>同时支持认证代理:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    proxy_auth = aiohttp.BasicAuth(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&quot;http://python.org&quot;</span>,</span><br><span class="line">                           proxy=<span class="string">&quot;http://some.proxy.com&quot;</span>,</span><br><span class="line">                           proxy_auth=proxy_auth) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="built_in">print</span>(resp.status)</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>与requests不同，aiohttp默认不会读取环境变量中的代理值。</li>
<li>但你可以通过传递<code>trust_env=True</code>来让<strong>aiohttp.ClientSession</strong>读取HTTP_PROXY或HTTPS_PROXY环境变量中的代理信息(不区分大小写)。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&quot;http://python.org&quot;</span>, trust_env=<span class="literal">True</span>) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="built_in">print</span>(resp.status)</span><br></pre></td></tr></table></figure>

<p>还可以使用ProxyConnector对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conn = aiohttp.ProxyConnector(proxy=<span class="string">&quot;http://some.proxy.com&quot;</span>)</span><br><span class="line">session = aiohttp.ClientSession(connector=conn)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://python.org&#x27;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">    <span class="built_in">print</span>(resp.status)</span><br></pre></td></tr></table></figure>



<h3 id="查看响应状态码"><a href="#查看响应状态码" class="headerlink" title="查看响应状态码"></a>查看响应状态码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">    <span class="keyword">assert</span> resp.status == <span class="number">200</span></span><br></pre></td></tr></table></figure>



<h3 id="设置Timeout"><a href="#设置Timeout" class="headerlink" title="设置Timeout"></a>设置Timeout</h3><p>默认情况下每个IO操作有5分钟超时时间。可以通过给<strong>ClientSession.get</strong>()及其同类组件传递<code>timeout</code>来覆盖原超时时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;https://github.com&#x27;</span>, timeout=<span class="number">60</span>) <span class="keyword">as</span> r:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> aiohttp.Timeout(<span class="number">0.001</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.get(<span class="string">&#x27;https://github.com&#x27;</span>) <span class="keyword">as</span> r:</span><br><span class="line">        <span class="keyword">await</span> r.text()</span><br></pre></td></tr></table></figure>

<p><code>None</code> 或者<code>0</code>则表示不检测超时。 还可通过调用<strong>async_timeout.timeout</strong>上下文管理器来为连接和解析响应内容添加一个总超时时间:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> async_timeout</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> async_timeout.timeout(<span class="number">0.001</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;https://github.com&#x27;</span>) <span class="keyword">as</span> r:</span><br><span class="line">        <span class="keyword">await</span> r.text()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<br>超时时间是累计的，包含如发送情况，重定向，响应解析，处理响应等所有操作在内…</p>
</blockquote>
<h3 id="获取响应头信息"><a href="#获取响应头信息" class="headerlink" title="获取响应头信息"></a>获取响应头信息</h3><p><strong>ClientResponse.headers</strong>使用的数据类型是<strong>CIMultiDcitProxy</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resp.headers</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;ACCESS-CONTROL-ALLOW-ORIGIN&#x27;: &#x27;*&#x27;,</span></span><br><span class="line"><span class="comment">#  &#x27;CONTENT-TYPE&#x27;: &#x27;application/json&#x27;,</span></span><br><span class="line"><span class="comment">#  &#x27;DATE&#x27;: &#x27;Tue, 15 Jul 2014 16:49:51 GMT&#x27;,</span></span><br><span class="line"><span class="comment">#  &#x27;SERVER&#x27;: &#x27;gunicorn/18.0&#x27;,</span></span><br><span class="line"><span class="comment">#  &#x27;CONTENT-LENGTH&#x27;: &#x27;331&#x27;,</span></span><br><span class="line"><span class="comment">#  &#x27;CONNECTION&#x27;: &#x27;keep-alive&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这是一个很特别的字典,他不分区大小写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp.headers[<span class="string">&#x27;Content-Type&#x27;</span>]</span><br><span class="line"><span class="comment"># &#x27;application/json&#x27;</span></span><br><span class="line"></span><br><span class="line">resp.headers.get(<span class="string">&#x27;content-type&#x27;</span>)</span><br><span class="line"><span class="comment"># &#x27;application/json&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="获取响应历史"><a href="#获取响应历史" class="headerlink" title="获取响应历史"></a>获取响应历史</h3><p>如果一个请求被重定向了，你可以用<strong>history</strong>属性查看其之前的响应:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp = <span class="keyword">await</span> session.get(<span class="string">&#x27;http://example.com/some/redirect/&#x27;</span>)</span><br><span class="line"><span class="comment"># &lt;ClientResponse(http://example.com/some/other/url/) [200]&gt;</span></span><br><span class="line"></span><br><span class="line">resp.history</span><br><span class="line"><span class="comment"># (&lt;ClientResponse(http://example.com/some/redirect/) [301]&gt;,)</span></span><br></pre></td></tr></table></figure>

<p>如果没有重定向或<code>allow_redirects</code>设置为<code>False</code>，history会被设置为空。</p>
<h3 id="使用WebSockets"><a href="#使用WebSockets" class="headerlink" title="使用WebSockets"></a>使用WebSockets</h3><ul>
<li>aiohttp提供开箱即用的客户端websocket。</li>
<li>使用<strong>aiohttp.ClientSession.ws_connect</strong>()协程对象。它的第一个参数接受URL，返回值是<strong>ClientWebSocketResponse</strong>，这样你就可以用响应的方法与websocket服务器进行通信。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">session = aiohttp.ClientSession()</span><br><span class="line"><span class="comment"># 连接目标网站的websocket</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.ws_connect(<span class="string">&#x27;http://example.org/websocket&#x27;</span>) <span class="keyword">as</span> ws:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> msg <span class="keyword">in</span> ws:</span><br><span class="line">        <span class="keyword">if</span> msg.<span class="built_in">type</span> == aiohttp.WSMsgType.TEXT:</span><br><span class="line">            <span class="keyword">if</span> msg.data == <span class="string">&#x27;close cmd&#x27;</span>:</span><br><span class="line">                <span class="keyword">await</span> ws.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">await</span> ws.send_str(msg.data + <span class="string">&#x27;/answer&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> msg.<span class="built_in">type</span> == aiohttp.WSMsgType.CLOSED:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> msg.<span class="built_in">type</span> == aiohttp.WSMsgType.ERROR:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>你只能使用一种读取方式  (例如<code>await ws.receive()</code> 或者 <code>async for msg in ws:</code>)  和写入方法，但可以有多个写入任务，写入任务也是异步完成的(<code>ws.send_str(&#39;data&#39;)</code>)。</p>
</blockquote>
<ul>
<li><p>当一个包含<code>ClientSession</code>的<code>async with</code>代码块的末尾行结束时(或直接调用了<code>.close()</code>)，因为asyncio内部的一些原因底层的<strong>连接其实没有关闭</strong>。</p>
</li>
<li><p>在实际使用中，底层连接需要有一个缓冲时间来关闭。然而，如果事件循环在底层连接关闭之前就结束了，那么会抛出一个 资源警告:<br>存在未关闭的传输(通道)(<code>ResourceWarning: unclosed transport</code>),如果警告可用的话。</p>
</li>
<li><p>为了避免这种情况，在关闭事件循环前加入一小段延迟让底层连接得到关闭的缓冲时间。 </p>
<blockquote>
<p>对于非SSL的<code>ClientSession</code>, 使用0即可(<code>await asyncio.sleep(0)</code>): </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_website</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://example.org/&#x27;</span>) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">await</span> response.read()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(read_website())</span><br><span class="line"><span class="comment"># 零睡眠以允许底层连接关闭</span></span><br><span class="line">loop.run_until_complete(asyncio.sleep(<span class="number">0</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>对于使用了SSL的<code>ClientSession</code>, 需要设置一小段合适的时间:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等待250 ms以便关闭基础SSL连接</span></span><br><span class="line">loop.run_until_complete(asyncio.sleep(<span class="number">0.250</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="异常等级图"><a href="#异常等级图" class="headerlink" title="异常等级图"></a>异常等级图</h2><blockquote>
<ul>
<li>ClientError</li>
<li><ul>
<li>ClientResponseError</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>ContentTypeError</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>WSServerHandshakeError</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>ClientHttpProxyError</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>ClientConnectionError</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>ClientOSError</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>ClientConnectorError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>ClientSSLError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>ClientConnectorCertificateError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>ClientConnectorSSLError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>ClientProxyConnectionError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>ServerConnectionError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>ServerDisconnectedError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>ServerTimeoutError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>ServerFingerprintMismatch</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>ClientPayloadError</li>
</ul>
</li>
<li><ul>
<li>InvalidURL</li>
</ul>
</li>
</ul>
</blockquote>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>