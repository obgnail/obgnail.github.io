<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h2&gt;&lt;p&gt;不同于&lt;code&gt;ports&lt;/code&gt; , &lt;code&gt;link&lt;/code&gt; , docker-compose的command如果不使用多条语句 , 不能使用列表"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>report2 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/zhangkun-internship/" rel="tag">zhangkun_internship</a></div><div class="post-time">2019-12-09</div></div></div><div class="container post-header"><h1>report2</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker"><span class="toc-number">1.</span> <span class="toc-text">docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flask"><span class="toc-number">2.</span> <span class="toc-text">flask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Model"><span class="toc-number">2.1.</span> <span class="toc-text">Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#form"><span class="toc-number">2.2.</span> <span class="toc-text">form</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template"><span class="toc-number">2.3.</span> <span class="toc-text">template</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#view"><span class="toc-number">2.4.</span> <span class="toc-text">view</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#other"><span class="toc-number">3.</span> <span class="toc-text">other</span></a></li></ol></details></div><div class="container post-content"><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>不同于<code>ports</code> , <code>link</code> , docker-compose的command如果不使用多条语句 , 不能使用列表</p>
<h2 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h2><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ol>
<li><p>flask的model在设计的时候 , 应该尽可能保证数据表的PK无意义化 , 不要使用实体的唯一属性作为PK , 力求让主键的唯一作用就是唯一标识 </p>
</li>
<li><p>在编写Model的时候 , 需要在文档注释说明每个字段及其含义</p>
</li>
<li><p>flask的自增列不能自己添入,必须交给sql自己自增填入</p>
</li>
<li><p>就算是远程数据库 , flask不能自己手动使用sql创建表,必须使用create_all()函数创建.操作同样会响应到远程数据库 . 而且注意 , create_all()并不能创建数据库 , 必须手动创建数据库才能使用create_all()</p>
</li>
<li><p>Sqlalchemy的remote_side : 表中的外键引用的是自身时,如Node类,如果想表示多对一的关系,那么就可以使用remote_side</p>
</li>
</ol>
<h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><ol>
<li>使用form时 , 不要手写submit标签 , 直接使用SubmitField字段即可 : <code>submit = SubmitField(&#39;登录&#39;)</code></li>
</ol>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><ol>
<li><p>macro使用<code>**kwargs</code>参数和<code>*args</code>参数 , 不需要在函数括号()里声明 , 直接在函数里调用<code>**kwargs</code>和<code>*args</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro render_field(field) %&#125;</span><br><span class="line">    &#123;% with errors = field.errors %&#125;</span><br><span class="line">        &lt;div class=&quot;form-group&#123;&#123; &#x27;has-error&#x27; if errors &#125;&#125;&quot;&gt;</span><br><span class="line">            &#123;&#123; field.label(class=&quot;control-label&quot;) &#125;&#125;</span><br><span class="line">            &#123;&#123; field(class=&#x27;form-control&#x27;, **kwargs) &#125;&#125;</span><br><span class="line">            &#123;% if errors %&#125;</span><br><span class="line">                &#123;% for error in errors %&#125;</span><br><span class="line">	                &lt;span class=&quot;help-block&quot; style=&quot;color: red&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt;</span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#123;% endwith %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于不敏感的用户配置 , 如navi的收缩状态 , 可以使用LocalStorage储存</p>
</li>
</ol>
<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><ol>
<li><p>切换redis的时候报UnicodeDecodeError 错误 , 有可能是redis中存在相关持久化文件，记住了前面的任务和配置信息，使得redis在进行get和set的时候出现混乱，造成错误 . 此时只要重启即可 . </p>
</li>
<li><p>Flask使用redis作为缓存装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache_table_data</span>(<span class="params">cache_time=<span class="number">60</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">warpper</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot; redis 缓存装饰器 &quot;&quot;&quot;</span></span><br><span class="line">            args_key = <span class="string">&quot;.&quot;</span>.join([<span class="built_in">str</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> args])</span><br><span class="line">            redis_key = <span class="string">&quot;table:&#123;&#125;:&#123;&#125;:&#123;&#125;-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                cls.__name__,</span><br><span class="line">                func.__name__,</span><br><span class="line">                args_key,</span><br><span class="line">                json.dumps(kwargs)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># 获取缓存</span></span><br><span class="line">            cache_data = cache_client.get(redis_key)</span><br><span class="line">            <span class="keyword">if</span> cache_data:</span><br><span class="line">                data = pickle.loads(cache_data)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                data = func(cls, *args, **kwargs)</span><br><span class="line">                cache_data = pickle.dumps(data)</span><br><span class="line">                cache_client.<span class="built_in">set</span>(redis_key, cache_data, cache_time)</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">return</span> warpper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure></li>
<li><p>生成签名的方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_signature</span>(<span class="params">req</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;生成签名&#x27;&#x27;&#x27;</span></span><br><span class="line">    req_str = <span class="string">&#x27;&amp;&#x27;</span>.join([<span class="string">&#x27;&#123;&#125;=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">sorted</span>(req.items())])</span><br><span class="line">    secret_key = current_app.config[<span class="string">&#x27;ZK_LOGIN_SECRET_KEY&#x27;</span>]</span><br><span class="line">    unsign_str = req_str + secret_key</span><br><span class="line">    sign = md5(unsign_str.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> sign</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><ol>
<li><p>flask里时间字段的管理 , 可以编辑一个命名元组 , Nametuple的属性就是各个时间的表示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">_Time = namedtuple(<span class="string">&quot;Time&quot;</span>, (<span class="string">&quot;timestamp&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;datetime&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_time</span>():</span></span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    timestamp = <span class="built_in">int</span>(now.strftime(<span class="string">&quot;%s&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> _Time(timestamp=timestamp, date=now.date(), datetime=now)</span><br></pre></td></tr></table></figure></li>
<li><p>使用redis的setex可以实现分布式锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;redis dist lock</span></span><br><span class="line"><span class="string">    @param name 锁名称</span></span><br><span class="line"><span class="string">    @param client redis连接</span></span><br><span class="line"><span class="string">    @param timeout 超过多少ms锁不释放，则自动过期</span></span><br><span class="line"><span class="string">    @param retries 重试次数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, client, timeout=<span class="number">2000</span>, retries=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">assert</span> retries &gt;= <span class="number">0</span>, <span class="string">&#x27;retries must &gt;= 0&#x27;</span></span><br><span class="line">        self.key = <span class="string">&quot;distributed-redis-lock:%s&quot;</span> % name</span><br><span class="line">        self.client = client</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.retries = retries</span><br><span class="line">        self.has_lock = <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            is_ok = self.client.<span class="built_in">set</span>(self.key, <span class="number">1</span>, ex=self.timeout, nx=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">if</span> is_ok:</span><br><span class="line">                self.has_lock = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> self</span><br><span class="line">            <span class="keyword">if</span> self.retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        self.client.delete(self.key)</span><br></pre></td></tr></table></figure></li>
<li><p>Flask-login内部逻辑</p>
<ol>
<li><p>每次访问被保护的视图(调用login_required时)都会新形成一个current_user对象 , 该对象从请求上下文栈顶获取user属性</p>
</li>
<li><p>新形成current_user的时候都会调用_loader_user()方法 , 该方法会去上下文中寻找user属性 </p>
<p>在获取失败的时候调用<code>_loader_user</code>方法 , 该方法会调用_load_user , 继而调用reloader_user方法 , reloader_user方法就能生成新的user对象,并且将相关信息写入session</p>
</li>
</ol>
</li>
<li><p>api文档的内容 : 接口功能 , 接口地址 , 接口所需参数(必须参数 , 非必须参数 , 通用参数) , 接口返回数据 , 数据字段 , 状态码 ,错误码</p>
</li>
<li><p>python修改环境变量 : 若没有特别设定，环境变量继承自父进程。因此，你在 python 里面修改了环境变量，只能影响自身，及由它创建的子进程（若没有显式设定）。</p>
</li>
<li><p>代码复用的方法 : 装饰器 , 钩子函数 , 封装函数 , 创建父类</p>
</li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>