<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="有序二维数组的查找"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>剑指offer | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></div><div class="post-time">2019-09-05</div></div></div><div class="container post-header"><h1>剑指offer</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E5%80%92%E5%BA%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">使用递归的倒序属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">重建二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">3.</span> <span class="toc-text">旋转数组的最小数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">4.</span> <span class="toc-text">青蛙跳台阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">列表排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">链表中倒数第k个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">树的子结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">8.</span> <span class="toc-text">顺时针打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="toc-number">9.</span> <span class="toc-text">包含min函数的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">11.</span> <span class="toc-text">从上往下打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">12.</span> <span class="toc-text">二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">13.</span> <span class="toc-text">二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">14.</span> <span class="toc-text">复杂链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">15.</span> <span class="toc-text">二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">16.</span> <span class="toc-text">字符串的排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">17.</span> <span class="toc-text">数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">18.</span> <span class="toc-text">连续子数组的最大和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">19.</span> <span class="toc-text">整数中1出现的次数(从1到n整数中1出现的次数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">20.</span> <span class="toc-text">把数组排成最小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%91%E6%95%B0"><span class="toc-number">21.</span> <span class="toc-text">丑数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">22.</span> <span class="toc-text">数组中的逆序对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">23.</span> <span class="toc-text">数组中只出现一次的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-number">24.</span> <span class="toc-text">和为S的连续正数序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90"><span class="toc-number">25.</span> <span class="toc-text">扑克牌顺子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%821-2-3-%E2%80%A6-n"><span class="toc-number">26.</span> <span class="toc-text">求1+2+3+…+n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="toc-number">27.</span> <span class="toc-text">不用加减乘除做加法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0"><span class="toc-number">28.</span> <span class="toc-text">把字符串转换成整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">29.</span> <span class="toc-text">数组中重复的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-number">30.</span> <span class="toc-text">构建乘积数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">31.</span> <span class="toc-text">正则表达式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">32.</span> <span class="toc-text">表示数值的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">33.</span> <span class="toc-text">字符流中第一个不重复的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="toc-number">34.</span> <span class="toc-text">链表中环的入口结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">35.</span> <span class="toc-text">删除链表中重复的结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">36.</span> <span class="toc-text">二叉树的下一个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">37.</span> <span class="toc-text">按之字形顺序打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">38.</span> <span class="toc-text">序列化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">39.</span> <span class="toc-text">数据流中的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">40.</span> <span class="toc-text">滑动窗口的最大值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">简单问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">1.</span> <span class="toc-text">替换空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">用两个栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">4.</span> <span class="toc-text">跳台阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96"><span class="toc-number">5.</span> <span class="toc-text">矩形覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">二进制中1的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text">合并两个排序的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">9.</span> <span class="toc-text">二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">最小的K个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">11.</span> <span class="toc-text">第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="toc-number">12.</span> <span class="toc-text">两个链表的第一个公共结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">数字在排序数组中出现的次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">14.</span> <span class="toc-text">二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">15.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">16.</span> <span class="toc-text">和为S的两个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">17.</span> <span class="toc-text">左旋转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97"><span class="toc-number">18.</span> <span class="toc-text">翻转单词顺序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF"><span class="toc-number">19.</span> <span class="toc-text">约瑟夫环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C"><span class="toc-number">20.</span> <span class="toc-text">把二叉树打印成多行</span></a></li></ol></details></div><div class="container post-content"><p>有序二维数组的查找</p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<blockquote>
<p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，</p>
<ul>
<li>当要查找数字比左下角数字大时。右移</li>
<li>要查找数字比左下角数字小时，上移</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span>(<span class="params">self, target, array</span>):</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        y = <span class="built_in">len</span>(array) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> x &lt;= <span class="built_in">len</span>(array[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> y &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> array[x][y] &lt; target:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> array[x][y] &gt; target:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.Find(<span class="number">7</span>,[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">13</span>],[<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>]]))</span><br></pre></td></tr></table></figure>



<h2 id="使用递归的倒序属性"><a href="#使用递归的倒序属性" class="headerlink" title="使用递归的倒序属性"></a>使用递归的倒序属性</h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, listNode</span>):</span></span><br><span class="line">    	<span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">    		<span class="keyword">return</span> []</span><br><span class="line">    	<span class="keyword">else</span>:</span><br><span class="line">    		<span class="keyword">return</span> self.printListFromTailToHead(listNode.<span class="built_in">next</span>) + [listNode.val]</span><br></pre></td></tr></table></figure>



<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<blockquote>
<ol>
<li>先求出根节点（前序序列第一个元素）。 </li>
<li>将根节点带入到中序遍历序列中求出左右子树的中序遍历序列。 </li>
<li>通过左右子树的中序序列元素集合带入前序遍历序列可以求出左右子树的前序序列。 </li>
<li>左右子树的前序序列第一个元素分别是根节点的左右儿子 </li>
<li>求出了左右子树的4种序列可以递归上述步骤</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span>(<span class="params">self, pre, tin</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 根节点</span></span><br><span class="line">        root = TreeNode(pre.pop(<span class="number">0</span>))</span><br><span class="line">        index = tin.index(root.val)</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre, tin[:index])</span><br><span class="line">        root.right = self.reConstructBinaryTree(pre, tin[index + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<blockquote>
<p>最大的陷阱:</p>
<ul>
<li>｛1，0，1，1，1｝ 和 ｛1，1，     1，0，1｝都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。  </li>
<li>这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。</li>
<li>只能使用遍历</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span>(<span class="params">self, rotateArray</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        front = <span class="number">0</span></span><br><span class="line">        rear = <span class="built_in">len</span>(rotateArray)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rotateArray[front] &lt; rotateArray[rear]:</span><br><span class="line">            <span class="keyword">return</span> rotateArray[front]</span><br><span class="line"></span><br><span class="line">        mid = (front + rear) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> rotateArray[front] == rotateArray[mid] <span class="keyword">and</span> rotateArray[rear] == rotateArray[mid]:</span><br><span class="line">            <span class="keyword">return</span> self.Inorder(rotateArray)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> front + <span class="number">1</span> &lt; rear:</span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt;= rotateArray[front]:</span><br><span class="line">                front = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rear = mid</span><br><span class="line">            mid = (front + rear) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> rotateArray[rear]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Inorder</span>(<span class="params">self, rotateArray</span>):</span></span><br><span class="line">        result = rotateArray[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(rotateArray)):</span><br><span class="line">            <span class="keyword">if</span> rotateArray[i] &lt; result:</span><br><span class="line">                result = rotateArray[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>



<h2 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<blockquote>
<p>关于本题，前提是n个台阶会有一次n阶的跳法。分析如下: </p>
<p>  f(1) = 1 </p>
<p>  f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。 </p>
<p>  f(3) = f(3-1) + f(3-2) + f(3-3)  </p>
<p>  … </p>
<p>  f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) </p>
<ul>
<li>这里的f(n) 代表的是n个台阶有一次1,2,…n阶的 跳法数。 </li>
<li>n = 1时，只有1种跳法，f(1) = 1 </li>
<li>n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)  </li>
<li>n = 3时，会有三种跳得方式，1阶、2阶、3阶， </li>
</ul>
<p>​        那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) </p>
<p>​       因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) </p>
<ol start="5">
<li>n = n时，会有n中跳的方式，1阶、2阶…n阶，得出结论： </li>
</ol>
<p>​       f(n) = f(n-1)+f(n-2)+…+f(n-(n-1)) + f(n-n) =&gt;   f(0) + f(1) + f(2) + f(3) + … + f(n-1) </p>
<p>​        </p>
<ol start="6">
<li>由以上已经是一种结论，但是为了简单，我们可以继续简化： </li>
</ol>
<p>​       f(n-1) = f(0) + f(1)+f(2)+f(3) + … + f((n-1)-1) =   f(0) + f(1) + f(2) + f(3) + … + f(n-2) </p>
<p>​       f(n) = f(0) + f(1) + f(2) + f(3) + … + f(n-2) +   f(n-1) = f(n-1) + f(n-1) </p>
<p>​       可以得出： </p>
<p>​       f(n) = 2*f(n-1) </p>
<p>​        </p>
<ol start="7">
<li>得出最终结论,在n阶台阶，一次有1、2、…n阶的跳的方式时，总得跳法为： </li>
</ol>
<p>​                 | 1       ,(n=0 )  </p>
<p>  f(n) =     | 1       ,(n=1 ) </p>
<p>​                 | 2*f(n-1),(n&gt;=2)</p>
</blockquote>
<blockquote>
<ul>
<li>若有n个台阶，则 跳法为第一下跳1阶剩余台阶的 跳法为f(n-1)，以及第一下跳2节剩余台阶跳法为f(n-2)，以及第一下跳3阶剩余台阶 跳法为f(n-3)，依次类推知道最后一次是一下子全部跳上去，方法为1，</li>
<li>因此f(n)=f(n-1)+f(n-2)+f(n-3)+…+f(1)+1，f(1)=1,f(2)=2..f(n)-f(n-1)=f(n-1)因此f(n)=2f(n-1)是等比数列，首项为1，比例 为2，f(n)=2^(n-1)  </li>
</ul>
</blockquote>
<p><img src="/images/321422_1431327516845_11111.PNG" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span>(<span class="params">self, number</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>**(number-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的<code>索引为奇数的元素</code>位于数组的前半部分，所有的<code>索引为偶数的元素</code>位于数组的后半部分，排序算法稳定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span>(<span class="params">self, array</span>):</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">sorted</span>(array,key= <span class="keyword">lambda</span> ele : array.index(ele) % <span class="number">2</span> == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>最大的坑:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这段代码是会报错的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="keyword">return</span> array.sort(key=<span class="keyword">lambda</span> ele : array.index(ele) % <span class="number">2</span> == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因 : array.sort是原地操作 , sorted是复制后操作 </p>
</blockquote>
<h2 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h2><blockquote>
<p>双指针法 :<br>设置两个指针，p1，p2，先让p2走k-1步，然后再一起走，直到p2为最后一个时，p1即为倒数第k个节点 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#设置两个指针，p2指针先走（k-1）步，然后再一起走，当p2为最后一个时，p1就为倒数第k个 数</span></span><br><span class="line">        p1=p2=head</span><br><span class="line"></span><br><span class="line">        <span class="comment">#p2先走，走k-1步，如果k大于链表长度则返回 空，否则的话继续走</span></span><br><span class="line">        <span class="keyword">while</span> k&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> p2.<span class="built_in">next</span>:</span><br><span class="line">                p2=p2.<span class="built_in">next</span></span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#两个指针一起 走，一直到p2为最后一个,p1即为所求</span></span><br><span class="line">        <span class="keyword">while</span> p2.<span class="built_in">next</span>:</span><br><span class="line">            p1=p1.<span class="built_in">next</span></span><br><span class="line">            p2=p2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>



<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树<strong>不是</strong>任意一个树的子结构）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span>(<span class="params">self, pRoot1, pRoot2</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> <span class="keyword">not</span> pRoot2 <span class="keyword">else</span> self.core(pRoot1,pRoot2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">core</span>(<span class="params">self, pRoot1, pRoot2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> pRoot1.val == pRoot2.val <span class="keyword">and</span> self.core(pRoot1.left,pRoot2.left) <span class="keyword">and</span> self.core(pRoot1.right,pRoot2.right):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> self.core(pRoot1.left,pRoot2) <span class="keyword">or</span> self.core(pRoot1.right,pRoot2)</span><br></pre></td></tr></table></figure>

<p>骚操作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span>(<span class="params">self, pRoot1, pRoot2</span>):</span></span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">p</span>):</span></span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">str</span>(p.val) +  convert(p.left) + convert(p.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> convert(pRoot2) <span class="keyword">in</span> convert(pRoot1) <span class="keyword">if</span> pRoot2 <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 </span><br><span class="line">5 6 7 8 </span><br><span class="line">9 10 11 12 </span><br><span class="line">13 14 15 16 </span><br></pre></td></tr></table></figure>

<p>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>我的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        startRow  = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        endRow    = [<span class="built_in">len</span>(matrix)-<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">        startCol  = [<span class="number">0</span>,<span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span>]</span><br><span class="line">        endCol    = [<span class="built_in">len</span>(matrix)-<span class="number">1</span>,<span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> startRow[<span class="number">0</span>] &lt; endCol[<span class="number">0</span>] <span class="keyword">and</span> startRow[<span class="number">1</span>] &lt; endCol[<span class="number">1</span>]:</span><br><span class="line">	        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(startRow[<span class="number">1</span>],startCol[<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">	        	res.append(matrix[startRow[<span class="number">0</span>]][idx])</span><br><span class="line"></span><br><span class="line">	        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(startCol[<span class="number">0</span>]+<span class="number">1</span>,endCol[<span class="number">0</span>]+<span class="number">1</span>):</span><br><span class="line">	        	res.append(matrix[idx][startCol[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">	        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(endCol[<span class="number">1</span>]-<span class="number">1</span>,endRow[<span class="number">1</span>]-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">	        	res.append(matrix[endRow[<span class="number">0</span>]][idx])</span><br><span class="line"></span><br><span class="line">	        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(endRow[<span class="number">0</span>]-<span class="number">1</span>,startRow[<span class="number">0</span>],-<span class="number">1</span>):</span><br><span class="line">	        	res.append(matrix[idx][startRow[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">	        </span><br><span class="line">	        startRow[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">	        startRow[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	        endRow[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">	        endRow[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	        startCol[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">	        startCol[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	        endCol[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">	        endCol[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],</span><br><span class="line">    [<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>],</span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(s.printMatrix(matrix))</span><br></pre></td></tr></table></figure>

<p>正确思路 :</p>
<blockquote>
<ol>
<li>打印一圈 </li>
</ol>
<ul>
<li>从左到右打印一行（这是一定有的）     </li>
<li>当有两行及以上时，存在从上到下打印     </li>
<li>当有两行及以上并有两列及以上时，存在从右到左     </li>
<li>当有两列并有三行及以上时，存在从下到上打打印   </li>
</ul>
<ol start="2">
<li>起点进入下一圈，即进入下一个循环  </li>
</ol>
<p>  初始几点为(0, 0), 打印一圈后有(1, 1), 再打印一圈为(2, 2)</p>
<p>都存在<code>行数 &gt; 起点 * 2</code> 并且<code>列数 &gt; 起点 * 2</code></p>
<p>简单来说就是， 如果把二维数组等分为四个部分 中点都为中心，那么起点肯定都位于左上部分。根据这个条件可以判断是否还有圈数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        columns = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printMatrixCircle</span>(<span class="params">start</span>):</span></span><br><span class="line">            endRow = rows - <span class="number">1</span> - start</span><br><span class="line">            endColumn = columns - <span class="number">1</span> - start</span><br><span class="line">             </span><br><span class="line">            <span class="comment"># 从左到右打印一行</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(start, endColumn + <span class="number">1</span>):</span><br><span class="line">                result.append(matrix[start][y])</span><br><span class="line">                 </span><br><span class="line">            <span class="comment"># 从上到下打印一列</span></span><br><span class="line">            <span class="keyword">if</span> endRow &gt; start:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(start + <span class="number">1</span>, endRow + <span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[x][endColumn])</span><br><span class="line">                     </span><br><span class="line">            <span class="comment"># 从右到左打印一行</span></span><br><span class="line">            <span class="keyword">if</span> endColumn &gt; start <span class="keyword">and</span> endRow &gt; start:</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(endColumn - <span class="number">1</span>, start - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[endRow][y])</span><br><span class="line">             </span><br><span class="line">            <span class="comment"># 从下到上打印</span></span><br><span class="line">            <span class="keyword">if</span> endRow &gt; start + <span class="number">1</span> <span class="keyword">and</span> endColumn &gt; start:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(endRow - <span class="number">1</span>, start, -<span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[x][start])</span><br><span class="line">         </span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> columns &gt; start * <span class="number">2</span> <span class="keyword">and</span> rows &gt; start * <span class="number">2</span>:</span><br><span class="line">            printMatrixCircle(start)</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>也可以使用如下思路:</p>
<blockquote>
<p>用旋转魔法的方式，一直取出第一行； </p>
<p>   例如  </p>
<p>   1 2 3  </p>
<p>   4 5 6  </p>
<p>   7 8 9  </p>
<p>   输出并删除第一行后，变为  </p>
<p>   4 5 6  </p>
<p>   7 8 9  </p>
<p>   再进行一次逆时针旋转，就变成：  </p>
<p>   6 9  </p>
<p>   5 8  </p>
<p>   4 7  </p>
<p>   继续重复上述操作即可。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res.extend(matrix[<span class="number">0</span>])</span><br><span class="line">            matrix = <span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix[<span class="number">1</span>:]))[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">    [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],</span><br><span class="line">    [<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>],</span><br><span class="line">]</span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.printMatrix(matrix))</span><br></pre></td></tr></table></figure>

<p>由此我们得出<code>反转矩阵</code>的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix = <span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix[<span class="number">1</span>:]))[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<blockquote>
<p>思路：利用一个辅助栈来存放最小值 </p>
<ul>
<li><p>栈  3，4，2，5，1</p>
</li>
<li><p>辅助栈 3，3，2，2，1</p>
</li>
</ul>
<p>每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶 </p>
<p>当出栈时，辅助栈也要出栈 </p>
<p>这种做法可以保证辅助栈顶一定都当前栈的最小值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.assist = []</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="built_in">min</span> = self.<span class="built_in">min</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">min</span> <span class="keyword">or</span> node &lt; <span class="built_in">min</span>:</span><br><span class="line">            self.assist.append(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.assist.append(<span class="built_in">min</span>)</span><br><span class="line">        self.stack.append(node)</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            self.assist.pop()</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.assist:</span><br><span class="line">            <span class="keyword">return</span> self.assist[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><ul>
<li>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。</li>
<li>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</li>
</ul>
<blockquote>
<p>模拟这个过程 : </p>
<p>借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 </p>
<p>  举例： </p>
<p>  入栈1,2,3,4,5 </p>
<p>  出栈4,5,3,2,1 </p>
<p>  首先1入辅助栈，此时栈顶1≠4，继续入栈2 </p>
<p>  此时栈顶2≠4，继续入栈3 </p>
<p>  此时栈顶3≠4，继续入栈4 </p>
<p>  此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3 </p>
<p>  此时栈顶3≠5，继续入栈5 </p>
<p>  此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span>(<span class="params">self, pushV, popV</span>):</span></span><br><span class="line">        <span class="comment"># stack中存入pushV中取出的数据</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> popV:</span><br><span class="line">            <span class="comment"># 如果stack的最后一个元素与popV中第一个元素相等，将两个元素都弹出</span></span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>]==popV[<span class="number">0</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                popV.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 如果pushV中有数据，压入stack</span></span><br><span class="line">            <span class="keyword">elif</span> pushV:</span><br><span class="line">                stack.append(pushV.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="comment"># 上面情况都不满足，直接返回false。</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.IsPopOrder([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>



<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">    		<span class="keyword">return</span> []</span><br><span class="line">    		</span><br><span class="line">        print_li = []</span><br><span class="line">        floor_li = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> floor_li:</span><br><span class="line">        	temp = []</span><br><span class="line">	        <span class="keyword">for</span> node <span class="keyword">in</span> floor_li:</span><br><span class="line">	        	print_li.append(node.val)</span><br><span class="line">	        	<span class="keyword">if</span> node.left:</span><br><span class="line">	        		temp.append(node.left)</span><br><span class="line">	        	<span class="keyword">if</span> node.right:</span><br><span class="line">	        		temp.append(node.right)</span><br><span class="line"></span><br><span class="line">        	floor_li = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> print_li</span><br></pre></td></tr></table></figure>



<h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<blockquote>
<p><strong>知道<code>二叉搜索树</code>的后序遍历,那么就知道二叉搜索树的中序遍历</strong></p>
<p>BST的后序序列的合法序列是:<br>对于一个序列S，最后一个元素是x   （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义   : ) 。  </p>
<p>后序遍历的序列中，最后一个数字是树的根节点 ，数组中前面的数字可以分为两部分：</p>
<ol>
<li>第一部分是左子树节点 的值，<strong>都比根节点的值小</strong>；</li>
<li>第二部分是右子树 节点的值，<strong>都比根节点的值大</strong>，后面用递归分别判断前后两部分 是否 符合以上原则  </li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span>(<span class="params">self, sequence</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        length = <span class="built_in">len</span>(sequence)</span><br><span class="line">        root = sequence[length-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在二叉搜索树中 左子树节点小于根节点</span></span><br><span class="line">        <span class="comment"># 找出根节点i</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> sequence[i]&gt;root:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二叉搜索树中 右子树的节点都大于根节点</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,length):</span><br><span class="line">            <span class="keyword">if</span> sequence[j]&lt;root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断 左子树是否为二叉树</span></span><br><span class="line">        left = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            left = self.VerifySquenceOfBST(sequence[<span class="number">0</span>:i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断 右子树是否为二叉树</span></span><br><span class="line">        right = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; length-<span class="number">1</span>:</span><br><span class="line">            right = self.VerifySquenceOfBST(sequence[i:-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure>



<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span>(<span class="params">self, root, expectNumber</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">subFindPath</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                b.append(root.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="built_in">sum</span>(b) == expectNumber:</span><br><span class="line">                    a.append(b[:])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    subFindPath(root.left),subFindPath(root.right)</span><br><span class="line">                b.pop()</span><br><span class="line">                </span><br><span class="line">        a, b = [], []</span><br><span class="line">        subFindPath(root)</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<blockquote>
<p>得出一个经验:</p>
<ul>
<li>对于一个递归函数来说,如果要引入二维表的话,可以考虑定义来个列表</li>
<li>然后一个list去append另一个list</li>
</ul>
</blockquote>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</p>
<blockquote>
<ol>
<li>遍历链表，复制链表中的每个结点，并将复制的结点插入到该结点的后面。例如，原链表为A-&gt;B-&gt;C, 遍历完毕后，链表变为A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’，其中A‘，B’，C’是结点A，B，C的复制结点。看图中，蓝色箭头为next指针：</li>
</ol>
<p><img src="/images/1379031-20180720004256599-1726273203.png" alt="img">  </p>
<p>复制结点后：</p>
<p><img src="/images/1379031-20180720004316219-1927624298.png" alt="img"></p>
<ol start="2">
<li>为复制结点的random指针赋值</li>
</ol>
<p>如果原结点的random指针指向的是结点B，那么将复制结点的random指针指向结点B的复制结点B’。</p>
<p>图中黑色箭头为random指针：复制结点的random指针赋值后：</p>
<p><img src="/images/1379031-20180720005045852-845801966.png" alt="img"></p>
<ol start="3">
<li>将链表的原始结点与复制结点分割至两个链表，使原始结点构成一个链表，复制结点构成一个链表。</li>
</ol>
<p><img src="/images/1379031-20180720005505570-2076127344.png" alt="img"></p>
<p><img src="/images/1379031-20180720005111566-783733294.png" alt="img"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class RandomListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#         self.random = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.connectnodes(pHead)</span><br><span class="line">        self.connectrandomnodes(pHead)</span><br><span class="line">        <span class="keyword">return</span> self.reconnectnodes(pHead)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 复制原始链表的每个结点, 将复制的结点链接在其原始结点的后面</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectnodes</span>(<span class="params">self,pHead</span>):</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> (pNode):</span><br><span class="line">            pClone = RandomListNode(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 复制</span></span><br><span class="line">            pClone.label = pNode.label</span><br><span class="line">            pClone.<span class="built_in">next</span> = pNode.<span class="built_in">next</span></span><br><span class="line">            pClone.random = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 连接</span></span><br><span class="line">            pNode.<span class="built_in">next</span> = pClone</span><br><span class="line">            pNode = pClone.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 将复制后的链表中的复制结点的random指针链接到被复制结点random指针的后一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectrandomnodes</span>(<span class="params">self,pHead</span>):</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> (pNode):</span><br><span class="line">            pClone = pNode.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> pNode.random:</span><br><span class="line">                pClone.random = pNode.random.<span class="built_in">next</span></span><br><span class="line">            pNode = pClone.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 拆分链表, 将原始链表的结点组成新的链表, 复制结点组成复制后的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconnectnodes</span>(<span class="params">self,pHead</span>):</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        pHeadclone = pClone = pNode.<span class="built_in">next</span></span><br><span class="line">        pNode.<span class="built_in">next</span> = pClone.<span class="built_in">next</span></span><br><span class="line">        pNode = pClone.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> pNode:</span><br><span class="line">            pClone.<span class="built_in">next</span> = pNode.<span class="built_in">next</span></span><br><span class="line">            pClone = pClone.<span class="built_in">next</span></span><br><span class="line">            pNode.<span class="built_in">next</span> = pClone.<span class="built_in">next</span></span><br><span class="line">            pNode = pNode.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pHeadclone</span><br></pre></td></tr></table></figure>



<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span>(<span class="params">self, pRootOfTree</span>):</span></span><br><span class="line">        <span class="comment"># 中序遍历</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_tree</span>(<span class="params">pRootOfTree</span>):</span></span><br><span class="line">            <span class="keyword">if</span> pRootOfTree.left:</span><br><span class="line">                get_tree(pRootOfTree.left)</span><br><span class="line">            node_list.append(pRootOfTree)</span><br><span class="line">            <span class="keyword">if</span> pRootOfTree.right:</span><br><span class="line">                get_tree(pRootOfTree.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        node_list = []</span><br><span class="line">        get_tree(pRootOfTree)</span><br><span class="line">        head = node_list[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 连接</span></span><br><span class="line">        <span class="keyword">for</span> node1,node2 <span class="keyword">in</span> <span class="built_in">zip</span>(node_list,node_list[<span class="number">1</span>:]):</span><br><span class="line">            node1.right = node2</span><br><span class="line">            node2.left = node1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<p>也可以:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span>(<span class="params">self, pRootOfTree</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">         </span><br><span class="line">        p = pRootOfTree</span><br><span class="line">         </span><br><span class="line">        stack = []</span><br><span class="line">        resStack = []</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                stack.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                resStack.append(node)</span><br><span class="line">                p = node.right</span><br><span class="line">             </span><br><span class="line">        resP = resStack[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> resStack:</span><br><span class="line">            top = resStack.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> resStack:</span><br><span class="line">                top.right = resStack[<span class="number">0</span>]</span><br><span class="line">                resStack[<span class="number">0</span>].left = top</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> resP</span><br></pre></td></tr></table></figure>

<p>至此,我们得出了不用递归的<code>中序遍历</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p = pRootOfTree</span><br><span class="line"> </span><br><span class="line">stack = []</span><br><span class="line">resStack = []</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">or</span> stack:</span><br><span class="line">    <span class="keyword">if</span> p:</span><br><span class="line">        stack.append(p)</span><br><span class="line">        p = p.left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        resStack.append(node)</span><br><span class="line">        p = node.right</span><br></pre></td></tr></table></figure>



<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><ul>
<li>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。按字典序打印出该字符串中字符的所有排列。</li>
<li>例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span>(<span class="params">self, ss</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ss)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ss)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [ss]</span><br><span class="line">        res=<span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ss)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> self.Permutation(ss[:i]+ss[i+<span class="number">1</span>:]):</span><br><span class="line">                res.add(ss[i]+j)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">list</span>(res))</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.Permutation(<span class="string">&#x27;abc&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。<strong>如果不存在则输出0</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        cur = numbers[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> cur == num:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                cur = num</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num == cur:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span>*c &gt; <span class="built_in">len</span>(numbers):</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><ul>
<li>计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？</li>
<li>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</li>
</ul>
<blockquote>
<p>dp[i] = max{ dp[i-1]+array[i] , array[i] }.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        opt = [<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)] * <span class="built_in">len</span>(array)</span><br><span class="line">        opt[<span class="number">0</span>] = array[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(array)):</span><br><span class="line">            planA = opt[idx-<span class="number">1</span>] + array[idx]</span><br><span class="line">            planB = array[idx]</span><br><span class="line">            opt[idx] = <span class="built_in">max</span>(planA,planB)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(opt)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Solution().FindGreatestSumOfSubArray([<span class="number">6</span>,-<span class="number">3</span>,-<span class="number">2</span>,<span class="number">7</span>,-<span class="number">15</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>



<h2 id="整数中1出现的次数-从1到n整数中1出现的次数"><a href="#整数中1出现的次数-从1到n整数中1出现的次数" class="headerlink" title="整数中1出现的次数(从1到n整数中1出现的次数)"></a>整数中1出现的次数(从1到n整数中1出现的次数)</h2><p>计算从1 到 n 中1出现的次数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span>(<span class="params">self,n</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">                num,remain = <span class="built_in">divmod</span>(num,<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">if</span> remain == <span class="number">1</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.NumberOf1Between1AndN_Solution(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><ul>
<li>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</li>
<li>例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</li>
</ul>
<blockquote>
<p>模仿快排</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,numbers))</span><br><span class="line">        res = self.core(numbers)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">core</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(numbers) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> numbers</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            val = numbers[<span class="number">0</span>]</span><br><span class="line">            left  = self.core([num <span class="keyword">for</span> num <span class="keyword">in</span> numbers[<span class="number">1</span>:] <span class="keyword">if</span> val + num &gt;= num + val])</span><br><span class="line">            right = self.core([num <span class="keyword">for</span> num <span class="keyword">in</span> numbers[<span class="number">1</span>:] <span class="keyword">if</span> val + num &lt; num + val])</span><br><span class="line">            <span class="keyword">return</span> left + [val] + right</span><br><span class="line">        </span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.PrintMinNumber([<span class="number">3</span>,<span class="number">32</span>,<span class="number">321</span>]))</span><br><span class="line"><span class="built_in">print</span>(s.PrintMinNumber([<span class="number">1</span>,<span class="number">11</span>,<span class="number">111</span>]))</span><br></pre></td></tr></table></figure>



<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> index: <span class="comment"># 处理边界情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = [<span class="number">0</span>,<span class="number">1</span>] <span class="comment"># 存储维护丑数序列</span></span><br><span class="line">        i2 = i3 = i5 = <span class="number">1</span> <span class="comment"># 待增加相应质因子的丑数的位置，i2之前的丑数增加一个2的结果已经都入列了，因此i2是序列中增加一个2的最小的位置了，i3i5同理</span></span><br><span class="line">        <span class="keyword">while</span>(index-<span class="number">1</span>):</span><br><span class="line">            x,y,z = res[i2]*<span class="number">2</span>,res[i3]*<span class="number">3</span>,res[i5]*<span class="number">5</span> <span class="comment"># 三个候选丑数</span></span><br><span class="line">            <span class="comment"># 选择其中最小的一个入列，并且向下遍历</span></span><br><span class="line">            <span class="keyword">if</span> x &lt;= y <span class="keyword">and</span> x &lt;= z:</span><br><span class="line">                tar = x</span><br><span class="line">                i2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> y &lt;= x <span class="keyword">and</span> y &lt;= z:</span><br><span class="line">                tar = y</span><br><span class="line">                i3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tar = z</span><br><span class="line">                i5 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> tar != res[-<span class="number">1</span>]: <span class="comment"># 去重操作，同样的数不多次入队</span></span><br><span class="line">                res.append(tar)</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<blockquote>
<p>题目保证输入的数组中没有的相同的数字</p>
<p>数据范围：</p>
<ul>
<li>对于%50的数据,size&lt;=10^4</li>
<li>对于%75的数据,size&lt;=10^5</li>
<li>对于%100的数据,size&lt;=2*10^5</li>
</ul>
<p>输入<code>1,2,3,4,5,6,7,0</code> , 输出<code>7</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">global</span> count</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span>(<span class="params">lists</span>):</span></span><br><span class="line">            <span class="keyword">global</span> count</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(lists) &lt;= <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> lists</span><br><span class="line">            num = <span class="built_in">len</span>(lists) // <span class="number">2</span></span><br><span class="line">            left = MergeSort(lists[:num])</span><br><span class="line">            right = MergeSort(lists[num:])</span><br><span class="line"></span><br><span class="line">            r, l=<span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            result=[]</span><br><span class="line">            <span class="keyword">while</span> l&lt;<span class="built_in">len</span>(left) <span class="keyword">and</span> r&lt;<span class="built_in">len</span>(right):</span><br><span class="line">                <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">                    result.append(left[l])</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append(right[r])</span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                    count += <span class="built_in">len</span>(left)-l</span><br><span class="line">                    </span><br><span class="line">            result += right[r:]</span><br><span class="line">            result += left[l:]</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        MergeSort(data)</span><br><span class="line">        <span class="keyword">return</span> count%<span class="number">1000000007</span></span><br></pre></td></tr></table></figure>



<h2 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h2><p>一个整型数组里除了<strong>两个数字</strong>之外，其他的数字都出现了<strong>两次</strong>。请写程序找出这两个只出现一次的数字。</p>
<blockquote>
<ul>
<li>异或的性质：两个相同数字异或=0，一个数和0异或还是它本身。</li>
<li>看两个数（我们假设是AB），先异或，剩下的数字肯定是A、B异或的结果，<strong>这个结果的二进制中的1，表现的是A和B的不同的位</strong>。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成<strong>两组</strong>，分组标准是第3位是否为1。如此，<strong>相同的数肯定在一个组</strong>，因为相同数字所有位都相同，而不同的数，<strong>肯定不在一组</strong>。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。  </li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 对array中的数字进行异或运算</span></span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            tmp ^= i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取tmp中最低位1的位置</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (tmp &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">            tmp &gt;&gt;= <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        a = b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> self.isBit(i, idx):</span><br><span class="line">                a ^= i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b ^= i</span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBit</span>(<span class="params">self, num, idx</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        判断num的二进制从低到高idx位是不是1</span></span><br><span class="line"><span class="string">        :param num: 数字</span></span><br><span class="line"><span class="string">        :param idx: 二进制从低到高位置</span></span><br><span class="line"><span class="string">        :return: num的idx位是否为1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num = num &gt;&gt; idx</span><br><span class="line">        <span class="keyword">return</span> num &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h2><ul>
<li>计算出9~16的和,马上就写出了正确答案是100。</li>
<li>有多少种连续的正数序列的和为100(至少包括两个数)。</li>
<li>找出所有和为S的连续正数序列? </li>
</ul>
<p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<blockquote>
<ul>
<li>双指针 , <strong>left=1,right=2</strong></li>
<li>如果当前窗口内的值之和小于sum，那么右边窗口右移一下 , 如果当前窗口内的值之和大于sum，那么左边窗口右移一下</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span>(<span class="params">self, tsum</span>):</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            tmp = (left + right) * ((right - left + <span class="number">1</span>) / <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">if</span> tmp &gt; tsum:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> tmp &lt; tsum:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([num <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(left,right+<span class="number">1</span>)])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.FindContinuousSequence(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般双指针都是左右不断缩小的,</p>
<p>要注意这种双指针不断扩大的类型</p>
</blockquote>
<h2 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h2><ul>
<li>普通扑克牌 , 多加大小王各一张 . </li>
<li>王能视任何牌 .A看作1,J为11,Q为12,K为13</li>
<li>现在给5张牌 , 看是否能组成顺子(为了方便起见,大小王表示为0。)</li>
</ul>
<blockquote>
<ul>
<li>排序,计算前面0的个数zeros</li>
<li>然后zeros - (顺子差的数)</li>
<li>若zeros最后 &gt;= 0 说明用大小王补够用 否则不行</li>
<li>还要判断一下只要有相同的牌直接返回false</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span>(<span class="params">self, numbers</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        numbers.sort()</span><br><span class="line">        <span class="comment"># 计算大小王的数量</span></span><br><span class="line">        zero_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> pocker <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> pocker == <span class="number">0</span>:</span><br><span class="line">                zero_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去除大小王</span></span><br><span class="line">        numbers = numbers[zero_count:]</span><br><span class="line">        <span class="comment"># 存在重复则直接失败</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(numbers) != <span class="built_in">len</span>(<span class="built_in">set</span>(numbers)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 在最大和最小之间使用王来补充 , 如果王的数量减到负数,说明失败</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(numbers[<span class="number">0</span>]+<span class="number">1</span>,numbers[-<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> numbers:</span><br><span class="line">                    zero_count -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> zero_count &lt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.IsContinuous([<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>



<h2 id="求1-2-3-…-n"><a href="#求1-2-3-…-n" class="headerlink" title="求1+2+3+…+n"></a>求1+2+3+…+n</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        res = n</span><br><span class="line">        temp = res <span class="keyword">and</span> self.Sum_Solution(n-<span class="number">1</span>)</span><br><span class="line">        res += temp</span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>

<p>甚至:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> n <span class="keyword">and</span> n + self.Sum_Solution(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        <span class="keyword">while</span>(b): </span><br><span class="line">            a,b = (a^b) &amp; <span class="number">0xFFFFFFFF</span>,((a&amp;b)&lt;&lt;<span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a&lt;=<span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> ~(a^<span class="number">0xFFFFFFFF</span>)</span><br></pre></td></tr></table></figure>



<h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        mapping = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> mapping:</span><br><span class="line">                res = mapping.index(char) + <span class="number">1</span> + res * <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res * sign</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.StrToInt(<span class="string">&#x27;+&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span>(<span class="params">self, numbers, duplication</span>):</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt; <span class="built_in">len</span>(numbers):</span><br><span class="line">            <span class="keyword">if</span> numbers[cur] == cur:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                 </span><br><span class="line">            <span class="keyword">if</span> numbers[cur] == numbers[numbers[cur]]:</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[cur]</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">             </span><br><span class="line">            <span class="comment"># 注意这里不能直接multiple assignment</span></span><br><span class="line">            temp = numbers[cur]</span><br><span class="line">            numbers[cur] = numbers[numbers[cur]]</span><br><span class="line">            numbers[temp] = temp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><ul>
<li>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]*A[1]*…*A[i-1]*A[i+1]*…*A[n-1]。不能使用除法。</li>
<li>题目要求B的i个元素等于A中除了i个元素所有元素乘积</li>
</ul>
<p><img src="/images/841505_1472459965615_8640A8F86FB2AB3117629E2456D8C652.jpg" alt="img"></p>
<blockquote>
<ul>
<li><strong>B[i]的值可以看作下图的矩阵中每行的乘积。</strong> </li>
<li>下三角用连乘可以很容求得，上三角，从下向上也是连乘。 </li>
<li>因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(A)</span><br><span class="line"></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(A)):</span><br><span class="line">            res[idx] = res[idx-<span class="number">1</span>] * A[idx-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            tmp *= A[idx+<span class="number">1</span>]</span><br><span class="line">            res[idx] *= tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.multiply([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure>



<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现一个函数用来匹配包括&#x27;.&#x27;和&#x27;*&#x27;的正则表达式。模式中的字符&#x27;.&#x27;表示任意一个字符，而&#x27;*&#x27;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">self, s, pattern</span>):</span></span><br><span class="line">        <span class="comment"># 如果s与pattern都为空，则True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(pattern) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果s不为空，而pattern为空，则False</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(s) != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(pattern) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 如果s为空，而pattern不为空，则需要判断</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(pattern) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># pattern中的第二个字符为*，则pattern后移两位继续比较</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pattern) &gt; <span class="number">1</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> self.match(s, pattern[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># s与pattern都不为空的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># pattern的第二个字符为*的情况</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pattern) &gt; <span class="number">1</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="comment"># s与pattern的第一个元素不同，则s不变，pattern后移两位，相当于pattern前两位当成空</span></span><br><span class="line">                <span class="keyword">if</span> s[<span class="number">0</span>] != pattern[<span class="number">0</span>] <span class="keyword">and</span> pattern[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> self.match(s, pattern[<span class="number">2</span>:])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果s[0]与pattern[0]相同，且pattern[1]为*，这个时候有三种情况</span></span><br><span class="line">                    <span class="comment"># pattern后移2个，s不变；相当于把pattern前两位当成空，匹配后面的</span></span><br><span class="line">                    <span class="comment"># pattern后移2个，s后移1个；相当于pattern前两位与s[0]匹配</span></span><br><span class="line">                    <span class="comment"># pattern不变，s后移1个；相当于pattern前两位，与s中的多位进行匹配，因为*可以匹配多位</span></span><br><span class="line">                    <span class="keyword">return</span> self.match(s, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">2</span>:]) <span class="keyword">or</span> self.match(s[<span class="number">1</span>:], pattern)</span><br><span class="line">            <span class="comment"># pattern第二个字符不为*的情况</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[<span class="number">0</span>] == pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><p>实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串<code>+100</code>,<code>5e2</code>,<code>-123</code>,<code>3.1416</code>和<code>-1E-16</code>都表示数值。 但是<code>12e</code>,<code>1a3.14</code>,<code>1.2.3</code>,<code>+-5</code>和<code>12e+4.3</code>都不是。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        has_point = <span class="literal">False</span></span><br><span class="line">        has_e = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i]==<span class="string">&#x27;E&#x27;</span> <span class="keyword">or</span> s[i] ==<span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> has_e: <span class="comment">#不能出现两个e or E (如9e5e6)</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    has_e = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="built_in">len</span>(s)-<span class="number">1</span>:    <span class="comment">#e不能出现在最后面</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] ==<span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> s[i] ==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> (s[i-<span class="number">1</span>] != <span class="string">&#x27;e&#x27;</span> <span class="keyword">and</span> s[i-<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>): <span class="comment">#符号位，必须是跟在e后面</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="built_in">len</span>(s)-<span class="number">1</span>:        <span class="comment">#不能出现在最后面</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] ==<span class="string">&#x27;.&#x27;</span>:             <span class="comment">#小数点不能出现两次；</span></span><br><span class="line">                <span class="keyword">if</span> has_point <span class="keyword">or</span> has_e:   <span class="comment">#如果已经出现过e了，就不能再出现小数点，e后面只能是整数</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    has_point = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="built_in">len</span>(s)-<span class="number">1</span>:    <span class="comment">#不能出现在最后面</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;0123456789&#x27;</span>: <span class="comment">#其他字符必须是‘0’到‘9’之间的</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h2 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.char_list = [-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">        self.index = <span class="number">0</span>  <span class="comment"># 记录当前字符的个数，可以理解为输入的字符串中的下标</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    解法：利用一个int型数组表示256个字符，这个数组初值置为-1.</span></span><br><span class="line"><span class="string">    每读出一个字符，将该字符的位置存入字符对应数组下标中。</span></span><br><span class="line"><span class="string">    若值为-1标识第一次读入，不为-1且&gt;0表示不是第一次读入，将值改为-2.</span></span><br><span class="line"><span class="string">    之后在数组中找到&gt;0的最小值，该数组下标对应的字符为所求。</span></span><br><span class="line"><span class="string">    在python中，ord(char)是得到char对应的ASCII码；chr(idx)是得到ASCII位idx的字符</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span>(<span class="params">self</span>):</span></span><br><span class="line">        min_value = <span class="number">500</span></span><br><span class="line">        min_idx = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> self.char_list[i] &gt; -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> self.char_list[i] &lt; min_value:</span><br><span class="line">                    min_value = self.char_list[i]</span><br><span class="line">                    min_idx = i</span><br><span class="line">        <span class="keyword">if</span> min_idx &gt; -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chr</span>(min_idx)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span>(<span class="params">self, char</span>):</span></span><br><span class="line">        <span class="comment"># 如果是第一出现，则将对应元素的值改为下边</span></span><br><span class="line">        <span class="keyword">if</span> self.char_list[<span class="built_in">ord</span>(char)] == -<span class="number">1</span>:</span><br><span class="line">            self.char_list[<span class="built_in">ord</span>(char)] = self.index</span><br><span class="line">        <span class="comment"># 如果已经出现过两次了，则不修改</span></span><br><span class="line">        <span class="keyword">elif</span> self.char_list[<span class="built_in">ord</span>(char)] == -<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 如果出现过一次，则进行修改，修改为-2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.char_list[<span class="built_in">ord</span>(char)] = -<span class="number">2</span></span><br><span class="line">        self.index += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单方法 :</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">id</span>(pHead) <span class="keyword">not</span> <span class="keyword">in</span> l:</span><br><span class="line">                l.append(<span class="built_in">id</span>(pHead))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> pHead</span><br><span class="line"></span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>找环中相汇点。分别用p1，p2指向链表头部，p1每次走一步，p2每次走二步，直到p1==p2找到在环中的相汇点。   </li>
<li>找环的入口。接上步，当p1=p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2比p1多走一圈有2x=n+x;     n=x;可以看出<strong>p1实际走了一个环的步数</strong>，</li>
<li>再让p2指向链表头部，p1位置不变，p1,p2每次走一步直到p1=p2;     此时p1指向环的入口。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        low = fast = pHead</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            low = low.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> low == fast:</span><br><span class="line">                low = pHead</span><br><span class="line">                <span class="keyword">while</span> low != fast:</span><br><span class="line">                    low = low.<span class="built_in">next</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> low</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>



<h2 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dummy = pre = ListNode(<span class="literal">None</span>)</span><br><span class="line">            dummy.<span class="built_in">next</span> = pHead</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> pHead <span class="keyword">and</span> pHead.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">if</span> pHead.val == pHead.<span class="built_in">next</span>.val:</span><br><span class="line">                    <span class="keyword">while</span> pHead.<span class="built_in">next</span> <span class="keyword">and</span> pHead.val == pHead.<span class="built_in">next</span>.val:</span><br><span class="line">                        pHead.<span class="built_in">next</span> = pHead.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">                    pre.<span class="built_in">next</span> = pHead.<span class="built_in">next</span></span><br><span class="line">                    pHead = pHead.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre = pHead</span><br><span class="line">                    pHead = pHead.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h2 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h2><ul>
<li>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。</li>
<li>注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span>(<span class="params">self, pNode</span>):</span></span><br><span class="line">        <span class="comment"># 有右子树</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            p = pNode.right</span><br><span class="line">            <span class="keyword">while</span> p.left:</span><br><span class="line">                p = p.left</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="comment"># 无右子树，则找第一个当前节点是父节点左孩子的节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> pNode.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">if</span> pNode.<span class="built_in">next</span>.left == pNode:</span><br><span class="line">                    <span class="keyword">return</span> pNode.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 沿着父节点向上遍历</span></span><br><span class="line">                pNode = pNode.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 到了根节点仍没找到，则返回空</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于中序遍历问题 , 我们需要分成<code>有右子树</code>和<code>没有右子树</code>两个问题.</p>
</blockquote>
<h2 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h2><p>请实现一个函数按照<code>之</code>字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        res = []</span><br><span class="line">        q = [pRoot]</span><br><span class="line">        left2right = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> left2right:</span><br><span class="line">                l = [node.val <span class="keyword">for</span> node <span class="keyword">in</span> q]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = <span class="built_in">list</span>(<span class="built_in">reversed</span>([node.val <span class="keyword">for</span> node <span class="keyword">in</span> q]))</span><br><span class="line">            res.append(l)</span><br><span class="line">            left2right = <span class="keyword">not</span> left2right</span><br><span class="line"></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line"></span><br><span class="line">            q = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<ul>
<li><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。</p>
</li>
<li><p>序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
</li>
<li><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.flag = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;#!&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(root.val) + <span class="string">&#x27;!&#x27;</span>+ self.Serialize(root.left) + self.Serialize(root.right)</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        l = s.split(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> self.flag &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = <span class="literal">None</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> l[self.flag] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(l[self.flag]))</span><br><span class="line">            root.left = self.Deserialize(s)</span><br><span class="line">            root.right = self.Deserialize(s)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self.sarializeCore(root)</span><br><span class="line">        <span class="keyword">return</span> self.s</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sarializeCore</span>(<span class="params">self,root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.s += <span class="string">&quot;#,&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.s += <span class="built_in">str</span>(root.val)+<span class="string">&quot;,&quot;</span></span><br><span class="line">        self.sarializeCore(root.left)</span><br><span class="line">        self.sarializeCore(root.right)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>]==<span class="string">&quot;#&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        s= s.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        root = self.DeserializeCore(s)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DeserializeCore</span>(<span class="params">self,s</span>):</span></span><br><span class="line"> </span><br><span class="line">        t = s[self.index]</span><br><span class="line">        <span class="keyword">if</span> t.isdigit():</span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(t))</span><br><span class="line">            self.index +=<span class="number">1</span></span><br><span class="line">            left = self.DeserializeCore(s)</span><br><span class="line">            right = self.DeserializeCore(s)</span><br><span class="line">            root.left = left</span><br><span class="line">            root.right = right</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> t ==<span class="string">&quot;#&quot;</span>:</span><br><span class="line">            self.index+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">t = TreeNode(<span class="number">8</span>)</span><br><span class="line">t1 =TreeNode(<span class="number">6</span>)</span><br><span class="line">t2 = TreeNode(<span class="number">10</span>)</span><br><span class="line">t3 = TreeNode(<span class="number">5</span>)</span><br><span class="line">t4 =TreeNode(<span class="number">7</span>)</span><br><span class="line">t5 = TreeNode(<span class="number">9</span>)</span><br><span class="line">t6 = TreeNode(<span class="number">11</span>)</span><br><span class="line">t.left = t1</span><br><span class="line">t.right = t2</span><br><span class="line">t1.left = t3</span><br><span class="line">t1.right = t4</span><br><span class="line">t2.left = t5</span><br><span class="line">t2.right = t6</span><br><span class="line"><span class="built_in">print</span> Solution().Serialize(t)</span><br><span class="line"><span class="built_in">print</span> Solution().Deserialize(Solution().Serialize(t))</span><br></pre></td></tr></table></figure>



<h2 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h2><p>求一个数据流中的中位数？</p>
<p>我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.heaps = [], []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        small, large = self.heaps</span><br><span class="line">        <span class="comment"># 将num放入大根堆，并弹出大根堆的最小值，取反，放入大根堆small</span></span><br><span class="line">        heappush(small, -heappushpop(large, num))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(large) &lt; <span class="built_in">len</span>(small):</span><br><span class="line">            <span class="comment"># 弹出small中最小的值，取反，即最大的值，放入large</span></span><br><span class="line">            heappush(large, -heappop(small)) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span>(<span class="params">self,ss</span>):</span></span><br><span class="line">        small,large = self.heaps</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(large) &gt; <span class="built_in">len</span>(small):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(large[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> (large[<span class="number">0</span>] - small[<span class="number">0</span>]) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>



<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span>(<span class="params">self, num, size</span>):</span></span><br><span class="line">        queue,res,i = [],[],<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> size &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(num):</span><br><span class="line">            <span class="comment"># 若最大值queue[0]位置过期 则弹出 </span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> <span class="keyword">and</span> i - size + <span class="number">1</span> &gt; queue[<span class="number">0</span>]: </span><br><span class="line">                queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 每次弹出所有比num[i]的数字</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> <span class="keyword">and</span> num[queue[-<span class="number">1</span>]] &lt; num[i]: </span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= size-<span class="number">1</span>:</span><br><span class="line">                res.append(num[queue[<span class="number">0</span>]])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.maxInWindows([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],<span class="number">3</span>))</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="简单问题"><a href="#简单问题" class="headerlink" title="简单问题"></a>简单问题</h1><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        s = s.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;%20&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>



<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack1) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.stack2):</span><br><span class="line">                self.stack1.append(self.stack2.pop())</span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.stack1) &gt; <span class="number">1</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">            <span class="keyword">return</span> self.stack1.pop()</span><br></pre></td></tr></table></figure>



<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res)&lt;=n:</span><br><span class="line">            res.append(res[-<span class="number">1</span>]+res[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br></pre></td></tr></table></figure>



<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">2</span>:</span><br><span class="line">        	<span class="keyword">return</span> number</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	a = b = <span class="number">1</span></span><br><span class="line">        	<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number-<span class="number">1</span>):</span><br><span class="line">        		a,b = b , a+b </span><br><span class="line">        	<span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>



<h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        res = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res) &lt;= number:</span><br><span class="line">            res.append(res[-<span class="number">1</span>] + res[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[number]</span><br></pre></td></tr></table></figure>



<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&quot;1&quot;</span>) <span class="keyword">if</span> n&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="built_in">bin</span>(<span class="number">2</span>**<span class="number">32</span>+n).count(<span class="string">&quot;1&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        p = pHead</span><br><span class="line">        j = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        p.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j:</span><br><span class="line">            pHead = j</span><br><span class="line">            j = j.<span class="built_in">next</span></span><br><span class="line">            pHead.<span class="built_in">next</span> = p</span><br><span class="line">            p = pHead</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pHead</span><br></pre></td></tr></table></figure>



<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span>(<span class="params">self, pHead1, pHead2</span>):</span></span><br><span class="line">        dummy = p = ListNode(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val &gt; pHead2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = pHead2</span><br><span class="line">                pHead2 = pHead2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = pHead1</span><br><span class="line">                pHead1 = pHead1.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        p.<span class="built_in">next</span> = pHead1 <span class="keyword">or</span> pHead2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span>(<span class="params">self, root</span>):</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			root.left,root.right = root.right,root.left</span><br><span class="line">			self.Mirror(root.left)</span><br><span class="line">			self.Mirror(root.right)</span><br><span class="line">			<span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">self,li,val</span>):</span></span><br><span class="line">        li.append(val)</span><br><span class="line">        idx = <span class="built_in">len</span>(li) -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> idx &gt;= <span class="number">1</span> <span class="keyword">and</span> li[idx-<span class="number">1</span>] &gt; li[idx]:</span><br><span class="line">            li[idx],li[idx-<span class="number">1</span>] = li[idx-<span class="number">1</span>],li[idx]</span><br><span class="line">            idx -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> li[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span>(<span class="params">self, tinput, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tinput) &lt; k <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        li = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * k</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> tinput:</span><br><span class="line">            <span class="keyword">if</span> num &lt; li[-<span class="number">1</span>]:</span><br><span class="line">                li = self.insert_sort(li,num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure>



<h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        idx_list = [<span class="number">0</span>] * <span class="number">58</span></span><br><span class="line">        mapping = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[idx] <span class="keyword">in</span> mapping:</span><br><span class="line">                mapping[s[idx]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mapping[s[idx]] = <span class="number">1</span></span><br><span class="line">                idx_list[<span class="built_in">ord</span>(s[idx])-<span class="number">65</span>] = idx</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> char,count <span class="keyword">in</span> mapping.items():</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">                res = <span class="built_in">min</span>(res,idx_list[<span class="built_in">ord</span>(char)-<span class="number">65</span>]) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><p>输入两个链表，找出它们的第一个公共结点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span>(<span class="params">self, pHead1, pHead2</span>):</span></span><br><span class="line">        p1,p2=pHead1,pHead2</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:</span><br><span class="line">            p1 = p1.<span class="built_in">next</span> <span class="keyword">if</span> p1 <span class="keyword">else</span> pHead2</span><br><span class="line">            p2 = p2.<span class="built_in">next</span> <span class="keyword">if</span> p2 <span class="keyword">else</span> pHead1</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>



<h2 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h2><p>统计一个数字在排序数组中出现的次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_count</span>(<span class="params">self,data,idx,k</span>):</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        left = idx - <span class="number">1</span></span><br><span class="line">        right = idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> data[left] == k:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt;= <span class="built_in">len</span>(data) - <span class="number">1</span> <span class="keyword">and</span> data[right] == k:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span>(<span class="params">self, data, k</span>):</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> data[mid] &gt; k:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> data[mid] &lt; k:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.find_count(data,mid,k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>输入一棵二叉树，求该树的深度。</p>
<blockquote>
<p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径， 最长路径的长度为树的深度。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = b = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pRoot.left:</span><br><span class="line">                a = <span class="number">1</span> + self.TreeDepth(pRoot.left)</span><br><span class="line">            <span class="keyword">if</span> pRoot.right:</span><br><span class="line">                b = <span class="number">1</span> + self.TreeDepth(pRoot.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(a,b)</span><br></pre></td></tr></table></figure>



<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = b = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pRoot.left:</span><br><span class="line">                a = <span class="number">1</span> + self.TreeDepth(pRoot.left)</span><br><span class="line">            <span class="keyword">if</span> pRoot.right:</span><br><span class="line">                b = <span class="number">1</span> + self.TreeDepth(pRoot.right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(a,b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(self.TreeDepth(pRoot.left) - self.TreeDepth(pRoot.right)) &lt;= <span class="number">1</span>:</span><br><span class="line">                a = self.IsBalanced_Solution(pRoot.left)</span><br><span class="line">                b = self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">                <span class="keyword">return</span> a <span class="keyword">and</span> b</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>进阶方法 : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced</span>(<span class="params">self, pRoot, depth</span>):</span></span><br><span class="line">        <span class="keyword">if</span> pRoot <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.IsBalanced(pRoot.right, right) <span class="keyword">and</span> self.IsBalanced(pRoot.left, left):</span><br><span class="line">            diff = <span class="built_in">abs</span>(left - right)</span><br><span class="line">            <span class="keyword">if</span> diff &lt;= <span class="number">1</span>:</span><br><span class="line">                depth = <span class="built_in">max</span>(left, right) +<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.IsBalanced(pRoot, depth)</span><br></pre></td></tr></table></figure>



<h2 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum</span>(<span class="params">self, array, tsum</span>):</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(array) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            tot = array[left] + array[right]</span><br><span class="line">            <span class="keyword">if</span> tot &lt; tsum:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> tot &gt; tsum:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> array[left],array[right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.FindNumbersWithSum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>],<span class="number">15</span>))</span><br></pre></td></tr></table></figure>



<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span>(<span class="params">self, s, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">            </span><br><span class="line">        leng = <span class="built_in">len</span>(s)</span><br><span class="line">        n %= leng</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            s = s[<span class="number">1</span>:] + s[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.LeftRotateString(<span class="string">&#x27;123456&#x27;</span>,<span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span>(<span class="params">self, s, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        n %=  <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s[n:]+s[:n]</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.LeftRotateString(<span class="string">&#x27;123456&#x27;</span>,<span class="number">7</span>))</span><br></pre></td></tr></table></figure>



<h2 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h2><p>“student. a am I”。把句子单词的顺序翻转，正确的句子应该是“I am a student.”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s.split(<span class="string">&#x27; &#x27;</span>)[::-<span class="number">1</span>]:</span><br><span class="line">            res += (char + <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.ReverseSentence(<span class="string">&#x27;student. a am I&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>或者 : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        word_start = word_end = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> word_start &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> s[word_start] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                word_start -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += s[word_start:word_end+<span class="number">1</span>]</span><br><span class="line">                word_start -= <span class="number">1</span></span><br><span class="line">                word_end = word_start</span><br><span class="line"></span><br><span class="line">        res += <span class="string">&#x27; &#x27;</span> + s[word_start+<span class="number">1</span>:word_end+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.ReverseSentence(<span class="string">&#x27;student. a am I&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        l = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(l) != <span class="number">1</span>:</span><br><span class="line">            k = (m + start - <span class="number">1</span>) % n</span><br><span class="line">            l.pop(k)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            start = k</span><br><span class="line">        <span class="keyword">return</span> l[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.LastRemaining_Solution(<span class="number">5</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h2 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span>(<span class="params">self, pRoot</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        q = [pRoot]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            res.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> q])</span><br><span class="line"></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line"></span><br><span class="line">            q = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>