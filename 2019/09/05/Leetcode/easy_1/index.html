<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和&quot;&gt;&lt;/a&gt;1.&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot;&gt;两数之和&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回他们的数组下标。(就是说，在数组中找出两个元素，他们的和为target)"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>easy_1 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></div><div class="post-time">2019-09-05</div></div></div><div class="container post-header"><h1>easy_1</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.</span> <span class="toc-text">1.两数之和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="toc-number">2.</span> <span class="toc-text">7. 整数反转</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">9. 回文数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">13. 罗马数字转整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="toc-number">5.</span> <span class="toc-text">14. 最长公共前缀</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">6.</span> <span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">21. 合并两个有序链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">8.</span> <span class="toc-text">26. 删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">9.</span> <span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-%E5%AE%9E%E7%8E%B0strStr"><span class="toc-number">10.</span> <span class="toc-text">28. 实现strStr()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.</span> <span class="toc-text">35. 搜索插入位置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38-%E6%8A%A5%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">38. 报数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">13.</span> <span class="toc-text">53. 最大子序和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">14.</span> <span class="toc-text">58. 最后一个单词的长度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#66-%E5%8A%A0%E4%B8%80"><span class="toc-number">15.</span> <span class="toc-text">66. 加一</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C"><span class="toc-number">16.</span> <span class="toc-text">67. 二进制求和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-number">17.</span> <span class="toc-text">69. x 的平方根</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">18.</span> <span class="toc-text">70. 爬楼梯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">19.</span> <span class="toc-text">83. 删除排序链表中的重复元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">20.</span> <span class="toc-text">88. 合并两个有序数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-number">21.</span> <span class="toc-text">100. 相同的树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">22.</span> <span class="toc-text">101. 对称二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">23.</span> <span class="toc-text">104. 二叉树的最大深度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II"><span class="toc-number">24.</span> <span class="toc-text">107. 二叉树的层次遍历 II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">25.</span> <span class="toc-text">108. 将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">26.</span> <span class="toc-text">110. 平衡二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">27.</span> <span class="toc-text">111. 二叉树的最小深度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">28.</span> <span class="toc-text">112. 路径总和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">29.</span> <span class="toc-text">118. 杨辉三角</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-II"><span class="toc-number">30.</span> <span class="toc-text">119. 杨辉三角 II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">31.</span> <span class="toc-text">121. 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-number">32.</span> <span class="toc-text">122. 买卖股票的最佳时机 II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">33.</span> <span class="toc-text">125. 验证回文串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">34.</span> <span class="toc-text">136. 只出现一次的数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">35.</span> <span class="toc-text">141. 环形链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">36.</span> <span class="toc-text">155. 最小栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">37.</span> <span class="toc-text">160. 相交链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">38.</span> <span class="toc-text">167. 两数之和 II - 输入有序数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0"><span class="toc-number">39.</span> <span class="toc-text">168. Excel表列名称</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#169-%E6%B1%82%E4%BC%97%E6%95%B0"><span class="toc-number">40.</span> <span class="toc-text">169. 求众数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#171-Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7"><span class="toc-number">41.</span> <span class="toc-text">171. Excel表列序号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6"><span class="toc-number">42.</span> <span class="toc-text">172. 阶乘后的零</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#175-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8"><span class="toc-number">43.</span> <span class="toc-text">175. 组合两个表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#176-%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4"><span class="toc-number">44.</span> <span class="toc-text">176. 第二高的薪水</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#181-%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5"><span class="toc-number">45.</span> <span class="toc-text">181. 超过经理收入的员工</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#182-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1"><span class="toc-number">46.</span> <span class="toc-text">182. 查找重复的电子邮箱</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#183-%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7"><span class="toc-number">47.</span> <span class="toc-text">183. 从不订购的客户</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">48.</span> <span class="toc-text">189. 旋转数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D"><span class="toc-number">49.</span> <span class="toc-text">190. 颠倒二进制位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">50.</span> <span class="toc-text">191. 位1的个数</span></a></li></ol></details></div><div class="container post-content"><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></h1><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。(就是说，在数组中找出两个元素，他们的和为target)</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<p>最垃圾的算法，复杂度为O(n^2^)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums,target</span>):</span></span><br><span class="line">	<span class="keyword">for</span> index1,num1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">		<span class="keyword">for</span> index2,num2 <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">			<span class="keyword">if</span> (index1 != index2) <span class="keyword">and</span> (num1 + num2 == target):</span><br><span class="line">				<span class="keyword">return</span> [index1,index2]</span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(func(a,<span class="number">9</span>))  <span class="comment"># (0, 2)</span></span><br></pre></td></tr></table></figure>

<p>正确的实现如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    hashmap = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">    	<span class="comment"># 另一个数字</span></span><br><span class="line">        another_num = target - num</span><br><span class="line">        <span class="comment"># 如果另一个数字在字典中</span></span><br><span class="line">        <span class="keyword">if</span> another_num <span class="keyword">in</span> hashmap:</span><br><span class="line">            <span class="keyword">return</span> [hashmap[another_num], index]</span><br><span class="line">        <span class="comment"># 将数字本身加入到字典中</span></span><br><span class="line">        hashmap[num] = index</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>==经验:下回遇到相加减乘除,都可以考虑移项,使用一个列表或集合将他装起来.==</p>
<hr>
<h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31^,  2^31^ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>下面是我写的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x &gt;<span class="number">0</span>:</span><br><span class="line">            temp = <span class="built_in">int</span>(<span class="built_in">str</span>(x)[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> x &lt;<span class="number">0</span>:</span><br><span class="line">            temp = - <span class="built_in">int</span>(<span class="built_in">str</span>(x)[<span class="number">1</span>:][::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> -<span class="number">2</span>**<span class="number">31</span> &lt;temp &lt; <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以更加美观:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    	<span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    		s = <span class="string">&#x27;-&#x27;</span></span><br><span class="line">    		x = -x</span><br><span class="line">    	<span class="keyword">else</span>:</span><br><span class="line">    		s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    	result = s + <span class="built_in">str</span>(x)[::-<span class="number">1</span>]</span><br><span class="line">    	<span class="keyword">if</span> <span class="built_in">int</span>(result) &gt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">int</span>(result) &lt; <span class="built_in">pow</span>(-<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">int</span>(result)</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong></p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<p>我的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    	x = <span class="built_in">str</span>(x)</span><br><span class="line">    	x_half_len = <span class="built_in">len</span>(x) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span> <span class="built_in">len</span>(x) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    		part1,part2 = x[:x_half_len],x[x_half_len:]</span><br><span class="line">    	<span class="keyword">else</span>:</span><br><span class="line">    		part1,part2 = x[:x_half_len],x[x_half_len+<span class="number">1</span>:]</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span> part1 == part2[::-<span class="number">1</span>]:</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    	<span class="keyword">else</span>:</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>使用算法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x</span>):</span></span><br><span class="line">		temp_x = x </span><br><span class="line">		k = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span> temp_x != <span class="number">0</span>:</span><br><span class="line">			<span class="comment"># 重点,每次都是弹出最后一位数</span></span><br><span class="line">			<span class="comment"># 所以k就是倒序的x</span></span><br><span class="line">			k = k * <span class="number">10</span> + temp_x % <span class="number">10</span></span><br><span class="line">			<span class="built_in">print</span>(k)</span><br><span class="line">			temp_x = temp_x // <span class="number">10</span></span><br><span class="line">		<span class="keyword">if</span> k == x:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h1><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，<strong>罗马数字中小的数字在大的数字的右边</strong>。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>

<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        hashmap = &#123;<span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>,<span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>,<span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span>&#125; </span><br><span class="line">        result = <span class="number">0</span>        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 特殊情况</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s)-<span class="number">1</span> <span class="keyword">and</span> hashmap[s[i]] &lt; hashmap[s[i+<span class="number">1</span>]]:   </span><br><span class="line">            	<span class="comment"># XLII:此时就把X当成-10</span></span><br><span class="line">                result -= hashmap[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += hashmap[s[i]]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>我一开始想的是跳过:当遇到XL,当扫描到X时直接输出90,然后跳过L.<br>==经验:当想要跳过的时候,可以考虑X本身可以变成什么==</p>
<hr>
<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code> 。  </p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        maxStr, minStr = <span class="built_in">max</span>(strs, default=<span class="string">&quot;&quot;</span>), <span class="built_in">min</span>(strs, default=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(minStr)):</span><br><span class="line">            <span class="keyword">if</span> maxStr[i] != minStr[i]:</span><br><span class="line">                <span class="keyword">return</span> minStr[:i]</span><br><span class="line">        <span class="comment"># 如果for里的if都成功,说明最短单词就是共同子串</span></span><br><span class="line">        <span class="keyword">return</span> minStr</span><br></pre></td></tr></table></figure>

<p>==经验:==</p>
<ol>
<li>==如果比较数组for循环的两个each,可以考虑是不是只需比较最长和最短的两个.<br>如果是在不行,可以取出数组的第一个值,然后使用for循环.==</li>
<li>==那么如何比较最长和最短的两个,先将他们在for外面取出来,然后在for里使用index,这样就可以使用两个索引来取出这两个值了==</li>
<li>==所以说不要总是想着使用for each in alist,而是使用for index in range(len(alist)-1)==</li>
</ol>
<p>如果使用二分法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs == []:</span><br><span class="line">            minlen = <span class="built_in">min</span>([<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> strs])</span><br><span class="line">            <span class="keyword">if</span> minlen == <span class="number">0</span>:</span><br><span class="line">            	<span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># 使用二分法</span></span><br><span class="line">            low = <span class="number">1</span></span><br><span class="line">            high = minlen</span><br><span class="line">            <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">                mid = (low + high) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> self.start_with(strs,mid):</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 注意这里要使用min(low,high)</span></span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>][:<span class="built_in">min</span>(low,high)]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_with</span>(<span class="params">self,strs,str_len</span>):</span></span><br><span class="line">        word = strs[<span class="number">0</span>][:str_len]</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> each.startswith(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>使用栈,代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self,s</span>):</span></span><br><span class="line">        hashmap = &#123;<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> s[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>]:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 遇到左括号就将他们压入栈</span></span><br><span class="line">        	<span class="keyword">if</span> each <span class="keyword">in</span> [<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>]:</span><br><span class="line">        		stack.append(each)</span><br><span class="line">        	<span class="comment"># 当遇到右括号</span></span><br><span class="line">        	<span class="keyword">else</span>:</span><br><span class="line">        		<span class="keyword">if</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] == hashmap[each]:</span><br><span class="line">        			stack.pop()</span><br><span class="line">        		<span class="keyword">else</span>:</span><br><span class="line">        			<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 最后当stack为空,说明全部配对成功</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>还有一种思路:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">&#x27;()&#x27;</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">&#x27;[]&#x27;</span> <span class="keyword">in</span> s:</span><br><span class="line">            s = s.replace(<span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            s = s.replace(<span class="string">&#x27;[]&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            s = s.replace(<span class="string">&#x27;()&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<p>链表定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>我的代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        newnode = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 注意这里,否则最后只会返回最后一个节点</span></span><br><span class="line">        result = newnode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="comment"># 当l1和l2都存在</span></span><br><span class="line">            <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            	<span class="comment"># 当l2的值比较小</span></span><br><span class="line">                <span class="keyword">if</span> l1.val &gt;= l2.val:</span><br><span class="line">                	<span class="comment"># 注意需要使用ListNode类来新建一个节点</span></span><br><span class="line">                    newnode.<span class="built_in">next</span> = ListNode(l2.val)</span><br><span class="line">                    newnode = newnode.<span class="built_in">next</span></span><br><span class="line">                    l2 = l2.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 当l1的值比较小</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    newnode.<span class="built_in">next</span> = ListNode(l1.val)</span><br><span class="line">                    newnode = newnode.<span class="built_in">next</span></span><br><span class="line">                    l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 当l1存在而l2不存在</span></span><br><span class="line">            <span class="keyword">elif</span> l1 <span class="keyword">and</span> (<span class="keyword">not</span> l2):</span><br><span class="line">                newnode.<span class="built_in">next</span> = ListNode(l1.val)</span><br><span class="line">                newnode = newnode.<span class="built_in">next</span></span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 当l2存在而l1不存在</span></span><br><span class="line">            <span class="keyword">elif</span> l2 <span class="keyword">and</span> (<span class="keyword">not</span> l1):</span><br><span class="line">                newnode.<span class="built_in">next</span> = ListNode(l2.val)</span><br><span class="line">                newnode = newnode.<span class="built_in">next</span></span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 因为刚刚创建newnode的时候,传入了None作为头节点,需要使用next去除</span></span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>==经验:==</p>
<ol>
<li>==注意13-15行,使用next连接的逻辑:赋值的右边必须新建一个节点==</li>
<li>==必须使用result = newnode来建立一个副本,不然最后return newnode只会返回最后一个节点==</li>
<li>==我们可以在新建ListNode的时候传入一个None作为头节点,最后使用next去除这个头节点==</li>
</ol>
<p>上面的代码很垃圾,问题出在当其中一个链表不存在的时候,==不需要一个节点一个节点的移动,直接把剩下的链表连接上去就行==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        newnode = ListNode(<span class="literal">None</span>)</span><br><span class="line">        result = newnode</span><br><span class="line">        <span class="comment"># 当两者都存在</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt;= l2.val:</span><br><span class="line">                    newnode.<span class="built_in">next</span> = ListNode(l2.val)</span><br><span class="line">                    newnode = newnode.<span class="built_in">next</span></span><br><span class="line">                    l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newnode.<span class="built_in">next</span> = ListNode(l1.val)</span><br><span class="line">                newnode = newnode.<span class="built_in">next</span></span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 当其中一个链表不存在,直接将另一个链表连接上去</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">and</span> (<span class="keyword">not</span> l2):</span><br><span class="line">            newnode.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">and</span> (<span class="keyword">not</span> l1):</span><br><span class="line">            newnode.<span class="built_in">next</span> = l2</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>我们根据上面两个代码,总结如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        <span class="comment"># 使用链表最经常的操作,连续两次赋值</span></span><br><span class="line">        dummy = pre = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                pre.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 使用惰性赋值</span></span><br><span class="line">        pre.<span class="built_in">next</span> = l1 <span class="keyword">or</span> l2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>==注意上面代码的第4行和第14行,是链表最为经常的操作.==</p>
<hr>
<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h1><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> nums == []:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        cur = nums[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 注意这里的range里的参数,其实就是倒序迭代数组(从倒数第二元素开始)</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果前面的元素和当前元素一样,删除它</span></span><br><span class="line">            <span class="keyword">if</span> cur == nums[index]:</span><br><span class="line">                nums.pop(index)</span><br><span class="line">            <span class="comment"># 否则将当期元素设置为它</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = nums[index]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>

<p>理解第7行的代码,看下面:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line"><span class="comment"># 列表遍历删除元素必须倒序</span></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> x[::-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">if</span> each == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">        x.remove(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>那个,如果不使用for each in alist,而是使用for index in range呢,该如何倒序:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> x[index] == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">        x.remove(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>经验:</p>
<ol>
<li>==range使用倒序的话,第一参数和第二参数需要互换位置==</li>
<li>原先range的使用规则是for index in range(0,len(alist))<br>因为range是上限不在内,即第一参数包含而第二参数不包含.所以第二参数len(alist)移到第一参数位置需要减一,第一参数0移到第二位置也需要减一.<br>(所以前面代码中的for index in range(len(nums)-2,-1,-1)就表示从倒数第二元素开始遍历到最前面)</li>
</ol>
<p>使用for index in range(len(nums)-2,-1,-1)固然可以,可是这时候使用while会更好:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">alist</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(alist):</span><br><span class="line">        <span class="built_in">print</span>(alist[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">func1([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])   <span class="comment"># [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">alist</span>):</span>    </span><br><span class="line">    i = <span class="built_in">len</span>(x) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(alist[i])</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">func2([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])    <span class="comment"># [4,3,2,1]</span></span><br></pre></td></tr></table></figure>

<p>所以代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> nums == []:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        cur = nums[-<span class="number">1</span>]</span><br><span class="line">        index = <span class="built_in">len</span>(nums) - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> cur == nums[index]:</span><br><span class="line">                nums.pop(index)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = nums[index]</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>

<p>经验:<br>==对于数组的循环,while会比for循环慢一点,但是内存消耗会小很多==</p>
<hr>
<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h1><p>给定一个数组 <em>nums</em> 和一个值 <em>val</em>，你需要<strong>原地</strong>移除所有数值等于 <em>val</em> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题很简单了,使用while循环:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self,nums,val</span>):</span></span><br><span class="line">        index = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[index] == val:</span><br><span class="line">                nums.remove(val)</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28. 实现strStr()"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现strStr()</a></h1><p>实现 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义,以及python中的find()相符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack, needle</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> haystack.find(needle)</span><br></pre></td></tr></table></figure>

<p>自己模拟find函数,代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self,haystack,needle</span>):</span></span><br><span class="line">        needle_len = <span class="built_in">len</span>(needle)</span><br><span class="line">        haystack_len = <span class="built_in">len</span>(haystack)</span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> needle_len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> haystack_len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt;= haystack_len - needle_len:</span><br><span class="line">            <span class="keyword">if</span> haystack[index:index + needle_len] == needle:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p>明显该使用二分法,代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums, target</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[mid]:</span><br><span class="line">                high = mid -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target == nums[mid]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意最后的return</span></span><br><span class="line">        <span class="comment"># 不是return min(low,high)</span></span><br><span class="line">        <span class="keyword">if</span> low &gt; mid:</span><br><span class="line">            <span class="keyword">return</span> low</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> high + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>二分法经验:</p>
<ol>
<li>==注意第3,4,6行,low=0,high=len(alist)-1,while的判断条件是while low&lt;=high==</li>
<li>==注意最后mid的取值,需要使用if…else语句,而不是直接return min(low,high)==</li>
</ol>
<p>其实还有一种二分写法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums, target</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            low = <span class="number">0</span></span><br><span class="line">            high = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                mid = low + (high - low)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                    high = mid</span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                    low = mid +<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>

<p>递归的二分法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="comment">#  基线条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mid == left:</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">            <span class="keyword">return</span> mid + self.searchInsert(nums[mid:],target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.searchInsert(nums[:mid],target)</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="38-报数"><a href="#38-报数" class="headerlink" title="38. 报数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-and-say/">38. 报数</a></h1><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>

<p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  “<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p>
<p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出报数序列的第 <em>n</em> 项。</p>
<p>注意：整数顺序将表示为一个字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br></pre></td></tr></table></figure>

<p>说人话:<br>题目的意思是<strong>对序列前一个数进行报数</strong>，<br>数列第一项不是1吗，那第二项就报第一项的有1个1，输出11，<br>然后第三项就在第二项的基础上报数，第二项是11，第三项不就是2个1么，然后输出21。</p>
<blockquote>
<p>第一项是一个 1<br>第二项是对第一项的描述：第二项报数：第一项是一个一 ：11<br>第三项报数：第二项是两个一： 21<br>第四项报数：第三项是一个二，一个一：1211<br>第五项报数：第四项是一个一，一个二，两个一：111221</p>
</blockquote>
<p>我的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        param = <span class="number">1</span></span><br><span class="line">        <span class="comment"># n就是重复调用几次get_next方法</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            before = self.get_next(param)</span><br><span class="line">            param = before</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(param)</span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 将低项转为高项.eg:1211 -&gt; 111221</span></span><br><span class="line">    <span class="comment"># 思路:将字符串按是否连续分割.(1211分割为1,2,11)(111221分割为111,22,1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next</span>(<span class="params">self,before</span>):</span></span><br><span class="line">        before = <span class="built_in">str</span>(before)</span><br><span class="line">        <span class="comment"># 遍历的元素</span></span><br><span class="line">        cur = before[<span class="number">0</span>]</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 从第二个元素开始</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(before)):</span><br><span class="line">            <span class="keyword">if</span> cur == before[index]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += (<span class="built_in">str</span>(count) + cur)</span><br><span class="line">                <span class="comment"># 新的遍历元素</span></span><br><span class="line">                cur = before[index]</span><br><span class="line">                <span class="comment"># 数量充值为1</span></span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        result += (<span class="built_in">str</span>(count) + cur)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>注意上面的5,6,7行代码,这里是不断的执行这个函数.将函数得到的结果当成下一次函数的参数.但是这里并<strong>不是递归</strong>.<br>最明显的区别就是:递归是会暂停函数执行的.而且递归是==在自己的函数体里调用自己==,而这里是在别人的函数体里调用自己.</p>
<p>但是,还是要有这种==在自己的函数体里重复调用别人==的思想.</p>
<p>我还写了个get_before方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_before</span>(<span class="params">after</span>):</span></span><br><span class="line">    after = <span class="built_in">str</span>(after)</span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(after),<span class="number">2</span>):</span><br><span class="line">        result += (<span class="built_in">int</span>(after[index]) * after[index+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(get_before(<span class="number">21</span>))      <span class="comment"># 11</span></span><br><span class="line"><span class="built_in">print</span>(get_before(<span class="number">111221</span>))  <span class="comment"># 1211</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h1><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong></p>
<p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>答案代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路:从左开始扫描整个数组,tot不断叠加数组元素,</span></span><br><span class="line"><span class="comment"># 一旦发现tot小于0,说明前面的数组无用.</span></span><br><span class="line"><span class="comment"># result跟踪tot的最大值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 阶段性求和</span></span><br><span class="line">        tot = <span class="number">0</span></span><br><span class="line">        result = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            tot += num</span><br><span class="line">            <span class="keyword">if</span> tot &gt; result:</span><br><span class="line">                result = tot</span><br><span class="line">            <span class="comment"># 一旦tot为负,就清零</span></span><br><span class="line">            <span class="keyword">if</span> tot &lt; <span class="number">0</span>:</span><br><span class="line">                tot = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="built_in">print</span>(s.maxSubArray([-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]))  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<p>代码解释:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于[-2,1,-3,4,-1,2,1,-5,4]数组来说,扫描-2,小于0.说明-2就是个累赘,舍去.</span><br><span class="line">扫描1时,tot为1,当扫描到-3时,tot=1+(-3)=-2,说明前面的[-2,1,-3]都是没用的.</span><br><span class="line">再次扫描到1时,tot=4-1+2+1=6,当扫描到-5时,tot变成1.此时result跟踪最大值,所以result还是6</span><br></pre></td></tr></table></figure>

<p>所以,还有一种写法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 让max(nums[i-1])和0比较大小</span></span><br><span class="line">            nums[i] += <span class="built_in">max</span>(nums[i-<span class="number">1</span>],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br></pre></td></tr></table></figure>

<p>代码解释:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以理解为思想是动态规划</span><br><span class="line">nums[i-1]并不是数组前一项的意思，而是到前一项为止的最大子序和</span><br><span class="line">和0比较是因为只要大于0，就可以相加构造最大子序和。如果小于0则相加为0，</span><br><span class="line">nums[i] += max(nums[i-1],0)其实是一边遍历一边计算最大序和.也就是说,首先判断i元素前面的子序列有没有用(是否大于0),如果有用的话,就将它们加到i元素上.所以,这个函数会修改原先的nums数组</span><br><span class="line">所以说,在迭代过程中,随着i的增大,只要前面的字序列大于0,i元素的值就会增大.最后使用max找到最大的元素就是我们所求的.</span><br></pre></td></tr></table></figure>

<p>经验:<br>==我们可以一边遍历数组一遍计算,原地修改数组的元素.这是一种阶段性求和思想.==</p>
<hr>
<h1 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/length-of-last-word/">58. 最后一个单词的长度</a></h1><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明：</strong>一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello World&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p>我的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s.find(<span class="string">&#x27; &#x27;</span>) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> s.split(<span class="string">&#x27; &#x27;</span>)[::-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> each:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">len</span>(each)</span><br><span class="line">        <span class="comment"># 当全是空格的时候</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果不使用内置函数,代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        tail = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 去掉末尾空格</span></span><br><span class="line">        <span class="keyword">while</span> tail &gt;= <span class="number">0</span> <span class="keyword">and</span> s[tail] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            tail -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 再计数,使用tail=0保证不会越界</span></span><br><span class="line">        <span class="keyword">while</span> tail &gt;= <span class="number">0</span> <span class="keyword">and</span> s[tail] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>

<p>经验:<br>==越界的判断总是由index&gt;=0来完成.==</p>
<hr>
<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a></h1><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<p>我的代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 先加上一</span></span><br><span class="line">        digits[-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        idx = <span class="built_in">len</span>(digits) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意这里idx没有等于0</span></span><br><span class="line">        <span class="keyword">while</span> idx &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> digits[idx] == <span class="number">10</span>:</span><br><span class="line">                digits[idx] = <span class="number">0</span></span><br><span class="line">                digits[idx-<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 尽早结束</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">            idx -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 判断是否要进位</span></span><br><span class="line">        <span class="keyword">if</span> digits[<span class="number">0</span>] == <span class="number">10</span>:</span><br><span class="line">            digits[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            digits.insert(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits   </span><br></pre></td></tr></table></figure>

<p>上面我的代码其实是歪门邪道,真正的做法是设置一个<strong>进位标识</strong>(表示是否进位):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># 进位标志，可以想象成‘一开始，个位的下一位进了一个1进来’</span></span><br><span class="line">        up = <span class="number">1</span> </span><br><span class="line">        i = <span class="number">0</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(digits):</span><br><span class="line">            <span class="comment">#当前值加进位 mod 10，就像小学生做加法一样</span></span><br><span class="line">            digits[-<span class="number">1</span>-i] = (digits[-<span class="number">1</span>-i] + up ) % <span class="number">10</span></span><br><span class="line">            <span class="comment"># 如果当前位变成0,说明发生了进位</span></span><br><span class="line">            <span class="keyword">if</span> digits[-<span class="number">1</span>-i] == <span class="number">0</span>:   </span><br><span class="line">                up = <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#如果到了最高位还有进位，那就在头部插入1</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="built_in">len</span>(digits) <span class="keyword">and</span> up == <span class="number">1</span>):    </span><br><span class="line">            digits.insert(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>

<p>经验:</p>
<ol>
<li><p>对于进位操作,一般都是:</p>
<ul>
<li>==使用进位标识==</li>
<li>==while跟踪进位标识==</li>
<li>==当前位的数值为(以前值+进位标识)%进制==</li>
</ul>
</li>
<li><p>倒序遍历数组有四种方法:</p>
<ul>
<li><p>```python<br>for each in alist[::-1]:</p>
<pre><code>each = ...
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```python</span><br><span class="line">  for idx in range(len(alist)-1,-1,-1):</span><br><span class="line">      alist[idx] = ...</span><br></pre></td></tr></table></figure></li>
<li><p>```python<br>idx = len(alist) - 1<br>while idx &gt;= 0:</p>
<pre><code>alist[idx] = ...
idx -= 1
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```python</span><br><span class="line">  idx = 0</span><br><span class="line">  while idx &lt; len(alist):</span><br><span class="line">      alist[-1-idx] = ...</span><br><span class="line">      idx += 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h1 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和</a></h1><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>

<p>如果使用内置函数int：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(<span class="built_in">int</span>(a,<span class="number">2</span>) + <span class="built_in">int</span>(b,<span class="number">2</span>))[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>

<p>要使用上面说的进位标志,代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="comment"># 首先补零:当a为1,b为111时,将a补为001</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">            b = <span class="string">&#x27;0&#x27;</span>*<span class="built_in">int</span>(<span class="built_in">len</span>(a)-<span class="built_in">len</span>(b)) + b</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = <span class="string">&#x27;0&#x27;</span>*<span class="built_in">int</span>(<span class="built_in">len</span>(b)-<span class="built_in">len</span>(a)) + a</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进位标志</span></span><br><span class="line">        up = <span class="number">0</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        idx = <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> idx &gt;= <span class="number">0</span>:</span><br><span class="line">            quo,remain = <span class="built_in">divmod</span>(<span class="built_in">int</span>(a[idx])+<span class="built_in">int</span>(b[idx])+up,<span class="number">2</span>)</span><br><span class="line">            res = <span class="built_in">str</span>(remain) + res</span><br><span class="line">            <span class="comment"># 当商大于0,表明发生了进位</span></span><br><span class="line">            <span class="keyword">if</span> quo &gt; <span class="number">0</span>:</span><br><span class="line">                up = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                up = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            idx -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当最后up等于1,表明位数发生变化,需要前面加入1</span></span><br><span class="line">        <span class="keyword">if</span> up == <span class="number">1</span>:</span><br><span class="line">            res = <span class="string">&#x27;1&#x27;</span> + res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>上面使用了quo,remain = divmod(int(a[idx])+int(b[idx])+up,2),但是注意到quo不是1就是0,和up是完全一样的值,所以可以直接使用up来代替quo:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="comment"># 首先补零:当a为1,b为111时,将a补为001</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">            b = <span class="string">&#x27;0&#x27;</span>*<span class="built_in">int</span>(<span class="built_in">len</span>(a)-<span class="built_in">len</span>(b)) + b</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = <span class="string">&#x27;0&#x27;</span>*<span class="built_in">int</span>(<span class="built_in">len</span>(b)-<span class="built_in">len</span>(a)) + a</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进位标志</span></span><br><span class="line">        up = <span class="number">0</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        idx = <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> idx &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 直接使用up</span></span><br><span class="line">            up,remain = <span class="built_in">divmod</span>(<span class="built_in">int</span>(a[idx])+<span class="built_in">int</span>(b[idx])+up,<span class="number">2</span>)</span><br><span class="line">            res = <span class="built_in">str</span>(remain) + res</span><br><span class="line">            idx -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 当最后up等于1,表明位数发生变化,需要前面加入1</span></span><br><span class="line">        <span class="keyword">if</span> up == <span class="number">1</span>:</span><br><span class="line">            res = <span class="string">&#x27;1&#x27;</span> + res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>经验:<br>使用while进位标志的方法:</p>
<ul>
<li>==quo,remain = divmod((string1[idx] + string2[idx] + up) ,进制)==,如果quo==1,就说明发生了进位.</li>
<li>当前值==s=(string1[idx] + string2[idx] + up) % 进制==,如果string[idx]+strings[idx]+up&gt;进制,就说明发生了进位</li>
</ul>
<hr>
<h1 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h1><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842...由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<p>当然可以使用遍历,但是复杂度高:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(x+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> each**<span class="number">2</span> &lt;= x &lt; (each+<span class="number">1</span>)**<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> each</span><br></pre></td></tr></table></figure>

<p>我的代码:使用二分法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 注意这里</span></span><br><span class="line">            <span class="keyword">if</span> mid**<span class="number">2</span> &lt;= x &lt;= (mid+<span class="number">1</span>)**<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (mid+<span class="number">1</span>)**<span class="number">2</span> == x:</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mid**<span class="number">2</span> &lt; x:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mid**<span class="number">2</span> &gt; x:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure>

<p>经验:<br>在这里,二分法会分成三段.==除了节点外mid就会在这三段中==,如下:</p>
<ol>
<li>BC段:对应第9行代码的if</li>
<li>AB段:对应第14行代码的if</li>
<li>CD段:对应第16行代码的if</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">　　A --&gt; B;</span><br><span class="line">　　B --&gt; C;</span><br><span class="line">　　C --&gt; D;</span><br></pre></td></tr></table></figure>

<p>一般来说,会==优先处理中间段(BC),BC长度固定为1,并且BC段会包含两个端点==,这样就能有效的防止low = mid + 1,high = mid - 1超出界限.</p>
<p>回顾地35题(搜索插入顺序)也是二分法,因为数组元素之间的距离就是为1,所以我们不必担心low = mid + 1,high = mid - 1会超出界限.</p>
<hr>
<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p>设$x​$为1阶的数量,$y​$为2阶的数量,$n​$为总阶数.<br>所以  $x+2y=n​$<br>得到  $\frac{x}{2} + y=\frac{n}{2}​$<br>得到  $y&lt;\frac{n}{2}​$</p>
<p>我的思路:</p>
<ol>
<li>因为一阶的数量为$x$,二阶的数量为$y$,所以数量和为$x+y$,即$n-y​$</li>
<li>题目可以演变成:<br>$y=[1,\frac{n}{2}]$,在$n-y$个空箱子中,放入$y$个小球(剩下的都是$x$),问有多少种方案.<br>即$y=[1,\frac{n}{2}]$,把所有$y$情况下的$C_{n-y}^{y}$相加</li>
<li>因为当$y=0​$的时候,只有一种方案,所以总数量要加1</li>
</ol>
<p>我的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 阶乘</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fact</span>(<span class="params">self,n</span>):</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            res *= each</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment"># 组合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combo</span>(<span class="params">self,m,n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(self.fact(n)/(self.fact(m)*self.fact(n-m)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意y从从1开始,当y=0的时候只有一种情况,所以最后的res加一</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            res += self.combo(y,n-y)</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>其实如果多列几项的话,就可以看出规律了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一阶楼梯：1</span><br><span class="line">两阶楼梯：2</span><br><span class="line">三阶楼梯：3</span><br><span class="line">四阶楼梯：5</span><br><span class="line">五阶楼梯：8</span><br><span class="line">六阶楼梯：13</span><br></pre></td></tr></table></figure>

<p>实际就是一个缺少第一项的斐波那契数列,具体思路:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n个台阶，一开始可以爬 1 步，也可以爬 2 步，那么n个台阶爬楼的爬楼方法就等于一开始爬1步的方法数 + 一开始爬2步的方法数，这样我们就只需要计算n-1个台阶的方法数和n-2个台阶方法数</span><br></pre></td></tr></table></figure>

<p>所以可以这么写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 设置存缓</span></span><br><span class="line"><span class="meta">    @lru_cache(<span class="params"><span class="number">10</span>**<span class="number">8</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.climbStairs(n - <span class="number">1</span>) + self.climbStairs(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以手动设置存缓:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        cache[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        cache[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            cache[i] = cache[i-<span class="number">1</span>] + cache[i-<span class="number">2</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> cache[i]</span><br></pre></td></tr></table></figure>

<p>上面的抖机灵算法,其实是一个<strong>动态规划</strong>问题,<br>动态规划是解决下面这些性质类问题的技术： </p>
<ol>
<li>==一个问题可以通过更小子问题的解决方法来解决==（即问题的最优解 包含了其子问题的最优解，也就是<strong>最优子结构性质</strong>）。 </li>
<li>有些子问题的解可能需要计算多次（也就是<strong>子问题重叠性质</strong>）。 </li>
<li>子问题的解存储在一张表格里，这样每个子问题只用计算一次。 </li>
<li>需要额外的空间以节省时间。</li>
</ol>
<hr>
<h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h1><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<p>链表的定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>我写的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">		<span class="keyword">elif</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">			<span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">		dummy = pre = head</span><br><span class="line">		after = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> after.<span class="built_in">next</span>:</span><br><span class="line">			<span class="keyword">if</span> pre.val == after.val:</span><br><span class="line">				pre.<span class="built_in">next</span> = after.<span class="built_in">next</span></span><br><span class="line">				after = pre.<span class="built_in">next</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				pre = after</span><br><span class="line">				after = after.<span class="built_in">next</span></span><br><span class="line">		<span class="keyword">if</span> pre.val == after.val:</span><br><span class="line">			pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">		<span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>

<p>其实after不是必须的,可以使用pre.next代替,修改之后代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> head) <span class="keyword">or</span> (<span class="keyword">not</span> head.<span class="built_in">next</span>):</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        dummy = pre = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pre.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> pre.val == pre.<span class="built_in">next</span>.val:</span><br><span class="line">                pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pre.val == pre.<span class="built_in">next</span>.val:</span><br><span class="line">            pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>

<p>上面代码分类太多了,应该如下使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        c = head</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">None</span> <span class="keyword">and</span> head.<span class="built_in">next</span>!=<span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span>.val == head.val:</span><br><span class="line">                head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>

<p>比较两种方法,得出经验:<br>==在while中不要使用pre.next.next,改为while(pre!=None and pre.next!=None)==</p>
<hr>
<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h1><p>给定两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使得 <em>num1</em> 成为一个有序数组。</p>
<p><strong>说明:</strong></p>
<ul>
<li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li>
<li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="comment"># while的功能就是将两个列表的最大值从后往前拍</span></span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">and</span> m:</span><br><span class="line">            <span class="keyword">if</span> nums2[n-<span class="number">1</span>] &gt;= nums1[m-<span class="number">1</span>]:</span><br><span class="line">                nums1[n+m-<span class="number">1</span>] = nums2[n-<span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[n+m-<span class="number">1</span>] = nums1[m-<span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># for的功能就是将num2剩余部分的元素从后往前放进num1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nums1[i] = nums2[i]</span><br></pre></td></tr></table></figure>
<p>同样的逻辑,上面代码可以修改为两个while:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,num1,m,num2,n</span>):</span></span><br><span class="line">        p = m + n -<span class="number">1</span></span><br><span class="line">        m =  m- <span class="number">1</span></span><br><span class="line">        n  = n - <span class="number">1</span></span><br><span class="line">       <span class="comment"># 这个while的功能就是把两个数组的最大值放在众多零的位置 </span></span><br><span class="line">        <span class="keyword">while</span>(m&gt;=<span class="number">0</span> <span class="keyword">and</span> n &gt;=<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span>(num1[m] &gt; num2[n]):</span><br><span class="line">                num1[p] = num1[m]</span><br><span class="line">                m = m -<span class="number">1</span></span><br><span class="line">                p = p-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num1[p] = num2[n]</span><br><span class="line">                n = n -<span class="number">1</span></span><br><span class="line">                p = p-<span class="number">1</span></span><br><span class="line">        <span class="comment"># 就是把nums2剩余的元素放到nums1上</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">0</span>):</span><br><span class="line">            num1[p] = num2[n]</span><br><span class="line">            n = n -<span class="number">1</span></span><br><span class="line">            p = p-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>将两个while合起来,可以得到最终代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        merge_index = m + n - <span class="number">1</span></span><br><span class="line">        index1 = m - <span class="number">1</span></span><br><span class="line">        index2 = n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> index1 &gt;= <span class="number">0</span> <span class="keyword">or</span> index2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 当nums1被消耗完,就使用nums2的元素填充</span></span><br><span class="line">            <span class="keyword">if</span> index1 &lt; <span class="number">0</span>:</span><br><span class="line">                nums1[merge_index] = nums2[index2]</span><br><span class="line">                index2 = index2 - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 当nums2被消耗完,就使用nums1的元素填充</span></span><br><span class="line">            <span class="keyword">elif</span> index2 &lt; <span class="number">0</span>:</span><br><span class="line">                nums1[merge_index] = nums1[index1]</span><br><span class="line">                index1 = index1 - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 若都没消耗完,则将两者中的最大值填充列表</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[index1] &gt; nums2[index2]:</span><br><span class="line">                nums1[merge_index] = nums1[index1]</span><br><span class="line">                index1 = index1 - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[merge_index] = nums2[index2]</span><br><span class="line">                index2 = index2 - <span class="number">1</span></span><br><span class="line">            merge_index = merge_index - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这其实是==归并排序的最后一并==.<br>归并排序:将列表进行两两分组，每组之间进行排序，每小组排序完成后，再见这些有序的小组之间进行合并排序，知道最后合并完成。</p>
<p>这里顺便回顾一下归并排序:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">alist</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Splitting &quot;</span>,alist)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(alist)&gt;<span class="number">1</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(alist)//<span class="number">2</span></span><br><span class="line">        lefthalf = alist[:mid]</span><br><span class="line">        righthalf = alist[mid:]</span><br><span class="line"></span><br><span class="line">        mergeSort(lefthalf)</span><br><span class="line">        mergeSort(righthalf)</span><br><span class="line"></span><br><span class="line">        i=j=k=<span class="number">0</span></span><br><span class="line"><span class="comment"># 将两个较小的列表组合成一个较大的列表</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(lefthalf) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(righthalf):</span><br><span class="line">            <span class="keyword">if</span> lefthalf[i] &lt; righthalf[j]:</span><br><span class="line">                alist[k]=lefthalf[i]</span><br><span class="line">                i=i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                alist[k]=righthalf[j]</span><br><span class="line">                j=j+<span class="number">1</span></span><br><span class="line">            k=k+<span class="number">1</span></span><br><span class="line"><span class="comment"># 经过上面的处理,只剩下最后一个元素没有处理.由下面的两个while中的一个来处理</span></span><br><span class="line"><span class="comment"># alist从[77,31,44,55,20]变成[20,31,44,55,20](77丢了)</span></span><br><span class="line"><span class="comment"># 77存在于lefthalf或者righthalf中</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(lefthalf):</span><br><span class="line">            alist[k]=lefthalf[i]</span><br><span class="line">            i=i+<span class="number">1</span></span><br><span class="line">            k=k+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(righthalf):</span><br><span class="line">            alist[k]=righthalf[j]</span><br><span class="line">            j=j+<span class="number">1</span></span><br><span class="line">            k=k+<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Merging &quot;</span>,alist)</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">mergeSort(alist)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<p>结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Splitting  [54, 26, 93, 17, 77, 31, 44, 55, 20]</span><br><span class="line">Splitting  [54, 26, 93, 17]</span><br><span class="line">Splitting  [54, 26]</span><br><span class="line">Splitting  [54]</span><br><span class="line">Merging  [54]</span><br><span class="line">Splitting  [26]</span><br><span class="line">Merging  [26]</span><br><span class="line">Merging  [26, 54]</span><br><span class="line">Splitting  [93, 17]</span><br><span class="line">Splitting  [93]</span><br><span class="line">Merging  [93]</span><br><span class="line">Splitting  [17]</span><br><span class="line">Merging  [17]</span><br><span class="line">Merging  [17, 93]</span><br><span class="line">Merging  [17, 26, 54, 93]</span><br><span class="line">Splitting  [77, 31, 44, 55, 20]</span><br><span class="line">Splitting  [77, 31]</span><br><span class="line">Splitting  [77]</span><br><span class="line">Merging  [77]</span><br><span class="line">Splitting  [31]</span><br><span class="line">Merging  [31]</span><br><span class="line">Merging  [31, 77]</span><br><span class="line">Splitting  [44, 55, 20]</span><br><span class="line">Splitting  [44]</span><br><span class="line">Merging  [44]</span><br><span class="line">Splitting  [55, 20]</span><br><span class="line">Splitting  [55]</span><br><span class="line">Merging  [55]</span><br><span class="line">Splitting  [20]</span><br><span class="line">Merging  [20]</span><br><span class="line">Merging  [20, 55]</span><br><span class="line">Merging  [20, 44, 55]</span><br><span class="line">Merging  [20, 31, 44, 55, 77]</span><br><span class="line">Merging  [17, 20, 26, 31, 44, 54, 55, 77, 93]</span><br><span class="line">[17, 20, 26, 31, 44, 54, 55, 77, 93]</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h1><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>我的代码(是错误的):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self,node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="keyword">return</span> self.preorder(node.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> self.preorder(node.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># 特殊情况,p或q不存在</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">if</span> p == q:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">            <span class="keyword">return</span> self.preorder(p) == self.preorder(q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>上面代码在输入为[10,5,15],[10,5,null,null,15]的时候,是错的.程序会返回True而不是False.<br>问题出在29行,因为self.preorder(p)最终只会返回一个值,同理,self.preorder(q)也是返回一个值.也就是说最终只会比较一次.</p>
<p>经验:==如果需要递归比较,那么就该递归参数必须含有这两个参数,不能在递归函数外比较==</p>
<p>递归的基线条件:</p>
<ol>
<li>两个节点都为空</li>
<li>一个为空，另一个非空</li>
<li>都为非空，但是值不相等</li>
</ol>
<p>递归条件:都为非空，但是值相等.</p>
<p>输入的明显是前序遍历,代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        <span class="comment"># 如果不存在p,q(基线条件1)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果pq都存在(递归条件)</span></span><br><span class="line">        <span class="keyword">elif</span> p <span class="keyword">and</span> q :</span><br><span class="line">            <span class="comment"># 如果子树的根节点相同,就判断左右子树是否相同</span></span><br><span class="line">            <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">                <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># pq其中一者存在(基线条件2)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>注意第10行:==需要使用and,左边判断两棵树的左子树是否相等,右边判断右子树是否相等==</p>
<p>可以更加精简:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">and</span> q <span class="keyword">and</span> p.val==q.val:</span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br><span class="line">        <span class="comment"># 如果p不存在,则判断q是否存在:q不存在则True,存在则False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> q</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<p>==其实对称就是左子树等于右子树==,这里可以稍微修改一下100题的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># 判断是否相等</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSame</span>(<span class="params">p,q</span>):</span></span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">and</span> q <span class="keyword">and</span> p.val==q.val:</span><br><span class="line">                <span class="comment"># 这里判断左子树等于右子树</span></span><br><span class="line">                <span class="keyword">return</span> isSame(p.left,q.right) <span class="keyword">and</span> isSame(p.right,q.left)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">not</span> q</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 判断root的左子树是否等于右子树</span></span><br><span class="line">        <span class="keyword">return</span> isSame(root.left,root.right)</span><br></pre></td></tr></table></figure>

<p>同理,可以设计一个isMorror函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.isMirror(root,root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMirror</span>(<span class="params">self,t1,t2</span>):</span></span><br><span class="line">    	<span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> t1 <span class="keyword">or</span> <span class="keyword">not</span> t2:</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 左子树等于右子树</span></span><br><span class="line">        <span class="keyword">return</span> t1.val==t2.val <span class="keyword">and</span> self.isMirror(t1.right,t2.left) <span class="keyword">and</span> self.isMirror(t1.left,t2.right)</span><br></pre></td></tr></table></figure>

<p>上面都是递归实现,可以使用中序遍历实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.is_mirror(root.left, root.right)</span><br><span class="line">        <span class="comment"># 空树为真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_mirror</span>(<span class="params">self, l_root, r_root</span>):</span></span><br><span class="line">        <span class="comment"># 镜像的节点都不为空，中序遍历，判断镜像的节点值是否相等</span></span><br><span class="line">        <span class="keyword">if</span> l_root <span class="keyword">and</span> r_root:</span><br><span class="line">            <span class="keyword">if</span> self.is_mirror(l_root.left, r_root.right):</span><br><span class="line">                <span class="keyword">if</span> l_root.val == r_root.val:</span><br><span class="line">                    <span class="keyword">return</span> self.is_mirror(l_root.right, r_root.left)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 镜像的节点至少一个为空，返回两个节点是否相等</span></span><br><span class="line">        <span class="keyword">return</span> l_root == r_root</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        lep = self.maxDepth(root.left)</span><br><span class="line">        rep = self.maxDepth(root.right)</span><br><span class="line">        <span class="comment"># 左右节点数,还有加一个根节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lep,rep)+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>经验:</p>
<ol>
<li>==使用递归的时候一定要搞清楚这个递归函数是干什么的,不然就不知道什么时候使用这个函数==.(就像对称二叉树题目的is_mirror函数和相同的树题目中的isSameTree函数)</li>
<li>树递归的基线条件一般是==到达叶节点==</li>
<li>==在递归中,需要需要计数,那么就计数的变量return出来.就是说:递归函数求什么就需要return出什么==</li>
<li>(重要)==使用递归时,不要管多层的递归栈,只要满足递归条件,只考虑一层栈即可.==</li>
</ol>
<p>总结使用递归时的思路:</p>
<ol>
<li>确定基线条件和递归条件</li>
<li>每次递归都要缩小问题的的规模,不断向基线条件靠拢</li>
<li>不过递归的多深,迟早是要return的</li>
<li>(重要)==使用递归时,不要管多层的递归栈,只要满足递归条件,只考虑一层栈即可,使用递归的时候一定要搞清楚这个递归函数是干什么的,不然就不知道什么时候使用这个函数.==</li>
<li>==在递归中,需要需要计数,那么就计数的变量return出来.==</li>
</ol>
<p>带着这五个点来看上面的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="comment"># 1.基线条件:最后一次传入的root变量为None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 1.递归条件:当节点有左右子树</span></span><br><span class="line">        <span class="comment"># 2.通过不断深入子树,不断逼近基线条件(传入的root为None)</span></span><br><span class="line">        <span class="comment"># 4.这个函数是用来计算路径长度的,既然树可以用,那么子树也可以用</span></span><br><span class="line">        lep = self.maxDepth(root.left)</span><br><span class="line">        rep = self.maxDepth(root.right)</span><br><span class="line">        <span class="comment"># 3.不管递归多深,上面lep的值就是下面return的东西</span></span><br><span class="line">        <span class="comment"># 5.我们需要计量节点数,那么就需要在return出这些东西</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(lep,rep)+<span class="number">1</span></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107. 二叉树的层次遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a></h1><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其自底向上的层次遍历为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要思路:将每层的节点倒序填充进res,然后将下一次要迭代的节点放入stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span>   </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 使用stack存放每层节点</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="comment"># 将来会倒序填充res</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 使用tmp存放每层节点的左右子节点</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="comment"># res_each用于存放每一层的元素</span></span><br><span class="line">            res_each = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="comment"># 将节点的值放入res_each中</span></span><br><span class="line">                res_each.append(i.val)</span><br><span class="line">                <span class="keyword">if</span> i.left:</span><br><span class="line">                    tmp.append(i.left)</span><br><span class="line">                <span class="keyword">if</span> i.right:</span><br><span class="line">                    tmp.append(i.right)</span><br><span class="line">            <span class="comment"># 将下次要迭代的节点放入stack</span></span><br><span class="line">            stack = tmp</span><br><span class="line">            <span class="comment"># 每次都在res头部添加</span></span><br><span class="line">            res.insert(<span class="number">0</span>,res_each)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>也可以使用队列:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 队列q存放将要迭代的节点,res存放每层的左右节点,List存放正序的结果,最后需要倒序输出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.levelOrder(root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self,root</span>):</span></span><br><span class="line">        q = deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="type">List</span> = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                item = q.popleft()</span><br><span class="line">                res.append(item.val)</span><br><span class="line">                <span class="keyword">if</span> item.left:</span><br><span class="line">                    q.append(item.left)</span><br><span class="line">                <span class="keyword">if</span> item.right:</span><br><span class="line">                    q.append(item.right)</span><br><span class="line">            <span class="type">List</span>.append(res)</span><br><span class="line">        <span class="comment"># 将List倒序输出</span></span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">while</span>(<span class="type">List</span>):</span><br><span class="line">            output.append(<span class="type">List</span>.pop())</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二分后递归(因为二分的中点就是根节点)</span></span><br><span class="line">        mid = <span class="built_in">int</span>(<span class="built_in">len</span>(nums)//<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 得到根节点</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[mid+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>经验:</p>
<ol>
<li>==列表的基线条件不仅可以用for each in alist,还可以不断的二分来获取,这时候的递归参数基本就是alist[:mid]和alist[:mid+1]==</li>
<li>涉及列表和树,基本不会使用for each in alist.因为需要root = TreeNode来创建节点.</li>
</ol>
<hr>
<h1 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回 <code>true</code> 。</p>
<p><strong>示例 2:</strong></p>
<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>返回 <code>false</code> 。</p>
<p>代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(self.countfloor(root.left)-self.countfloor(root.right))&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">    <span class="comment">#求二叉树及其子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countfloor</span>(<span class="params">self,root</span>):</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 重要</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(self.countfloor(root.left),self.countfloor(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我的代码(是错误的):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_height</span>(<span class="params">self,root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        a = self.get_height(root.left) + <span class="number">1</span></span><br><span class="line">        b = self.get_height(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a,b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        a = self.get_height(root.left)</span><br><span class="line">        b = self.get_height(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(a-b) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 这里只判断了根节点,没有判断其他节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 这里是错误的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>上面正确的代码和我的代码最大的区别就是最后的return:<br>当某个节点平时,我们可以考虑这个节点的左节点和右节点,而不是直接return.</p>
<p>经验:==需要对整个树的节点都使用递归函数,那么就需要对Node.left和Node.right使用该递归函数==</p>
<hr>
<h1 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h1><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最小深度  2.  </p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        a = self.minDepth(root.left)</span><br><span class="line">        b = self.minDepth(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果是叶节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">or</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(a,b)</span><br><span class="line">        <span class="comment"># 如果不是叶节点(因为叶节点肯定会return 0,所以不能使用min)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(a,b)</span><br></pre></td></tr></table></figure>

<p>经验:==在递归中,判断叶节点的方式有两种==</p>
<ol>
<li><code>if not root.left or not root.right:</code></li>
<li><code>if not root</code></li>
</ol>
<hr>
<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h1><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>

<p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root, <span class="built_in">sum</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 只有一个根节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span> == root.val <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 沿着各个路径查找，每次经过一个节点，sum就减去当前节点的val值</span></span><br><span class="line">        <span class="keyword">if</span> self.hasPathSum(root.left,<span class="built_in">sum</span>-root.val) <span class="keyword">or</span> self.hasPathSum(root.right,<span class="built_in">sum</span>-root.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>这里的递归条件是==节点的左子树或者右子树的路径和是sum-root.val==</p>
<p>经验:</p>
<ol>
<li><p>==递归里的加法我们可以让参数递减来实现==</p>
</li>
<li><p>我们在写递归代码的时候一定要注意<strong>描述出递归条件</strong></p>
</li>
</ol>
<hr>
<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></h1><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p>
<p><img src="/images/PascalTriangleAnimated2.gif" alt="img"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triangle</span>(<span class="params">self, numRows</span>):</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">elif</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = self.triangle(numRows-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>] + [a[n]+a[n+<span class="number">1</span>] <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>)] + [<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self,numRows</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [self.triangle(num) <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,numRows+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure>

<p>经验:==一旦求了通项函数,要求遍历的值.这时需要果断新建一个函数进行遍历==<br>如当triangle传入5时会输出[1,4,6,4,1],但是要求输出[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]],这时需要果断新建一个函数进行遍历</p>
<p>当然可以使用循环来解决:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, numRows</span>):</span></span><br><span class="line">        <span class="comment"># pre是上一行,now是当前行</span></span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numRows):</span><br><span class="line">                now = [<span class="number">1</span>]*(i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i):</span><br><span class="line">                        now[n] = pre[n-<span class="number">1</span>]+pre[n]</span><br><span class="line">                result += [now]</span><br><span class="line">                pre = now</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h1><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<p><img src="/images/7d98fb04-PascalTriangleAnimated2.gif" alt="img"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p>
<p>我的代码:刚刚已经求出通项函数了,现在直接套用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span>(<span class="params">self, rowIndex: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.triangle(rowIndex+<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triangle</span>(<span class="params">self, rowIndex: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> rowIndex == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = self.triangle(rowIndex-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>] + [a[n]+a[n+<span class="number">1</span>] <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>)] + [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>也可以使用循环:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span>(<span class="params">self, rowIndex</span>):</span></span><br><span class="line">        <span class="comment"># 长度为K</span></span><br><span class="line">        re = [<span class="number">1</span>]+[<span class="number">0</span>]*(rowIndex)</span><br><span class="line">        <span class="comment"># 从第1行开始（从0开始数）计算每一行的参数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,rowIndex+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 当前行的最后一个位置填1</span></span><br><span class="line">            re[i] = <span class="number">1</span>                   </span><br><span class="line">            <span class="comment"># 逆序修改当前行的值，不包括首尾</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>): </span><br><span class="line">                <span class="comment"># 更新j位置上的数为上一行的j-1位置与j位置的数的和</span></span><br><span class="line">                re[j] += re[j-<span class="number">1</span>]        </span><br><span class="line">        <span class="keyword">return</span> re</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p>我的代码:和53题”求最大子序列和”一样的思路.是一个动态规划问题:<br><strong>前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 购买的价格</span></span><br><span class="line">        buy = prices[<span class="number">0</span>]</span><br><span class="line">        idx = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> idx &lt;= <span class="built_in">len</span>(prices)-<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 发现某天的价格更低,于是在那天购买</span></span><br><span class="line">            <span class="keyword">if</span> buy - prices[idx] &gt; <span class="number">0</span>:</span><br><span class="line">                buy = prices[idx]</span><br><span class="line">            <span class="comment"># 发现某天的收益更高,于是在那天卖出</span></span><br><span class="line">            <span class="keyword">elif</span> -(buy - prices[idx]) &gt; res:</span><br><span class="line">                res = -(buy - prices[idx])</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>真正的动态规划写法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        min_p = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 求出前i天最低价</span></span><br><span class="line">            min_p = <span class="built_in">min</span>(min_p, prices[i])</span><br><span class="line">            <span class="comment"># 前i天的最高收益</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - min_p)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>对比上面两种代码,其实是一致的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发现某天的价格更低,于是在那天购买</span></span><br><span class="line"><span class="keyword">if</span> buy - prices[idx] &gt; <span class="number">0</span>:</span><br><span class="line">    buy = prices[idx]</span><br><span class="line"><span class="comment"># 发现某天的收益更高,于是在那天卖出</span></span><br><span class="line"><span class="keyword">elif</span> -(buy - prices[idx]) &gt; res:</span><br><span class="line">    res = -(buy - prices[idx])</span><br><span class="line">    </span><br><span class="line"><span class="comment">### 上面代码等同于下面代码:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求出前i天最低价</span></span><br><span class="line">min_p = <span class="built_in">min</span>(min_p, prices[i])</span><br><span class="line"><span class="comment"># 前i天的最高收益</span></span><br><span class="line">res = <span class="built_in">max</span>(res, prices[i] - min_p)</span><br></pre></td></tr></table></figure>

<p>回忆53题”求最大子序列和”的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        tot = <span class="number">0</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        idx = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> idx &lt;= <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">            tot += nums[idx]</span><br><span class="line">            res = <span class="built_in">max</span>(res,tot)</span><br><span class="line">            tot = <span class="built_in">max</span>(tot,<span class="number">0</span>)</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">   </span><br><span class="line"><span class="comment">### 上面代码等同于下面代码:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 阶段性求和</span></span><br><span class="line">        tot = <span class="number">0</span></span><br><span class="line">        result = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            tot += num</span><br><span class="line">            <span class="keyword">if</span> tot &gt; result:</span><br><span class="line">                result = tot</span><br><span class="line">            <span class="comment"># 一旦tot为负,就清零</span></span><br><span class="line">            <span class="keyword">if</span> tot &lt; <span class="number">0</span>:</span><br><span class="line">                tot = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><code>[7, 1, 5, 6]</code> 第二天买入，第四天卖出，收益最大（6-1），所以**一般人可能会想，怎么判断不是第三天就卖出了呢? **这里就把问题复杂化了.<br>根据题目的意思，==当天卖出以后，当天还可以买入==，所以其实可以第三天卖出，第三天买入，第四天又卖出（（5-1）+ （6-5） === 6 - 1）。所以算法可以直接简化为只要今天比昨天大，就卖出。</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 贪心法，只要后一天比前一天股价高就卖</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> day <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)-<span class="number">1</span>):</span><br><span class="line">            differ = prices[day+<span class="number">1</span>] - prices[day]</span><br><span class="line">            <span class="keyword">if</span> differ &gt; <span class="number">0</span>:</span><br><span class="line">                profit += differ</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>

<p>还有一种非常装逼的写法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(b-a <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">zip</span>(prices,prices[<span class="number">1</span>:]) <span class="keyword">if</span> b&gt;a)</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        s = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">filter</span>(<span class="built_in">str</span>.isalnum,s)).lower()</span><br><span class="line">        <span class="keyword">return</span> s==s[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>Python isalnum() 方法检测字符串是否由字母和数字组成。</p>
<p>类似函数:</p>
<ol>
<li>str.isalnum() 函数:判断该字符串是否只是字母数字组合</li>
<li>str.isalpha() 函数:判断该字符串是否是字母组合</li>
<li>str.isdigit() 函数:判断该字符串是否只包含数字</li>
<li>str.islower() 函数:判断该字符串中是否只是小写字母</li>
<li>str.isupper() 函数:检查该字符串中的单词是否首字母都大写</li>
<li>str.isspace() 函数:判断该字符串是否只包含空格</li>
<li>str.istitle() 函数:检查该字符串中的单词是否首字母都大写</li>
</ol>
<p>当然,可以使用双指针:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        s_length = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> s_length &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span>              <span class="comment"># 左指针</span></span><br><span class="line">        j = s_length - <span class="number">1</span>   <span class="comment"># 右指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="comment"># 遇到非数字或字母</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[i].isalnum() <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[j].isalnum() <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s[i].lower() != s[j].lower():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>经验:==对于类似于回文问题,不要使用二分法,而是使用双指针==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuanzhizhen</span>(<span class="params">string</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(string) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> string[left] != string[right]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shuanzhizhen(<span class="string">&#x27;123456654321&#x27;</span>)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h1><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 使用异或</span></span><br><span class="line">            a = a ^ num</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>异或复习:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b</span><br><span class="line">任何数于0异或为任何数 0 ^ n =&gt; n</span><br><span class="line">相同的数异或为0: n ^ n =&gt; 0</span><br><span class="line">所以,对于var a = [2,3,2,4,4]:</span><br><span class="line">2 ^ 3 ^ 2 ^ 4 ^ 4等价于 2 ^ 2 ^ 4 ^ 4 ^ 3 =&gt; 0 ^ 0 ^3 =&gt; 3</span><br></pre></td></tr></table></figure>

<p>还有讨巧的方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">sum</span>(<span class="built_in">set</span>(nums)) - <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nums.count(i) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="/images/circularlinkedlist.png" alt="img"></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><img src="/images/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><img src="/images/circularlinkedlist_test3.png" alt="img"></p>
<p><strong>进阶：</strong></p>
<p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p>
<p>有一种调皮的算法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bjfuvth15925作为标记。只要访问过的结点，都用bjfuvth15925标记一下，</span></span><br><span class="line"><span class="comment"># 一旦这个标记再次出现，也就意味这个结点被访问过，说明链表循环。</span></span><br><span class="line"><span class="comment"># 缺点就是，如果这个链表中的某个结点值（val）正好等于bjfuvth15925，就会误判。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val == <span class="string">&#x27;bjfuvth15925&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head.val = <span class="string">&#x27;bjfuvth15925&#x27;</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>最准确的做法:<strong>使用快慢双指针</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快慢双指针:快指针多跑一步，如有环总会相撞</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="comment"># 参数合法性校验</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="comment"># 如果有环,fast.next和fast.next.next总是存在</span></span><br><span class="line">        <span class="comment"># 如果无环,fast.next会先到终点(先为空),因为惰性运算,保证fast.next.next不会运行</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 此时fast多跑了一圈</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>快慢双指针的内存就是$$O(1)$$</p>
<p>用一个更好理解的版本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        slow = fast = head </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast:</span><br><span class="line">            <span class="keyword">if</span> slow.<span class="built_in">next</span>:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># fast先走一步</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> fast:</span><br><span class="line">                fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>可以使用地址法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        id_list = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">id</span>(head) <span class="keyword">in</span> id_list:</span><br><span class="line">                id_list.append(<span class="built_in">id</span>(head))</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>经验:==对于环的判断,要使用快慢指针==</p>
<hr>
<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h1><p>设计一个支持 push，pop，top 操作，并能在<strong>常数时间</strong>内检索到最小元素的栈。</p>
<ul>
<li>push(x) – 将元素 x 推入栈中。</li>
<li>pop() – 删除栈顶的元素。</li>
<li>top() – 获取栈顶元素。</li>
<li>getMin() – 检索栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p>就是普通的stack多了一个getMin()函数.</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="comment"># 使用一个列表维护stack的最小值</span></span><br><span class="line">        self.minstack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="comment"># 将最小的放在后面</span></span><br><span class="line">        <span class="keyword">if</span> self.minstack == [] <span class="keyword">or</span> x &lt;= self.minstack[-<span class="number">1</span>]:</span><br><span class="line">            self.minstack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">if</span> self.stack[-<span class="number">1</span>] == self.minstack[-<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 如果弹出是最小值,那么minstack也要弹出,为下一个最小元素让位</span></span><br><span class="line">                self.minstack.pop()</span><br><span class="line">            self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.minstack:            </span><br><span class="line">            <span class="keyword">return</span> self.minstack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">minstack = MinStack()</span><br><span class="line">minstack.push(<span class="number">5</span>)</span><br><span class="line">minstack.push(<span class="number">3</span>)</span><br><span class="line">minstack.push(<span class="number">4</span>)</span><br><span class="line">minstack.push(<span class="number">1</span>)</span><br><span class="line">minstack.push(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(minstack.stack,minstack.minstack)  <span class="comment"># [5, 3, 4, 1, 2] [5, 3, 1]</span></span><br><span class="line"><span class="built_in">print</span>(minstack.getMin())  <span class="comment"># 1</span></span><br><span class="line">minstack.pop()</span><br><span class="line"><span class="built_in">print</span>(minstack.getMin())  <span class="comment"># 1</span></span><br><span class="line">minstack.pop()</span><br><span class="line"><span class="built_in">print</span>(minstack.getMin())  <span class="comment"># 3</span></span><br><span class="line">minstack.pop()</span><br><span class="line"><span class="built_in">print</span>(minstack.getMin())  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p>注意上面代码的10,11行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.minstack == [] <span class="keyword">or</span> x &lt;= self.minstack[-<span class="number">1</span>]:</span><br><span class="line">    self.minstack.append(x)</span><br></pre></td></tr></table></figure>

<p><strong>minstack.minstack并没有维护整个排好序的stack,minstack.minstack只是维护了降序的stack</strong>:<br><code>x &lt;= self.minstack[-1]</code>保证了最小值一定在最后,<code>self.minstack == []</code>保证了stack栈底元素一定在最前.</p>
<p>这样就导致了<strong>在stack中,比minstack最小元素还要小的元素一定排在前面,会更早的被pop出来</strong>.eg:上面测试中,4并没有在minstack中.但是在stack中4排在3的前面,也就是说==如果要pop出3一定要先pop出4==</p>
<p>经验:==以空间换时间的做法就是维护一个数据来存放必要的东西==</p>
<hr>
<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="/images/160_statement.png" alt="img"></a></p>
<p>在节点 c1 开始相交。</p>
<p><strong>示例 1：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="/images/160_example_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="/images/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="/images/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>如果两个链表没有交点，返回 <code>null</code>.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>
</ul>
<p>最简单的想法就是使用地址法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        id_list = []</span><br><span class="line">        <span class="keyword">while</span> headA:</span><br><span class="line">            id_list.append(<span class="built_in">id</span>(headA))</span><br><span class="line">            headA = headA.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> headB:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">id</span>(headB) <span class="keyword">in</span> id_list:</span><br><span class="line">                <span class="keyword">return</span> headB</span><br><span class="line">            headB = headB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>链表相交使用==双指针法==:<br><strong>定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点</strong>(这移动中恰好抹除了长度差) 两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度</p>
<p>理解:<br><img src="/images/80240968-160_statement.png" alt="img"></p>
<p>在相交前,<br>A链走的路径为a1–a2–c1–c2–c3–b1–b2–b3–c1;<br>B链走的路径为b1–b2–b3–c1–c2–c3–a1–a2–c1.<br>也就是说AB链都走遍了全部的节点,这样就抹除了长度差.</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        a, b = headA, headB</span><br><span class="line">        <span class="keyword">while</span> a != b:</span><br><span class="line">            a = a.<span class="built_in">next</span> <span class="keyword">if</span> a <span class="keyword">else</span> headB</span><br><span class="line">            b = b.<span class="built_in">next</span> <span class="keyword">if</span> b <span class="keyword">else</span> headA</span><br><span class="line">        <span class="comment"># 当两条链没有相交的时候,最终a和b都会变成None,从while出来,输出None</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>当然可以写的罗嗦一点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        p = headA</span><br><span class="line">        q = headB</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p != q <span class="keyword">and</span> flag &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">                p = headB</span><br><span class="line">                flag += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> q:</span><br><span class="line">                q = headA</span><br><span class="line">                flag += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> p == q:</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>还可以使用快慢指针:<br>==求出两个链表A和B的长度, 长链表先走|len(A)-len(B)|步, 然后同时遍历返回第一个公共节点.==</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        a = headA</span><br><span class="line">        b = headB</span><br><span class="line">        a_num = b_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> a:</span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">            a_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            b = b.<span class="built_in">next</span></span><br><span class="line">            b_num += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> a_num &gt;= b_num:</span><br><span class="line">            <span class="comment"># 计算|len(A)-len(B)|</span></span><br><span class="line">            gap = a_num - b_num</span><br><span class="line">            <span class="comment"># 长链表先走|len(A)-len(B)|步,</span></span><br><span class="line">            <span class="keyword">while</span> gap:</span><br><span class="line">                headA = headA.<span class="built_in">next</span></span><br><span class="line">                gap -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 同时遍历AB,返回第一个公共节点    </span></span><br><span class="line">            <span class="keyword">while</span> headA <span class="keyword">and</span> headB:</span><br><span class="line">                <span class="keyword">if</span> headA == headB:</span><br><span class="line">                    <span class="keyword">return</span> headA</span><br><span class="line">                headA = headA.<span class="built_in">next</span></span><br><span class="line">                headB = headB.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gap = b_num - a_num</span><br><span class="line">            <span class="keyword">while</span> gap:</span><br><span class="line">                headB = headB.<span class="built_in">next</span></span><br><span class="line">                gap -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> headA <span class="keyword">and</span> headB:</span><br><span class="line">                <span class="keyword">if</span> headA == headB:</span><br><span class="line">                    <span class="keyword">return</span> headA</span><br><span class="line">                headA = headA.<span class="built_in">next</span></span><br><span class="line">                headB = headB.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>相同的逻辑,上面的写法太罗嗦,下面的优雅很多:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        a,b = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        p,q = headA,headB</span><br><span class="line">        <span class="comment"># 计算长度,注意这里使用and(说明长链表的head还没消耗完)</span></span><br><span class="line">        <span class="keyword">while</span> headA <span class="keyword">and</span> headB:</span><br><span class="line">            headA = headA.<span class="built_in">next</span></span><br><span class="line">            headB = headB.<span class="built_in">next</span></span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 长链表先走|len(A)-len(B)|步</span></span><br><span class="line">        <span class="keyword">while</span> headA:</span><br><span class="line">            headA = headA.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> headB:</span><br><span class="line">            headB = headB.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 重新同时遍历</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p == q:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>

<p>经验:对于相交链表,有两种方式:</p>
<ol>
<li>==快慢指针==:求出两个链表A和B的长度, 长链表先走|len(A)-len(B)|步, 然后同时遍历返回第一个公共节点.</li>
<li>==指针追逐==:定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点.</li>
</ol>
<hr>
<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h1><p>给定一个已按照<strong>升序排列</strong>的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p>
<p><strong>说明:</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure>

<p>采用前后双指针法:<strong>小了往后走 大了往前走</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            cur = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> cur &lt; target:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur &gt; target:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cur == target:</span><br><span class="line">                <span class="keyword">return</span> left+<span class="number">1</span>,right+<span class="number">1</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel表列名称</a></h1><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p>例如，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;A&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 28</span><br><span class="line">输出: &quot;AB&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 701</span><br><span class="line">输出: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>

<p>  本质相当于26进制,<strong>转换前需减1</strong>,代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertToTitle</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 注意要减一</span></span><br><span class="line">        n,remain = <span class="built_in">divmod</span>(n-<span class="number">1</span>,<span class="number">26</span>)</span><br><span class="line">        <span class="comment"># chr(65)==&#x27;A&#x27;,使用n-1能从零开始算起</span></span><br><span class="line">        res = <span class="built_in">chr</span>(<span class="number">65</span> + remain) + res</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>也可以使用递归:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToTitle</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># 递归处理</span></span><br><span class="line">        <span class="keyword">if</span> (n-<span class="number">1</span>)//<span class="number">26</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">chr</span>( <span class="number">65</span> + (n-<span class="number">1</span>) % <span class="number">26</span> )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.convertToTitle( (n-<span class="number">1</span>)//<span class="number">26</span> ) + <span class="built_in">chr</span>(<span class="number">65</span> + (n-<span class="number">1</span>) % <span class="number">26</span>)</span><br></pre></td></tr></table></figure>

<p>经验:</p>
<ol>
<li>==对于禁止转化,注意要减一==</li>
<li> 对于数字转字母,注意不要使用字典去映射,直接使用chr函数.</li>
</ol>
<hr>
<h1 id="169-求众数"><a href="#169-求众数" class="headerlink" title="169. 求众数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169. 求众数</a></h1><p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>最简单的方式就是使用字典了:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[num] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key,val <span class="keyword">in</span> hashmap.items():</span><br><span class="line">            <span class="keyword">if</span> val &gt; <span class="built_in">len</span>(nums)//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure>

<p>更合适的做法是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的众数是指在数组中出现次数大于n/2的元素。</span></span><br><span class="line"><span class="comment"># 从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，</span></span><br><span class="line"><span class="comment"># 减到0就重新换个数开始计数，总能找到最多的那个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        cnt, ret = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                ret = num</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> num != ret:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>摩尔投票算法:<br>该算法用于解决寻找一个含有$n​$个元素的数列${an}​$中出现<strong>超过$\frac{1}{K}​$</strong>(即大于$\frac{n}{K}​$次)的元素（假设满足要求的元素存在）。满足要求的元素最多有$(k−1)​$个。</p>
<p>摩尔投票算法可以快速的计算出一个数组中出现次数过半的数即<strong>大多数（majority）</strong>，算法核心思想是<code>同加，异减</code></p>
<p>该方法的思想是众数一定比其他所有的数加起来的数量要多，就算是众数与其他每一个数相抵消，最后剩下来的也是众数。况且还有其他数之间的抵消，所以剩下来的一定是众数。</p>
<p>当K大于2的时候,代码会比较复杂:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        a, b, ca, cb = <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == a:</span><br><span class="line">                ca += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num  == b:</span><br><span class="line">                cb += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ca == <span class="number">0</span>:</span><br><span class="line">                a, ca = num, <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> cb == <span class="number">0</span>:</span><br><span class="line">                b, cb = num, <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ca -= <span class="number">1</span></span><br><span class="line">                cb -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 这两个数不一定都会比数组长的1/3大</span></span><br><span class="line">        <span class="comment"># 所以还需要检查它们出现的次数是否符合条件。</span></span><br><span class="line">        ca, cb = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == a:</span><br><span class="line">                ca += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num == b:</span><br><span class="line">                cb += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> ca &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">            ans.append(a)</span><br><span class="line">        <span class="keyword">if</span> cb &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">            ans.append(b)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>经验:对于出现次数大于$\frac{1}{K}$的情况,可以使用==摩尔投票法==</p>
<hr>
<h1 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171. Excel表列序号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-number/">171. Excel表列序号</a></h1><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p>
<p>例如，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A&quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;AB&quot;</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;ZY&quot;</span><br><span class="line">输出: 701</span><br></pre></td></tr></table></figure>

<p>我的代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># 表示第几位</span></span><br><span class="line">        up = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 注意倒序</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> s[::-<span class="number">1</span>]:</span><br><span class="line">            res += (<span class="built_in">ord</span>(each)-<span class="number">64</span>)*(<span class="number">26</span>**(up-<span class="number">1</span>))</span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>还可以这么写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">titleToNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            n = n*<span class="number">26</span> + <span class="built_in">ord</span>(ch)-<span class="number">65</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>

<p>经验:转为数值的时候,一般都是倒序输出,每位数乘以<strong>进制的N次方</strong></p>
<hr>
<h1 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h1><p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 0</span><br><span class="line">解释: 3! = 6, 尾数中没有零。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! = 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 你算法的时间复杂度应为 <em>O</em>(log <em>n</em>) 。  </p>
<p>有几个零靠的是个位数,根据九九乘法表,只有二五,四五,六五,八五才能得到一个整数.<br>根据阶乘性质,而2一定在5的前面,有5就一定有2.所以一个10里就有2两个零(2*5与10)</p>
<p>我的代码:(是错的)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trailingZeroes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        quo,remain = <span class="built_in">divmod</span>(n,<span class="number">10</span>)</span><br><span class="line">        res = quo * <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> remain &gt;= <span class="number">5</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>上面的代码问题就在当n=25的时候,25可以拆除两个5,所以会多出一个0,同理50会多出2个0</p>
<pre><code>所以我们需要计算到底有多少个5
假若N=31,31里能凑10的5为[5, 2*5, 3*5, 4*5, 25, 6*5] 其中 25还能拆为 5**2 
所以,里面的5的个数为 int(31/(5**1)) +  int(31/(5**2))
所以,只要先找个一个 5**x &lt; n 的x的最大数 然后按上面循环加起来
结论就是:数n中含有5的幂次的个数之和就是答案，直观一点 answer = n//5+n//25 +n// 125 +n//625 + n//3125+.......
</code></pre>
<p>所以正确答案如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trailingZeroes</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">            n //= <span class="number">5</span></span><br><span class="line">            <span class="comment"># 这里的n就是n//5,n//25,n//125...的数量</span></span><br><span class="line">            <span class="comment"># n等于0的时候,说明5**n已经大于刚开始输入的n了</span></span><br><span class="line">            res += n</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175. 组合两个表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></h1><p>当前SQL架构如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Person (PersonId <span class="type">int</span>, FirstName <span class="type">varchar</span>(<span class="number">255</span>), LastName <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Address (AddressId <span class="type">int</span>, PersonId <span class="type">int</span>, City <span class="type">varchar</span>(<span class="number">255</span>), State <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (PersonId, LastName, FirstName) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Address</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Address (AddressId, PersonId, City, State) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;New York City&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>表1: <code>Person</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId 是上表主键</span><br></pre></td></tr></table></figure>

<p>表2: <code>Address</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure>
<p>SQL中Truncate的用法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">truncate table命令用于删除现有表中完整的数据。(删除内容、释放空间但不删除定义。)</span><br><span class="line">删除表中的数据的方法有delete,truncate, 其中TRUNCATE TABLE用于删除表中的所有行，而不记录单个行删除操作。TRUNCATE TABLE 与没有 WHERE 子句的 DELETE 语句类似；但是，TRUNCATE TABLE 速度更快，使用的系统资源和事务日志资源更少。</span><br><span class="line">当你不再需要该表时，用 drop；当你仍要保留该表，但要删除所有记录时，用 truncate；当你要删除部分记录时（always with a WHERE clause), 用 delete.</span><br></pre></td></tr></table></figure>

<p>其实考的就是left join 和 right join</p>
<p>代码如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.FirstName, p.LastName, a.City, a.State </span><br><span class="line"><span class="keyword">FROM</span> Person p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Address a </span><br><span class="line"><span class="keyword">ON</span>  p.PersonId <span class="operator">=</span> a.personId;</span><br></pre></td></tr></table></figure>

<p>left join 和 right join复习:<br>left join就是以左表为关键字,<strong>返回左表的全部行</strong>,可能右表中没有匹配的行。</p>
<hr>
<h1 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></h1><p>当前SQL架构如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Employee (Id <span class="type">int</span>, Salary <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Employee</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (Id, Salary) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;100&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (Id, Salary) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;200&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (Id, Salary) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;300&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>

<p>例如上述 <code>Employee</code> 表，SQL查询应该返回 <code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>

<p>代码如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">as</span> SecondHighestSalary <span class="keyword">from</span> employee</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> (<span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> employee);</span><br></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(Salary) <span class="keyword">as</span> SecondHighestSalary <span class="keyword">from</span> Employee</span><br><span class="line">	<span class="keyword">where</span> Salary <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">max</span>(Salary) <span class="keyword">as</span> Salary <span class="keyword">from</span> Employee);</span><br></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> IFNULL(</span><br><span class="line">	(<span class="keyword">select</span> Salary <span class="keyword">from</span> Employee</span><br><span class="line">     <span class="keyword">group</span> <span class="keyword">by</span> Salary <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> limit <span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    ,<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="181-超过经理收入的员工"><a href="#181-超过经理收入的员工" class="headerlink" title="181. 超过经理收入的员工"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/">181. 超过经理收入的员工</a></h1><p>当前SQL架构如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Employee (Id <span class="type">int</span>, Name <span class="type">varchar</span>(<span class="number">255</span>), Salary <span class="type">int</span>, ManagerId <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Employee</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (Id, Name, Salary, ManagerId) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;70000&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (Id, Name, Salary, ManagerId) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Henry&#x27;</span>, <span class="string">&#x27;80000&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (Id, Name, Salary, ManagerId) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;60000&#x27;</span>, <span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (Id, Name, Salary, ManagerId) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;90000&#x27;</span>, <span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>Employee</code> 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></table></figure>

<p>给定 <code>Employee</code> 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Employee |</span><br><span class="line">+----------+</span><br><span class="line">| Joe      |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>

<p>代码如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name Employee <span class="keyword">FROM</span> Employee <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">WHERE</span> Salary <span class="operator">&gt;</span></span><br><span class="line">(<span class="keyword">SELECT</span> Salary <span class="keyword">FROM</span> Employee <span class="keyword">WHERE</span> Id <span class="operator">=</span> a.Managerid);</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.Name <span class="keyword">AS</span> Employee <span class="keyword">FROM</span> Employee e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Employee y <span class="keyword">ON</span> e.ManagerId <span class="operator">=</span> y.Id <span class="keyword">AND</span> e.Salary <span class="operator">&gt;</span> y.Salary;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/duplicate-emails/">182. 查找重复的电子邮箱</a></h1><p>当前SQL架构如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Person (Id <span class="type">int</span>, Email <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (Id, Email) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a@b.com&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (Id, Email) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;c@d.com&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (Id, Email) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;a@b.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure>

<p>根据以上输入，你的查询应返回以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>所有电子邮箱都是小写字母。</p>
<p>代码如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Email <span class="keyword">from</span> Person <span class="keyword">group</span> <span class="keyword">by</span> Email <span class="keyword">having</span> <span class="built_in">count</span>(Email) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.email <span class="keyword">FROM</span> Person p <span class="keyword">GROUP</span> <span class="keyword">BY</span> p.email <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(p.email) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183. 从不订购的客户"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/customers-who-never-order/">183. 从不订购的客户</a></h1><p>当前SQL架构如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Customers (Id <span class="type">int</span>, Name <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Orders (Id <span class="type">int</span>, CustomerId <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Customers</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers (Id, Name) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers (Id, Name) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Henry&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers (Id, Name) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers (Id, Name) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;Max&#x27;</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Orders (Id, CustomerId) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Orders (Id, CustomerId) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p>
<p><code>Customers</code> 表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>

<p><code>Orders</code> 表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure>

<p>例如给定上述表格，你的查询应返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">as</span> Customers <span class="keyword">from</span> Customers</span><br><span class="line"><span class="keyword">where</span> Id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> CustomerId <span class="keyword">from</span> Orders)</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.Name <span class="keyword">AS</span> Customers <span class="keyword">FROM</span></span><br><span class="line">Customers c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders o <span class="keyword">ON</span> c.Id <span class="operator">=</span> o.CustomerId</span><br><span class="line"><span class="keyword">WHERE</span> o.CustomerId <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h1><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的原地算法。</li>
</ul>
<p>最简单的代码,但是空间复杂度为O(k),而且不是原地算法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="keyword">return</span> nums[-k:] + nums[:-k]</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            nums.insert(<span class="number">0</span>,nums.pop())</span><br></pre></td></tr></table></figure>

<p>还有如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 使用k%n求余,防止旋转一整圈回到原点,保证k&lt;n</span></span><br><span class="line">        k %= n</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        tmp = nums[:]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 原先某个元素从位置i变成位置(i+k)%n,使用%n是为了防止越界</span></span><br><span class="line">            nums[(i+k)%n] = tmp[i]</span><br></pre></td></tr></table></figure>

<p>还有很酷的方法:三次反转</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reverse前半部分、后半部分、全部，这种方法时间复杂度是O(n)。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        nums[:n-k] = <span class="built_in">reversed</span>(nums[:n-k])</span><br><span class="line">        nums[n-k:] = <span class="built_in">reversed</span>(nums[n-k:])</span><br><span class="line">        nums.reverse()</span><br></pre></td></tr></table></figure>

<p>也可以写成如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reverse前半部分、后半部分、全部，这种方法时间复杂度是O(n)。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        <span class="comment"># 首先全部翻转</span></span><br><span class="line">        self.func(nums, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 然后分两部分翻转</span></span><br><span class="line">        self.func(nums, <span class="number">0</span>, k-<span class="number">1</span>)</span><br><span class="line">        self.func(nums, k, n-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self, nums, start, end</span>):</span></span><br><span class="line">        <span class="comment"># 采用双指针</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            nums[start],nums[end]=nums[end],nums[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>最pythonic的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 注意：这儿是nums[:],而不是nums</span></span><br><span class="line">        <span class="comment"># 相当于nums[:k],nums[k:] = nums[n-k:],nums[:n-k]</span></span><br><span class="line">        nums[:] = nums[n-k:]+nums[<span class="number">0</span>:n-k]</span><br></pre></td></tr></table></figure>

<p>经验:</p>
<ol>
<li>如果是非原地修改就是return nums[n-k:]+nums[0:n-k],<br>==如果要原地修改就是nums[:] = nums[n-k:]+nums[0:n-k]==</li>
<li>对于旋转数组问题,可以考虑三次翻转.</li>
</ol>
<hr>
<h1 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a></h1><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br><span class="line">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，因此返回 964176192，其二进制表示形式为00111001011110000010100101000000。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：10111111111111111111111111111111</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 2</strong> 中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li>
</ul>
<p><strong>进阶</strong>:<br>如果多次调用这个函数，你将如何优化你的算法？</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># 转为翻转的二进制</span></span><br><span class="line">        str1 = <span class="built_in">bin</span>(n)[<span class="number">2</span>:][::-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 补零</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(str1)&lt;<span class="number">32</span>:</span><br><span class="line">            str1 += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(str1,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码效率不高,应该使用<strong>右移</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        rev = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="comment"># 按位与:判断i位的数是不是1,如果为1就返回1,不然就返回0.</span></span><br><span class="line">            pop = n &amp; <span class="number">1</span></span><br><span class="line">            <span class="comment"># 对这个数在进行31-i位的左移,再自加</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            rev = rev*<span class="number">2</span> + pop</span><br><span class="line">        <span class="keyword">return</span> rev</span><br></pre></td></tr></table></figure>

<p>python位运算符复习:<br>| 运算符 | 描述 | 实例 |<br>| :—– | :—–| :—–|<br>| &amp; | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 |<br>| | | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。| (a | b) 输出结果 61 ，二进制解释： 0011 1101 |<br>| ^ | 按位异或运算符：当两对应的二进位相异时，结果为1 | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 |<br>| ~ | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。**<del>x** 类似于 <strong>-x-1</strong> | (</del>a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。|<br>| &lt;&lt; | 左移动运算符：运算数的各二进位全部左移若干位，由 <strong>&lt;&lt;** 右边的数字指定了移动的位数，高位丢弃，低位补0。| a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 |<br>| &gt;&gt; | 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，</strong>&gt;&gt;** 右边的数字指定了移动的位数 | a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 |</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">60</span>            <span class="comment"># 60 =  0011 1100 </span></span><br><span class="line">b = <span class="number">13</span>            <span class="comment"># 13 =  0000 1101 </span></span><br><span class="line"> </span><br><span class="line">c = a &amp; b;        <span class="comment"># 12 =  0000 1100</span></span><br><span class="line">c = a | b;        <span class="comment"># 61 =  0011 1101 </span></span><br><span class="line">c = a ^ b;        <span class="comment"># 49 =  0011 0001</span></span><br><span class="line">c = ~a;           <span class="comment"># -61 = 1100 0011</span></span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>;       <span class="comment"># 240 = 1111 0000</span></span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>;       <span class="comment"># 15 =  0000 1111</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a></h1><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li>
</ul>
<p><strong>进阶</strong>:<br>如果多次调用这个函数，你将如何优化你的算法？</p>
<p>可以耍赖使用字符串的count函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>经验:==不仅str类型有count函数,byte类型一样有count函数==</p>
<p>最正确的方式还是使用位运算:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="comment"># 不断与n-1按位与</span></span><br><span class="line">            n &amp;= (n-<span class="number">1</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>