<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第零章-知识点思维导图&quot;&gt;&lt;a href=&quot;#第零章-知识点思维导图&quot; class=&quot;headerlink&quot; title=&quot;第零章:知识点思维导图&quot;&gt;&lt;/a&gt;第零章:知识点思维导图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/9113969-12631836bbc5f26f.png&quot; alt=&quot;img&quot;&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>计算机网络课本 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Computer-Network/" rel="tag">Computer Network</a></div><div class="post-time">2019-04-08</div></div></div><div class="container post-header"><h1>计算机网络课本</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E9%9B%B6%E7%AB%A0-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">第零章:知识点思维导图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">第一章:概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">第二章:物理层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">第三章:数据链路层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text">第四章:网络层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-number">6.</span> <span class="toc-text">第五章:运输层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">7.</span> <span class="toc-text">第六章:应用层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%96%99%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">资料参考:</span></a></li></ol></details></div><div class="container post-content"><h1 id="第零章-知识点思维导图"><a href="#第零章-知识点思维导图" class="headerlink" title="第零章:知识点思维导图"></a>第零章:知识点思维导图</h1><p><img src="/images/9113969-12631836bbc5f26f.png" alt="img"></p>
<p><img src="/images/9113969-989a598d8db375f8.png" alt="img"></p>
<p><img src="/images/9113969-c97f9d822c8529a7.png" alt="png"></p>
<p><img src="/images/9113969-cc247c922f04ac15.png" alt="img"></p>
<p><img src="/images/9113969-2df335c0e3a0993d.png" alt="img"></p>
<p><img src="/images/9113969-11f6b923141e0273.png" alt="img"></p>
<p><img src="/images/9113969-48cc4057908fb92d.png" alt="png"></p>
<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章:概述"></a>第一章:概述</h1><p>与网络相连的计算机称为主机.</p>
<p>互联网服务提供商:ISP<br>ISP就是IP的批发商,我们就是从ISP中购买IP的使用权.</p>
<p>主机A和主机B进行通讯,实际上指的是主机A上的某个程序和主机B的某个程序进行通信.</p>
<p>互联网,不可能所有电脑两两连接</p>
<p><img src="/images/1-1FZ5232325246.gif" alt="img"></p>
<p>而是集中到一台交换机上:</p>
<p><img src="/images/20180623164007959.gif" alt="img"></p>
<p>当电脑数量增多是,就要使用很多的交换机彼此连接.</p>
<p>为了提高交换的效率,我们采用的是<strong>分组交换</strong>的方式.分组交换采用<code>存储转发</code>技术.</p>
<p>我们将要转发的整块数据成为<code>报文</code>.<br>我们将报文等长划分分组,每组加上头部(头部加上了目的地址和源地址等信息)</p>
<p><img src="/images/1060770-20171018122921881-838285755.png" alt="img"></p>
<p>所谓的路由器就是用来<strong>转发分组</strong>的</p>
<p>==路由器收到一个分组,先暂时存储一下,检查其首部,查找转发表,按照首部中的目的地址,找到合适的接口转发出去,把分组交给下一个路由器==,就这样一步一步的以存储转发的方式,把分组交付到最终的目的主机.<br>(注意:每个分组所走的路径千差万别,如果某个链路繁忙,就可能走其他的路了)</p>
<p>三种交换方式:</p>
<ol>
<li>电路交换:建立连接-连续比特流传送-断开连接</li>
<li>报文交换:整个报文送到相邻节点</li>
<li>分组交换:报文切片,将每个切片送到相邻节点.</li>
</ol>
<p>网络带宽:单位时间内某信道说通过的<strong>最高</strong>数据率.单位:比特每秒</p>
<p>高速链路的意思是:发送分组的速度很快,而不是在链路中传播地很快</p>
<p>应用层:进程之间的交互<br>运输层:为进程提供通用的数据传输服务(实现进程之间的数据交换)<br>网络层:能主机能找到目的主机<br>链路层:将IP数据表组装成帧<br>物理层:让数据转成01比特流</p>
<p><img src="/images/20181129103551941.png" alt="img"></p>
<p>可见:==每过一层就要将数据加一层头部==(链路层还有加尾部,物理层将数据转为比特流)</p>
<p><img src="/images/20180918141906411.png" alt="img"></p>
<h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章:物理层"></a>第二章:物理层</h1><p>模拟信号/连续信号:消息是连续的.<br>数字信号/离散信号:消息是离散的.</p>
<h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章:数据链路层"></a>第三章:数据链路层</h1><p>我们知道链路层需要将IP数据包前面添加首部,后面添加尾部:</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B8%A7.png" alt="img"></p>
<p>那么如何界定每帧的开始和结束呢?<br>使用ASCII码中的SOH和EOT.<br>如果IP数据报中存在SOH和EOT怎么办?<br>使用ESC来转义.</p>
<p><img src="/images/%E7%BB%8F%E8%BF%87%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85%E5%90%8E%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt="img"></p>
<p>当目标主机接收到了这个分组后,就可以检查有没有完整的SOH和EOT.如果没有就舍弃掉.</p>
<p>CSMA/CD协议:载波监听多点接入/碰撞检测.==一对一通讯==<br>CSMA/CD一般用于局域网:将许多计算机都连接到一根总线上</p>
<p><img src="/images/20180126170519644.png" alt="imgimg"></p>
<p>CSMA/CD如何实现一对一通讯?<br>主机发送数据帧的时候,在帧的首部写明接受主机的地址(也就是目的地址和适配器的ROM中硬件地址一致).只有地址对应的主机才接受这个数据帧,<strong>其他主机就舍去这个数据帧</strong></p>
<p>CSMA/CD协议举例:<br>==开会,大家随机发言.如果你听到有谁在说话,你必须等他说完才能发言.碰巧两个人同时发言了,一旦发生冲突,大家都停止发言,等听到没有人发言了你在发言.==</p>
<p>所以CSMA/CD协议的要点是:</p>
<ol>
<li>多点接入</li>
<li>载波监听</li>
<li>碰撞检测(边发送边监听)</li>
</ol>
<p><img src="/images/20160713140200063.jpg" alt="img"></p>
<p>CSMA/CD协议:一个站不可能同时进行发送和接受.所以CSMA/CD协议是半双工通信.</p>
<p>两倍的传播时延$2\tau​$被称为<code>争用期</code><br>也就是说,经过了争用期这段时间还没有检测到碰撞,才能肯定这次发送没有发生碰撞.</p>
<p>退避算法:<br>就是说,每当发生一次碰撞之后,随机等待n倍的争用期后才能发送信息.</p>
<p>CSMA/CD协议要点归纳如下：</p>
<ol>
<li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，加入适配器的缓存中。但在发送之前，必须先检测信道。</li>
<li>检测信道：若检测到信道忙，则应不停的检测，一直等待信道转为空闲。若检测到信道空闲，并在96比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。</li>
<li>在发送过程中仍不断的检测信道，即网络适配器要边发送边监听。<ol>
<li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能发送成功。发送完毕后什么也不做，回到（1）。</li>
<li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待r倍512比特时间后，返回步骤（2），继续检测信道。若重传达16次仍不成功，则停止重传而向上报错。</li>
</ol>
</li>
</ol>
<p>以太网每发送完一帧，一定要把已发送的帧暂时保留一下。如果在争用期内检测出发生了碰撞，那么还要在推迟一段时间后再把这个暂时保留的帧重传一次。</p>
<p>以太网的MAC层<br><code>硬件地址</code>又称<code>MAC地址</code>或<code>物理地址</code>.</p>
<p><img src="/images/1334157-20180513182354689-2023335741.png" alt="img"></p>
<h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章:网络层"></a>第四章:网络层</h1><p>与IP协议配套使用的还有三个协议:</p>
<ul>
<li>地址解析协议ARP</li>
<li>网际控制报文协议ICMP</li>
<li>网际组管理协议IGMP</li>
</ul>
<p><img src="/images/2018-03-01-15199033763600.jpg" alt="img"></p>
<p>在这一层中，ARP 画在最下面，因为IP 经常要使用这个协议。<br>ICMP 和IGMP 画在这一层的上部,因为它们要使用IP协议。</p>
<p>分类的IP地址</p>
<p><img src="/images/2018-03-01-15199058167827.jpg" alt="img"></p>
<p>重要特点</p>
<p>每一个IP地址都由网络号和主机号两部分组成。IP 地址是一种分等级的地址结构。分两个等级的好处是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP 地址管理机构在分配IP 地址时只分配网络号(第一级)，而剩下的主机号(第二级) 则由得到该网络号的单位自行分配。这样就方便了IP地址的管理; </span><br><span class="line">路由器仅根据目的主机所连接的网络号来转发分组(而不考虑目的主机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。</span><br></pre></td></tr></table></figure>
<p>IP地址与硬件地址的区别:</p>
<p><img src="/images/20160311202637585.jpg" alt="img"></p>
<p>==虽然在IP数据报首部有源站的IP地址,当路由器只根据目的站的IP地址的网络号进行路由选择==.</p>
<p>地址解析协议ARP:<strong>根据机器的IP地址解析出相应的硬件地址</strong></p>
<p><img src="/images/wKioL1cHdYrzdFoQAABCVOaI8VA489.png" alt="img"></p>
<p>地址解析协议ARP:<br>在<strong>主机</strong><code>ARP高速存缓</code>(ARP cache)中存放一个从IP地址到硬件地址的映射表,并且这个映射表还经常动态更新.</p>
<p><img src="/images/1862021-e6047a66dbe9b8da.jpg" alt="img"></p>
<p>当ARP高速存缓中,没有找到目标IP的硬件地址,这时就会广播求助.<br>目标主机接收这个信息后会<strong>单播</strong>给提问主机.</p>
<p>上面的流程是两个主机都在局域网里,如果是跨网络就需要借助路由器,多次使用ARP协议.</p>
<p>现在有个问题:<br>既然在网络链路上传送的帧最终是按照硬件地址来找到主机的,那么为什么还要使用抽象的IP地址?而不直接使用硬件地址进行通信?这样就能免除使用ARP了.<br>原因很简单:硬件地址千奇百怪,硬件地址的转化及其复杂,主机基本不可能直接找到目标主机的硬件地址.但是IP编址是一样的.所以我们可以根据IP地址来找硬件地址.</p>
<p>IP数据报的格式</p>
<p><img src="/images/2018-03-01-15199079821851.jpg" alt="img"></p>
<p>版本：</p>
<p>占4位，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目<br>前广泛使用的IP 协议版本号为4 (即IPv4)。</p>
<p>首部长度</p>
<p>占4位，可表示的最大十进制数值是15。请注意，首部长度字段所表示数的单位是32位字(1个32位字长是4 字节)。因为IP首部的固定长度是20字节，因此首部长度字段的最小值是5 (即二进制表示的首部长度是0101)。而当首部长度为最大值1111时(即十进制数的15),就表明首部长度达到最大值15个32 位字长，即60 字节。当IP 分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。因此IP数据报的数据部分永远在4字节的整数倍时开始，这样在实现IP 协议时较为方便。<br>首部长度限制为60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度是20字节(即首部长度为0101),这时不使用任何选项。</p>
<p>区分服务</p>
<p>占8位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。只有在使用区分服务时，这个字段才起作用。在一般的情况下都不使用这个字段。<br></p>
<p>总长度</p>
<p>总长度指<strong>首部和数据之和</strong>的长度，单位为字节。总长度字段为16 位，因此数据报的最大长度为2的16次方- 1= 65535 字节。然而实际上传送这样长的数据报在现实中。是极少遇到的。<br>在IP 层下面的每一种数据链路层协议都规定了– **一个数据帧中的数据字段的最大长度，这称为最大传送单元MTU (Maximum Transfer Unit)**。当一个IP 数据报封装成链路层的帧时，此数据报的总长度(即首部加上数据部分)一定不能超过下面的数据链路层所规定的MTU值。例如，最常用的以太网就规定其MTU值是1500字节。若所传送的数据报长度超过数据链路层的MTU值,就必须把过长的数据报进行分片处理。<br>虽然使用尽可能长的IP数据报会使传输效率得到提高(因为每一个IP数据报中首部长度占数据报总长度的比例就会小些)，但数据报短些也有好处。每一个IP数据报越短，路由器转发的速度就越快。为此，IP协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过576字节的数据报。这是假定上层交下来的数据长度有512字节(合理的长度),加上最长的IP 首部60字节，再加上4字节的富余量，就得到576 字节。当主机需要发送长度超过576字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。在进行分片时(见后面的“片偏移”字段)，数据报首部中的“总长度”字段是指分片<br>后的每一个分片的首部长度与该分片的数据长度的总和。</p>
<p>标识(identification)</p>
<p>占16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报,计数器就加1,并将此值赋给标识字段。但这个“标识”并不是序号,因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。==相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报==。(证明两个切片是相同的id)</p>
<p>标志(flag)</p>
<p>占3位，但目前只有两位有意义：</p>
<ul>
<li>标志字段中的最低位记为MF (More Fragment)。MF= 1即表示后面“还有分片”<br>的数据报。MF=0 表示这已是若千数据报片中的最后一个。</li>
<li>标志字段中间的一位记为DF (Don’t Fragment),意思是“不能分片”。只有当DF=<br>0时才允许分片。</li>
</ul>
<p><img src="/images/g496fwerow.png" alt="img"></p>
<p>片偏移</p>
<p>占13 位。片偏移指出: 较长的分组在分片后，某片在原分组中的相对位置。也就是说,相对于用户数据字段的起点,该片从何处开始。片偏移以8个字节为偏移单位。这就是说，每个分片的长度一定是8字节(64位)的整数倍。</p>
<p>生存时间</p>
<p>占8位，生存时间字段常用的英文缩写是TTL (Time To Live),表明这是数据报在网络中的寿命。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子(例如从路由器R1转发到R2,再转发到R3，然后又转发到R1),因而白白消耗网络资源。最初的设计是以秒作为TTL值的单位。每经过一个路由器时，就把TTL 减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于1秒，就把TTL值减1。当TTL 值减为零时，就丢弃这个数据报。<br>然而随着技术的进步,路由器处理数据报所需的时间不断在缩短，一般都远远小于1<br>秒,后来就把TTL字段的功能改为“<strong>跳数限制</strong>”(但名称不变)。路由器在每次转发数据报<br>之前就把TTL值减1.若TTL 值减小到零，就丢弃这个数据报，不再转发。<strong>因此，现在TTL 的单位不再是秒，而是跳数</strong>。TTL 的意义是指明数据报在互联网中至多可经过多少个<br>路由器。显然，数据报能在互联网中经过的路由器的最大数值是255。若把TTL 的初始值<br>设置为1,就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的<br>某个路由器，在被转发之前TTL值就减小到零，因而就会被这个路由器丢弃。</p>
<p>协议</p>
<p>协议字段指出此数据报携带的数据是使用何种协议，以便使目的占8位,主机的IP层知道应将数据部分上交给哪个协议进行处理。<br>常用协议对应字段：</p>
<table>
<thead>
<tr>
<th align="center">协议名</th>
<th align="center">ICMP</th>
<th align="center">IGMP</th>
<th align="center">IP</th>
<th align="center">TCP</th>
<th align="center">EGP</th>
<th align="center">IGP</th>
<th align="center">UDP</th>
<th align="center">IPv6</th>
<th align="center">ESP</th>
<th align="center">OSPF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">协议字段值</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">17</td>
<td align="center">41</td>
<td align="center">50</td>
<td align="center">89</td>
</tr>
</tbody></table>
<blockquote>
<p>这里的IP表示特殊的IP数据报–IP数据报再封装到IP数据报中。</p>
</blockquote>
<p>首部检验和</p>
<p>占16 位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算- 一下首部检验和(一些字段，如生存时间、标志、片偏移等都可能发生变化)。不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP 首部的检验和不采用复杂的CRC 检验码而采用下面的简单计算方法:<br>在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有16 位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。</p>
<p><a target="_blank" rel="noopener" href="http://picture.acemurder.com/2018-03-02-15199605053064.jpg"><img src="/images/2018-03-02-15199605053064.jpg" alt="img"></a></p>
<p>源地址: 占32位</p>
<p>目的地址: 占32位</p>
<p>IP数据报首部可变部分</p>
<p>IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从1个字节到40 个字节不等，取决于所选择的项目。某些选项项目只需要1个字节，它只包括1个字节的选项代码。而有些选项需要多个字节，这些选项一个个拼接起来,中间不需要有分隔符,最后用全0 的填充字段补齐成为4字节的整数倍。<br>增加首部的可变部分是为了增加IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。很多路由器都不考虑IP 首部的选项字段，因此新的IP版本IPV6 就把IP数据报的首部长度<br>做成固定的。</p>
<p>IP层转发分组的流程</p>
<p>在互联网上转发分组时，是从一个路由器转发到下一个路由器，在路由表中，每一条路由最主要的是两个信息：</p>
<blockquote>
<p>(目的网络地址，下一跳地址)</p>
</blockquote>
<p>分组转发算法：</p>
<ol>
<li>从数据报的首部提取目的主机的<code>IP地址D</code>,得出<code>目的网络地址N</code>。</li>
<li>N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机(这里包括把目的主机地址D 转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧); 否则就是间接交付，执行(3)。</li>
<li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器;否则，执行(4)。</li>
<li>若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器; 否则，执行(5)。</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器; 否则，执行(6)。</li>
<li>报告转发分组出错。</li>
</ol>
<p>划分子网的方法:<br>从主机号中借用若干位作为子网号.</p>
<p><img src="/images/ghfj5k3h86.png" alt="img"></p>
<p><img src="/images/um83hoj16n.png" alt="img"></p>
<p>子网掩码:<br>对于一个数据报(其目的地址是145.13.3.10)已经R<del>1</del>,那么这个路由器如何把它转发到子网145.13.3.0呢?</p>
<blockquote>
<p>使用子网掩码</p>
</blockquote>
<p>简单来说,就是如何让145.13.3.10变成145.13.3.0?</p>
<blockquote>
<p>子网掩码:子网号前面(包含)的都为1,主机号都为0.然后<strong>按位相与</strong></p>
</blockquote>
<p><img src="/images/41m7di4vsx.png" alt="img"></p>
<p><img src="/images/qvzycjub23.png" alt="img"></p>
<p>如果我们没有手动划分子网,那么就会使用默认子网掩码.因为没有子网号(子网号没有占用主机号),那么子网掩码就是网络号(包含)以前的都是1,主机号都是0</p>
<p><img src="/images/l5n98pqw2l.png" alt="img"></p>
<p>子网例题:<br>IP 地址141.14.72.24，子网掩码255.255.224.0,求子网网络地址:</p>
<p><img src="/images/qz5rzz0bbg.png" alt="img"></p>
<p>使用较少位数的子网号,子网数就较少,每个子网上可连接的主机数就较多,<br>使用较多位数的子网号,子网数就较多,每个子网上可连接的主机数就较少.</p>
<p>无分类编址CIDR(构造超网):<br>CIDR是一个<strong>无分类</strong>的两级编址,把IP地址再次分成:</p>
<blockquote>
<p>IP地址 ::={&lt;网络前缀&gt;,&lt;主机号&gt;}</p>
</blockquote>
<p>例如:128.14.35.7/20代表:前面20位是网络前缀,后面12位(32-20=12)是主机号</p>
<p>CIDR其实就是一个<code>分块</code>技术.如上面的128.14.35.7/20就是将前20位分成一个块,那么这个块最小地址就是==10000000 00001110 0010==0000 00000000<br>最大地址就是==10000000 00001110 0010==1111 11111111</p>
<p>我们可以将这种地址块简称为<code>/20地址块</code></p>
<p>CIDR中,其实也有掩码,不过不叫子网掩码,而是叫做<code>地址掩码</code>,地址掩码很简单:</p>
<blockquote>
<p>网络前缀都是1,主机号都是0</p>
</blockquote>
<p>例如上面的/20地址块,地址掩码就是<strong>20个1加12个0</strong></p>
<p>使用CIDR可以很简单的求出该地址块的最大和最小地址的IP:<br>eg:对于192.199.170.82/27来说,网络前缀有27为,主机位有32-27=5位.<br>192.199.170.82的IP地址就是11000000,11000111,10101010,01010010.<br>前27位保持不变,后面5位为0和1,即:<br>最小IP为==11000000,11000111,10101010,010==00000.即:192.199.170.64<br>最大IP为==11000000,11000111,10101010,010==11111.即:192.199.170.95</p>
<p>CIDR这样的地址块就被称为<code>路由聚合</code>,又称<code>构成超网</code></p>
<p>网络前缀越长,那么该地址块就会很小,就越精确.所以路由器在进行分组传送的时候就会选择网络前缀最长的那个,这种做法称为<code>最长前缀匹配</code></p>
<p>路由器为了快速查找最长前缀匹配,使用了<code>二叉线索</code></p>
<p><img src="/images/687.png" alt="title"></p>
<p>VPN(虚拟专用网):</p>
<blockquote>
<p>利用公用的互联网作为本机构各专用网之间的通信载体.</p>
</blockquote>
<p><img src="/images/9113969-1393e55231d207a9.png" alt="img"></p>
<h1 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章:运输层"></a>第五章:运输层</h1><p>运输层向他上面的应用层提供通信服务.<br>它属于面向通信部分的最高层,同时也是用户功能中的最底层.</p>
<p><img src="/images/5bdc148c0001d0c909330557.jpg" alt="img"></p>
<p>IP协议是点到点的通信,即从一个主机到另一个主机.但是真正在通信的其实是两个主机的进程之间的通信.一个主机可能有多个进程与另一个主机的进程之间有通信.<br>TCP协议是端到端的通信.</p>
<p>运输层还有一个重要的功能就是:<strong>对收到的报文进行差错检测</strong>.</p>
<p>运输层基本就是两个协议组成:TCP,UDP</p>
<p><img src="/images/5bdc148e0001233904750257.jpg" alt="img"></p>
<p>复用和分用:<br>学校有一个快递站,学生寄邮件的时候都要到快递站去,这就是复用.<br>学生收邮件的时候都要去快递站里收,这就是分用.</p>
<p>运输层就类似于快递站:<br>发信息的时候,应用层复用运输层,把多个进程的信息送到运输层.<br>收信息的时候,应用层分用运输层,把运输层的报文送到应用层各个进程.</p>
<p>TCP的端口:</p>
<ul>
<li>端口用一个 16 位端口号进行标志。</li>
<li>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。</li>
</ul>
<p>三类端口号:</p>
<ul>
<li>熟知端口，数值一般为 0~1023。</li>
<li>登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li>
<li>客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用</li>
</ul>
<p>UDP:<br>其实UDP就是在IP服务加了两个东西:</p>
<ol>
<li>复用和分用</li>
<li>差错检测</li>
</ol>
<p>所以UDP的特性就是:</p>
<ol>
<li>UDP是无连接的(不需要先TCP一样先建立连接)</li>
<li>UDP是不可靠的</li>
<li>UDP是面向报文的.<br>==发送方的UDP对应程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文既不合并也不拆分，而是保留这些报文的边界。==</li>
</ol>
<p><img src="/images/180924145972613.jpg" alt="img"></p>
<p>简单来说,就是<strong>应用层传下来的报文,UDP加上自己的首部后直接就传给IP层了,其实什么事都不做</strong>.</p>
<ol start="4">
<li>UDP没有拥塞控制(就算网络堵塞了,源主机也不会降低发送的速率)</li>
<li>UDP支持一对一，一对多，多对一和多对多交换通信。</li>
<li>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ol>
<p>UDP的头部</p>
<p><img src="/images/180924145972611.jpg" alt="img"></p>
<p>TCP的特点</p>
<ul>
<li><p>面向连接的运输层协议<br>面向连接意味着两个使用 TCP的应用在交换数据前必须先建立一个 TCP 连接,在一个 TCP 连接中，仅有两方进行彼此通信，广播和多播不能用于 TCP</p>
</li>
<li><p>每一条 TCP 连接只能有两个端点(endpoint)<br>每一条 TCP 连接只能是点对点的（一对一）</p>
</li>
<li><p>提供可靠交付的服务<br>(无差错,不丢失,不重复,按序到达)</p>
</li>
<li><p>提供全双工通信</p>
</li>
<li><p>面向字节流<br>字节流指的是:流入到进程或者从进程流出的字节序列.</p>
<p><img src="/images/5bdc148f0001e4bb09110469.jpg" alt="img"></p>
<p>字节流服务：两个应用程序通过 TCP 连接，TCP 不在字节中插入记录标识符,<br>TCP对字节流的内容不做任何解释,不知道传输的字节流数据是二进制数据还是 ASCII 字符或其他类型数据,对字节流的解释由TCP连接双方的应用层.</p>
</li>
</ul>
<p>应当注意</p>
<ul>
<li>TCP 连接是一条虚连接而不是一条真正的物理连接</li>
<li>TCP 对应用进程一次把多长的报文发送到TCP的缓存中是不关心的</li>
<li><strong>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节</strong>（而UDP 发送的报文长度是应用进程给出的）</li>
<li>TCP 可把太长的数据块划分短一些再传送,TCP 也可等待积累有足够多的字节后再构成报文段发送出去</li>
</ul>
<p>TCP 的连接</p>
<ul>
<li><p>TCP 把连接作为最基本的抽象</p>
</li>
<li><p>每一条 TCP 连接有两个端点</p>
</li>
<li><p>TCP 连接的端点不是主机,不是主机的IP 地址,不是应用进程,也不是运输层的协议端口.==TCP连接的端点叫做套接字(socket)==<br>(这么想:TCP是进程之间的通信协议,而进程又被一台主机的端口号唯一确定,主机被IP号唯一确定.所以套接字就是<strong>IP地址+端口号</strong>)</p>
</li>
<li><p>端口号拼接到(contatenated with) IP地址即构成了套接字</p>
<blockquote>
<p>套接字 socket = (IP地址:端口号)</p>
</blockquote>
<p>两点确定一直线,每条TCP连接被通信的两个端点说确定</p>
<blockquote>
<p>TCP连接::={socket<del>1</del>,socket<del>2</del>} = { (IP<del>1</del>:port<del>1</del>) , (IP<del>2</del>:port<del>2</del>) }</p>
</blockquote>
</li>
</ul>
<p>理想的传输条件:</p>
<ol>
<li>信道不产生差错</li>
<li>不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据.</li>
</ol>
<p>既然如此,TCP要想实现可靠的传输,就需要解决上面两个问题:</p>
<ol>
<li>当出现差错的时候就要让发送方重传出现差错的数据.</li>
<li>接受方在来不及接受的时候提醒发送方降低发送数据的速度.</li>
</ol>
<p>停止等待协议:<br>这个协议最简单,所谓的<code>停止等待</code>就是说每发完一个分组就停止发送,等待对方的确认,在收到确认之后才发送下一个分组.</p>
<p>出现差错<br>超时重传：A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。<br>要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。</p>
<ul>
<li>A在发送完一个分组后，必须暂时保留已发送的分组的副本。</li>
<li>分组和确认分组都必须进行编号</li>
<li>超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
<li><img src="/images/9113969-414b294023245084.png" alt="img"></li>
</ul>
<p>确认丢失和确认重传<br>若B所发送的对M1的<strong>确认丢失</strong>了，A在超时计时器到期后就要重传M1。此时B第二次收到了M1,应采取两个动作：<br>（1）丢弃这个重复的分组M1，不向上层交付。<br>（2）向A发送确认</p>
<p><img src="/images/1554714363080.png" alt="1554714363080"></p>
<p>上面这种重传协议被称为<code>自动重传请求ARQ</code>(Automatic Repeat Request)</p>
<p>停止等待协议的信道利用率:</p>
<p><img src="/images/9113969-d5423cfd47ce4818.png" alt="img"></p>
<p>这时候就要使用流水线传输</p>
<p><img src="/images/asdasd.png" alt="asdasd"></p>
<p>使用流水线传输需要使用<code>连续ARQ协议</code>和<code>滑动窗口协议</code><br><img src="/images/1554715337142.png" alt="1554715337142"></p>
<p>上图(a)就表示:一口气先将1,2,3,4,5共5个分组发出去.然后停止等待.收到一个确认后发送窗口就向前滑动一格.上图中，数据包6被滑进格子里，此时数据包6就可以被发送，同时数据包1也可以从缓存中清除，</p>
<p>接收方一般采用<strong>累积确认</strong>的方式。即不必对收到的分组逐个发送确认，而是对按序到达的==最后一个分组发送确认==，这样就表示：到这个分组为止的所有分组都已正确收到了。</p>
<ul>
<li>优点是：容易实现，即使确认丢失也不必重传。</li>
<li>缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。</li>
</ul>
<hr>
<p>TCP 可靠通信的具体实现:</p>
<ul>
<li>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。</li>
<li>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。</li>
<li>TCP 两端的四个窗口经常处于动态变化之中。</li>
<li>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间</li>
</ul>
<p>结构决定功能,TCP的所有功能都体现在了TCP报文额度首部中各个字段</p>
<p><img src="/images/1554715359289.png" alt="1554715359289"></p>
<ul>
<li>源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li>
<li>序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的<strong>第一个字节的序号</strong>.<br>(例如:一段文段的序号字段的值为301,携带了100字节的数据,这就表明:本报文段的数据的第一个字节的序号就是301,最后一个字节的序号是400,所以下一个报文段的序号就是401)</li>
<li>确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。<br>(例如:A发来报文的序号为501,该报文为200字节长度,那么B希望下次收到的数据就是从701开始的,所以确认号为701)</li>
<li>数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</li>
<li>保留字段——占 6 位，保留为今后使用，但目前应置为 0。</li>
<li>紧急 URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</li>
<li>确认 ACK —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。</li>
<li>推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付</li>
<li>复位 RST (ReSeT) —— 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li>
<li>同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。</li>
<li>终止 FIN (FINis) —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>
<li>窗口—— 告诉发送方,接收方目前允许发送方发送的数据量.<br>(例如:发送了一个报文段,确认号是701,窗口字段是1000,这就是告诉对方:从701号开始,我的接受存缓空间还可以接受1000字节的数据[也就是说,字节序号是701-1700])</li>
<li>检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li>
<li>紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li>
<li>选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS（<strong>TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。</strong>）。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”</li>
<li>填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。</li>
</ul>
<p>前面TCP首部有一个窗口字段,指的就是发送窗口.<br>下图,接收方B发来了确认报文,确认值为30,窗口值为20(就是说,前面的30字节已经接收完毕,接下来B期望收到的下一个序号就是31,这次期望接收20个字节)</p>
<p><img src="/images/9113969-c7b526fbb1f37e86.png" alt="img"></p>
<p>也就是说:==B的确认值决定了发送窗口的后沿,B的窗口值决定了发送窗口的前沿==前后沿决定了窗口的位置.</p>
<p>要描述一个发送窗口的状态需要三个指针：P1,P2,P3。<br>(因为发送还需要时间,所以会存在P2)</p>
<ul>
<li>小于P1的都是已发送并已确认的部分，大于P3的是不允许发送的部分</li>
<li>P3-P1=A的发送窗口</li>
<li>P2-P1=已发送但尚未收到确认的字节数</li>
<li>P3-P2=允许发送但当前尚未发送的字节数（有效窗口或可用窗口）</li>
</ul>
<p><img src="/images/9113969-5077571b04981d8a.png" alt="img"></p>
<p>下面看一下TCP的存缓和窗口之间的关系</p>
<p><img src="/images/007.png" alt="img"></p>
<p><img src="/images/9113969-84a73e1bbb30426d.png" alt="img"></p>
<p>TCP超时重传的时间选择:</p>
<p>TCP超时重传时间的选择:<strong>加权平均往返时间RTT<del>s</del></strong>.</p>
<p>但是这样又会有一个问题.发送端超时重传了,过了一段时间后收到了确定报文,那么这个确定报文是对第一次报文的确定,还是重传报文的确定?</p>
<p><img src="/images/9113969-21a4daedbdf7a6b6.png" alt="å¾ç.png"></p>
<p>如果都当做是超时重传的确认，那么RTT会被计算小，如果都当做是发送端的确认，则RTT会偏大.在计算加权平均RTT<del>s</del>时，只要报文段重传了，就不采用其往返时间样本，但是这样超时重传时间就不会被更新，所以最终做法是新的重传时间设为旧的重传时间的二倍。</p>
<p>选择确认SACK</p>
<p>TCP通信时，如果发送序列中间某个数据包丢失，TCP会通过重传最后确认的包开始的后续包，这样原先已经正确传输的包也可能重复发送，急剧降低了TCP性能。<br>那么有没有优化方案?使用<code>选择确认SACK</code></p>
<p><img src="/images/1554729484188.png" alt="1554729484188"></p>
<p>如上图,就算是丢包了,还是可以得出丢包的左右边界.这样就可以重传丢失的包了.</p>
<p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项.如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</p>
<p>TCP的流量控制</p>
<p>接收方的窗口值决定发送方的滑动窗口,所以我们就可以通过滑动窗口来控制流量</p>
<p><img src="/images/9113969-923aeccf17704636.png" alt="å¾ç.png"></p>
<p>TCP的拥塞控制</p>
<p>TCP猜测发生拥塞的方法很简单:如果迟迟不能收到对方主机的确认信息,就判断发生了拥塞.</p>
<p>注意拥塞控制和流量控制不是同一种东西:<br>流量控制是指<strong>点对点</strong>的通信量控制<br>拥塞控制是<strong>全局性的</strong>,就是<strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</strong><br>简单来讲:流量控制指的是怕接收端来不及存缓而让发送端放慢速度.拥塞控制让整个网络不至于过载.</p>
<p><img src="/images/9113969-68351b3ab8efd30a.png" alt="å¾ç.png"></p>
<p>提供的负载：代表单位时间内输入给网络的分组数目。<br>吞吐量：代表单位时间内从网络输出的分组数目。</p>
<p>当提供的负载达到某一数值时，网络的吞吐量反而随提供的负载的增大而下降，这时网络就进入了拥塞状态。<br>当提供的负载继续增大到某一数值，网络的吞吐量就下降到0，网络已无法工作，这就是所谓的<strong>死锁</strong>。</p>
<p>拥塞控制的方法：开环控制和闭环控制<br>开环控制：在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。一旦整个系统运行起来，就不再中途进行改正了。<br>闭环控制：基于反馈环路的概念</p>
<ul>
<li>检测网络系统以便检测到拥塞发生在何时、何处地方。</li>
<li>把拥塞发生的信息传送到可采取行动的地方。</li>
<li>调整网络系统的运行以解决出现的问题。</li>
</ul>
<p>TCP进行拥塞控制的算法有四种：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方维持一个叫做**拥塞窗口 cwnd (congestion window)**的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。<br> 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<p>慢开始算法:<br>由于对网络负荷的情况不清楚，先探测一下，<strong>由小到大逐渐增大发送窗口</strong>，每经过一次传输轮训，拥塞窗口cwnd就<strong>加倍</strong>。</p>
<p><strong>慢开始算法的原理：</strong><br> 1、在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。<br> 2、在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。<br> 3、用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理</p>
<p>拥塞避免算法:<br>让拥塞窗口缓慢的变大,即每过一个往返时间RTT就把发送端的拥塞窗口加1</p>
<p><img src="/images/1554727969702.png" alt="1554727969702"></p>
<p><strong>快重传算法</strong>:接收方每收到一个<strong>失序的报文</strong>，就立即发出<strong>重复确认</strong>，而不用等待自己发送数据时才进行捎带确认。发送方一连收到三个<strong>重复确认</strong>就立即重传对方尚未收到的报文。</p>
<p><img src="/images/fdsfdfsd.png" alt="img"></p>
<p><strong>快恢复算法</strong>：发送方一连收到三个<strong>重复确认</strong>时，就“乘法减小”，把ssthresh减半，然后执行拥塞避免算法，“加法增大”</p>
<p><img src="/images/erere.png" alt="img"></p>
<p>在出现拥塞的时候并不会将滑动窗口设置为1重新进行慢开始，而是将滑动窗口设置为出现拥塞时窗口的一半，然后再以加法进行增加，此过程也可称为是快恢复，这样就可以避免网络拥塞的出现。</p>
<p>主动队管理AQM:<br>路由器使用先进先出的策略.一般路由器在发生拥塞时就会把队列尾部的分组舍去.<br>AQM实际上就是对路由器中的分组排队进行智能管理，而不是简单地把队列的尾部丢弃。<br>具体来说就是,当路由器的队列长度已经到达拥塞的警戒值时,就主动丢弃尾部的分组.</p>
<p>TCP的运输连接管理:<br>运输连接有三个阶段：<strong>连接建立、数据传送和连接释放。</strong>运输连接的管理就是使运输连接的建立和释放都能正常地进行。</p>
<p>TCP 连接的建立都是采用客户服务器方式。<br>主动发起连接建立的应用进程叫做客户(client)。<br>被动等待连接建立的应用进程叫做服务器(server)。</p>
<p>三次握手<br>(注:SYN为同步,seq为序列号,ack为确认号)</p>
<p><img src="/images/8992321-08b9544000f3a26e.png" alt="img"></p>
<p>TCP建立连接的三次握手</p>
<ul>
<li>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入<code>SYN_SEND</code>态，待服务器确认<br>SYN：同步序列编号(Synchronize Sequence Numbers)</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，服务器进入<code>SYN_RECV</code>态</li>
<li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入<code>ESTABLISHED</code>状态，完成三次握手</li>
</ul>
<p>完成三次握手，客户端与服务器开始传送数据<br>一个完整的三次握手也就是 请求—应答—再次确认</p>
<p>四次挥手</p>
<p><img src="/images/1554732261416.png" alt="1554732261416"></p>
<p>由于TCP连接是全双工的，因此每个方向都必须<code>单独进行关闭</code></p>
<ul>
<li>原则是<br><code>当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接</code><br>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据<br><code>首先进行关闭的一方将执行主动关闭，另一方执行被动关闭</code></li>
</ul>
<ol>
<li>客户端A发送一个FIN，用来关闭Client A —-&gt;&gt;&gt;Server B的数据传送</li>
<li>B收FIN，发ACK，确认序号为收到的序号加1</li>
<li>B关闭与A的连接，发FIN给A</li>
<li>A发ACK报文确认，并将确认序号设置为收到序号加1</li>
</ol>
<p>为什么连接的时候是三次握手，关闭的时候是四次挥手呢？因为发送FIN时，只是表示自己这一方不再有数据要发送，但是对方发送的数据，还是需要继续接收，直到对方也发送FIN后才可以断开连接。</p>
<p>TCP的有限状态机</p>
<p><img src="/images/8992321-8fff8604fe663781.png" alt="img"></p>
<h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章:应用层"></a>第六章:应用层</h1><p><strong>运输层为应用进程提供了端到端的通信服务。但不同的网络应用进程之间，还需要有不同的通信规则。因此在运输层协议之上，还需要有应用层协议。因为每个应用层协议都是为了解决某一类应用问题，而问题的解决必须通过位于不同主机中的多个应用进程之间的通信和协同工作来完成。应用进程之间的这种通信必须遵循严格的规则。应用层的具体内容就是精确定义这些通信规则。</strong><br>应用层的许多协议都是基于客户服务器方式。客户和服务器都是指通信中所设计的两个应用进程。客户是服务请求方，服务器是服务提供方。</p>
<p>域名系统DNS</p>
<p>域名系统DNS是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。<br>域名到IP地址的解析是由分布在互联网上的许多域名服务器程序共同完成的。域名服务器在专设的结点上运行，而人们也常把运行域名服务器程序的机器称为域名服务器。<br>域名到IP地址的解析过程：</p>
<ul>
<li><strong>当某一个应用进程需要把主机名解析为IP地址时，该应用程序就调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。（使用UDP是为了减少开销）。本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用进程获得目的主机的IP地址后即可进行通信。</strong></li>
<li><strong>若本地域名服务器不能回答该请求，则此域名服务器就暂时成为DNS中的另一个客户，并向其他域名服务器发出查询请求。这种过程直至找到能够回答该请求的域名服务器为止。</strong></li>
</ul>
<p>互联网的域名结构</p>
<p>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。<br>每一个域名都由标号序列组成，而各标号之间用点隔开。</p>
<p><img src="/images/9113969-118ef4ef35fe4139.png" alt="img"></p>
<p>DNS规定，域名中的标号都由英文字母和数字组成，每一个标号不超过63个字符，也不区分大小写字母。级别最低的域名写在最左边，级别最高的顶级域名则卸载最右边。由多个标号组成的完整域名总共不超过255个字符。</p>
<p>域名服务器</p>
<p>实现域名系统则是使用分布在各地的域名服务器。<br>一个服务器所负责管辖的范围叫做区。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。DNS服务器的管辖范围不是以域为单位，而是以区为单位。</p>
<p><img src="/images/9113969-96d1fd46c3f96849.png" alt="å¾ç.png"></p>
<p>根据域名服务器所起的作用，可以把域名服务器划分为四种类型：根域名服务器、顶级域名服务器、权限域名服务器、本地域名服务器。</p>
<p><img src="/images/9113969-700b435ef0df7e96.png" alt="img"></p>
<p>为了提高DNS查询效率，并减轻根域名服务器的负荷和减少互联网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存。用来存放最近查询过的域名以及从何处获得域名映射信息的记录。<br>许多主机在启动时从本地域名服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。</p>
<p>FTP</p>
<p>文件传送协议FTP（File Transfer Protocol）[RFC 959]是互联网上使用得最广泛的文件传送协议。FTP提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效口令）。<br>FTP采用双TCP连接方式</p>
<ul>
<li>控制连接-使用TCP端口号21<br>用于在FTP客户端和FTP服务器之间传输FTP控制命令及命令执行信息。控制连接在整个FTP会话期间一直保持打开。</li>
<li>数据连接-使用TCP端口号20<br>用于传输数据，包括数据上传、下载、文件列表发送等。数据传输结束后数据连接将终止。</li>
</ul>
<p>FTP的基本工作原理</p>
<p>FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。<br>FTP使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。FTP的服务器进程由两大部分组成：一个<strong>主进程</strong>，负责接受新的请求；另外有若干个<strong>从属进程</strong>，负责处理单个请求。<br>在进程文件传输时，FTP的客户和服务器之间要建立两个并行的TCP连接：”控制连接”和”数据连接”。控制连接在整个会话期间一直保持打开，FTP客户机所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。实际用于传输文件的是”数据连接”。服务器端的控制进程在接收到FTP客户发送来的文件传输请求后就创建”数据传送进程”和”数据连接”，用来连接客户端和服务器的数据传送进程。</p>
<p><img src="/images/9113969-2aca321f2181c77b.png" alt="img"></p>
<p>NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。在网络上传送的只是少量修改的数据。</p>
<p>简单文件传送协议TFTP</p>
<p>TCP/IP协议族中还有一个简单文件传送协议TFTP（Trivial File Transfer Protocol），它是一个很小且易于实现的文件传送协议。<br>TFTP只支持文件传输而不支持文件交互。TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。<br>TFTP的两个主要优点：</p>
<ul>
<li>可用于UDP环境，例如当需要将程序或文件同时向许多机器下载时。</li>
<li>代码所占的内存较小。</li>
</ul>
<p>TFTP主要特点</p>
<ul>
<li>每次传送的数据报文中有512字节的数据，但最后一次可不足512字节。</li>
<li>数据报文按序编号，从1开始</li>
<li>支持ASCII码或二进制传送</li>
<li>可对文件进行读或者写</li>
<li>使用很简单的首部</li>
</ul>
<p>远程终端协议TELNET</p>
<p>TELNET是一个简单的远程终端协议。用户使用TELNET就可以在其所在地通过TCP连接注册（即登陆）到远地的另一台主机上。TELNET能将用户的击键传送远地主机，同时也能将远地主机的输出通过TCP连接返回到用户的屏幕。<br>TELNET能够适应许多计算机和操作系统的差异。</p>
<p><img src="/images/9113969-bce796f1f7bec35c.png" alt="å¾ç.png"></p>
<p>万维网</p>
<p><img src="/images/9113969-7150a52b3df77278.png" alt="img"></p>
<ul>
<li>万维网以客户服务器方式工作。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。</li>
<li>万维网使用统一资源定位符URL标志万维网上的各种文档，并使每个文档在整个互联网的范围内具有唯一的标识符URL。</li>
<li>为了实现万维网上的各种连接，就要使万维网客户程序与万维网服务器程序之间的交互遵守严格的协议，这就是超文本传送协议HTTP(HyperText Transfer Protocol)。HTTP是一个应用层协议，它使用TCP连接进行可靠的传送。</li>
<li>为了使不同的创作者创作的不同风格的万维网文档都能在互联网上的各种主机上显示出来，同时使用户知道在什么地方存在链接，万维网使用超文本传输语言HTML(HyperText Markup Language)使得万维网页面的设计者可以很方便的用链接从本页面的某处链接到互联网的任何一个万维网页面，并且能够在自己的主机屏幕上将这些页面显示出来。</li>
</ul>
<p>统一资源定位符URL</p>
<p>URL的格式<br>统一资源定位符URL是用来表示从互联网上得到的资源位置和访问这些资源的方法。<br>URL的一般形式由以下四个部分组成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</span><br></pre></td></tr></table></figure>

<p>超文本传输协议HTTP</p>
<p><strong>HTTP协议定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。</strong></p>
<p><img src="/images/9113969-8cd0810e951e7765.png" alt="å¾ç.png"></p>
<p>在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则。这些格式和规则就是超文本传输协议HTTP。<br>HTTP协议是本身无连接的，虽然HTTP使用了TCP连接，但通信的双方在交换HTTP报文之前不需要先建立HTTP连接。<br>HTTP协议是无状态的。<br>HTTP/1.0的主要缺点就是每请求一个文档就要有两倍RTT的开销。若一个主页上有一很多链接对象需要依次进行链接，那么每一次链接下载都导致2×RTT的开销。另一种开销就是万维网客户和服务器每一次建立新的TCP连接都要分配缓存和变量。这种<strong>非持续连接</strong>会使万维网服务器的负担很重。<br>HTTP/1.1协议使用了<strong>持续连接</strong>，就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。<br><strong>HTTP/1.1协议的持续连接有两种工作方式，即非流水线方式和流水线方式。</strong></p>
<p>代理服务器:<br>代理服务器是一种网络实体，它又称为<strong>万维网高速缓存</strong>。</p>
<p>HTTP报文结构</p>
<p><img src="/images/9113969-ce54ddd4eca202c4.png" alt="img"></p>
<p>电子邮件</p>
<p>电子邮件两个最重要的标准：简单邮件传送协议SMTP和互联网文本报文格式<br>由于互联网的SMTP只能传送可打印的7位ASCII码邮件，因此在1993年又提出了<strong>通用互联网邮件扩充MIME。</strong>MIME在其邮件首部中说明了邮件的数据类型（如文本、声音、图像、视像等）。在MIME邮件中可同时传送多种类型的数据。</p>
<p><img src="/images/9113969-3bddc3685e473ada.png" alt="img"></p>
<p>简单邮件传送协议SMTP</p>
<p>1、连接建立<br>发件人的邮件送到发送方邮件服务器的邮件缓存后，SMTP客户就每隔一段时间（例如30分钟）对邮件缓存扫描一次。如发现有邮件，就使用SMTP的端口25与接收方服务器的SMTP服务器建立TCP连接。连接建立后，接收方服务器要发送”220 Service ready”。然后SMTP向SMTP服务器发送HELO命令，附上发送方的主机名。SMTP服务器若有能力接收邮件，则回答”250 OK”，若SMTP服务器不可用，则回答”421 Service not available”。<br>SMTP服务器不使用中间的邮件服务器。<br>2、邮件传送<br>1）、邮件的传送从MAIL命令开始。MAIL命令后面有发件人的地址。如MAIL FROM：<code>&lt;test@163.com&gt;</code> 。服务器给出响应回应；</p>
<p>2）、接下来便是一个或多个RCPT命令，取决于把同一个邮件发送给一个或多个收件人，其格式为RCPT TO:&lt;收件人地址&gt;</p>
<p>3）、再接下来就是DATA命令，表示要开始传送邮件的内容了。SMTP服务器返回的信息是：354 Start mail input;end with . ；这里是回车换行的意思。发送完毕后，再发送.表示邮件内容结束。<br>3、连接释放<br>邮件发送完毕后，SMTP客户发送QUIT命令。SMTP服务器返回的信息是：221 服务关闭，表示SMTP同意释放TCP连接。邮件传送的全部过程即结束。</p>
<p>动态主机配置协议DHCP</p>
<p>互联网现在广泛使用的是动态主机配置协议DHCP，它提供了一种机制，称为即插即用连网。<br>DHCP使用客户服务器方式，需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文（将目的地址置为全1，即255.255.255.255），这时该主机就成为DHCP客户。发送广播报文是因为现在还不知道DHCP服务器在什么地方，因此要发现DHCP服务器的IP地址。这台主机目前还没有IP地址，因此它将IP数据报的源IP地址设为全0。在本地网络上的所有主机都会收到这个广播报文，但只有DHCP服务器才对此广播报文回答。DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。找不到则从服务器的IP地址池（address pool）中取一个地址分配给该计算机。DHCP的回答报文叫做提供报文（DHCPOFFER）。<br>每一个网络至少有一个<strong>DHCP中继代理</strong>（通常是一台路由器），它配置了DHCP服务器的IP地址信息。当DHCP中继代理收到主机A以广播形式发送的发现报文后，就以单播方式向DHCP服务器转发此报文，收到DHCP服务器回答的提供报文后，DHCP中继代理再把此提供报文发回给主机。</p>
<p><img src="/images/9113969-a591155500f4dd90.png" alt="img"></p>
<p>DHCP服务器分配给DHCP客户的IP地址是临时的。</p>
<p>应用进程跨域网络的通信:<br>如果我们还有一些特定的应用需要互联网的支持，但这些应用又不能直接使用已经标准化的互联网应用协议。那么就要了解<strong>系统调用</strong>和<strong>应用编程接口</strong>。</p>
<p>系统调用:<br>现在大多数的操作系统采用系统调用的机制在应用程序和操作系统之间转化控制权。例如应用程序要对一个文件进行操作，它不能直接去找那个文件然后操作。应用程序的进程首先要调用一个请求函数（系统调用）请求对这个文件的操作，操作系统进程得到此请求后会创建一个文件描述符（后面将详述）给应用程序进程，应用程序进程再根据系统提供的文件描述符去操作文件。</p>
<p>应用编程接口</p>
<p>应用编程接口（API）系统调用接口的另一种称呼。它定义了许多标准的应用接口函数供应用进程调用，以获得操作系统的服务。在网络编程中，应用进程与运输层协议（如 TCP、UDP、甚至SCTP）的接口就是套接字。</p>
<p><img src="/images/9113969-44594e1e2c79b80a.png" alt="img"></p>
<p><strong>套接字以上的进程是受应用程序控制的，而在套接字以下的运输层协议软件则是受计算机操作系统的控制。因此，只要应用程序使用TCP/IP协议进行通信，它就必须通过套接字与操作系统交互（这就要使用系统调用函数）并请求服务。</strong></p>
<p><img src="/images/9113969-5e2d23be1d3e567e.png" alt="img"></p>
<p>客户进程、服务器进程的通信</p>
<p><img src="/images/9113969-a5cdd992243269fa.png" alt="img"></p>
<p>以上是针对TCP连接的，由于UDP是不是面向连接的，所以不会有listen 和 accept。服务器进程虽然创建了套接字，但是其中的端口号和IP地址时空的，调用bind可以获取端口号和IP地址。客户端进程没有调用套接字，端口号随机分配。这其中最重要的就是accept的调用，当服务器主进程调用accept后，将会发生以下步骤：</p>
<ul>
<li>主进程为每一个新的连接请求新建一个套接字（连接套接字），以及创建一个从属进程；</li>
<li> 从属进程用新建的连接套接字与客户进程建立连接，然后在这个连接上传送和接受数据；</li>
<li>主进程利用原来的套接字重新调用accept，继续接受下一个连接请求。</li>
</ul>
<p>这样服务器就能同时处理多个连接，并发工作。</p>
<hr>
<h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考:"></a>资料参考:</h1><p><a target="_blank" rel="noopener" href="https://www.smi1e.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC7%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">计算机网络第7版读书笔记</a></p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>