<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av68608598/&quot;&gt;Redis视频教程&lt;/a&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>缓存Redis视频教程全集 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Redis/" rel="tag">Redis</a></div><div class="post-time">2019-11-16</div></div></div><div class="container post-header"><h1>缓存Redis视频教程全集</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80"><span class="toc-number">1.</span> <span class="toc-text">地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">数据库架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NoSQL"><span class="toc-number">1.2.</span> <span class="toc-text">NoSQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.</span> <span class="toc-text">Redis基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.4.</span> <span class="toc-text">String字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E5%88%97%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">List列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">1.6.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash"><span class="toc-number">1.7.</span> <span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zset"><span class="toc-number">1.8.</span> <span class="toc-text">Zset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6redis-config"><span class="toc-number">1.9.</span> <span class="toc-text">解析配置文件redis.config</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Units%E5%8D%95%E4%BD%8D"><span class="toc-number">1.9.1.</span> <span class="toc-text">Units单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INCLUDES%E5%8C%85%E5%90%AB"><span class="toc-number">1.9.2.</span> <span class="toc-text">INCLUDES包含</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GENERAL%E9%80%9A%E7%94%A8"><span class="toc-number">1.9.3.</span> <span class="toc-text">GENERAL通用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SNAPSHOTTING%E5%BF%AB%E7%85%A7"><span class="toc-number">1.9.4.</span> <span class="toc-text">SNAPSHOTTING快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REPLICATION%E5%A4%8D%E5%88%B6"><span class="toc-number">1.9.5.</span> <span class="toc-text">REPLICATION复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SECURITY%E5%AE%89%E5%85%A8"><span class="toc-number">1.9.6.</span> <span class="toc-text">SECURITY安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIMITS%E9%99%90%E5%88%B6"><span class="toc-number">1.9.7.</span> <span class="toc-text">LIMITS限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APPEND-ONLY-MOD-%E8%BF%BD%E5%8A%A0"><span class="toc-number">1.9.8.</span> <span class="toc-text">APPEND ONLY MOD 追加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.10.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-Redis-DataBase"><span class="toc-number">1.10.1.</span> <span class="toc-text">RDB(Redis DataBase)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">RDB是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">RDB怎么做</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">如何使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">如何停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#save%E5%92%8Cbgsave%E5%91%BD%E4%BB%A4"><span class="toc-number">1.10.1.5.</span> <span class="toc-text">save和bgsave命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flushall%E5%92%8Cshutdown%E5%91%BD%E4%BB%A4"><span class="toc-number">1.10.1.6.</span> <span class="toc-text">flushall和shutdown命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E5%8A%A3%E5%8A%BF"><span class="toc-number">1.10.1.7.</span> <span class="toc-text">优势劣势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-Append-Only-File"><span class="toc-number">1.10.2.</span> <span class="toc-text">AOF(Append Only File)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">AOF是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-%E6%81%A2%E5%A4%8D-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">启动&#x2F;恢复&#x2F;异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rewrite"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">rewrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86"><span class="toc-number">1.10.2.4.</span> <span class="toc-text">重写原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.2.5.</span> <span class="toc-text">重写触发机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E5%8A%A3%E5%8A%BF-1"><span class="toc-number">1.10.2.6.</span> <span class="toc-text">优势劣势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-Which-one"><span class="toc-number">1.10.3.</span> <span class="toc-text">总结(Which one)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.11.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.11.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">1.11.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.3.</span> <span class="toc-text">常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#case1%EF%BC%9A%E6%AD%A3%E5%B8%B8%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">case1：正常事务操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Case2%EF%BC%9A%E6%94%BE%E5%BC%83%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">Case2：放弃事务操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Case3%EF%BC%9A%E5%85%A8%E4%BD%93%E8%BF%9E%E5%9D%90"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">Case3：全体连坐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Case4%EF%BC%9A%E5%86%A4%E5%A4%B4%E5%80%BA%E4%B8%BB"><span class="toc-number">1.11.3.4.</span> <span class="toc-text">Case4：冤头债主</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Case5%EF%BC%9Awatch%E7%9B%91%E6%8E%A7%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.11.3.5.</span> <span class="toc-text">Case5：watch监控事务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.11.3.5.0.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.11.3.5.0.2.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CAS-Check-And-Set"><span class="toc-number">1.11.3.5.0.3.</span> <span class="toc-text">CAS(Check And Set)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%89%E9%98%B6%E6%AE%B5"><span class="toc-number">1.11.4.</span> <span class="toc-text">事务三阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-number">1.11.5.</span> <span class="toc-text">事务三特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">1.12.</span> <span class="toc-text">Redis的发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">1.12.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%91%BD%E4%BB%A4"><span class="toc-number">1.12.2.</span> <span class="toc-text">发布订阅命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%A4%8D%E5%88%B6-Master-Slave"><span class="toc-number">1.13.</span> <span class="toc-text">Redis的复制(Master&#x2F;Slave)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">1.13.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.2.</span> <span class="toc-text">主从复制与集群的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-1"><span class="toc-number">1.13.3.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">1.13.4.</span> <span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E4%BB%8E-%E5%BA%93-%E4%B8%8D%E9%85%8D%E4%B8%BB-%E5%BA%93"><span class="toc-number">1.13.4.1.</span> <span class="toc-text">配从(库)不配主(库)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.13.5.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">1.13.5.1.</span> <span class="toc-text">一主二从</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E6%9C%BA%E8%B7%9F%E9%9A%8F%E4%B8%BB%E6%9C%BA"><span class="toc-number">1.13.5.1.1.</span> <span class="toc-text">从机跟随主机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E4%B8%BB%E6%9C%BA%E8%83%BD%E5%86%99-%E4%BB%8E%E6%9C%BA%E4%B8%8D%E8%83%BD%E5%86%99"><span class="toc-number">1.13.5.1.2.</span> <span class="toc-text">只有主机能写,从机不能写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E4%BB%8E%E6%9C%BA%E8%BA%AB%E4%BB%BD%E5%8F%98%E5%8C%96"><span class="toc-number">1.13.5.1.3.</span> <span class="toc-text">主机从机身份变化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">1.13.5.2.</span> <span class="toc-text">薪火相传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">1.13.5.3.</span> <span class="toc-text">反客为主</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">1.13.6.</span> <span class="toc-text">复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-sentinel"><span class="toc-number">1.13.7.</span> <span class="toc-text">哨兵模式(sentinel)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">1.13.7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.13.7.2.</span> <span class="toc-text">使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E7%9B%91%E6%8E%A7%E5%A4%9A%E4%B8%AAMaster"><span class="toc-number">1.13.7.3.</span> <span class="toc-text">同时监控多个Master</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.13.8.</span> <span class="toc-text">复制的缺点</span></a></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av68608598/">Redis视频教程</a></p>
<p>DAL<br>dal是数据访问层的英文缩写，即为数据访问层（Data Access Layer）。<br>其功能主要是负责数据库的访问。简单地说就是实现对数据表的Select（查询）、Insert（插入）、Update（更新）、Delete（删除）等操作。</p>
<h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><p>最简单的数据库架构</p>
<p><img src="/images/1560694324080.png" alt="1560694324080"></p>
<p>上述架构下，我们来看看数据存储的瓶颈是什么？</p>
<ol>
<li>数据量的总大小一个机器放不下时</li>
<li>数据的索引（B+Tree）一个机器的内存放不下</li>
<li>访问量（读写混合,读和写都在同一库)一个实例不能承受</li>
</ol>
<p>Memcached(缓存)+MySQL+垂直拆分的架构</p>
<p><img src="/images/1560694618982.png" alt="1560694618982"></p>
<p>大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。<br>开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台Web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品</p>
<p>Mysql主从读写分离架构</p>
<ul>
<li>主从复制<br>(主库有什么操作,从库迅速跟随)</li>
<li>读写分离</li>
</ul>
<p>由于数据库的<strong>写入</strong>压力增加，Memcached只能缓解数据库的读取压力。<br>读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性.<br>Mysql的master-slave模式成为这个时候的网站标配了。</p>
<p><img src="/images/1560695019682.png" alt="1560695019682"></p>
<blockquote>
<p>简单来讲就是:<br>写的操作放在主库,读的操作都在从库去读</p>
</blockquote>
<p>分表分库+水平拆分+mysql集群架构</p>
<p>Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时 MySQL的主库的写压力开始出现瓶颈，而数据量的持续猛增，由于 MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发 MySQL应用开始使用<br>InnoDB引擎代替 MyISAM</p>
<p>同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然 MySQL推出了 MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p>
<p><img src="/images/1560695378719.png" alt="1560695378719"></p>
<h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>NoSQL:Not only SQL,<code>不仅仅是SQL</code>,泛指非关系型数据库</p>
<p>非关系型数据库的数据存储<strong>不需要固定的模式</strong>，无需多余操作就可以横向扩展。</p>
<blockquote>
<p>固定的模式:MySQL的一张表的字段总是固定的有限的</p>
</blockquote>
<ul>
<li>冷数据,不常改变的数据<br>使用MySQL</li>
<li>多文字类<br>使用MongDB</li>
<li>热点高频信息:<br>使用Redis</li>
</ul>
<p>NoSQL的四个分类:</p>
<ul>
<li>KV键值</li>
<li>文档型数据库</li>
<li>列存储数据库</li>
<li>图关系数据库</li>
</ul>
<p>传统的ACID:</p>
<ul>
<li>A(Atimicity):原子性</li>
<li>C(Consitency):一致性</li>
<li>I(Isolation):独立性</li>
<li>D(Durability):持久性</li>
</ul>
<blockquote>
<ul>
<li>原子性:<br>事务里的所有操作要么全部做完，要么都不做</li>
<li>一致性:<br>数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束</li>
<li>独立性:<br>并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。<br>比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元</li>
<li>持久性:<br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上出现岩机也不会丢失</li>
</ul>
</blockquote>
<p>NoSQL的CAP:</p>
<ul>
<li>C(Consistency):强一致性</li>
<li>A(Availability):可用性</li>
<li>P(Parition  tolerance):分区容错性</li>
</ul>
<blockquote>
<p>注意:NoSQL并不能同时做到上面三点,只能三选二.而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡.<br>现在大多数网站架构的选择都是AP</p>
<p>为什么都是选择AP:<br>对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多Web应用来说，并不要求这么高的实时性，比方说发一条消息之后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</p>
</blockquote>
<p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<ul>
<li>基本可用(Basically Available)</li>
<li>软状态(Soft state)</li>
<li>最终一致(Eventually consistent)</li>
</ul>
<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p>
<p>分布式和集群的区别:</p>
<ul>
<li>分布式：不同的多台服务器上面部署<strong>不同</strong>的服务模块（工程），他们之间通过RpC/Rmi之间信和调用，对外提供服务和组内协作。</li>
<li>集群：不同的多台服务器上面部署<strong>相同</strong>的服务模块、通过分布式调度软件进行统一的调度，对外提供服务和访问。</li>
</ul>
<h2 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到5号数据库</span></span><br><span class="line">select 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据库大小</span></span><br><span class="line">DBSIZE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询数据库的所有keys</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询以k开头的key</span></span><br><span class="line"><span class="comment"># 也可以使用keys k??</span></span><br><span class="line">keys k*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空当前数据库</span></span><br><span class="line">FLUSHDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空所有数据库</span></span><br><span class="line">FLUSHALL</span><br></pre></td></tr></table></figure>

<p><img src="/images/1560737187994.png" alt="1560737187994"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据键获取值:</span></span><br><span class="line">get key1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置:</span></span><br><span class="line"><span class="built_in">set</span> key2 val2</span><br></pre></td></tr></table></figure>

<p>Redis五大数据类型:</p>
<ul>
<li>字符串String</li>
<li>列表List</li>
<li>集合Set</li>
<li>哈希Hash</li>
<li>有序集合Zset(sorted set)</li>
</ul>
<blockquote>
<p><code>二进制安全</code>是什么?<br>比如Redis的String类型就是二进制安全的,意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象</p>
</blockquote>
<p>Key键:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询全部的键</span></span><br><span class="line">keys * </span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断某个key是否存在</span></span><br><span class="line">exists key1 key2 key3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将某个key1移动到3号数据库</span></span><br><span class="line">move key1 3</span><br><span class="line"></span><br><span class="line"><span class="comment">#为给定的key3设置10秒的过期时间</span></span><br><span class="line">expire key3 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看还有多少秒过期(-1为永不过期,-2为已过期)</span></span><br><span class="line"><span class="comment"># ttl -- time to live(生存时间)</span></span><br><span class="line">ttl key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除mykey的过期时间(变成永久)</span></span><br><span class="line">persist mykey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看key的类型</span></span><br><span class="line"><span class="built_in">type</span> key</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 <code>ttl key</code>可以检查任何不存在的键而不出错:<code>ttl 这是一个不存在的键</code>,得到<code>(integer) -2</code></p>
<p>同理,expire也可以给不存在的键设置过期时间(虽然没有效果,但是不会出错)</p>
<p>鉴于设置过期时间就可以删除数据,所以我们可以使用expire来实现删除功能:<br><code>expire mykey 0</code><br>当然,也可以使用<code>del mykey</code></p>
</blockquote>
<h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果key已经存在并且是一个字符串，APPEND 命令将 value 追加到 key 原来的值的末尾。</span></span><br><span class="line"><span class="comment"># 如果key不存在,APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。</span></span><br><span class="line">append mykey myvalue</span><br><span class="line"></span><br><span class="line"><span class="comment"># mykey的长度</span></span><br><span class="line">strlen mykey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加:incr</span></span><br><span class="line"><span class="comment"># 减少decr</span></span><br><span class="line"><span class="built_in">set</span> k2 2</span><br><span class="line">incr k2</span><br><span class="line"></span><br><span class="line"><span class="comment"># incrby:给k3增加5(为8)</span></span><br><span class="line"><span class="comment"># decrby</span></span><br><span class="line"><span class="built_in">set</span> k3 2</span><br><span class="line">incrby k3 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># getrange/setrange:获取指定区间范围内的值,类似于between..and..的关系</span></span><br><span class="line"><span class="built_in">set</span> k1 hyl456</span><br><span class="line">getrange k1 0 -1 <span class="comment"># hyl456</span></span><br><span class="line">getrange k1 0 3  <span class="comment"># hyl4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法:setrange key offset value</span></span><br><span class="line"><span class="comment"># setrange会覆盖原先的字符串</span></span><br><span class="line"><span class="built_in">set</span> k1 hyl456</span><br><span class="line">setrange k1 0 xxxxx <span class="comment"># xxxxx6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setex/setnx (set with expire/set if not exists)</span></span><br><span class="line"><span class="comment"># 语法:setex key seconds value</span></span><br><span class="line">setex  k4 10 v4</span><br><span class="line"><span class="comment"># 语法:setnx key value(如果存在则不会覆盖)</span></span><br><span class="line">setnx k4 v4</span><br><span class="line"></span><br><span class="line"><span class="comment"># mset/mget/msetnx(merge set/merge get/merge setnx)</span></span><br><span class="line"><span class="comment"># 合并创建/合并获取</span></span><br><span class="line">mset k1 v1 k2 v2</span><br><span class="line">mget k1 k2</span><br><span class="line"><span class="comment"># 1) &quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;v2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要有一个存在,就会全部失效</span></span><br><span class="line">mset k1 v1 k2 v2</span><br><span class="line">msetnx k1 V1 k2 V2 k3 V3</span><br><span class="line">mget k1 k2 k3</span><br><span class="line"><span class="comment"># 1) &quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;v2&quot;</span></span><br><span class="line"><span class="comment"># 3) (nil)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<code>msetnx</code>只要有一个key存在,那么就会全部失效</p>
</blockquote>
<h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#lpush/rpush/lrange</span></span><br><span class="line"><span class="comment"># 语法: lpush key v1 v2 v3</span></span><br><span class="line">lpush mylist 1 2 3 4 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于列表,不可以使用get获取,要使用lrange</span></span><br><span class="line"><span class="comment"># 语法:lrange key start stop</span></span><br><span class="line">lrange mylist 0 0 </span><br><span class="line"><span class="comment"># 1) &quot;5&quot;</span></span><br><span class="line">lrange mylist 0 -1</span><br><span class="line"><span class="comment"># 1) &quot;5&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;4&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;3&quot;</span></span><br><span class="line"><span class="comment"># 4) &quot;2&quot;</span></span><br><span class="line"><span class="comment"># 5) &quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lpop/rpop</span></span><br><span class="line">lpop mylist <span class="comment"># 5</span></span><br><span class="line">rpop mylist <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#lindx:按照索引下标获取元素</span></span><br><span class="line"><span class="comment"># 语法:lindex key index</span></span><br><span class="line">lindex mylist 0 <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">llen mylist <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法:lrem key count value</span></span><br><span class="line"><span class="comment"># 从表头开始,删除两个5</span></span><br><span class="line">lrem mylist 2 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># trim(修剪)让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</span></span><br><span class="line"><span class="comment"># 只保留idx为1到2的元素</span></span><br><span class="line">ltrim mylist 1 2 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法:rpoplpush source destination</span></span><br><span class="line">lpoplpush mylist mylist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法:lset key index value</span></span><br><span class="line"><span class="comment"># 将mylist中index为2的值设置为hh</span></span><br><span class="line">lset mylist 2 hh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法:linsert key before/after pivot vlaue</span></span><br><span class="line"><span class="comment"># 在mylist中,hh值的前面插入java</span></span><br><span class="line">linsert mylist before hh java</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:lindex这里的<code>l</code>和<code>lpush</code>的<code>l</code>是不一样的意思:<code>lindex</code>的代表<code>list</code>,<code>lpush</code>的l代表<code>left</code></p>
</blockquote>
<blockquote>
<p>lrem:<br>根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素</p>
<ul>
<li>count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。</li>
<li>count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。</li>
<li>count = 0 : 移除表中所有与 VALUE 相等的值。</li>
</ul>
<p>其中count的数量可以大于list中的数量</p>
</blockquote>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法:sadd key member1 member2...</span></span><br><span class="line"><span class="comment"># 语法:smembers key</span></span><br><span class="line"><span class="comment"># 语法:sismember key member</span></span><br><span class="line"><span class="comment"># 创建集合set1</span></span><br><span class="line">sadd set1 1 2 3 4 5 55 4 2 3</span><br><span class="line"><span class="comment"># 查看集合成员</span></span><br><span class="line">smember set1</span><br><span class="line"><span class="comment"># 判断是否为集合成员</span></span><br><span class="line">sismember set1 10000000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取集合里面的元素个数</span></span><br><span class="line">scard set1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除集合中的元素</span></span><br><span class="line"><span class="comment"># (如果set中包含java,不包含python,那只会删除java)</span></span><br><span class="line">srem set1 java python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集合set1中随机出5个数</span></span><br><span class="line">srandmember set1 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机出栈5个元素(如果set1少于5个则全部弹出)</span></span><br><span class="line">spop set1 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将key1中的值移动key2</span></span><br><span class="line">smove key1 key2 key1中的某个值</span><br><span class="line"></span><br><span class="line"><span class="comment"># sdiff差集</span></span><br><span class="line"><span class="comment"># sinter交集</span></span><br><span class="line"><span class="comment"># sunion并集</span></span><br><span class="line">sdiff key1 key2 key3</span><br></pre></td></tr></table></figure>



<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>KV模式不变,但是V是一个键值对</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hset/hget/hmset/hmget/hgetall/hdel</span></span><br><span class="line">hset user id 311600418</span><br><span class="line">hset user name hyl</span><br><span class="line">hset user phonne 6632678</span><br><span class="line"></span><br><span class="line">hget user id  <span class="comment"># 311600418</span></span><br><span class="line"></span><br><span class="line">hmset friend id 11 name czj age 21</span><br><span class="line">hmget friend id name age</span><br><span class="line"><span class="comment"># 1) &quot;11&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;czj&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;21&quot;</span></span><br><span class="line"></span><br><span class="line">hgetall friend</span><br><span class="line"><span class="comment"># 1) &quot;id&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;11&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;name&quot;</span></span><br><span class="line"><span class="comment"># 4) &quot;czj&quot;</span></span><br><span class="line"><span class="comment"># 5) &quot;age&quot;</span></span><br><span class="line"><span class="comment"># 6) &quot;21&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除user哈希表中的Key:name</span></span><br><span class="line">hdel user name</span><br><span class="line"></span><br><span class="line">hlen user</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在哈希表里是否存在的某个值key</span></span><br><span class="line">hexists friend id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希表的所有键/值</span></span><br><span class="line">hkeys friend</span><br><span class="line">hvals friend</span><br><span class="line"></span><br><span class="line"><span class="comment"># hincrby/hincrbyfloat</span></span><br><span class="line"><span class="comment"># 给哈希表friend的age键对应的值添加100</span></span><br><span class="line">hincrby friend age 100</span><br><span class="line">hincrbyfloat friend age 10000.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法:hsetnx key field value</span></span><br><span class="line">hsetnx friend shool gdgy</span><br></pre></td></tr></table></figure>



<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>在set基础上,加一个score值。之前set是k1 v1 v2 v3，现在zset是k1 score1 v1 score2 v2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zadd/zrange</span></span><br><span class="line">zadd zset1 60 v1 70 v2</span><br><span class="line">zrange zset1 0 -1</span><br><span class="line"><span class="comment"># 1) &quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;v2&quot;</span></span><br><span class="line"></span><br><span class="line">zrange zset1 0 -1 withscores</span><br><span class="line"><span class="comment"># 1) &quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;60&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;v2&quot;</span></span><br><span class="line"><span class="comment"># 4) &quot;70&quot;</span></span><br><span class="line"></span><br><span class="line">zrangebyscore zset1 20 200</span><br><span class="line"><span class="comment"># 1) &quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;v2&quot;</span></span><br><span class="line"></span><br><span class="line">zrangebyscore zset1 20 200 withscores</span><br><span class="line"><span class="comment"># 1) &quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;60&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;v2&quot;</span></span><br><span class="line"><span class="comment"># 4) &quot;70&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 70上限不在内</span></span><br><span class="line">zrangebyscore zset1 20 (70</span><br><span class="line"><span class="comment"># 1) &quot;v1&quot;</span></span><br><span class="line">zrangebyscore zset1 (60 (70</span><br><span class="line"><span class="comment"># (empty list or set)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第一个开始限制一个</span></span><br><span class="line">zrangebyscore zset1 20 200 <span class="built_in">limit</span> 1 1</span><br><span class="line"><span class="comment"># 1) &quot;v2&quot;</span></span><br><span class="line"><span class="comment"># 从第二个开始限制三个</span></span><br><span class="line">zrangebyscore zset1 20 200 <span class="built_in">limit</span> 2 3</span><br><span class="line"></span><br><span class="line">zrem zset1 v1 v2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看zset1数量</span></span><br><span class="line">zcard zset1</span><br><span class="line"><span class="comment"># 查看zset1分数在[20,40]的数量</span></span><br><span class="line">zcount zset1 20 40</span><br><span class="line"><span class="comment"># 区间为(20,40)</span></span><br><span class="line">zcount zset1 (20 (40</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意zrank排行从0开始</span></span><br><span class="line">zrange zset1 0 -1</span><br><span class="line"><span class="comment"># 1) &quot;v3&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;v4&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;v5&quot;</span></span><br><span class="line">zrank zset1 v3</span><br><span class="line"><span class="comment"># (integer) 0</span></span><br><span class="line">zrank zset1 v4</span><br><span class="line"><span class="comment"># (integer) 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># v3对应的分数</span></span><br><span class="line">zscore zset1 v3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆序的zrank(逆序获得下标值)</span></span><br><span class="line">zrevrank zset1 v3</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrevrange:逆序的zrank</span></span><br><span class="line">zrange zset1 0 -1</span><br><span class="line"><span class="comment"># 1) &quot;v3&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;v4&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;v5&quot;</span></span><br><span class="line">zrevrange zset1 0 -1</span><br><span class="line"><span class="comment"># 1) &quot;v5&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;v4&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;v3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># zrevrangebyscore:逆序的zrangebyscore</span></span><br><span class="line"><span class="comment"># 注意max和min的位置颠倒</span></span><br><span class="line">zrevrangebyscore zset1 90 30</span><br><span class="line"><span class="comment"># 1) &quot;v5&quot;</span></span><br><span class="line"><span class="comment"># 2) &quot;v4&quot;</span></span><br><span class="line"><span class="comment"># 3) &quot;v3&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="解析配置文件redis-config"><a href="#解析配置文件redis-config" class="headerlink" title="解析配置文件redis.config"></a>解析配置文件redis.config</h2><ol>
<li>Units单位</li>
<li>INCLUDES包含</li>
<li>GENERAL通用</li>
<li>SNAPSHOTTING快照</li>
<li>REPLICATION复制</li>
<li>SECURITY安全</li>
<li>LIMITS限制</li>
<li>APPEND ONLY MODE追加</li>
<li>常见配置 redis.conf介绍</li>
</ol>
<h3 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a>Units单位</h3><p>对于Redis来说,<code>1M</code>和<code>1MB</code>是不同的,同理,1k和1kb,1g和1gb都是不同的</p>
<ul>
<li>1m =&gt; 1000000 bytes</li>
<li>1mb =&gt; 1024*1024 bytes</li>
</ul>
<h3 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a>INCLUDES包含</h3><p>和Struts2配置文件类似，可以通过<code>includes 包含</code>，redis.conf可以作为总闸，<code>包含一个或多个其他配置文件。</code></p>
<h3 id="GENERAL通用"><a href="#GENERAL通用" class="headerlink" title="GENERAL通用"></a>GENERAL通用</h3><p>通用配置</p>
<ul>
<li><p>daemonize : 默认情况下，Redis不作为守护进程运行。如果需要，请使用“是”。</p>
<blockquote>
<p>daemonize  : <strong>独立于终端而存在的进程，不会因为终端结束而结束，一直伴随系统进程而存在，</strong>不设置成守护进程在后台运行，那么你退出终端后redis的进程也就终止了。</p>
</blockquote>
</li>
<li><p>bind : 绑定的IP , 默认127.0.0.1</p>
</li>
<li><p>port : 绑定端口 , 默认6379</p>
</li>
<li><p>protected-mode : 默认情况下，已启用保护模式。只有当您确定希望来自其他主机的客户机连接到Redis时（即使未配置身份验证）</p>
</li>
<li><p>tcp-backlog : 设置tcp的backlog</p>
<blockquote>
<ul>
<li>backlog其实是一个连接队列</li>
<li>backlog队列总和=未完成三次握手队列+已经完成三次握手队列。</li>
<li>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</li>
<li>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值</li>
<li>所以需要确认增大 somaxconn和 tcp_max_syn_backlog两个值来达到想要的效果</li>
</ul>
</blockquote>
</li>
<li><p>timeout : 在客户端空闲N秒后关闭连接（0表示禁用 , 一直连着,不关闭）</p>
</li>
<li><p>Tcp-keepalive : 单位为秒，如果设置为0，则不会进行 Keepalive检测，建议设置成60</p>
</li>
<li><p>loglevel : 日志级别</p>
</li>
<li><p>logfile : 日志文件</p>
</li>
<li><p>syslog-enabled : 是否开启系统日志(是否写入syslog) , 默认为NO</p>
</li>
<li><p>syslog-ident : 指定syslog里的日志标志(也就是日志内容的前缀)</p>
</li>
<li><p>databases : 数据表的数量</p>
</li>
</ul>
<h3 id="SNAPSHOTTING快照"><a href="#SNAPSHOTTING快照" class="headerlink" title="SNAPSHOTTING快照"></a>SNAPSHOTTING快照</h3><p>将数据库保存在磁盘上</p>
<ul>
<li><p>Save</p>
<ul>
<li><p>Redis默认配置文件中提供了三个条件：</p>
<ul>
<li>save 900 1</li>
<li>save 300 10</li>
<li>save 60 10000</li>
</ul>
</li>
<li><p>save 秒钟 写操作次数</p>
<p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，<br>默认<br>是1分钟内改了1万次，<br>或5分钟内改了10次，<br>或15分钟内改了1次。</p>
</li>
<li><p> 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。也就是说,生成快照的触发条件就是<code>900秒内有1个更改</code>或者<code>300秒内有10个更改</code>或者<code>60秒内有10000个更改</code></p>
</li>
<li><p>禁用</p>
<p>如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以</p>
<p><code>save &quot;&quot;</code>表示禁用RDB持久化的策略</p>
</li>
</ul>
</li>
<li><p>stop-writes-on-bgsave-error</p>
<p>如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制</p>
<blockquote>
<p><code>bgsave</code> : 即<code>background save</code> , 后台保存</p>
</blockquote>
</li>
<li><p>rdbcompression</p>
<p>rdbcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用<br>LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</p>
</li>
<li><p>rdbchecksum</p>
<p>rdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约<br>10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p>
</li>
<li><p>dbfilename</p>
<p>指定本地数据库文件名，默认值为dbfilename dump.rdb</p>
</li>
<li><p>dir ./ 指定本地数据库存放目录</p>
</li>
</ul>
<blockquote>
<p>save 和 bgsave的区别:</p>
<ul>
<li>save:save时只管保存，其它不管，<strong>全部阻塞</strong></li>
<li>BGSAVE:Reds会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间</li>
</ul>
</blockquote>
<h3 id="REPLICATION复制"><a href="#REPLICATION复制" class="headerlink" title="REPLICATION复制"></a>REPLICATION复制</h3><h3 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h3><p>访问密码的查看、设置和取消</p>
<ul>
<li><code> config get requirepass</code> 获取密码</li>
<li><code>config set requirepass &quot;123456&quot;</code> 设置密码</li>
<li><code>auth 123456</code> 登录</li>
</ul>
<h3 id="LIMITS限制"><a href="#LIMITS限制" class="headerlink" title="LIMITS限制"></a>LIMITS限制</h3><ul>
<li><p>maxclients : 一旦达到限制，Redis将关闭所有新连接，并发送一个错误“max number of clients reached”</p>
</li>
<li><p>maxmemory : 最大的内存</p>
</li>
<li><p>maxmemory-policy : 最大内存的策略(过期内存的移除策略)</p>
<blockquote>
<p>也就是说 , 当达到了最大内存 , 移除过期内存的策略</p>
<ol>
<li><code>volatile-lru</code> -&gt; 使用LRU算法移除key，只对设置了过期时间的键</li>
<li><code>allkeys-lru</code> -&gt; 使用LRU算法移除key , 对所有的Key(也就是说,只要你最近很少使用就移除)</li>
<li><code>volatile-random</code> -&gt; 在过期集合中移除随机的key，只对设置了过期时间的键</li>
<li><code>allkeys-random</code> -&gt; 移除随机的key </li>
<li><code>volatile-ttl</code> -&gt; 移除那些TTL值最小的key，即那些即将过期的key</li>
<li><code>noeviction</code> -&gt; 不进行移除。针对写操作，只是返回错误信息</li>
</ol>
</blockquote>
<blockquote>
<p><code>lru </code>: <code>Least Recently Used</code> 最近最少使用</p>
</blockquote>
</li>
<li><p>maxmemory-samples : 设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小 , redis默认会检查这么多个key并选择其中LRU的那个 . 默认为5</p>
</li>
</ul>
<h3 id="APPEND-ONLY-MOD-追加"><a href="#APPEND-ONLY-MOD-追加" class="headerlink" title="APPEND ONLY MOD 追加"></a>APPEND ONLY MOD 追加</h3><ul>
<li>appendonly : 是否开启AOF , 默认为No</li>
<li>appendfilename : 默认appendonly.aof</li>
<li>appendfsync<ul>
<li>always：同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li>
<li>everysec：出厂默认推荐，异步操作，每秒记录   如果一秒内宕机，有数据丢失</li>
<li>no : 不同步(阻塞)</li>
</ul>
</li>
<li>no-appendfsync-on-rewrite：重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。(NO即重写时阻塞进程)</li>
<li>auto-aof-rewrite-min-size：设置重写的基准值</li>
<li>auto-aof-rewrite-percentage：设置重写的基准值</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>redis.conf 配置项说明如下：</p>
<ol>
<li>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</li>
</ol>
<p>daemonize no</p>
<ol start="2">
<li>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</li>
</ol>
<p>pidfile /var/run/redis.pid</p>
<ol start="3">
<li><p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p>
</li>
<li><p>port 6379</p>
</li>
<li><p>绑定的主机地址 bind 127.0.0.1</p>
</li>
<li><p>timeout 300 当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 </p>
</li>
<li><p>loglevel verbose 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>
</li>
<li><p>logfile stdout 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>
</li>
<li><p>databases 16 设置数据库的数量，默认数据库为0，可以使用<code>SELECT &lt;dbid&gt;</code>命令在连接上指定数据库id</p>
</li>
<li><p><code>save &lt;seconds&gt; &lt;changes&gt;</code>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>
</li>
<li><p>Redis默认配置文件中提供了三个条件：</p>
<ul>
<li>save 900 1</li>
<li>save 300 10</li>
<li>save 60 10000</li>
</ul>
</li>
</ol>
<p> 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。也就是说,生成快照的触发条件就是<code>900秒内有1个更改</code>或者<code>300秒内有10个更改</code>或者<code>60秒内有10000个更改</code></p>
<p><code>save &quot;&quot;</code>表示禁用RDB持久化的策略</p>
<ol start="11">
<li><p>rdbcompression yes 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p>
</li>
<li><p>dump.rdb 指定本地数据库文件名，默认值为dbfilename dump.rdb</p>
</li>
<li><p>dir ./ 指定本地数据库存放目录</p>
</li>
<li><p><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>
</li>
<li><p><code>masterauth &lt;master-password&gt;</code>当master服务设置了密码保护时，slav服务连接master的密码</p>
</li>
<li><p><code>requirepass foobared</code> 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过<code>AUTH &lt;password&gt;</code>命令提供密码，默认关闭</p>
</li>
<li><p>maxclients 128 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>
</li>
<li><p><code>maxmemory &lt;bytes&gt;</code> 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p>
</li>
<li><p>appendonly no 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p>
</li>
<li><p>appendfilename appendonly.aof 指定更新日志文件名，默认为appendonly.aof</p>
</li>
<li><p>指定更新日志条件，共有3个可选值： </p>
<ul>
<li>no：表示等操作系统进行数据缓存同步到磁盘（快） </li>
<li>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </li>
<li>everysec：表示每秒同步一次（折衷，默认值）</li>
<li>appendfsync everysec</li>
</ul>
</li>
<li><p> vm-enabled no 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p>
</li>
<li><p>vm-swap-file /tmp/redis.swap 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p>
</li>
<li><p>vm-max-memory 0 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p>
</li>
<li><p>vm-page-size 32 Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>
</li>
<li><p>vm-pages 134217728 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p>
</li>
<li><p>vm-max-threads 4 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p>
</li>
<li><p>glueoutputbuf yes 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>
</li>
<li><p>hash-max-zipmap-entries 64  hash-max-zipmap-value 512 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>
</li>
<li><p>activerehashing yes 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p>
</li>
<li><p>include /path/to/local.conf 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p>
</li>
</ol>
</blockquote>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><ul>
<li>RDB:(Redis DataBase)</li>
<li>AOF(Append Only File)</li>
</ul>
<h3 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h3><h4 id="RDB是什么"><a href="#RDB是什么" class="headerlink" title="RDB是什么"></a>RDB是什么</h4><ul>
<li><strong>在指定的时间间隔内将内存中的数据集快照写入磁盘</strong>,也就是行话讲的 <code>Snapshot快照</code>，</li>
<li><strong>它恢复时是将快照文件直接读到内存里</strong></li>
</ul>
<h4 id="RDB怎么做"><a href="#RDB怎么做" class="headerlink" title="RDB怎么做"></a>RDB怎么做</h4><ul>
<li>Redis会单独创建（fork)一个子进程来进行持久化，会先将数据写入到个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件</li>
<li>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能.</li>
<li>如果需要进行大规模数据的恢复，且对于数据恢复的<strong>完整性不是非常敏感</strong>，那RDB方式要比AOF方式更加的高效.</li>
<li>RDB的缺点是最后一次持久化后的数据可能丢失</li>
</ul>
<p>eg:</p>
<ol>
<li>现在RDB时间设置为5min , 第一个5min就将内存中的数据块写入临时文件中 , </li>
<li>第二个5min后 , 这个内存数据块变得更大 , 再将这个内存数据块写入临时文件中(会覆盖掉原来的文件内容)</li>
</ol>
<blockquote>
<p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
</blockquote>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><ol>
<li>当我们redis所在目录中 ,存在<code>dump.rdb</code>文件的时候,就会自动将dump.rdb的内容重写写入内存数据库</li>
<li>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务就可以自动恢复数据</li>
</ol>
<h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><p>动态所有停止RDB保存规则的方法：<code>redis-cli config set save &quot;&quot;</code></p>
<h4 id="save和bgsave命令"><a href="#save和bgsave命令" class="headerlink" title="save和bgsave命令"></a>save和bgsave命令</h4><p>我们在redis命令行中可以调用<code>save</code>命令手动生成dump.rdb文件</p>
<ul>
<li>Save：save时只管保存，其它不管，全部阻塞</li>
<li>BGSAVE：Redis会在后台异步进行快照操作，<br>快照同时还可以响应客户端请求。可以通过lastsave<br>命令获取最后一次成功执行快照的时间</li>
</ul>
<h4 id="flushall和shutdown命令"><a href="#flushall和shutdown命令" class="headerlink" title="flushall和shutdown命令"></a>flushall和shutdown命令</h4><p>redis执行<code>shutdown</code> 或者<code>flushdb</code> 命令的时候 , 一样会生成<code>dump.rdb</code>文件(实际后台的操作就是 : 斩断内存,并且重新生成dump.rdb , 也就是说,此时的dump.rdb为空)</p>
<p>简单来说 : 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
<h4 id="优势劣势"><a href="#优势劣势" class="headerlink" title="优势劣势"></a>优势劣势</h4><ul>
<li>优势<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
</li>
<li>劣势<ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>
<li>fork的时候，内存中的数据被克隆了一份，导致大致2倍的膨胀性</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>RDB是一个非常紧凑的文件</li>
<li>RDB ,在保存RDB文件时父进程唯需要做的就是fork出一个子进程接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以<strong>RDB持久化方式可以最大化redis的性能</strong></li>
<li>与AOF相比在恢复大的数据集的时候，RDB方武会更快一些</li>
<li>数据丢失风险大</li>
<li>RDB需要经常fork子进程来保存数据集到硬盘上 , 当数据集比较大的时候fork的过程是非常耗时的 , 可能会导致redis在一些毫秒级不能相应客户端请求</li>
</ul>
</blockquote>
<h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><h4 id="AOF是什么"><a href="#AOF是什么" class="headerlink" title="AOF是什么"></a>AOF是什么</h4><ul>
<li>以日志的形式来记录每个<strong>写操作</strong>，将Redis执行过的所有写指令记录下来(读操作不记录)，</li>
<li>只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，</li>
<li>换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</li>
<li>Aof保存的是appendonly.aof文件</li>
</ul>
<h4 id="启动-恢复-异常处理"><a href="#启动-恢复-异常处理" class="headerlink" title="启动/恢复/异常处理"></a>启动/恢复/异常处理</h4><ul>
<li><p>启动AOF : conf里设置<code>appendonly yes</code></p>
</li>
<li><p>将有数据的aof文件复制一份保存到对应目录(config get dir)</p>
</li>
<li><p><code>appendonly.aof</code>和<code>dump.rdb</code>文件可以共存 , 如果两者都存在 , 首先加载<code>append.aof</code> .</p>
<blockquote>
<p>所以 , 如果应该机器错误导致<code>appendonly.aof</code>文件出错 , 那么此时redis将无法正常启动</p>
</blockquote>
</li>
<li><p>但redis因为<code>appendonly.aof</code>文件出错导致无法正常启动 , 就会生成<code>redis-benchmark</code> , <code>redis-check-aof</code> , <code>redis-check-dump</code>文件 , 此时我们可以执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure>

<p>进行修复</p>
<blockquote>
<p>当然也可以使用<code>redis-check-dump</code>文件进行修复</p>
</blockquote>
</li>
</ul>
<h4 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h4><ul>
<li>AOF采用文件追加方式，文件会越来越大 .为避免出现此种情况，新增了重写机制,</li>
<li>当AOF文件的大小超过所设定的阈值时，Redis就会<strong>启动AOF文件的内容压缩</strong>，只保留可以恢复数据的最小指令集.</li>
<li>可以使用命令bgrewriteaof</li>
</ul>
<h4 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h4><ul>
<li>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，</li>
<li><strong>重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</strong></li>
</ul>
<h4 id="重写触发机制"><a href="#重写触发机制" class="headerlink" title="重写触发机制"></a>重写触发机制</h4><ul>
<li>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</li>
<li>通过设置<code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 修改配置<ul>
<li>auto-aof-rewrite-min-size：设置重写的基准值 ,默认64mb</li>
<li>auto-aof-rewrite-percentage：设置重写的基准值 ,默认100</li>
</ul>
</li>
</ul>
<h4 id="优势劣势-1"><a href="#优势劣势-1" class="headerlink" title="优势劣势"></a>优势劣势</h4><ul>
<li>优势<ul>
<li>每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li>
<li>每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失(也就是说 , 最多丢失1秒的数据)</li>
<li>不同步：appendfsync no   不同步(阻塞)</li>
</ul>
</li>
<li>劣势<ul>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>AOF文件是一个只进行追加的日志文件</li>
<li>redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写</li>
<li>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis协议的格式保存，因此AOF文件的内容非常容被人读懂，对文件进行分析也很轻松</li>
<li>对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积</li>
<li>根据所使用的 fsync策略，AOF的速度可能会慢于RDB</li>
</ul>
</blockquote>
<h3 id="总结-Which-one"><a href="#总结-Which-one" class="headerlink" title="总结(Which one)"></a>总结(Which one)</h3><ul>
<li><p>RDB持久化方式能够在<strong>指定的时间间隔能对你的数据进行快照存储</strong></p>
</li>
<li><p>AOF持久化方式记录每次对服务器写的操作</p>
</li>
<li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p>
</li>
<li><p>同时开启两种持久化方式</p>
<ul>
<li>在这种情况下,当<strong>redis重启的时候会优先载入AOF文件来恢复原始的数据</strong>,<br>因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？<br>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ul>
</li>
<li><p>性能建议</p>
<ul>
<li><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p>
</li>
<li><p>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单 , 只load自己的AOF文件就可以了。</p>
<ul>
<li>代价一 : 带来了持续的IO，</li>
<li>代价二 : rewrite使用异步 , 但是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的</li>
</ul>
<blockquote>
<p>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</p>
</blockquote>
</li>
<li><p>如果不使用 AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时down掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。</p>
</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>可以一次执行多个命令，<strong>本质是一组命令的集合。</strong>一个事务中的所有命令都会序列化，<strong>按顺序地串行化执行</strong>而不会被其它命令插入，不许加塞</p>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>一个队列中，一次性、顺序性、排他性的执行一系列命令</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DISCARD</td>
<td>取消事务 , 放弃执行事务快内的所有命令</td>
</tr>
<tr>
<td>EXEC</td>
<td>执行事务块内的所有命令</td>
</tr>
<tr>
<td>MULTI</td>
<td>标记一个事务块的开始</td>
</tr>
<tr>
<td>UNWATCH</td>
<td>取消WATCH命令对所有key的监视</td>
</tr>
<tr>
<td>WATCH key [key….]</td>
<td>监视一个(或多个key) , 如果在事务执行之前这个(或者写)key被其他命令所改动,那么事务将被打断</td>
</tr>
</tbody></table>
<h4 id="case1：正常事务操作"><a href="#case1：正常事务操作" class="headerlink" title="case1：正常事务操作"></a>case1：正常事务操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MUTIL</span><br><span class="line"><span class="built_in">set</span> k1 v1</span><br><span class="line">get k2</span><br><span class="line"><span class="built_in">set</span> k3 v3</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<h4 id="Case2：放弃事务操作"><a href="#Case2：放弃事务操作" class="headerlink" title="Case2：放弃事务操作"></a>Case2：放弃事务操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MUTIL</span><br><span class="line"><span class="built_in">set</span> k1 v1</span><br><span class="line">get k2</span><br><span class="line"><span class="built_in">set</span> k3 v3</span><br><span class="line">DISCARD</span><br></pre></td></tr></table></figure>



<h4 id="Case3：全体连坐"><a href="#Case3：全体连坐" class="headerlink" title="Case3：全体连坐"></a>Case3：全体连坐</h4><p>事务中只要有一个命令有<code>语法错误</code> ,全部操作都会失效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MUTIL</span><br><span class="line"><span class="built_in">set</span> k1 v1</span><br><span class="line"><span class="built_in">set</span> k2 v2</span><br><span class="line">getset k3 <span class="comment"># 语法错误,没有getset命令</span></span><br><span class="line"><span class="built_in">set</span> k4 v4</span><br><span class="line">EXEC  <span class="comment"># EXECABORT </span></span><br><span class="line"></span><br><span class="line">get k4 <span class="comment"># nil</span></span><br></pre></td></tr></table></figure>



<h4 id="Case4：冤头债主"><a href="#Case4：冤头债主" class="headerlink" title="Case4：冤头债主"></a>Case4：冤头债主</h4><p>事务中如果有一个命令有<code>执行错误</code> , 那么只有这个命令会失效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> k1 aa</span><br><span class="line"></span><br><span class="line">MUTIL</span><br><span class="line">inc k1  <span class="comment"># 语法是正确的,但是执行会出错(因为aa是字符串,不能inc)</span></span><br><span class="line"><span class="built_in">set</span> k2 v2</span><br><span class="line">EXEC </span><br><span class="line"></span><br><span class="line">get k2 <span class="comment"># v2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Case3 : 全体连坐</code> 和 <code>Case4 : 冤头债主</code>的区别:</p>
<ol>
<li>Case3 是语法错误</li>
<li>Case4 是执行错误</li>
</ol>
<p>因为使用事务 , redis会先将命令存入Queue , 然后再一起执行 , </p>
<ul>
<li>所以,只要是语法正确的都会入队</li>
<li>语法错误则一开始就无法入队</li>
</ul>
<p>简单来说 , <code>执行错误</code>只有在运行的时候才能发现错误 , <code>语法错误</code>一开始就能检测的到</p>
</blockquote>
<p>所以得到 : <strong>redis对事物的支持是部分支持</strong></p>
<h4 id="Case5：watch监控事务"><a href="#Case5：watch监控事务" class="headerlink" title="Case5：watch监控事务"></a>Case5：watch监控事务</h4><p>缓存的数据大家都来拿  , 而对于关键数据则不希望被修改 , 这是就需要监控这些数据</p>
<h6 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h6><ul>
<li>悲观锁(Pessimistic Lock)顾名思义，就是很悲观，<strong>每次去拿数据的时候都认为别人会修改</strong>，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</li>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如<code>行锁</code>，<code>表锁</code>等，<code>读锁</code>，<code>写锁</code>等，都是在做操作之前先上锁</li>
</ul>
<h6 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h6><ul>
<li>乐观锁(Optimistic Lock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</li>
<li>乐观锁适用于多读的应用类型，这样可以提高吞吐量</li>
</ul>
<blockquote>
<p>乐观锁策略 : <strong>提交版本必须大于记录当前版本才能执行更新</strong></p>
</blockquote>
<h6 id="CAS-Check-And-Set"><a href="#CAS-Check-And-Set" class="headerlink" title="CAS(Check And Set)"></a>CAS(Check And Set)</h6><blockquote>
<ul>
<li>watch : 监视一个(或多个)key , 如果在事务<code>执行</code>(也就是<code>EXEC</code>)之前这个key被其他命令所改动,那么事务将被打断</li>
<li>在 Redis 中使用 <strong>watch 命令可以决定事务是执行还是回滚。</strong></li>
<li><strong>当 Redis 使用 exec 命令执行事务的时候，它首先会去比对被 watch 命令所监控的键值对，如果没有发生变化，那么它会执行事务队列中的命令，提交事务；如果发生变化，那么它不会执行任何事务中的命令，而去事务回滚。</strong></li>
</ul>
<p><img src="/images/5-1ZH4122J5538.png" alt="Redis执行事务过程"></p>
</blockquote>
<p>以信用卡<code>可用余额</code>(目前还可以透支消费的额度)和<code>欠额</code>为例 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一开始可用余额100,欠额0</span></span><br><span class="line"><span class="built_in">set</span> balance 100</span><br><span class="line"><span class="built_in">set</span> debt 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控balance</span></span><br><span class="line">WATCH balance</span><br><span class="line">MUTIL</span><br><span class="line">decrby balance 20</span><br><span class="line">incby debt 20</span><br><span class="line">EXEC</span><br><span class="line"><span class="comment"># (integer 80)</span></span><br><span class="line"><span class="comment"># (integer 20)</span></span><br></pre></td></tr></table></figure>



<p>小结</p>
<ul>
<li>Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行</li>
<li>通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，<br>EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败</li>
</ul>
<h3 id="事务三阶段"><a href="#事务三阶段" class="headerlink" title="事务三阶段"></a>事务三阶段</h3><ul>
<li>开启：以MULTI开始一个事务</li>
<li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li>
<li>执行：由EXEC命令触发事务</li>
</ul>
<h3 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h3><ul>
<li>单独的隔离操作：<br>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>没有隔离级别的概念：<br>队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在<code>事务内的查询要看到事务里的更新，在事务外查询不能看到</code>这个让人万分头痛的问题</li>
<li>不保证原子性：<br>redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
<h2 id="Redis的发布订阅"><a href="#Redis的发布订阅" class="headerlink" title="Redis的发布订阅"></a>Redis的发布订阅</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</li>
<li>订阅/发布消息图</li>
</ul>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="/images/pubsub1.png" alt="img"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="/images/pubsub2.png" alt="img"></p>
<h3 id="发布订阅命令"><a href="#发布订阅命令" class="headerlink" title="发布订阅命令"></a>发布订阅命令</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PSUBSCRIBE pattern [pattern …]</td>
<td align="left">订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td align="left">PUBSUB subcommand [argument [argument …]]</td>
<td align="left">查看订阅与发布系统状态。</td>
</tr>
<tr>
<td align="left">PUBLISH channel message</td>
<td align="left">将信息发送到指定的频道。</td>
</tr>
<tr>
<td align="left">PUNSUBSCRIBE [pattern [pattern …]]</td>
<td align="left">退订所有给定模式的频道。</td>
</tr>
<tr>
<td align="left">SUBSCRIBE channel [channel …]</td>
<td align="left">订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td align="left">UNSUBSCRIBE [channel [channel …]]</td>
<td align="left">指退订给定的频道。</td>
</tr>
</tbody></table>
<p>先订阅后发布后才能收到消息，</p>
<p>示例一 : </p>
<ol>
<li>可以一次性订阅多个，<code>SUBSCRIBE c1 c2 c3</code></li>
<li>消息发布，<code>PUBLISH c2 hello-redis</code></li>
</ol>
<p>示例二 : </p>
<ol>
<li>订阅多个，通配符*， <code>PSUBSCRIBE new*</code></li>
<li>收取消息， <code>PUBLISH new1 redis2015</code></li>
</ol>
<h2 id="Redis的复制-Master-Slave"><a href="#Redis的复制-Master-Slave" class="headerlink" title="Redis的复制(Master/Slave)"></a>Redis的复制(Master/Slave)</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>也就是我们所说的<code>主从复制</code>，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，<code>Master以写为主</code>，<code>Slave以读为主</code></p>
<p>设备分为主设备和从设备，</p>
<ul>
<li>主设备负责分配工作并整合结果，或作为指令的来源；</li>
<li>从设备负责完成工作，一般只能和主设备通信</li>
</ul>
<blockquote>
<p>核心思想是基于分而治之的思想,将一个原始任务分解为若干个语义等同的子任务,并由专门的工作者线程来并行执行这些任务,原始任务的结果是通过整合各个子任务的处理结果形成的</p>
</blockquote>
<blockquote>
<p>说人话 :</p>
<ul>
<li>为了数据完整性,容灾备份 , 当主数据库插入数据的时候 , 从数据库立马随着也插一条</li>
<li>主数据库以写为主 , 从数据库以读为主 </li>
</ul>
<p>所以是 : <strong>以主从复制技术来达到读写分离的效果</strong></p>
</blockquote>
<h3 id="主从复制与集群的区别"><a href="#主从复制与集群的区别" class="headerlink" title="主从复制与集群的区别"></a>主从复制与集群的区别</h3><p>最本质的区别，其实也就是data-sharing和nothing-sharing的区别。</p>
<ul>
<li>集群是共享存储的。</li>
<li>主从复制中没有任何共享。每台机器都是独立且完整的系统。</li>
</ul>
<h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li>读写分离</li>
</ul>
<blockquote>
<ol>
<li><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。</p>
</li>
<li><p>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p>
</li>
<li><p>读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p>
</li>
</ol>
</blockquote>
<ul>
<li>容灾恢复</li>
</ul>
<blockquote>
<ul>
<li>容灾系统是指在相隔较远的异地，建立两套或多套功能相同的IT系统，互相之间可以进行健康状态监视和功能切换，当一处系统因意外（如火灾、地震等）停止工作时，整个应用系统可以切换到另一处，使得该系统功能可以继续正常工作。</li>
<li>容灾技术是系统的高可用性技术的一个组成部分，容灾系统更加强调处理外界环境对系统的影响，特别是灾难性事件对整个IT节点的影响，提供节点级别的系统恢复功能。</li>
</ul>
</blockquote>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="配从-库-不配主-库"><a href="#配从-库-不配主-库" class="headerlink" title="配从(库)不配主(库)"></a>配从(库)不配主(库)</h4><p>从库配置：<code>slaveof 主库IP 主库端口</code> </p>
<ul>
<li><p>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</p>
</li>
<li><p>eg : <code>slaveof 127.0.0.1 6379</code></p>
</li>
</ul>
<p>事前准备</p>
<ol>
<li>制作三个redis.conf , </li>
<li>设置daemonize yes,</li>
<li>设置端口为6379,6380,6381</li>
<li>开启三个redis进程</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h4><h5 id="从机跟随主机"><a href="#从机跟随主机" class="headerlink" title="从机跟随主机"></a>从机跟随主机</h5><blockquote>
<p>从机数据和主机数据永远会保持一致</p>
</blockquote>
<p><code>info replication</code> : 查看主从复制的相关属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置6379redis的值</span></span><br><span class="line"><span class="built_in">set</span> name hyl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置6380redis,6381redis为6379的从机</span></span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在6380redis,6381redis获取值</span></span><br><span class="line">get name <span class="comment">#hyl</span></span><br></pre></td></tr></table></figure>



<h5 id="只有主机能写-从机不能写"><a href="#只有主机能写-从机不能写" class="headerlink" title="只有主机能写,从机不能写"></a>只有主机能写,从机不能写</h5><p>现在<code>主机</code>执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> num 1</span><br></pre></td></tr></table></figure>

<p><code>从机</code>执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> num 2</span><br></pre></td></tr></table></figure>

<p>是不可以的 , <code>读写分离</code> , 顾名思义,<strong>只有主机能写,从机不能写</strong></p>
<h5 id="主机从机身份变化"><a href="#主机从机身份变化" class="headerlink" title="主机从机身份变化"></a>主机从机身份变化</h5><p>现在有一台主机 , 两台从机 .</p>
<ol>
<li><p>如果主机挂了 , 那么两台从机在原地待命(也就是从机还是从机,不会变成主机)</p>
<p>之后主机重新上线 , 那么就是<code>视为无事发生</code>,</p>
</li>
<li><p>如果从机挂了 , 之后从机重新上线 , 那么<strong>这台从机将变成主机</strong>(除非将设置写入配置文件)</p>
<blockquote>
<p>每次与master断开之后，都需要重新连接 (重新执行<code>slaveof 127.0.0.1 6379</code>)，除非你配置进redis.conf文件</p>
</blockquote>
</li>
<li><p>原因 : 执行<code>slaveof 127.0.0.1 6379</code> 其实就是<strong>设置了这台主机的master属性</strong> , </p>
<ul>
<li>这个属性不会跟着主机的下线而改变(也就是不会<code>从机上位</code>)</li>
<li>但是这个属性会跟着从机的下线而消失(废话 , 对象都消失了,属性自然跟着消失)</li>
<li>如果我们将属性配置进redis.conf文件 , 那么每次生成新的redis对象时,就会自动设置它的maser属性,进而变成从机</li>
</ul>
</li>
</ol>
<h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><ul>
<li>我们可以一主二从 , 也可以一主多从 , 但是这样会造成<code>中心化</code>太严重.</li>
<li>所以我们可以设置<code>从机的从机</code> , 实现<code>去中心化</code></li>
<li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力</li>
</ul>
<p><img src="/images/1573901747414.png" alt="1573901747414"></p>
<blockquote>
<p>去中心化的缺陷</p>
<ol>
<li>数据在传递过程中的失真</li>
<li>复制延时 , 数据传递速度慢</li>
</ol>
</blockquote>
<ul>
<li>中途变更转向:会清除之前的数据，重新建立拷贝最新的</li>
<li>命令<code>slaveof 新主库IP 新主库端口</code></li>
</ul>
<h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><p>命令 :<code>SLAVEOF no one</code> 使当前数据库停止与其他数据库的同步，转成主数据库</p>
<ol>
<li>6379是主机 , 下面有6380,6381两个从机</li>
<li>6379挂了 , 6380执行<code>SALVEOF on one</code> , 那么6380变成主机</li>
<li><strong>此时的6381依旧是从机 ,他的领导依旧是6379</strong></li>
</ol>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul>
<li>slave启动成功连接到master后, slave会发送一个<code>sync</code>命令</li>
<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave,以完成一次完全同步</strong></li>
<li><code>全量复制</code>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li><code>增量复制</code>：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<blockquote>
<p>简单来说就是 :</p>
<ol>
<li>当slave首次执行<code>slaveof</code>命令,就执行一次<code>全量复制</code></li>
<li>之后每次slave的更新 , 都是<code>增量复制</code></li>
</ol>
</blockquote>
<h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a>哨兵模式(sentinel)</h3><h4 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h4><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul>
<li><p>主机6379下面带着6380、6381两个从机</p>
</li>
<li><p>/redis目录下新建<code>sentinel.conf</code>文件</p>
</li>
<li><p>配置哨兵,填写内容</p>
<ul>
<li>sentinel monitor 被监控数据库名字(名字随便取) 127.0.0.1 6379 1</li>
<li>上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机(谁的票数多于一票谁就是新的老大)</li>
</ul>
<blockquote>
<p>简单来说 , <code>sentinel.conf</code>需要两个配置</p>
<ol>
<li>监控哪个主机</li>
<li>如果主机挂了 , 投票选举的方式</li>
</ol>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor my_master_redis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>启动哨兵</p>
<ul>
<li>命令 : <code>redis-sentinel /redis/sentinel.conf </code></li>
<li>上述目录依照各自的实际情况配置，可能目录不同</li>
</ul>
</li>
<li><p>问题：如果之前的master重启回来，会不会双master冲突？</p>
<blockquote>
<p>老领导重新上线回来之后 , 就不再是领导了 , <strong>直接变成从机</strong></p>
</blockquote>
</li>
</ul>
<h4 id="同时监控多个Master"><a href="#同时监控多个Master" class="headerlink" title="同时监控多个Master"></a>同时监控多个Master</h4><p>一组sentinel能同时监控多个Master , 这样就支持了<code>去中心化</code>的架构设计</p>
<h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>