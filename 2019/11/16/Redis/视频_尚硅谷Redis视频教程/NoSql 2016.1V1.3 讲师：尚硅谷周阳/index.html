<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;NoSql&quot;&gt;&lt;a href=&quot;#NoSql&quot; class=&quot;headerlink&quot; title=&quot;NoSql&quot;&gt;&lt;/a&gt;NoSql&lt;/h1&gt;&lt;p&gt;2016.1V1.3&lt;br&gt;讲师：尚硅谷周阳"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>NoSql 2016.1V1.3 讲师：尚硅谷周阳 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Redis/" rel="tag">Redis</a></div><div class="post-time">2019-11-16</div></div></div><div class="container post-header"><h1>NoSql 2016.1V1.3 讲师：尚硅谷周阳</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NoSql"><span class="toc-number">1.</span> <span class="toc-text">NoSql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NoSql%E5%85%A5%E9%97%A8%E5%92%8C%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">NoSql入门和概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">入门概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3V-3%E9%AB%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">3V+3高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E4%B8%8B%E7%9A%84NoSQL%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">当下的NoSQL经典应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">NoSQL数据模型简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.5.</span> <span class="toc-text">NoSQL数据库的四大分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADCAP%E5%8E%9F%E7%90%86CAP-BASE"><span class="toc-number">1.1.6.</span> <span class="toc-text">在分布式数据库中CAP原理CAP+BASE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">Redis入门介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">入门概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VMWare-VMTools%E5%8D%83%E9%87%8C%E4%B9%8B%E8%A1%8C%E5%A7%8B%E4%BA%8E%E8%B6%B3%E4%B8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">VMWare+VMTools千里之行始于足下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.3.</span> <span class="toc-text">Redis的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%90%AF%E5%8A%A8%E5%90%8E%E6%9D%82%E9%A1%B9%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">Redis启动后杂项基础知识讲解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Redis数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">Redis的五大数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E9%87%8C%E5%8E%BB%E8%8E%B7%E5%BE%97redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">哪里去获得redis常见数据类型操作命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E9%94%AE-key"><span class="toc-number">1.3.3.</span> <span class="toc-text">Redis 键(key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="toc-number">1.3.4.</span> <span class="toc-text">Redis字符串(String)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%97%E8%A1%A8-List"><span class="toc-number">1.3.5.</span> <span class="toc-text">Redis列表(List)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E5%90%88-Set"><span class="toc-number">1.3.6.</span> <span class="toc-text">Redis集合(Set)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%93%88%E5%B8%8C-Hash"><span class="toc-number">1.3.7.</span> <span class="toc-text">Redis哈希(Hash)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88Zset-sorted-set"><span class="toc-number">1.3.8.</span> <span class="toc-text">Redis有序集合Zset(sorted set)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">解析配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%83%E5%9C%A8%E5%93%AA"><span class="toc-number">1.4.1.</span> <span class="toc-text">它在哪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#units%E5%8D%95%E4%BD%8D"><span class="toc-number">1.4.2.</span> <span class="toc-text">units单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INCLUDES%E5%8C%85%E5%90%AB"><span class="toc-number">1.4.3.</span> <span class="toc-text">INCLUDES包含</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GENERAL%E9%80%9A%E7%94%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">GENERAL通用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SNAPSHOTTING%E5%BF%AB%E7%85%A7"><span class="toc-number">1.4.5.</span> <span class="toc-text">SNAPSHOTTING快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REPLICATION%E5%A4%8D%E5%88%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">REPLICATION复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SECURITY%E5%AE%89%E5%85%A8"><span class="toc-number">1.4.7.</span> <span class="toc-text">SECURITY安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIMITS%E9%99%90%E5%88%B6"><span class="toc-number">1.4.8.</span> <span class="toc-text">LIMITS限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APPEND-ONLY-MODE%E8%BF%BD%E5%8A%A0"><span class="toc-number">1.4.9.</span> <span class="toc-text">APPEND ONLY MODE追加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AEredis-conf%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.10.</span> <span class="toc-text">常见配置redis.conf介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">redis的持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">总体介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%EF%BC%88Redis-DataBase%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">RDB（Redis DataBase）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%EF%BC%88Append-Only-File%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">AOF（Append Only File）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-Which-one"><span class="toc-number">1.5.4.</span> <span class="toc-text">总结(Which one)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.</span> <span class="toc-text">Redis的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">1.6.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%8E%A9"><span class="toc-number">1.6.3.</span> <span class="toc-text">怎么玩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E9%98%B6%E6%AE%B5"><span class="toc-number">1.6.4.</span> <span class="toc-text">3阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.5.</span> <span class="toc-text">3特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">1.7.</span> <span class="toc-text">Redis的发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">1.7.2.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E5%88%97"><span class="toc-number">1.7.3.</span> <span class="toc-text">案列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%EF%BC%8CPUBLISH-c2-hello-redis"><span class="toc-number">2.</span> <span class="toc-text">2 消息发布，PUBLISH c2 hello-redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%A4%8D%E5%88%B6-Master-Slave"><span class="toc-number">2.1.</span> <span class="toc-text">Redis的复制(Master&#x2F;Slave)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">2.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B-1"><span class="toc-number">2.1.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%8E%A9-1"><span class="toc-number">2.1.3.</span> <span class="toc-text">怎么玩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.4.</span> <span class="toc-text">复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-sentinel"><span class="toc-number">2.1.5.</span> <span class="toc-text">哨兵模式(sentinel)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.6.</span> <span class="toc-text">复制的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AFJedis"><span class="toc-number">2.2.</span> <span class="toc-text">Redis的Java客户端Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85JDK"><span class="toc-number">2.2.1.</span> <span class="toc-text">安装JDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85eclipse"><span class="toc-number">2.2.2.</span> <span class="toc-text">安装eclipse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84jar%E5%8C%85"><span class="toc-number">2.2.3.</span> <span class="toc-text">Jedis所需要的jar包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.</span> <span class="toc-text">Jedis常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JedisPool"><span class="toc-number">2.2.5.</span> <span class="toc-text">JedisPool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lifo%EF%BC%9AborrowObject%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E6%98%AF%E9%87%87%E7%94%A8DEFAULT-LIFO%EF%BC%88last-in-first-out%EF%BC%8C%E5%8D%B3%E7%B1%BB%E4%BC%BCcache%E7%9A%84%E6%9C%80%E9%A2%91%E7%B9%81%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%EF%BC%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%BAFalse%EF%BC%8C%E5%88%99%E8%A1%A8%E7%A4%BAFIFO%E9%98%9F%E5%88%97%EF%BC%9B"><span class="toc-number">3.</span> <span class="toc-text">lifo：borrowObject返回对象时，是采用DEFAULT_LIFO（last in first out，即类似cache的最频繁使用队列），如果为False，则表示FIFO队列；</span></a></li></ol></details></div><div class="container post-content"><h1 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a>NoSql</h1><p>2016.1V1.3<br>讲师：尚硅谷周阳</p>
<h2 id="NoSql入门和概述"><a href="#NoSql入门和概述" class="headerlink" title="NoSql入门和概述"></a>NoSql入门和概述</h2><h3 id="入门概述"><a href="#入门概述" class="headerlink" title="入门概述"></a>入门概述</h3><ul>
<li><p>1 互联网时代背景下<br>大机遇，为什么用nosql</p>
<ul>
<li><p>1单机MySQL的美好年代</p>
<p>在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。<br>在那个时候，更多的都是静态网页，动态交互类型的网站不多。<br>上述架构下，我们来看看数据存储的瓶颈是什么？<br>1.数据量的总大小 一个机器放不下时<br>2.数据的索引（B+ Tree）一个机器的内存放不下时<br>3.访问量(读写混合)一个实例不能承受<br> 如果满足了上述1 or 3个，进化……</p>
</li>
<li><p>2 Memcached(缓存)+MySQL+垂直拆分</p>
<p>后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注在功能上，同时也在追求性能。程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品。<br> Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端</p>
</li>
<li><p>3 Mysql主从读写分离</p>
<p>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。</p>
</li>
<li><p>4 分表分库+水平拆分+mysql集群 </p>
<p>在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。<br> 同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p>
</li>
<li><p>5 MySQL的扩展性瓶颈</p>
<p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</p>
</li>
<li><p>6 今天是什么样子？？</p>
</li>
<li><p>7 为什么用NoSQL</p>
<p>为什么使用NoSQL ?<br>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。</p>
</li>
</ul>
</li>
<li><p>2 是什么</p>
<p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，<br>泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。<br>（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>
</li>
<li><p>3 能干嘛</p>
<ul>
<li><p>易扩展</p>
<p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。<br>数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p>
</li>
<li><p>大数据量高性能</p>
<p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。<br>这得益于它的无关系性，数据库的结构简单。<br>一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，<br>在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，<br>是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了</p>
</li>
<li><p>多样灵活的数据模型</p>
<p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，<br>增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦</p>
</li>
<li><p>传统RDBMS VS NOSQL</p>
<p>RDBMS vs NoSQL<br>RDBMS</p>
<ul>
<li>高度组织化结构化数据</li>
<li>结构化查询语言（SQL）</li>
<li>数据和关系都存储在单独的表中。</li>
<li>数据操纵语言，数据定义语言</li>
<li>严格的一致性</li>
<li>基础事务<br>NoSQL</li>
<li>代表着不仅仅是SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式</li>
<li>键 - 值对存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非ACID属性</li>
<li>非结构化和不可预知的数据</li>
<li>CAP定理</li>
<li>高性能，高可用性和可伸缩性</li>
</ul>
</li>
</ul>
</li>
<li><p>4 去哪下</p>
<ul>
<li>Redis</li>
<li>memcache</li>
<li>Mongdb</li>
</ul>
</li>
<li><p>5 怎么玩</p>
<ul>
<li>KV</li>
<li>Cache</li>
<li>Persistence</li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="3V-3高"><a href="#3V-3高" class="headerlink" title="3V+3高"></a>3V+3高</h3><ul>
<li><p>大数据时代的3V</p>
<ul>
<li>海量Volume</li>
<li>多样Variety</li>
<li>实时Velocity</li>
</ul>
</li>
<li><p>互联网需求的3高</p>
<ul>
<li>高并发</li>
<li>高可扩</li>
<li>高性能</li>
</ul>
</li>
</ul>
<h3 id="当下的NoSQL经典应用"><a href="#当下的NoSQL经典应用" class="headerlink" title="当下的NoSQL经典应用"></a>当下的NoSQL经典应用</h3><ul>
<li><p>当下的应用是sql和nosql一起使用</p>
</li>
<li><p>阿里巴巴中文站商品信息如何存放</p>
<ul>
<li><p>看看阿里巴巴中文网站首页<br>以女装/女包包为例</p>
<ul>
<li><p>架构发展历程</p>
<ul>
<li>演变过程</li>
<li>第5代</li>
<li>第5代架构使命</li>
<li>……</li>
</ul>
</li>
<li><p>和我们相关的，多数据源多数据类型的存储问题</p>
</li>
</ul>
</li>
<li><p>1 商品基本信息</p>
<ul>
<li><p>名称、价格，出厂日期，生产厂商等</p>
</li>
<li><p>关系型数据库：mysql/oracle目前淘宝在去O化(也即拿掉Oracle)，<br>注意，淘宝内部用的Mysql是里面的大牛自己改造过的</p>
<ul>
<li><p>为什么去IOE</p>
<p> 2008年，王坚加盟阿里巴巴成为集团首席架构师，即现在的首席技术官。这位前微软亚洲研究院常务副院长被马云定位为：将帮助阿里巴巴集团建立世界级的技术团队，并负责<br>集团技术架构以及基础技术平台搭建。<br><br>在加入阿里后，带着技术基因和学者风范的王坚就在阿里巴巴集团提出了被称为“去IOE”（在IT建设过程中，去除IBM小型机、Oracle数据库及EMC存储设备）的<br>想法，并开始把云计算的本质，植入阿里IT基因。<br><br>王坚这样概括“去IOE”运动和阿里云之间的关系：“去IOE”彻底改变了阿里集团IT架构的基础，是阿里拥抱云计算，产出计算服务的基础。“去IOE”的本质是分布化<br>，让随处可以买到的Commodity PC架构成为可能，使云计算能够落地的首要条件。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2 商品描述、详情、评价信息(多文字类)</p>
<ul>
<li>多文字信息描述类，IO读写性能变差</li>
<li>文档数据库MongDB中</li>
</ul>
</li>
<li><p>3 商品的图片</p>
<ul>
<li><p>商品图片展现类</p>
</li>
<li><p>分布式的文件系统中</p>
<ul>
<li>淘宝自己的TFS</li>
<li>Google的GFS</li>
<li>Hadoop的HDFS</li>
</ul>
</li>
</ul>
</li>
<li><p>4 商品的关键字</p>
<ul>
<li>搜索引擎，淘宝内用</li>
<li>ISearch</li>
</ul>
</li>
<li><p>5 商品的波段性的热点高频信息</p>
<ul>
<li>内存数据库</li>
<li>tair、Redis、Memcache</li>
</ul>
</li>
<li><p>6 商品的交易、价格计算、积分累计</p>
<ul>
<li>外部系统，外部第3方支付接口</li>
<li>支付宝</li>
</ul>
</li>
<li><p>总结大型互联网应用(大数据、高并发、<br>多样数据类型)的难点和解决方案</p>
<ul>
<li><p>难点</p>
<ul>
<li>数据类型多样性</li>
<li>数据源多样性和变化重构</li>
<li>数据源改造而数据服务平台不需要大面积重构</li>
</ul>
</li>
<li><p>解决办法</p>
<ul>
<li><p>给学生画图介绍EAI和统一数据平台服务层</p>
</li>
<li><p>阿里、淘宝干了什么？UDSL</p>
<ul>
<li><p>是什么</p>
</li>
<li><p>什么样</p>
<ul>
<li>映射</li>
<li>API</li>
<li>热点缓存</li>
<li>……</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="NoSQL数据模型简介"><a href="#NoSQL数据模型简介" class="headerlink" title="NoSQL数据模型简介"></a>NoSQL数据模型简介</h3><ul>
<li><p>以一个电商客户、订单、订购<br>、地址模型来对比下关系型<br>数据库和非关系型数据库</p>
<ul>
<li><p>传统的关系型数据库你如何设计？</p>
<ul>
<li>ER图(1:1/1:N/N:N,主外键等常见)</li>
</ul>
</li>
<li><p>nosql你如何设计</p>
<ul>
<li><p>什么是BSON</p>
<p>BSON（）是一种类json的一种二进制形式的存储格式，简称Binary JSON，<br><br>它和JSON一样，支持内嵌的文档对象和数组对象</p>
</li>
<li><p>给学生用BSon画出构建的数据模型</p>
<p>{<br><br> “customer”:{<br><br>   “id”:1136,<br><br>   “name”:”Z3”,<br><br>   “billingAddress”:[{“city”:”beijing”}],<br><br>   “orders”:[<br><br>    {<br><br>      “id”:17,<br><br>      “customerId”:1136,<br><br>      “orderItems”:[{“productId”:27,”price”:77.5,”productName”:”thinking in…</p>
</li>
</ul>
</li>
<li><p>两者对比，问题和难点</p>
<ul>
<li><p>为什么上述的情况可以用聚合模型来处理</p>
<ul>
<li>高并发的操作是不太建议有关联查询的，<br>互联网公司用冗余数据来避免关联查询</li>
<li>分布式事务是支持不了太多的并发的</li>
</ul>
</li>
<li><p>启发学生，想想关系模型数据库你如何查？<br>如果按照我们新设计的BSon，是不是查询起来很可爱</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>聚合模型</p>
<ul>
<li><p>KV键值</p>
</li>
<li><p>bson</p>
</li>
<li><p>列族</p>
<p>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，<br><br>对针对某一列或者某几列的查询有非常大的IO优势。</p>
</li>
<li><p>图形</p>
</li>
</ul>
</li>
</ul>
<h3 id="NoSQL数据库的四大分类"><a href="#NoSQL数据库的四大分类" class="headerlink" title="NoSQL数据库的四大分类"></a>NoSQL数据库的四大分类</h3><ul>
<li><p>KV键值：典型介绍</p>
<ul>
<li>新浪：BerkeleyDB+redis</li>
<li>美团：redis+tair</li>
<li>阿里、百度：memcache+redis</li>
</ul>
</li>
<li><p>文档型数据库(bson格式比较多)：典型介绍</p>
<ul>
<li><p>CouchDB</p>
</li>
<li><p>MongoDB</p>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。<br><br><br><br>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
</li>
</ul>
</li>
<li><p>列存储数据库</p>
<ul>
<li>Cassandra, HBase</li>
<li>分布式文件系统</li>
</ul>
</li>
<li><p>图关系数据库</p>
<ul>
<li>它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统</li>
<li>社交网络，推荐系统等。专注于构建关系图谱</li>
<li>Neo4J, InfoGrid</li>
</ul>
</li>
<li><p>四者对比</p>
</li>
</ul>
<h3 id="在分布式数据库中CAP原理CAP-BASE"><a href="#在分布式数据库中CAP原理CAP-BASE" class="headerlink" title="在分布式数据库中CAP原理CAP+BASE"></a>在分布式数据库中CAP原理CAP+BASE</h3><ul>
<li><p>传统的ACID分别是什么</p>
<p>关系型数据库遵循ACID规则<br><br>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：<br><br><br><br>1、A (Atomicity) 原子性<br><br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如<br>银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第<br>二步失败，钱会莫名其妙少了100元。<br><br><br><br>2、C (Consistency) 一致性<br><br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。…</p>
<ul>
<li>A (Atomicity) 原子性</li>
<li>C (Consistency) 一致性</li>
<li>I (Isolation) 独立性</li>
<li>D (Durability) 持久性</li>
</ul>
</li>
<li><p>CAP</p>
<ul>
<li>C:Consistency（强一致性）</li>
<li>A:Availability（可用性）</li>
<li>P:Partition tolerance（分区容错性）</li>
</ul>
</li>
<li><p>CAP的3进2</p>
<p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。<br><br>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以<br><br><br><br>分区容忍性是我们必须需要实现的。<br><br><br><br>所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。<br><br>===============================================================================<br>========================================<br><br>C:强一致性 A：高可用性 P：分布式容忍性<br><br> CA 传统Oracle数据库…</p>
</li>
<li><p>经典CAP图</p>
<p> CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，<br><br>最多只能同时较好的满足两个。<br><br>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：<br><br>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。<br><br>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。<br><br>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p>
</li>
<li><p>BASE</p>
<ul>
<li><p>是什么</p>
<p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。<br><br><br><br>BASE其实是下面三个术语的缩写：<br><br>    基本可用（Basically Available）<br><br>    软状态（Soft state）<br><br>    最终一致（Eventually consistent）<br><br><br><br>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能<br>采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p>
</li>
</ul>
</li>
<li><p>分布式+集群简介</p>
<p>分布式系统<br><br><br><br>分布式系统（distributed system）<br><br> <br>由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚<br>性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域<br>网上等。<br><br><br><br><br><br>…</p>
</li>
</ul>
<h2 id="Redis入门介绍"><a href="#Redis入门介绍" class="headerlink" title="Redis入门介绍"></a>Redis入门介绍</h2><h3 id="入门概述-1"><a href="#入门概述-1" class="headerlink" title="入门概述"></a>入门概述</h3><ul>
<li><p>1是什么</p>
<ul>
<li><p>Redis:REmote DIctionary Server(远程字典服务器)</p>
</li>
<li><p>是完全开源免费的，用C语言编写的，遵守BSD协议，<br>是一个高性能的(key/value)分布式内存数据库，基于内存运行<br>并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,<br>也被人们称为数据结构服务器</p>
</li>
<li><p>Redis 与其他 key - value 缓存产品有以下三个特点</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份</li>
</ul>
</li>
</ul>
</li>
<li><p>2 能干嘛</p>
<ul>
<li>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li>
<li>取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面</li>
<li>模拟类似于HttpSession这种需要设定过期时间的功能</li>
<li>发布、订阅消息系统</li>
<li>定时器、计数器</li>
</ul>
</li>
<li><p>3 去哪下</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.redis.cn/">http://www.redis.cn/</a></li>
</ul>
</li>
<li><p>4 怎么玩</p>
<ul>
<li>数据类型、基本操作和配置</li>
<li>持久化和复制，RDB/AOF</li>
<li>事务的控制</li>
<li>复制</li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="VMWare-VMTools千里之行始于足下"><a href="#VMWare-VMTools千里之行始于足下" class="headerlink" title="VMWare+VMTools千里之行始于足下"></a>VMWare+VMTools千里之行始于足下</h3><ul>
<li><p>VMWare虚拟机的安装</p>
</li>
<li><p>CentOS或者RedHad5的安装</p>
<ul>
<li><p>如何查看自己的linux是32位还是64位</p>
<p>getconf LONG_BIT<br><br>返回是多少就是几位</p>
</li>
<li><p>假如出现了不支持虚拟化的问题</p>
<p>我的笔记本cpu是64位的，操作系统也是64位的，问题应该如虚拟机右下角提示所说，<br><br><br><br>是“宿主机BIOS设置中的硬件虚拟化被禁用了。”<br><br>需要打开笔记本BIOS中的IVT对虚拟化的支持。<br><br>找到菜单“Security”–“System Security”，<br><br>将Virtualization Technology(VTx)和Virtualization Technology DirectedI/O(VTd)设置为 <br>Enabled。<br><br>保存并退出BIOS设置，重启电脑，</p>
</li>
</ul>
</li>
<li><p>VMTools的安装</p>
</li>
<li><p>设置共享目录</p>
</li>
<li><p>上述环境都OK后开始进行Redis的服务器安装配置</p>
</li>
</ul>
<h3 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h3><ul>
<li><p>Windows版安装</p>
<p>Window 下安装<br>下载地址：<a target="_blank" rel="noopener" href="https://github.com/dmajkic/redis/downloads">https://github.com/dmajkic/redis/downloads</a><br>下载到的Redis支持32bit和64bit。根据自己实际情况选择，将64bit的内容cp到自定义盘符安装目录取名redis。 如 C:\reids<br>打开一个cmd窗口 使用cd命令切换目录到 C:\redis 运行 redis-server.exe redis.conf 。<br>如果想方便的话，可以把redis的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个redis.conf可以省略，<br>如果省略，会启用默认的。输入之后，会显示如下界面：<br>这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。<br>切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。<br>设置键值对 set myKey abc<br>取出键值对 get myKey</p>
</li>
<li><p>重要提示：</p>
<ul>
<li>由于企业里面做Redis开发，99%都是Linux版的运用和安装，<br>几乎不会涉及到Windows版，上一步的讲解只是为了知识的完整性，<br>Windows版不作为重点，同学可以下去自己玩，企业实战就认一个版：Linux</li>
</ul>
</li>
<li><p>Linux版安装</p>
<ul>
<li><p>下载获得redis-3.0.4.tar.gz后将它放入我们的Linux目录/opt</p>
</li>
<li><p>/opt目录下，解压命令:tar -zxvf redis-3.0.4.tar.gz</p>
</li>
<li><p>解压完成后出现文件夹：redis-3.0.4</p>
</li>
<li><p>进入目录:cd redis-3.0.4</p>
</li>
<li><p>在redis-3.0.4目录下执行make命令</p>
<ul>
<li><p>运行make命令时故<br>意出现的错误解析：</p>
<ul>
<li><p>安装gcc</p>
<p>gcc是linux下的一个编译程序，是C程序的编译工具。<br>GCC(GNU Compiler Collection) 是 GNU(GNU’s Not Unix) 计划提供的编译器家族，它能够支持 C, C++, Objective-C, Fortran, Java 和 Ada 等等程序设计语言前端，同时能够运行在 x86, x86-64, IA-64, PowerPC, SPARC 和 Alpha 等等几乎目前所有的硬件平台上。鉴于这些特征，以及 GCC 编译代码的高效性，使得 GCC 成为绝大多数自由软件开发编译的首选工具。虽然对于程序员们来说，编译器只是一个工具，除了开发和维护人员，很少有人关注编译器的发展，但是 GCC 的影响力是如此之大，它的性能提升甚至有望改善所有的自由软件的运行效率，同时它的内部结构的变化也体现出现代编译器发展的新特征。</p>
<ul>
<li>能上网：yum install gcc-c++</li>
<li>不上网：</li>
</ul>
</li>
<li><p>二次make</p>
</li>
<li><p>jemalloc/jemalloc.h：没有那个文件或目录</p>
<ul>
<li>运行make distclean之后再make</li>
</ul>
</li>
<li><p>Redis Test(可以不用执行)</p>
<p>下载TCL的网址：<br><a target="_blank" rel="noopener" href="http://www.linuxfromscratch.org/blfs/view/cvs/general/tcl.html">http://www.linuxfromscratch.org/blfs/view/cvs/general/tcl.html</a><br>安装TCL</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果make完成后继续执行make install</p>
</li>
<li><p>查看默认安装目录：usr/local/bin</p>
<ul>
<li><p>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</p>
<ul>
<li>服务启动起来后执行</li>
</ul>
</li>
<li><p>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</p>
</li>
<li><p>redis-check-dump：修复有问题的dump.rdb文件</p>
</li>
<li><p>redis-cli：客户端，操作入口</p>
</li>
<li><p>redis-sentinel：redis集群使用</p>
</li>
<li><p>redis-server：Redis服务器启动命令</p>
</li>
</ul>
</li>
<li><p>启动</p>
<ul>
<li>修改redis.conf文件将里面的daemonize no 改成 yes，让服务在后台启动</li>
<li>将默认的redis.conf拷贝到自己定义好的一个路径下，比如/myconf</li>
<li>启动</li>
<li>连通测试</li>
<li>/usr/local/bin目录下运行redis-server，运行拷贝出存放了自定义conf文件目录下的redis.conf文件</li>
</ul>
</li>
<li><p>永远的helloworld</p>
</li>
<li><p>关闭</p>
<ul>
<li>单实例关闭：redis-cli shutdown</li>
<li>多实例关闭，指定端口关闭:redis-cli -p 6379 shutdown</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Redis启动后杂项基础知识讲解"><a href="#Redis启动后杂项基础知识讲解" class="headerlink" title="Redis启动后杂项基础知识讲解"></a>Redis启动后杂项基础知识讲解</h3><ul>
<li><p>单进程</p>
<ul>
<li>单进程模型来处理客户端的请求。对读写等事件的响应<br>是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率</li>
<li>epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，<br>它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</li>
</ul>
</li>
<li><p>默认16个数据库，类似数组下表从零开始，初始默认使用零号库</p>
<p>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id<br>  databases 16</p>
</li>
<li><p>select命令切换数据库</p>
</li>
<li><p>dbsize查看当前数据库的key的数量</p>
</li>
<li><p>flushdb：清空当前库</p>
</li>
<li><p>Flushall；通杀全部库</p>
</li>
<li><p>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</p>
</li>
<li><p>Redis索引都是从零开始</p>
</li>
<li><p>为什么默认端口是6379</p>
</li>
</ul>
<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="Redis的五大数据类型"><a href="#Redis的五大数据类型" class="headerlink" title="Redis的五大数据类型"></a>Redis的五大数据类型</h3><ul>
<li><p>string（字符串）</p>
<p>String（字符串）<br>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。<br>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。<br>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>
</li>
<li><p>hash（哈希，类似java里的Map）</p>
<p>Hash（哈希）<br>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>类似Java里面的Map&lt;String,Object&gt;</p>
</li>
<li><p>list（列表）</p>
<p>List（列表）<br>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表</p>
</li>
<li><p>set（集合）</p>
<p>Set（集合）<br>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的，</p>
</li>
<li><p>zset(sorted set：有序集合)</p>
<p>zset(sorted set：有序集合)<br>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
</li>
</ul>
<h3 id="哪里去获得redis常见数据类型操作命令"><a href="#哪里去获得redis常见数据类型操作命令" class="headerlink" title="哪里去获得redis常见数据类型操作命令"></a>哪里去获得redis常见数据类型操作命令</h3><ul>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/">http://redisdoc.com/</a></li>
</ul>
<h3 id="Redis-键-key"><a href="#Redis-键-key" class="headerlink" title="Redis 键(key)"></a>Redis 键(key)</h3><ul>
<li><p>常用</p>
</li>
<li><p>案例</p>
<ul>
<li> keys *</li>
<li> exists key的名字，判断某个key是否存在</li>
<li> move key db   —&gt;当前库就没有了，被移除了</li>
<li> expire key 秒钟：为给定的key设置过期时间</li>
<li> ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
<li> type key 查看你的key是什么类型</li>
</ul>
</li>
</ul>
<h3 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h3><ul>
<li><p>常用</p>
</li>
<li><p>单值单value</p>
</li>
<li><p>案例</p>
<ul>
<li> set/get/del/append/strlen</li>
<li>Incr/decr/incrby/decrby,一定要是数字才能进行加减</li>
<li> getrange/setrange</li>
</ul>
<pre><code>getrange:获取指定区间范围内的值，类似between......and的关系
从零到负一表示全部
setrange设置指定区间范围内的值，格式是setrange key值 具体值
</code></pre>
<ul>
<li> setex(set with expire)键秒值/setnx(set if not exist)</li>
</ul>
<pre><code>setex:设置带过期时间的key，动态设置。
setex 键 秒值 真实值
setnx:只有在 key 不存在时设置 key 的值。
</code></pre>
<ul>
<li> mset/mget/msetnx</li>
</ul>
<pre><code>mset:同时设置一个或多个 key-value 对。
mget:获取所有(一个或多个)给定 key 的值。
msetnx:同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。
</code></pre>
<ul>
<li> getset(先get再set)</li>
</ul>
<pre><code>getset:将给定 key 的值设为 value ，并返回 key 的旧值(old value)。
简单一句话，先get然后立即set
</code></pre>
</li>
</ul>
<h3 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a>Redis列表(List)</h3><ul>
<li><p>常用</p>
</li>
<li><p>单值多value</p>
</li>
<li><p>案例</p>
<ul>
<li> lpush/rpush/lrange</li>
<li> lpop/rpop</li>
<li> lindex，按照索引下标获得元素(从上到下)</li>
</ul>
<pre><code>通过索引获取列表中的元素 lindex key index
</code></pre>
<ul>
<li> llen</li>
<li> lrem key 删N个value</li>
</ul>
<pre><code>* 从left往right删除2个值等于v1的元素，返回的值为实际删除的数量
 *  LREM list3 0 值，表示删除全部给定的值。零个就是全部值
</code></pre>
<ul>
<li> ltrim key 开始index 结束index，截取指定范围的值后再赋值给key</li>
</ul>
<pre><code>ltrim：截取指定索引区间的元素，格式是ltrim list的key 起始索引 结束索引
</code></pre>
<ul>
<li> rpoplpush 源列表 目的列表</li>
</ul>
<pre><code>移除列表的最后一个元素，并将该元素添加到另一个列表并返回
</code></pre>
<ul>
<li> lset key index value</li>
<li> linsert key  before/after 值1 值2</li>
</ul>
<pre><code>在list某个已有值的前后再添加具体值
</code></pre>
<ul>
<li><p>性能总结</p>
<p>它是一个字符串链表，left、right都可以插入添加；<br>如果键不存在，创建新的链表；<br>如果键已存在，新增内容；<br>如果值全移除，对应的键也就消失了。<br>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h3><ul>
<li><p>常用</p>
</li>
<li><p>单值多value</p>
</li>
<li><p>案例</p>
<ul>
<li> sadd/smembers/sismember</li>
<li> scard，获取集合里面的元素个数</li>
</ul>
<pre><code>获取集合里面的元素个数
</code></pre>
<ul>
<li> srem key value 删除集合中元素</li>
<li> srandmember key 某个整数(随机出几个数)</li>
</ul>
<pre><code>*   从set集合里面随机取出2个
 *   如果超过最大数量就全部取出，
 *   如果写的值是负数，比如-3 ，表示需要取出3个，但是可能会有重复值。
</code></pre>
<ul>
<li><p> spop key 随机出栈</p>
</li>
<li><p> smove key1 key2 在key1里某个值      作用是将key1里的某个值赋给key2</p>
</li>
<li><p>数学集合类</p>
<ul>
<li><p>差集：sdiff</p>
<p>在第一个set里面而不在后面任何一个set里面的项</p>
</li>
<li><p>交集：sinter</p>
</li>
<li><p>并集：sunion</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h3><ul>
<li><p>常用</p>
</li>
<li><p>KV模式不变，但V是一个键值对</p>
</li>
<li><p>案例</p>
<ul>
<li>  hset/hget/hmset/hmget/hgetall/hdel</li>
<li> hlen</li>
<li> hexists key 在key里面的某个值的key</li>
<li> hkeys/hvals</li>
<li> hincrby/hincrbyfloat</li>
<li> hsetnx</li>
</ul>
<pre><code>不存在赋值，存在了无效。
</code></pre>
</li>
</ul>
<h3 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h3><ul>
<li><p>多说一句</p>
<ul>
<li>在set基础上，加一个score值。<br>之前set是k1 v1 v2 v3，<br>现在zset是k1 score1 v1 score2 v2</li>
</ul>
</li>
<li><p>常用</p>
</li>
<li><p>案例</p>
<ul>
<li><p>zadd/zrange</p>
<ul>
<li>withscores</li>
</ul>
</li>
<li><p>zrangebyscore key 开始score 结束score</p>
<ul>
<li><p> withscores</p>
</li>
<li><p> (   不包含</p>
</li>
<li><p>limit 作用是返回限制</p>
<ul>
<li> limit 开始下标步 多少步</li>
</ul>
</li>
</ul>
</li>
<li><p> zrem key 某score下对应的value值，作用是删除元素</p>
</li>
</ul>
<pre><code>删除元素，格式是zrem zset的key 项的值，项的值可以是多个
zrem key score某个对应值，可以是多个值
</code></pre>
<ul>
<li> zcard/zcount key score区间/zrank key values值，作用是获得下标值/zscore key 对应值,获得分数</li>
</ul>
<pre><code>zcard ：获取集合中元素个数
zcount ：获取分数区间内元素个数，zcount key 开始分数区间 结束分数区间
zrank： 获取value在zset中的下标位置
zscore：按照值获得对应的分数
</code></pre>
<ul>
<li> zrevrank key values值，作用是逆序获得下标值</li>
</ul>
<pre><code>正序、逆序获得下标索引值
</code></pre>
<ul>
<li> zrevrange</li>
<li> zrevrangebyscore  key 结束score 开始score</li>
</ul>
<pre><code>zrevrangebyscore zset1 90 60 withscores    分数是反着来的
</code></pre>
</li>
</ul>
<h2 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h2><p>redis.conf</p>
<h3 id="它在哪"><a href="#它在哪" class="headerlink" title="它在哪"></a>它在哪</h3><ul>
<li>地址</li>
<li>为什么我将它拷贝出来单独执行？</li>
</ul>
<h3 id="units单位"><a href="#units单位" class="headerlink" title="units单位"></a>units单位</h3><p>1  配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>    2  对大小写不敏感</p>
<h3 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a>INCLUDES包含</h3><p>和我们的Struts2配置文件类似，可以通过includes包含，redis.conf可以作为总闸，包含其他</p>
<h3 id="GENERAL通用"><a href="#GENERAL通用" class="headerlink" title="GENERAL通用"></a>GENERAL通用</h3><ul>
<li><p>daemonize</p>
</li>
<li><p>pidfile</p>
</li>
<li><p>port</p>
</li>
<li><p>tcp-backlog</p>
<p>tcp-backlog<br><br>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。<br><br>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的<br>值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值<br><br>来达到想要的效果</p>
</li>
<li><p>timeout</p>
</li>
<li><p>bind </p>
</li>
<li><p>tcp-keepalive</p>
<p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60</p>
</li>
<li><p>loglevel</p>
</li>
<li><p>logfile</p>
</li>
<li><p>syslog-enabled</p>
<p>是否把日志输出到syslog中</p>
</li>
<li><p>syslog-ident</p>
<p>指定syslog里的日志标志</p>
</li>
<li><p>syslog-facility</p>
<p>指定syslog设备，值可以是USER或LOCAL0-LOCAL7</p>
</li>
<li><p>databases</p>
</li>
</ul>
<h3 id="SNAPSHOTTING快照"><a href="#SNAPSHOTTING快照" class="headerlink" title="SNAPSHOTTING快照"></a>SNAPSHOTTING快照</h3><ul>
<li><p>Save</p>
<ul>
<li> save 秒钟 写操作次数</li>
</ul>
<pre><code>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，
默认
是1分钟内改了1万次，
或5分钟内改了10次，
或15分钟内改了1次。
</code></pre>
<ul>
<li><p>禁用</p>
<p>如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以</p>
</li>
</ul>
</li>
<li><p>stop-writes-on-bgsave-error</p>
<p>如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制</p>
</li>
<li><p> rdbcompression</p>
</li>
</ul>
<p>  rdbcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用<br>  LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</p>
<ul>
<li> rdbchecksum</li>
</ul>
<p>  rdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约<br>  10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</p>
<ul>
<li> dbfilename</li>
<li> dir</li>
</ul>
<h3 id="REPLICATION复制"><a href="#REPLICATION复制" class="headerlink" title="REPLICATION复制"></a>REPLICATION复制</h3><h3 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h3><ul>
<li>访问密码的查看、设置和取消</li>
</ul>
<h3 id="LIMITS限制"><a href="#LIMITS限制" class="headerlink" title="LIMITS限制"></a>LIMITS限制</h3><ul>
<li><p>maxclients</p>
<p>设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你<br>无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自<br>身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这<br>些连接请求方发出“max number of clients reached”以作回应。</p>
</li>
<li><p>maxmemory</p>
<p>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，<br>那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。<br>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素</p>
</li>
<li><p>maxmemory-policy</p>
<p>（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键<br>（2）allkeys-lru：使用LRU算法移除key<br>（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键<br>（4）allkeys-random：移除随机的key<br>（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key<br>（6）noeviction：不进行移除。针对写操作，只是返回错误信息</p>
<ul>
<li>volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</li>
<li>allkeys-lru -&gt; remove any key according to the LRU algorithm</li>
<li>volatile-random -&gt; remove a random key with an expire set</li>
<li>allkeys-random -&gt; remove a random key, any key</li>
<li>volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</li>
<li>noeviction -&gt; don’t expire at all, just return an error on write operations</li>
</ul>
</li>
<li><p>maxmemory-samples</p>
<p>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<br>redis默认会检查这么多个key并选择其中LRU的那个</p>
</li>
</ul>
<h3 id="APPEND-ONLY-MODE追加"><a href="#APPEND-ONLY-MODE追加" class="headerlink" title="APPEND ONLY MODE追加"></a>APPEND ONLY MODE追加</h3><ul>
<li><p> appendonly : 是否开启AOF , 默认为no</p>
</li>
<li><p> appendfilename</p>
</li>
<li><p>appendfsync</p>
<ul>
<li>always：同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li>
<li>everysec：出厂默认推荐，异步操作，每秒记录   如果一秒内宕机，有数据丢失</li>
<li>no</li>
</ul>
</li>
<li><p>no-appendfsync-on-rewrite：重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</p>
</li>
<li><p>auto-aof-rewrite-min-size：设置重写的基准值</p>
</li>
<li><p>auto-aof-rewrite-percentage：设置重写的基准值</p>
</li>
</ul>
<h3 id="常见配置redis-conf介绍"><a href="#常见配置redis-conf介绍" class="headerlink" title="常见配置redis.conf介绍"></a>常见配置redis.conf介绍</h3><p>参数说明<br>redis.conf 配置项说明如下：</p>
<ol>
<li><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程<br>  daemonize no</p>
</li>
<li><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定<br>  pidfile /var/run/redis.pid</p>
</li>
<li><p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字<br>  port 6379</p>
</li>
<li><p>绑定的主机地址<br>  bind 127.0.0.1</p>
</li>
<li><p>当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能<br>  timeout 300</p>
</li>
<li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose<br>  loglevel verbose</p>
</li>
<li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null<br>  logfile stdout</p>
</li>
<li><p>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id<br>  databases 16</p>
</li>
<li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合<br>  save <seconds> <changes><br>  Redis默认配置文件中提供了三个条件：<br>  save 900 1<br>  save 300 10<br>  save 60 10000<br>  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</p>
</li>
<li><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大<br>  rdbcompression yes</p>
</li>
<li><p>指定本地数据库文件名，默认值为dump.rdb<br>  dbfilename dump.rdb</p>
</li>
<li><p>指定本地数据库存放目录<br>  dir ./</p>
</li>
<li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步<br>  slaveof <masterip> <masterport></p>
</li>
<li><p>当master服务设置了密码保护时，slav服务连接master的密码<br>  masterauth <master-password></p>
</li>
<li><p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭<br>  requirepass foobared</p>
</li>
<li><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息<br>  maxclients 128</p>
</li>
<li><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区<br>  maxmemory <bytes></p>
</li>
<li><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no<br>  appendonly no</p>
</li>
<li><p>指定更新日志文件名，默认为appendonly.aof<br>   appendfilename appendonly.aof</p>
</li>
<li><p>指定更新日志条件，共有3个可选值： <br>  no：表示等操作系统进行数据缓存同步到磁盘（快） <br>  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） <br>  everysec：表示每秒同步一次（折衷，默认值）<br>  appendfsync everysec</p>
</li>
<li><p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）<br>   vm-enabled no</p>
</li>
<li><p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享<br>   vm-swap-file /tmp/redis.swap</p>
</li>
<li><p>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0<br>   vm-max-memory 0</p>
</li>
<li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值<br>   vm-page-size 32</p>
</li>
<li><p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。<br>   vm-pages 134217728</p>
</li>
<li><p>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4<br>   vm-max-threads 4</p>
</li>
<li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启<br>  glueoutputbuf yes</p>
</li>
<li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法<br>  hash-max-zipmap-entries 64<br>  hash-max-zipmap-value 512</p>
</li>
<li><p>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）<br>  activerehashing yes</p>
</li>
<li><p>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件<br>  include /path/to/local.conf</p>
</li>
</ol>
<h2 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h2><h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><ul>
<li>官网介绍</li>
</ul>
<h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><ul>
<li><p>官网介绍</p>
</li>
<li><p>是什么：</p>
<ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘，<br>也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</li>
<li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到<br>一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。<br>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能<br>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方<br>式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</li>
</ul>
</li>
<li><p>Fork</p>
<ul>
<li>fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）<br>数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li>
</ul>
</li>
<li><p>rdb 保存的是dump.rdb文件</p>
</li>
<li><p>配置位置</p>
</li>
<li><p>如何触发RDB快照</p>
<ul>
<li><p>配置文件中默认的快照配置</p>
<ul>
<li><p>冷拷贝后重新使用</p>
<ul>
<li>可以cp dump.rdb dump_new.rdb</li>
</ul>
</li>
</ul>
</li>
<li><p>命令save或者是bgsave</p>
<ul>
<li>Save：save时只管保存，其它不管，全部阻塞</li>
<li>BGSAVE：Redis会在后台异步进行快照操作，<br>快照同时还可以响应客户端请求。可以通过lastsave<br>命令获取最后一次成功执行快照的时间</li>
</ul>
</li>
<li><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
</li>
</ul>
</li>
<li><p>如何恢复</p>
<ul>
<li>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li>
<li>CONFIG GET dir获取目录</li>
</ul>
</li>
<li><p>优势</p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
</li>
<li><p>劣势</p>
<ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就<br>会丢失最后一次快照后的所有修改</li>
<li>fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
</ul>
</li>
<li><p>如何停止</p>
<ul>
<li>动态所有停止RDB保存规则的方法：redis-cli config set save “”</li>
</ul>
</li>
<li><p>小总结</p>
</li>
</ul>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><ul>
<li><p>官网介绍</p>
</li>
<li><p>是什么：</p>
<ul>
<li>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，<br>只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis<br>重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</li>
</ul>
</li>
<li><p>Aof保存的是appendonly.aof文件</p>
</li>
<li><p>配置位置</p>
</li>
<li><p>AOF启动/修复/恢复</p>
<ul>
<li><p>正常恢复</p>
<ul>
<li><p>启动：设置Yes</p>
<ul>
<li>修改默认的appendonly no，改为yes</li>
</ul>
</li>
<li><p>将有数据的aof文件复制一份保存到对应目录(config get dir)</p>
</li>
<li><p>恢复：重启redis然后重新加载</p>
</li>
</ul>
</li>
<li><p>异常恢复</p>
<ul>
<li><p>启动：设置Yes</p>
<ul>
<li>修改默认的appendonly no，改为yes</li>
</ul>
</li>
<li><p>备份被写坏的AOF文件</p>
</li>
<li><p>修复：</p>
<ul>
<li>redis-check-aof –fix进行修复</li>
</ul>
</li>
<li><p>恢复：重启redis然后重新加载</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>rewrite</p>
<ul>
<li><p>是什么：</p>
<ul>
<li>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,<br>当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，<br>只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</li>
</ul>
</li>
<li><p>重写原理</p>
<ul>
<li>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，<br>遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，<br>而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</li>
</ul>
</li>
<li><p>触发机制</p>
<ul>
<li>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</li>
</ul>
</li>
</ul>
</li>
<li><p>优势</p>
<ul>
<li>每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li>
<li>每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失</li>
<li>不同步：appendfsync no   从不同步</li>
</ul>
</li>
<li><p>劣势</p>
<ul>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li>
</ul>
</li>
<li><p>小总结</p>
</li>
</ul>
<h3 id="总结-Which-one"><a href="#总结-Which-one" class="headerlink" title="总结(Which one)"></a>总结(Which one)</h3><ul>
<li><p>官网建议</p>
</li>
<li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p>
</li>
<li><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些<br>命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.<br>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p>
</li>
<li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p>
</li>
<li><p>同时开启两种持久化方式</p>
<ul>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,<br>因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？<br>作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，<br>快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ul>
</li>
<li><p>性能建议</p>
<p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。<br>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。<br>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构</p>
</li>
</ul>
<h2 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>可以一次执行多个命令，<strong>本质是一组命令的集合。</strong>一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞</li>
<li>官网</li>
</ul>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li>一个队列中，一次性、顺序性、排他性的执行一系列命令</li>
</ul>
<h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><ul>
<li><p>常用命令</p>
</li>
<li><p>case1：正常执行</p>
</li>
<li><p>Case2：放弃事务</p>
</li>
<li><p>Case3：全体连坐</p>
</li>
<li><p>Case4：冤头债主</p>
</li>
<li><p>Case5：watch监控</p>
<ul>
<li><p>悲观锁/乐观锁/CAS(Check And Set)</p>
<ul>
<li><p>悲观锁</p>
<p> 悲观锁(Pessimistic Lock), <br>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里<br>边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</p>
</li>
<li><p>乐观锁</p>
<p> 乐观锁(Optimistic Lock), <br>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐<br>观锁适用于多读的应用类型，这样可以提高吞吐量，<br><br><br><br>乐观锁策略:提交版本必须大于记录当前版本才能执行更新</p>
</li>
<li><p>CAS</p>
</li>
</ul>
</li>
<li><p>初始化信用卡可用余额和欠额</p>
</li>
<li><p>无加塞篡改，先监控再开启multi，<br>保证两笔金额变动在同一个事务内</p>
</li>
<li><p>有加塞篡改</p>
<ul>
<li>监控了key，如果key被修改了，后面一个事务的执行失效</li>
</ul>
</li>
<li><p> unwatch</p>
</li>
<li><p>一旦执行了exec之前加的监控锁都会被取消掉了</p>
</li>
<li><p>小结</p>
<ul>
<li>Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，<br>比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行</li>
<li>通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，<br>EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3阶段"><a href="#3阶段" class="headerlink" title="3阶段"></a>3阶段</h3><ul>
<li>开启：以MULTI开始一个事务</li>
<li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li>
<li>执行：由EXEC命令触发事务</li>
</ul>
<h3 id="3特性"><a href="#3特性" class="headerlink" title="3特性"></a>3特性</h3><ul>
<li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，<br>也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</li>
<li>不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
<h2 id="Redis的发布订阅"><a href="#Redis的发布订阅" class="headerlink" title="Redis的发布订阅"></a>Redis的发布订阅</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</li>
<li>订阅/发布消息图</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h3 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h3><p>先订阅后发布后才能收到消息，<br>1 可以一次性订阅多个，SUBSCRIBE c1 c2 c3</p>
<h1 id="2-消息发布，PUBLISH-c2-hello-redis"><a href="#2-消息发布，PUBLISH-c2-hello-redis" class="headerlink" title="2 消息发布，PUBLISH c2 hello-redis"></a>2 消息发布，PUBLISH c2 hello-redis</h1><p>3 订阅多个，通配符<em>， PSUBSCRIBE new</em><br>4 收取消息， PUBLISH new1 redis2015</p>
<h2 id="Redis的复制-Master-Slave"><a href="#Redis的复制-Master-Slave" class="headerlink" title="Redis的复制(Master/Slave)"></a>Redis的复制(Master/Slave)</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>官网</li>
<li>行话：也就是我们所说的主从复制，主机数据更新后根据配置和策略，<br>自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主</li>
</ul>
<h3 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul>
<li>读写分离</li>
<li>容灾恢复</li>
</ul>
<h3 id="怎么玩-1"><a href="#怎么玩-1" class="headerlink" title="怎么玩"></a>怎么玩</h3><ul>
<li><p>配从(库)不配主(库)</p>
</li>
<li><p>从库配置：<code>slaveof 主库IP 主库端口</code></p>
<ul>
<li>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</li>
<li>info replication</li>
</ul>
</li>
<li><p>修改配置文件细节操作</p>
<ul>
<li>拷贝多个redis.conf文件</li>
<li>开启daemonize yes</li>
<li>pid文件名字</li>
<li>指定端口</li>
<li>log文件名字</li>
<li>dump.rdb名字</li>
</ul>
</li>
<li><p>常用3招</p>
<ul>
<li><p>一主二仆</p>
<ul>
<li><p>Init</p>
</li>
<li><p>一个Master两个Slave</p>
</li>
<li><p>日志查看</p>
<ul>
<li>主机日志</li>
<li>备机日志</li>
<li> info replication</li>
</ul>
</li>
<li><p>主从问题演示</p>
<p>1 切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的123是否也可以复制<br>2 从机是否可以写？set可否？<br>3 主机shutdown后情况如何？从机是上位还是原地待命<br>4 主机又回来了后，主机新增记录，从机还能否顺利复制？<br>5 其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p>
</li>
</ul>
</li>
<li><p>薪火相传</p>
<ul>
<li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他<br>slaves的连接和同步请求，那么该slave作为了链条中下一个的master,<br>可以有效减轻master的写压力</li>
<li>中途变更转向:会清除之前的数据，重新建立拷贝最新的</li>
<li>slaveof 新主库IP 新主库端口</li>
</ul>
</li>
<li><p>反客为主</p>
<ul>
<li><p>SLAVEOF no one</p>
<ul>
<li>使当前数据库停止与其他数据库的同步，转成主数据库</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul>
<li>slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，<br>在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li>
<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a>哨兵模式(sentinel)</h3><ul>
<li><p>是什么</p>
<ul>
<li>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</li>
</ul>
</li>
<li><p>怎么玩(使用步骤)</p>
<ul>
<li><p>调整结构，6379带着80、81</p>
</li>
<li><p>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</p>
</li>
<li><p>配置哨兵,填写内容</p>
<ul>
<li> sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1</li>
<li>上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机</li>
</ul>
</li>
<li><p>启动哨兵</p>
<ul>
<li>redis-sentinel /myredis/sentinel.conf </li>
<li>上述目录依照各自的实际情况配置，可能目录不同</li>
</ul>
</li>
<li><p>正常主从演示</p>
</li>
<li><p>原有的master挂了</p>
</li>
<li><p>投票新选</p>
</li>
<li><p>重新主从继续开工,info replication查查看</p>
</li>
<li><p>问题：如果之前的master重启回来，会不会双master冲突？</p>
</li>
</ul>
</li>
<li><p>一组sentinel能同时监控多个Master</p>
</li>
</ul>
<h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><ul>
<li><p>复制延时</p>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
</li>
</ul>
<h2 id="Redis的Java客户端Jedis"><a href="#Redis的Java客户端Jedis" class="headerlink" title="Redis的Java客户端Jedis"></a>Redis的Java客户端Jedis</h2><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><ul>
<li> tar -zxvf jdk-7u67-linux-i586.tar.gz</li>
<li> vi /etc/profile</li>
<li>重启一次Centos</li>
<li>编码验证</li>
</ul>
<h3 id="安装eclipse"><a href="#安装eclipse" class="headerlink" title="安装eclipse"></a>安装eclipse</h3><h3 id="Jedis所需要的jar包"><a href="#Jedis所需要的jar包" class="headerlink" title="Jedis所需要的jar包"></a>Jedis所需要的jar包</h3><ul>
<li>commons-pool-1.6.jar</li>
<li>jedis-2.1.0.jar</li>
</ul>
<h3 id="Jedis常用操作"><a href="#Jedis常用操作" class="headerlink" title="Jedis常用操作"></a>Jedis常用操作</h3><ul>
<li><p>测试连通性</p>
<p>public class Demo01 {<br>  public static void main(String[] args) {<br>    //连接本地的 Redis 服务<br>    Jedis jedis = new Jedis(“127.0.0.1”,6379);<br>    //查看服务是否运行，打出pong表示OK<br>    System.out.println(“connection is OK==========&gt;: “+jedis.ping());<br>  }<br>}</p>
</li>
<li><p>5+1</p>
<p>package com.atguigu.redis.test;<br>import java.util.<em>;<br>import redis.clients.jedis.Jedis;<br>public class Test02 <br>{<br>  public static void main(String[] args) <br>  {<br>     Jedis jedis = new Jedis(“127.0.0.1”,6379);<br>     //key<br>     Set<String> keys = jedis.keys(“</em>“);<br>     for (Iterator iterator = keys.iterator(); iterator.hasNext();) {<br>       String key = (String) iterator.next();<br>       System.out.println(key);<br>     }<br>     System.out.println(“jedis.exists====&gt;”+jedis.exists(“k2”));<br>     System.out.println(jedis.ttl(“k1”));<br>     //String<br>     //jedis.append(“k1”,”myreids”);<br>     System.out.println(jedis.get(“k1”));<br>     jedis.set(“k4”,”k4_redis”);<br>     System.out.println(“—————————————-“);<br>     jedis.mset(“str1”,”v1”,”str2”,”v2”,”str3”,”v3”);<br>     System.out.println(jedis.mget(“str1”,”str2”,”str3”));<br>     //list<br>     System.out.println(“—————————————-“);<br>     //jedis.lpush(“mylist”,”v1”,”v2”,”v3”,”v4”,”v5”);<br>     List<String> list = jedis.lrange(“mylist”,0,-1);<br>     for (String element : list) {<br>       System.out.println(element);<br>     }<br>     //set<br>     jedis.sadd(“orders”,”jd001”);<br>     jedis.sadd(“orders”,”jd002”);<br>     jedis.sadd(“orders”,”jd003”);<br>     Set<String> set1 = jedis.smembers(“orders”);<br>     for (Iterator iterator = set1.iterator(); iterator.hasNext();) {<br>       String string = (String) iterator.next();<br>       System.out.println(string);<br>     }<br>     jedis.srem(“orders”,”jd002”);<br>     System.out.println(jedis.smembers(“orders”).size());<br>     //hash<br>     jedis.hset(“hash1”,”userName”,”lisi”);<br>     System.out.println(jedis.hget(“hash1”,”userName”));<br>     Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();<br>     map.put(“telphone”,”13811814763”);<br>     map.put(“address”,”atguigu”);<br>     map.put(“email”,”<a href="mailto:&#97;&#98;&#x63;&#64;&#49;&#x36;&#51;&#46;&#99;&#x6f;&#109;">&#97;&#98;&#x63;&#64;&#49;&#x36;&#51;&#46;&#99;&#x6f;&#109;</a>“);<br>     jedis.hmset(“hash2”,map);<br>     List<String> result = jedis.hmget(“hash2”, “telphone”,”email”);<br>     for (String element : result) {<br>       System.out.println(element);<br>     }<br>     //zset<br>     jedis.zadd(“zset01”,60d,”v1”);<br>     jedis.zadd(“zset01”,70d,”v2”);<br>     jedis.zadd(“zset01”,80d,”v3”);<br>     jedis.zadd(“zset01”,90d,”v4”);<br>     <br>     Set<String> s1 = jedis.zrange(“zset01”,0,-1);<br>     for (Iterator iterator = s1.iterator(); iterator.hasNext();) {<br>       String string = (String) iterator.next();<br>       System.out.println(string);<br>     }<br>          <br>  }<br>}</p>
<ul>
<li>一个key</li>
<li>五大数据类型</li>
</ul>
</li>
<li><p>事务提交</p>
<ul>
<li><p>日常</p>
<p>package com.atguigu.redis.test;<br>import redis.clients.jedis.Jedis;<br>import redis.clients.jedis.Response;<br>import redis.clients.jedis.Transaction;<br>public class Test03 <br>{<br>  public static void main(String[] args) <br>  {<br>     Jedis jedis = new Jedis(“127.0.0.1”,6379);<br>     <br>     //监控key，如果该动了事务就被放弃<br>     /<em>3<br>     jedis.watch(“serialNum”);<br>     jedis.set(“serialNum”,”s#####################”);<br>     jedis.unwatch();</em>/<br>     <br>     Transaction transaction = jedis.multi();//被当作一个命令进行执行<br>     Response<String> response = transaction.get(“serialNum”);<br>     transaction.set(“serialNum”,”s002”);<br>     response = transaction.get(“serialNum”);<br>     transaction.lpush(“list3”,”a”);<br>     transaction.lpush(“list3”,”b”);<br>     transaction.lpush(“list3”,”c”);<br>     <br>     transaction.exec();<br>     //2 transaction.discard();<br>     System.out.println(“serialNum***********”+response.get());<br>          <br>  }<br>}</p>
</li>
<li><p>加锁</p>
<p>public class TestTransaction {<br>  public boolean transMethod() {<br>     Jedis jedis = new Jedis(“127.0.0.1”, 6379);<br>     int balance;// 可用余额<br>     int debt;// 欠额<br>     int amtToSubtract = 10;// 实刷额度<br>     jedis.watch(“balance”);<br>     //jedis.set(“balance”,”5”);//此句不该出现，讲课方便。模拟其他程序已经修改了该条目<br>     balance = Integer.parseInt(jedis.get(“balance”));<br>     if (balance &lt; amtToSubtract) {<br>       jedis.unwatch();<br>       System.out.println(“modify”);<br>       return false;<br>     } else {<br>       System.out.println(“*<em><strong><em><strong><strong><strong>transaction”);<br>       Transaction transaction = jedis.multi();<br>       transaction.decrBy(“balance”, amtToSubtract);<br>       transaction.incrBy(“debt”, amtToSubtract);<br>       transaction.exec();<br>       balance = Integer.parseInt(jedis.get(“balance”));<br>       debt = Integer.parseInt(jedis.get(“debt”));<br>       System.out.println(“</strong></strong></strong></em>“ + balance);<br>       System.out.println(“</strong></em>****” + debt);<br>       return true;<br>     }<br>  }<br>  /**<br>   * 通俗点讲，watch命令就是标记一个键，如果标记了一个键， 在提交事务前如果该键被别人修改过，那事务就会失败，这种情况通常可以在程序中<br>   * 重新再尝试一次。<br>   * 首先标记了键balance，然后检查余额是否足够，不足就取消标记，并不做扣减； 足够的话，就启动事务进行更新操作，<br>   * 如果在此期间键balance被其它人修改， 那在提交事务（执行exec）时就会报错， 程序中通常可以捕获这类错误再重新执行一次，直到成功。<br>   */<br>  public static void main(String[] args) {<br>     TestTransaction test = new TestTransaction();<br>     boolean retValue = test.transMethod();<br>     System.out.println(“main retValue——-: “ + retValue);<br>  }<br>}</p>
</li>
</ul>
</li>
<li><p>主从复制</p>
<p>public static void main(String[] args) throws InterruptedException <br>  {<br>     Jedis jedis_M = new Jedis(“127.0.0.1”,6379);<br>     Jedis jedis_S = new Jedis(“127.0.0.1”,6380);<br>     <br>     jedis_S.slaveof(“127.0.0.1”,6379);<br>     <br>     jedis_M.set(“k6”,”v6”);<br>     Thread.sleep(500);<br>     System.out.println(jedis_S.get(“k6”));<br>  }</p>
<ul>
<li>6379,6380启动，先各自先独立</li>
<li>主写</li>
<li>从读</li>
</ul>
</li>
</ul>
<h3 id="JedisPool"><a href="#JedisPool" class="headerlink" title="JedisPool"></a>JedisPool</h3><ul>
<li><p>获取Jedis实例需要从JedisPool中获取</p>
</li>
<li><p>用完Jedis实例需要返还给JedisPool</p>
</li>
<li><p>如果Jedis在使用过程中出错，则也需要还给JedisPool</p>
</li>
<li><p>案例见代码</p>
<ul>
<li><p>JedisPoolUtil</p>
<p>package com.atguigu.redis.test;<br>import redis.clients.jedis.Jedis;<br>import redis.clients.jedis.JedisPool;<br>import redis.clients.jedis.JedisPoolConfig;<br>public class JedisPoolUtil {</p>
<p> private static volatile JedisPool jedisPool = null;//被volatile修饰的变量不会被本地线程缓存，对该变量的读写都是直接操作共享内存。</p>
<p>  private JedisPoolUtil() {}</p>
<p>  public static JedisPool getJedisPoolInstance()<br> {<br>     if(null == jedisPool)<br>    {<br>       synchronized (JedisPoolUtil.class)<br>      {<br>          if(null == jedisPool)<br>         {<br>           JedisPoolConfig poolConfig = new JedisPoolConfig();<br>           poolConfig.setMaxActive(1000);<br>           poolConfig.setMaxIdle(32);<br>           poolConfig.setMaxWait(100*1000);<br>           poolConfig.setTestOnBorrow(true);<br>            <br>            jedisPool = new JedisPool(poolConfig,”127.0.0.1”);<br>         }<br>      }<br>    }<br>     return jedisPool;<br> }</p>
<p>  public static void release(JedisPool jedisPool,Jedis jedis)<br> {<br>     if(null != jedis)<br>    {<br>      jedisPool.returnResourceObject(jedis);<br>    }<br> }<br>}</p>
</li>
<li><p>Demo5</p>
<p>package com.atguigu.redis.test;<br>import redis.clients.jedis.Jedis;<br>import redis.clients.jedis.JedisPool;<br>public class Test01 {<br>  public static void main(String[] args) {<br>     JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance();<br>     Jedis jedis = null;<br>     <br>     try <br>     {<br>       jedis = jedisPool.getResource();<br>       jedis.set(“k18”,”v183”);<br>       <br>     } catch (Exception e) {<br>       e.printStackTrace();<br>     }finally{<br>       JedisPoolUtil.release(jedisPool, jedis);<br>     }<br>  }<br>}</p>
<ul>
<li>jedisPool.getResource();</li>
</ul>
</li>
</ul>
</li>
<li><p>配置总结all</p>
<p>JedisPool的配置参数大部分是由JedisPoolConfig的对应项来赋值的。<br>maxActive：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted。<br>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；<br>whenExhaustedAction：表示当pool中的jedis实例都被allocated完时，pool要采取的操作；默认有三种。<br> WHEN_EXHAUSTED_FAIL –&gt; 表示无jedis实例时，直接抛出NoSuchElementException；<br> WHEN_EXHAUSTED_BLOCK –&gt; 则表示阻塞住，或者达到maxWait时抛出JedisConnectionException；<br> WHEN_EXHAUSTED_GROW –&gt; 则表示新建一个jedis实例，也就说设置的maxActive无用；<br>maxWait：表示当borrow一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛JedisConnectionException；<br>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；<br>testOnReturn：return 一个jedis实例给pool时，是否检查连接可用性（ping()）；<br>testWhileIdle：如果为true，表示有一个idle object evitor线程对idle object进行扫描，如果validate失败，此object会被从pool中drop掉；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；<br>timeBetweenEvictionRunsMillis：表示idle object evitor两次扫描之间要sleep的毫秒数；<br>numTestsPerEvictionRun：表示idle object evitor每次扫描的最多的对象数；<br>minEvictableIdleTimeMillis：表示一个对象至少停留在idle状态的最短时间，然后才能被idle object evitor扫描并驱逐；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；<br>softMinEvictableIdleTimeMillis：在minEvictableIdleTimeMillis基础上，加入了至少minIdle个对象已经在pool里面了。如果为-1，evicted不会根据idle time驱逐任何对象。如果minEvictableIdleTimeMillis&gt;0，则此项设置无意义，且只有在timeBetweenEvictionRunsMillis大于0时才有意义；</p>
<h1 id="lifo：borrowObject返回对象时，是采用DEFAULT-LIFO（last-in-first-out，即类似cache的最频繁使用队列），如果为False，则表示FIFO队列；"><a href="#lifo：borrowObject返回对象时，是采用DEFAULT-LIFO（last-in-first-out，即类似cache的最频繁使用队列），如果为False，则表示FIFO队列；" class="headerlink" title="lifo：borrowObject返回对象时，是采用DEFAULT_LIFO（last in first out，即类似cache的最频繁使用队列），如果为False，则表示FIFO队列；"></a>lifo：borrowObject返回对象时，是采用DEFAULT_LIFO（last in first out，即类似cache的最频繁使用队列），如果为False，则表示FIFO队列；</h1><p>其中JedisPoolConfig对一些参数的默认设置如下：<br>testWhileIdle=true<br>minEvictableIdleTimeMills=60000<br>timeBetweenEvictionRunsMillis=30000<br>numTestsPerEvictionRun=-1</p>
</li>
</ul>
<p><em>XMind: ZEN - Trial Version</em></p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>