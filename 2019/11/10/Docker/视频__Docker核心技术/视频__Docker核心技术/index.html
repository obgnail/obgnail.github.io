<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;为什么使用Docker&quot;&gt;&lt;a href=&quot;#为什么使用Docker&quot; class=&quot;headerlink&quot; title=&quot;为什么使用Docker&quot;&gt;&lt;/a&gt;为什么使用Docker&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;环境配置如此麻烦，换一台机器，就要重来一次，费力费时。&lt;/li&gt;
&lt;li&gt;很多人想到，能不能从根本上解决问题，&lt;strong&gt;软件可以带环境安装&lt;/strong&gt;？也就是说，安装的时候，把原始环境一模一样地复制过来。&lt;/li&gt;
&lt;li&gt;开发人员利用 Docker可以消除协作编码时“在我的机器上可正常工作”的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;打个比方 : "><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Docker核心技术 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Docker/" rel="tag">Docker</a></div><div class="post-time">2019-11-10</div></div></div><div class="container post-header"><h1>Docker核心技术</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Docker"><span class="toc-number">1.</span> <span class="toc-text">为什么使用Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%92%8C%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">2.</span> <span class="toc-text">Docker和传统虚拟化方法的不同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Docker%E8%B7%91%E5%BE%97%E6%AF%94VM%E5%BF%AB"><span class="toc-number">2.1.</span> <span class="toc-text">为什么Docker跑得比VM快?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E4%B8%89%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.</span> <span class="toc-text">Docker三个元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F-image"><span class="toc-number">3.1.</span> <span class="toc-text">镜像(image)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-container"><span class="toc-number">3.2.</span> <span class="toc-text">容器(container)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%93%E5%BA%93-repository"><span class="toc-number">3.3.</span> <span class="toc-text">仓库(repository)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-run"><span class="toc-number">4.</span> <span class="toc-text">Docker run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">Docker帮助命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-version"><span class="toc-number">5.1.</span> <span class="toc-text">docker version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-info"><span class="toc-number">5.2.</span> <span class="toc-text">docker info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E2%80%93help"><span class="toc-number">5.3.</span> <span class="toc-text">docker –help</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">6.</span> <span class="toc-text">Docker镜像命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E9%95%9C%E5%83%8F-docker-images"><span class="toc-number">6.1.</span> <span class="toc-text">列出本地主机上的镜像 docker images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F-docker-search-image-name"><span class="toc-number">6.2.</span> <span class="toc-text">查找镜像 docker search image_name</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F-docker-pull-image-name-TAG"><span class="toc-number">6.3.</span> <span class="toc-text">下载镜像 docker pull image_name[:TAG]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F-docker-rmi-image-name-ID-TAG"><span class="toc-number">6.4.</span> <span class="toc-text">删除镜像 docker rmi image_name_ID[:TAG]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">7.</span> <span class="toc-text">Docker容器命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">新建并启动容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E6%89%80%E6%9C%89%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">列出当前所有正在运行的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">7.3.</span> <span class="toc-text">退出容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">启动容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8"><span class="toc-number">7.5.</span> <span class="toc-text">重启容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">7.6.</span> <span class="toc-text">停止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">7.7.</span> <span class="toc-text">强制停止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E7%BB%8F%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">7.8.</span> <span class="toc-text">删除已经停止的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">7.9.</span> <span class="toc-text">启动守护式容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span class="toc-number">7.10.</span> <span class="toc-text">查看容器日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.11.</span> <span class="toc-text">查看容器内运行的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><span class="toc-number">7.12.</span> <span class="toc-text">查看容器内部细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B9%B6%E4%BB%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92"><span class="toc-number">7.13.</span> <span class="toc-text">进入正在运行的容器并以命令行交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">7.14.</span> <span class="toc-text">重新进入容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%AE%B9%E5%99%A8%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E6%9C%BA%E4%B8%8A"><span class="toc-number">7.15.</span> <span class="toc-text">从容器拷贝文件到主机上</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F"><span class="toc-number">9.</span> <span class="toc-text">Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UnionFS%EF%BC%88%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">UnionFS（联合文件系统）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">Docker镜像加载原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">9.3.</span> <span class="toc-text">分层的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E7%89%B9%E7%82%B9"><span class="toc-number">9.4.</span> <span class="toc-text">Docker镜像特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8Fcommit%E6%93%8D%E4%BD%9C%E8%A1%A5%E5%85%85"><span class="toc-number">9.5.</span> <span class="toc-text">Docker镜像commit操作补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">10.</span> <span class="toc-text">Docker容器数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">10.1.</span> <span class="toc-text">添加数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0"><span class="toc-number">10.1.1.</span> <span class="toc-text">直接命令添加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DockerFile%E6%B7%BB%E5%8A%A0"><span class="toc-number">10.1.2.</span> <span class="toc-text">DockerFile添加</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">10.2.</span> <span class="toc-text">数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8%E6%9D%A5%E5%A4%87%E4%BB%BD%E3%80%81%E6%81%A2%E5%A4%8D%E3%80%81%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">10.3.</span> <span class="toc-text">利用数据卷容器来备份、恢复、迁移数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD"><span class="toc-number">10.3.1.</span> <span class="toc-text">备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D"><span class="toc-number">10.3.2.</span> <span class="toc-text">恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dockerfile"><span class="toc-number">11.</span> <span class="toc-text">dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-%E5%88%86%E4%B8%BA%E5%9B%9B%E9%83%A8%E5%88%86"><span class="toc-number">11.1.</span> <span class="toc-text">Dockerfile 分为四部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%89%A7%E8%A1%8C-Dockerfile%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">11.2.</span> <span class="toc-text">Docker执行 Dockerfile的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile%E4%B8%8EDocker%E9%95%9C%E5%83%8F%E4%B8%8EDocker%E5%AE%B9%E5%99%A8"><span class="toc-number">11.3.</span> <span class="toc-text">Dockerfile与Docker镜像与Docker容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile%E8%AF%AD%E6%B3%95"><span class="toc-number">11.4.</span> <span class="toc-text">dockerfile语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerFile%E8%AF%AD%E6%B3%95%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">11.5.</span> <span class="toc-text">DockerFile语法简要说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">12.</span> <span class="toc-text">创建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerFile%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.1.</span> <span class="toc-text">DockerFile示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">12.2.</span> <span class="toc-text">较复杂的实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">13.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F"><span class="toc-number"></span> <span class="toc-text">推送镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90"><span class="toc-number"></span> <span class="toc-text">我的国内镜像源</span></a></details></div><div class="container post-content"><h2 id="为什么使用Docker"><a href="#为什么使用Docker" class="headerlink" title="为什么使用Docker"></a>为什么使用Docker</h2><ol>
<li>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。</li>
<li>很多人想到，能不能从根本上解决问题，<strong>软件可以带环境安装</strong>？也就是说，安装的时候，把原始环境一模一样地复制过来。</li>
<li>开发人员利用 Docker可以消除协作编码时“在我的机器上可正常工作”的问题。</li>
</ol>
<blockquote>
<p>打个比方 : </p>
<ul>
<li>以前搬家要将家具什么都挨个搬过去 , 搬过去过程中可能会增加/减少一些东西</li>
<li>现在是将整栋楼搬过去 , 以前是怎么样的现在就是怎么样的</li>
</ul>
<p>Docker就是将整个项目的<code>代码</code>,<code>配置</code>,<code>系统</code>,<code>数据</code>等等全部从开发搬去运维</p>
<p>这栋楼就是<code>镜像</code></p>
</blockquote>
<p>Docker镜像的设计 , 使得Docker得以打破过去<code>程序即应用</code>的观念 . 透过镜像就爱那个作业系统核心除外 , 运作应用程式多需要的系统环境 , 由下而上打包 ,达到应用程式跨平台间的无缝接轨运作.</p>
<blockquote>
<p>解决了运行环境和配置问题的软件容器 , 方便做持续集成并有助于整体发布的容器虚拟化技术</p>
</blockquote>
<h2 id="Docker和传统虚拟化方法的不同"><a href="#Docker和传统虚拟化方法的不同" class="headerlink" title="Docker和传统虚拟化方法的不同"></a>Docker和传统虚拟化方法的不同</h2><ol>
<li>传统虚拟机技术是虚拟出一套硬件后 , 在其上运行一个完整操作系统 , 在该系统上在运行所需要的应用进程</li>
<li>容器内的应用进程直接运行于宿主的内核 , 容器没有自己的内核 , 而且也没有进行硬件虚拟 . 因此容器要比传统虚拟机更为轻便 </li>
<li>每个容器之间互相隔离,每个容器有自己的文件系统 , 容器之间进程不会互相影响 , 能区分计算资源</li>
</ol>
<h3 id="为什么Docker跑得比VM快"><a href="#为什么Docker跑得比VM快" class="headerlink" title="为什么Docker跑得比VM快?"></a>为什么Docker跑得比VM快?</h3><ol>
<li>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</li>
<li>docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</li>
</ol>
<p><img src="/images/1572770296308.png" alt="1572770296308"></p>
<h2 id="Docker三个元素"><a href="#Docker三个元素" class="headerlink" title="Docker三个元素"></a>Docker三个元素</h2><h3 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像(image)"></a>镜像(image)</h3><p>镜像就是模板 . <strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong></p>
<blockquote>
<ul>
<li>image 是二进制文件。</li>
<li>实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。</li>
<li>举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</li>
</ul>
</blockquote>
<h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>容器就是镜像的实例</p>
<blockquote>
<ul>
<li><p>Docker镜像就是一个只读的模板 . 镜像可以用来创建Docker容器 , 一个镜像可以创建很多容器</p>
<p>简单理解 , 镜像就是Python里的<code>类</code> , 容器就是<code>类实例</code></p>
</li>
<li><p>Docker利用容器独立运行一个或一组应用 ,他可以被启动,开始 ,停止 ,删除.每个容器都是互相隔离的 , 保证安全的平台</p>
</li>
<li><p><strong>可以把容器看作是一个简易版的Linux环境</strong> (包括root用户权限 , 进程空间 , 用户空间和网络空间等)和运行在其中的应用程序</p>
</li>
<li><p>容器的定义和镜像几乎一模一样, 也是一堆层和统一视角 , 唯一区别在于容器的最上面那层是可读可写的.</p>
</li>
</ul>
</blockquote>
<h3 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库(repository)"></a>仓库(repository)</h3><ul>
<li>仓库是<code>集中存放镜像</code>文件的场所</li>
<li>仓库和仓库进程服务器是有区别的 . 仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的标签</li>
<li>仓库分为公开仓库和私有仓库 , 存放了数量庞大的镜像同用户下载.</li>
</ul>
<blockquote>
<p>总结 :</p>
<ul>
<li>Docker本身是一个<code>容器</code>运行载体或称之为<code>管理引擎</code> . 我们把应用层程序和配置依赖打包好 , 形成一个可交付的运行环境 , 这个打包好的运行环境就是image镜像文件 . </li>
<li>只有通过这个镜像文件才能生成Docker容器 . image文件可以看作是容器的模板 ,Docker根据image文件生成容器实例 , 同一个image文件 , 可以生成多个同时运行的容器实例</li>
<li><strong>一个容器运行一种服务</strong>, 当我们需要的时候就可以通过Docker客户端创建一个对应的运行实例</li>
<li>仓库就是放了一堆镜像的地方,我们可以把镜像发布到仓库中 , 需要的时候从仓库拉下了就可以了</li>
</ul>
</blockquote>
<h2 id="Docker-run"><a href="#Docker-run" class="headerlink" title="Docker run"></a>Docker run</h2><p><img src="/images/1572769948434.png" alt="1572769948434"></p>
<p><img src="/images/1572769657763.png" alt="1572769657763"></p>
<ul>
<li>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</li>
<li> 容器，是一个运行时环境，就是我们说的集装箱。</li>
</ul>
<p><img src="/images/1572770082996.png" alt="1572770082996"></p>
<h2 id="Docker帮助命令"><a href="#Docker帮助命令" class="headerlink" title="Docker帮助命令"></a>Docker帮助命令</h2><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h3><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h3><h3 id="docker-–help"><a href="#docker-–help" class="headerlink" title="docker –help"></a>docker –help</h3><h2 id="Docker镜像命令"><a href="#Docker镜像命令" class="headerlink" title="Docker镜像命令"></a>Docker镜像命令</h2><h3 id="列出本地主机上的镜像-docker-images"><a href="#列出本地主机上的镜像-docker-images" class="headerlink" title="列出本地主机上的镜像 docker images"></a>列出本地主机上的镜像 docker images</h3><p>列出本地主机上的镜像</p>
<ul>
<li>-a : 列出本地所有的镜像(含中间映像层)</li>
<li>-q : 只显示镜像ID</li>
<li>–digests : 显示镜像的摘要信息</li>
<li>–no-trunc :显示完整的镜像信息</li>
</ul>
<p>示例 :输入<code>docker images</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        10 months ago       1.84kB</span><br></pre></td></tr></table></figure>

<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<blockquote>
<p>同一仓库源可以有多个TAG，代表这个仓库源的不同的版本，我们使用 <code>REPOSITORY:TAG</code> 来定义不同的镜像。</p>
<p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker将默认使用 ubuntu：latest镜像</p>
</blockquote>
<h3 id="查找镜像-docker-search-image-name"><a href="#查找镜像-docker-search-image-name" class="headerlink" title="查找镜像 docker search image_name"></a>查找镜像 docker search image_name</h3><p>查找镜像</p>
<ul>
<li>–no-trunc：显示完整的镜像描述</li>
<li>-s：列出收藏数不小于指定值的镜像</li>
<li>–automated：只列出 automated build类型的镜像；</li>
</ul>
<blockquote>
<p>示例 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker search tomcat</span><br><span class="line">NAME                          DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">tomcat                        Apache Tomcat is an open source implementati…   2551                [OK]</span><br><span class="line">tomee                         Apache TomEE is an all-Apache Java EE certif…   69                  [OK]</span><br><span class="line">dordoka/tomcat                Ubuntu 14.04, Oracle JDK 8 and Tomcat 8 base…   53                                      [OK]</span><br><span class="line">bitnami/tomcat                Bitnami Tomcat Docker Image                     29                                      [OK]</span><br><span class="line">kubeguide/tomcat-app          Tomcat image for Chapter 1                      28</span><br><span class="line">consol/tomcat-7.0             Tomcat 7.0.57, 8080, &quot;admin/admin&quot;              16                                      [OK]</span><br><span class="line">cloudesire/tomcat             Tomcat server, 6/7/8                            15                                      [OK]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 点赞数高于30的tomcat镜像</span></span><br><span class="line">docker search -s 30 tomcat</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="下载镜像-docker-pull-image-name-TAG"><a href="#下载镜像-docker-pull-image-name-TAG" class="headerlink" title="下载镜像 docker pull image_name[:TAG]"></a>下载镜像 docker pull image_name[:TAG]</h3><p>下载镜像 , 如果不输入<code>:TAG</code> , 默认就是<code>:lastest</code></p>
<p>也就是说 : <code>docker pull tomcat</code>等价于<code>docker pull tomcat:lastest</code></p>
<blockquote>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat:3.2</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="删除镜像-docker-rmi-image-name-ID-TAG"><a href="#删除镜像-docker-rmi-image-name-ID-TAG" class="headerlink" title="删除镜像 docker rmi image_name_ID[:TAG]"></a>删除镜像 docker rmi image_name_ID[:TAG]</h3><blockquote>
<p><code>rmi</code> 即为 <code>remove image</code></p>
</blockquote>
<p>同理  , 如果没有TAG,默认就是lastest</p>
<ul>
<li>删除镜像</li>
<li>删除单个 : <code>docker rmi -f 镜像ID</code></li>
<li>删除多个 : <code>docker rmi -f 镜像名1:TAG 镜像名2:TAG</code></li>
<li>删除全部 : <code>docker rmi -f $(docker images -qa)</code></li>
</ul>
<p><code>docker rmi -f $(docker images -qa)</code> : 使用<code>docker images -qa</code>查出全部的image_id ,传给$</p>
<blockquote>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f hello-world</span><br></pre></td></tr></table></figure>

<p>-f : force</p>
</blockquote>
<h2 id="Docker容器命令"><a href="#Docker容器命令" class="headerlink" title="Docker容器命令"></a>Docker容器命令</h2><p><strong>有镜像才能创建容器，这是根本前提</strong></p>
<blockquote>
<p>下载一个 Centos<code>镜像</code>演示 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [options] image [<span class="built_in">command</span>] [arg...]</span><br></pre></td></tr></table></figure>

<p><code>docker run 容器id或者容器名</code> :<strong>依照某个镜像创建一个镜像实例(容器),然后将这个容器跑起来</strong></p>
<ul>
<li>–name=”容器新名字”: 为容器指定一个名称；</li>
<li>-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</li>
<li><strong>-i：以交互模式运行容器，通常与 -t 同时使用；</strong></li>
<li><strong>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</strong></li>
<li>-P: 随机端口映射；</li>
<li>-p: 指定端口映射，有以下四种格式<ol>
<li>ip:hostPort:containerPort</li>
<li>ip::containerPort</li>
<li>hostPort:containerPort</li>
<li>containerPort</li>
</ol>
</li>
</ul>
<blockquote>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it  centos</span><br><span class="line"><span class="built_in">pwd</span> </span><br><span class="line"><span class="comment"># 返回/</span></span><br></pre></td></tr></table></figure>

<p>解释 : </p>
<ol>
<li>-i 以交互形式运行容器 , -t 新建一个伪终端</li>
<li>所以<code>docker run -it  centos</code>就是以交互的形式新建一个centos容器.并且进入这个容器,打开容器的终端</li>
<li>所以输入的<code>pwd</code>就是检查centos的当前文件路径,也就是root</li>
</ol>
</blockquote>
<h3 id="列出当前所有正在运行的容器"><a href="#列出当前所有正在运行的容器" class="headerlink" title="列出当前所有正在运行的容器"></a>列出当前所有正在运行的容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [options]</span><br></pre></td></tr></table></figure>

<ul>
<li>-a :列出当前所有正在运行的容器+历史上运行过的</li>
<li>-l :显示最近创建的容器。</li>
<li>-n：显示最近n个创建的容器。</li>
<li>-q :静默模式，只显示容器编号。</li>
<li>–no-trunc :不截断输出。</li>
</ul>
<blockquote>
<p>就是查看鲸鱼背上有哪几个集装箱</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">2cb96ad7dfdc        centos              <span class="string">&quot;/bin/bash&quot;</span>         21 minutes ago      Exited (0) 16 minutes ago                       condescending_williamson</span><br></pre></td></tr></table></figure>

<ul>
<li>CONTAINER ID:容器的唯一表示ID。</li>
<li>IMAGE:创建容器时使用的镜像。</li>
<li>COMMAND:<strong>容器最后运行的命令</strong>。</li>
<li>CREATED:创建容器的时间。</li>
<li>STATUS:容器状态。</li>
<li>PORTS:对外开放的端口。</li>
<li>NAMES:容器名。可以和容器ID一样唯一标识容器，同一台宿主机上不允许有同名容器存在，否则会冲突。</li>
</ul>
<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器停止退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器不停止退出</span></span><br><span class="line">ctrl + P + Q</span><br></pre></td></tr></table></figure>



<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID或者容器名</span><br></pre></td></tr></table></figure>



<h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器ID或者容器名</span><br></pre></td></tr></table></figure>



<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID或者容器名</span><br></pre></td></tr></table></figure>



<h3 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> 容器ID或者容器名</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>docker stop 容器ID或者容器名</code>和<code>docker kill 容器ID或者容器名</code>两者的区别:</p>
<ol>
<li><code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</li>
<li>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</li>
</ol>
</blockquote>
<h3 id="删除已经停止的容器"><a href="#删除已经停止的容器" class="headerlink" title="删除已经停止的容器"></a>删除已经停止的容器</h3><p>删除单个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器ID或者容器名</span><br></pre></td></tr></table></figure>

<p>删除多个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm ID1 ID2 ID3... </span><br></pre></td></tr></table></figure>

<p>删除全部</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a -q | xargs docker rm</span><br></pre></td></tr></table></figure>



<h3 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h3><p>以<strong>后台模式</strong>启动一个容器:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 容器名</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：然后使用<code>docker ps -a </code>进行查看, 会发现<strong>容器已经退出</strong></p>
<p>说明: </p>
<ol>
<li><strong>Docker容器后台运行,就必须有一个前台进程.</strong></li>
<li>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就会自动退出。</li>
</ol>
<p>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。</p>
<p>例如<code>service nginx start</code></p>
<p>但是,这样做,nginx为后台进程模式运行,就导致<strong>docker前台没有运行的应用</strong>,</p>
<p>这样的容器后台启动后,会立即自杀,因为他觉得他没事可做了.</p>
<p>所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行</p>
<p>看下面命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos /bin/sh -c <span class="string">&quot;while true;do echo hello zzyy;sleep 2;done&quot;</span></span><br></pre></td></tr></table></figure>

<p>要分成两段:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos</span><br><span class="line">/bin/sh -c <span class="string">&quot;while true;do echo hello zzyy;sleep 2;done&quot;</span></span><br></pre></td></tr></table></figure>

<p>也就是 :</p>
<ol>
<li>后台执行centos</li>
<li>前端bash执行shell脚本</li>
</ol>
<p>这样保证了容器的前台一直活着 , 后台就不会退出了</p>
<p>我们可以使用<code>docker ps</code>验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">0b519370107e        centos              <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   6 seconds ago       Up 4 seconds                            lucid_noyce</span><br></pre></td></tr></table></figure>

<p>或者也可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos tail -f /dev/null</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><p>即容器里面 Shell 的标准输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail n 容器ID</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg:</span></span><br><span class="line">docker logs -f -t --tail 7 97bb985e65df</span><br></pre></td></tr></table></figure>

<ul>
<li>-t :加入时间戳</li>
<li>-f :跟随最新的日志打印</li>
<li>–tail :数字显示最后多少条</li>
</ul>
<h3 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure>



<h3 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>



<h3 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器ID bashShell</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不进入容器,但是让容器执行ls命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -t cc52328f4d92 ls</span><br><span class="line"><span class="comment"># bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var</span></span><br><span class="line"><span class="comment"># dev  home  lib64  media       opt  root  sbin  sys  usr</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="重新进入容器"><a href="#重新进入容器" class="headerlink" title="重新进入容器"></a>重新进入容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当你使用<code>ctrl+p+q</code>不停止推出容器后就可以使用此命令重新进入容器</p>
</blockquote>
<blockquote>
<p>attach 和 exec 的区别</p>
<ol>
<li><code>attach</code>直接进入容器启动命令的终端，不会启动新的进程</li>
<li><code>exec</code>是在容器中打开新的终端，并且可以启动新的进程</li>
</ol>
</blockquote>
<h3 id="从容器拷贝文件到主机上"><a href="#从容器拷贝文件到主机上" class="headerlink" title="从容器拷贝文件到主机上"></a>从容器拷贝文件到主机上</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目的主机路径</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp cc52328f4d92:/tmp/req.py c:/</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/1572788521271.png" alt="1572788521271"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">attach    Attach to a running container                 <span class="comment"># 当前 shell 下 attach 连接指定运行镜像</span></span><br><span class="line">build     Build an image from a Dockerfile              <span class="comment"># 通过 Dockerfile 定制镜像</span></span><br><span class="line">commit    Create a new image from a container changes   <span class="comment"># 提交当前容器为新的镜像</span></span><br><span class="line">cp        Copy files/folders from the containers filesystem to the host path   <span class="comment">#从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class="line">create    Create a new container                        <span class="comment"># 创建一个新的容器，同 run，但不启动容器</span></span><br><span class="line">diff      Inspect changes on a container<span class="string">&#x27;s filesystem   # 查看 docker 容器变化</span></span><br><span class="line"><span class="string">events    Get real time events from the server          # 从 docker 服务获取容器实时事件</span></span><br><span class="line"><span class="string">exec      Run a command in an existing container        # 在已存在的容器上运行命令</span></span><br><span class="line"><span class="string">export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span><br><span class="line"><span class="string">history   Show the history of an image                  # 展示一个镜像形成历史</span></span><br><span class="line"><span class="string">images    List images                                   # 列出系统当前镜像</span></span><br><span class="line"><span class="string">import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span></span><br><span class="line"><span class="string">info      Display system-wide information               # 显示系统相关信息</span></span><br><span class="line"><span class="string">inspect   Return low-level information on a container   # 查看容器详细信息</span></span><br><span class="line"><span class="string">kill      Kill a running container                      # kill 指定 docker 容器</span></span><br><span class="line"><span class="string">load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</span></span><br><span class="line"><span class="string">login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器</span></span><br><span class="line"><span class="string">logout    Log out from a Docker registry server          # 从当前 Docker registry 退出</span></span><br><span class="line"><span class="string">logs      Fetch the logs of a container                 # 输出当前容器日志信息</span></span><br><span class="line"><span class="string">port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口</span></span><br><span class="line"><span class="string">pause     Pause all processes within a container        # 暂停容器</span></span><br><span class="line"><span class="string">ps        List containers                               # 列出容器列表</span></span><br><span class="line"><span class="string">pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class="line"><span class="string">push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器</span></span><br><span class="line"><span class="string">restart   Restart a running container                   # 重启运行的容器</span></span><br><span class="line"><span class="string">rm        Remove one or more containers                 # 移除一个或者多个容器</span></span><br><span class="line"><span class="string">rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span><br><span class="line"><span class="string">run       Run a command in a new container              # 创建一个新的容器并运行一个命令</span></span><br><span class="line"><span class="string">save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</span></span><br><span class="line"><span class="string">search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</span></span><br><span class="line"><span class="string">start     Start a stopped containers                    # 启动容器</span></span><br><span class="line"><span class="string">stop      Stop a running containers                     # 停止容器</span></span><br><span class="line"><span class="string">tag       Tag an image into a repository                # 给源中镜像打标签</span></span><br><span class="line"><span class="string">top       Lookup the running processes of a container   # 查看容器中运行的进程信息</span></span><br><span class="line"><span class="string">unpause   Unpause a paused container                    # 取消暂停容器</span></span><br><span class="line"><span class="string">version   Show the docker version information           # 查看 docker 版本号</span></span><br><span class="line"><span class="string">wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure>



<h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包<strong>软件运行环境和基于运行环境开发的软件</strong>，它包含运行某个软件所需的所有内容包括代码、运行时、库、环境变量和配置文件。</p>
<h3 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h3><ul>
<li>Union文件系统（UnionFS）是一种分层、轻量级并且高性能的<code>文件系统</code>，它支持<strong>对文件系统的修改作为一次提交来一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</li>
<li>Union 文件系统是 Docker 镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</li>
<li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</li>
</ul>
<h3 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h3><ul>
<li>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</li>
<li>bootfs(boot file system)主要包含<code>bootloader</code>和<code>kernel</code>, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</li>
<li>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</li>
</ul>
<blockquote>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？</p>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
</blockquote>
<h3 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h3><ul>
<li>tomcat应用需要依赖于JDK8 , </li>
<li>JDK8需要依赖操作系统centos , </li>
<li>centos需要内核Kernel</li>
</ul>
<p>![Untitled Diagram](/images/Untitled Diagram.png)</p>
<p>因此 , 我们就可以将tomcat项目拆分成4层</p>
<blockquote>
<p>为什么 Docker镜像要采用这种分层结构呢</p>
<ul>
<li><p>最大的一个好处就是 : <strong>共享资源</strong></p>
</li>
<li><p>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，</p>
<p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
</li>
<li><p>下图 , tomcat和Maven共享了JDK8这个镜像 </p>
<p><img src="/images/1572873351908.png" alt="1572873351908"></p>
</li>
</ul>
</blockquote>
<h3 id="Docker镜像特点"><a href="#Docker镜像特点" class="headerlink" title="Docker镜像特点"></a>Docker镜像特点</h3><ul>
<li>Docker镜像都是只读的。</li>
<li>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作<code>容器层</code>，容器层之下的都叫<code>镜像层</code>。</li>
</ul>
<h3 id="Docker镜像commit操作补充"><a href="#Docker镜像commit操作补充" class="headerlink" title="Docker镜像commit操作补充"></a>Docker镜像commit操作补充</h3><ul>
<li><p><code>docker commit</code> : 提交<code>容器副本</code>使之成为一个新的镜像</p>
<p>完整语法 : <code>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名[标签名]</code></p>
</li>
<li><p>示例 :</p>
<ol>
<li><p>从Hub上下载 tomcat镜像到本地并成功运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8080:8080 tomcat</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> : <code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问</li>
<li><code>-P</code> : 随机分配端口</li>
</ul>
</blockquote>
</li>
<li><p>删除镜像生成的tomcat容器中的文档</p>
</li>
<li><p>当前的 tomcat运行实例是一个没有文档内容的容器，以它为模板 commit 一个没有doc的 Tomcat新镜像 tomcat02</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a=<span class="string">&quot;hyl&quot;</span> -m=<span class="string">&quot;del tomcat docs&quot;</span> d525cea537 tomcat02:1.2</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h2><ul>
<li><p>Docker容器产生的数据，如果不通过docker commit生成新的镜像使得数据做为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。</p>
</li>
<li><p>为了能保存数据在docker中我们使用<code>卷</code>。</p>
</li>
<li><p>卷的功能:</p>
<ol>
<li>容器的持久化</li>
<li>容器间继承+共享数据</li>
</ol>
</li>
<li><p>Docker容器数据卷 : 将容器产生的数据持久化</p>
</li>
<li><p>将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</p>
</li>
<li><p>容器之间希望有可能共享数据</p>
<blockquote>
<p>比如说 , 一个web项目需要Tomcat容器和MySQL容器 . 我们需要将Tomcat产生的数据储存到MySQL容器中</p>
</blockquote>
</li>
</ul>
<ul>
<li><strong>卷就是目录或文件</strong>，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性.</li>
<li>卷的设计目的就是数据的持久化，<strong>完全独立于容器的生存周期</strong>，因此Docker不会在容器删除时删除其挂载的数据卷</li>
<li>特点：<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接生效</li>
<li><strong>数据卷中的更改不会包含在镜像的更新中</strong></li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
</li>
</ul>
<h3 id="添加数据卷"><a href="#添加数据卷" class="headerlink" title="添加数据卷"></a>添加数据卷</h3><p>数据卷可以提供很多有用的特性，如下所示：</p>
<ol>
<li>数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便；</li>
<li>对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作；</li>
<li>对数据卷的更新不会影响镜像，解耦了应用和数据；</li>
<li><strong>卷会一直存在，直到没有容器使用，可以安全地卸载它</strong>。</li>
</ol>
<h4 id="直接命令添加"><a href="#直接命令添加" class="headerlink" title="直接命令添加"></a>直接命令添加</h4><ul>
<li><p>添加数据卷命令 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v  /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure></li>
<li><p>功能 : 链接两个目录 , <strong>互通数据</strong></p>
</li>
<li><p>示例 :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /home:/me  centos</span><br></pre></td></tr></table></figure></li>
<li><p>查看数据卷是否挂载成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>

<p>返回 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Volumes&quot;: &#123;</span><br><span class="line">    &#x27;/container_dir&#x27;:&#x27;/host_dir&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;VolumesRW&quot;: &#123;</span><br><span class="line">    &#x27;/container_dir&#x27;:true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>只读的添加数据卷命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure></li>
<li><p><code>ro</code> : 即 read only . 使用<code>ro</code>的话,只能从宿主机传数据给容器 , 容器不能传数据给宿主机</p>
</li>
<li><p>此时使用<code>docker inpect 容器ID</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Volumes&quot;: &#123;</span><br><span class="line">    &#x27;/container_dir&#x27;:&#x27;/host_dir&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;VolumesRW&quot;: &#123;</span><br><span class="line">    &#x27;/container_dir&#x27;:false</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="DockerFile添加"><a href="#DockerFile添加" class="headerlink" title="DockerFile添加"></a>DockerFile添加</h4><ul>
<li><p>DockerFIle是什么?</p>
<blockquote>
<p>Docker images的描述文件 . 有点类似于<code>shell编程</code></p>
</blockquote>
</li>
<li><p>DockerFile中的VOLUME：授权访问从容器内到主机上的目录。</p>
</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME[<span class="string">&quot;/dataVolumeContainer&quot;</span>,<span class="string">&quot;/dataVolumeContainer2&quot;</span>,<span class="string">&quot;/dataVolumeContainer3&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>添加数据卷命令是 :</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v  /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>

<ul>
<li><p>但是dockerfile中的<code>VOLUME</code>不允许添加<code>宿主机绝对路径目录</code></p>
</li>
<li><p>原因 : 出于可移植和分享的考虑，用<code>-v 主机目录:容器目录</code>这种方法不能够直接在Dockerfile中实现。</p>
<p>由于宿主机目录是依赖于特定宿主机的，并<strong>不能够保证在所有的宿主机上都存在这样的特定目录</strong>。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>示例:</p>
<ol>
<li><p>创建dockerfile</p>
<p>在mydocker目录下创建<code>DockerFIle文件</code>,取名为my_dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line">COLUME [<span class="string">&quot;/container_dir1&quot;</span>,<span class="string">&quot;/container_dir2&quot;</span>]</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;finished,---success&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的dockerfile就可以翻译成下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /host1:/container_dir1 -v host2:/container_dir2 centos /bin/bash</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>执行docker build</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /mydocker/my_dockerfile -t my_centos .</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>-f</code> : file , 指明dockerfile的路径(因为dockerFile文件的文件名可以任意取)</li>
<li><code>-t</code> : 指定 image 文件的名字</li>
<li><code>.</code> : 表示在当前目录创建image</li>
</ul>
<p>整个命令的翻译 : 使用mydocker目录下的my_dockerfile这个DockerFile文件, 在当前目录下创建一个名字为my_centos的image</p>
</blockquote>
</li>
<li><p>创建镜像my_centos的容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it my_centos</span><br></pre></td></tr></table></figure>

<p>此时就会发现新建的centos的容器中 , 就会自动生成两个数据卷(<code>container_dir1</code>,<code>container_dir2</code>)</p>
<blockquote>
<ul>
<li>因为我们在创建my_centos容器的时候没有传入<code>宿主机的数据卷目录</code> , 那么在宿主机上就会自动创建一个默认的<code>数据卷目录</code></li>
<li>也就是说 , 即使我们没有传入<code>宿主机的数据卷目录</code> , my_centos容器也会自动挂载数据卷 . 一样可以进行数据交互</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p>备注 :<br>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied</p>
<p>解决办法：在挂载目录后多加一个<code>--privileged=true</code>参数即可.</p>
<p>也就是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v  /宿主机绝对路径目录:/容器内目录 --privileged=<span class="literal">true</span>  镜像名</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>什么是数据卷容器?</p>
<blockquote>
<ul>
<li>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器</li>
<li>说人话 : 移动硬盘挂载移动硬盘,实现数据的传递依赖. 有一个容器A有数据卷 , 然后其他容器B挂载到容器A , 这样,当宿主机传递数据给容器A , 容器A再传给其他容器B , 实现了数据的传递</li>
<li>简单来说 , <strong>数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</strong>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>数据卷（Data Volumes）：容器内数据直接映射到本地主机环境</p>
<p>主要问题 : 如何在容器内创建数据卷，并且把本地的目录或文件挂载到容器内的数据卷中。</p>
</li>
<li><p>数据卷容器（Data Volume Containers）：使用特定容器维护数据卷。</p>
<p>主要问题 : 如何使用数据卷容器在容器和主机、容器和容器之间共享数据，并实现数据的备份和恢复。</p>
</li>
</ul>
</blockquote>
<p>示例 :</p>
<ol>
<li><p>首先，创建一个数据卷容器dbdata，并在其中创建一个数据卷挂载到/dbdata：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /dbdata --name dbdata ubuntu</span><br></pre></td></tr></table></figure></li>
<li><p>然后，可以在其他容器中使用<code>--volumes-from</code>来挂载dbdata容器中的数据卷. 创建db1和db2两个容器，并从dbdata容器挂载数据卷：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="line">docker run -it --volumes-from dbdata --name db2 ubuntu</span><br></pre></td></tr></table></figure>

<p>此时，容器db1和db2都挂载同一个数据卷到相同的/dbdata目录。<strong>三个容器任何一方在该目录下的写入，其他容器都可以看到</strong>。</p>
<blockquote>
<ul>
<li>使用<code>--volumes-from</code>参数所挂载数据卷的容器自身并不需要保持在运行状态。</li>
<li>如果删除了挂载的容器（包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用<code>docker rm -v</code>命令来指定同时删除关联的容器。</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</strong></p>
</blockquote>
<h3 id="利用数据卷容器来备份、恢复、迁移数据卷"><a href="#利用数据卷容器来备份、恢复、迁移数据卷" class="headerlink" title="利用数据卷容器来备份、恢复、迁移数据卷"></a>利用数据卷容器来备份、恢复、迁移数据卷</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>首先使用 <code>--volumes-from</code> 标记来创建一个加载 dbdata 容器卷的容器，并从本地主机挂载当前到容器的 /backup 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --volumes-from dbdata -v $(<span class="built_in">pwd</span>):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>首先利用ubuntu镜像创建了一个容器worker。</li>
<li>使用–volumes-from dbdata参数来让worker容器挂载dbdata容器的数据卷(即dbdata数据卷),</li>
<li>使用-v  $(pwd):/backup参数来挂载本地的当前目录到worker容器的/backup目录。</li>
<li>worker容器启动后，使用了tar cvf  /backup/backup.tar /dbdata命令来将/dbdata下内容备份为容器内的/backup/backup.tar，即宿主主机当前目录下的backup.tar。</li>
</ol>
</blockquote>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>首先创建一个带有数据卷的容器 dbdata2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>然后创建另一个容器，挂载 dbdata2 的容器，并使用 <code>untar</code> 解压备份文件到挂载的容器卷中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --volumes-from dbdata2 -v $(<span class="built_in">pwd</span>):/backup busybox tar xvf</span><br><span class="line">/backup/backup.tar</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from dbdata2 -v $(<span class="built_in">pwd</span>):/backup --name worker ubuntu bash</span><br><span class="line"><span class="built_in">cd</span> /dbdata</span><br><span class="line">tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure>



<h2 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h2><ul>
<li>Dockerfile 文件是一个文本文件，用来配置 image。</li>
<li>构建三步走 : <ol>
<li>Dockerfile文件</li>
<li>docker build</li>
<li>docker run</li>
</ol>
</li>
</ul>
<h3 id="Dockerfile-分为四部分"><a href="#Dockerfile-分为四部分" class="headerlink" title="Dockerfile 分为四部分"></a>Dockerfile 分为四部分</h3><ul>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时执行指令。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This dockerfile uses the ubuntu image</span></span><br><span class="line"><span class="comment"># VERSION 2 - EDITION 1</span></span><br><span class="line"><span class="comment"># Author: docker_user</span></span><br><span class="line"><span class="comment"># Command format: Instruction [arguments / command] ..</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Base image to use, this must be set as the first line</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Maintainer: docker_user &lt;docker_user at email.com&gt; (@docker_user)</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> docker_user docker_user@email.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands to update the image</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot;</span> &gt;&gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;\ndaemon off;&quot;</span> &gt;&gt; /etc/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands when creating a new container</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/sbin/nginx</span></span><br></pre></td></tr></table></figure>



<h3 id="Docker执行-Dockerfile的流程"><a href="#Docker执行-Dockerfile的流程" class="headerlink" title="Docker执行 Dockerfile的流程"></a>Docker执行 Dockerfile的流程</h3><ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似 docker commit 的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行 dockerfile中的下一条指令直到所有指令都执行完成</li>
</ol>
<h3 id="Dockerfile与Docker镜像与Docker容器"><a href="#Dockerfile与Docker镜像与Docker容器" class="headerlink" title="Dockerfile与Docker镜像与Docker容器"></a>Dockerfile与Docker镜像与Docker容器</h3><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>
<ul>
<li><p>Dockerfile是软件的原材料</p>
</li>
<li><p>Docker镜像是软件的交付品</p>
</li>
<li><p>Docker容器则可以认为是软件的运行态。</p>
</li>
</ul>
<blockquote>
<ul>
<li>Dockerfile面向开发，</li>
<li>Docker镜像成为交付标准，</li>
<li>Docker容器则涉及部署与运维，</li>
</ul>
<p>三者缺一不可，合力充当Docker体系的基石。</p>
</blockquote>
<p><img src="/images/1573026242509.png" alt="1573026242509"></p>
<ol>
<li>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li>
<li>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</li>
<li>Docker容器，容器是直接提供服务的。</li>
</ol>
<h3 id="dockerfile语法"><a href="#dockerfile语法" class="headerlink" title="dockerfile语法"></a>dockerfile语法</h3><ul>
<li>支持的语法命令 : <code>INSTRUCTION argument</code> . 指令不区分大小写。但是，命名约定为全部大写。</li>
<li>Dockerfile文件中命令的顺序就是命令被执行的顺序。</li>
<li><strong>每条指令都会创建一个新的镜像层，并对镜像进行提交</strong></li>
</ul>
<ol>
<li><p>FROM : <code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code></p>
<blockquote>
<ul>
<li>所有Dockerfile都必须以<code>FROM</code>命令开始。 <code>FROM</code>命令会指定镜像基于哪个基础镜像创建，接下来的命令也会基于这个基础镜像 . <code>FROM</code>命令可以多次使用，表示会创建多个镜像。</li>
<li>所有镜像的祖先类都是<code>scratch</code> , 也就是<code>base image</code></li>
</ul>
</blockquote>
</li>
<li><p>MAINTAINER：<code>MAINTAINER &lt;name&gt;</code> , 设置该镜像的作者。</p>
</li>
<li><p>RUN：在shell或者exec的环境下执行的命令。每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并<strong>提交为新的镜像</strong>。当命令较长时可以使用 <code>\</code> 来换行。</p>
<blockquote>
<p>RUN有两种形式：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> &lt;<span class="built_in">command</span>&gt; </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>前者将在 shell 终端中运行命令，即 <code>/bin/sh -c</code>；</li>
<li>后者则使用 <code>exec</code> 执行。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>。</li>
</ul>
</blockquote>
</li>
<li><p>ADD：<code>ADD &lt;src&gt; &lt;dest&gt;</code>该命令将复制指定的 <code>&lt;src&gt;</code> 到容器中的 <code>&lt;dest&gt;</code>。 其中 <code>&lt;src&gt;</code> 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。</p>
</li>
<li><p>CMD：提供了容器<strong>默认</strong>的执行命令。 Dockerfile只允许使用一次CMD指令。 使用多个CMD会抵消之前所有的指令，只有最后一个指令生效。 </p>
<blockquote>
<p> CMD有三种形式：</p>
 <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> 使用 <code>exec</code> 执行，推荐方式；</li>
<li><code>CMD command param1 param2</code> 在 <code>/bin/sh</code> 中执行，提供给需要交互的应用；</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 提供给 <code>ENTRYPOINT</code> 的默认参数；</li>
</ul>
</blockquote>
</li>
<li><p>EXPOSE : <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>指定容器在运行时监听的端口。</p>
<blockquote>
<ul>
<li>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。</li>
<li><code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是<strong>声明容器打算使用什么端口</strong>而已，并不会自动在宿主进行端口映射。</li>
</ul>
</blockquote>
</li>
<li><p>COPY:  <code>COPY &lt;src&gt; &lt;dest&gt;</code> . 复制本地主机的 <code>&lt;src&gt;</code>（为 Dockerfile 所在目录的相对路径）到容器中的 <code>&lt;dest&gt;</code>。</p>
<p>当使用本地目录为源目录时，推荐使用 <code>COPY</code>。</p>
</li>
<li><p>ENTRYPOINT：配置容器启动后执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖。类似于<code>CMD</code>，Docker只允许一个ENTRYPOINT，多个ENTRYPOINT只执行最后的ENTRYPOINT指令。</p>
<blockquote>
<p>ENTRYPOINT有两种形式：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>WORKDIR： <code>WORKDIR /path/to/workdir</code>。指定<code>RUN</code>、<code>CMD</code>与<code>ENTRYPOINT</code>命令的工作目录。</p>
<blockquote>
<p>可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<p>则最终路径为 <code>/a/b/c</code></p>
</blockquote>
</li>
<li><p>ENV： <code>ENV &lt;key&gt; &lt;value&gt;</code> .  指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持。</p>
</li>
<li><p>USER：<code>USER daemon</code> .指定运行容器时的用户名或 UID，后续的 <code>RUN</code> 也会使用指定用户。</p>
</li>
<li><p>VOLUME：<code>VOLUME [&quot;/data&quot;]</code>。创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。授权访问从容器内到主机上的目录。</p>
</li>
<li><p>ONBUILD: <code>ONBUILD [INSTRUCTION]</code>。配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image name&gt;</span><br><span class="line"><span class="keyword">MAINTAINER</span> &lt;author name&gt;</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> 《<span class="built_in">command</span>》</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> 《src》 《destination》</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt;;</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">USER</span> &lt;uid&gt;</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>copy和add的异同:</p>
<ul>
<li><p>都是复制 , 但是add比copy强大.add还支持解压缩</p>
</li>
<li><p>也就是说 : <code>add = copy + 解压缩</code></p>
</li>
</ul>
<p>CMD 和 ENTRYPOINT 的异同:</p>
<ul>
<li>都是容器<strong>启动</strong>时要运行的命令</li>
<li>对于<code>docker run -it cat tmp/</code>这条命令中的<code>cat tmp/</code>表示容器创建后执行的命令 , 这条cat命令会覆盖CMD的命令 , 但是不会覆盖ENTRYPOINT的命令 , 而是在ENTRYPOINT命令后追加cat命令</li>
<li>也就是说 , <ol>
<li><strong>CMD会被 docker run之后的参数替换</strong> , </li>
<li>docker run之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="DockerFile语法简要说明"><a href="#DockerFile语法简要说明" class="headerlink" title="DockerFile语法简要说明"></a>DockerFile语法简要说明</h3><ol>
<li>FROM : 基础镜像，当前新镜像是基于哪个镜像的</li>
<li>MAINTAINER : 镜像维护者的姓名和邮箱地址</li>
<li>RUN : 容器构建时需要运行的命令</li>
<li>EXPOSE : 当前容器对外暴露出的端口</li>
<li>WORKDIR : 指定在创建容器后，终端默认登陆的进来工作目录，是一个落脚点</li>
<li>ENV : 用来在构建镜像过程中设置环境变量(这个环境变量可以在后续的任何RUN指令中使用)</li>
<li>ADD : 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</li>
<li>COPY : 类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</li>
<li>VOLUME : 容器数据卷，用于数据保存和持久化工作</li>
<li>CMD : 指定一个容器<strong>启动</strong>时要运行的命令 , Dockerfille中可以有多个CMD指令，但只有最后一个生效，会被 docker run之后的参数替换</li>
<li>ENTRYPOINT : 指定一个容器启动时要运行的命令 , ENTRYPOINT 的目的和CMD一样，都是在指定容器启动程序及参数</li>
<li>ONBUILD : 触发器 , 当构建一个被继承的 Dockerfile 时运行命令，父镜像在被子继承后父镜像的 ONBUILD 被触发</li>
</ol>
<p>示例一 :</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li>
<li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li>
<li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li>
<li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>
<li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>
</ul>
<p>示例二:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.4</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构建一个基于 Python 3.4 的镜像</li>
<li>把当前目录添加到镜像中的 /code 路径下</li>
<li>把工作路径设置成 /code</li>
<li>安装 Python 依赖</li>
<li>设置容器的默认命令为 <code>python app.py</code></li>
</ul>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>编写完成 Dockerfile 之后，可以通过 <code>docker build</code> 命令来创建镜像。</p>
<p>基本的格式为 <code>docker build [选项] 路径</code>，该命令将读取指定路径下（包括子目录）的 Dockerfile，并将该路径下所有内容发送给 Docker 服务端，由服务端来创建镜像。因此一般建议放置 Dockerfile 的目录为空目录。也可以通过 <code>.dockerignore</code> 文件（每一行添加一条匹配模式）来让 Docker 忽略路径下的目录和文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。</li>
<li>如果不指定，默认的标签就是<code>latest</code>。</li>
<li>最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</li>
</ul>
<h3 id="DockerFile示例"><a href="#DockerFile示例" class="headerlink" title="DockerFile示例"></a>DockerFile示例</h3><p>现在的centos创建的默认路径为根目录 , 不支持使用vim和ifconfig , 现在自定义一个centos,使之登录后默认路径为/tmp,拥有vim编辑器,支持ifconfig</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">ENV default_path /tmp</span><br><span class="line">WORKDIR $default_path</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>执行<code>docker build -t mycentos .</code> 创建image</p>
<p>执行<code>docker run -it mycentos</code> 创建运行容器</p>
<p>执行<code>docker history mycentos</code> 查看image创建历史</p>
<p>使用ENTRTPORINT支持自行添加参数</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y curl</span></span><br><span class="line">ENTRTPORINT [<span class="string">&quot;curl&quot;</span> , <span class="string">&quot;-s&quot;</span> , <span class="string">&quot;http://ip.cn&quot;</span>]</span><br></pre></td></tr></table></figure>

<ol>
<li>执行<code>docker build -f Docker -t mycentos .</code></li>
<li>执行<code>docker run mycentos</code> . 成功 . 相当于执行<code>curl -s http://ip.cn</code></li>
<li>执行<code>docker run mycentos -i</code> . 成功 . 相当于执行<code>curl -s http://ip.cn -i</code></li>
</ol>
<p>onbuild:当父镜像被继承之后 , onbuild就会被触发</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y curl</span></span><br><span class="line">ENTRTPORINT [<span class="string">&quot;curl&quot;</span> , <span class="string">&quot;-s&quot;</span> , <span class="string">&quot;http://ip.cn&quot;</span>]</span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;=== father image onbuild ===&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>就是响应dockerfile中的<code>FROM</code>命令</p>
<h3 id="较复杂的实例"><a href="#较复杂的实例" class="headerlink" title="较复杂的实例"></a>较复杂的实例</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>         centos</span><br><span class="line"><span class="keyword">MAINTAINER</span>    zzyy&lt;zzyybs@<span class="number">126</span>.com&gt;</span><br><span class="line"><span class="comment">#把宿主机当前目录下的c.txt拷贝到容器/usr/local/路径下,并重命名为cincontainer.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> c.txt /usr/<span class="built_in">local</span>/cincontainer.txt</span></span><br><span class="line"><span class="comment">#把当前目录下的java包与tomcat包添加到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u171-linux-x64.tar.gz /usr/<span class="built_in">local</span>/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> apache-tomcat-9.0.8.tar.gz /usr/<span class="built_in">local</span>/</span></span><br><span class="line"><span class="comment">#安装vim编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"><span class="comment">#设置工作访问时候的WORKDIR路径，登录落脚点</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="comment">#配置java与tomcat环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_171</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_BASE /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"><span class="comment">#容器运行时监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">8080</span></span><br><span class="line"><span class="comment">#启动时运行tomcat</span></span><br><span class="line"><span class="comment"># ENTRYPOINT [&quot;/usr/local/apache-tomcat-9.0.8/bin/startup.sh&quot; ]</span></span><br><span class="line"><span class="comment"># CMD [&quot;/usr/local/apache-tomcat-9.0.8/bin/catalina.sh&quot;,&quot;run&quot;]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/<span class="built_in">local</span>/apache-tomcat-9.0.8/bin/logs/catalina.out</span></span><br></pre></td></tr></table></figure>



<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/1573268919481.png" alt="1573268919481"></p>
<h1 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h1><p>首先由容器生成镜像</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a hyl -m <span class="string">&quot;mycentos&quot;</span> c112312 mycentos:<span class="number">1.4</span></span><br></pre></td></tr></table></figure>

<p>将本地的c112312镜像 命名为mycentos:1.4</p>
<ul>
<li>-a是<code>author</code> , 作者</li>
<li>-m是<code>comment</code> , 说明注释</li>
</ul>
<p>推送镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login --username= registry.cn-hangzhou.alyuncs.com</span><br><span class="line">sudo docker tag [ImageID] registry.rn-hangzhou.aliyuncs.com/hyl/mycentos:[镜像版本号]</span><br><span class="line">sudo docker push registry.cn-hangzhou.aliyuncs.com/hyl/mycentos:[镜像版本号]</span><br></pre></td></tr></table></figure>



<h1 id="我的国内镜像源"><a href="#我的国内镜像源" class="headerlink" title="我的国内镜像源"></a>我的国内镜像源</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh default</span><br><span class="line"></span><br><span class="line">sudo sed -i <span class="string">&quot;s|EXTRA_ARGS=&#x27;|EXTRA_ARGS=&#x27;--registry-mirror=https://01bg3cok.mirror.aliyuncs.com |g&quot;</span> /var/lib/boot2docker/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">docker-machine restart default</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh default</span><br><span class="line"></span><br><span class="line">sudo sed -i <span class="string">&quot;s|EXTRA_ARGS=&#x27;|EXTRA_ARGS=&#x27;--registry-mirror=http://hub-mirror.c.163.com |g&quot;</span> /var/lib/boot2docker/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">docker-machine restart default</span><br></pre></td></tr></table></figure>






</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>