<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Celery是一个功能完备即插即用的任务队列。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Celery博客教程 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-none-link" href="/tags/Celery/" rel="tag">Celery</a></div><div class="post-time">2019-11-13</div></div></div><div class="container post-header"><h1>Celery博客教程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">生产者消费者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Master-Worker%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">Master-Worker模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%B0%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">走个流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">1.创建应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B0%83%E7%94%A8%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.2.</span> <span class="toc-text">2.调用任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%9C"><span class="toc-number">4.3.</span> <span class="toc-text">3.存储结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BD%BF%E7%94%A8celery"><span class="toc-number">5.</span> <span class="toc-text">模块化使用celery</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text">定时任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8CELERYBEAT-SCHEDULE"><span class="toc-number">6.1.</span> <span class="toc-text">使用CELERYBEAT_SCHEDULE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8on-after-configure-connect%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">6.2.</span> <span class="toc-text">使用on_after_configure.connect装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#crontab-%E4%B8%BE%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">crontab 举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">7.</span> <span class="toc-text">常用配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#celery%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">celery命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">任务调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canvas-%E8%AE%BE%E8%AE%A1%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">10.</span> <span class="toc-text">Canvas:设计工作流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AD%BE%E5%90%8D"><span class="toc-number">10.1.</span> <span class="toc-text">任务签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#canvas%E5%8E%9F%E8%AF%AD"><span class="toc-number">10.2.</span> <span class="toc-text">canvas原语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Group"><span class="toc-number">10.2.1.</span> <span class="toc-text">Group</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Chains"><span class="toc-number">10.2.2.</span> <span class="toc-text">Chains</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Chords"><span class="toc-number">10.2.3.</span> <span class="toc-text">Chords</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">11.</span> <span class="toc-text">链式任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#celelry-asyncio"><span class="toc-number">12.</span> <span class="toc-text">celelry + asyncio</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%89%A7%E8%A1%8C%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">13.</span> <span class="toc-text">根据任务状态执行不同操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AAWorker"><span class="toc-number">14.</span> <span class="toc-text">启动多个Worker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Django%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">15.</span> <span class="toc-text">在Django中使用的最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">15.1.</span> <span class="toc-text">异步任务方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">15.2.</span> <span class="toc-text">异步任务方法二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-1"><span class="toc-number">15.3.</span> <span class="toc-text">定时任务</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>Celery是一个功能完备即插即用的任务队列。</p>
<p>celery的特点是：</p>
<ul>
<li>简单，易于使用和维护，有丰富的文档。</li>
<li>高效，单个celery进程每分钟可以处理数百万个任务。</li>
<li>灵活，celery中几乎每个部分都可以自定义扩展。</li>
</ul>
<p>celery非常易于集成到一些web开发框架中.</p>
<h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><p>某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。</p>
<p>单单抽象出生产者和消费者，还够不上是生产者消费者模式。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据，如下图所示：</p>
<p><img src="/images/1018261-20161017182223795-1680377415.png" alt="img"></p>
<p><strong>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题</strong>。</p>
<blockquote>
<p>生产者和消费者彼此之间不直接通讯，而通过消息队列（缓冲区）来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给消息队列，消费者不找生产者要数据，而是直接从消息队列里取，<strong>消息队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力</strong>。这个消息队列就是用来给生产者和消费者解耦的。</p>
</blockquote>
<p>缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。</p>
<h2 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h2><p> Master-Worker模式是常用的并行模式之一，它的核心思想是，系统有两个进程协同工作：</p>
<ul>
<li><p>Master进程，负责接收和分配任务；</p>
</li>
<li><p>Worker进程，负责处理子任务。</p>
<blockquote>
<p>当Worker进程将子任务处理完成后，结果返回给Master进程，由Master进程做归纳汇总，最后得到最终的结果。</p>
</blockquote>
</li>
</ul>
<p>结构图</p>
<p><img src="/images/1563378187404.png" alt="1563378187404"></p>
<p><img src="/images/1563378204192.png" alt="1563378204192"></p>
<p>Worker：用于实际处理一个任务；</p>
<p>Master：任务的分配和最终结果的合成；</p>
<p>Main：启动程序，调度开启Master。</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>任务队列中包含称作<code>任务</code>的工作单元。<br>有专门的工作进程持续不断的监视任务队列，并从中获得新的任务并处理.</p>
<blockquote>
<p>celery通过<code>消息</code>进行通信，通常使用一个叫Broker(中间人)来协client(任务的发出者)和worker(任务的处理者):</p>
<ul>
<li>clients发出消息到队列中</li>
<li>broker将队列中的信息派发给worker来处理</li>
<li>worker处理任务</li>
</ul>
</blockquote>
<p><img src="/images/cce0ab4a-3.png" alt="img"></p>
<p>一个celery系统可以包含很多的worker和broker，可增强横向扩展性和高可用性能。</p>
<p><img src="/images/5f877a64-v2-b59a38b663c3f51d682d5a7528cc680d_r.jpg" alt="img"></p>
<ul>
<li>任务生产者 ：调用Celery提供的API，函数，装饰器而<strong>产生任务并交给任务队列</strong>的都是任务生产者。</li>
<li>任务调度 Beat：Celery Beat进程会读取配置文件的内容，周期性的将配置中到期需要执行的<strong>任务发送给任务队列</strong>。</li>
<li>中间人（Broker）：Celery 用<strong>消息通信</strong>，通常使用中间人（Broker）在客户端和 worker 之前传递，这个过程从客户端向队列添加消息开始，之后中间人把消息派送给 worker。</li>
<li>执行单元 worker：worker 是任务执行单元，是属于任务队列的消费者，<strong>worker持续地监控任务队列，当队列中有新地任务时，它便取出来执行</strong>。worker 可以运行在不同的机器上，只要它指向同一个中间人即可，worker还可以监控一个或多个任务队列， Celery 是分布式任务队列的重要原因就在于 worker 可以分布在多台主机中运行。修改配置文件后不需要重启 worker，它会自动生效。</li>
<li>任务结果存储backend：用来持久<strong>存储 Worker 执行任务的结果</strong>，Celery支持不同的方式存储任务的结果，包括AMQP，Redis，memcached，MongoDb，SQLAlchemy等。</li>
</ul>
<p>简单版本:</p>
<ul>
<li>Task:<br>任务(Task)就是你要做的事情，例如一个注册流程里面有很多任务，给用户发验证邮件就是一个任务，这种耗时的任务就可以交给Celery去处理，还有一种任务是定时任务，比如每天定时统计网站的注册人数，这个也可以交给Celery周期性的处理。</li>
<li>Broker:<br>Broker 的中文意思是经纪人，指为市场上买卖双方提供中介服务的人。在Celery中这个角色相当于数据结构中的队列，介于生产者和消费者之间经纪人。例如一个Web系统中，生产者是主程序，它生产任务，将任务发送给 Broker，消费者是 Worker，是专门用于执行任务的后台服务。Celery本身不提供队列服务，一般用Redis或者RabbitMQ来实现队列服务。</li>
<li>Worker:<br>Worker 就是那个一直在后台执行任务的人，也成为任务的消费者，它会实时地监控队列中有没有任务，如果有就立即取出来执行。</li>
<li>Beat:<br>Beat 是一个定时任务调度器，它会根据配置定时将任务发送给 Broker，等待 Worker 来消费。</li>
<li>Backend:<br>Backend 用于保存任务的执行结果，每个任务都有返回值，比如发送邮件的服务会告诉我们有没有发送成功，这个结果就是存在Backend中，当然我们并不总是要关心任务的执行结果。</li>
</ul>
<p><img src="/images/c760eeb0-1563254594586.png" alt="1563254594586"></p>
<h2 id="走个流程"><a href="#走个流程" class="headerlink" title="走个流程"></a>走个流程</h2><h3 id="1-创建应用"><a href="#1-创建应用" class="headerlink" title="1.创建应用"></a>1.创建应用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## tasks.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">import</span> celeryconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们这里案例使用redis作为broker,demo为app的名字</span></span><br><span class="line">app = Celery(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从单独的配置模块中加载配置</span></span><br><span class="line">app.config_from_object(<span class="string">&#x27;celeryconfig&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建任务函数</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span>(<span class="params">email</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send mail to &quot;</span>, email)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># celeryconfig.py</span></span><br><span class="line"><span class="comment"># redis://:password@hostname:port/db_number</span></span><br><span class="line">result_backend = <span class="string">&#x27;redis://127.0.0.1:6379/2&#x27;</span></span><br><span class="line">broker_url = <span class="string">&#x27;redis://127.0.0.1:6379/1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>my_task函数加上装饰器app.task, 将其<strong>注册到broker的队列中</strong>。</p>
<p>现在我们在创建一个worker， 等待处理队列中的任务.<br>打开终端，执行命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A tasks worker --loglevel=info</span><br></pre></td></tr></table></figure>

<p><img src="/images/ececd21f-201907161353191.png" alt="201907161353191"></p>
<p>这里需要注意,如果是使用win10可能会发生错误.<br>这时候需要安装<code>pip install eventlet</code></p>
<p>然后执行下面语句来运行 Celery worker 服务器:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A tasks worker -l info -P eventlet</span><br></pre></td></tr></table></figure>



<h3 id="2-调用任务"><a href="#2-调用任务" class="headerlink" title="2.调用任务"></a>2.调用任务</h3><p>任务加入到broker队列中，以便刚才我们创建的celery workder服务器能够从队列中取出任务并执行。如何将任务函数加入到队列中，可使用delay()。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> send_mail</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>():</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1. 插入记录到数据库&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2. celery 帮我发邮件&quot;</span>)</span><br><span class="line">    send_mail.delay(<span class="string">&quot;xx@gmail.com&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3. 告诉用户注册成功&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;耗时：%s 秒 &quot;</span> % (time.time() - start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    register()</span><br></pre></td></tr></table></figure>

<p><img src="/images/e9f72cf1-1563257165377.png" alt="1563257165377"></p>
<p><img src="/images/c4d00d46-201907161405471.png" alt="201907161405471"></p>
<ul>
<li>send_mail.delay()会将此任务加入到broker队列中</li>
<li>worker发现broker队列中有任务,取出并执行</li>
</ul>
<p>通过worker的控制台，可以看到我们的任务被worker处理。调用一个任务函数，将会返回一个AsyncResult对象，这个对象可以用来检查任务的状态或者获得任务的返回值。</p>
<h3 id="3-存储结果"><a href="#3-存储结果" class="headerlink" title="3.存储结果"></a>3.存储结果</h3><p>如果我们想跟踪任务的状态，Celery需要将结果保存到某个地方。<br>有几种保存的方案可选:SQLAlchemy、Django ORM、Memcached、 Redis、RPC (RabbitMQ/AMQP)。</p>
<blockquote>
<p>任务结果存储配置我们通过Celery的backend参数来设定。<br>backend参数 : 指定redis作为结果存储</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tasks.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们这里案例使用redis作为broker</span></span><br><span class="line">app = Celery(<span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">             backend=<span class="string">&#x27;redis://127.0.0.1:6379/2&#x27;</span>,</span><br><span class="line">             broker=<span class="string">&#x27;redis://127.0.0.1:6379/1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建任务函数</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_task</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务函数正在执行....&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的装饰器<code>app.task</code>实际上是<strong>将一个正常的函数修饰成了一个 celery task 类实例</strong></p>
</blockquote>
<p>执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A tasks worker -l info -P eventlet</span><br></pre></td></tr></table></figure>

<blockquote>
<p>意思就是运行 tasks 这个任务集合的 worker 进行工作（当然此时broker中还没有任务，worker此时相当于待命状态）</p>
</blockquote>
<p>调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> my_task</span><br><span class="line"></span><br><span class="line">res = my_task.delay(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(res.failed())   <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(res.result)   <span class="comment"># 30</span></span><br></pre></td></tr></table></figure>

<ul>
<li>state: 返回任务状态；</li>
<li>task_id: 返回任务id；</li>
<li>result: 返回任务结果，同get()方法；</li>
<li>get(): 获取返回值；</li>
<li>ready(): 判断任务是否以及有结果，有结果为True，否则False；</li>
<li>info(): 获取任务信息，默认为结果；</li>
<li>wait(t): 等待t秒后获取结果，若任务执行完毕，则不等待直接获取结果，若任务在执行中，则wait期间一直阻塞，直到超时报错；</li>
<li>successfu(): 判断任务是否成功，成功为True，否则为False；</li>
</ul>
<blockquote>
<p>事实上，delay 方法封装了 apply_async，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delay</span>(<span class="params">self, *partial_args, **partial_kwargs</span>):</span></span><br><span class="line"> <span class="string">&quot;&quot;&quot;Shortcut to :meth:`apply_async` using star arguments.&quot;&quot;&quot;</span></span><br><span class="line"> <span class="keyword">return</span> self.apply_async(partial_args, partial_kwargs)</span><br></pre></td></tr></table></figure>

<p>apply_async 支持更多的参数，它的一般形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply_async(args=(), kwargs=&#123;&#125;, route_name=<span class="literal">None</span>, **options)</span><br></pre></td></tr></table></figure>

<p>apply_async 常用的参数如下：</p>
<ul>
<li><p>countdown：指定多少秒后执行任务<br><code>task1.apply_async(args=(2, 3), countdown=5)</code>5 秒后执行任务</p>
</li>
<li><p>eta (estimated time of arrival)：指定任务被调度的具体时间，参数类型是 datetime</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前 UTC 时间再加 10 秒后执行任务</span></span><br><span class="line">task1.multiply.apply_async(args=[<span class="number">3</span>, <span class="number">7</span>], eta=datetime.utcnow() + timedelta(seconds=<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>expires：任务过期时间，参数类型可以是 int，也可以是 datetime<br><code>task1.multiply.apply_async(args=[3, 7], expires=10)</code>10 秒后过期</li>
<li>retry: 任务发送失败的重试次数</li>
<li>priority: 任务优先级，范围是0-9</li>
<li>serializer: 参数和返回值的序列化方式</li>
</ul>
</blockquote>
<h2 id="模块化使用celery"><a href="#模块化使用celery" class="headerlink" title="模块化使用celery"></a>模块化使用celery</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">celery_demo                    <span class="comment"># 项目根目录</span></span><br><span class="line">    ├── celery_app             <span class="comment"># 存放 celery 相关文件</span></span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── celeryconfig.py    <span class="comment"># 配置文件</span></span><br><span class="line">    │   ├── task1.py           <span class="comment"># 任务文件 1</span></span><br><span class="line">    │   └── task2.py           <span class="comment"># 任务文件 2</span></span><br><span class="line">    └── client.py              <span class="comment"># 应用程序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;demo&#x27;</span>)                                <span class="comment"># 创建 Celery 实例</span></span><br><span class="line">app.config_from_object(<span class="string">&#x27;celery_app.celeryconfig&#x27;</span>)   <span class="comment"># 通过 Celery 实例加载配置模块</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># celeryconfig.py</span></span><br><span class="line">BROKER_URL = <span class="string">&#x27;redis://127.0.0.1:6379&#x27;</span>               <span class="comment"># 指定 Broker</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://127.0.0.1:6379/0&#x27;</span>  <span class="comment"># 指定 Backend</span></span><br><span class="line"></span><br><span class="line">CELERY_TIMEZONE=<span class="string">&#x27;Asia/Shanghai&#x27;</span>                     <span class="comment"># 指定时区，默认是 UTC</span></span><br><span class="line"><span class="comment"># CELERY_TIMEZONE=&#x27;UTC&#x27;                             </span></span><br><span class="line"></span><br><span class="line">CELERY_IMPORTS = (                                  <span class="comment"># 指定导入的任务模块</span></span><br><span class="line">    <span class="string">&#x27;celery_app.task1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;celery_app.task2&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task1.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task2.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client.py</span></span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> task1</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> task2</span><br><span class="line"></span><br><span class="line">task1.add.apply_async(args=[<span class="number">2</span>, <span class="number">8</span>])        <span class="comment"># 也可用 task1.add.delay(2, 8)</span></span><br><span class="line">task2.multiply.apply_async(args=[<span class="number">3</span>, <span class="number">7</span>])   <span class="comment"># 也可用 task2.multiply.delay(3, 7)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>启动 Celery Worker 进程，在项目的根目录下执行下面命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A celery_app worker -l info -P eventlet</span><br></pre></td></tr></table></figure>

<p>执行两个task:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python client.py</span><br></pre></td></tr></table></figure>



<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="使用CELERYBEAT-SCHEDULE"><a href="#使用CELERYBEAT-SCHEDULE" class="headerlink" title="使用CELERYBEAT_SCHEDULE"></a>使用CELERYBEAT_SCHEDULE</h3><ul>
<li><p>使用定时任务,说明就不需要<code>client.py</code>来暴露函数的接口了,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">celery_demo                    <span class="comment"># 项目根目录</span></span><br><span class="line">    ├── celery_app             <span class="comment"># 存放 celery 相关文件</span></span><br><span class="line">        ├── __init__.py</span><br><span class="line">        ├── celeryconfig.py    <span class="comment"># 配置文件</span></span><br><span class="line">        ├── task1.py           <span class="comment"># 任务文件</span></span><br><span class="line">        └── task2.py           <span class="comment"># 任务文件</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用定时任务最关键的就是修改<code>celeryconfig.py</code>文件,其他保持不变:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># celeryconfig.py</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line">BROKER_URL = <span class="string">&#x27;redis://127.0.0.1:6379&#x27;</span>               <span class="comment"># 指定 Broker</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://127.0.0.1:6379/0&#x27;</span>  <span class="comment"># 指定 Backend</span></span><br><span class="line"></span><br><span class="line">CELERY_TIMEZONE=<span class="string">&#x27;Asia/Shanghai&#x27;</span>                     <span class="comment"># 指定时区，默认是 UTC</span></span><br><span class="line"><span class="comment"># CELERY_TIMEZONE=&#x27;UTC&#x27;                             </span></span><br><span class="line"></span><br><span class="line">CELERY_IMPORTS = (                                  <span class="comment"># 指定导入的任务模块</span></span><br><span class="line">    <span class="string">&#x27;celery_app.task1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;celery_app.task2&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># schedules</span></span><br><span class="line">CELERYBEAT_SCHEDULE = &#123;</span><br><span class="line">    <span class="string">&#x27;add-every-30-seconds&#x27;</span>: &#123;</span><br><span class="line">         <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_app.task1.add&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;schedule&#x27;</span>: timedelta(seconds=<span class="number">30</span>),       <span class="comment"># 每 30 秒执行一次</span></span><br><span class="line">         <span class="string">&#x27;args&#x27;</span>: (<span class="number">5</span>, <span class="number">8</span>)                           <span class="comment"># 任务函数参数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;multiply-at-some-time&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_app.task2.multiply&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;schedule&#x27;</span>: crontab(hour=<span class="number">9</span>, minute=<span class="number">50</span>),   <span class="comment"># 每天早上 9 点 50 分执行一次</span></span><br><span class="line">        <span class="string">&#x27;args&#x27;</span>: (<span class="number">3</span>, <span class="number">7</span>)                            <span class="comment"># 任务函数参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;demo&#x27;</span>)                                <span class="comment"># 创建 Celery 实例</span></span><br><span class="line">app.config_from_object(<span class="string">&#x27;celery_app.celeryconfig&#x27;</span>)   <span class="comment"># 通过 Celery 实例加载配置模块</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task1.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task2.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure>

<p><strong>Celery Beat 进程通过读取配置文件的内容，周期性地将定时任务发往任务队列。</strong></p>
<p>==启动 Celery Worker 进程==，<br>在项目的根目录下执行下面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A celery_app worker --loglevel=info -P eventlet</span><br></pre></td></tr></table></figure>

<p>==启动 Celery Beat 进程==，定时将任务发送到 Broker，<br>在项目根目录下执行下面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery beat -A celery_app -P eventlet</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用on-after-configure-connect装饰器"><a href="#使用on-after-configure-connect装饰器" class="headerlink" title="使用on_after_configure.connect装饰器"></a>使用on_after_configure.connect装饰器</h3><p>新建一个函数,里面调用task函数,并且添加<code>app.on_after_configure.connect</code>装饰器:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_after_configure.connect</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_periodic_tasks</span>(<span class="params">sender, **kwargs</span>):</span></span><br><span class="line">    <span class="comment"># 每10秒执行一次</span></span><br><span class="line">    sender.add_periodic_task(<span class="number">10.0</span>, func.s(<span class="number">2</span>), name=<span class="string">&#x27;run func every 10&#x27;</span>) <span class="comment"># 给任务取个名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每30秒执行一次</span></span><br><span class="line">    sender.add_periodic_task(<span class="number">30</span>, func2.s(<span class="number">4</span>), expires=<span class="number">10</span>)  <span class="comment"># 设置任务超时时间10秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行周期和Linux的计划任务crontab设置一样</span></span><br><span class="line">    sender.add_periodic_task(</span><br><span class="line">        crontab(hour=<span class="string">&#x27;*&#x27;</span>, minute=<span class="string">&#x27;*/2&#x27;</span>, day_of_week=<span class="string">&#x27;*&#x27;</span>),</span><br><span class="line">        func2.s(<span class="number">4</span>),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>使用如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">celery_demo                    <span class="comment"># 项目根目录</span></span><br><span class="line">    ├── celery_app             <span class="comment"># 存放 celery 相关文件</span></span><br><span class="line">        ├── __init__.py</span><br><span class="line">        ├── celeryconfig.py    <span class="comment"># 配置文件</span></span><br><span class="line">        └── task1.py           <span class="comment"># 任务文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;test_celery&#x27;</span>)</span><br><span class="line">app.config_from_object(<span class="string">&#x27;celery_app.celeryconfig&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># celeryconfig.py</span></span><br><span class="line">BROKER_URL = <span class="string">&#x27;redis://127.0.0.1:6379/0&#x27;</span>               <span class="comment"># 指定 Broker</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://127.0.0.1:6379/1&#x27;</span>  <span class="comment"># 指定 Backend</span></span><br><span class="line"></span><br><span class="line">CELERY_TIMEZONE=<span class="string">&#x27;Asia/Shanghai&#x27;</span>                     <span class="comment"># 指定时区，默认是 UTC</span></span><br><span class="line"><span class="comment"># CELERY_TIMEZONE=&#x27;UTC&#x27;                             </span></span><br><span class="line"></span><br><span class="line">CELERY_IMPORTS = (                                  <span class="comment"># 指定导入的任务模块</span></span><br><span class="line">    <span class="string">&#x27;celery_app.task1&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task1.py</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- func start ---&#x27;</span>)</span><br><span class="line">	<span class="keyword">await</span> asyncio.sleep(num)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- func end ---&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- fun2 ---&#x27;</span>)</span><br><span class="line">	<span class="keyword">await</span> asyncio.sleep(num)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- func2 end ---&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	time.sleep(<span class="number">10</span>)</span><br><span class="line">	loop = asyncio.new_event_loop()</span><br><span class="line">	asyncio.set_event_loop(loop)</span><br><span class="line">	loop.run_until_complete(asyncio.wait([func(<span class="number">2</span>),func2(<span class="number">5</span>)]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_after_configure.connect</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_periodic_tasks</span>(<span class="params">sender, **kwargs</span>):</span></span><br><span class="line">    <span class="comment"># 每10秒执行一次</span></span><br><span class="line">    sender.add_periodic_task(<span class="number">10.0</span>, main.s(), name=<span class="string">&#x27;run main every 10&#x27;</span>) <span class="comment"># 给任务取个名字</span></span><br></pre></td></tr></table></figure>

<p>启动worker进程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A celery_app worker -l info -P eventlet</span><br></pre></td></tr></table></figure>

<p>启动beat进程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A celery_app.task1 beat -l info</span><br></pre></td></tr></table></figure>



<p>上面两种定时任务的区别就是:</p>
<ul>
<li>一个是写在配置文件里</li>
<li>一个是使用装饰器</li>
</ul>
<h3 id="crontab-举例"><a href="#crontab-举例" class="headerlink" title="crontab 举例"></a>crontab 举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Example</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>crontab()</td>
<td>Execute every minute.</td>
</tr>
<tr>
<td>crontab(minute=0, hour=0)</td>
<td>Execute daily at midnight.</td>
</tr>
<tr>
<td>crontab(minute=0, hour=’*/3’)</td>
<td>Execute every three hours: 3am, 6am, 9am, noon, 3pm, 6pm, 9pm.</td>
</tr>
<tr>
<td>crontab(minute=0,hour=’0,3,6,9,12,15,18,21’)</td>
<td>Same as previous.</td>
</tr>
<tr>
<td>crontab(minute=’*/15’)</td>
<td>Execute every 15 minutes.</td>
</tr>
<tr>
<td>crontab(day_of_week=’sunday’)</td>
<td>Execute every minute (!) at Sundays.</td>
</tr>
<tr>
<td>crontab(minute=’<em>‘,hour=’</em>‘, day_of_week=’sun’)</td>
<td>Same as previous.</td>
</tr>
<tr>
<td>crontab(minute=’*/10’,hour=’3,17,22’, day_of_week=’thu,fri’)</td>
<td>Execute every ten minutes, but only between 3-4 am, 5-6 pm and 10-11 pm on Thursdays or Fridays.</td>
</tr>
<tr>
<td>crontab(minute=0, hour=’<em>/2,</em>/3’)</td>
<td>Execute every even hour, and every hour divisible by three. This means: at every hour except: 1am, 5am, 7am, 11am, 1pm, 5pm, 7pm, 11pm</td>
</tr>
<tr>
<td>crontab(minute=0, hour=’*/5’)</td>
<td>Execute hour divisible by 5. This means that it is triggered at 3pm, not 5pm (since 3pm equals the 24-hour clock value of “15”, which is divisible by 5).</td>
</tr>
<tr>
<td>crontab(minute=0, hour=’*/3,8-17’)</td>
<td>Execute every hour divisible by 3, and every hour during office hours (8am-5pm).</td>
</tr>
<tr>
<td>crontab(day_of_month=’2’)</td>
<td>Execute on the second day of every month.</td>
</tr>
<tr>
<td>crontab(day_of_month=’2-30/3’)</td>
<td>Execute on every even numbered day.</td>
</tr>
<tr>
<td>crontab(day_of_month=’1-7,15-21’)</td>
<td>Execute on the first and third weeks of the month.</td>
</tr>
<tr>
<td>crontab(day_of_month=’11’,month_of_year=’5’)</td>
<td>Execute on 11th of May every year.</td>
</tr>
<tr>
<td>crontab(month_of_year=’*/3’)</td>
<td>Execute on the first month of every quarter.</td>
</tr>
<tr>
<td>timedelta(minutes=30)</td>
<td>每30分钟</td>
</tr>
</tbody></table>
<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置某个任务的优先度</span></span><br><span class="line">CELERY_ROUTES = &#123;<span class="string">&#x27;tasks.add&#x27;</span>: <span class="string">&#x27;low-priority&#x27;</span>,&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制任务的速率:每分钟只允许处理 10 个该类型的任务：</span></span><br><span class="line">CELERY_ANNOTATIONS = &#123;<span class="string">&#x27;tasks.add&#x27;</span>: &#123;<span class="string">&#x27;rate_limit&#x27;</span>: <span class="string">&#x27;10/m&#x27;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某个特定任务只能使用某个队列。</span></span><br><span class="line">task_routes = &#123; <span class="string">&#x27;proj.tasks.add&#x27;</span>: &#123;<span class="string">&#x27;queue&#x27;</span>: <span class="string">&#x27;hipri&#x27;</span>&#125;,&#125;</span><br></pre></td></tr></table></figure>

<p>使用redis还可以在运行时直接在worker上设置速率限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery control rate_limit tasks.add 10/m</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line">app = Celery(<span class="string">&#x27;proj&#x27;</span>,</span><br><span class="line">             broker=<span class="string">&#x27;amqp://&#x27;</span>,</span><br><span class="line">             backend=<span class="string">&#x27;amqp://&#x27;</span>,</span><br><span class="line">             include=[<span class="string">&#x27;proj.tasks&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>include关键字参数是一个在worker启动时要导入的模块列表。</p>
<p>就相当于celeryconfig.py中的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CELERY_IMPORTS = (                                  <span class="comment"># 指定导入的任务模块</span></span><br><span class="line">    <span class="string">&#x27;celery_app.task1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;celery_app.task2&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>一个任务只能处于某一个状态，但是它可以在不同的状态间转化，一个典型的任务状态过程如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PENDING -&gt; STARTED -&gt; SUCCESS</span><br></pre></td></tr></table></figure>



<h2 id="celery命令行参数"><a href="#celery命令行参数" class="headerlink" title="celery命令行参数"></a>celery命令行参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 获取全部的命令行参数</span><br><span class="line">celery worker --help</span><br></pre></td></tr></table></figure>



<p><img src="/images/ececd21f-201907161353191.png" alt="201907161353191"></p>
<ul>
<li><p>broker URL(transport)是我们在celery模块中指定的broker关键字参数，你也可以通过-b选项在命令行指定一个不同的broker.</p>
</li>
<li><p>concurrency 是用来执行任务而<strong>准备的worker进程</strong>，如果所有的worker都在执行任务，那么新添加的任务必须要等待有一个正在执行的任务完成后才能被执行。</p>
<blockquote>
<p>默认的concurrency数量是机器上CPU的数量，你可以通过-c选项(celery worker -c )指定数量。</p>
</blockquote>
</li>
<li><p>task events是一个选项，它可以用来使Celery在worker中有事件发生时<strong>发送监控消息（events）</strong>。这些信息可以被一些监控程序使用，比如celery events和Flower(一个实时的Celery monitor)</p>
</li>
<li><p>Queuens是一个队列列表，<strong>workers将会从Queuens中消费任务</strong>。可以告诉worker一次性地从多个队列中消费任务，这可以用来路由消息给指定的worker。这对于构建高质量的服务，关系的分离和提供优先级都有意义。</p>
</li>
</ul>
<h2 id="任务调用"><a href="#任务调用" class="headerlink" title="任务调用"></a>任务调用</h2><p>delay 方法封装了 apply_async，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delay</span>(<span class="params">self, *partial_args, **partial_kwargs</span>):</span></span><br><span class="line"> <span class="string">&quot;&quot;&quot;Shortcut to :meth:`apply_async` using star arguments.&quot;&quot;&quot;</span></span><br><span class="line"> <span class="keyword">return</span> self.apply_async(partial_args, partial_kwargs)</span><br></pre></td></tr></table></figure>

<p>apply_async 支持更多的参数，它的一般形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply_async(args=(), kwargs=&#123;&#125;, route_name=<span class="literal">None</span>, **options)</span><br></pre></td></tr></table></figure>

<p>apply_async 常用的参数如下：</p>
<ul>
<li>countdown：指定多少秒后执行任务<br><code>task1.apply_async(args=(2, 3), countdown=5)</code>5 秒后执行任务</li>
<li>eta (estimated time of arrival)：指定任务被调度的具体时间，参数类型是 datetime</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前 UTC 时间再加 10 秒后执行任务</span></span><br><span class="line">task1.multiply.apply_async(args=[<span class="number">3</span>, <span class="number">7</span>], eta=datetime.utcnow() + timedelta(seconds=<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>expires：任务过期时间，参数类型可以是 int，也可以是 datetime<br><code>task1.multiply.apply_async(args=[3, 7], expires=10)</code>10 秒后过期</li>
<li>queue:任务应该被发送给哪个队列<br><code>add.apply_async((2, 2), queue=&#39;lopri&#39;, countdown=10)</code>任务将会被发送给’lopri’队列，任务最早将会在消息发送10s之后执行。</li>
</ul>
<h2 id="Canvas-设计工作流"><a href="#Canvas-设计工作流" class="headerlink" title="Canvas:设计工作流"></a>Canvas:设计工作流</h2><h3 id="任务签名"><a href="#任务签名" class="headerlink" title="任务签名"></a>任务签名</h3><p>签名包装了一个任务的<strong>调用参数</strong>和<strong>执行参数</strong>，这样它就可以被传递给函数,进程甚至被序列化和在网络上传递。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add.signature((<span class="number">2</span>, <span class="number">2</span>), countdown=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># tasks.add(2, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简写:</span></span><br><span class="line">add.s(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># tasks.add(2, 2)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>signature 具体作用就是生成一个包含调用任务及其调用参数与其他信息的对象，个人感觉有点类似偏函数的概念：<br>先不执行任务，而是把任务与任务参数存起来以供其他地方调用。</p>
</blockquote>
<p>签名实例也可以调用delay,apply_async方法。</p>
<p>但是有些许不同，签名在创建时<strong>可能已经指定了参数</strong>。<br>add任务需要2个参数，上面的签名在创建时已经指定了2个参数，所以你只需向下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = add.s(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">res = s1.delay()</span><br><span class="line">res.get()</span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<p>甚至你也可以把它当成偏函数使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s2 = add.s(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># resolves the partial: add(8, 2)</span></span><br><span class="line">res = s2.delay(<span class="number">8</span>)</span><br><span class="line">res.get()</span><br><span class="line"><span class="comment"># 10</span></span><br></pre></td></tr></table></figure>

<p><strong>关键字参数也可以在调用签名时添加</strong>，新添加的参数会与原参数合并，但是调用时的参数优先级高：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3 = add.s(<span class="number">2</span>, <span class="number">2</span>, a=<span class="literal">True</span>)</span><br><span class="line">s3.delay(a=<span class="literal">False</span>)   <span class="comment"># a is now False.</span></span><br></pre></td></tr></table></figure>



<h3 id="canvas原语"><a href="#canvas原语" class="headerlink" title="canvas原语"></a>canvas原语</h3><ul>
<li>group</li>
<li>chain</li>
<li>chord</li>
<li>map</li>
<li>starmap</li>
<li>chunks</li>
</ul>
<p>这些原语<strong>本身就是签名对象</strong>。所以它们可以被用任意方式组合成复杂的工作流。</p>
<h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>group并行地执行一个任务列表，按顺序返回一个特殊的<strong>结果实例</strong>(GroupResult对象)(所以可以使用<code>.get()</code>获取值)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> group</span><br><span class="line"><span class="keyword">from</span> proj.tasks <span class="keyword">import</span> add</span><br><span class="line"></span><br><span class="line"> group(add.s(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))().get()</span><br><span class="line"><span class="comment"># [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>group(add.s(i, i) for i in range(10) : 返回<code>&lt;class &#39;celery.canvas.group&#39;&gt;</code></li>
<li>group(add.s(i, i) for i in range(10)() : 返回<code>&lt;class &#39;celery.result.GroupResult&#39;&gt;</code></li>
<li>group(add.s(i, i) for i in range(10))().get() : 返回 <code>[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</code></li>
</ul>
</blockquote>
<h4 id="Chains"><a href="#Chains" class="headerlink" title="Chains"></a>Chains</h4><p>通过Chains，任务可以像使用管道一样连接在一起，前一个执行完成后会执行下一个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">from</span> proj.tasks <span class="keyword">import</span> add, mul</span><br><span class="line"></span><br><span class="line"><span class="comment"># (4 + 4) * 8</span></span><br><span class="line">chain(add.s(<span class="number">4</span>, <span class="number">4</span>) | mul.s(<span class="number">8</span>))().get()</span><br><span class="line"><span class="comment"># 64</span></span><br></pre></td></tr></table></figure>

<h4 id="Chords"><a href="#Chords" class="headerlink" title="Chords"></a>Chords</h4><p>chord是一个带回调函数的group</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> chord</span><br><span class="line"><span class="keyword">from</span> proj.tasks <span class="keyword">import</span> add, xsum</span><br><span class="line"></span><br><span class="line">chord((add.s(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), <span class="built_in">sum</span>.s())().get()</span><br><span class="line"><span class="comment">#90</span></span><br></pre></td></tr></table></figure>



<h2 id="链式任务"><a href="#链式任务" class="headerlink" title="链式任务"></a>链式任务</h2><p>有些任务可能需由几个子任务组成，此时调用各个子任务的方式就变的很重要，尽量不要以同步阻塞的方式调用子任务，而是<strong>用异步回调的方式进行链式任务的调用</strong></p>
<p>下面例子为:<code>获取网页 -- 解析网页 -- 存储网页</code></p>
<blockquote>
<p>注意下面是三个函数(获取网页 – 解析网页 – 存储网页)是不一样的</p>
</blockquote>
<p>错误示范</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_page</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">return</span> myhttplib.get(url)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span>(<span class="params">url, page</span>):</span></span><br><span class="line">    <span class="keyword">return</span> myparser.parse_document(page)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">store_page_info</span>(<span class="params">url, info</span>):</span></span><br><span class="line">    <span class="keyword">return</span> PageInfo.objects.create(url, info)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># fetch_page -&gt; parse_page -&gt; store_page</span></span><br><span class="line">    page = fetch_page.delay(url).get()</span><br><span class="line">    info = parse_page.delay(url, page).get()</span><br><span class="line">    store_page_info.delay(url, info)</span><br></pre></td></tr></table></figure>

<p>正确示范1:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.task()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_page</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">return</span> myhttplib.get(url)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="keyword">return</span> myparser.parse_document(page)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(<span class="params">ignore_result=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">store_page_info</span>(<span class="params">info, url</span>):</span></span><br><span class="line">    PageInfo.objects.create(url=url, info=info)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># fetch_page -&gt; parse_page -&gt; store_page</span></span><br><span class="line">    chain = fetch_page.s(url) | parse_page.s() | store_page_info.s(url)</span><br><span class="line">    chain()</span><br></pre></td></tr></table></figure>

<p>正确示范2:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch_page.apply_async((url), link=[parse_page.s(), store_page_info.s(url)])</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>链式任务中前一个任务的返回值默认是下一个任务的输入值之一</strong> ( 不想让返回值做默认参数可以用 si() 或者 s(immutable=True) 的方式调用 )。</p>
</blockquote>
<h2 id="celelry-asyncio"><a href="#celelry-asyncio" class="headerlink" title="celelry + asyncio"></a>celelry + asyncio</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">celery_demo                    # 项目根目录</span><br><span class="line">    ├── celery_app             # 存放 celery 相关文件</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        ├── celeryconfig.py    # 配置文件</span><br><span class="line">        ├── task1.py           # 任务文件</span><br><span class="line">        └── task2.py           # 任务文件</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;test_celery&#x27;</span>)</span><br><span class="line">app.config_from_object(<span class="string">&#x27;celery_app.celeryconfig&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># celeryconfig.py</span></span><br><span class="line">BROKER_URL = <span class="string">&#x27;redis://127.0.0.1:6379&#x27;</span>               <span class="comment"># 指定 Broker</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://127.0.0.1:6379/0&#x27;</span>  <span class="comment"># 指定 Backend</span></span><br><span class="line"></span><br><span class="line">CELERY_TIMEZONE=<span class="string">&#x27;Asia/Shanghai&#x27;</span>                     <span class="comment"># 指定时区                     </span></span><br><span class="line"></span><br><span class="line">CELERY_IMPORTS = (                                  <span class="comment"># 指定导入的任务模块</span></span><br><span class="line">    <span class="string">&#x27;celery_app.task2&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task2.py</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- func start ---&#x27;</span>)</span><br><span class="line">	<span class="keyword">await</span> asyncio.sleep(num)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- func end ---&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- fun2 start ---&#x27;</span>)</span><br><span class="line">	<span class="keyword">await</span> asyncio.sleep(num)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;--- func2 end ---&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">	time.sleep(<span class="number">10</span>)</span><br><span class="line">	<span class="comment"># 使用asyncio.new_event_loop函数建立一个新的事件循环，并使用asyncio.set_event_loop设置全局的事件循环</span></span><br><span class="line">	loop = asyncio.new_event_loop()</span><br><span class="line">	asyncio.set_event_loop(loop)</span><br><span class="line">	</span><br><span class="line">	loop.run_until_complete(asyncio.wait([func(<span class="number">2</span>),func2(<span class="number">5</span>)]))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> celery_app.task2 <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line">main.delay()</span><br></pre></td></tr></table></figure>

<p>执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A celery_app worker -l info -P eventlet</span><br></pre></td></tr></table></figure>



<h2 id="根据任务状态执行不同操作"><a href="#根据任务状态执行不同操作" class="headerlink" title="根据任务状态执行不同操作"></a>根据任务状态执行不同操作</h2><p>装饰器<code>app.task</code>实际上是将一个正常的函数修饰成了一个 celery task 类实例，所以我们可以给修饰器加上参数来决定修饰后的 task 对象的一些属性。让被修饰的函数成为 task 对象的绑定方法，这样就相当于被修饰的函数 add 成了 task 的实例方法，可以调用 self 获取当前 task 实例的很多状态及属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Task</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span>(<span class="params">Task</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_success</span>(<span class="params">self, retval, task_id, args, kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;******* task done: &#123;0&#125; *******&#x27;</span>.<span class="built_in">format</span>(retval))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().on_success(retval, task_id, args, kwargs)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_failure</span>(<span class="params">self, exc, task_id, args, kwargs, einfo</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;******* task fail, reason: &#123;0&#125; *******&#x27;</span>.<span class="built_in">format</span>(exc))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().on_failure(exc, task_id, args, kwargs, einfo)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(<span class="params">base=MyTask</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>



<h2 id="启动多个Worker"><a href="#启动多个Worker" class="headerlink" title="启动多个Worker"></a>启动多个Worker</h2><ul>
<li><code>celery -A 项目名 worker -loglevel=info</code> ： 前台启动命令</li>
<li><code>celery multi start w1 -A 项目名 -l info</code> ： 后台启动命令</li>
<li><code>celery multi restart w1 -A 项目名 -l info</code> ： 后台重启命令</li>
<li><code>celery multi stop w1 -A 项目名 -l info</code> ： 后台停止命令</li>
</ul>
<blockquote>
<ul>
<li>前后台的区别：后台是通过multi启动的。</li>
<li>w1是worker的名称，可以后台启动多个worker，每个worker有一个名称。<br>即便是所有的worker都已经done了，用户仍然会启动任务，所有的任务都会保留，直到有worker来执行并返回结果。</li>
<li>如果前台启动的worker断开了，那么worker的任务会消失；如果后台启动的worker断开了，后台的任务仍然在。</li>
</ul>
</blockquote>
<h2 id="在Django中使用的最佳实践"><a href="#在Django中使用的最佳实践" class="headerlink" title="在Django中使用的最佳实践"></a>在Django中使用的最佳实践</h2><h3 id="异步任务方法一"><a href="#异步任务方法一" class="headerlink" title="异步任务方法一"></a>异步任务方法一</h3><ul>
<li>可以把celery的配置直接写在django的settings.py文件里</li>
<li>任务函数写在tasks.py文件里,<strong>放在各个app的目录下</strong><br>(每个app下都可以有一个tasks.py)</li>
</ul>
<p>目录大概如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">UsingCeleryWithDjango</span><br><span class="line">│</span><br><span class="line">├─manage.py</span><br><span class="line">│</span><br><span class="line">├─app01</span><br><span class="line">│  │  admin.py</span><br><span class="line">│  │  apps.py</span><br><span class="line">│  │  models.py</span><br><span class="line">│  │  tests.py</span><br><span class="line">│  │  views.py</span><br><span class="line">│  └  __init__.py</span><br><span class="line">│</span><br><span class="line">├─CeleryPro</span><br><span class="line">│  │  celery.py</span><br><span class="line">│  └  __init__.py</span><br><span class="line">│</span><br><span class="line">├─templates</span><br><span class="line">│</span><br><span class="line">└─webproject</span><br><span class="line">    │  settings.py</span><br><span class="line">    │  urls.py</span><br><span class="line">    │  wsgi.py</span><br><span class="line">    └  __init__.py</span><br></pre></td></tr></table></figure>

<ul>
<li>CeleryPro/celery.py 文件，是用来创建celery实例的。</li>
<li>CeleryPro/__init__.py 文件，需要确保当Django启动时加载celery。</li>
<li>tasks.py文件里创建的函数用的是 <code>@shared_task</code> 这个装饰器。这些任务是所有app共享的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UsingCeleryWithDjango/CeleryPro/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line">__author__ = <span class="string">&#x27;749B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This will make sure the app is always imported when</span></span><br><span class="line"><span class="comment"># Django starts so that shared_task will use this app.</span></span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># UsingCeleryWithDjango/CeleryPro/celery.py</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the default Django settings module for the &#x27;celery&#x27; program.</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;UsingCeleryWithDjango.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings  <span class="comment"># noqa</span></span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;CeleryPro&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using a string here means the worker will not have to</span></span><br><span class="line"><span class="comment"># pickle the object when using Windows.</span></span><br><span class="line">app.config_from_object(<span class="string">&#x27;django.conf:settings&#x27;</span>)</span><br><span class="line"><span class="comment"># 自动发现所有app下的tasks</span></span><br><span class="line"><span class="comment"># 但是，新版django的INSTALLED_APPS的写法无法发现到</span></span><br><span class="line"><span class="comment"># app.autodiscover_tasks(lambda: settings.INSTALLED_APPS)  # 这是官方示例的写法</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 这里是setting.py里的INSTALLED_APPS部分</span></span><br><span class="line"><span class="string">INSTALLED_APPS = [</span></span><br><span class="line"><span class="string">    &#x27;django.contrib.admin&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;django.contrib.auth&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;django.contrib.contenttypes&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;django.contrib.sessions&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;django.contrib.messages&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;django.contrib.staticfiles&#x27;,</span></span><br><span class="line"><span class="string">    &#x27;app01.apps.App01Config&#x27;,  # 这种写法自动发现找不到tasks</span></span><br><span class="line"><span class="string">    # &#x27;app01&#x27;,  # 这种写法就能自动发现</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 或者不想改settings.INSTALLED_APPS，那就自己把app的列表写在一个列表里作为参数吧</span></span><br><span class="line">app.autodiscover_tasks([<span class="string">&#x27;app01&#x27;</span>])  <span class="comment"># 这里我就这么</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(<span class="params">bind=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug_task</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Request: &#123;0!r&#125;&#x27;</span>.<span class="built_in">format</span>(self.request))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UsingCeleryWithDjango/app01/tasks.py</span></span><br><span class="line"><span class="comment"># Create your tasks here</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> shared_task</span><br><span class="line"></span><br><span class="line"><span class="meta">@shared_task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="meta">@shared_task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="meta">@shared_task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xsum</span>(<span class="params">numbers</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(numbers)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UsingCeleryWithDjango/UsingCeleryWithDjango/settings.py</span></span><br><span class="line">BROKER_URL = <span class="string">&#x27;redis://192.168.246.11/0&#x27;</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://192.168.246.11/0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A CeleryPro worker -l info</span><br></pre></td></tr></table></figure>



<h3 id="异步任务方法二"><a href="#异步任务方法二" class="headerlink" title="异步任务方法二"></a>异步任务方法二</h3><ol>
<li><p>在project目录下(也就是settings.py所在目录)创建celery.py文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为celery设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;celery_demo.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建应用</span></span><br><span class="line">app = Celery(<span class="string">&quot;demo&quot;</span>)</span><br><span class="line"><span class="comment"># 配置应用</span></span><br><span class="line">app.conf.update(</span><br><span class="line">    <span class="comment"># 配置broker, 这里我们用redis作为broker</span></span><br><span class="line">    BROKER_URL=<span class="string">&#x27;redis://:332572@127.0.0.1:6379/1&#x27;</span>,</span><br><span class="line">     <span class="comment"># 使用项目数据库存储任务执行结果</span></span><br><span class="line">    CELERY_RESULT_BACKEND=<span class="string">&#x27;django-db&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 设置app自动加载任务</span></span><br><span class="line"><span class="comment"># 从已经安装的app中查找任务</span></span><br><span class="line">app.autodiscover_tasks(settings.INSTALLED_APPS)</span><br></pre></td></tr></table></figure></li>
<li><p>每个APP目录下创建task.py文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery_demo.celery <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上app对象的task装饰器</span></span><br><span class="line"><span class="comment"># 此函数为任务函数</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务开始执行....&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务执行结束....&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>如果要存储task的结果,可以使用<code>django_celery_results</code>包<br><code>pip install django-celery-results</code></p>
</li>
<li><p>添加到settings.py中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django_celery_results&#x27;</span>,  <span class="comment"># 注意此处应用名为下划线</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>迁移同步</p>
</li>
</ol>
<h3 id="定时任务-1"><a href="#定时任务-1" class="headerlink" title="定时任务"></a>定时任务</h3><ol>
<li><p>使用django_celery_beat包<code>pip install django_celery_beat</code></p>
</li>
<li><p>settings.py中安装此应用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django_celery_beat&#x27;</span>, </span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>在project/celery.py模块中增加定时任务配置<code>CELERYBEAT_SCHEDULER</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置应用</span></span><br><span class="line">app.conf.update(</span><br><span class="line">    <span class="comment"># 配置broker, 这里我们用redis作为broker</span></span><br><span class="line">    BROKER_URL=<span class="string">&#x27;redis://:332572@127.0.0.1:6379/1&#x27;</span>,</span><br><span class="line">    <span class="comment"># 使用项目数据库存储任务执行结果</span></span><br><span class="line">    CELERY_RESULT_BACKEND=<span class="string">&#x27;django-db&#x27;</span>,</span><br><span class="line">    <span class="comment"># 配置定时器模块，定时器信息存储在数据库中</span></span><br><span class="line">    CELERYBEAT_SCHEDULER=<span class="string">&#x27;django_celery_beat.schedulers.DatabaseScheduler&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>迁移同步</p>
</li>
<li><p>在task.py里面编写task函数</p>
</li>
<li><p>登录管理后台Admin设置</p>
</li>
<li><p>启动定时任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A celery_demo worker -l info --beat</span><br></pre></td></tr></table></figure></li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>