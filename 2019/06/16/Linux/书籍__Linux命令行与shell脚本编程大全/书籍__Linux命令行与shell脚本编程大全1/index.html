<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第1章-初识Linux-shell&quot;&gt;&lt;a href=&quot;#第1章-初识Linux-shell&quot; class=&quot;headerlink&quot; title=&quot;第1章.初识Linux shell&quot;&gt;&lt;/a&gt;第1章.初识Linux shell&lt;/h1&gt;&lt;p&gt;Linux可划分为以下四部分："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Linux命令行与shell脚本编程大全1 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Linux/" rel="tag">Linux</a></div><div class="post-time">2019-06-16</div></div></div><div class="container post-header"><h1>Linux命令行与shell脚本编程大全1</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E5%88%9D%E8%AF%86Linux-shell"><span class="toc-number">1.</span> <span class="toc-text">第1章.初识Linux shell</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E8%B5%B0%E8%BF%9Bshell"><span class="toc-number">2.</span> <span class="toc-text">第2章.走进shell</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E7%9A%84bash-shell%E5%91%BD%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">第3章.基本的bash shell命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cd"><span class="toc-number">3.2.</span> <span class="toc-text">cd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ls"><span class="toc-number">3.3.</span> <span class="toc-text">ls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#touch"><span class="toc-number">3.4.</span> <span class="toc-text">touch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cp"><span class="toc-number">3.5.</span> <span class="toc-text">cp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5-ln"><span class="toc-number">3.6.</span> <span class="toc-text">文件链接(ln)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6-mv"><span class="toc-number">3.7.</span> <span class="toc-text">重命名文件(mv)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6-rm"><span class="toc-number">3.8.</span> <span class="toc-text">删除文件(rm)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%9B%AE%E5%BD%95-mkdir-rmdir-file-cat-less-more-tail-head"><span class="toc-number">3.9.</span> <span class="toc-text">处理目录(mkdir,rmdir,file,cat,less.more,tail,head)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">3.10.</span> <span class="toc-text">查看文件内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">3.11.</span> <span class="toc-text">查看整个文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%83%A8%E5%88%86%E6%96%87%E4%BB%B6"><span class="toc-number">3.12.</span> <span class="toc-text">查看部分文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.13.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E7%9A%84bash-shell%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">第4章.更多的bash shell命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%B5%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">监测程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A2%E6%9F%A5%E8%BF%9B%E7%A8%8B-ps-top"><span class="toc-number">4.1.1.</span> <span class="toc-text">探查进程(ps,top)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B-kill-kiilall"><span class="toc-number">4.2.</span> <span class="toc-text">结束进程(kill,kiilall)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%B5%8B%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4-mount-umount"><span class="toc-number">4.3.</span> <span class="toc-text">监测磁盘空间(mount,umount)</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="第1章-初识Linux-shell"><a href="#第1章-初识Linux-shell" class="headerlink" title="第1章.初识Linux shell"></a>第1章.初识Linux shell</h1><p>Linux可划分为以下四部分：</p>
<ol>
<li>Linux内核</li>
<li>GNU工具</li>
<li>图形化桌面环境</li>
<li>应用软件</li>
</ol>
<p><img src="/images/1554343685930.png" alt="1554343685930"></p>
<p>内核主要负责以下四种功能：</p>
<ol>
<li>系统内存管理</li>
<li>软件程序管理</li>
<li>硬件设备管理</li>
<li>文件系统管理</li>
</ol>
<p>内存存储单元按组划分成很多块，这些块称作页面（page）.<br>内核将每个内存页面放在物理内存或交换空间。然后，内核会维护一个内存页面表，指明哪些页面位于物理内存内，哪些页面被换到了磁盘上。</p>
<p>内核创建了第一个进程（称为<strong>init进程</strong>）来启动系统上所有其他进程。<br>内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。</p>
<p>Linux系统将硬件设备当成特殊的文件，称为设备文件。设备文件有3种分类：</p>
<ol>
<li>字符型设备文件</li>
<li>块设备文件</li>
<li>网络设备文件</li>
</ol>
<p>字符型设备文件是指处理数据时每次只能处理一个字符的设备.<br>块设备文件是指处理数据时每次能处理大块数据的设备，比如硬盘。<br>网络设备文件是指采用数据包发送和接收数据的设备，包括各种网卡和一个特殊的回环设<br>备。这个回环设备允许Linux系统使用常见的网络编程协议同自身通信。</p>
<p>Linux为系统上的每个设备都创建一种称为<strong>节点</strong>的特殊文件。与设备的所有通信都通过设备节点完成。每个节点都有唯一的数值对供Linux内核标识它(类似于python中的id)。<br>数值对包括一个主设备号和一个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特定设备。</p>
<p>供Linux系统使用的这组核心工具被称为coreutils（coreutilities）软件包。<br>GNU coreutils软件包由三部分构成：</p>
<ol>
<li>用以处理文件的工具</li>
<li>用以操作文本的工具</li>
<li>用以管理进程的工具</li>
</ol>
<p>shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。</p>
<p>shell在命令行中执行,你也可以将多个shell命令放入文件中作为程序执行。这些文件被称作<code>shell脚本</code>。</p>
<p>Linux的shell其实有好多种,最常用的就是<code>bash shell</code>.</p>
<p>我们将完整的Linux系统包称为发行版。</p>
<table>
<thead>
<tr>
<th>发行版</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CentOS</td>
<td>一款基于Red Hat企业版Linux源代码构建的免费发行版</td>
</tr>
<tr>
<td>Ubuntu</td>
<td>一款用于学校和家庭的免费发行版</td>
</tr>
<tr>
<td>PCLinuxOS</td>
<td>一款用于家庭和办公的免费发行版</td>
</tr>
<tr>
<td>Mint</td>
<td>一款用于家庭娱乐的免费发行版</td>
</tr>
<tr>
<td>dyne:bolic</td>
<td>一款用于音频和MIDI应用的免费发行版</td>
</tr>
<tr>
<td>Puppy Linux</td>
<td>一款适用于老旧PC的小型免费发行版</td>
</tr>
</tbody></table>
<h1 id="第2章-走进shell"><a href="#第2章-走进shell" class="headerlink" title="第2章.走进shell"></a>第2章.走进shell</h1><p>shell中的快捷键一般是 Ctrl + Shift +: </p>
<p>Ctrl + Shift + T : 打开shell<br>Ctrl + Shift + N : 新建一个shell<br>Ctrl + Shift + F : 搜索<br>Ctrl + Shift + H : 向后搜索<br>Ctrl + Shift + G : 向前搜索</p>
<p>在Linux的shell中,复制粘贴是Ctrl + Shift +C/V</p>
<h1 id="第3章-基本的bash-shell命令"><a href="#第3章-基本的bash-shell命令" class="headerlink" title="第3章.基本的bash shell命令"></a>第3章.基本的bash shell命令</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>默认bash shell提示符是美元符号（$），</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu系统的提示符:用户名为achilles,系统名ubuntu</span></span><br><span class="line">achilles@ubuntu:~$</span><br><span class="line"><span class="comment"># CentOS系统的提示符:用户名为christine,系统名server01</span></span><br><span class="line">[christine@server01 ~]$ </span><br></pre></td></tr></table></figure>

<p>当使用man命令查看命令手册页的时候，这些手册页是由分页程序（pager）来显示的。分页 程序是一种实用工具，能够逐页显示文本。可以通过点击<strong>空格键进行翻页</strong>，或是使用<strong>回车键逐行查看</strong>。另外还可以使用箭头键向前向后滚动手册页的内容。</p>
<p>手册页将与命令相关的信息分成了不同的节。<br>如果不记得命令名怎么办？可以使用关键字搜索手册页。语法是：man  -k 关键字。例如，要查找与终端相关的命令，可以输入man -k terminal。</p>
<p>除了man,info命令用于查看帮助,很多命令都支持–help来查看帮助.</p>
<p>不像Windows,Linux在路径名中不使用驱动器盘符。(eg:c:\Users\Rich\Documents\test.doc )<br>Linux将文件存储在单个目录结构中，这个目录被称为<code>虚拟目录</code>（virtual directory）。<br>Linux虚拟目录结构只包含一个称为根（root）目录的基础目录。根目录下的目录和文件会按 照访问它们的目录路径一一列出，这点跟Windows类似。 (eg:/home/Rich/Documents/test.doc)</p>
<p>通常系统文件会存储在根驱动器中，而用户文件则存储在另一驱动器中<br><img src="/images/1554433336449.png" alt="1554433336449"><br>上面展示了计算机中的两块硬盘。一块硬盘和<strong>虚拟目录</strong>的根目录（由正斜线/表示）关联起 来。剩下的硬盘就可以挂载到虚拟目录结构中的任何地方。<br>在这个例子中，第二块硬盘被挂载到了/home位置，用户目录都位于这个位置。</p>
<table>
<thead>
<tr>
<th>目  录</th>
<th>用  途</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>虚拟目录的根目录。通常不会在这里存储文件</td>
</tr>
<tr>
<td>/bin</td>
<td>二进制目录，存放许多用户级的GNU工具</td>
</tr>
<tr>
<td>/boot</td>
<td>启动目录，存放启动文件</td>
</tr>
<tr>
<td>/dev</td>
<td>设备目录，Linux在这里创建设备节点</td>
</tr>
<tr>
<td>/etc</td>
<td>系统配置文件目录</td>
</tr>
<tr>
<td>/home</td>
<td>主目录，Linux在这里创建用户目录</td>
</tr>
<tr>
<td>/lib</td>
<td>库目录，存放系统和应用程序的库文件</td>
</tr>
<tr>
<td>/media</td>
<td>媒体目录，可移动媒体设备的常用挂载点</td>
</tr>
<tr>
<td>/mnt</td>
<td>挂载目录，另一个可移动媒体设备的常用挂载点</td>
</tr>
<tr>
<td>/opt</td>
<td>可选目录，常用于存放第三方软件包和数据文件</td>
</tr>
<tr>
<td>/proc</td>
<td>进程目录，存放现有硬件及当前进程的相关信息</td>
</tr>
<tr>
<td>/root</td>
<td>root用户的主目录</td>
</tr>
<tr>
<td>/sbin</td>
<td>系统二进制目录，存放许多GNU管理员级工具</td>
</tr>
<tr>
<td>/run</td>
<td>运行目录，存放系统运作时的运行时数据</td>
</tr>
<tr>
<td>/srv</td>
<td>服务目录，存放本地服务的相关文件</td>
</tr>
<tr>
<td>/sys</td>
<td>系统目录，存放系统硬件信息的相关文件</td>
</tr>
<tr>
<td>/tmp</td>
<td>临时目录，可以在该目录中创建和删除临时工作文件</td>
</tr>
<tr>
<td>/usr</td>
<td>用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里</td>
</tr>
<tr>
<td>/var</td>
<td>可变目录，用以存放经常变化的文件，比如日志文件</td>
</tr>
</tbody></table>
<p>在登录系统并获得一个shell CLI提示符后，会话将从主目录开始。<br>主目录是分配给用户账户的一个特有目录。用户账户在创建之后，系统通常会为其分配一个特有的目录。</p>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>cd destination:destination可以使用绝对路径或者相对路径.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $前面有一个~</span></span><br><span class="line">achilles@ubuntu:~$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line"><span class="comment"># cd结束后~被/usr/bin替代了。</span></span><br><span class="line">achilles@ubuntu:/usr/bin$ </span><br></pre></td></tr></table></figure>

<p>原因:<br>CLI提示符正是用它来帮助你跟踪当前所在虚拟<strong>目录结构中的位置</strong>。<br>==波浪号表明shell会话位于你的主目录中(注意不是根目录)==。在切换出主目录之后，如果提示符已经进行了相关配置的话，绝对文件路径就会显示在提示符中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所以cd ~就是cd到主目录中</span></span><br><span class="line"><span class="comment"># 跳转到/home/liangbo</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure>

<p>主目录和根目录:<br>主目录就是当前用户的目录(eg:/home/liangbo),根目录就是真正的/<br>他们的层级关系看上面的”Linux文件结构”图</p>
<p>和python一样,有两个特殊字符可用于相对文件路径中：</p>
<ul>
<li>单点符（.），表示当前目录；</li>
<li>双点符（..），表示当前目录的父目录。</li>
</ul>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>注意，ls命令输出的列表是按字母排序的.<br>使用**-F参数的ls命令可以区分文件和目录**。(文件夹带有/,可执行文件带有星号)</p>
<p><img src="/images/1554435845497.png" alt="1554435845497"></p>
<p>ls命令并没有将全部文件和文件夹都显示出来(Linux经常采用隐藏文件来保存配置信息。)<br>在Linux上，隐藏文件通常是文件名以点号开始的文件。使用**-a属性显示隐藏文件**.</p>
<p><img src="/images/1554435151535.png" alt="1554435151535"></p>
<p>注意，有三个以.bash开始的文件。它们是bash shell环境所使用的隐藏文件</p>
<p>-R参数是ls命令的另一个参数，叫作递归选项。**-R列出当前目录下包含的子目录中的文件**。<br>eg:dir5中有dir6,dir6中有dir7</p>
<p><img src="/images/1554435771757.png" alt="1554435771757"></p>
<p>-l参数会产生长列表格式的输出，包含了目录中每个文件的更多相关信息。</p>
<p><img src="/images/1554436148675.png" alt="1554436148675"></p>
<p>上面的信息包括:</p>
<ol>
<li>文件类型，比如目录（d）、文件（-）、字符型文件（c）或块设备（b）；</li>
<li>文件的权限；</li>
<li>文件的硬链接总数；</li>
<li>文件属主的用户名；</li>
<li>文件属组的组名；</li>
<li>文件的大小（以字节为单位）；</li>
<li>文件的上次修改时间；</li>
<li>文件名或目录名。 </li>
</ol>
<p>ls命令最长使用的参数 -lrt(-l:以列表形式显示,-r:逆序,-t:以时间排序)</p>
<p><img src="/images/1554436548017.png" alt="1554436548017"></p>
<p>ls还携带过滤器,在后面添加要查找的文件名即可:<br>注意文件名<strong>必须是全名且名字正确</strong>,否则可以使用通配符:</p>
<ul>
<li>问号（?）代表一个字符；</li>
<li>星号（*）代表零个或多个字符 </li>
</ul>
<p><img src="/images/1554437036303.png" alt="1554437036303"></p>
<p>星号和问号被称为<code>文件扩展匹配</code>,这和word中的通配符是同样的功能.<br>通配符正式的名称叫作元字符通配符</p>
<p>需要注意的是,==对于文件夹”dir”,使用<code>ls d?r</code>是拿不到的==,需要使用<code>ls d?r*</code></p>
<p>通配符还可以和正则表达式类比.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a或i</span></span><br><span class="line"><span class="variable">$ls</span> -l my_scr[ai]pt</span><br><span class="line"><span class="comment"># a到i</span></span><br><span class="line">$ ls -l f[a-i]ll </span><br><span class="line"><span class="comment"># 不包括a</span></span><br><span class="line">$ ls -l f[!a]ll </span><br></pre></td></tr></table></figure>

<h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>touch命令不仅可以创建指定的新文件,<strong>文件的大小是零</strong>.<br>touch命令还可用来改变文件的<strong>修改时间</strong>。这个操作并不需要改变文件的内容。 </p>
<p><img src="/images/1554558085463.png" alt="1554558085463"></p>
<p>有修改时间,就有<strong>访问时间</strong>,如果touch要改变访问时间,就需要使用-a参数.<br>(注意:如果只使用ls –l命令，并不会显示访问时间。这是因为默认显示的是修改时间。<br>要想查看文件的访问时间，需要加入另外一个参数：–time=atime)</p>
<p>而且–time=atime必须配合-l命令.因为ls命令本来就不能显示时间.</p>
<p><img src="/images/1554558791048.png" alt="1554558791048"></p>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>cp命令需要两个参数——源对象和目标对象:<code>cp source destination </code><br>cp命令将源文件复制成一个新文件，并且以 destination命名。新文件就像全新的文件一样，有<strong>新的修改时间</strong>.</p>
<p>注意cp命令是覆盖型的,也就是说,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp test_one test_two</span><br></pre></td></tr></table></figure>

<p>如果test_two本身就存在,那么他就会被覆盖掉.<br>这时就需要使用-i参数:(后面输入y/n)<br><img src="/images/1554559126935.png" alt="1554559126935"></p>
<p>需要注意的是,cp可以将文件复制到其他地方:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件test_one移动到同级目录dir1下面</span></span><br><span class="line">cp test_one dir1/</span><br><span class="line"><span class="comment"># 注意必须使用dir1/,而不是dir,dir1/直接说明了这是一个目录</span></span><br><span class="line"><span class="comment"># 假设dir1不存在,使用cp test_one dir1/就会弹出错误,但是使用cp test_one dir1就会创建一个dir文件,根本不会弹出错误.导致你错了都不知道.</span></span><br></pre></td></tr></table></figure>

<p>上面代码是<strong>将当前文件复制到其他文件夹中</strong>,如果需要<strong>将其他目录下的文件复制到当前目录</strong>下.就可以==使用点号==</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将dir1目录下的test_one文件复制到当前目录中</span></span><br><span class="line">cp dir1/test_one .</span><br><span class="line"><span class="comment"># 将dir1目录下所有以test开头的文件复制到当前目录中</span></span><br><span class="line">cp dir1/<span class="built_in">test</span>* .</span><br></pre></td></tr></table></figure>

<p>-l参数:复制文件的<code>硬链接文件</code></p>
<p>-R参数<strong>递归地</strong>复制整个目录的内容。 </p>
<h2 id="文件链接-ln"><a href="#文件链接-ln" class="headerlink" title="文件链接(ln)"></a>文件链接(ln)</h2><p>在Linux中有两种 不同类型的文件链接：</p>
<ol>
<li>符号链接 </li>
<li>硬链接 </li>
</ol>
<p>符号链接就是一个实实在在的文件，它指向另一个文件。 这两个通过符号链接在一起的文件，彼此的内容并不相同。 可以==使用ln命令以及-s选项来创建符号链接==。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个符号链接file2,使file2指向file1</span></span><br><span class="line">ln -s file1 file2</span><br></pre></td></tr></table></figure>



<p><img src="/images/1554561728385.png" alt="1554561728385"></p>
<p><img src="/images/1554561857254.png" alt="1554561857254"></p>
<p>证明链接文件是独立文件的方法是查看<strong>inode编号</strong>。文件或目录的inode编号是一个用于标识的唯一数字，这个数字由内核分配给文件系统中的每一个对象。(类似于python里的id)<br>要查看文件或目录的inode 编号，可以给ls命令加入-i参数(刚好就是id的i)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -i file*</span><br><span class="line"><span class="comment"># 得到:402949 file1  402947 file2</span></span><br><span class="line"><span class="comment"># 一个编号是402949,一个编号是402947:说明是不同的文件</span></span><br></pre></td></tr></table></figure>

<p>如何理解硬链接:<br>就像是python的内存数据和变量引用之间的关系,只要引用不为0,那么内存数据就会一直存在.<br>类比于硬链接,硬链接就是对内存数据的引用,我们使用<code>cp -l file1 file2</code>其实就是新建一个引用file2,这个file2指向file1这个内存.所以就算以后file1被删除了,那么指向内存数据的引用就会少了一个,还是有file2引用到内存数据,一样可以使用内存数据.</p>
<p>简单来说:<br>==硬连接记录的是目标的 inode,符号连接记录的是目标的 path==。<br>==软连接就像是快捷方式,而硬连接就像是备份!==<br>符号连接可以做跨分区的 link；而硬连接由于inode的缘故，只能在本分区中做 link.所以,符号连接的使用频率要高的多。</p>
<p><strong>ln默认创建的是硬链接。使用 -s 开关可以创建符号链接</strong>。</p>
<p>复制链接文件的时候一定要小心。如果使用cp命令复制一个文件，而该文件又已经被链接到了另一个源文件上，那么你得到的其实是<strong>源文件的一个副本</strong>。<br>==千万别创建软链接文件的软链接==。这会形成混乱的链接链，不仅容易断裂，还会造成各种麻烦。 </p>
<h2 id="重命名文件-mv"><a href="#重命名文件-mv" class="headerlink" title="重命名文件(mv)"></a>重命名文件(mv)</h2><p>在Linux中，重命名文件称为移动（moving）。因为mv命令既可以移动也可以重命名.<br>简单来说,mv既可以移动也可以重命名,这取决与第二个参数是文件名还是目录名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将file2移动到dir2</span></span><br><span class="line">mv file2 dir2/</span><br><span class="line"><span class="comment"># 将file2重命名为file3</span></span><br><span class="line">mv file2 file3</span><br><span class="line"><span class="comment"># 将file2移动到dir2同时重命名为file3</span></span><br><span class="line">mv file2 dir2/file3</span><br></pre></td></tr></table></figure>

<p>mv不管是重命名还是移动,<strong>inode编号</strong>和<strong>时间戳</strong>保持不变.</p>
<p>==mv也有覆盖的问题,需要使用-i来询问==(注意:没有发生问题的时候是不会提醒的)</p>
<h2 id="删除文件-rm"><a href="#删除文件-rm" class="headerlink" title="删除文件(rm)"></a>删除文件(rm)</h2><p>-i命令参数提示你是不是要真的删除该文件。</p>
<p>如果删除整组的文件,-i会一个个的问过去:</p>
<p><img src="/images/1554595359904.png" alt="1554595359904"></p>
<p>和-i相反,使用-f就是<strong>不询问是否删除</strong>,然后直接强制删除.</p>
<h2 id="处理目录-mkdir-rmdir-file-cat-less-more-tail-head"><a href="#处理目录-mkdir-rmdir-file-cat-less-more-tail-head" class="headerlink" title="处理目录(mkdir,rmdir,file,cat,less.more,tail,head)"></a>处理目录(mkdir,rmdir,file,cat,less.more,tail,head)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir new_dir</span><br><span class="line"><span class="comment"># 使用-p创建多级目录</span></span><br><span class="line">mkdir -p new_dir/new_dir2/new_dir3</span><br></pre></td></tr></table></figure>

<p>一般我们删除目录使用的是<code>rm -rf dir1</code>,但是还有一个<code>rmdir</code>命令.</p>
<p><code>rm</code>在没有-r参数的时候只能删除空目录,<code>rmdir</code>同理.(<strong>-r是递归的意思</strong>,所以rm -r就是递归删除)<br>所以说,-r选项使得命令可以向下进入目录，删除其中的文件，然后再删除目录本身。</p>
<p><code>rmdir</code>没有-r参数,所以<strong>rmdir只能删除空目录</strong>.</p>
<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><p><strong>file:查看文件类型</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看dir2的文件类型,返回dir2: directory</span></span><br><span class="line">file dir2/</span><br><span class="line"><span class="comment"># 查看new_file的文件类型,返回dir2/newfile: empty</span></span><br><span class="line">file dir2/newfile</span><br><span class="line"><span class="comment"># 甚至能看符号链接文件所指的源文件所在地</span></span><br><span class="line"><span class="comment"># 查看file2的文件类型,返回file2: symbolic link to file1</span></span><br><span class="line">file file2</span><br></pre></td></tr></table></figure>

<h2 id="查看整个文件"><a href="#查看整个文件" class="headerlink" title="查看整个文件"></a>查看整个文件</h2><p><strong>cat:显示文本文件</strong><br>-n参数会给所有的行加上行号。 -n会给空行也加上行号,<br>-b参数会只给有文本的行加上行号.<br>-T参数不显示制表符(制表符会变成^I)</p>
<p>cat会一次性加载全部的文件内容.<br>而<strong>more命令能按页加载文件内容</strong></p>
<p><img src="/images/1554597434399.png" alt="1554597434399"></p>
<p>需要使用:空格进行下一页,回车进行下一行,q进行取消</p>
<p>less就是more命令的升级版,它提供了一些极为实用的特性，能够实现在文本文件中前后翻动，而且还有一些高级搜索功能。</p>
<h2 id="查看部分文件"><a href="#查看部分文件" class="headerlink" title="查看部分文件"></a>查看部分文件</h2><p>more命令确实能按页呈现.<br>但是如果我看需要查看的内容在中间怎么办.这时需要使用head和tail命令</p>
<p>tail命令会显示文件后几行的内容（文件的“尾部”）。<br>默认情况下，它会显示文件的末尾10行。 </p>
<p><strong>tail使用-n参数修改显示几行</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示file2的最后3行</span></span><br><span class="line">tail -n 3 file2</span><br><span class="line"><span class="comment"># 简写成:</span></span><br><span class="line">tail -3 file2</span><br></pre></td></tr></table></figure>

<p>-f参数是tail命令的一个突出特性。<br>它允许你在其他进程使用该文件时查看文件的内容。 tail命令会保持活动状态，并不断显示添加到文件中的内容。这是实时监测系统日志的绝妙方式。<br>简单来说,==-f参数能让tail命令保持活动状态,实时监控文件==.</p>
<p>head命令，顾名思义，会显示文件开头那些行的内容。默认情况下，它会显示文件前10行的文本.head命令和tail命令差不多,都是使用-n参数的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示file2的头三行</span></span><br><span class="line">head -3 file2</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>cd命令在虚拟目录里切换目录。 </li>
<li>ls命令列出目录中的文件和子目录。</li>
<li>touch命令创建空文件和变更已有文件的访问时间或修改时间。</li>
<li>cp命令将已有文件复制到其他位置。</li>
<li>ln命令复制硬链接和符号链接。 </li>
<li>mv和rm命令移动文件移除文件。</li>
<li>mkdir和rmdir命令移动文件移除文件目录。</li>
<li>cat、more和less命令查看文件全部内容。</li>
<li>tail和head命令查看文件中的一小部分内容。 </li>
</ol>
<h1 id="第4章-更多的bash-shell命令"><a href="#第4章-更多的bash-shell命令" class="headerlink" title="第4章.更多的bash shell命令"></a>第4章.更多的bash shell命令</h1><p>本章将详细介绍Linux系统管理命令</p>
<h2 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h2><h3 id="探查进程-ps-top"><a href="#探查进程-ps-top" class="headerlink" title="探查进程(ps,top)"></a>探查进程(ps,top)</h3><p>ps命令能输出运行在系统上的所有程序的许多信息。 ps命令参数及其复杂,<br>默认情况下，ps命令只会显示运行在当前控制台下的属于当前用户的进程。</p>
<p><img src="/images/1554599225461.png" alt="1554599225461"></p>
<p>上例中的基本输出显示了程序的进程ID（Process ID，PID）、它们运行在哪个终端（TTY） 以及进程已用的CPU时间。 </p>
<p>Linux系统中使用的GNU ps命令支持3种不同类型的命令行参数：</p>
<ul>
<li>Unix风格的参数，前面加单破折线</li>
<li>BSD风格的参数，前面不加破折线</li>
<li>GNU风格的长参数，前面加双破折线。 </li>
</ul>
<p>查看系统上运行的所有进程:-ef<br> (-e参数指定显示所有运行在系统上的进程；-f参数则扩展了输出，这些扩展的列包含了有用的信息)</p>
<p><img src="/images/1554599567084.png" alt="1554599567084"></p>
<ul>
<li>UID：启动这些进程的用户。</li>
<li> PID：进程的进程ID。</li>
<li> PPID：父进程的进程号（如果该进程是由另一个进程启动的）。</li>
<li> C：进程生命周期中的CPU利用率。 </li>
<li> STIME：进程启动时的系统时间。 </li>
<li> TTY：进程启动时的终端设备。 </li>
<li> TIME：运行进程需要的累计CPU时间。 </li>
<li> CMD：启动的程序名称</li>
</ul>
<p>ps命令的不足之处：它只能显示某个特定时间点的信息。<br>top命令跟ps命令相似，能够显示进程信息，但它是实时显示的。</p>
<p><img src="/images/1554599934835.png" alt="1554599934835"></p>
<p>上图的表是实时变动的.也就是说,==top命令是实时监控进程的==</p>
<p>第一行load average有三个值：近1分钟的、近5分钟的和近15分钟的平均负载。</p>
<p>第二行显示了进程概要信息——top命令的输出中将进程叫作任务（task）：有多少进程处在 运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。 </p>
<p>第三行显示了CPU的概要信息。top根据进程的属主（用户还是系统）和进程的状态（运行、 空闲还是等待）将CPU利用率分成几类输出。 </p>
<p>最后两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存， 当前用了多少，还有多少空闲。<br>最后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。 后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似。 </p>
<ul>
<li>PID：进程的ID。 </li>
<li>USER：进程属主的名字。 </li>
<li>PR：进程的优先级。 </li>
<li>NI：进程的谦让度值。 </li>
<li>VIRT：进程占用的虚拟内存总量。 </li>
<li>RES：进程占用的物理内存总量。 </li>
<li>SHR：进程和其他进程共享的内存总量。 </li>
<li>S：进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表 跟踪状态或停止状态，Z代表僵化状态）。 </li>
<li>%CPU：进程使用的CPU时间比例。 </li>
<li>%MEM：进程使用的内存占可用内存的比例</li>
<li>TIME+：自进程启动到目前为止的CPU时间总量。</li>
<li>COMMAND：进程所对应的命令行名称，也就是启动的程序名。 </li>
</ul>
<h2 id="结束进程-kill-kiilall"><a href="#结束进程-kill-kiilall" class="headerlink" title="结束进程(kill,kiilall)"></a>结束进程(kill,kiilall)</h2><p>在Linux中，进程之间通过<code>信号</code>来通信。<br>进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。</p>
<table>
<thead>
<tr>
<th>信  号</th>
<th>名  称</th>
<th>描  述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>HUP</td>
<td>挂起</td>
</tr>
<tr>
<td>2</td>
<td>INT</td>
<td>中断</td>
</tr>
<tr>
<td>3</td>
<td>QUIT</td>
<td>结束运行</td>
</tr>
<tr>
<td>9</td>
<td>KILL</td>
<td>无条件终止</td>
</tr>
<tr>
<td>11</td>
<td>SEGV</td>
<td>段错误</td>
</tr>
<tr>
<td>15</td>
<td>TERM</td>
<td>尽可能终止</td>
</tr>
<tr>
<td>17</td>
<td>STOP</td>
<td>无条件停止运行，但不终止</td>
</tr>
<tr>
<td>18</td>
<td>TSTP</td>
<td>停止或暂停，但继续在后台运行</td>
</tr>
<tr>
<td>19</td>
<td>CONT</td>
<td>在STOP或TSTP之后恢复执行</td>
</tr>
</tbody></table>
<p>kill命令:<br>kill命令可通过进程ID（PID）给进程发信号。<br>遗憾的是，你只能用进程的PID而不能用命令名，所以kill命令有时并不好用。 </p>
<p>killall命令:<br>killall命令非常强大，它支持通过进程名而不是PID来结束进程。killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 结束所有以http开头的进程</span></span><br><span class="line">killall http* </span><br></pre></td></tr></table></figure>

<h2 id="监测磁盘空间-mount-umount"><a href="#监测磁盘空间-mount-umount" class="headerlink" title="监测磁盘空间(mount,umount)"></a>监测磁盘空间(mount,umount)</h2><p>本节将介绍在日常系统管理 中经常用到的核心命令。 </p>
<p>如第3章中讨论的，Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒 体之前，需要把它放到虚拟目录下。这项工作称为挂载（mounting）。 </p>
<p> mount命令:<br>用来挂载媒体的命令。<br>默认情况下，<strong>mount命令会输出当前系统上挂载的设备列表</strong>。 </p>
<p><img src="/images/1554601886705.png" alt="1554601886705"></p>
<p>mount命令提供如下四部分信息：</p>
<ul>
<li>媒体的设备文件名 </li>
<li> 媒体挂载到虚拟目录的挂载点</li>
<li> 文件系统类型 </li>
<li> 已挂载媒体的访问状态 </li>
</ul>
<p>要手动在虚拟目录中挂载设备，需要以root用户身份登录，或是以root用户身份运行sudo命 令。下面是手动挂载媒体设备的基本命令： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模板:</span></span><br><span class="line">mount -t <span class="built_in">type</span> device directory </span><br></pre></td></tr></table></figure>

<p>type参数指定了磁盘被格式化的文件系统类型。</p>
<ul>
<li>vfat：Windows长文件系统。</li>
<li>ntfs：Windows NT、XP、Vista以及Windows 7中广泛使用的高级文件系统。</li>
<li>iso9660：标准CD-ROM文件系统</li>
</ul>
<p>后面两个参数定义了该存储设备的设备文件的位置以及挂载点在虚拟目录中的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eg:</span></span><br><span class="line">mount -t vfat /dev/sdb1 /media/disk</span><br></pre></td></tr></table></figure>

<p>umount命令:<br>从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。<br>卸载设备的命令是umount</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模板</span></span><br><span class="line">umount [directory | device ] </span><br></pre></td></tr></table></figure>

<p>和win一样,如果有任何程序正在使 用设备上的文件，系统就不会允许你卸载它：</p>
<p>df命令:<br>df命令可以让你很方便地查看所有已挂载磁盘的使用情况</p>
<p><img src="/images/1554602921540.png" alt="1554602921540"></p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>