<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第一章-基础知识&quot;&gt;&lt;a href=&quot;#第一章-基础知识&quot; class=&quot;headerlink&quot; title=&quot;第一章 基础知识&quot;&gt;&lt;/a&gt;第一章 基础知识&lt;/h1&gt;&lt;h2 id=&quot;机器语言&quot;&gt;&lt;a href=&quot;#机器语言&quot; class=&quot;headerlink&quot; title=&quot;机器语言&quot;&gt;&lt;/a&gt;机器语言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;机器语言是&lt;code&gt;机器指令&lt;/code&gt;的集合。&lt;/li&gt;
&lt;li&gt;机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将其转变成一列高低电平，以使计算机的电子器件受到驱动，进行运算。&lt;/li&gt;
&lt;li&gt;每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使他工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;早期的程序设计均使用机器语言。程序员们将用0、1数字编成的程序代码打在纸带或卡片上。1打孔，0不打孔。再将程序通过纸带机或卡片机输入计算机进行运算。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>汇编语言（第四版） | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Assembly-Language/" rel="tag">Assembly Language</a></div><div class="post-time">2022-02-08</div></div></div><div class="container post-header"><h1>汇编语言（第四版）</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">第一章 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">机器语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">汇编语言的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%92%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">指令和数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%AF%B9%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">1.1.3.</span> <span class="toc-text">CPU对存储器的读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">1.1.4.</span> <span class="toc-text">总线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%80%BB%E7%BA%BF"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">地址总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">数据总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">控制总线</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.5.</span> <span class="toc-text">内存地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PC%E6%9C%BA%E4%B8%AD%E5%90%84%E7%B1%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">PC机中各类存储器的逻辑连接</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">第二章 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mov%E3%80%81add"><span class="toc-number">2.2.</span> <span class="toc-text">mov、add</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF16%E4%BD%8D%E7%9A%84CPU"><span class="toc-number">2.3.</span> <span class="toc-text">什么是16位的CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8086CPU%E7%BB%99%E5%87%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">8086CPU给出物理地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E6%AE%B5%E5%9C%B0%E5%9D%80x16-%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">物理地址 &#x3D; 段地址x16 + 偏移地址的本质含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E6%AE%B5%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">段地址为什么叫段地址？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">段寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CS%E3%80%81IP%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">CS、IP段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E8%AF%BB%E5%8F%96%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">CPU读取执行一条指令的全流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%A0%B9%E6%8D%AE%E4%BB%80%E4%B9%88%E5%B0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E7%9C%8B%E4%BD%9C%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="toc-number">2.5.3.</span> <span class="toc-text">CPU根据什么将内存中的信息看作指令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmp%EF%BC%9A%E4%BF%AE%E6%94%B9CS%E3%80%81IP%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.4.</span> <span class="toc-text">jmp：修改CS、IP的指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">2.6.</span> <span class="toc-text">代码段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">第三章 寄存器（内存访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%8D%95%E5%85%83"><span class="toc-number">3.1.</span> <span class="toc-text">字单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DS%E5%92%8C-address"><span class="toc-number">3.2.</span> <span class="toc-text">DS和[address]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DS%E7%A4%BA%E4%BE%8B%E4%B8%80"><span class="toc-number">3.2.1.</span> <span class="toc-text">DS示例一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DS%E7%A4%BA%E4%BE%8B%E4%BA%8C"><span class="toc-number">3.2.2.</span> <span class="toc-text">DS示例二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">3.2.3.</span> <span class="toc-text">累加数据段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">CPU提供的栈机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%A9%BA%E7%8A%B6%E6%80%81SP%E4%B8%BA%E5%A4%9A%E5%B0%91"><span class="toc-number">3.3.1.</span> <span class="toc-text">栈空状态SP为多少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">栈顶越界问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push%E3%80%81pop%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.3.</span> <span class="toc-text">push、pop指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%AE%B5"><span class="toc-number">3.3.4.</span> <span class="toc-text">栈段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E7%BB%BC%E8%BF%B0"><span class="toc-number">3.4.</span> <span class="toc-text">段的综述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8086%E6%89%80%E6%9C%89%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">8086所有的寄存器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">第四章 第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">伪指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#segment%E2%80%A6ends"><span class="toc-number">4.1.1.</span> <span class="toc-text">segment…ends</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#end"><span class="toc-number">4.1.2.</span> <span class="toc-text">end</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assume"><span class="toc-number">4.1.3.</span> <span class="toc-text">assume</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%8F%B7"><span class="toc-number">4.2.</span> <span class="toc-text">标号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E"><span class="toc-number">4.3.</span> <span class="toc-text">程序返回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E7%BB%93%E6%9D%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text">与结束相关的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">4.4.</span> <span class="toc-text">编译与链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E4%BB%B6%E5%A5%97"><span class="toc-number">4.4.1.</span> <span class="toc-text">四件套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.4.3.</span> <span class="toc-text">链接的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5"><span class="toc-number">4.4.4.</span> <span class="toc-text">简化编译链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%86%99%E5%87%BA%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.5.</span> <span class="toc-text">汇编程序从写出到执行的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%B7%9F%E8%B8%AA"><span class="toc-number">4.5.</span> <span class="toc-text">程序执行过程中的跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EXE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.1.</span> <span class="toc-text">EXE文件中程序的加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8debug%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95"><span class="toc-number">4.5.2.</span> <span class="toc-text">使用debug进行调试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">第五章 [BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BX"><span class="toc-number">5.1.</span> <span class="toc-text">[BX]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loop%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">Loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Debug%E4%B8%AD%E8%B7%9F%E8%B8%AA%E7%94%A8loop%E6%8C%87%E4%BB%A4"><span class="toc-number">5.3.</span> <span class="toc-text">在Debug中跟踪用loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug%E5%92%8C%E6%B1%87%E7%BC%96%E7%BC%96%E8%AF%91%E5%99%A8masm%E5%AF%B9-idata-%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">Debug和汇编编译器masm对[idata]的不同处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">第六章 包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">6.1.</span> <span class="toc-text">在代码段中使用数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="toc-number">6.2.</span> <span class="toc-text">在代码段中使用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5"><span class="toc-number">6.3.</span> <span class="toc-text">将数据、代码、栈放入不同的段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">第七章 更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#and%E5%92%8Cor%E6%8C%87%E4%BB%A4"><span class="toc-number">7.1.</span> <span class="toc-text">and和or指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F%E7%BB%99%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">7.2.</span> <span class="toc-text">以字符形式给出的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.3.</span> <span class="toc-text">如何进行大小写转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-idata"><span class="toc-number">7.4.</span> <span class="toc-text">[bx+idata]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SI%E5%92%8CDI"><span class="toc-number">7.5.</span> <span class="toc-text">SI和DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-si-%E5%92%8C-bx-di"><span class="toc-number">7.6.</span> <span class="toc-text">[bx+si]和[bx+di]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">7.7.</span> <span class="toc-text">不同的寻址方式的灵活应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">第八章 数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bx%E3%80%81si%E3%80%81di%E3%80%81bp"><span class="toc-number">8.1.</span> <span class="toc-text">bx、si、di、bp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="toc-number">8.2.</span> <span class="toc-text">机器指令处理的数据在什么地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-number">8.3.</span> <span class="toc-text">汇编语言中数据位置的表达</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">8.4.</span> <span class="toc-text">寻址方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%89%E5%A4%9A%E9%95%BF"><span class="toc-number">8.5.</span> <span class="toc-text">指令要处理的数据有多长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.6.</span> <span class="toc-text">汇编和C语言的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#div%E6%8C%87%E4%BB%A4"><span class="toc-number">8.7.</span> <span class="toc-text">div指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4dd"><span class="toc-number">8.8.</span> <span class="toc-text">伪指令dd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dup"><span class="toc-number">8.9.</span> <span class="toc-text">dup</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">第九章 转移指令的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6offset"><span class="toc-number">9.1.</span> <span class="toc-text">操作符offset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">9.2.</span> <span class="toc-text">依据位移进行转移的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">9.3.</span> <span class="toc-text">转移的目的地址在指令中的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">9.4.</span> <span class="toc-text">转移地址在寄存器中的jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84-jmp-%E6%8C%87%E4%BB%A4"><span class="toc-number">9.5.</span> <span class="toc-text">转移地址在内存中的 jmp 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jcxz%E6%8C%87%E4%BB%A4"><span class="toc-number">9.6.</span> <span class="toc-text">jcxz指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop%E6%8C%87%E4%BB%A4"><span class="toc-number">9.7.</span> <span class="toc-text">loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">9.8.</span> <span class="toc-text">根据位移进行转移的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E8%BD%AC%E7%A7%BB%E4%BD%8D%E7%A7%BB%E8%B6%85%E7%95%8C%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">9.9.</span> <span class="toc-text">编译器对转移位移超界的检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.10.</span> <span class="toc-text">一个奇怪的程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4"><span class="toc-number">10.</span> <span class="toc-text">第十章 CALL和RET指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ret%E5%92%8Cretf"><span class="toc-number">10.1.</span> <span class="toc-text">ret和retf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-number">10.2.</span> <span class="toc-text">依据位移进行转移的call指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-number">10.3.</span> <span class="toc-text">转移的目的地址在指令中的call指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-number">10.4.</span> <span class="toc-text">转移地址在寄存器中的call指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%AD%98%E4%BA%8E%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-number">10.5.</span> <span class="toc-text">转移地址存于内存中的call指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call%E5%92%8Cret%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">10.6.</span> <span class="toc-text">call和ret的配合使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mul%E6%8C%87%E4%BB%A4"><span class="toc-number">10.7.</span> <span class="toc-text">mul指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%9C%E4%BC%A0%E9%80%92%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">10.8.</span> <span class="toc-text">参数和结果传递的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">10.9.</span> <span class="toc-text">批量数据的传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">10.10.</span> <span class="toc-text">寄存器冲突的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">第十一章标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">何为标志寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8086CPUflag%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.</span> <span class="toc-text">8086CPUflag寄存器的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CF%E4%B8%8EOF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.3.</span> <span class="toc-text">CF与OF的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#adc%E6%8C%87%E4%BB%A4"><span class="toc-number">11.4.</span> <span class="toc-text">adc指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sbb%E6%8C%87%E4%BB%A4"><span class="toc-number">11.5.</span> <span class="toc-text">sbb指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmp%E6%8C%87%E4%BB%A4"><span class="toc-number">11.6.</span> <span class="toc-text">cmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">11.7.</span> <span class="toc-text">检测比较结果的条件转移指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DF%E6%A0%87%E5%BF%97%E5%92%8C%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">11.8.</span> <span class="toc-text">DF标志和串传送指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pushf%E5%92%8Cpopf"><span class="toc-number">11.9.</span> <span class="toc-text">pushf和popf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%A8Debug%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">11.10.</span> <span class="toc-text">标志寄存器在Debug中的表示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%86%85%E4%B8%AD%E6%96%AD"><span class="toc-number">12.</span> <span class="toc-text">第12章 内中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">12.1.</span> <span class="toc-text">内中断的产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B%E7%A0%81"><span class="toc-number">12.2.</span> <span class="toc-text">中断类型码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">12.3.</span> <span class="toc-text">中断处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">12.4.</span> <span class="toc-text">中断向量表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B"><span class="toc-number">12.5.</span> <span class="toc-text">中断过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%92%8Ciret%E6%8C%87%E4%BB%A4"><span class="toc-number">12.6.</span> <span class="toc-text">中断处理程序和iret指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%A4%84%E7%90%860%E5%8F%B7%E4%B8%AD%E6%96%AD"><span class="toc-number">12.7.</span> <span class="toc-text">编程处理0号中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">12.8.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do0"><span class="toc-number">12.9.</span> <span class="toc-text">do0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%AD%A5%E4%B8%AD%E6%96%AD"><span class="toc-number">12.10.</span> <span class="toc-text">单步中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">12.11.</span> <span class="toc-text">响应中断的特殊情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-int%E6%8C%87%E4%BB%A4"><span class="toc-number">13.</span> <span class="toc-text">第十三章 int指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%BE%9B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-number">13.1.</span> <span class="toc-text">编写供应用程序调用的中断例程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%B1%82%E4%B8%80word%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">13.1.1.</span> <span class="toc-text">示例一：求一word型数据的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%B0%86%E4%B8%80%E4%B8%AA%E5%85%A8%E6%98%AF%E5%AD%97%E6%AF%8D%EF%BC%8C%E4%BB%A50%E7%BB%93%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%A4%A7%E5%86%99"><span class="toc-number">13.1.2.</span> <span class="toc-text">示例二：将一个全是字母，以0结尾的字符串，转化为大写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9int%E3%80%81iret%E5%92%8C%E6%A0%88%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-number">13.2.</span> <span class="toc-text">对int、iret和栈的深入理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E4%BB%BFloop%E6%8C%87%E4%BB%A4"><span class="toc-number">13.2.1.</span> <span class="toc-text">模仿loop指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E4%BB%BFjmp-near-ptr-s%E6%8C%87%E4%BB%A4"><span class="toc-number">13.2.2.</span> <span class="toc-text">模仿jmp near ptr s指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIOS%E5%92%8CDOS%E6%89%80%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-number">13.3.</span> <span class="toc-text">BIOS和DOS所提供的中断例程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIOS%E5%92%8CDOS%E6%89%80%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-number">13.4.</span> <span class="toc-text">BIOS和DOS所提供的中断例程及安装过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%BA%94%E7%94%A8"><span class="toc-number">13.5.</span> <span class="toc-text">BIOS中断例程应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%BA%94%E7%94%A8"><span class="toc-number">13.6.</span> <span class="toc-text">DOS中断例程应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%AB%AF%E5%8F%A3"><span class="toc-number">14.</span> <span class="toc-text">第十四章 端口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">14.1.</span> <span class="toc-text">端口的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E5%92%8C%E8%AE%BF%E9%97%AE%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">14.1.1.</span> <span class="toc-text">访问内存和访问端口的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMOS-RAM%E8%8A%AF%E7%89%87"><span class="toc-number">14.2.</span> <span class="toc-text">CMOS RAM芯片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shl%E5%92%8Cshr%E6%8C%87%E4%BB%A4"><span class="toc-number">14.3.</span> <span class="toc-text">shl和shr指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMOS-RAM%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">14.4.</span> <span class="toc-text">CMOS RAM中存储的时间信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="toc-number">15.</span> <span class="toc-text">第十五章 外中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="toc-number">15.1.</span> <span class="toc-text">接口芯片和端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E4%B8%AD%E6%96%AD%E4%BF%A1%E6%81%AF"><span class="toc-number">15.2.</span> <span class="toc-text">外中断信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-number">15.2.1.</span> <span class="toc-text">可屏蔽中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-number">15.2.2.</span> <span class="toc-text">不可屏蔽中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E5%AF%B9%E5%A4%96%E8%AE%BE%E8%BE%93%E5%85%A5%E7%9A%84%E9%80%9A%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">15.3.</span> <span class="toc-text">CPU对外设输入的通常处理方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PC%E6%9C%BA%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">15.4.</span> <span class="toc-text">PC机键盘的处理过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="toc-number">15.4.1.</span> <span class="toc-text">键盘输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%8F%919%E5%8F%B7%E4%B8%AD%E6%96%AD"><span class="toc-number">15.4.2.</span> <span class="toc-text">引发9号中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cint9%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-number">15.4.3.</span> <span class="toc-text">执行int9中断例程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99int-9%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-number">15.5.</span> <span class="toc-text">编写int 9中断例程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E6%AC%A1%E6%98%BE%E7%A4%BA%E2%80%9Da%E2%80%9D-%E2%80%9Dz%E2%80%9D"><span class="toc-number">15.5.1.</span> <span class="toc-text">依次显示”a”~”z”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%B8%8BEsc%E9%94%AE%E5%90%8E%E6%94%B9%E5%8F%98%E6%98%BE%E7%A4%BA%E7%9A%84%E9%A2%9C%E8%89%B2"><span class="toc-number">15.5.2.</span> <span class="toc-text">按下Esc键后改变显示的颜色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%96%B0%E7%9A%84int-9%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-number">15.6.</span> <span class="toc-text">安装新的int 9中断例程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93"><span class="toc-number">15.7.</span> <span class="toc-text">指令总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8"><span class="toc-number">16.</span> <span class="toc-text">第十六章 直接定址表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E5%8D%95%E5%85%83%E9%95%BF%E5%BA%A6%E7%9A%84%E6%A0%87%E5%8F%B7"><span class="toc-number">16.1.</span> <span class="toc-text">描述单元长度的标号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%85%B6%E4%BB%96%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E6%A0%87%E5%8F%B7"><span class="toc-number">16.2.</span> <span class="toc-text">在其他段中使用数据标号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8"><span class="toc-number">16.3.</span> <span class="toc-text">直接定址表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8"><span class="toc-number">16.4.</span> <span class="toc-text">程序入口地址的直接定址表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E4%BD%BF%E7%94%A8BIOS%E8%BF%9B%E8%A1%8C%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99"><span class="toc-number">17.</span> <span class="toc-text">第十七章 使用BIOS进行键盘输入和磁盘读写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#int-9%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%AF%B9%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">17.1.</span> <span class="toc-text">int 9中断例程对键盘输入的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8int-16h%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E8%AF%BB%E5%8F%96%E9%94%AE%E7%9B%98%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">17.2.</span> <span class="toc-text">使用int 16h中断例程读取键盘缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-number">17.3.</span> <span class="toc-text">字符串的输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8int-13h%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%AF%B9%E7%A3%81%E7%9B%98%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99"><span class="toc-number">17.4.</span> <span class="toc-text">应用int 13h中断例程对磁盘进行读写</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h1><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><ul>
<li>机器语言是<code>机器指令</code>的集合。</li>
<li>机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将其转变成一列高低电平，以使计算机的电子器件受到驱动，进行运算。</li>
<li>每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使他工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。</li>
</ul>
<p>早期的程序设计均使用机器语言。程序员们将用0、1数字编成的程序代码打在纸带或卡片上。1打孔，0不打孔。再将程序通过纸带机或卡片机输入计算机进行运算。</p>
<p>应用8086CPU完成运算s=768+12288-1280，机器码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">101110000000000000000011</span><br><span class="line">000001010000000000110000</span><br><span class="line">001011010000000000000101</span><br></pre></td></tr></table></figure>



<p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。<strong>汇编指令是机器指令便于记忆的书写格式</strong>。</p>
<p>例如：机器指令1000100111011000表示把寄存器BX的内容送到AX中。汇编指令则写成<code>mov ax bx</code>。这样的写法与人类语言接近，便于阅读和记忆。</p>
<p>此后，程序员们就用汇编指令编写源程序。可是，计算机能读懂的只有机器指令，那如何让计算机执行程序员用汇编指令编写的程序呢？这时，就需要有一个能够将汇编指令转换成机器指令的翻译程序，这样的程序我们称其为<code>编译器</code>。</p>
<p>程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器码，由计算机最终执行。</p>
<p><img src="/images/image-20211112161024210.png" alt="image-20211112161024210"></p>
<h3 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h3><p>汇编语言由以下3类指令组成。</p>
<ul>
<li><code>汇编指令</code>：机器码的助记符，有对应的机器码。</li>
<li><code>伪指令</code>：没有对应的机器码，由编译器执行，计算机并不执行。</li>
<li><code>其他符号</code>：如+、-、*、/等，由编译器识别，没有对应的机器码。</li>
</ul>
<p>汇编语言的核心是汇编指令，它决定了汇编语言的特性。</p>
<h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><p>指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，<strong>都是二进制信息</strong>。CPU在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。就像围棋的棋子，在棋盒里的时候没有任何区别，在对弈的时候就有了不同的意义。</p>
<p>例如，内存中的二进制信息1000100111011000，计算机可以把它看作大小为89D8H的数据来处理，也可以将其看作指令 <code>mov ax bx</code>来执行。</p>
<h3 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h3><p>存储器分成<code>内存储器</code>(内存)和<code>外存储器</code>(外存，硬盘)。</p>
<ul>
<li>CPU要从内存中读数据，首先要指定存储单元的地址。也就是说它要先确定它要读取哪一个存储单元中的数据。</li>
<li>在一台微机中，不只有存储器这一种器件。CPU在读写数据时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读岀数据，还是向里面写入数据。</li>
</ul>
<p>可见，CPU要想进行数据的读写，必须和外部器件(标准的说法是芯片)进行下面3类信息的交互。</p>
<ul>
<li>地址信息：存储单元的地址</li>
<li>控制信息：器件的选择，读或写的命令</li>
<li>数据信息：读或写的数据</li>
</ul>
<p>那么CPU是通过什么将地址、数据和控制信息传到存储器芯片中的呢？</p>
<p>电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送。在计算机中专门有连接CPU和其他芯片的导线，通常称为<code>总线</code>。</p>
<blockquote>
<p>总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3类：</p>
<ul>
<li><code>地址总线</code></li>
<li><code>控制总线</code></li>
<li><code>数据总线</code></li>
</ul>
</blockquote>
<p>CPU从3号单元中读取数据的过程：</p>
<ol>
<li>CPU通过地址线将地址信息3发出。</li>
<li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。</li>
<li>储存器将3号单元中的数据数据8通过数据线送入CPU。</li>
</ol>
<p>写操作 与 读操作 类似。如向3号单元写入数据26：</p>
<ol>
<li>CPU通过地址线将地址信息3发出。</li>
<li>CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。</li>
<li>CPU通过数据线将数据26送入内存的3号单元中。</li>
</ol>
<p><img src="/images/image-20211112185327032.png" alt="image-20211112185327032"></p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个CPU可以引出3种总线的宽度标志了这个CPU的不同方面的性能：</p>
<ul>
<li>地址总线的宽度决定了CPU的寻址能力；</li>
<li>数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量：</li>
<li>控制总线的宽度决定了CPU对系统中其他器件的控制能力。</li>
</ul>
<h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><p><strong>CPU是通过地址总线来指定存储器单元的</strong>。所以，地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。</p>
<p>下图为一个具有10根地址线的CPU向内存发出地址信息11的时候，10根地址线上传送的二进制信息(<code>1101</code>)。</p>
<p><img src="/images/image-20211114092629490.png" alt="image-20211114092629490"></p>
<blockquote>
<p>也就是说：</p>
<ul>
<li>一条地址线一次传递一个二进制位。</li>
<li>一个CPU有N条地址线，那么这个CPU一次能发送/读取N bit数据。</li>
<li>一个CPU有N条地址线，那么这个CPU最多可以寻找2^N个内存单元。</li>
</ul>
</blockquote>
<h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。</p>
<p>数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次可传送两个字节。</p>
<p>下图为8086CPU写入数据89D8H时，数据总线上的数据传送情况</p>
<p><img src="/images/image-20211114094647096.png" alt="image-20211114094647096"></p>
<h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>CPU对外部器件的控制是通过控制总线来进行的。</p>
<p>在这里控制总线是个总称，控制总线是一些不同控制线的集合。<strong>有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制</strong>。所以，控制总线的宽度决定了CPU对外部器件的控制能力。</p>
<blockquote>
<p>前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根称为“读信号输出”的控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据：有一根称为“写信号输出”的控制线则负责传送写信号。</p>
</blockquote>
<h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>一个CPU的地址总线宽度为10，那么可以寻址2的10次方共计1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。</p>
<h4 id="PC机中各类存储器的逻辑连接"><a href="#PC机中各类存储器的逻辑连接" class="headerlink" title="PC机中各类存储器的逻辑连接"></a>PC机中各类存储器的逻辑连接</h4><p><img src="/images/image-20211114100358072.png" alt="image-20211114100358072"></p>
<p>存储器在物理上是独立的器件，但是有两点相同：</p>
<ul>
<li>都和CPU的总线相连。</li>
<li>CPU对它们进行读或写的时候都通过控制线发出内存读写命令</li>
</ul>
<p>这也就是说，<strong>CPU在操控它们的时候，将各类存储器看作是一个逻辑存储器，把它们都当作内存来对待</strong>，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。</p>
<p><img src="/images/image-20211115110615698.png" alt="image-20211115110615698"></p>
<p>不同的计算机系统的内存地址空间的分配情况是不同的。下图展示了8086PC机内存地址空间分配的基本情况。</p>
<p><img src="/images/image-20211115111718699.png" alt="image-20211115111718699"></p>
<h1 id="第二章-寄存器"><a href="#第二章-寄存器" class="headerlink" title="第二章 寄存器"></a>第二章 寄存器</h1><ul>
<li>一个典型的CPU由运算器、控制器、寄存器等器件构成。<ul>
<li><code>运算器</code>进行信息处理。</li>
<li><code>寄存器</code>进行信息存储。</li>
<li><code>控制器</code>控制各种器件进行工作。</li>
</ul>
</li>
<li>这些器件靠内部总线相连。前一章所说的总线，是外部总线。</li>
<li>内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系。</li>
</ul>
<ul>
<li><strong>寄存器是CPU中程序员可以用指令读写的部件</strong>。程序员通过改变各种寄存器中的内容来实现对CPU的控制。</li>
<li>不同的CPU，寄存器的个数、结构是不相同的。8086CPU有14个寄存器，每个寄存器有一个名称。这些寄存器是:AX、BX、CX、DX、SIDI、SP、BP、IP、CS、SS、DS、ES、PSW。</li>
</ul>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>8086CPU的所有寄存器都是16位的。可以存放两个字节。AX，BX，CX，DX这4个寄存器通常用来存放一般性的数据，被称为<code>通用寄存器</code>。</p>
<p><img src="/images/image-20211115112705320.png" alt="image-20211115112705320"></p>
<p>8086CPU的上一代CPU的寄存器都是8位的，为了保证兼容，4个通用寄存器都可以分成可独立使用分的8位寄存器来用。</p>
<p>出于对兼容性的考虑，8086PU可以一次性处理以下两种尺寸的数据。</p>
<ul>
<li><code>字节</code>：记为 byte，一个字节由8个bt组成，可以存在8位寄存器中。</li>
<li><code>字</code>：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节</li>
</ul>
<p><img src="/images/image-20211115113125290.png" alt="image-20211115113125290"></p>
<h2 id="mov、add"><a href="#mov、add" class="headerlink" title="mov、add"></a>mov、add</h2><ul>
<li>mov被称为<code>传送指令</code></li>
</ul>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax，18</td>
<td>将18送入寄存器AX</td>
<td>AX=18</td>
</tr>
<tr>
<td>add ax，8</td>
<td>将寄存器AX中的数值加上8</td>
<td>AX=AX+8</td>
</tr>
<tr>
<td>mov ax，bx</td>
<td>将寄存器BX中的数据送入寄存器AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax，bx</td>
<td>将AX和BX中的数值相加，结果存于AX中</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<h2 id="什么是16位的CPU"><a href="#什么是16位的CPU" class="headerlink" title="什么是16位的CPU"></a>什么是16位的CPU</h2><p>16位结构，16位机，字长位16位，表示相同的意思。16位CPU具有下面的结构特性：</p>
<ul>
<li>运算器一次最多处理16位的数据</li>
<li>寄存器的最大宽度为16位</li>
<li>寄存器和运算器之间的通路为16位。</li>
</ul>
<blockquote>
<p>内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，</p>
<p>这也就是说，16位CPU，<strong>能一次性处理、传输、暂时存储16位的地址</strong>。</p>
</blockquote>
<h2 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h2><ul>
<li>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。</li>
<li>从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。</li>
<li>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</li>
</ul>
<p><img src="/images/image-20211115121612793.png" alt="image-20211115121612793"></p>
<p>如图所示，当8086CPU要读写内存时：</p>
<ol>
<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</li>
<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li>
<li>地址加法器将两个16位地址合成为一个20位的物理地址</li>
<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</li>
<li>输入输出控制电路将20位物理地址送上地址总线;</li>
<li>20位物理地址被地址总线传送到存储器</li>
</ol>
<p>地址加法器采用<code>物理地址 = 段地址x16 + 偏移地址</code>的方法合成物理地址。</p>
<p>例如，8086CPU要访问地址为123C8H的内存单元，此时，地址加法器的工作过程</p>
<p><img src="/images/image-20211115122043995.png" alt="image-20211115122043995"></p>
<h3 id="物理地址-段地址x16-偏移地址的本质含义"><a href="#物理地址-段地址x16-偏移地址的本质含义" class="headerlink" title="物理地址 = 段地址x16 + 偏移地址的本质含义"></a><code>物理地址 = 段地址x16 + 偏移地址</code>的本质含义</h3><p><code>段地址×16+偏移地址=物理地址</code>的本质含义是：</p>
<ul>
<li>CPU在访问内存时，用一个基础地址(段地址×16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</li>
<li>更一般地说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。8086CPU中，段地址×16可看作是基础地址。</li>
</ul>
<blockquote>
<p>使用比喻说明“基础地址+偏移地址=物理地址”的思想。</p>
<p><img src="/images/image-20211115141224487.png" alt="image-20211115141224487"></p>
<p>你要去图书馆，问我那里的地址，我可以用两种方式告诉你图书馆的地址</p>
<ul>
<li>从学校走2826m到图书馆。这2826m可以认为是图书馆的物理地址。这种方法是直接给出物理地址2826m</li>
<li>从学校走2000m到体育馆，从体育馆再走826m到图书馆。第一个距离200m是相对于起点的基础地址，第二个距离826m是相对于基础地址的偏移地址(以基础地址为起点的地址)。这种方式是用基础地址和偏移地址相加来得到物理地址的。</li>
</ul>
<p>现在再加一些限制条件，比如只能通过纸条进行通信。你问我图书馆的地址，我只能将它写在纸上告诉你。显然必须有一张容纳4位数的纸条才能写下2826这个数据。</p>
<p><img src="/images/image-20211115142201297.png" alt="image-20211115142201297"></p>
<p>但是现在没有能容纳4位数的纸条，仅有两张可以容纳3位数的纸条。这样我们就需要使用下面的方式来传递数据：</p>
<p><img src="/images/image-20211115142320650.png" alt="image-20211115142320650"></p>
<p>在第一张纸上写上200（段地址），在第二张纸上写上826（偏移地址）。然后我们约定，当你得到这两张纸后，做这样的运算：<code>200 * 10 + 826 = 2826</code>。</p>
<p>8086CPU就是这样一个只能提供两张3位数纸条的CPU。</p>
</blockquote>
<h3 id="段地址为什么叫段地址？"><a href="#段地址为什么叫段地址？" class="headerlink" title="段地址为什么叫段地址？"></a>段地址为什么叫段地址？</h3><p>因为8086CPU使用<code>基础地址(段地址x16) + 偏移地址 = 物理地址</code>的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。</p>
<p>段地址和偏移地址都为16位。所以可以得出下面的公式：(x表示段地址，y表示偏移地址)</p>
<ul>
<li>16x + y = 2^20</li>
<li>0 &lt;= y &lt;= 2^16</li>
</ul>
<p>也就是说，<strong>如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可以定位2^16个内存单元</strong>。我们就可以把这2^16的范围称之为<code>一段</code>。</p>
<p>例如：地址10000H～100FFH的内存单元组成一个段。该段的起始地址位10000H，段地址为10000H/16=1000H，大小为100H。</p>
<p>我们也可以认为地址10000H～1007FH、10080H～100FFH的内存单元组成两个段，他们的起始地址为10000H和10080H，段地址为100H和1008H，大小都为80H。</p>
<p><img src="/images/image-20211115153550604.png" alt="image-20211115153550604"></p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><ul>
<li>段地址在8086CPU的段寄存器中存放。</li>
<li>8086CPU有4个段寄存器：CS，DS，SS，ES。</li>
</ul>
<h3 id="CS、IP段寄存器"><a href="#CS、IP段寄存器" class="headerlink" title="CS、IP段寄存器"></a>CS、IP段寄存器</h3><ul>
<li>CS和IP提供了CPU当前要读取和执行指令的地址。CS为代码段寄存器，IP为指令指针寄存器。</li>
<li>假设CS中的内容为M，IP的内容为N。CPU就可以从内存<code>M * 16 + N</code>单元开始，读取一条指令并执行。</li>
</ul>
<h3 id="CPU读取执行一条指令的全流程"><a href="#CPU读取执行一条指令的全流程" class="headerlink" title="CPU读取执行一条指令的全流程"></a>CPU读取执行一条指令的全流程</h3><p><img src="/images/image-20211115180957601.png" alt="image-20211115180957601"></p>
<p>情况说明如下：</p>
<ul>
<li>当前CS中的内容为2000H，IP中的内容为0000H</li>
<li>内存20000H-20002H单元存放着可执行的机器码，长度为3Byte，对应的汇编指令为<code>mov ax,0123H</code></li>
</ul>
<p>CPU读取执行一条指令的流程如下：</p>
<ol>
<li>CS和IP中的内容送入地址加法器。</li>
<li>地址加法器完成计算，得出物理地址20000H。</li>
<li>地址加法器见物理地址送入输入输出控制电路。</li>
<li>输入输出电路见物理地址20000H送上地址总线。</li>
<li>从内存20000H单元开始存放的机器指令B8 23 01 通过数据总线被送入CPU。</li>
<li>输入输出控制电路见机器指令B8 23 01 送入指令缓冲器。</li>
<li>IP中的值自动增加。（读取一条指令后，IP中的值会自动增加，以使CPU可以读取下一条指令。因为当前读入的指令B82301长度为3个字节，所以IP中的值加3，此时CS:IP指向内存单元2000:0003）</li>
<li>执行控制器执行指令B82301（即 mov ax,0123H）</li>
<li>指令B82301被执行后，AX中的内容为0123H。</li>
<li>接下来，CPU将从过年内存单元2000:0003处读取指令，重复上述的流程。</li>
</ol>
<blockquote>
<p>8086CPU的工作过程可以简要总结如下：</p>
<ol>
<li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>IP=IP+所读取指令的长度，从而指向下一条指令；</li>
<li>执行指令。赚到步骤1，重复这个过程。</li>
</ol>
</blockquote>
<p>在8086CPU刚开启工作时，CS和IP被设置为CS=FFFFH，IP=0000H。即8086CPU机刚启动时，CPU从内存FFFF0H单元中读取指令执行。FFFF0H单元中的指令时8086机开机后执行的第一条指令。</p>
<h3 id="CPU根据什么将内存中的信息看作指令？"><a href="#CPU根据什么将内存中的信息看作指令？" class="headerlink" title="CPU根据什么将内存中的信息看作指令？"></a>CPU根据什么将内存中的信息看作指令？</h3><p>在内存中，指令和数据没有任何区别，都是二进制信息。CPU时怎么区分二者的？</p>
<ul>
<li><strong>CPU将CS：IP指向的内存单元中的内容看作指令。</strong></li>
<li>在任何时候，CPU都会将CS当作指令的段地址，把IP当作指令的偏移地址，用他们合成指令的物理地址，到内存中读取指令码，执行。</li>
<li>也就是说，如果内存中的一段信息曾经被CPU执行过的话，那么，它所在的内存单元必然被CS：IP指向过。</li>
</ul>
<h3 id="jmp：修改CS、IP的指令"><a href="#jmp：修改CS、IP的指令" class="headerlink" title="jmp：修改CS、IP的指令"></a>jmp：修改CS、IP的指令</h3><ul>
<li>在CPU中，程序员能用指令读写的部件只有寄存器。因为CPU执行的指令是由CS、IP中的内容决定的，所以可以通过修改寄存器的内容对CPU实现控制。</li>
<li>mov可以修改AX，BX，CX，DX寄存器，但是不能修改CS、IP寄存器。能修改CS、IP的指令被称为<code>转移指令</code>。<code>jmp</code>是其中一种转移指令。</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JMP 1000H</td>
<td>CS不变，IP变成1000H</td>
</tr>
<tr>
<td>JMP CX</td>
<td>CS不变，IP变成CX（含义类似于 mov IP,CX）</td>
</tr>
<tr>
<td>JMP 1000H:2000H</td>
<td>修改CS、IP（含义类似于mov CS,1000H; mov IP,2000H）</td>
</tr>
<tr>
<td>JMP DWORD PTR [SI]</td>
<td>段间间接转移转移地址在SI所指地址开始的4个单元中</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 模版:</span><br><span class="line">jmp 段地址:偏移地址</span><br><span class="line"></span><br><span class="line"># 执行后，CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令。</span><br><span class="line">jmp 2AE3:3</span><br><span class="line"></span><br><span class="line"># 执行后，CS=0003H，IP=0B16H，CPU将从00B46H处读取指令。</span><br><span class="line">jmp 3:0B16</span><br></pre></td></tr></table></figure>



<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>对于8086PC机，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N（N &lt;= 64KB）的一组代码，存于一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个<code>代码段</code>。</p>
<p>比如，将：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0000  ; (B8 00 01)</span><br><span class="line">add ax,0123H ; (05 23 01)</span><br><span class="line">mov bx,ax.   ; (8B D8)</span><br><span class="line">jmp bx       ; (FF E3)</span><br></pre></td></tr></table></figure>

<p>这段长度为10个字节的指令，存放在123B0H<del>123B9H的一组内存单元中，我们就可以认为，123B0H</del>123B9H这段内存是用来存放代码的，是一个代码段，它的段地址为 123BH， 长度为10个字节。如果要让这段代码得到执行，可设CS=123BH、IP=0000H。</p>
<h1 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h1><h2 id="字单元"><a href="#字单元" class="headerlink" title="字单元"></a>字单元</h2><ul>
<li><p>8086CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。所以<strong>一个字要用两个地址连续的内存单元来存放</strong>，这个字的<strong>低位字节存放在低地址单元中，高位字节存放在高地址单元中</strong>。这两个字节，就被称为<code>字单元</code>。</p>
</li>
<li><p>比如我们从0地址开始存放20000(4E20H)，如图所示</p>
<p><img src="/images/image-20211116113503481.png" alt="image-20211116113503481"></p>
</li>
</ul>
<h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><ul>
<li><p>8086CPU中有一个DS寄存器，通常<strong>用来存放要访问数据的段地址</strong>。</p>
</li>
<li><p><code>[…]</code>：表示一个内存单元。</p>
</li>
<li><p><code>mov al,[0]</code>：将DS寄存器中的内容作为段地址，[]的内存单元的内容作为偏移地址。读取内存中的数据，将其写入al中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx  ; ds是段寄存器，mov ds,1000H是非法的。只能使用一个通用寄存器作为中转</span><br><span class="line"></span><br><span class="line">; 读取10000H:0单元的内容，写入al</span><br><span class="line">mov al,[0] ; 将DS寄存器中的内容作为段地址，[]的内存单元的内容作为偏移地址，传入al</span><br><span class="line"></span><br><span class="line">; 将al的数据传输到10000H:0的内存中。</span><br><span class="line">mov [0],al</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DS示例一"><a href="#DS示例一" class="headerlink" title="DS示例一"></a>DS示例一</h3><p><img src="/images/image-20211116142555443.png" alt="image-20211116142555443"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[0]</span><br><span class="line">mov bx,[2]</span><br><span class="line">mov cx,[1]</span><br><span class="line">add bx,[1]</span><br><span class="line">add cx,[2]</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211116142624357.png" alt="image-20211116142624357"></p>
<h3 id="DS示例二"><a href="#DS示例二" class="headerlink" title="DS示例二"></a>DS示例二</h3><p><img src="/images/image-20211116144349072.png" alt="image-20211116144349072"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,11316</span><br><span class="line">mov [0],ax</span><br><span class="line">mov bx,[0]</span><br><span class="line">sub bx,[2]</span><br><span class="line">mov [2],bx</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211116144537772.png" alt="image-20211116144537772"></p>
<h3 id="累加数据段"><a href="#累加数据段" class="headerlink" title="累加数据段"></a>累加数据段</h3><p>累加数据段中前3个字的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,123BH </span><br><span class="line">mov ds, ax   ; 将123BH送入ds中，作为数据段的段地址</span><br><span class="line">mov ax,O     ; 用ax存放累加结果</span><br><span class="line">add ax, [0]  ; 将数据段第一个字（偏移地址为0）加到ax中</span><br><span class="line">add ax, [2]  ; 将数据段第二个字（偏移地址为2）加到ax中</span><br><span class="line">add ax, [4]  ; 将数据段第三个字（偏移地址为4）加到ax中</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，一个字型数据占两个单元，所以偏移地址是 0、2、4。</p>
</blockquote>
<h2 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h2><ul>
<li>8086CPU提供相关的指令来以栈的方式访问内存空间。这意味着，在基于8086CPU编程的时候，<strong>可以将一段内存当作栈来使用</strong>。</li>
<li>8086CPU提供入栈和出栈指令，最基本的两个是PUSH（入栈）和POP（出栈）。</li>
<li><strong><code>push ax</code>表示将寄存器ax中的数据送入栈中，<code>pop ax</code>表示从栈顶取出数据送入ax。</strong></li>
<li>8086CPU的入栈和出栈操作都是<strong>以字为单位进行的</strong>。</li>
</ul>
<ul>
<li>8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，<strong>栈顶的段地址存放在<code>SS</code>中，偏移地址存放在<code>SP</code>中</strong>。</li>
<li><strong>任意时刻，<code>SS：SP</code>指向栈顶元素。</strong></li>
<li>push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</li>
</ul>
<p>举例说明，我们可以将10000H~1000FH这段内存当作栈来使用。</p>
<p><img src="/images/image-20211116161344067.png" alt="image-20211116161344067"></p>
<p>push ax的执行，由以下两步完成：</p>
<ol>
<li>SP=SP-2，SS：SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶； </li>
<li>将ax中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶。</li>
</ol>
<p><img src="/images/image-20211116162217296.png" alt="image-20211116162217296"></p>
<blockquote>
<p>入栈时，栈顶从高地址向低地址方向增长。</p>
</blockquote>
<p>pop ax的执行过程和push ax刚好相反，由以下两步完成。</p>
<ul>
<li>将SS：SP指向的内存单元处的数据送入ax中；</li>
<li>SP=SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ul>
<p><img src="/images/image-20211116163323998.png" alt="image-20211116163323998"></p>
<blockquote>
<p>出栈后，SS：SP指向新的栈顶1000EH，pop操作前的栈顶元素，<strong>1000CH处的2266H依然存在</strong>，但是，它已不在栈中。当再次执行push等入栈指令后，SS：SP移至1000CH，并在里面写入新的数据，它将被覆盖。</p>
</blockquote>
<p>总结：</p>
<ul>
<li>push指令的执行步骤： <ol>
<li>SP=SP-2；</li>
<li>向SS：SP指向的字单元中送入数据。 </li>
</ol>
</li>
<li>pop指令的执行步骤： <ol>
<li>从SS：SP指向的字单元中读取数据； </li>
<li>SP=SP+2。</li>
</ol>
</li>
</ul>
<h3 id="栈空状态SP为多少"><a href="#栈空状态SP为多少" class="headerlink" title="栈空状态SP为多少"></a>栈空状态SP为多少</h3><ul>
<li>将10000H~1000FH这段空间当作栈段，初始状态栈是空的，SS=1000H，栈空间大小为16字节，栈最底部的字单元地址为1000:000E。</li>
<li>任意时刻，SS：SP指向栈顶，当栈中只有一个元素的时候，SS=1000H，SP=000EH。</li>
<li>栈为空，就相当于栈中唯一的元素出栈，出栈后，SP=SP+2，SP原来为000EH，加2后SP=10H，所以，当栈为空的时候，SS=1000H，SP=10H。</li>
</ul>
<p><img src="/images/image-20211116162650612.png" alt="image-20211116162650612"></p>
<h3 id="栈顶越界问题"><a href="#栈顶越界问题" class="headerlink" title="栈顶越界问题"></a>栈顶越界问题</h3><ul>
<li>当栈满的时候再使用push指令入栈，或栈空的时候再使用pop指令出栈，都将发生栈顶超界问题。</li>
<li>8086CPU<strong>不保证我们对栈的操作不会超界</strong>。</li>
<li>这也就是说，<strong>8086CPU只知道栈顶在何处（由SS：SP指示），而不知道我们安排的栈空间有多大</strong>。这点就好像CPU只知道当前要执行的指令在何处（由CS：IP指示），而不知道要执行的指令有多少。</li>
</ul>
<h3 id="push、pop指令"><a href="#push、pop指令" class="headerlink" title="push、pop指令"></a>push、pop指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push 寄存器   ; 将一个寄存器中的数据入栈(将寄存器中的数据push进内存)</span><br><span class="line">pop 寄存器    ; 出栈，用一个寄存器接收出栈的数据(将内存中的数据pop到寄存器中)</span><br><span class="line">push 内存单元 ; 将一个内存字单元处的字入栈（注意：栈操作都是以字为单位） </span><br><span class="line">pop 内存单元  ; 出栈，用一个内存字单元接收出栈的数据</span><br><span class="line"></span><br><span class="line">; eg:</span><br><span class="line">mov ax,1000H </span><br><span class="line">mov ds,ax     ; 内存单元的段地址要放在ds中</span><br><span class="line">push [0]      ; 将1000：0处的字压入栈中</span><br><span class="line">pop [2]       ; 出栈，出栈的数据送入1000：2处</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H </span><br><span class="line">mov ss,ax      ; 设置栈的段地址，SS=1000H，不能直接向段寄存器SS中送入数据，所以用ax中转。</span><br><span class="line">mov sp,0010H   ; 设置栈顶的偏移地址，因栈为空，所以sp=0010H。</span><br><span class="line"></span><br><span class="line">push ax </span><br><span class="line">push bx </span><br><span class="line">push ds</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，</li>
<li>与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS：SP指出的。</li>
<li>同时，push和pop指令还要改变SP中的内容。</li>
</ul>
</blockquote>
<h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><ul>
<li>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N（N &lt;= 64KB）的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个<code>栈段</code>。</li>
<li>比如，我们将10010H~1001FH这段长度为16字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为个栈段，段地址为1001H，大小为16字节。</li>
<li>从栈操作指令所完成的功能的角度上来看，push、pop等指令在执行的时候只修改SP，所以栈顶的变化范围是0~FFFFH，从栈空时候的SP=0，一直压栈，直到栈满时SP=0；<strong>如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容</strong>。所以一个栈段的容量最大为64KB。</li>
</ul>
<h2 id="段的综述"><a href="#段的综述" class="headerlink" title="段的综述"></a>段的综述</h2><ul>
<li>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。<ul>
<li>我们可以用一个段存放数据，将它定义为“数据段”；</li>
<li>我们可以用一个段存放代码，将它定义为“代码段”；</li>
<li>我们可以用一个段当作栈，将它定义为“栈段”。</li>
</ul>
</li>
<li>我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：<ul>
<li>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问；</li>
<li>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；</li>
<li>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。</li>
</ul>
</li>
<li>可见，不管我们如何安排，<ul>
<li>CPU将内存中的某段内容当作代码，是因为CS：IP指向了那里；</li>
<li>CPU将内存中的某段内存当作栈，是因为SS：SP指向了那里。</li>
</ul>
</li>
</ul>
<p> 比如我们将10000H~1001FH安排为代码段，并在里面存储如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0020H  ; 初始化栈顶</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax    ; 设置数据段段地址</span><br><span class="line">mov ax, [0]</span><br><span class="line">add ax, [2] </span><br><span class="line">mov bx, [4] </span><br><span class="line">add bx, [6] </span><br><span class="line">push ax </span><br><span class="line">push bx </span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br></pre></td></tr></table></figure>

<ul>
<li>设置CS=1000H，IP=0，这段代码将得到执行。可以看到，在这段代码中，我们又将10000H<del>1001FH安排为栈段和数据段。10000H</del>1001FH这段内存，既是代码段，又是栈段和数据段。</li>
<li>一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即CS、IP，SS、SP，DS的指向。</li>
</ul>
<blockquote>
<p>window10使用debug：</p>
<ol>
<li><p>首先下载debug和DOSbox。</p>
</li>
<li><p>debug.exe 文件所在的磁盘（如 D 盘，完整的路径为 D:\masm\debug）做一次 mount（挂载）操作，比如我们将其挂载到 DOSbox 的 C 盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Z:\&gt; mount c d:\</span><br><span class="line">Z:\&gt; c:\</span><br><span class="line">C:\&gt; <span class="built_in">cd</span> masm\debug</span><br><span class="line">C:\MASM\DEBUG&gt; </span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h2 id="8086所有的寄存器"><a href="#8086所有的寄存器" class="headerlink" title="8086所有的寄存器"></a>8086所有的寄存器</h2><ul>
<li>AX（accumulator）：累加寄存器</li>
<li>BX（base）：基址寄存器</li>
<li>CX（count）：计数寄存器</li>
<li>DX（data）：数据寄存器</li>
<li>SP（Stack Pointer）：堆栈指针寄存器</li>
<li>BP（Base Pointer）：基址指针寄存器</li>
<li>SI（Source Index）：源变址寄存器</li>
<li>DI（Destination Index）：目的变址寄存器</li>
<li>IP（Instruction Pointer）：指令指针寄存器</li>
<li>CS（Code Segment）代码段寄存器</li>
<li>DS（Data Segment）：数据段寄存器</li>
<li>SS（Stack Segment）：堆栈段寄存器</li>
<li>ES（Extra Segment）：附加段寄存</li>
<li>FLAG（FLAG）：标志寄存器</li>
</ul>
<h1 id="第四章-第一个程序"><a href="#第四章-第一个程序" class="headerlink" title="第四章 第一个程序"></a>第四章 第一个程序</h1><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>在汇编语言源程序中，包含两种指令，一种是<code>汇编指令</code>，一种是<code>伪指令</code>。</p>
<ul>
<li><code>汇编指令</code>有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。</li>
<li><code>伪指令</code>没有对应的机器码的指令，最终不被CPU所执行，用于指导编译器进行编译工作。</li>
</ul>
<p><img src="/images/image-20211118140712671.png" alt="image-20211118140712671"></p>
<h3 id="segment…ends"><a href="#segment…ends" class="headerlink" title="segment…ends"></a>segment…ends</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; segment和ends的功能是定义一个段，</span><br><span class="line">; segment说明一个段开始，ends说明一个段结束。</span><br><span class="line">; 一个段必须有一个名称来标识</span><br><span class="line">XXX segment</span><br><span class="line">XXX ends</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>segment和ends的功能是定义一个段</strong>。</li>
<li>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。</li>
<li>我们在前面的课程中所讲解的段的概念，在汇编源程序中得到了应用与体现，一个源程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到了不同的段中。</li>
<li>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。</li>
</ul>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中如果碰到了伪指令end，就结束对源程序的编译。</p>
<h3 id="assume"><a href="#assume" class="headerlink" title="assume"></a>assume</h3><ul>
<li>这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。</li>
<li>通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</li>
<li>assume并不是一条非要深入理解不可的伪指令，以后我们编程时，记着<strong>用assume将有特定用途的段和相关的段寄存器关联起来</strong>即可。</li>
</ul>
<blockquote>
<p>简单来说：assume的作用是<strong>关联段名与段寄存器</strong>，让编译器知道在代码段中使用的变量来自于哪个段，从而可以利用段寄存器寻址。而将段地址装入段寄存器的任务仍然是由用户手动完成的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; 用codesg segment... codesg ends定义了一个名为codseg的段，在这个段中存放代码，所以这个段是一个代码段。</span><br><span class="line">; 在程序的开头，用assumecs：codesg将用作代码段的段codesg和CPU中的段寄存器cs联系起来。</span><br><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">	mov ax,0123H</span><br><span class="line">	mov bx,0456H</span><br><span class="line">	add ax,bx</span><br><span class="line">	add ax,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00H</span><br><span class="line">	int 21H</span><br><span class="line">	</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><ul>
<li>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如“codesg”。</li>
<li>一个标号指代了一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序<strong>处理为一个段的段地址</strong>。</li>
</ul>
<h2 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h2><ul>
<li>一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为：<code>程序返回</code>。</li>
<li>那么，如何返回呢？应该在程序的末尾添加返回的程序段。</li>
</ul>
<p>上面代码中的就是用于程序返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>



<h3 id="与结束相关的概念"><a href="#与结束相关的概念" class="headerlink" title="与结束相关的概念"></a>与结束相关的概念</h3><table>
<thead>
<tr>
<th>指令</th>
<th>目 的</th>
<th>指令性质</th>
<th>指令执行者</th>
</tr>
</thead>
<tbody><tr>
<td>段名 ends</td>
<td>通知编译器一个<strong>段结束</strong></td>
<td>伪指令</td>
<td>编译时,由编译器执行</td>
</tr>
<tr>
<td>end</td>
<td>通知编译器<strong>程序结束</strong></td>
<td>伪指令</td>
<td>编译时,由编译器执行</td>
</tr>
<tr>
<td>mov ax,4c00H int21H</td>
<td><strong>程序返回</strong></td>
<td>汇编指令</td>
<td>执行时,由CPU执行</td>
</tr>
</tbody></table>
<h2 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h2><h3 id="四件套"><a href="#四件套" class="headerlink" title="四件套"></a>四件套</h3><ul>
<li><code>EDIT.COM</code>：编辑器</li>
<li><code>LINK.EXE</code>：链接器</li>
<li><code>MASM.EXE</code>：编译器</li>
<li><code>DEBUG.EXE</code>：调试工具</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p><img src="/images/image-20211124145334420.png" alt="image-20211124145334420"></p>
<ul>
<li><code>.asm</code>：待编译的文件。</li>
<li><code>1.obj</code>：因为我们已经输入了源程序文件名为1.asm，则编译程序默认要输出的目标文件名为1.obj。</li>
<li><code>nul.lst</code>：列表文件的名称，这个文件是编译器将源程序编译为目标文件的过程中产生的中间结果。如果要让编译器不生成这个文件，直接按Enter键即可。</li>
<li><code>nul.crf</code>：交叉引用文件的名称，这个文件同列表文件一样，是编译器将源程序编译为目标文件过程中产生的中间结果。如果让编译器不生成这个文件，直接按Enter键即可。</li>
</ul>
<blockquote>
<ul>
<li>在编译的过程中，我们提供了一个输入，即源程序文件。</li>
<li>最多可以得到3个输出：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf），</li>
<li>这3个输出文件中，目标文件是我们最终要得到的结果，而另外两个只是中间结果，可以让编译器忽略对它们的生成。</li>
</ul>
</blockquote>
<ul>
<li>在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。</li>
<li>我们已经对<code>c:\l.asm</code>进行编译得到<code>c:\masm\l.obj</code>，现在再将<code>c:\masm\1.obj</code>连接为<code>c:\masm\l.exe</code>。</li>
</ul>
<p><img src="/images/image-20211124150212608.png" alt="image-20211124150212608"></p>
<ul>
<li><code>.obj</code>：待链接的目标文件名。</li>
<li><code>1.exe</code>：生成的可执行文件的名称，可执行文件是我们对一个程序进行连接要得到的最终结果。</li>
<li><code>nul.map</code>：映像文件的名称，这个文件是连接程序将目标文件连接为可执行文件过程中产生的中间结果，如果希望连接程序不生成这个文件，直接按Enter键即可。</li>
<li><code>.lib</code>：库文件的名称。库文件里面包含了一些可以调用的子程序，如果程序中调用了某一个库文件中的子程序，就需要在连接的时候，将这个库文件和目标文件连接到一起，生成可执行文件。但是现在程序中没有调用任何子程序，所以这里忽略库文件名的输入，直接按Enter键即可。</li>
</ul>
<h3 id="链接的作用"><a href="#链接的作用" class="headerlink" title="链接的作用"></a>链接的作用</h3><ul>
<li>当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；</li>
<li>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；</li>
<li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li>
</ul>
<h3 id="简化编译链接"><a href="#简化编译链接" class="headerlink" title="简化编译链接"></a>简化编译链接</h3><p>通过在最后添加分号，自动忽略生成中间文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masm c:\hello;</span><br><span class="line">link hello;</span><br></pre></td></tr></table></figure>



<h3 id="汇编程序从写出到执行的过程"><a href="#汇编程序从写出到执行的过程" class="headerlink" title="汇编程序从写出到执行的过程"></a>汇编程序从写出到执行的过程</h3><blockquote>
<p>操作系统的外壳：</p>
<p>如果用户要执行一个程序，则输入该程序的可执行文件的名称，CMD首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS：IP指向程序的入口。此后，CMD暂停运行，CPU运行程序。程序运行结束后，返回到CMD中，CMD再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。</p>
</blockquote>
<ol>
<li>编程（Edit）</li>
<li>hello.asm</li>
<li>编译（masm）</li>
<li>hello.obj</li>
<li>链接（link）</li>
<li>hello.exe</li>
<li>加载（command）</li>
<li>内存中的程序</li>
<li>运行（CPU）</li>
</ol>
<h2 id="程序执行过程中的跟踪"><a href="#程序执行过程中的跟踪" class="headerlink" title="程序执行过程中的跟踪"></a>程序执行过程中的跟踪</h2><h3 id="EXE文件中程序的加载过程"><a href="#EXE文件中程序的加载过程" class="headerlink" title="EXE文件中程序的加载过程"></a>EXE文件中程序的加载过程</h3><p><img src="/images/image-20211124180636387.png" alt="image-20211124180636387"></p>
<p>从图中我们知道以下的信息。</p>
<ul>
<li>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds：0；</li>
<li>这个内存区的前256个字节中存放的是PSP，DOS<strong>用来和程序进行通信</strong>。从256字节处向后的空间存放的是程序。</li>
</ul>
<blockquote>
<p>从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA×16+0。因为PSP占256（100H）字节，所以程序的物理地址是：SA×16+0+256=SA×16+16×16+0=(SA+16)×16+0 。可用段地址和偏移地址表示为：SA+10H：0。</p>
<p>简单来说：<strong>CS = DS + 10H</strong>。</p>
</blockquote>
<h3 id="使用debug进行调试"><a href="#使用debug进行调试" class="headerlink" title="使用debug进行调试"></a>使用debug进行调试</h3><p>Debug可以将程序加载入内存，设置 CS：IP指向程序的入口，但Debug并不放弃对 CPU的控制，这样我们就可以使用Debug的相关命令来单步执行程序，查看每一条指令的执行结果。</p>
<p><img src="/images/image-20211124160425865.png" alt="image-20211124160425865"></p>
<p>Debug将程序从可执行文件加载入内存后，cx中存放的是程序的长度。1.exe中程序的机器码共有15个字节。则1.exe加载后，cx中的内容为000FH。</p>
<p>CS=12AE，IP0000，CS：IP指向程序的第一条指令。可以看到，从12AE：0000~12AE：000E都是程序的机器码。</p>
<p><img src="/images/image-20211124181512289.png" alt="image-20211124181512289"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; 1.asm</span><br><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">  mov ax,0123h</span><br><span class="line">  mov bx,0456h</span><br><span class="line">  add ax,bx</span><br><span class="line">  add ax,ax</span><br><span class="line"></span><br><span class="line">  mov ax,4c00h</span><br><span class="line">  int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>现在，我们可以开始跟踪了，<strong>用T命令单步执行程序中的每一条指令，并观察每条指令的执行结果</strong>。等走到最后一条指令<code>int 21h</code>，需要执行P命令。</p>
<p><img src="/images/image-20211124181758904.png" alt="image-20211124181758904"></p>
<h1 id="第五章-BX-和loop指令"><a href="#第五章-BX-和loop指令" class="headerlink" title="第五章 [BX]和loop指令"></a>第五章 [BX]和loop指令</h1><h2 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h2><p>要完整地描述一个内存单元，需要两种信息：</p>
<ul>
<li>内存单元的地址；</li>
<li>内存单元的长度（类型）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为0，段地址在ds中。</span><br><span class="line">mov ax,[0]</span><br><span class="line">; 将一个内存单元的内容送入al，这个内存单元的长度为1字节（字节单元），存放一个字节，偏移地址为0，段地址在ds中。</span><br><span class="line">mov al,[0]</span><br></pre></td></tr></table></figure>

<p>用<code>[0]</code>表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; [bx]同样也表示一个内存单元，它的偏移地址在bx中</span><br><span class="line">; 将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址在bx中，段地址在ds中。</span><br><span class="line">mov ax, [bx]</span><br><span class="line"></span><br><span class="line">; 将一个内存单元的内容送入al，这个内存单元的长度为1字节（字节单元），存放一个字节，偏移地址在bx中，段地址在ds中。</span><br><span class="line">mov al,[bx]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单来讲就是：将ds整个值作为段地址，将bx整个值作为偏移地址。</p>
</blockquote>
<h2 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h2><p>loop指令的格式是：loop标号，CPU执行loop指令的时候，要进行两步操作 </p>
<ul>
<li>(cx)=(cx)-l;</li>
<li>判断 cX中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li>
</ul>
<blockquote>
<p>简单来说，通常我们用loop指令来实现循环功能，cx中存放循环次数。</p>
</blockquote>
<p>计算2^5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	mov ax,2</span><br><span class="line">	mov ax,ax</span><br><span class="line">	mov ax,ax</span><br><span class="line">	mov ax,ax</span><br><span class="line">	mov ax,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>使用loop：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	 mov ax,2</span><br><span class="line">	 </span><br><span class="line">	 mov cx,4</span><br><span class="line">s: add ax,ax</span><br><span class="line">   loop s</span><br><span class="line">	</span><br><span class="line">	 mov ax,4c00h</span><br><span class="line">	 int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>所以，计算123*236。其实就是123加236次，或者236加123次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	 mov ax,0</span><br><span class="line">	 </span><br><span class="line">	 mov cx,236</span><br><span class="line">s: add ax,123</span><br><span class="line">   loop s</span><br><span class="line">	</span><br><span class="line">	 mov ax,4c00h</span><br><span class="line">	 int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="在Debug中跟踪用loop指令"><a href="#在Debug中跟踪用loop指令" class="headerlink" title="在Debug中跟踪用loop指令"></a>在Debug中跟踪用loop指令</h2><p>计算<code>ffff:0006</code>单元中的数乘以3，结果存储在dx中。</p>
<p>难点在于：<code>ffff:0006</code>单元是一个字节单元，8位，ax是一个16位寄存器，数据的长度不一样，如何赋值？</p>
<p>解决方法：用一个16位寄存器来做中介。将内存单元中的 8位数据赋值到一个16位寄存器ax中，再将ax中的数据加到dx上，从而使两个运算对象的类型匹配并且结果不会超界。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">		; 在汇编源程序中，数据不能以字母开头，所以要在前面加0。</span><br><span class="line">    mov ax,0ffffh</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,6        ; 以上，设置ds:bx指向ffff:6</span><br><span class="line"></span><br><span class="line">    mov al,[bx]</span><br><span class="line">    mov ah,0        ; 以上，设置(al)=((ds*16)+(bx)),(ah)=0 </span><br><span class="line"></span><br><span class="line">    mov dx,0        ; 累加寄存器清0</span><br><span class="line">    mov cx,3        ; 循环3次</span><br><span class="line">  s:add dx,ax</span><br><span class="line">    loop s          ; 以上累加计算(ax)*3</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h         ; 程序返回</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>使用debug：</p>
<p><img src="/images/image-20211125112501949.png" alt="image-20211125112501949"></p>
<p><img src="/images/image-20211125112515772.png" alt="image-20211125112515772"></p>
<p>可以看到，从0B3D:0000~0B3D:001A是我们的程序，0B3D:0014处是源程序中的指令loops，只是此处<strong>loops中的标号s已经变为一个地址0012h。如果在执行“loop 0012”时，cx减1后不为0，“loop 0012”就把IP设置为0012h，从而使CS：IP指向0B3D：0012处的add dx，ax，实现转跳</strong>。</p>
<p>断点：</p>
<ul>
<li>如果想从CS：0012处开始跟踪，可以使用g命令，<code>g 0012</code>表示执行程序到当前代码段（段地址在CS中）的0012h处。也就是说“g0012”将使Debug从当前的CS:IP指向的指令执行，一直到(IP)=0012h为止。</li>
<li>如果想直接跳过loop，还可以使用<code>p命令</code>，<strong>Debug就会自动重复执行循环中的指令，直到(cx)=0为止</strong>。</li>
</ul>
<p><img src="/images/image-20211125113358546.png" alt="image-20211125113358546"></p>
<p><img src="/images/image-20211125113410435.png" alt="image-20211125113410435"></p>
<h2 id="Debug和汇编编译器masm对-idata-的不同处理"><a href="#Debug和汇编编译器masm对-idata-的不同处理" class="headerlink" title="Debug和汇编编译器masm对[idata]的不同处理"></a>Debug和汇编编译器masm对<code>[idata]</code>的不同处理</h2><p>我们在Debug中写过类似的指令：<code>mov ax, [0]</code>，表示将ds：0处的数据送入ax中。但是在汇编源程序中，指令<code>mov ax, [0]</code>被编译器当作指令<code>mov ax，0</code>处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">  mov ax,2000h</span><br><span class="line">  mov ds,ax</span><br><span class="line">  mov al,[0]</span><br><span class="line">  mov bl,[1]</span><br><span class="line">  mov cl,[2]</span><br><span class="line">  mov dl,[3]</span><br><span class="line"></span><br><span class="line">  mov ax,4c00h</span><br><span class="line">  int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211125115358012.png" alt="image-20211125115358012"></p>
<p><img src="/images/image-20211125115409997.png" alt="image-20211125115409997"></p>
<p>从图中我们可以明显地看出，Debug和编译器masm对形如<code>mov ax，[0]</code>这类指令在解释上的不同。我们在Debug中和源程序中写入同样形式的指令，但Debug和编译器对这些指令中的<code>[idata]</code>却有不同的解释。</p>
<ul>
<li>Debug将它解释为<code>[idata]</code>是一个内存单元，<code>[idata]</code>是内存单元的偏移地址；</li>
<li>而编译器将<code>[idata]</code>解释为idata。</li>
</ul>
<p>那么我们如何在源程序中实现将内存2000:0、2000:1、2000:2、2000:3单元中的数据送入al、bl、cl、dl中呢？</p>
<p>方法一：可将偏移地址送入bx寄存器中，用[bx]的方式来访问内存单元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000h</span><br><span class="line">mov ds,ax     ; 段地址2000h送入ds</span><br><span class="line">mov bx,0      ; 偏移地址0送入bx</span><br><span class="line">mov al,[bx]   ; ds:bx单元中的数据送入al</span><br></pre></td></tr></table></figure>

<p>方法二：显式地给出段地址所在的段寄存器。这被称为<code>段前缀</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov al,ds:[0]</span><br></pre></td></tr></table></figure>



<p>练习：计算<code>ffff:0 ~ ffff:b</code>单元中的数据的和，结果存储在dx中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov dx,0</span><br><span class="line">	</span><br><span class="line">	mov cx,12</span><br><span class="line">s:mov al,[bx]</span><br><span class="line">	mov ah,0</span><br><span class="line">	add dx,ax</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h1 id="第六章-包含多个段的程序"><a href="#第六章-包含多个段的程序" class="headerlink" title="第六章 包含多个段的程序"></a>第六章 包含多个段的程序</h1><p>如果程序需要用其他空间来存放数据，使用哪里呢？程序取得所需空间的方法有两种，</p>
<ul>
<li>在加载程序的时候为程序分配，</li>
<li>程序在执行的过程中向系统申请。</li>
</ul>
<p>现在讨论第一种，加载程序的时候为程序分配空间。</p>
<h2 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h2><p>考虑这样一个问题，编程计算以下8个数据的和，结果存在ax寄存器中<br>0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h</p>
<ul>
<li>首先要将这些数据存储在一组地址连续的内存单元中。如何将这些数据存储在一组地址连续的内存单元中呢？我们可以用指令一个一个地将它们送入地址连续的内存单元中，可是这样又有一个问题，到哪里去找这段内存空间呢？</li>
<li>从规范的角度来讲，我们是不能自己随便决定哪段空间可以使用的，应该让系统来为我们分配。我们<strong>可以在程序中，定义我们希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写到可执行文件中</strong>。当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。与此同时，我们要处理的数据也就自然而然地获得了存储空间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dw</code>：即“define word”。含义是<strong>定义字型数据</strong>。在这里，使用dw定义了8个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为16个字节。</li>
<li>程序中的指令就要对这8个数据进行累加，可这8个数据在哪里呢？由于它们在代码段中，程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。它们的偏移地址是多少呢？<strong>因为因为IP默认为0，且用dw定义的数据处于代码段的最开始，所以偏移地址为0</strong>，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是CS:0、CS:2、CS:4、CS:6、CS:8、CS:A、CS:C、CS:E</li>
</ul>
<blockquote>
<p>简单来说：程序加载到内存中后，所占内存空间的<strong>前16个单元存放在源程序中用“dw”定义的数据</strong>，后面的单元存放源程序中汇编指令所对应的机器指令。</p>
</blockquote>
<p>因为程序的入口处不是我们所希望执行的指令。如何让这个程序在编译、连接后可以在系统中直接运行呢？怎样执行程序中的指令呢？用Debug加载后，可以将IP设置为10h，从而使CS:IP指向程序中的第一条指令。然后再用t命令、p命令，或者是g命令执行。</p>
<p>为了解决上述这么麻烦的操作，我们可以在源程序中指明程序的入口所在，具体做法如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">	</span><br><span class="line">	start:	mov bx,0</span><br><span class="line">					mov ax,0</span><br><span class="line">					mov cx,8</span><br><span class="line">	s:			add ax,cs:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s</span><br><span class="line">	</span><br><span class="line">					mov ax,4c00h</span><br><span class="line">					int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单来说，<strong>若要CPU从何处开始执行程序，只要在源程序中用“end标号”指明就可以了</strong>。</p>
<p>有了这种方法，就可以这样来安排程序的框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	数据...</span><br><span class="line">start:</span><br><span class="line">	代码...</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h2><p>完成下面的程序，利用栈，将程序中定义的数据逆序存放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; 将这段空间当作栈使用</span><br><span class="line">	</span><br><span class="line">	start:	mov ax,cs</span><br><span class="line">					mov ss,ax</span><br><span class="line">					mov sp,30h ; 将设置栈顶ss:sp指向cs：30</span><br><span class="line"></span><br><span class="line">					mov bx,0</span><br><span class="line">					mov cx,8</span><br><span class="line">	s:			push cs:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s</span><br><span class="line"></span><br><span class="line">					mov bx,0</span><br><span class="line">					mov cx,8</span><br><span class="line">	s0:			pop cs:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s0</span><br><span class="line">	</span><br><span class="line">					mov ax,4c00h</span><br><span class="line">					int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; 将这段空间当作栈使用</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">	start:	mov ax,stacksg</span><br><span class="line">					mov ss,ax</span><br><span class="line">					mov sp,20h ; 将设置栈顶ss:sp指向stack: 20h</span><br><span class="line"></span><br><span class="line">					mov ax,datasg</span><br><span class="line">					mov ds,ax  ; ds指向datasg段</span><br><span class="line"></span><br><span class="line">					mov bx,0   ; ds：bx指向data段中的第一个单元</span><br><span class="line">					mov cx,8</span><br><span class="line">	s:			push ds:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s</span><br><span class="line"></span><br><span class="line">					mov bx,0</span><br><span class="line">					mov cx,8</span><br><span class="line">	s0:			pop ds:[bx]</span><br><span class="line">					add bx,2</span><br><span class="line">					loop s0</span><br><span class="line">	</span><br><span class="line">					mov ax,4c00h</span><br><span class="line">					int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li><p>现在，程序中有多个段了，如何访问段中的数据呢？当然要通过地址，而地址是分为两部分的，即段地址和偏移地址。如何指明要访问的数据的段地址呢？在程序中，<strong>段名就相当于一个标号，它代表了段地址</strong>。所以指令<code>mov ax,datasg</code>的含义就是将名称为“datasg”的段的段地址送入ax。</p>
</li>
<li><p>一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。程序中“datasg”段中的数据“0abch”的地址就是：datasg:6。要将它送入bx中，就要用如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure>

<p>不能用下面的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 8086CPU不允许将一个数值直接送入段寄存器中</span><br><span class="line">mov ds,datasg</span><br><span class="line">mov bx,ds:[6]</span><br></pre></td></tr></table></figure></li>
<li><p>注意，所谓的“代码段”、“数据段”、“栈段”完全是我们的安排。</p>
</li>
</ul>
<p>CPU执行流程：</p>
<p>若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是CPU要执行的内容。CPU如何知道去执行它们？</p>
<ol>
<li><p>我们在源程序的最后用“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，</p>
</li>
<li><p>可执行文件中的程序被加载入内存后，CPU的CS：IP被设置指向这个入口，从而开始执行程序中的第一条指令。标号“start”在“code”段中，这样CPU就将code段中的内容当作指令来执行了。</p>
</li>
<li><p>我们在code段中，使用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">moy sp，20h</span><br></pre></td></tr></table></figure>

<p>设置ss指向stacksg，设置ss:sp指向stack:20，<strong>CPU执行这些指令后，将把stacksg段当做栈空间来用</strong>。</p>
</li>
</ol>
<blockquote>
<p>总之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。</p>
</blockquote>
<p>练习示例</p>
<p>写code段中的代码，将a段和b段中的数据依次相加，将结果存到c段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">    db 1, 2, 3, 4, 5, 6, 7, 8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">    db 1, 2, 3, 4, 5, 6, 7, 8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">    db 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line">  s:</span><br><span class="line">    mov ax,0</span><br><span class="line">  </span><br><span class="line">    mov dx,a</span><br><span class="line">    mov ds,dx</span><br><span class="line">    add ax,[bx]</span><br><span class="line">  </span><br><span class="line">    mov dx,b</span><br><span class="line">    mov ds,dx</span><br><span class="line">    add ax,[bx]</span><br><span class="line">  </span><br><span class="line">    mov dx,c</span><br><span class="line">    mov ds,dx</span><br><span class="line">    mov [bx],ax</span><br><span class="line">  </span><br><span class="line">    add bx,2</span><br><span class="line">  loop s</span><br><span class="line">  </span><br><span class="line">  mov ax, 4c00h</span><br><span class="line">  int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>编写code段中的代码，用push指令将a段中的前8个字型数据，逆序存储到b段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">    dw 1, 2, 3, 4, 5, 6, 7, 8, 9, 0ah, 0bh, 0ch, 0dh, 0eh, 0fh, 0ffh</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">    dw 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  </span><br><span class="line">  mov ax,b</span><br><span class="line">  mov ss,ax</span><br><span class="line">  mov sp,10h</span><br><span class="line"></span><br><span class="line">  mov ax,a</span><br><span class="line">  mov ds,ax</span><br><span class="line"></span><br><span class="line">  mov bx,0</span><br><span class="line">  mov cx,8</span><br><span class="line">  s:</span><br><span class="line">    push [bx]</span><br><span class="line">    add bx,2</span><br><span class="line">  loop s</span><br><span class="line"></span><br><span class="line">  mov ax, 4c00h</span><br><span class="line">  int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h1 id="第七章-更灵活的定位内存地址的方法"><a href="#第七章-更灵活的定位内存地址的方法" class="headerlink" title="第七章 更灵活的定位内存地址的方法"></a>第七章 更灵活的定位内存地址的方法</h1><h2 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></table></figure>

<p>执行后al=00100011B。</p>
<p>通过该指令可将操作对象的相应位设为0，其他位不变：</p>
<ul>
<li>将al的第6位设为0的指令是：and al 10111111B</li>
<li>将al的第7位设为0的指令是：and al 01111111B</li>
<li>将al的第0位设为0的指令是：and al 11111110B</li>
</ul>
<p>在文本编辑过程中，我们按一下键盘的a键，就会在屏幕上看到“a”。这是怎样一个过程呢？</p>
<ol>
<li>我们按下键盘的a键，这个按键的信息被送入计算机，计算机用ASCII码的规则对其进行编码，将其转化为61H存储在内存的指定空间中；</li>
<li>文本编辑软件从内存中取出61H，将其送到显卡上的显存中；</li>
<li>工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，61H被当作字符“a”，显卡驱动显示器，将字符“a”的图像画在屏幕上。</li>
</ol>
<blockquote>
<p>可以看到，显卡在处理文本信息的时候，是按照ASCII码的规则进行的。这也就是说，如果我们要想在显示器上看到“a”，就要给显卡提供“a”的ASCII码，61H。如何提供？当然是写入显存中。</p>
</blockquote>
<h2 id="以字符形式给出的数据"><a href="#以字符形式给出的数据" class="headerlink" title="以字符形式给出的数据"></a>以字符形式给出的数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;unIX&#x27;</span><br><span class="line">    db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: 	mov al,&#x27;a&#x27;</span><br><span class="line">				mov bl,&#x27;b&#x27;</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li><code>db</code>即<code>define byte</code>。</li>
<li><code>db &#39;unIX&#39;</code>相当于<code>db 75H,6EH,49H,58H</code>。</li>
<li><code>mov al &#39;a&#39;</code>相当于<code>mov al,61H</code>。</li>
</ul>
<p>使用Debug就可以看到data段的内容头部就是unIXfoRK</p>
<p><img src="/images/image-20211128094047600.png" alt="image-20211128094047600"></p>
<blockquote>
<p>先用r命令分析一下data段的地址，因“ds=0B2D”，去除10H的PSP，所以程序从0B3DH段开始，data段又是程序中的第一个段，它就在程序的起始处，所以它的段地址为OB3DH</p>
</blockquote>
<h2 id="如何进行大小写转换"><a href="#如何进行大小写转换" class="headerlink" title="如何进行大小写转换"></a>如何进行大小写转换</h2><p>众所周知，<code>小写字母ASCII值 = 大写字母ASCII值 + 20H</code>。</p>
<blockquote>
<p>一个字母，不管它原来是大写还是小写，将它的第5位设置为0，它就必将变为大写字母；将它的第5位设置为1，它就必将变为小写字母。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &#x27;BaSiC&#x27;</span><br><span class="line">    db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0 ; 设置（bx）=0，ds：bx指向&#x27;BaSic&#x27;的第一个字母</span><br><span class="line">        mov cx,5</span><br><span class="line">s:      mov al,[bx]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx],al</span><br><span class="line">        inc bx</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov bx,5 ; 设置（bx）=5，ds:bx指向’iNfOrMaTiOn&#x27;的第一个字母</span><br><span class="line">        mov cx,11</span><br><span class="line">s0:     mov al,[bx]</span><br><span class="line">        or al,000100000B</span><br><span class="line">        mov [bx],al</span><br><span class="line">        inc bx</span><br><span class="line">        loop s0</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h2><p>在前面，我们用<code>[bx]</code>的方式来指明一个内存单元，还可以用一种更为灵活的方式来指明内存单元：<code>[bx+idata]</code>表示一个内存单元，它的偏移地址为<code>(bx) + idata(bx中的数值加上idata)</code>。</p>
<ul>
<li><p><code>mov ax,[bx+200]</code>：将一个内存单元的内存送入ax，这个内存单元大的长度为2个字节(字单元)，存放一个字，偏移地址为bx中的数据加上200，段地址在ds。</p>
<p>数学化的描述为<code>(ax)=((ds)*16+(bx)+200)</code></p>
</li>
<li><p>该指令也可以写成如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[200+bx]</span><br><span class="line">mov ax,200[bx]</span><br><span class="line">mov ax,[bx].200</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以上述字母大小写转换的代码可以改成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &#x27;BaSiC&#x27;</span><br><span class="line">    db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: 	mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,5</span><br><span class="line">s:      mov al,[bx]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx],al</span><br><span class="line">        mov al,[5+bx]</span><br><span class="line">        or al,000100000B</span><br><span class="line">        mov [5+bx],al</span><br><span class="line"></span><br><span class="line">        inc bx</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，上面的代码和原始代码不是等价的，他只能修改<code>iNfOrMaTiOn</code>的前五位。</p>
</blockquote>
<h2 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h2><p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。</p>
<p>用si和di实现将字符串<code>welcome to masm!</code>复制到它后面的数据区中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;welcome to masm!&#x27;</span><br><span class="line">	db &#x27;................&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start: 	mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        mov di,16</span><br><span class="line"></span><br><span class="line">        mov cx,8</span><br><span class="line">s:      mov ax,[si]</span><br><span class="line">        mov [di],ax</span><br><span class="line">        add si,2</span><br><span class="line">        add di,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="bx-si-和-bx-di"><a href="#bx-si-和-bx-di" class="headerlink" title="[bx+si]和[bx+di]"></a>[bx+si]和[bx+di]</h2><ul>
<li><code>[bx+si]</code>表示一个内存单元，他的偏移地址为(bx)+(si)，即bx中的数字加上si中的数值。</li>
<li><code>mov ax，[bx+si]</code>数学化的描述为<code>(ax) = ((ds)*16 + (bx)+(si))</code></li>
<li>该指令可以写成如下：<code>mov ax, [bx][si]</code></li>
</ul>
<p>同理还有[bx+si+idata]：</p>
<ul>
<li><p><code>[bx+si+idata]</code>表示一个内存单元，他的偏移地址为(bx)+(si)+idata。</p>
</li>
<li><p><code>mov ax，[bx+si+idata]</code>数学化的描述为<code>(ax) = ((ds)*16 + (bx)+(si)+idata)</code></p>
</li>
<li><p>该指令可以写成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200+si]</span><br><span class="line">mov ax,[200+bx+si]</span><br><span class="line">mov ax,200[bx][si]</span><br><span class="line">mov ax,[bx].200[si]</span><br><span class="line">mov ax,[bx][si].200</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="不同的寻址方式的灵活应用"><a href="#不同的寻址方式的灵活应用" class="headerlink" title="不同的寻址方式的灵活应用"></a>不同的寻址方式的灵活应用</h2><p>定位内存地址的方法，称为<code>寻址方式</code>。</p>
<p>五种寻址方式：</p>
<ul>
<li>[idata]用一个常量来表示地址，可用于直接定位一个内存单元；</li>
<li>[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元</li>
<li>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；</li>
<li>[bx+si]用两个变量表示地址。</li>
<li>[bx+si+idata]用两个变量和一个常量表示地址。</li>
</ul>
<p>编程，将datasg段中每个单词的头一个字母改为大写字母。</p>
<p><img src="/images/image-20211128111720117.png" alt="image-20211128111720117"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assme cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;1. file         &#x27;</span><br><span class="line">	db &#x27;2. edit         &#x27;</span><br><span class="line">	db &#x27;3. search       &#x27;</span><br><span class="line">	db &#x27;4. view         &#x27;</span><br><span class="line">	db &#x27;5. options      &#x27;</span><br><span class="line">	db &#x27;6. help         &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,6</span><br><span class="line">s:      mov al,[bx+3]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+3],al</span><br><span class="line">        add bx,16</span><br><span class="line">        loop s</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>双层循环：</p>
<p>编程，将datasg段中每个单词改为大写字母。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assme cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;ibm         &#x27;</span><br><span class="line">	db &#x27;dec         &#x27;</span><br><span class="line">	db &#x27;doc         &#x27;</span><br><span class="line">	db &#x27;vax         &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,4</span><br><span class="line">        </span><br><span class="line">s0:			mov si,0</span><br><span class="line">				mov cx,3</span><br><span class="line">				</span><br><span class="line">s:			mov al,[bx+3]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">				loop s        </span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        loop s0</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>上面代码，有一个问题。在于cx的使用，我们进行二重循环，却只用了一个循环计数器，造成在进行内<br>层循环的时候，覆盖了外层循环的循环计数值。多用一个计数器又不可能，因为1oop指令默认cx为循环计数器。怎么办呢？</p>
<p>我们想到的办法就是在每次开始内层循环的时候，<strong>用寄存器dx将外层循环的cx中的数值临时保存起来</strong>，在执行外层循环的loop指令前，再恢复外层循环的cx数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,4</span><br><span class="line">        </span><br><span class="line">s0:			mov dx,cx  ; 将外层循环的cx值保存在dx中</span><br><span class="line">				mov si,0</span><br><span class="line">				mov cx,3   ; cx设置内层循环的次数</span><br><span class="line">				</span><br><span class="line">s:			mov al,[bx+si]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">				loop s        </span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        mov cx,dx  ; 用dx中存放的外层循环的计数值恢复cx</span><br><span class="line">        loop s0</span><br><span class="line">codesg ends</span><br></pre></td></tr></table></figure>



<p>但是问题又来了，寄存器的数量是有限的，对于复杂循环，可能面临没有寄存器可用的情况。这时就可以将其存储在内存中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assme cs:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;ibm         &#x27;</span><br><span class="line">	db &#x27;dec         &#x27;</span><br><span class="line">	db &#x27;doc         &#x27;</span><br><span class="line">	db &#x27;vax         &#x27;</span><br><span class="line">	dw 0     ; 定义一个字，用来暂存cx</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,4</span><br><span class="line">s0:			mov ds:[40H],cx  ; 将外层循环的cx值保存在datasg:40H单元中</span><br><span class="line">				mov si,0</span><br><span class="line">				mov cx,3         ; cx设置为内层循环的次数</span><br><span class="line">				</span><br><span class="line">s:			mov al,[bx+si]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">				loop s        </span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        mov cx,ds:[40H]  ; 用datasg:40H单元中的值回复cx</span><br><span class="line">        loop s0</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00H</span><br><span class="line">        int 21H</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>但是问题又来了，如果需要保存多个数据的时候，你必须要记住数据放到了哪个单元中，这样程序容易混乱。这时，我们就可以使用栈来保存数据。</p>
<blockquote>
<p>一般来说，在需要暂存数据的时候，我们都应该使用栈。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">assme cs:codesg,ds:datasg,ss:stasksg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;ibm         &#x27;</span><br><span class="line">	db &#x27;dec         &#x27;</span><br><span class="line">	db &#x27;doc         &#x27;</span><br><span class="line">	db &#x27;vax         &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment   ; 定义一个段，用来做栈段，容量为16个字节</span><br><span class="line">	dw 0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,stacksg</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line">        </span><br><span class="line">        mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov cx,4</span><br><span class="line">s0:			push cx          ; 将外层循环的cx值压栈</span><br><span class="line">				mov si,0</span><br><span class="line">				mov cx,3         ; cx设置为内层循环的次数</span><br><span class="line">				</span><br><span class="line">s:			mov al,[bx+si]</span><br><span class="line">        and al,11011111B</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">				loop s        </span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        pop cx            ; 从栈顶弹出原cx的值，恢复cx</span><br><span class="line">        loop s0</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00H</span><br><span class="line">        int 21H</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h1 id="第八章-数据处理的两个基本问题"><a href="#第八章-数据处理的两个基本问题" class="headerlink" title="第八章 数据处理的两个基本问题"></a>第八章 数据处理的两个基本问题</h1><p>计算机是进行数据处理、运算的机器，那么其中包含两个基本的问题：</p>
<ul>
<li>处理的数据在什么地方</li>
<li>要处理的数据有多长</li>
</ul>
<p>这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。本章我们就针对8086CPU对这两个基本问题进行讨论。</p>
<p>使用描述性的符号<code>reg</code>来表示一个寄存器，用<code>sreg</code>表示一个段寄存器。</p>
<ul>
<li>reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；</li>
<li>sreg的集合包括：ds、ss、cs、es</li>
</ul>
<h2 id="bx、si、di、bp"><a href="#bx、si、di、bp" class="headerlink" title="bx、si、di、bp"></a>bx、si、di、bp</h2><ul>
<li>在8086CPU中，只有这4个寄存器可以用在<code>[...]</code>中来进行内存单元的寻址。</li>
<li>这4个寄存器可以单个出现，或只能以4种组合出现：<ul>
<li>bx和si</li>
<li>bx和di</li>
<li>bp和si</li>
<li>bp和di</li>
</ul>
</li>
<li>只要在<code>[...]</code>中使用寄存器bp，且指令中没有显性地给出段地址，段地址就默认在ss中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+di]</span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+si]</span><br><span class="line">mov ax,[bp+di]</span><br><span class="line">mov ax,[bx+si+idata]</span><br><span class="line">mov ax,[bx+di+idata]</span><br><span class="line">mov ax,[bp+si+idata]</span><br><span class="line">mov ax,[bp+di+idata]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [bp]           ; 含义：（ax）=（（ss）*16 +（bp））</span><br><span class="line">mov ax, [bp+idata]     ; 含义：（ax）=（（ss）*16 +（bp) + idata）</span><br><span class="line">mov ax, [bp+si]        ; 含义：（ax）=（（ss）*16 +（bp) +（si））</span><br><span class="line">mov ax, [bp+si+idata]  ; 含义：（ax）=（（ss）*16 +（bp）+（si）+idata）</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>BP</code>(base pointer): </p>
<ul>
<li>基数指针寄存器，它的用途有点特殊，是和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到。</li>
<li>比如说，堆栈中压入了很多数据或者地址，你肯定想通过SP来访问这些数据或者地址，但SP是要指向栈顶的，是不能随便乱改的，这时候你就需要使用BP，把SP的值传递给BP，通过BP来寻找堆栈里数据或者地址。</li>
<li>简单来说，SP和BP一般与段寄存器SS联用，以确定栈寄存器中某一单元的地址，SP用以指示栈顶的偏移地址，而BP可作为堆栈区中的一个基地址，用以确定在堆栈中的操作数地址。</li>
<li>一般除了保存数据外，可以作为指针寄存器用于存储器寻址，此时它默认搭配的段寄存器是SS-堆栈段寄存器。</li>
<li>BP是16位的，再扩充16位就是EBP，用于32位编程环境的。一般高级语言的参数传递等等，转换为汇编后经常由BP/EBP来负责寻址处理。</li>
</ul>
</blockquote>
<h2 id="机器指令处理的数据在什么地方"><a href="#机器指令处理的数据在什么地方" class="headerlink" title="机器指令处理的数据在什么地方"></a>机器指令处理的数据在什么地方</h2><p>绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：<code>读取</code>、<code>写入</code>、<code>运算</code>。</p>
<p>在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：<code>CPU内部</code>、<code>内存</code>、<code>端口</code>。</p>
<table>
<thead>
<tr>
<th>机器码</th>
<th>汇编指令</th>
<th>指令执行前数据的位置</th>
</tr>
</thead>
<tbody><tr>
<td>8E1E0000</td>
<td>mov bx,[0]</td>
<td>内存，ds:0单元</td>
</tr>
<tr>
<td>89C3</td>
<td>mov bx,ax</td>
<td>CPU内部，ax寄存器</td>
</tr>
<tr>
<td>BB0100</td>
<td>mov bx,1</td>
<td>CPU内部，指令缓冲器</td>
</tr>
</tbody></table>
<h2 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h2><p>在汇编语言中如何表达数据的位置？汇编语言中用3个概念来表达数据的位置。</p>
<ul>
<li><p><code>立即数(idata)</code>：对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称为：立即数（idata），在汇编指令中直接给出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add bx,2000h</span><br><span class="line">or bx,0001000b</span><br><span class="line">mov al,&#x27;a&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><code>寄存器</code>：指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx</span><br><span class="line">mov ds,ax</span><br><span class="line">push bx</span><br><span class="line">mov ds:[0],bx</span><br><span class="line">push ds</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,ax</span><br></pre></td></tr></table></figure></li>
<li><p><code>段地址(SA)和偏移地址(EA)</code>：指令要处理的数据在内存中，在汇编指令中可用<code>[X]</code>的格式给出EA，SA在某个段寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0]</span><br><span class="line">mov ax,[di]</span><br><span class="line">mov ax,[bx+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bx+si+8]</span><br><span class="line"></span><br><span class="line">mov ax,[bp]</span><br><span class="line">mov ax,[bp+8]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bp+si+8]</span><br><span class="line"></span><br><span class="line">mov ax,ds:[bp]</span><br><span class="line">mov ax,es:[bx]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为<code>寻址方式</code>。</p>
<p><img src="/images/image-20211128144024797.png" alt="image-20211128144024797"></p>
<h2 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h2><p>8086CPU的指令，可以处理两种尺寸的数据，<code>byte</code>和<code>word</code>。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。</p>
<ul>
<li><p>通过寄存器名指明要处理的数据的尺寸。(通过寄存器宽度来丈量)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; 字操作</span><br><span class="line">mov ax,1</span><br><span class="line">mov bx,ds:[0]</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">inc ax</span><br><span class="line">add ax,1000</span><br><span class="line"></span><br><span class="line">; 字节操作</span><br><span class="line">mov al,1</span><br><span class="line">mov al,bl</span><br><span class="line">mov al,as:[0]</span><br><span class="line">mov ds:[0],al</span><br><span class="line">inc al</span><br><span class="line">add al,100</span><br></pre></td></tr></table></figure></li>
<li><p>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元</span><br><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line">add word ptr [bx],2</span><br><span class="line"></span><br><span class="line">; 下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元</span><br><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">inc byte ptr [bx]</span><br><span class="line">inc byte ptr ds:[0]</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure></li>
<li><p>其他方法：有些指令默认了访问的是字单元还是字节单元，比如，<code>push[1000H]</code>就不用指明访问的是字单元还是字节单元，因为push指令只进行字操作。</p>
</li>
</ul>
<h2 id="汇编和C语言的转换"><a href="#汇编和C语言的转换" class="headerlink" title="汇编和C语言的转换"></a>汇编和C语言的转换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> cn[<span class="number">3</span>];    <span class="comment">// 公司名称</span></span><br><span class="line">  <span class="keyword">char</span> hn[<span class="number">9</span>];    <span class="comment">// 总裁姓名</span></span><br><span class="line">  <span class="keyword">int</span> pm;        <span class="comment">// 排名</span></span><br><span class="line">  <span class="keyword">int</span> sr;        <span class="comment">// 收入</span></span><br><span class="line">  <span class="keyword">char</span> cp[<span class="number">3</span>];    <span class="comment">// 著名产品</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span> <span class="title">desc</span> =</span> &#123;<span class="string">&quot;DEC&quot;</span>, <span class="string">&quot;Ken Olsen&quot;</span>, <span class="number">137</span>, <span class="number">40</span>, <span class="string">&quot;PDP&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码在内存结构如下：这些数据被存放在seg段中从偏移地址60H起始的位置。</p>
<p><img src="/images/image-20211128150510309.png" alt="image-20211128150510309"></p>
<p>将其编译成成汇编语言，得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60h</span><br><span class="line"></span><br><span class="line">mov word ptr [bx+0ch],38</span><br><span class="line">mov word ptr [bx+0eh],70</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov byte ptr [bx+10h+si],&#x27;V&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10h+si],&#x27;A&#x27;</span><br><span class="line">inc si</span><br><span class="line">mov byte ptr [bx+10h+si],&#x27;X&#x27;</span><br><span class="line">inc si</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="number">1</span>;</span><br><span class="line">  dec.pm = <span class="number">38</span>;</span><br><span class="line">  dec.sr = dec.sr+<span class="number">70</span>;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  dec.cp[i]=<span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">  i++;</span><br><span class="line">  dec.cp[i]=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  i++;</span><br><span class="line">  dec.cp[i]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码转成汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,seg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,60h     ; 记录首地址，送入bx</span><br><span class="line"></span><br><span class="line">mov word ptr [bx].0ch,38        ; C: dec.pm=38;</span><br><span class="line">mov word ptr [bx].0eh,70        ; C: dec.sr=dec.sr+70;</span><br><span class="line"></span><br><span class="line">mov si,0                        ; C: i=0;</span><br><span class="line">mov byte ptr [bx].10h[si],&#x27;V&#x27;   ; C: dec.cp[i]=&#x27;V&#x27;;</span><br><span class="line">inc si                          ; C: i++;</span><br><span class="line">mov byte ptr [bx],10h[si],&#x27;A&#x27;   ; C: dec.cp[i]=&#x27;A&#x27;;</span><br><span class="line">inc si                          ; C: i++;</span><br><span class="line">mov byte ptr [bx],10h[si],&#x27;X&#x27;   ; C: dec.cp[i]=&#x27;X&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>8086CPU提供的如<code>[bx+si+idata]</code>的寻址方式为结构化数据的处理提供了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。</p>
<ul>
<li>从上面可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字型数<br>据，有的是字节型数据，有的是数组（字符串）。</li>
<li>一般来说，我们可以用<code>[bx+idata+si]</code>的方式来访问结构体中的数据。<strong>用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素</strong>。为此，汇编语言提供了更为贴切的书写方式，如：<code>[bx].idata</code>、<code>[bx].idata[si]</code></li>
<li>在C语言程序中我们看到，如：<code>dec.cp[i]</code>，dec是一个变量名，指明了结构体变量的地址，cp是一个名称，指明了数据项cp的地址，而i用来定位cp中的每一个字符。汇编语言中的做法是：<code>bx.10h[si]</code>。看一下，是不是很相似？</li>
</ul>
</blockquote>
<h2 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h2><p>div是除法指令，使用div做除法的时候应注意以下问题。</p>
<ul>
<li>除数：有8位和16位两种，在一个reg或内存单元中。</li>
<li>被除数：默认放在<code>AX</code>或<code>DX和AX</code>中，<ul>
<li>如果除数为8位，被除数则为16位，默认在AX中存放。</li>
<li>如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</li>
</ul>
</li>
<li>结果：<ul>
<li>如果除数为8位，则AL存储商，AH存储余数；</li>
<li>如果除数为16位，则AX存储商，DX存储余数。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; 格式如下：</span><br><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line">; 示例：</span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">; (al) = (ax) / ((ds)*16+0) 的商</span><br><span class="line">; (ah) = (ax) / ((ds)*16+0) 的余数</span><br><span class="line"></span><br><span class="line">div word ptr es:[0]</span><br><span class="line">; （ax）=[（dx）*10000H+（ax）]/（（es）*16+0）的商</span><br><span class="line">; （dx）=[（dx）*10000H+（ax）]/（（es）*16+0）的余数</span><br><span class="line"></span><br><span class="line">div byte ptr [bx+si+8]</span><br><span class="line">; （al）=（ax）/（（ds）*16+（bx）+（si）+8）的商</span><br><span class="line">; （ah）=（ax）/（（ds）*16+（bx）+（si）+8）的余数</span><br><span class="line"></span><br><span class="line">div word ptr [bx+si+8]</span><br><span class="line">; （ax）=[（dx）*10000H+（ax）]/（（ds）*16+（bx）+（si）+8）的商</span><br><span class="line">; （dx）=[（dx）*10000H+（ax）]/（（ds）*16+（bx）+（si）+8）的余数</span><br></pre></td></tr></table></figure>

<p>利用除法指令计算100001/100。</p>
<p>首先分析一下，被除数100001大于65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位寄存器中存放，但是，因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。因为要分别为dx和ax赋100001的高16位值和低16位值，所以应先将100001表示为16进制形式：186A1H。程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H ; (dx)*10000H+(ax)=100001</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>



<p>编程，利用除法指令计算1001/100。<br>首先分析一下，被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，也就是说，要进行8位的除法。程序如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1001</span><br><span class="line">mov bl,100</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure>



<h2 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h2><p>db和dw定义字节型数据和字型数据。dd是用来定义dword(double word，双字）型数据的。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db 1</span><br><span class="line">	dw 1</span><br><span class="line">	dd 1</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个数据为01H，在data:0处，占1个字节</li>
<li>第二个数据为0001H，在data:1处，占1个字；</li>
<li>第三个数据为00000001H，在data:3处，占2个字。</li>
</ul>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p><code>dup</code>：duplicate，是和db、dw、dd等数据定义伪指令配合使用的，用来进行<strong>数据的重复</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 重复的次数 dup (重复的字节型数据)</span><br><span class="line">dw 重复的次数 dup (重复的字型数据)</span><br><span class="line">dd 重复的次数 dup (重复的双字型数据)</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<ul>
<li><code>db 3 dup(0)</code>：定义了3个字节，它们的值都是0，相当于<code>db 0,0,0</code>。</li>
<li><code>db 3 dup(0,1,2)</code>：定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于<code>db 0,1,2,0,1,2,0,1,2</code>。</li>
<li><code>db 3 dup (&#39;abc&#39;，ABC&#39;)</code>：定义了18个字节，它们是abcABCabcABCabcABC，相当于<code>db &#39;abcABCabcABCabcABC&#39;</code></li>
</ul>
<h1 id="第九章-转移指令的原理"><a href="#第九章-转移指令的原理" class="headerlink" title="第九章 转移指令的原理"></a>第九章 转移指令的原理</h1><p><strong>可以修改IP，或同时修改CS和IP的指令统称为转移指令</strong>。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
<p>8086CPU的转移行为有以下几类。</p>
<ul>
<li>只修改IP时，称为<code>段内转移</code>，比如：jmp ax。</li>
<li>同时修改CS和IP时，称为<code>段间转移</code>，比如：jmp1000：0。</li>
</ul>
<p>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。</p>
<ul>
<li>短转移IP的修改范围为-128~127。</li>
<li>近转移IP的修改范围为-32768~32767.</li>
</ul>
<p>8086CPU的转移指令分为以下几类。</p>
<ul>
<li>无条件转移指令（如：jmp）</li>
<li>条件转移指令</li>
<li>循环指令（如：loop）</li>
<li>过程</li>
<li>中断</li>
</ul>
<h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><p>操作符offset在汇编语言中是由编译器处理的符号，它的<strong>功能是取得标号的偏移地址</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	start:mov ax,offset start ; 找到start标记的指令的偏移地址，相当于mov ax,0</span><br><span class="line">	s:		mov ax,offset s     ; 找到s标记的指令的偏移地址，第一条指令长度为3个字节，相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>使该程序在运行中将s处的一条指令复制到s0处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"> codesg segment</span><br><span class="line">   s: mov ax,bx         ;（mov ax,bx 的机器码占两个字节）</span><br><span class="line">      mov si,offset s</span><br><span class="line">      mov di,offset s0</span><br><span class="line">      mov ax,cs:[si]</span><br><span class="line">      mov cs:[di],ax</span><br><span class="line"> s0: 	nop               ;（nop的机器码占一个字节）</span><br><span class="line">      nop</span><br><span class="line"> codesg ends</span><br><span class="line"> ends</span><br></pre></td></tr></table></figure>



<h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><p>jmp为无条件转移指令，可以只修改IP也可以同时修改CS和IP。</p>
<p>jmp指令要给出两种信息：</p>
<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号（转到标号处执行指令）</span><br></pre></td></tr></table></figure>

<p>这种格式的jmp指令实现的是<code>段内短转移</code>，它对IP的修改范围为-128~127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。</p>
<p>jmp指令中的“short”符号，说明指令进行的是短转移。jmp指令中的“标号”是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS：IP应该指向标号处的指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">	start: mov ax,0</span><br><span class="line">				 mov bx,0</span><br><span class="line">				 jmp short s</span><br><span class="line">				 add ax,1  ; 跳过此条指令</span><br><span class="line">			s: inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>查看内存：</p>
<p><img src="/images/image-20211129150132868.png" alt="image-20211129150132868"></p>
<p>可以看到，<code>jmp short s</code>被翻译成了<code>jmp 0008</code>，对应的机器码为<code>EB03</code>。</p>
<p>注意，这个机器码中竟不包含转移的目的地址。这意味着，CPU在执行 EB03的时，并不知道转移的目的地址。</p>
<blockquote>
<p><strong>CPU在执行jmp指令的时候并不需要转移的目的地址</strong>。机器指令中不包含目的地址的地址，那么也就是说，CPU不需要这个目的地址就可以实现对IP的修改。</p>
</blockquote>
<p>CPU在执行EB03的时候是根据什么修改的IP，使其指向目标指令呢？<strong>就是根据指令码中的03</strong>。注意，要转移的目的地址是CS：000B，而CPU执行EB03时，当前的（IP）=0008H，将当前的IP值加3，使（IP）=000BH，CS：IP就可指向目标指令。</p>
<blockquote>
<p>在转移指令EB03中并没有告诉CPU要转移的目的地址，却告诉了CPU要转移的位移，即将当前的IP向后移动3个字节。</p>
</blockquote>
<p>在“jmp short 标号”指令所对应的机器码中，并不包含转移的目的地址，而<strong>包含的是转移的位移</strong>。这个位移，是编译器根据汇编指令中的“标号”计算出来的：</p>
<p><img src="/images/image-20211129151303118.png" alt="image-20211129151303118"></p>
<p>实际上，“jmp short 标号”的功能为：<code>(IP)=(IP)+8位位移</code>。</p>
<ol>
<li>8位位移=标号处的地址 - jmp指令后的第一个字节的地址；</li>
<li>short指明此处的位移为8位位移；</li>
<li>8位位移的范围为-128~127，用补码表示；</li>
<li>8位位移由编译程序在编译时算出。</li>
</ol>
<p>还有一种和“ jmp short 标号”功能相近的指令格式，<code>jmp near ptr 标号</code>，它实现的是<strong>段内近转移</strong>。</p>
<ol>
<li>“jmp near ptr 标号”的功能为：(IP)=(IP)+16位位移。</li>
<li>16位位移=标号处的地址 - jmp指令后的第一个字节的地址； near ptr指明此处的位移为16位位移，进行的是段内近转移； 16位位</li>
<li>移的范围为-32768~ 32767，用补码表示；</li>
<li>16位位移由编译程序在编译时算出。</li>
</ol>
<h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><p>“jmp far ptr 标号”实现的是段间转移，又称为<strong>远转移</strong>。功能如下：</p>
<ul>
<li>（CS）= 标号所在段的段地址； </li>
<li>（IP）= 标号在段中的偏移地址。 </li>
</ul>
<p>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	start: mov ax,0</span><br><span class="line">				 mov bx,0</span><br><span class="line">				 jmp far ptr s</span><br><span class="line">				 db 256 dup(0)</span><br><span class="line">	s:		 add ax,1</span><br><span class="line">				 inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211129153937410.png" alt="image-20211129153937410"></p>
<p>源程序中的<code>db 256 dup(0)</code>，被Debug解释为相应的若干条汇编指令。这不是关键，关键是我们要注意一下jmp far ptrs所对应的机器码：<code>EA0B01BD0B</code>，其中包含转移的目的地址。“0B01BD0B”是目的地址在指令中的存储顺序，高地址的“BDB”是转移的段地址：0BBDH，低地址的“0B01”是偏移地址：010BH。</p>
<h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><ul>
<li>指令格式：<code>jmp 16位reg</code></li>
<li>功能：（IP）=（16位reg）</li>
</ul>
<h2 id="转移地址在内存中的-jmp-指令"><a href="#转移地址在内存中的-jmp-指令" class="headerlink" title="转移地址在内存中的 jmp 指令"></a>转移地址在内存中的 jmp 指令</h2><p>转移地址在内存中的jmp指令有两种格式： </p>
<ul>
<li><p>jmp word ptr 内存单元地址（段内转移）：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0] ; 执行后(IP)=0123H</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">jmp word ptr [bx] ; 执行后(IP)=0123H</span><br></pre></td></tr></table></figure></li>
<li><p>jmp dword ptr 内存单元地址（段间转移）：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0] ; 执行后，(CS)=0,(IP)=0123H</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]   ; 执行后，(CS)=0,(IP)=0123H</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2><p>jcxz：<code>jump when CX is zero</code></p>
<p>功能：<strong>如果(cx)=0，则转移到标号处执行。当(cx)≠0时，什么也不做（程序向下执行）</strong></p>
<ul>
<li>当(cx)=0时，(IP)=(IP)+8位位移</li>
<li>8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址；</li>
<li>8位位移的范围为-128~127，用补码表示；</li>
<li>8位位移由编译程序在编译时算出。</li>
</ul>
<blockquote>
<p><code>jcxz 标号</code>的功能类似于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cx == <span class="number">0</span>) &#123;</span><br><span class="line">	jmp <span class="keyword">short</span> 标号;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>jcxz是有条件转移指令</p>
<ul>
<li>所有的有条件转移指令都是短转移</li>
<li>对IP的修改范围都为-128~127</li>
<li>在对应的机器码中包含转移的位移，而不是目的地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; 在内存2000H段中查找第一个值为0的字节，找到后，将它的偏移地址存储在dx中。</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start: mov ax,2000H</span><br><span class="line">       mov ds,ax</span><br><span class="line">       mov bx,0</span><br><span class="line"></span><br><span class="line">    s: mov cl,[bx]</span><br><span class="line">       mov ch,0</span><br><span class="line">       jcxz ok</span><br><span class="line">       inc bx</span><br><span class="line">       jmp short s</span><br><span class="line"></span><br><span class="line">   ok: mov dx,bx</span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">   </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127。</p>
<p>“loop 标号”的功能相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line"><span class="keyword">if</span> (cx!=<span class="number">0</span>) &#123;</span><br><span class="line">  jmp <span class="keyword">short</span> 标号;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start: mov ax,2000H</span><br><span class="line">       mov ds,ax</span><br><span class="line">       mov bx,0</span><br><span class="line">      </span><br><span class="line">    s: mov cl,[bx]</span><br><span class="line">       mov ch,0</span><br><span class="line">       inc cx</span><br><span class="line">       inc bx</span><br><span class="line">       loop s</span><br><span class="line"></span><br><span class="line">   ok: dec bx</span><br><span class="line">       mov dx,bx</span><br><span class="line"></span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h2><ul>
<li>jmp short标号</li>
<li>jmp near ptr标号</li>
<li>jcxz标号</li>
<li>loop标号</li>
</ul>
<p>等几种汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。这种设计，<strong>方便了程序段在内存中的浮动装配</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   mov cx,6        ; B9 06 00</span><br><span class="line">   mov ax,10h      ; B8 10 00</span><br><span class="line">s: add ax,ax       ; 01 C0</span><br><span class="line">	 loop s          ; E2 FC</span><br></pre></td></tr></table></figure>

<ul>
<li>这段程序装在内存中的不同位置都可正确执行，因为loops在执行时只涉及s的位移（-4，前移4个字节，补码表示为FCH），而不是s的地址。</li>
<li>如果loops的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制，因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。</li>
</ul>
<h2 id="编译器对转移位移超界的检测"><a href="#编译器对转移位移超界的检测" class="headerlink" title="编译器对转移位移超界的检测"></a>编译器对转移位移超界的检测</h2><p>根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	start: jmp short s   ; ERROR: jmp short s的转移范围是-128~127，IP最多向后移动127个字节</span><br><span class="line">				 db 128 dup(0)</span><br><span class="line">			s: mov ax,0ffffh</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="一个奇怪的程序"><a href="#一个奇怪的程序" class="headerlink" title="一个奇怪的程序"></a>一个奇怪的程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">        mov ax, 4c00H</span><br><span class="line">        int 21H</span><br><span class="line"></span><br><span class="line">start:  mov ax, 0</span><br><span class="line">    s:  nop    ; 分配一个字节的空间</span><br><span class="line">        nop</span><br><span class="line"></span><br><span class="line">        mov di, offset s</span><br><span class="line">        mov si, offset s2</span><br><span class="line">        mov ax, cs:[si]</span><br><span class="line">        mov cs:[di], ax ; 将jmp short s1这个指令的机器码赋值给了s标号后面2个字节</span><br><span class="line"></span><br><span class="line">    s0: jmp short s ; 对应的机器码为EBF6，执行它会向前偏移10个字节</span><br><span class="line">    </span><br><span class="line">    s1: mov ax, 0   ; 标号s1及以后的汇编代码，程序就没有执行了。</span><br><span class="line">        int 21H</span><br><span class="line">        mov ax, 0</span><br><span class="line">        </span><br><span class="line">    s2: jmp short s1</span><br><span class="line">        nop</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h1 id="第十章-CALL和RET指令"><a href="#第十章-CALL和RET指令" class="headerlink" title="第十章 CALL和RET指令"></a>第十章 CALL和RET指令</h1><h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p>call和ret指令经常被共同用来实现子程序的设计。<strong>比如函数调用</strong>。</p>
<ul>
<li>ret（return）指令用栈中的数据，修改IP的内容，从而实现近转移；</li>
<li>retf（return far）指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</li>
</ul>
<p>CPU执行ret指令时，相当于进行下面两步操作：</p>
<ul>
<li>(IP)=(ss)*16+(sp)</li>
<li>(sp)=(sp)+2</li>
</ul>
<p>CPU执行retf指令时，相当于进行下面4步操作：</p>
<ul>
<li>(IP)=(ss)*16+(sp)</li>
<li>(sp)=(sp)+2</li>
<li>(CS)=(ss)*16+(sp)</li>
<li>(sp)=(sp)+2</li>
</ul>
<p>可以看出，如果我们用汇编语法来解释ret和retf指令，则：</p>
<p>CPU执行ret指令时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br></pre></td></tr></table></figure>

<p>CPU执行retf指令时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br></pre></td></tr></table></figure>



<p>下面的程序中，ret指令执行后，(IP)=0，CS:IP指向代码段的第一条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">	db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">			mov ax,4c00h</span><br><span class="line">			int 21h</span><br><span class="line">start:mov ax,stack</span><br><span class="line">			mov ss,ax</span><br><span class="line">			mov sp,16</span><br><span class="line"></span><br><span class="line">			mov ax,0</span><br><span class="line">			push ax</span><br><span class="line">			mov bx,0</span><br><span class="line">			ret   ; ret指令执行后，（IP）=O，CS：IP指向代码段的第一条指令。</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>下面的程序中，retf指令执行后，CS:IP指向代码段的第一条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        inc 21h</span><br><span class="line"></span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line">        </span><br><span class="line">        mov ax,0</span><br><span class="line">        push cs</span><br><span class="line">        push ax</span><br><span class="line">        mov bx,0</span><br><span class="line">        retf</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h2><p>CPU执行call指令时，进行两步操作：</p>
<ol>
<li><strong>将当前的IP或CS和IP压入栈中</strong>；</li>
<li><strong>转移</strong>。</li>
</ol>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p>
<p><code>call 标号(将当前的IP压栈后，转到标号处执行指令)</code>，CPU执行此种格式的call指令时，进行如下的操作：</p>
<ul>
<li>(sp)=(sp)-2</li>
<li>(ss)*16+(sp)=(IP)</li>
<li>(IP)=(IP)+16位位移。</li>
</ul>
<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>



<p>下面的程序执行后，ax中的数值为多少？答案为6</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1000：0 	mov ax,0		;读取此条指令后IP=3 ，执行完该指令后IP=3</span><br><span class="line">1000：3 	call s			;读取此条指令后IP=6 ，所以IP=6入栈，执行完该指令后IP=7，跳转到s处</span><br><span class="line">1000：6 	inc ax</span><br><span class="line">1000：7 	s:pop ax		；所以POP后，ax=6</span><br></pre></td></tr></table></figure>



<h2 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h2><p>前面讲的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。</p>
<p><code>call far ptr 标号</code>：实现的是段间转移</p>
<p>CPU执行此种格式的cal指令时，进行如下的操作。</p>
<ul>
<li>(sp)=(sp)-2</li>
<li>((ss)*16+(sp)) = (cs)</li>
<li>(sp)=(sp)-2</li>
<li>((ss)*16+(sp)) = (ip)</li>
</ul>
<p>也就是说，CPU执行<code>call far ptr 标号</code>时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>



<h2 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h2><p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 16位的reg</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<ul>
<li>(sp)=(sp)-2</li>
<li>((ss)*16+(sp)) = (ip)</li>
<li>(ip)=(16位的reg)</li>
</ul>
<p>也就是说，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp 16位的reg</span><br></pre></td></tr></table></figure>



<p>下面的程序执行后，ax中的数值为多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址   汇编指令</span><br><span class="line">1000:0    mov ax,6</span><br><span class="line">1000:2    call ax	    ; 相当于push IP=5 ,jmp ax=6,此指令未改变CS的值</span><br><span class="line">1000:5    inc ax	    ; 未执行</span><br><span class="line">1000:6    mov bp,sp</span><br><span class="line">          add ax,[bp]	; 相当于add ax,[sp]，默认段地址ss，所以即把栈顶元素弹出和AX相加 ，6+5=11=BH</span><br></pre></td></tr></table></figure>



<h2 id="转移地址存于内存中的call指令"><a href="#转移地址存于内存中的call指令" class="headerlink" title="转移地址存于内存中的call指令"></a>转移地址存于内存中的call指令</h2><p>转移地址在内存中的call指令有两种格式。</p>
<ul>
<li><p><code>call word ptr 内存单元地址</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 相当于</span><br><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure></li>
<li><p><code>call dword ptr 内存单元地址</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 相当于</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure></li>
</ul>
<p>示例一：下面代码执行后，(ip) = 0123H，(sp) = 0EH</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp, 10h</span><br><span class="line">mov ax, 0123h</span><br><span class="line">mov ds:[0], ax  ; 将ds：[0] 的值设置为0123h</span><br><span class="line"></span><br><span class="line">call word ptr ds:[0] ; 存储当前的ip，然后将ds：[0]里的值作为最新的ip</span><br></pre></td></tr></table></figure>



<p>下面的程序执行后，ax中的数值为多少？答案为3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:</span><br><span class="line">        mov ax, stack</span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov sp, 0010H</span><br><span class="line">        </span><br><span class="line">        mov ds, ax		;ds与ss值相同，指向同一段内存空间</span><br><span class="line">        call word ptr ds:[0EH]</span><br><span class="line">        inc ax</span><br><span class="line">        inc ax</span><br><span class="line">        inc ax</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>执行 call word ptr ds:[0EH] 的过程：</p>
<ol>
<li>CPU取该指令 : (call word ptr ds:[0EH])</li>
<li>ip自增，指向了下一条指令 (inc ax)</li>
<li>开始执行 call word ptr ds:[0EH] 指令。 <ol>
<li>push ip ; 将 ip 压入栈，</li>
<li>jmp ds:[0EH] ，即程序从 ds:[0EH] 中取出数据赋值给 ip，所以ds:[0EH]就是刚才push进去的IP的位置</li>
</ol>
</li>
<li>执行三个 inc ax</li>
<li>因此最终 ax 值为 3</li>
</ol>
<p><img src="/images/image-20211213214402514.png" alt="image-20211213214402514"></p>
<p>示例二：</p>
<p><img src="/images/20200412165812891.png" alt="在这里插入图片描述"></p>
<h2 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:</span><br><span class="line">        mov ax, 1</span><br><span class="line">        mov cx, 3</span><br><span class="line">        call s</span><br><span class="line">        mov bx,ax</span><br><span class="line">        mov ax,4c00h																</span><br><span class="line">        int 21h</span><br><span class="line">       s:</span><br><span class="line">        add ax, ax</span><br><span class="line">        loop s</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上述程序执行完毕，(bx) = 8</p>
<ul>
<li>我们发现，使用call和ret可以写一个具有一定功能的程序段，我们称其为<code>子程序</code></li>
<li>在需要的时候，用call指令转去执行。call指令转去执行子程序之前，call指令<strong>后面的指令的地址</strong>将存储在栈中，所以可在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。</li>
</ul>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p>mul是乘法指令</p>
<ul>
<li>两个相乘的数：两个相乘的数，<strong>要么都是8位，要么都是16位</strong>。<ul>
<li>如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；</li>
<li>如果是16位，一个默认在AX中，另一个放在16位reg或内存字单元中。</li>
</ul>
</li>
<li>结果：<ul>
<li>如果是8位乘法，结果默认放在AX中；</li>
<li>如果是16位乘法，结果高位默认在DX中存放，低位在AX中放。</li>
</ul>
</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">mul byte ptr ds:[0] </span><br><span class="line">; 等同于 (ax) = (al) * ((ds) * 16 + 0)</span><br><span class="line"></span><br><span class="line">mul word ptr [bx+si+8] </span><br><span class="line">; 等同于:</span><br><span class="line">; (ax) = (ax) * ((ds) * 16 + (bx) + (si) + 8)结果的低16位</span><br><span class="line">; (dx) = (ax) * ((ds) * 16 + (bx) + (si) + 8)结果的高16位</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; 计算100*10</span><br><span class="line">; 100和10都小于255，可以使用8位乘法</span><br><span class="line">; 结果: (ax)=1000(03E8H)</span><br><span class="line">mov al, 100</span><br><span class="line">mov bl, 10</span><br><span class="line">mul bl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 计算100*10000</span><br><span class="line">; 100小于255，10000大于255，所以必须使用16位乘法</span><br><span class="line">; 结果：(ax)=4240H,(dx)=000FH,(F4240H=1000000)</span><br><span class="line">mov ax, 100</span><br><span class="line">mov bx, 10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure>



<h2 id="参数和结果传递的问题"><a href="#参数和结果传递的问题" class="headerlink" title="参数和结果传递的问题"></a>参数和结果传递的问题</h2><p>设计一个子程序，可以根据提供的N，来计算N的3次方。这里面就有两个问题：</p>
<ul>
<li>将参数N存储在什么地方？</li>
<li>计算得到的数值，存储在什么地方？</li>
</ul>
<blockquote>
<p><strong>用寄存器来存储参数和结果</strong>是最常使用的方法。</p>
</blockquote>
<p>用寄存器来存储，可以将参数放到bx中；因为子程序中要计算<code>N*N*N</code>，可以使用多个mul指令，为了方便，可将结果放到dx和ax中。子程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; 说明：计算N的3次方</span><br><span class="line">; 参数：（bx）= N</span><br><span class="line">; 结果：（dx:ax）= N^3</span><br><span class="line">cube: mov ax,bx</span><br><span class="line">			mul bx</span><br><span class="line">			mul bx</span><br><span class="line">			ret</span><br></pre></td></tr></table></figure>

<p>计算data段中第一组数据的3次方，结果保存在后面一组dword单元中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw  1,2,3,4,5,6,7,8</span><br><span class="line">    dd  0,0,0,0,0,0,0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    </span><br><span class="line">    mov si,0</span><br><span class="line">    mov di,16</span><br><span class="line"></span><br><span class="line">    mov cx,8</span><br><span class="line">s:</span><br><span class="line">    mov bx,[si]</span><br><span class="line">    call cube</span><br><span class="line">    mov [di], ax</span><br><span class="line">    mov [di].2, dx</span><br><span class="line">    add si,2</span><br><span class="line">    add di,4</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">cube:</span><br><span class="line">    mov ax,bx</span><br><span class="line">    mul bx</span><br><span class="line">    mul bx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="批量数据的传递"><a href="#批量数据的传递" class="headerlink" title="批量数据的传递"></a>批量数据的传递</h2><p>如果子程序需要多个参数怎么办？我们不可能简单地用寄存器来存放多个需要传递的数据。对于返回值，也有同样的问题。</p>
<blockquote>
<p>在这种时候，我们将批量数据放到内存中，然后<strong>将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序</strong>。对于具有批量数据的返回结果，也可用同样的方法。</p>
</blockquote>
<p>设计一个子程序，功能：将一个全是字母的字符串转化为大写。</p>
<p><strong>这个子程序需要知道两件事，<code>字符串的内容</code>和<code>字符串的长度</code>。(对应C语言中的数组指针和数组长度)</strong></p>
<ul>
<li>将字符串在内存中的首地址放在寄存器中传递给子程序。</li>
<li>因为子程序中要用到循环，我们可以用loop指令，而循环的次数恰恰就是字符串的长度。出于方便的考虑，可以将字符串的长度放到cx中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">  data segment</span><br><span class="line">    db &#x27;conversation&#x27;</span><br><span class="line">  data ends</span><br><span class="line"></span><br><span class="line">  code segment</span><br><span class="line">    start:mov ax,data</span><br><span class="line">          mov ds,ax</span><br><span class="line">          </span><br><span class="line">          mov si,0         ; ds:si指向字符串(批量数据〕所在空间的首地址</span><br><span class="line">          mov cx,12        ; CX存放字符串的长度</span><br><span class="line">          call capital</span><br><span class="line">          mov ax,4c00h</span><br><span class="line">          int  21h</span><br><span class="line"></span><br><span class="line">capital:and byte ptr [si]，11011111b   ; 将ds:si所指单元中的字母转化为大写</span><br><span class="line">        inc si                        ; ds:si指向下一个单元</span><br><span class="line">        loop capital</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="寄存器冲突的问题"><a href="#寄存器冲突的问题" class="headerlink" title="寄存器冲突的问题"></a>寄存器冲突的问题</h2><p>众所周知，C语言中字符串以<code>\0</code>结尾，所以可以如下定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db &#x27;hello world&#x27;,0</span><br></pre></td></tr></table></figure>

<ul>
<li>所以上述子程序可以依次读取每个字符进行检测，<ul>
<li>如果不是0，就进行大写的转化</li>
<li>如果是0，就结束处理。</li>
</ul>
</li>
<li>由于可通过检测0而知道是否已经处理完整个字符串，<strong>所以子程序可以不需要字符串的长度作为参数</strong>。可以用jcxz来检测0。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">  db &#x27;word&#x27;,0</span><br><span class="line">  db &#x27;unix&#x27;,0</span><br><span class="line">  db &#x27;wind&#x27;,0</span><br><span class="line">  db &#x27;good&#x27;,0</span><br><span class="line">data ends</span><br><span class="line">;可以看到，所有字符串的长度都是5(算上结尾符0)，使用循环，重复调用子程序</span><br><span class="line">;capital，完成对4个字符串的处理。完整的程序如下。</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">       mov ax,data</span><br><span class="line">			 mov ds,ax</span><br><span class="line">			 </span><br><span class="line">       mov bx,0</span><br><span class="line">		 	 mov cx,4</span><br><span class="line">    s: mov si,bx</span><br><span class="line">       call capital</span><br><span class="line">       add bx,5</span><br><span class="line">       loop s</span><br><span class="line"></span><br><span class="line">       mov ax,4c00h</span><br><span class="line">       int 21h</span><br><span class="line">       </span><br><span class="line">; 说明：将一个全是字母，以0结尾的字符串，转化为大写</span><br><span class="line">; 参数：ds:si指向字符串的首地址</span><br><span class="line">; 结果：没有返回值</span><br><span class="line">capital:    mov cl,[si]</span><br><span class="line">            mov ch,0</span><br><span class="line">            jcxz ok      ; 如果（cx）=0，结束：如果不是0，处理</span><br><span class="line">            and byte ptr [si],11011111b  ; 将ds:si所指单元中的字母转化为大写</span><br><span class="line">            inc si       ; ds:si指向下一个单元</span><br><span class="line">            jmp short capital</span><br><span class="line">ok:         ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码其实是有问题的，问题在于cx的使用，</li>
<li>主程序要使用cx记录循环次数，可是子程序中也使用了cx，在执行子程序的时候，cx中保存的循环计数值被改变，使得主程序的循环出错。</li>
<li>从上面的问题中，实际上引出了一个一般化的问题：<strong>子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突</strong>。</li>
</ul>
<p>我们希望：</p>
<ul>
<li>编写调用子程序的程序的时候不必关心子程序到底使用了哪些寄存器；</li>
<li>编写子程序的时候不必关心调用者使用了哪些寄存器；</li>
<li>不会发生寄存器冲突。</li>
</ul>
<blockquote>
<p>解决这个问题的简捷方法是，在子程序的开始<strong>将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复</strong>。可以用栈来保存寄存器中的内容。</p>
<p>这里的知识可以对应到<strong>C语言函数调用时，所有函数自己内部的参数都会放到函数栈的内存中</strong>。</p>
</blockquote>
<p>所以，子程序的标准框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序开始：子程序中使用的寄存器入栈</span><br><span class="line">          子程序内容</span><br><span class="line">          子程序中使用的寄存器出栈</span><br><span class="line">          返回（ret、retf）</span><br></pre></td></tr></table></figure>



<p>改进一下子程序 capital 的设计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; 说明：将一个全是字母，以0结尾的字符串，转化为大写</span><br><span class="line">; 参数：ds:si指向字符串的首地址</span><br><span class="line">; 结果：没有返回值</span><br><span class="line">capital:    push cx</span><br><span class="line">						push si</span><br><span class="line"></span><br><span class="line">change:			mov cl,[si]</span><br><span class="line">            mov ch,0</span><br><span class="line">            jcxz ok                      ; 如果（cx）=0，结束：如果不是0，处理</span><br><span class="line">            and byte ptr [si],11011111b  ; 将ds:si所指单元中的字母转化为大写</span><br><span class="line">            inc si                       ; ds:si指向下一个单元</span><br><span class="line">            jmp short change</span><br><span class="line">            </span><br><span class="line">ok:         pop si</span><br><span class="line">         		pop cx</span><br><span class="line">         		ret</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对比原代码：其实就是<strong>将参数挨个入栈，最后将其出栈</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">capital:    mov cl,[si]</span><br><span class="line">            mov ch,0</span><br><span class="line">            jcxz ok      ; 如果（cx）=0，结束：如果不是0，处理</span><br><span class="line">            and byte ptr [si],11011111b  ; 将ds:si所指单元中的字母转化为大写</span><br><span class="line">            inc si       ; ds:si指向下一个单元</span><br><span class="line">            jmp short capital</span><br><span class="line">ok:         ret</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="第十一章标志寄存器"><a href="#第十一章标志寄存器" class="headerlink" title="第十一章标志寄存器"></a>第十一章标志寄存器</h1><h2 id="何为标志寄存器"><a href="#何为标志寄存器" class="headerlink" title="何为标志寄存器"></a>何为标志寄存器</h2><ul>
<li>回顾一下ALU，为其添加两个两个输入，它会输出计算结果，并且会返回一些FLAG交给CPU，我们将这些FLAG称为<code>标志</code></li>
<li>有一个专门的寄存器用来存放所有的标志位，该寄存器称为<code>程序状态字</code>(PSW)。</li>
</ul>
<p><img src="/images/1580877210170.png" alt="1580877210170"></p>
<p><img src="/images/image-20211212102252616.png" alt="image-20211212102252616"></p>
<p>标志寄存器的作用：</p>
<ul>
<li>用来存储相关指令的某些执行结果</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPU的相关工作方式</li>
</ul>
<blockquote>
<p>因为ALU是<code>算术逻辑单元</code>，所以一般情况下只有<code>运算指令</code>能影响标志位。<code>传送指令</code>没有影响。</p>
</blockquote>
<h2 id="8086CPUflag寄存器的结构"><a href="#8086CPUflag寄存器的结构" class="headerlink" title="8086CPUflag寄存器的结构"></a>8086CPUflag寄存器的结构</h2><p><img src="/images/image-20211214144230093.png" alt="image-20211214144230093"></p>
<ul>
<li><p>ZF：零标志。如果运算结果为0，ZF置1。</p>
</li>
<li><p>PF：奇偶标志。如果运算结果中1的位数是偶数，PF置1，表示运算结果具有偶数性，反之为0。</p>
</li>
<li><p>SF：符号标志。运算结果最高有效位位1，SF置1，表示运算结果为负数。</p>
</li>
<li><p>CF：进位标志。在进行<strong>无符号数</strong>运算的时候，它记录了<strong>运算结果的最高有效位向更高位的进位值</strong>，或从更高位的借位值。</p>
<p><img src="/images/image-20211214154110135.png" alt="image-20211214154110135"></p>
<blockquote>
<ul>
<li>98H+98H，将产生进位。由于这个进位值在8位数中无法保存，其实CPU在运算的时候，并不丢弃这个进位值，而是记录在一个flag寄存器的CF位上。</li>
<li>97H-98H，将产生借位，借位后，相当于计算197H-98H。而flag的CF位也可以用来记录这个借位值。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al, 98H</span><br><span class="line">add al, al ; 执行后:(al)=30H,CF=1,CF记录了从最高有效位向更高位的进位值</span><br><span class="line">add al, al ; 执行后:(al)=60H,CF=0,CF记录了从最高有效位向更高位的进位值</span><br><span class="line"></span><br><span class="line">mov al, 97H</span><br><span class="line">sub al, 98H ; 执行后:(al)=FFH,CF=1,CF记录了向更高位的借位值</span><br><span class="line">sub al, al  ; 执行后:(al)=0,CF=0,CF记录了向更高位的借位值</span><br></pre></td></tr></table></figure></li>
<li><p>OF：溢出标志。在进行<strong>有符号数</strong>运算的时候，如结果超过了机器所能表示的范围称为溢出。</p>
</li>
<li><p>TF：调试标志位。当TF=1时，处理器每次只执行一条指令，即单步执行。</p>
</li>
<li><p>IF：中断允许标志位。它用来控制8086是否允许接收<strong>外部</strong>中断请求。若IF=1，8086能响应外部中断，反之则屏蔽外部中断。</p>
</li>
</ul>
<h2 id="CF与OF的区别"><a href="#CF与OF的区别" class="headerlink" title="CF与OF的区别"></a>CF与OF的区别</h2><ul>
<li><p>CF和OF的区别：<strong>CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。</strong></p>
<blockquote>
<p>简单来说就是：OF标志的意思是，假定你进行的是有符号数运算，如果运算结果是正确的，那么OF=0，否则OF=1。</p>
</blockquote>
</li>
<li><p>CF用于<strong>无符号数</strong>运算，OF用于<strong>有符号数</strong>运算</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AL，7EH</span><br><span class="line">ADD AL，5BH</span><br></pre></td></tr></table></figure>

<ul>
<li>结果AL=D9，AL是AX的低8位</li>
<li>首先要考虑D9是有符号数还是无符号数，因为计算机中的数值是以补码存储的，不知道是有符号还是无符号，<ul>
<li>当D9是无符号数时，AL能否存得下D9？可以这样想，AL最大存的无符号数是FF，这时D9&lt;FF，说明没有假想的更高位进位，所以CF=0</li>
<li>当D9是表示有符号位时，因为AL能存的最大的有符号数是7F，而D9&gt;7F，说明溢出了，OF=1</li>
</ul>
</li>
<li>在任何时候，处理器都不可能知道你的意图，不知道你进行的是有符号数运算，还是无符号数运算。因此，它所能做的，就是假定进行的是有符号数运算，并根据结果提供OF标志，至于如何处理，是你自己的事。比如说，如果你进行的是无符号数运算，那么，你可以不用理会该标志。</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ah, 0x70</span><br><span class="line">add ah, ah</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，本次相加，用二进制数来说就是 01110000+01110000=11100000，最高位没有进位，故CF=0。 </li>
<li>其次，从无符号数的角度来看（十进制），即112+112=224，并未超出一个字节所能容纳的数值上限255，结果是正确的。 </li>
<li>但是，从有符号数运算的角度来看（十进制），即112+112=-32，两正数相加，结果为负，明显是错的，在这种情况下，OF=1。错误的原因是，两个正数112和112相加，理论上的计算结果224超出了寄存器AH 所能容纳的有符号数的范围-128～127，所以破坏了符号位，使得结果变成了负数（-32）</li>
</ol>
</blockquote>
<h2 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h2><p>adc：add with carry，带进位加法，它利用了CF位上的进位值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1, 操作对象2</span><br></pre></td></tr></table></figure>

<ul>
<li>功能：<code>操作对象1 = 操作对象1 + 操作对象2 + CF</code></li>
<li>例如：<code>adc ax, bx</code>实现的功能是：<code>(ax)=(ax)+(bx)+CF</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 2</span><br><span class="line">mov bx, 1</span><br><span class="line">sub bx, ax</span><br><span class="line">adc ax, 1 ; 执行后，(ax)=4。adc执行时，相当于计算：(ax)+1+CF = 2+1+1 = 4</span><br></pre></td></tr></table></figure>



<p>为什么要加上CF的值呢？CPU为什么要提供这样一条指令呢？</p>
<blockquote>
<p>CF的值的含义：在执行adc指令的时候加上的<strong>CF的值的含义，是由adc指令前面的指令决定的</strong>，也就是说，关键在于所加上的CF值是被什么指令设置的。</p>
<ul>
<li>如果CF的值是被sub指令设置的，那么它的含义就是借位值。</li>
<li>如果是被add指令设置的，那么它的含义就是进位值。</li>
</ul>
<p>我们来看一下两个数据：0198H和0183H如何相加的：</p>
<p><img src="/images/image-20211214214438101.png" alt="image-20211214214438101"></p>
<p>可以看出，加法可以分两步来进行：</p>
<ol>
<li>低位相加。</li>
<li>高位相加再加上低位相加产生的进位值。</li>
</ol>
<p><strong>CPU提供adc指令的目的，就是来进行加法的第二步运算的</strong>。</p>
</blockquote>
<p><strong>adc指令和add指令相配合就可以对更大的数据进行加法运算</strong>。</p>
<p>编程，计算1EF000H+201000H，结果放在ax(高16位)和bx(低16位)中。</p>
<p>因为两个数据的位数都大于16，用add指令无法进行计算。我们将计算分两步进行，<code>先将低16位相加，然后将高16位和进位值相加</code>。程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 001EH</span><br><span class="line">mov bx, 0F000H</span><br><span class="line">add bx, 1000H</span><br><span class="line">adc ax, 0020H</span><br></pre></td></tr></table></figure>



<p>编程，计算1EF0001000H+2010001EF0H，结果放在ax（最高16位），bx（次高16位），cx（低16位）中：</p>
<p>计算分3步进行：</p>
<ol>
<li>先将低16位相加，完成后，CF中记录本次相加的进位值；</li>
<li>再将次高16位和CF（来自低16位的进位值）相加，完成后，CF中记录本次相加的进位值；</li>
<li>最后高16位和CF（来自次高16位的进位值）相加，完成后，CF中记录本次相加的进位值。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 001EH</span><br><span class="line">mov bx, 0F000H</span><br><span class="line">mov cx, 1000H</span><br><span class="line">add cx, 1EF0H</span><br><span class="line">adc bx, 1000H</span><br><span class="line">adc ax, 0020H</span><br></pre></td></tr></table></figure>



<p>编写一个子程序，对两个128位数据进行相加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">; 参数：ds:si指向存储第一个数的内存空间，因数据为128位，所以需要8个字单元由低地址单元到高地址单元依次存放128位数据由低到高的各个字。运算结果存储在第一个数的存储空间中。</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment</span><br><span class="line">		db 88H,88H,88H,88H,88H,88H,88H,88H,88H,88H,88H,88H,88H,88H,88H,88H</span><br><span class="line">		db 11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 0</span><br><span class="line">        mov di, 16</span><br><span class="line"></span><br><span class="line">        mov cx, 8</span><br><span class="line">        call add128</span><br><span class="line">        mov ax, 4c00H</span><br><span class="line">	      int 21H</span><br><span class="line"></span><br><span class="line">add128:	push ax</span><br><span class="line">        push cx</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line"></span><br><span class="line">        sub ax, ax		;将CF设置为0</span><br><span class="line">s:      mov ax, [si]</span><br><span class="line">        adc ax, [di]</span><br><span class="line">        mov [si], ax</span><br><span class="line">        inc si</span><br><span class="line">        inc si</span><br><span class="line">        inc di</span><br><span class="line">        inc di</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h2><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sbb 操作对象1, 操作对象2</span><br><span class="line">; 功能：操作对象1 = 操作对象1 - 操作对象2 -CF</span><br><span class="line">; sbb ax，bx 实现的功能是：（ax）=（ax）-（bx）- CF</span><br></pre></td></tr></table></figure>



<p>sbb指令执行后，将对CF进行设置。<strong>利用sbb指令可以对任意大的数据进行减法运算</strong>。</p>
<p>比如，计算003E1000H-00202000H，结果放在ax,bx中，程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H</span><br><span class="line">mov ax, 003EH</span><br><span class="line">sub bx, 2000H</span><br><span class="line">sbb ax, 0020H</span><br></pre></td></tr></table></figure>



<h2 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h2><ul>
<li><p>cmp是比较指令，<strong>cmp的功能相当于减法指令，只是不保存结果</strong>。</p>
</li>
<li><p>cmp指令执行后，将<strong>对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1, 操作对象2</span><br><span class="line">; cmp ax,ax  </span><br><span class="line">; 指令执行后：zf=l，pf=l，sf=0，cf=0，of=0</span><br></pre></td></tr></table></figure></li>
<li><p>总结该指令，对于<code>cmp ax,bx</code>的情况：</p>
<ul>
<li>如果（ax）=（bx）则（ax）-（bx）= 0，所以：zf=l；</li>
<li>如果（ax）≠（bx）则（ax）-（bx）≠ 0，所以：zf=0；</li>
<li>如果（ax）&lt;（bx）则（ax）-（bx）将产生借位，所以：cf=l:</li>
<li>如果（ax）≥（bx）则（ax）-（bx）不必借位，所以：cf=0；</li>
<li>如果（ax）&gt;（bx）则（ax）-（bx）既不必借位，结果又不为0，所以：cf=0并且zf=0:</li>
<li>如果（ax）≤（bx）则（ax）-（bx）既可能借位，结果可能为0，所以：cf=l或zf=1。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>cmp 操作对象1,  操作对象2</code>指令执行后，sf=l，就说明 操作对象1&lt;操作对象2?</p>
<ul>
<li>不行。(ah)=22H，(bh)=0A0H：则(ah)-(bh) = 34-(-96) = 82H，82H是-126的补码，所以sf=1。</li>
<li><strong>所得到的相应结果的正负，并不能说明运算所应该得到的结果的正负</strong>。这是因为在运算的过程中可能发生溢出。如果有这样的情况发生，那么，sf的值就不能说明任何问题。</li>
<li>同时对比<code>sf</code>和<code>of</code>就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。</li>
</ul>
</blockquote>
<h2 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h2><ul>
<li><code>转移</code>指的是它能够修改IP，而<code>条件</code>指的是它可以根据某种条件，决定是否修改IP。</li>
<li><strong>大多数条件转移指令都检测标志寄存器的相关标志位的结果来决定是否修改IP</strong>。</li>
<li>所以，这些条件转移指令通常都和cmp相配合使用。</li>
<li>因为cmp指今可以同时进行两种比较，<code>无符号数比较</code>和<code>有符号数比较</code>，所以根据cmp指令的比较结果进行转移的指令也分为<code>根据无符号数的比较结果进行转移的条件转移指令</code>和<code>根据有符号数的比较结果进行转移的条件转移指令</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>nb：not below</li>
<li>na：not above</li>
</ul>
</blockquote>
<p>编程实现如下功能：如果（ah）-（bh）则（ah）-（ah）+（ah），否则（ah）=（ah）+ (bh）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 		cmp ah, bh</span><br><span class="line">    je s</span><br><span class="line">    add ah, bh</span><br><span class="line">    jmp short ok</span><br><span class="line">s : add ah, ah</span><br><span class="line">ok: ...</span><br></pre></td></tr></table></figure>



<p>编程：统计data段中数值为8的字节的个数，用ax保存统计结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db 8,11,8,1,8,5,63,38</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov ax, data</span><br><span class="line">      	mov ds, ax</span><br><span class="line">        mov bx, 0			;ds:bx指向第一个字节</span><br><span class="line">        mov ax, 0			;初始化累加器</span><br><span class="line">        mov cx, 0</span><br><span class="line"></span><br><span class="line">s:		  cmp byte ptr [bx], 8 ;和8进行比较</span><br><span class="line">				jne next			;如果不相等转到next，继续循环 jne : jmp not equal</span><br><span class="line">				inc ax				;如果相等就将计数值加1</span><br><span class="line">		</span><br><span class="line">next:		inc bx</span><br><span class="line">				loop s				;程序执行后：(ax)=3</span><br><span class="line">		</span><br><span class="line">        mov ax, 4C00H</span><br><span class="line">        int 21H</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h2><p>DF：definition flag，方向标志位。在串处理指令中，控制每次操作后si 、di 的增减。</p>
<ul>
<li>df=0：每次操作后si、di 递增</li>
<li>df=1：每次操作后si、di 递减</li>
</ul>
<blockquote>
<p><code>movesb</code>指令：move string byte，功能是<strong>将ds:si指向的内存单元中的字节送入es:di中</strong>，然后根据标志寄存器df位的值，将si和d递增或递减。</p>
<p>相当于执行如下步骤：</p>
<ol>
<li><code>((es)*16+(di))=((ds)*16+(si))</code></li>
<li>如果df=0 则： (si)=(si)+1; (di)=(di)+1</li>
<li>如果df=1 则： (si)=(si)-1; (di)=(di)-1</li>
</ol>
<p>用汇编语法描述<code>movsb</code>的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov es:[di], byte ptr ds:[si] ; 8086并不支持这样的指令，这里只是个描述</span><br><span class="line">; 如果df=0:</span><br><span class="line">inc si</span><br><span class="line">inc di</span><br><span class="line">; 如果df=1:</span><br><span class="line">dec si</span><br><span class="line">dec di</span><br></pre></td></tr></table></figure>

<p>同理有movsw指令：move string word，功能<strong>是将ds:si指向的内存字单元中的字送入es:di 中</strong>，然后根据标志寄存器df位的值，将si和di 递增2或递减2 。</p>
<p>用汇编语法描述<code>movsw</code>的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov es:[di],word ptr ds:[si] ; 8086并不支持这样的指令，这里只是个描述</span><br><span class="line">; 如果df=0:</span><br><span class="line">add si,2</span><br><span class="line">add di,2</span><br><span class="line">; 如果df=1:</span><br><span class="line">sub si,2</span><br><span class="line">sub di,2</span><br></pre></td></tr></table></figure>



<p>movsb和movsw进行的是<strong>串传送操作中的一个步骤</strong>，</p>
<p>一般来说， movsb和movsw都和rep配合使用，格式为：<code>rep movsb</code></p>
<p>用汇编语法来描述rep movsb的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s: movsb</span><br><span class="line">   loop s</span><br></pre></td></tr></table></figure>

<p>rep的作用是根据cx的值，重复执行后面的<code>串传送指令</code>。由于每执行一次movsb指令si和di会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。</p>
<p>同理，也可以使用这样的指令： rep movsw。相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s: movsw  </span><br><span class="line">	 loop s</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由于flag的<code>df</code>位决定着串传送指令执行后si和di改变的方向，所以CPU应该提供相应的指令来对df位进行设置，从而使程序员能够决定传送的方向。</p>
<ul>
<li>cld指令：<strong>clear direction</strong>，df置为0</li>
<li>std指令：<strong>set direction</strong>，df置为1</li>
</ul>
<p>将data段中的第一个字符串复制到它后面的空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">  db &#x27;Welcome to masm!&#x27;</span><br><span class="line">  db 16 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">  mov ax,data</span><br><span class="line">  mov ds,ax</span><br><span class="line">  mov si,0    ; ds:si指向data:0</span><br><span class="line">  </span><br><span class="line">  mov es,ax</span><br><span class="line">  mov di,16   ; es:di指向data:0010</span><br><span class="line">  </span><br><span class="line">  mov cx,16   ; (ex)=16,rep循环16次</span><br><span class="line">  cld         ; 设置df=0，正向传送</span><br><span class="line">  rep movsb</span><br><span class="line"></span><br><span class="line">  mov ax, 4C00H</span><br><span class="line">  int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h2><p><code>pushf</code>和<code>popf</code>，为<strong>直接访问标志寄存器</strong>提供了一种方法。</p>
<ul>
<li>pushf的功能是将标志寄存器的值压栈，</li>
<li>popf是从栈中弹出数据，送入标志寄存器中。</li>
</ul>
<p><img src="/images/b6d19390-image-20211214144230093.png" alt="image-20211214144230093"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">push ax				</span><br><span class="line">popf	; 执行后标志寄存器的16位都是零</span><br><span class="line"></span><br><span class="line">mov ax,0fff0h</span><br><span class="line">add ax,0010h ; add完后结果是10000H，显然无符号数计算有进位，所以CF=1,无符号数对OF不起作用，所以OF=0，值未变，SF=0，PF=1，ZF=1，DF=0，所以该指令执行完毕后，标志寄存器为：0000 0000 0100 0101</span><br><span class="line"></span><br><span class="line">pushf	  ; 将标志寄存器的值压栈</span><br><span class="line">pop ax	; 即将压入栈中的标志寄存器的值弹出给ax,此时AX=0000 0000 0100 0101</span><br><span class="line">and al,11000101b	; 执行完毕后，al=0100 0101 = 45H</span><br><span class="line">and ah,00001000b	; 执行完毕后，ah=0000 0000 = 00H,所以AX=0045H</span><br></pre></td></tr></table></figure>

<p>程序执行后：（ax）= 0045H</p>
<h2 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a>标志寄存器在Debug中的表示</h2><p>标志寄存器的值在Debug中是用英文字母表示的</p>
<p><img src="/images/1208477-20200609142951956-1083638180.png" alt="img"></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>值为1</th>
<th>值为0</th>
</tr>
</thead>
<tbody><tr>
<td>OF溢出标志位</td>
<td>OV(overflow溢出）</td>
<td>NV(not over没有溢出）</td>
</tr>
<tr>
<td>SF符号标志位</td>
<td>NG(negative负数）</td>
<td>PL(plus正数）</td>
</tr>
<tr>
<td>ZF零标志位</td>
<td>ZR（zero零）</td>
<td>NZ（not zero非零）</td>
</tr>
<tr>
<td>PF奇偶标志位</td>
<td>PE（plus加起来even偶数）</td>
<td>PO（plus加起来odd奇数）</td>
</tr>
<tr>
<td>CF进位标志符</td>
<td>CY（carry有借进位）</td>
<td>NC（not carry没有借进位）</td>
</tr>
<tr>
<td>DF方向标志位</td>
<td>DN (down）</td>
<td>UP(up）</td>
</tr>
</tbody></table>
<p>编写一个子程序，将包含任意字符，以0结尾的字符串中的小写字母转变成大写字母：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    db &quot;Beginner&#x27;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">begin:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">    call letterc</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">;名称：letterc</span><br><span class="line">;功能：将以0结尾的字符串中的小写字母转变为大写字母</span><br><span class="line">;参数：ds:si指向字符串首地址</span><br><span class="line">letterc:</span><br><span class="line">    push cx</span><br><span class="line">    pushf</span><br><span class="line">    </span><br><span class="line">    mov cx,0</span><br><span class="line">s1:</span><br><span class="line">    mov cl,ds:[si]</span><br><span class="line">    jcxz ok</span><br><span class="line">    cmp cl,61h</span><br><span class="line">    jb nextgo</span><br><span class="line">    cmp cl,7ah</span><br><span class="line">    ja nextgo</span><br><span class="line">    and cl,0dfh</span><br><span class="line">    mov ds:[si],cl</span><br><span class="line">nextgo:</span><br><span class="line">    inc si</span><br><span class="line">    jmp short s1</span><br><span class="line">ok:</span><br><span class="line">    popf</span><br><span class="line">    pop cx</span><br><span class="line">    ret</span><br><span class="line">code ends</span><br><span class="line">end begin</span><br></pre></td></tr></table></figure>

<h1 id="第12章-内中断"><a href="#第12章-内中断" class="headerlink" title="第12章 内中断"></a>第12章 内中断</h1><ul>
<li>任何一个通用的CPU都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。</li>
<li>这种特殊的信息，我们可以称其为：<code>中断信息</code>。中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。</li>
</ul>
<h2 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h2><p>内中断主要有四种：</p>
<ul>
<li>除法错误，比如，执行div指令产生的除法溢出</li>
<li>单步执行</li>
<li>执行into 指令</li>
<li>执行int 指令</li>
</ul>
<h2 id="中断类型码"><a href="#中断类型码" class="headerlink" title="中断类型码"></a>中断类型码</h2><ul>
<li>对于不同的中断需要进行不同处理。要进行不同的处理，CPU首先要知道，所接收到的中断信息的来源（简称为<code>中断源</code>）。所以中断信息中必须包含识别来源的编码。8086CPU用称为<code>中断类型码</code>的数据来标识中断信息的来源。</li>
<li>中断类型码识别为<strong>一个字节</strong>型数据，可以表示256种中断信息的来源。</li>
<li>中断类型如下：<ul>
<li>除法错误：0</li>
<li>单步执行：1</li>
<li>执行into指令：4</li>
<li>执行int指令，该指令的格式为 int n，指令中的n位字节型立即数，是提供给CPU的中断类型码</li>
</ul>
</li>
</ul>
<h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><ul>
<li>CPU收到中断信息后，需要对中断信息进行处理。而如何对中断信息进行处理，可以由我们编程决定。我们编写的，用来处理中断信息的程序被称为<code>中断处理程序</code>。</li>
<li>CPU在收到中断信息后，应该转去执行该中断信息的处理程序。若要8086CPU执行某处的程序，就要将CS：IP指向它的入口（即程序第一条指令的地址）。CPU在接收到中断信息后，如何根据中断信息确定其处理程序的入口。</li>
<li>所以必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。</li>
<li><strong>中断类型码的作用就是用来定位中断处理程序</strong>。比如CPU根据中断类型码4，就可以找到4号中断的处理程序。</li>
<li>可随之而来的问题是：若要定位中断处理程序，需要知道它的段地址和偏移地址，而如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢，这时需要使用到<code>中断向量表</code></li>
</ul>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><ul>
<li>中断向量：就是<strong>中断处理程序的入口地址</strong>。</li>
<li>中断向量表：就是中断处理程序入口地址的列表。</li>
<li>CPU用中断类型码，通过查找中断向量表，就可以得到中断处理程序的入口地址。</li>
<li>中断向量表在内存中存放，对于8086PC机，中断向量表指定<strong>放在内存地址0处</strong>。从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。</li>
<li>在中断向量表中，一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU，这个入口地址<strong>包括段地址和偏移地址</strong>，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</li>
</ul>
<p><img src="/images/image-20211215132012759.png" alt="image-20211215132012759"></p>
<p>用debug查看内存，情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000:0000 68 10 A7 00 8B 01 70 00-16 00 9D 03 8B 01 70 00</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0号：00A7：1068</span><br><span class="line">1号：0070：108B</span><br><span class="line">2号：039D：0016</span><br><span class="line">3号：0070：108B</span><br></pre></td></tr></table></figure>



<h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><ul>
<li>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为<code>中断过程</code>。</li>
<li>8086CPU在收到中断信息后，所引发的中断过程：<ol>
<li>(从中断信息中)取得中断类型码；</li>
<li>标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)；</li>
<li>设置标志寄存器的第8位TF和第9位IF的值为0；</li>
<li>CS的内容入栈；</li>
<li>IP的内容入栈；</li>
<li>从内存地址为 <code>中断类型码×4</code> 和 <code>中断类型码×4+2</code> 的两个字单元中读取中断处理程序的入口地址设置IP和CS。</li>
</ol>
</li>
<li>我们更简洁地描述中断过程，如下：<ol>
<li>取得中断类型码N；</li>
<li>pushf</li>
<li>TF=0，IF=0</li>
<li>push CS</li>
<li>push IP</li>
<li><code>(IP)=(N*4)，(CS)=(N*4+2)</code></li>
</ol>
</li>
</ul>
<blockquote>
<p>CPU现场：某一时刻，CPU中各个寄存器的值。</p>
</blockquote>
<h2 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h2><p>由于CPU随时都可能检测到中断信息，也就是说CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p>
<p>中断处理程序的编写方法<strong>和子程序的相似</strong>，下面是常规的步骤：</p>
<ol>
<li>保存用到的寄存器；</li>
<li>处理中断；</li>
<li>恢复用到的寄存器；</li>
<li>用iret指令返回。</li>
</ol>
<p>iret（<code>interrupt return</code>）指令的功能用汇编语法描述为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>

<ul>
<li>iret通常和硬件自动完成的中断过程配合使用。</li>
<li>在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其相对应。</li>
</ul>
<h2 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h2><ul>
<li>0号中断，即除法错误中断的处理。</li>
<li>当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。</li>
<li>现在希望重新编写一个0号中断处理程序，它的功能是在屏幕中间显示“overflow!”，然后返回到操作系统</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000h</span><br><span class="line">mov bh,1</span><br><span class="line">div bh</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211215191044028.png" alt="image-20211215191044028"></p>
<p>当发生除法溢出的时候，产生0号中断信息，从而引发中断过程。</p>
<p>此时，CPU将进行以下工作。</p>
<ol>
<li>取得中断类型码0</li>
<li>标志寄存器入栈，TF、圧设置为0</li>
<li>CS、IP入栈</li>
<li>(IP)=(0x4)，(CS)=(0x4+2)</li>
</ol>
<p>当中断0发生时，CPU将转去执行中断处理程序。</p>
<ol>
<li>相关处理</li>
<li>向显示缓冲区送字符串“overflow!”</li>
<li>返回DOS</li>
</ol>
<p>我们暂时将这段程序称为：do0，我们可以将do0的代码放在内存0000:0200处。若要使得除法溢岀发生的时候，CPU转去执行do0，则必须将do0的入口地址，即0000:0200登记在中断向量表的对应表项中。</p>
<p>所以，我们要做以下几件事情：</p>
<ol>
<li>编写可以显示“overflow!”的中断处理程序：do0；</li>
<li>将do0送入内存0000:0200处；</li>
<li>将do0的入口地址0000:0200存储在中断向量表0号表项中。</li>
</ol>
<p>所以，程序的框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  do0安装程序</span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">        </span><br><span class="line"> do0:   显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面代码执行时，do0的代码是不执行的，它只是作为do0安装程序所要传送的数据。程序执行时：</p>
<ol>
<li>首先执行do0安装程序：<strong>将do0的代码复制到内存0:200处，</strong></li>
<li>然后设置中断向量表：<strong>将do0的入口地址，即偏移地址200H和段地址0，保存在0号表项中。</strong></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以使用movsb指令，将do0的代码送入0:200处。</p>
<p>框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  设置es:di指向目的地址</span><br><span class="line">        设置ds:si指向源地址</span><br><span class="line">        设置cx为传输长度</span><br><span class="line">        设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    do0:显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0       ;设置ds:si指向源地址</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h     ;设置es :di指向目的地址</span><br><span class="line"></span><br><span class="line">        mov cx,offset do0end-offset do0     ;设置cx为传输长度</span><br><span class="line"></span><br><span class="line">        cld     ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">   do0 :显示字符串&quot;overflow!”</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0end:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-</code> 是编译器识别的运算符号，编译器可以用它来进行两个常数的减法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8-4 ; 等同于 mov ax,4</span><br><span class="line">mov ax,(5+3)x5/10 ; 等同于 mov ax,4</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h2><p>do0程序的主要任务是显示字符串，程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">do0:   设置ds:si指向字符串</span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,12*160+36*2      ;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">        mov cx,9        ;设置cx为字符串长度</span><br><span class="line"></span><br><span class="line">s:      mov al,[si]</span><br><span class="line">        mov es:[di],al</span><br><span class="line">        inc si</span><br><span class="line">        add di,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0end:	nop</span><br></pre></td></tr></table></figure>



<p>所以，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0  ;设置ds:si指向源地址</span><br><span class="line">        </span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h     ;设置es:di指向目的地址</span><br><span class="line">        </span><br><span class="line">        mov cx,offset do0end-offset do0    ;设置cx为传输长度 </span><br><span class="line">        cld             ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line">        </span><br><span class="line">        mov ax, 0       ; 设置中断向量表</span><br><span class="line">				mov es, ax</span><br><span class="line">				mov word ptr es:[0*4], 200h</span><br><span class="line">				mov word ptr es:[0*4+2], 0</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0:    jmp short do0start</span><br><span class="line">        db &quot;overflow!&quot;  ;将“overflow!”放到do0程序中</span><br><span class="line"></span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,202h     ;设置ds:si指向字符串</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,12*160+36*2      ;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">        mov cx,9        ;设置cx为字符串长度</span><br><span class="line"></span><br><span class="line">    s:  mov al,[si]</span><br><span class="line">        mov es:[di],al</span><br><span class="line">        inc si</span><br><span class="line">        add di,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，因为在<strong>do0程序开始处的“overflow!”不是可以执行的代码</strong>，所以在“overflow!”之前加上一条jmp指令，转移到正式的do0程序。当除法溢出发生时，CPU执行0:200处的jmp指令，跳过后面的字符串，转到正式的do0程序执行。</p>
<p>do0程序执行过程中必须要找到“overflow!”，那么它在哪里呢？</p>
<p>首先来看段地址，“overflow!”和do0的代码处于同一个段中，而除法溢出发生时，CS中必然存放do0的段地址，也就是”overflow!”的段地址；再来看偏移地址，0:200处的指令为jmp short do0start，这条指令占两个字节，所以”overflow!”的偏移地址为202h。</p>
</blockquote>
<h2 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h2><ul>
<li>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。</li>
<li>单步中断的中断类型码为1，则它所引发的中断过程如下。<ol>
<li>取得中断类型码1</li>
<li>标志寄存器入栈，TF、IF设置为0</li>
<li>CS、IP入栈</li>
<li>(IP)=(1x4)，(CS)=(1x4+2)</li>
</ol>
</li>
<li>如上所述，如果TF=1，则执行一条指令后，CPU就要转去执行1号中断处理程序。所以单步中断经常被用来DEBUG</li>
</ul>
<h2 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h2><ul>
<li><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断引发中断过程。</p>
</li>
<li><p>在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应。</p>
</li>
<li><p>eg：在执行完向ss寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; right</span><br><span class="line">mov ax,1000h</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0</span><br><span class="line"></span><br><span class="line">; wrong</span><br><span class="line">mov ax,1000h</span><br><span class="line">mov ss,ax</span><br><span class="line">mov ax,0</span><br><span class="line">mov sp,0</span><br></pre></td></tr></table></figure></li>
<li><p>这就能解释使用<code>-t</code>时，会跳过<code>mov sp,10</code>这条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 2000</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp,10</span><br><span class="line"></span><br><span class="line">mov ax,3123</span><br><span class="line">push ax</span><br><span class="line">mov ax,3366</span><br><span class="line">push ax</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20211216121222413.png" alt="image-20211216121222413"></p>
</li>
</ul>
<p>编写0号中断的处理程序，使得在除法溢出发生时，在屏幕中间显示字符串“divide error！”，然后返回dos：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">   start:   mov ax,cs</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,offset do0                   ;设置 ds:si 指向源地址</span><br><span class="line">            mov ax,0                            </span><br><span class="line">            mov es,ax                           </span><br><span class="line">            mov di,0200h                        ;设置 es:di 指向目的地址</span><br><span class="line"></span><br><span class="line">            mov cx,offset do0end-offset do0     ;设置 cx 为传输长度（利用编译器来计算 do0 的长度）</span><br><span class="line"></span><br><span class="line">            cld                                 ;设置传输方向为正</span><br><span class="line">            rep movsb                           ;串传送操作</span><br><span class="line"></span><br><span class="line">            mov ax,0</span><br><span class="line">            mov es,ax</span><br><span class="line">            mov word ptr es:[0*4],200h</span><br><span class="line">            mov word ptr es:[0*4+2],0           ;设置中断向量表</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line">      </span><br><span class="line">     do0:   jmp short do0start                  ;这条指令占两个字节</span><br><span class="line">            db &quot;divide error!&quot;</span><br><span class="line">      </span><br><span class="line">do0start:   mov ax,cs</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,202h                         ;设置 ds:si 指向字符串</span><br><span class="line"></span><br><span class="line">            mov ax,0b800h                 </span><br><span class="line">            mov es,ax</span><br><span class="line">            mov di,12*160+33*2                  ;设置 es:di 指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">            mov cx,13                           ;设置 cx 为字符串长度</span><br><span class="line"></span><br><span class="line">       s:   mov al,ds:[si]</span><br><span class="line">            mov es:[di],al                      ;将字符串送入显存空间，默认黑底白字</span><br><span class="line">            inc si</span><br><span class="line">            add di,2</span><br><span class="line">            loop s</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">  do0end:   nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h1 id="第十三章-int指令"><a href="#第十三章-int指令" class="headerlink" title="第十三章 int指令"></a>第十三章 int指令</h1><ul>
<li><p> 中断信息可以来自CPU的内部和外部，当CPU的内部有需要处理的事情发生的时候，将产生需要马上处理的中断信息，引发中断过程。</p>
</li>
<li><p>int指令引发内中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int n ; n为中断类型码</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov byte ptr es:[12*160+40*2],&#x27;!&#x27;</span><br><span class="line">        int 0</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li>
<li><p>CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下：</p>
<ol>
<li>取中断类型码n</li>
<li>标志寄存器入栈，IF=0，TF=0</li>
<li>CS入栈</li>
<li>IP入栈</li>
<li>(IP)=(n×4)，(CS)=(n×4+2)</li>
</ol>
</li>
<li><p>也就是，int指令相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pushf</span><br><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp xxxx:xxxx</span><br></pre></td></tr></table></figure></li>
<li><p>将中断处理程序简称为<code>中断例程</code>。</p>
</li>
</ul>
<h2 id="编写供应用程序调用的中断例程"><a href="#编写供应用程序调用的中断例程" class="headerlink" title="编写供应用程序调用的中断例程"></a>编写供应用程序调用的中断例程</h2><h3 id="示例一：求一word型数据的平方"><a href="#示例一：求一word型数据的平方" class="headerlink" title="示例一：求一word型数据的平方"></a>示例一：求一word型数据的平方</h3><ul>
<li>功能：编写、安装中断7ch的中断例程，求一word型数据的平方。</li>
<li>参数：(ax)=要计算的数据。</li>
<li>返回值：dx、ax中存放结果的高16位和低16位。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,3456       ;(ax)=3456</span><br><span class="line">        int 7ch           ;调用中断7ch的中断例程，计算ax中的数据的平方</span><br><span class="line">        add ax,ax</span><br><span class="line">        adc dx,dx         ;dx:ax存放结果，将结果乘以2</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>分析一下，我们要做以下3部分工作。</p>
<ol>
<li>编写实现求平方功能的程序；</li>
<li>安装程序，将其安装在0:200处；</li>
<li>设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        </span><br><span class="line">        mov si,offset sqr       ; 设置ds:si指向源地址</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h             ; 设置es:di指向目的地址</span><br><span class="line">        </span><br><span class="line">        mov cx,offset sqrend-offset sqr     ; 设置cx为传输长度</span><br><span class="line">        cld                     ; 设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[7ch*4],200h</span><br><span class="line">        mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int21h</span><br><span class="line"></span><br><span class="line">sqr:    mul ax</span><br><span class="line">        iret</span><br><span class="line"></span><br><span class="line">sqrend:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="示例二：将一个全是字母，以0结尾的字符串，转化为大写"><a href="#示例二：将一个全是字母，以0结尾的字符串，转化为大写" class="headerlink" title="示例二：将一个全是字母，以0结尾的字符串，转化为大写"></a>示例二：将一个全是字母，以0结尾的字符串，转化为大写</h3><ul>
<li>功能：编写、安装中断7ch的中断例程，将一个全是字母，以0结尾的字符串，转化为大写。</li>
<li>参数：ds:si指向字符串的首地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;conversation&#x27;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        int 7ch</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>安装程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        </span><br><span class="line">        mov si,offset capital</span><br><span class="line">        mov ax,0</span><br><span class="line">        </span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h</span><br><span class="line">        </span><br><span class="line">        mov cx,offset capitalend-offset capital</span><br><span class="line">        cld</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[7ch*4],200h</span><br><span class="line">        mov word ptr es: [7ch*4+2],0</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">capital:push cx</span><br><span class="line">        push si</span><br><span class="line"></span><br><span class="line">change: mov cl,[si]</span><br><span class="line">        mov ch,0</span><br><span class="line">        jcxz ok</span><br><span class="line">        and byte ptr [si],11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp short change</span><br><span class="line"></span><br><span class="line">    ok: pop si</span><br><span class="line">        pop cx</span><br><span class="line">        iret</span><br><span class="line"></span><br><span class="line">capitalend:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="对int、iret和栈的深入理解"><a href="#对int、iret和栈的深入理解" class="headerlink" title="对int、iret和栈的深入理解"></a>对int、iret和栈的深入理解</h2><h3 id="模仿loop指令"><a href="#模仿loop指令" class="headerlink" title="模仿loop指令"></a>模仿loop指令</h3><ul>
<li><p>问题：用7ch中断例程完成loop指令的功能。</p>
</li>
<li><p>loop s的执行需要两个信息，循环次数和到s的位移，所以7ch中断例程要完成loop指令的功能，也需要这两个信息作为参数：</p>
<ul>
<li><strong>用cx存放循环次数</strong></li>
<li><strong>用bx存放位移</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	 mov ax,2</span><br><span class="line">	 </span><br><span class="line">	 mov cx,4</span><br><span class="line">s: add ax,ax</span><br><span class="line">   loop s</span><br><span class="line">	</span><br><span class="line">	 mov ax,4c00h</span><br><span class="line">	 int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ul>
<p>应用举例：在屏幕中间显示80个“!”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,160*12</span><br><span class="line"></span><br><span class="line">        mov bx,offset s-offset se     ; 设置从标号se到标号s的转移位移</span><br><span class="line">        mov cx,80</span><br><span class="line"></span><br><span class="line">    s:  mov byte ptr es:[di], &#x27;!&#x27;</span><br><span class="line">        add di, 2</span><br><span class="line">        int 7ch     ; 如果(cx)不等于0,转移到标号s处</span><br><span class="line"></span><br><span class="line">   se:  nop</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li><p>为了模拟loop指令，7ch中断例程应具备下面的功能。</p>
<ul>
<li>dec cx；</li>
<li>如果(cx)不等于0，转到标号s处执行，否则向下执行。</li>
</ul>
</li>
<li><p>如何获取位移？</p>
<ul>
<li>int 7ch引发中断过程后，进入7ch中断例程，在中断过程中，当前的标志寄存器、CS和IP都要压栈，此时压入的CS和IP中的内容，分别是调用程序的段地址(可以认为是标号S的段地址)和<strong>int 7ch后一条指令的偏移地址</strong>(即标号se的偏移地址)。</li>
<li>可见，在中断例程中，可以从栈里取得标号s的段地址和标号se的偏移地址，而<strong>用标号se的偏移地址加上bx中存放的转移位移就可以得到标号s的偏移地址</strong>。</li>
</ul>
</li>
<li><p>从栈中直接和间接地得到标号s的段地址和偏移地址后，如何设置CS:IP？</p>
<ul>
<li>利用iret指令，我们将栈中的se的偏移地址加上bx中的转移位移，则栈中的se的偏移地址就变为了s的偏移地址。我们再使用iret指令，用栈中的内容设置CS、IP，从而实现转移到标号s处。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   lp:  push bp    ; 因为要访问栈，使用了bp，在程序开始处将bp入栈保存，结束时出栈恢复</span><br><span class="line">        mov bp,sp</span><br><span class="line">        </span><br><span class="line">        dec cx</span><br><span class="line">        jcxz Ipret</span><br><span class="line">        </span><br><span class="line">        add [bp+2], bx ; 此时bx保存了从标号se到标号s的转移位移</span><br><span class="line"></span><br><span class="line">Ipret:  pop bp</span><br><span class="line">        iret</span><br></pre></td></tr></table></figure>

<ul>
<li>当要修改栈中se的偏移地址的时候，栈中的情况为：栈顶处是bp原来的数值，下面是se的偏移地址(原IP)，再下面是s的段地址(原CS)，再下面是标志寄存器的值(FLAG)。</li>
<li>而此时，bp中为栈顶的偏移地址，所以**<code>((ss)×16+(bp)+2)</code>处为se的偏移地址(原IP)**，将它加上bx中的转移位移就变为s的偏移地址。最后用iret岀栈返回，CS:IP即从标号s处开始执行指令。</li>
</ul>
</li>
</ol>
<p>在上面内容中，我们用7ch中断例程实现<code>loop</code>的功能，则上面的7ch中断例程所能进行的最大转移位移是多少？</p>
<p>位移的转移是通过<code>bx</code>中存储的<code>offset</code>来实现的，因此理论上来说，最大转移位移取决于<code>bx</code>中数据的大小，而<code>bx</code>是一个16位的寄存器，最大值为<code>65535</code>。</p>
<h3 id="模仿jmp-near-ptr-s指令"><a href="#模仿jmp-near-ptr-s指令" class="headerlink" title="模仿jmp near ptr s指令"></a>模仿jmp near ptr s指令</h3><p>用7ch中断例程完成<code>jmp near ptr s</code>指令的功能，用bx向中断例程传送转移位移。</p>
<p>应用举例：在屏幕的第12行，显示data段中以0结尾的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">  db &#x27;conversation&#x27;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,cs   ; 移动代码</span><br><span class="line">	mov ds,ax </span><br><span class="line">	</span><br><span class="line">	mov si,offset jmpst</span><br><span class="line">	</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov di,200h</span><br><span class="line">	</span><br><span class="line">	mov cx,offset jmpe - offset jmpst</span><br><span class="line">	cld</span><br><span class="line">	rep movsb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mov ax,0  ; 安装</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov word ptr es:[7ch*4],200h</span><br><span class="line">	mov word ptr es:[7ch*4+2],0</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	mov ax,data  ; 显示</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov si,0</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov di,12*160+35*2</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">	cmp byte ptr [si], 0</span><br><span class="line">	je ok</span><br><span class="line">	mov al,ds:[si]</span><br><span class="line">	mov es:[di],al</span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	mov bx,offset s - offset ok</span><br><span class="line">	int 7ch    ; 转移到标号s处</span><br><span class="line">ok:</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">jmpst:       ; 模仿指令的代码 </span><br><span class="line">	push bp</span><br><span class="line">	mov bp,sp</span><br><span class="line">	add [bp+2],bx</span><br><span class="line">	pop bp</span><br><span class="line">	iret</span><br><span class="line">jmpe:	nop</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h2><p>在系统板的ROM中存放着一套程序，称为<code>BIOS</code>（基本输入输出系统），BIOS中主要包含以下几部分内容：</p>
<ul>
<li>硬件系统的检测和初始化程序</li>
<li><strong>外部中断和内部中断的中断例程</strong></li>
<li>用于对硬件设备进行IO操作的中断例程</li>
<li>其他和硬件系统相关的中断例程</li>
</ul>
<p>操作系统DOS也提供了中断例程，<strong>从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源</strong>。</p>
<p>BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。</p>
<p>和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p>
<h2 id="BIOS和DOS所提供的中断例程及安装过程"><a href="#BIOS和DOS所提供的中断例程及安装过程" class="headerlink" title="BIOS和DOS所提供的中断例程及安装过程"></a>BIOS和DOS所提供的中断例程及安装过程</h2><p>将BIOS和DOS提供的中断例程安装到内存，步骤如下：</p>
<ol>
<li>开机后，CPU一加电，初始化(CS)=0FFFFH，(IP)=0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</li>
<li>初始化程序将建立BIOS所支持的中断向量，即：将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，无需编写，因为它们是固化到ROM中的程序，一直在内存中存在。</li>
<li>硬件系统检测和初始化完成后，调用<code>int 19h</code>引导启动操作系统。从此将计算机交由操作系统控制。</li>
<li>DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</li>
</ol>
<h2 id="BIOS中断例程应用"><a href="#BIOS中断例程应用" class="headerlink" title="BIOS中断例程应用"></a>BIOS中断例程应用</h2><ul>
<li><code>int 10h</code>中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。</li>
<li>一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部<strong>用传递进来的参数来决定执行哪一个子程序</strong>。BIOS和DOS提供的中断例程，都用<code>ah</code>来传递内部子程序的编号。</li>
</ul>
<p>int 10h中断例程的设置光标位置功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,2   ; 置光标</span><br><span class="line">mov bh,0   ; 第0页</span><br><span class="line">mov dh,5   ; dh中放行号</span><br><span class="line">mov dl,12  ; dl中放列号</span><br><span class="line">int 10h</span><br></pre></td></tr></table></figure>

<ul>
<li>(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在的行号(80x25字符模式下：0~24)、列号(80x25字符模式下：0-79)，和页号作为参数。</li>
<li>(bh)=0，(dh)=5，(dl)=12，设置光标到第0页，第5行，第12列。</li>
</ul>
<p>再看一下int 10h中断例程的在光标位置显示字符功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ah,9   ; 在光标位置显示字符</span><br><span class="line">mov al,&#x27;a&#x27; ; 字符</span><br><span class="line">mov bl,7   ; 颜色属性</span><br><span class="line">mov bh,0   ; 第0页</span><br><span class="line">mov cx,3   ; 字符重复个数</span><br><span class="line">int 10h</span><br></pre></td></tr></table></figure>

<ul>
<li>(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。</li>
</ul>
<p>编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的“a”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">        mov ah,2        ;置光标</span><br><span class="line">        mov bh,0        ;第0页</span><br><span class="line">        mov dh,5        ;dh中放行号</span><br><span class="line">        mov dl,12       ;dl中放列号</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        mov ah,9        ;在光标位置显示字符</span><br><span class="line">        mov al,&#x27;a&#x27;      ;字符</span><br><span class="line">        mov bl,11001010b;颜色属性</span><br><span class="line">        mov bh,0        ;第0页</span><br><span class="line">        mov cx,3        ;字符重复个数</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="DOS中断例程应用"><a href="#DOS中断例程应用" class="headerlink" title="DOS中断例程应用"></a>DOS中断例程应用</h2><ul>
<li><p><code>int 21h</code>中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。</p>
</li>
<li><p>我们前面一直使用的是int 21h中断例程的4ch号功能，即<code>程序返回功能</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch  ; 程序返回</span><br><span class="line">mov al,0    ; 返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>

<p>(ah)=4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure></li>
<li><p>int21h中断例程在光标位置显示字符串的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:dx 指向字符串   ; 要显示的字符串需用&quot;$&quot;作为结束符</span><br><span class="line">mov ah,9         ; 功能号9,表示在光标位置显示字符串</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>

<p>(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</p>
</li>
</ul>
<p>编程：在屏幕的5行12列显示字符串”Welcome to masm!”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#x27;Welcome to masm&#x27;,&#x27;$&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ah,2        ;置光标</span><br><span class="line">        mov bh,0        ;第0页</span><br><span class="line">        mov dh,5        ;dh中放行号</span><br><span class="line">        mov dl,12       ;dl中放列号</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov dx,0        ;ds:dx指向字符串的首地址data:0</span><br><span class="line">        mov ah,9</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上述程序在屏幕的5行12列显示字符串”Welcome to masm!”，直到遇见”$” $本身并不显示，只起到边界的作用。</p>
<h1 id="第十四章-端口"><a href="#第十四章-端口" class="headerlink" title="第十四章 端口"></a>第十四章 端口</h1><ul>
<li><p>我们前面讲过，各种存储器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们都当作内存来对待，把它们总地看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器我们称其为<code>内存地址空间</code>。</p>
<p><img src="/images/76e9f928-image-20211115110615698.png" alt="image-20211115110615698"></p>
</li>
<li><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片。</p>
<ul>
<li>各种接口卡(比如，网卡、显卡)上的接口芯片，它们控制接口卡进行工作；</li>
<li>主板上的接口芯片，CPU通过它们对部分外设进行访问；</li>
<li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。</li>
</ul>
</li>
<li><p>在这些芯片中，都有一组可以<strong>由CPU读写的寄存器</strong>。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们有两点相同：</p>
<ul>
<li>都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的；</li>
<li>CPU对它们进行读或写的时候都通过<code>控制线</code>向它们所在的芯片发出端口读写命令。</li>
</ul>
</li>
<li><p>可见，从CPU的角度，将这些寄存器都当作端口，对它们<strong>进行统一编址</strong>，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。</p>
</li>
<li><p>CPU可以直接读写以下3个地方的数据：</p>
<ul>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口</li>
</ul>
</li>
</ul>
<h2 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h2><ul>
<li>在访问端口的时候，CPU<strong>通过端口地址来定位端口</strong>。因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样，都是通过地址总线来传送。</li>
<li>CPU最多可以定位64KB个不同的端口，所有端口地址的范围为0~65535。</li>
<li>端口的读写指令只有两条：<code>in</code>和<code>out</code>，分别用于从端口读取数据和向端口写入数据。</li>
</ul>
<h3 id="访问内存和访问端口的流程"><a href="#访问内存和访问端口的流程" class="headerlink" title="访问内存和访问端口的流程"></a>访问内存和访问端口的流程</h3><p>访问内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, ds:[8] ; 假设执行前(ds)=0</span><br></pre></td></tr></table></figure>

<p>执行时与总线相关的操作流程：</p>
<ol>
<li>CPU通过地址线将地址信息8发出</li>
<li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它将要从中读取数据</li>
<li>存储器将8号单元中的数据通过数据线送入CPU</li>
</ol>
<p>访问端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h ; 从60h号端口读入一个字节</span><br></pre></td></tr></table></figure>

<p>执行时与总线相关的操作流程：</p>
<ol>
<li>CPU通过地址线将地址信息60h发出</li>
<li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据</li>
<li>端口所在的芯片将60h端口中的数据通过数据线送入CPU</li>
</ol>
<p>注意，在in和out指令中，<strong>只能</strong>使用<code>ax</code>或<code>al</code>来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用<code>al</code>，访问16位端口时用<code>ax</code>。</p>
<p>对0~255以内的端口进行读写时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al, 20h         ; 从2011端口读入一个字节</span><br><span class="line">out 20h, al        ; 向20打端口写入一个字节</span><br></pre></td></tr></table></figure>

<p>对256~65535的端口进行读写时，端口号放在dx中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 3f8h       ; 将端口号3f8h送入dx</span><br><span class="line">in al, dx          ; 从3f8h端口读入一个字节</span><br><span class="line">out dx, al         ; 向3f8h端口写入一个字节</span><br></pre></td></tr></table></figure>



<h2 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h2><p>PC机中，有一个CMOS RAM芯片，一般简称为CMOS。此芯片的特征如下：</p>
<ul>
<li>包含一个实时钟和一个有128个存储单元的RAM存储器(早期的计算机为64个字节)。</li>
<li>该芯片靠电池供电。所以，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失。</li>
<li>128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。</li>
<li>该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM。</li>
<li>70h为<code>地址端口</code>，存放要访问的CMOS RAM单元的地址；71h为<code>数据端口</code>，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。</li>
<li>可见CPU对CMOS RAM的读写分两步进行，例如，读CMOS RAM的2号单元：<ol>
<li>将2送入端口70h；</li>
<li>从端口71h读出2号单元的内容。</li>
</ol>
</li>
</ul>
<p>读取CMOS RAM的 2号单元的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">				mov al, 2</span><br><span class="line">        out 70H,al  ;将2送入端口70H   </span><br><span class="line">        in  al,71H  ;从端口71H读出2号单元的内容</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00H</span><br><span class="line">        int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>向CMOS RAM的2号单元写入0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">				mov al,2    </span><br><span class="line">        out 70h,al  ;要访问的CMOS RAM单元地址为 (al)=2</span><br><span class="line">        mov al,0</span><br><span class="line">        out 71H,al  ;写入数据到选定的CMOS RAM单元地址</span><br><span class="line"></span><br><span class="line">        mov ax,4c00H</span><br><span class="line">        int 21H</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h2><ul>
<li>shl和shr是逻辑移位指令。shl是逻辑左移指令，shr是逻辑右移指令。</li>
<li>shl是逻辑左移指令，它的功能为：<ol>
<li>将一个寄存器或内存单元中的数据向左移位</li>
<li>将最后移出的一位写入CF中</li>
<li>最低位用0补充</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1      ; 将al中的数据左移一位。执行后(al)=1001 0000b，CF=0。</span><br><span class="line">shl al,1      ; 将al中的数据左移一位。执行后(al)=0010 0000b，CF=1。</span><br></pre></td></tr></table></figure>



<p>如果移动位数大于1时，必须将移动位数放在<code>cl</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01010001b</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl ; 执行后(al)=10001000b，因为最后移出的一位是0，所以CF=0。</span><br></pre></td></tr></table></figure>



<p>编程，用加法和移位指令计算（ax） = （ax) * 10<br>提示：（ax）* 10 = （ax）* 2 + （ax）* 8。即：乘以2即左移一位，乘以8即左移三位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,10</span><br><span class="line">	mov bx,ax</span><br><span class="line">	shl ax,1</span><br><span class="line">	mov cl,3</span><br><span class="line">	shl bx,cl</span><br><span class="line">	add ax,bx</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="CMOS-RAM中存储的时间信息"><a href="#CMOS-RAM中存储的时间信息" class="headerlink" title="CMOS RAM中存储的时间信息"></a>CMOS RAM中存储的时间信息</h2><blockquote>
<p>BCD码是以4位二进制数表示十进制数码的编码方法，如下所示：</p>
<table>
<thead>
<tr>
<th>十进制数码</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>对应的BCD码</td>
<td>0000</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
<td>1000</td>
<td>1001</td>
</tr>
</tbody></table>
<p>比如，数值26用BCD码表示为：0010 0110。</p>
<p>可见<strong>一个字节可表示两个BCD码</strong>。也就是说，一个字节的BCD码可以表示<code>两位的十进制数</code>，高4位的BCD码表示十位，低4位的BCD码表示个位。比如，00010100b表示14。</p>
</blockquote>
<ul>
<li>在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。</li>
<li>这6个信息的长度都为1个字节，存放单元为：<code>秒：0  分：2  时：4   日：7  月：8  年：9</code>。这些数据以BCD码的方式存放。</li>
</ul>
<p>编程，在屏幕中间显示当前的月份。</p>
<blockquote>
<p>分析：</p>
<ol>
<li>需要从CMOS RAM的8号单元读出当前月份的BCD码。</li>
<li>将用BCD码表示的月份以十进制的形式显示到屏幕上。</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov al,8    ; 首先要向地址端口70h写入要访问的单元的地址</span><br><span class="line">        out 70h,al</span><br><span class="line">        in al,71h   ; 从数据端口71h中取得指定单元中的数据</span><br><span class="line"></span><br><span class="line">        mov ah,al   ; al中为从CMOS RAM的8号单元中读出的数据</span><br><span class="line">        mov cl,4</span><br><span class="line">        shr ah,cl   ; ah中为月份的十位数码值</span><br><span class="line">        and al,00001111b ; al中为月份的个位数码值</span><br><span class="line"></span><br><span class="line">        add ah,30h</span><br><span class="line">        add al,30h</span><br><span class="line"></span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov byte ptr es:[160*12+40*2],ah        ;显示月份的十位数码</span><br><span class="line">        mov byte ptr es:[160*12+40*2+2],al      ;接着显示月份的个位数码</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>编程，以<code>年/月/日 时：分：秒</code>的格式，显示当前的日期、时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"> </span><br><span class="line">data segment</span><br><span class="line">        db 9,8,7,4,2,0 ;存放顺序读取的CMOS端口</span><br><span class="line">        db &#x27;00/00/00 00:00:00&#x27;,&#x27;$&#x27;       ;存放预先设置的时间字符串格式</span><br><span class="line">data ends</span><br><span class="line"> </span><br><span class="line">stack segment</span><br><span class="line">        db 32 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"> </span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,data</span><br><span class="line">        mov ds,ax    </span><br><span class="line"> </span><br><span class="line">        mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,10h</span><br><span class="line"> </span><br><span class="line">        mov bx,6</span><br><span class="line">        mov si,0</span><br><span class="line"> </span><br><span class="line">        mov cx,6</span><br><span class="line"> </span><br><span class="line">    s:  call parse</span><br><span class="line">        inc si</span><br><span class="line">        add bx,3</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">			  ; 设置光标位置</span><br><span class="line">        mov ah,2</span><br><span class="line">        mov bh,0</span><br><span class="line">        mov dh,5</span><br><span class="line">        mov dl,0</span><br><span class="line">        int 10h</span><br><span class="line"> </span><br><span class="line">				; 显示字符串</span><br><span class="line">        mov dx,6</span><br><span class="line">        mov ah,9</span><br><span class="line">        int 21h</span><br><span class="line"> </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">				;这个函数是解析CMOS中读出的数据，是书中的示例</span><br><span class="line"> parse: mov al,[si]</span><br><span class="line">        out 70h,al</span><br><span class="line">        in al,71h</span><br><span class="line">        push cx</span><br><span class="line"> </span><br><span class="line">        mov cl,4</span><br><span class="line">        mov ah,al</span><br><span class="line">        and ah,00001111b</span><br><span class="line">        and al,11110000b</span><br><span class="line">        shr al,cl</span><br><span class="line"> </span><br><span class="line">        add ah,30h</span><br><span class="line">        add al,30h</span><br><span class="line"> </span><br><span class="line">        mov [bx],ax</span><br><span class="line">        pop cx</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line"> </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h1 id="第十五章-外中断"><a href="#第十五章-外中断" class="headerlink" title="第十五章 外中断"></a>第十五章 外中断</h1><ul>
<li>CPU在计算机系统中，除了能够执行指令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出。也就是说，<strong>CPU除了有运算能力外，还要有I/O能力</strong>。<ul>
<li>比如，我们按下键盘上的一个键，CPU最终要能够处理这个键。</li>
<li>在使用文本编辑器时，按下a键后，可以看到屏幕上出现“a”，是CPU将从键盘上输入的键所对应的字符送到显示器上的。</li>
</ul>
</li>
<li>要及时处理外设的输入，显然需要解决两个问题：<ul>
<li>外设的输入随时可能发生，CPU如何得知？</li>
<li>CPU从何处得到外设的输入？</li>
</ul>
</li>
</ul>
<h2 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a>接口芯片和端口</h2><ul>
<li><strong>CPU通过端口和外部设备进行联系</strong>。</li>
<li>PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问。</li>
<li>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。</li>
<li>CPU向外设输出控制命令，这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。</li>
</ul>
<h2 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h2><ul>
<li>外设随时都可能发生需要CPU及时处理的事件，CPU如何及时得知并进行处理？</li>
<li>CPU提供<code>中断机制</code>来满足这种需要。当CPU外部有需要处理的事情发生的时候，比如说外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。</li>
<li>外中断源一共有两类：<ul>
<li>可屏蔽中断</li>
<li>不可屏蔽中断</li>
</ul>
</li>
</ul>
<h3 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h3><ul>
<li>可屏蔽中断：<strong>CPU可以不响应的外中断</strong>。</li>
<li>CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。当CPU检测到可屏蔽中断信息时，<ul>
<li>如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程；</li>
<li>如果IF=0，则不响应可屏蔽中断。</li>
</ul>
</li>
</ul>
<p>可屏蔽中断所引发的中断过程，除在第1步的实现上有所不同外，基本上和内中断的中断过程相同。：</p>
<ol>
<li>取中断类型码n；</li>
<li>标志寄存器入栈，IF=0，TF=0；</li>
<li>CS、IP入栈；</li>
<li><code>(IP)=(n*4)，(CS)=(n*4+2)</code></li>
</ol>
<blockquote>
<p>因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。</p>
</blockquote>
<blockquote>
<p>为什么中断过程中将IF置为0？</p>
<p>原因就是：<strong>在进入中断处理程序后，禁止其他的可屏蔽中断</strong>。</p>
</blockquote>
<p>如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sti ; 设置 IF=1；</span><br><span class="line">cli ; 设置 IF=0。</span><br></pre></td></tr></table></figure>



<h3 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h3><ul>
<li>不可屏蔽中断：<strong>CPU必须响应的外中断</strong>。</li>
<li>当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应引发中断过程。</li>
<li>几乎所有由外设引发的外中断，都是可屏蔽中断。不可屏蔽中断是在系统中有必须处理的<strong>紧急情况发生时</strong>用来通知CPU的中断信息。</li>
</ul>
<p>对于8086CPU，<strong>不可屏蔽中断的中断类型码固定为2</strong>，所以中断过程中不需要取中断类型码。进而不可屏蔽中断的中断过程为：</p>
<ol>
<li>标志寄存器入栈，IF=0，TF=0；</li>
<li>CS、IP入栈；</li>
<li>(IP)=(8)，(CS)=(0AH)。</li>
</ol>
<h2 id="CPU对外设输入的通常处理方法"><a href="#CPU对外设输入的通常处理方法" class="headerlink" title="CPU对外设输入的通常处理方法"></a>CPU对外设输入的通常处理方法</h2><ol>
<li>外设的输入送入端口;</li>
<li>向CPU发出外中断(可屏蔽中断)信息；</li>
<li>CPU检测到可屏蔽中断信息，如果IF=1，CPU在执行完当前指令后响应中断，执行相应的中断例程；</li>
<li>可在中断例程中实现对外设输入的处理。</li>
</ol>
<blockquote>
<p>端口和中断机制，是CPU进行I/O的基础。</p>
</blockquote>
<h2 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h2><h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><ol>
<li>键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。</li>
<li>按下一个键时，开关接通该芯片就产生一个<code>扫描码</code>，<strong>扫描码说明了按下的键在键盘上的位置</strong>。</li>
<li>扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60h。</li>
<li>松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60h端口中.<ul>
<li>一般将按下一个键时产生的扫描码称为<code>通码</code>，松开一个键产生的扫描码称为<code>断码</code>。</li>
<li>扫描码长度为<code>一个字节</code>，通码的第7位为0，断码的第7位为1，即：<strong>断码=通码+80h</strong></li>
<li>比如，g键的通码为22h，断码为a2h。</li>
</ul>
</li>
</ol>
<h3 id="引发9号中断"><a href="#引发9号中断" class="headerlink" title="引发9号中断"></a>引发9号中断</h3><p>键盘的输入到达60h端口时，相关的芯片就会<strong>向CPU发出中断类型码为9的可屏蔽中断信息</strong>。</p>
<p>CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程转去执行int9中断例程。 </p>
<h3 id="执行int9中断例程"><a href="#执行int9中断例程" class="headerlink" title="执行int9中断例程"></a>执行int9中断例程</h3><p>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要的工作如下：</p>
<ol>
<li>读出60h端口中的扫描码；<ul>
<li>如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）送入内存中的BIOS键盘缓冲区；</li>
<li>如果是控制键（比如Ctrl）和切换键（比如CapsLock）的扫描码，则将其转变为状态字节（用二进制位记录控制键和切换键状态的字节）写入内存中存储状态字节的单元；</li>
</ul>
</li>
<li>对键盘系统进行相关的控制，比如说向相关芯片发出应答信息。</li>
</ol>
<p>BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以存储15个键盘输入，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。</p>
<blockquote>
<p>0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下：</p>
<ul>
<li>0：右Shift状态，置1表示按下右Shift键；</li>
<li>1：左Shift状态，置1表示按下左Shift键；</li>
<li>2：Ctrl状态，置1表示按下Ctrl键；</li>
<li>3：Alt状态，置1表示按下Alt键；</li>
<li>4：ScrollLock状态，置1表示Scroll指示灯亮；</li>
<li>5：NumLock状态，置1表示小键盘输入的是数字；</li>
<li>6：CapsLock状态，置1表示输入大写字母；</li>
<li>7：Insert状态，置1表示处于删除态。</li>
</ul>
</blockquote>
<h2 id="编写int-9中断例程"><a href="#编写int-9中断例程" class="headerlink" title="编写int 9中断例程"></a>编写int 9中断例程</h2><p>键盘输入的处理过程：</p>
<ol>
<li>键盘产生扫描码</li>
<li>扫描码送入60h端口</li>
<li>引发9号中断</li>
<li>CPU执行int 9中断例程处理键盘输入</li>
</ol>
<blockquote>
<p>上面的过程中，第1、2、3步都是由硬件系统完成的。我们能够改变的只有int 9中断处理程序。</p>
</blockquote>
<p>编程：在屏幕中间依次显示”a”~”z”，并可以让人看清。在显示的过程中，按下Esc键后改变显示的颜色。</p>
<ul>
<li>依次显示”a”~”z”</li>
<li>按下Esc键后改变显示的颜色</li>
</ul>
<h3 id="依次显示”a”-”z”"><a href="#依次显示”a”-”z”" class="headerlink" title="依次显示”a”~”z”"></a>依次显示”a”~”z”</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov ah,&#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">    s:  mov es: [160*12+40*2],ah</span><br><span class="line">        call delay</span><br><span class="line">        inc ah</span><br><span class="line">        cmp ah,&#x27;z&#x27;</span><br><span class="line">        jna s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  delay:push ax</span><br><span class="line">        push dx</span><br><span class="line">        mov dx,1000h     ;循环10000000h次，读者可以根据自己机器的速度调整循环次数</span><br><span class="line">        mov ax,0</span><br><span class="line"></span><br><span class="line">    s1: sub ax,1</span><br><span class="line">        sbb dx,0</span><br><span class="line">        cmp ax,0</span><br><span class="line">        jne s1</span><br><span class="line">        cmp dx,0</span><br><span class="line">        jne s1</span><br><span class="line">        pop dx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h3 id="按下Esc键后改变显示的颜色"><a href="#按下Esc键后改变显示的颜色" class="headerlink" title="按下Esc键后改变显示的颜色"></a>按下Esc键后改变显示的颜色</h3><p>键盘输入到达60h端口后，就会引发9号中断，CPU则转去执行int 9中断例程。我们可以编写int 9中断例程，功能如下。</p>
<ol>
<li>从60h端口读出键盘的输入；</li>
<li>调用BIOS的int 9中断例程，处理其他硬件细节；</li>
<li>判断是否为Esc的扫描码，如果是改变显示的颜色后返回；如果不是则直接返回。</li>
</ol>
<blockquote>
<p>要注意的是，我们写的中断处理程序要成为新的int 9中断例程，主程序必须要将中断向量表中的int 9中断例程的入口地址改为我们写的中断处理程序的入口地址。</p>
<p>所以在新的中断处理程序中调用原来的int 9中断例程时，中断向量表中的int 9中断例程的入口地址却不是原来的int 9中断例程的地址。所以不能使用int指令直接调用。</p>
<p>要能在我们写的新中断例程中调用原来的中断例程，就必须在将中断向量表中的中断例程的入口地址改为新地址之前，将原来的入口地址保存起来。这样，在需要调用的时候，我们才能找到原来的中断例程的入口。</p>
</blockquote>
<p>有了入口地址后，需要手动调用。</p>
<p>原先的流程为：</p>
<ol>
<li>取中断类型码n；</li>
<li>标志寄存器入栈；</li>
<li>IF=0，TF=0；</li>
<li>CS、IP入栈；</li>
<li><code>(IP)=(n*4), (CS)=(n*4+2)</code></li>
</ol>
<p>手动调用的流程为：</p>
<ol>
<li>标志寄存器入栈；</li>
<li>IF=0，TF=0；</li>
<li>call dword ptr ds:[0]。</li>
</ol>
<p>即为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pushf ;标志寄存器入栈</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">and ah,11111100b</span><br><span class="line">push ax</span><br><span class="line">popf ;IF=0, TF=0</span><br><span class="line"></span><br><span class="line">call dword ptr ds:[0] ;CS、IP入栈；(IP)=((ds)x16+0)，(CS)=((ds)x16+2)</span><br></pre></td></tr></table></figure>



<p>完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line"></span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        push es:[9*4]</span><br><span class="line">        pop ds:[0]</span><br><span class="line">        push es:[9*4+2]</span><br><span class="line">        pop ds:[2]      ;将原来的int 9中断例程的入口地址保存在ds:0、ds:2单元中</span><br><span class="line"></span><br><span class="line">        mov word ptr es:[9*4],offset int9</span><br><span class="line">        mov es:[9*4+2],cs       ;在中断向量表中设置新的int 9中断例程的入口地址</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov ah,&#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">    s:  mov es:[160*12+40*2],ah</span><br><span class="line">        call delay</span><br><span class="line">        inc ah</span><br><span class="line">        cmp ah,&#x27;z&#x27;</span><br><span class="line">        jna s</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        push ds:[0]</span><br><span class="line">        pop es:[9*4]</span><br><span class="line">        push ds:[2]</span><br><span class="line">        pop es:[9*4+2]      ;将中断向量表中int 9中断例程的入口恢复为原来的地址</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  delay:push ax</span><br><span class="line">        push dx</span><br><span class="line">        mov dx,1000h</span><br><span class="line">        mov ax,0</span><br><span class="line">    s1: sub ax,1</span><br><span class="line">        sbb dx,0</span><br><span class="line">        cmp ax,0</span><br><span class="line">        jne s1</span><br><span class="line">        cmp dx,0</span><br><span class="line">        jne s1</span><br><span class="line">        pop dx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">;------以下为新的int 9中断例程------</span><br><span class="line"></span><br><span class="line">int9:   push ax</span><br><span class="line">        push bx</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">        in al,60h</span><br><span class="line"></span><br><span class="line">        pushf</span><br><span class="line">        pushf</span><br><span class="line">        pop bx</span><br><span class="line">        and bh,11111100b</span><br><span class="line">        push bx</span><br><span class="line">        popf</span><br><span class="line">        call dword ptr ds:[0]       ;对int指令进行模拟，调用原来的int 9中断例程</span><br><span class="line"></span><br><span class="line">        cmp al,1</span><br><span class="line">        jne int9ret</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        inc byte ptr es:[160*12+40*2+1]     ;将属性值加1,改变颜色</span><br><span class="line"></span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="安装新的int-9中断例程"><a href="#安装新的int-9中断例程" class="headerlink" title="安装新的int 9中断例程"></a>安装新的int 9中断例程</h2><p>我们安装一个新的int 9中断例程，使得原int 9中断例程的功能得到扩展：</p>
<ul>
<li>任务：安装一个新的int 9中断例程。</li>
<li>功能：在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line"></span><br><span class="line">        push cs</span><br><span class="line">        pop ds</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        mov si,offset int9      ;设置ds:si指向源地址</span><br><span class="line">        mov di,204h     ;设置es:di指向目的地址</span><br><span class="line">        mov cx,offset int9end-offset int9       ;设置cx为传输长度</span><br><span class="line">        cld     ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        push es:[9*4]</span><br><span class="line">        pop es:[200h]</span><br><span class="line">        push es:[9*4+2]</span><br><span class="line">        pop es:[202h]</span><br><span class="line"></span><br><span class="line">        cli </span><br><span class="line">        mov word ptr es:[9*4],204h</span><br><span class="line">        mov word ptr es: [9*4+2],0</span><br><span class="line">        sti</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">int9:   push ax</span><br><span class="line">        push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">        in al,60h</span><br><span class="line"></span><br><span class="line">        pushf</span><br><span class="line">        call dword ptr cs:[200h]        ;当此中断例程执行时(CS)=0</span><br><span class="line"></span><br><span class="line">        cmp al,3bh      ;F1的扫描码为3bh</span><br><span class="line">        jne int9ret</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov bx,1</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">     s: inc byte ptr es:[bx]</span><br><span class="line">        add bx,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line"></span><br><span class="line">int9end:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="指令总结"><a href="#指令总结" class="headerlink" title="指令总结"></a>指令总结</h2><p>8086CPU提供以下几大类指令。</p>
<p><strong>1. 数据传送指令</strong></p>
<p>比如mov、push、pop、pushf、popf、xchg等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。</p>
<p><strong>2. 算术运算指令</strong></p>
<p>比如add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的sf、zf、of、cf、pf、af位。</p>
<p><strong>3. 逻辑指令</strong></p>
<p>比如and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr等都是逻辑指令。除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。</p>
<p><strong>4. 转移指令</strong></p>
<p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令分为以下几类。</p>
<p>（1）无条件转移指令，比如，jmp；<br>（2）条件转移指令,比如，jcxz、je、jb、ja、jnb、jna等;<br>（3）循环指令，比如，loop；<br>（4）过程，比如，call、ret、retf；<br>（5）中断，比如，int、iret。</p>
<p><strong>5. 处理机控制指令</strong></p>
<p>这些指令对标志寄存器或其他处理机状态进行设置，比如，cld、std、ch、sti、nop、clc、cmc、stc、hit、wait、esc、lock等都是处理机控制指令。</p>
<p><strong>6. 串处理指令</strong></p>
<p>这些指令对内存中的批量数据进行处理，比如，movsb、movsw、cmps、scas、lods、stos等。若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。</p>
<h1 id="第十六章-直接定址表"><a href="#第十六章-直接定址表" class="headerlink" title="第十六章 直接定址表"></a>第十六章 直接定址表</h1><h2 id="描述单元长度的标号"><a href="#描述单元长度的标号" class="headerlink" title="描述单元长度的标号"></a>描述单元长度的标号</h2><p>将code段中的a标号处的8个数据累加，结果存储到b标号处的字中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">        a: db 1,2,3,4,5,6,7,8</span><br><span class="line">        b: dw 0</span><br><span class="line"></span><br><span class="line">start:  mov si,offset a</span><br><span class="line">        mov bx,offset b</span><br><span class="line">        mov cx,8</span><br><span class="line"></span><br><span class="line">    s:  mov al,cs:[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add cs:[bx],ax</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>程序中，code、a、b、start、s都是标号。这些<strong>标号仅仅表示了内存单元的地址</strong>。</p>
<p>我们还可以使用一种标号，这种标号<strong>不但表示内存单元的地址，还表示了内存单元的长度</strong>，即：表示在此标号处的单元是一个<code>字节单元</code> or<code>字单元</code> or <code>双字单元</code>。</p>
<p>上面的程序还可以写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">        a db 1,2,3,4,5,6,7,8</span><br><span class="line">        b dw 0</span><br><span class="line"></span><br><span class="line">start:  mov si, 0</span><br><span class="line">        mov cx, 8</span><br><span class="line">    s:  mov al, a[si]</span><br><span class="line">        mov ah, 0</span><br><span class="line">        add b, ax</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在code段中使用的<strong>标号a、b后面没有<code>：</code>，它们是同时描述内存地址和单元长度的标号</strong>。</p>
<ul>
<li>标号a，描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元；</li>
<li>标号b，描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。</li>
</ul>
</blockquote>
<p>因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line"></span><br><span class="line">	a db 1,2,3,4,5,6,7,8</span><br><span class="line">	b dw 0     ; 标号b代表了一个内存单元，地址为code:8，长度为两个字节。</span><br><span class="line">	</span><br><span class="line">	mov ax, b  ; 相当于：mov ax, cs:[8]</span><br><span class="line">	mov b, 2   ; 相当于：mov word ptr cs:[8], 2</span><br><span class="line">	inc b      ; inc word ptr cs:[8]</span><br><span class="line">	</span><br><span class="line">	mov al,b   ; 引起编译错误：因为b代表的内存单元是字单元，而al是8位寄存器。</span><br><span class="line">	</span><br><span class="line">	mov al, a[si]     ; 相当于：mov al, cs:0[si]</span><br><span class="line">	mov al, a[3]      ; 相当于：mov al, cs:0[3]</span><br><span class="line">	mov al,a[bx+si+3] ; 相当于：mov al, cs:0[bx+si+3]</span><br><span class="line">	</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>

<p>可见使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。我们将这种标号称为<code>数据标号</code>，它标记了存储数据的单元的地址和长度。它不同于仅仅表示地址的地址标号。</p>
<p>将code段中a处的8个数据累加，结果存储到b处的双字中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    a dw 1,2,3,4,5,6,7,8</span><br><span class="line">    b dd 0</span><br><span class="line"></span><br><span class="line">start:mov si,0</span><br><span class="line">      mov cx,8</span><br><span class="line">   s: mov ax,a[si]</span><br><span class="line">      add word ptr b,ax</span><br><span class="line">      adc word ptr b[2],0</span><br><span class="line">      add si,2</span><br><span class="line">      loop s</span><br><span class="line">     </span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="在其他段中使用数据标号"><a href="#在其他段中使用数据标号" class="headerlink" title="在其他段中使用数据标号"></a>在其他段中使用数据标号</h2><p>一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中。在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。</p>
<blockquote>
<p>在后面加有“：”的地址标号，只能在代码段中使用，不能在其他段中使用。</p>
</blockquote>
<p>将data段中a标号处的8个数据累加，结果存储到b标号处的字中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,8</span><br><span class="line"></span><br><span class="line">    s:  mov al,a[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add b,ax</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>可以将标号当作数据来定义，此时编译器将标号所表示的地址当作数据的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">    </span><br><span class="line">    ; 数据标号c处存储的两个字型数据为标号a、b的偏移地址。</span><br><span class="line">    ; 相当于: c dw offset a, offset b</span><br><span class="line">    c dw a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">    </span><br><span class="line">    ; 数据标号C处存储的两个双字型数据为标号a的偏移地址和段地址、标号b的偏移地址和段地址。</span><br><span class="line">    ; 相当于：c dw offset a, seg a, offset b, seg b</span><br><span class="line">    c dd a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<blockquote>
<p>seg操作符：功能为<strong>取得某一标号的段地址</strong>。</p>
</blockquote>
<p>将data段中a处的8个数据累加，结果存储到b处的字中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,es:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    a db 1,2,3,4,5,6,7,8</span><br><span class="line">    b dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:mov ax,data</span><br><span class="line">      mov es,ax</span><br><span class="line">      mov si,0</span><br><span class="line">      mov cx,8</span><br><span class="line">   s: mov al,a[si]</span><br><span class="line">      mov ah,0</span><br><span class="line">      add b,ax</span><br><span class="line">      inc si</span><br><span class="line">      loop s</span><br><span class="line"></span><br><span class="line">      mov ax,4c00h</span><br><span class="line">      int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h2><p>在数值 <code>0~15</code> 和 字符 <code>”0&quot;~&quot;F&quot;</code> 之间找到一种映射关系。即：</p>
<ul>
<li><code>数值 + 30h = 对应字符的ASCII值</code><ul>
<li>0+30h=”0” 的 ASCII 值</li>
<li>1+30h=”1” 的 ASCII 值</li>
<li>2+30h=”2” 的 ASCII 值</li>
<li>…</li>
</ul>
</li>
<li><code>数值 + 37h = 对应字符的ASCII值</code><ul>
<li>10+37h=”A” 的 ASCII 值</li>
<li>11+37h=”B” 的 ASCII 值</li>
<li>12+37h=”C” 的 ASCII 值</li>
<li>…</li>
</ul>
</li>
</ul>
<p>可以将一个字节的高4位和低4位分开，分别用它们的值得到对应的数码字符。比如2Bh，可以得到高4位的值为2，低4位的值为11</p>
<p>建立一张表，表中依次存储字符”0”~”F”，我们可以通过数值0-15直接查找到对应的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">;用al传送要显示的数据</span><br><span class="line">showbyte:jmp short show</span><br><span class="line">        table db &#x27;0123456789ABCDEF&#x27;   ; 字符表</span><br><span class="line"></span><br><span class="line">show:   push bx</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">        mov ah,al</span><br><span class="line">        shr ah,1</span><br><span class="line">        shr ah,1</span><br><span class="line">        shr ah,1</span><br><span class="line">        shr ah,1           ; 右移4位,ah中得到高4位的值</span><br><span class="line">        and al,00001111b   ; al中为低4位的值</span><br><span class="line"></span><br><span class="line">        mov bl,ah</span><br><span class="line">        mov bh,0</span><br><span class="line">        mov ah,table[bx]        ; 用高4位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line"></span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov es:[160*12+40*2],ah</span><br><span class="line"></span><br><span class="line">        mov bl,al</span><br><span class="line">        mov bh,0</span><br><span class="line">        mov al,table[bx]        ; 用低4位的值作为相对于table的偏移，取得对应的字符</span><br><span class="line"></span><br><span class="line">        mov es:[160*12+40*2+2],al</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>可以看出在子程序中，我们在数值0~15和字符”0”-“F”之间建立的映射关系为：以数值N为table表中的偏移，可以找到对应的字符。</p>
<p>像这种可以通过依据数据，直接计算出所要找的元素的位置的表，我们称其为<code>直接定址表</code>。</p>
<h2 id="程序入口地址的直接定址表"><a href="#程序入口地址的直接定址表" class="headerlink" title="程序入口地址的直接定址表"></a>程序入口地址的直接定址表</h2><p>在直接定址表中存储子程序的地址，从而方便地实现不同子程序的调用。</p>
<p>实现一个子程序setscreen，为显示输出提供如下功能：</p>
<ul>
<li>清屏</li>
<li>设置前景色</li>
<li>设置背景色</li>
<li>向上滚动一行</li>
</ul>
<p>入口参数说明如下。</p>
<ul>
<li>用ah寄存器传递功能号：0表示清屏，1表示设置前景色，2表示设置背景色，3表示向上滚动一行；</li>
<li>对于1、2号功能，用al传送颜色值，(al)∈{0,1,2,3,4,5,6,7}。</li>
</ul>
<p>将这4个功能分别写为4个子程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">sub1:   push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,0</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">sub1s:  mov byte ptr es:[bx],&#x27; &#x27;</span><br><span class="line">        add bx,2</span><br><span class="line">        loop sub1s</span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">sub2:   push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,1</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">sub2s:  and byte ptr es:[bx],11111000b</span><br><span class="line">        or es:[bx],al</span><br><span class="line">        add bx,2</span><br><span class="line">        loop sub2s</span><br><span class="line"></span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">sub3:   push bx</span><br><span class="line">        push cx</span><br><span class="line">        push es</span><br><span class="line">        mov cl,4</span><br><span class="line">        shl al,cl</span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov bx,1</span><br><span class="line">        mov cx,2000</span><br><span class="line"></span><br><span class="line">sub3s:  and byte ptr es:[bx],10001111b</span><br><span class="line">        or es:[bx],al</span><br><span class="line">        add bx,2</span><br><span class="line">        loop sub3s</span><br><span class="line">        pop es</span><br><span class="line">        pop cx</span><br><span class="line">        pop bx</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">sub4:   push ex</span><br><span class="line">        push si</span><br><span class="line">        push di</span><br><span class="line">        push es</span><br><span class="line">        push ds</span><br><span class="line"></span><br><span class="line">        mov si,0b800h</span><br><span class="line">        mov es,si</span><br><span class="line">        mov ds,si</span><br><span class="line">        mov si,160      ;ds:si指向第 n+1 行</span><br><span class="line">        mov di,0        ;es:di指向第 n 行</span><br><span class="line">        cld</span><br><span class="line">        mov cx,24       ;共复制24行</span><br><span class="line"></span><br><span class="line">sub4s:  push ex</span><br><span class="line">        mov cx,160</span><br><span class="line">        rep movsb       ;复制</span><br><span class="line">        pop cx</span><br><span class="line">        loop sub4s </span><br><span class="line"></span><br><span class="line">        mov cx,80</span><br><span class="line">        mov si,0</span><br><span class="line"></span><br><span class="line">sub4s1: mov byte ptr [160*24+si],&#x27; &#x27;        ;最后一行清空</span><br><span class="line">        add si,2</span><br><span class="line">        loop sub4s1</span><br><span class="line"></span><br><span class="line">        pop ds</span><br><span class="line">        pop es</span><br><span class="line">        pop di</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>我们可以将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。对应关系为：功能号*2=对应的功能子程序在地址表中的偏移：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setscreen: jmp short set</span><br><span class="line"></span><br><span class="line">table dw sub1,sub2,sub3,sub4</span><br><span class="line"></span><br><span class="line">set:    push bx</span><br><span class="line"></span><br><span class="line">        cmp ah,3        ;判断功能号是否大于3</span><br><span class="line">        ja sret</span><br><span class="line">        mov bl,ah</span><br><span class="line">        mov bh,0</span><br><span class="line">        add bx,bx       ;根据ah中的功能号计算对应子程序在table表中的偏移</span><br><span class="line"></span><br><span class="line">    call word ptr table[bx]     ;调用对应的功能子程序</span><br><span class="line"></span><br><span class="line">sret: pop bx</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>



<h1 id="第十七章-使用BIOS进行键盘输入和磁盘读写"><a href="#第十七章-使用BIOS进行键盘输入和磁盘读写" class="headerlink" title="第十七章 使用BIOS进行键盘输入和磁盘读写"></a>第十七章 使用BIOS进行键盘输入和磁盘读写</h1><h2 id="int-9中断例程对键盘输入的处理"><a href="#int-9中断例程对键盘输入的处理" class="headerlink" title="int 9中断例程对键盘输入的处理"></a>int 9中断例程对键盘输入的处理</h2><ul>
<li>键盘输入将引发9号中断，BIOS提供了int 9中断例程。</li>
<li>CPU在9号中断发生后，执行int 9中断例程，从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。</li>
<li>一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中。键盘缓冲区中有16个字单元，可以存储15个按键的扫描码和对应的ASCII码。 </li>
</ul>
<p>下面我们按照键盘缓冲区的逻辑结构，来看一下键盘输入的扫描码和对应的ASCII码是如何写入键盘缓冲区的。</p>
<p>通过下面几个键：<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code>、<code>Shift_A</code>、<code>A</code>的输入过程，简要地看一下int 9中断例程对键盘输入的处理方法。</p>
<ol>
<li><p>初始状态下，没有键盘输入，键盘缓冲区空，此时没有任何元素。</p>
<p><img src="/images/1162354-20211015185336672-610750453.png" alt="img"></p>
</li>
<li><p>按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；然后检测状态字节，看看是否有Shift、Ctrl等切换键按下；发现没有切换键按下，则将A键的扫描码1Eh和对应的ASCII码，即字母”a”的ASCII码61h，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCII码。此时缓冲区中的内容如下。</p>
<p><img src="/images/1162354-20211015185405062-963479278.png" alt="img"></p>
</li>
<li><p>按下B键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出B键的通码；然后检测状态字节，看看是否有切换键按下；发现没有切换键按下，将B键的扫描码30h和对应的ASCII码，即字母”b”的ASCII码62h，写入键盘缓冲区。此时缓冲区中的内容如下。</p>
<p><img src="/images/1162354-20211015185434311-2041533138.png" alt="img"></p>
</li>
<li><p>按下C、D、E键后，缓冲区中的内容如下。</p>
<p><img src="/images/1162354-20211015185455218-1796647714.png" alt="img"></p>
</li>
<li><p>按下左Shift键，引发键盘中断；int 9中断例程接收左Shift键的通码，设置0040:17处的状态字节的第1位为1，表示左Shift键按下。</p>
</li>
<li><p>按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；检测状态字节，看看是否有切换键按下；发现左Shift键被按下，则将A键的扫描码1Eh和Shift_A对应的ASCII码，即字母”A”的ASCII码41h，写入键盘缓冲区。此时缓冲区中的内容如下。</p>
<p><img src="/images/1162354-20211015185507686-993748594.png" alt="img"></p>
</li>
<li><p>松开左Shift键，引发键盘中断；int 9中断例程接收左Shift键的断码，设置 0040:17处的状态字节的第1位为0，表示左Shift键松开。</p>
</li>
<li><p>按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；然后检测状态字节，看看是否有切换键按下；发现没有切换键按下，则将A键的扫描码1Eh和A对应的ASCII码，即字母”a”的ASCII码61h，写入键盘缓冲区。此时缓冲区中的内容如下。</p>
<p><img src="/images/1162354-20211015185556627-1342218058.png" alt="img"></p>
</li>
</ol>
<h2 id="使用int-16h中断例程读取键盘缓冲区"><a href="#使用int-16h中断例程读取键盘缓冲区" class="headerlink" title="使用int 16h中断例程读取键盘缓冲区"></a>使用int 16h中断例程读取键盘缓冲区</h2><p>BIOS提供了int 16h中断例程供程序员调用。int 16h中断例程中包含的一个最重要的功能是<strong>从键盘缓冲区中读取一个键盘输入</strong>，该功能的编号为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 从键盘缓冲区中读取一个键盘输入，并且将其从缓冲区中删除：</span><br><span class="line">mov ah,0</span><br><span class="line">int 16h ; 结果：(ah)=扫描码，(al)=ASCII码。</span><br></pre></td></tr></table></figure>



<p>第一次执行上述代码后，ah中的内容为1Eh，al中的内容为61h。缓冲区中的内容如下：</p>
<p><img src="/images/1162354-20211015185627067-1366927467.png" alt="img"></p>
<p>第二次执行上述代码后，ah中的内容为30h，al中的内容为62h。缓冲区中的内容如下：</p>
<p><img src="/images/1162354-20211015185639338-997908865.png" alt="img"></p>
<p>执行七次以后，缓冲区为空。</p>
<p>第八次执行后，检测键盘缓冲区，<strong>发现缓冲区空则循环等待，直到缓冲区中有数据</strong>。</p>
<blockquote>
<p>循环等待的int 16h中断例程检测到键盘缓冲区中有数据，将其读出缓冲区又为空。</p>
</blockquote>
<p>从上面我们可以看出，int 16h中断例程的0号功能，进行如下的工作：</p>
<ol>
<li>检测键盘缓冲区中是否有数据；</li>
<li>没有则继续做第1步；</li>
<li>读取缓冲区第一个字单元中的键盘输入；</li>
<li>将读取的扫描码送入ah，ASCII码送入al；</li>
<li>将己读取的键盘输入从缓冲区中删除。</li>
</ol>
<blockquote>
<p>可见，BIOS的int 9中断例程和int 16h中断例程是一对相互配合的程序，<strong>int 9中断例程向键盘缓冲区中写入，int 16h中断例程从缓冲区中读出</strong>。</p>
<p>它们写入和读出的时机不同：</p>
<ul>
<li>int 9中断例程是在有键按下的时候向键盘缓冲区中写入数据；</li>
<li>int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。</li>
</ul>
</blockquote>
<h2 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h2><p>最基本的字符串输入程序，需要具备下面的功能。</p>
<ol>
<li>在输入的同时需要显示这个字符串</li>
<li>一般在输入回车符后，字符串输入结束</li>
<li>能够删除己经输入的字符</li>
</ol>
<p>对应的解决方案：</p>
<ol>
<li>每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。</li>
<li>输入回车符后，可以在字符串中加入0，表示字符串结束。</li>
<li>字符的输入和输出是按照栈的访问规则进行的，即后进先出。这样我们就可以用栈的方式来管理字符串的存储空间，也就是说字符串的存储空间实际上是一个字符栈。字符栈中的所有字符，从栈底到栈顶，组成一个字符串。</li>
</ol>
<p>现在我们可以简单地确定程序的处理过程如下：</p>
<ol>
<li>调用int 16h读取键盘输入；</li>
<li>如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行1；</li>
<li>如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行1；</li>
<li>如果是Enter键，向字符栈中压入0，返回。</li>
</ol>
<h2 id="应用int-13h中断例程对磁盘进行读写"><a href="#应用int-13h中断例程对磁盘进行读写" class="headerlink" title="应用int 13h中断例程对磁盘进行读写"></a>应用int 13h中断例程对磁盘进行读写</h2><p>编程：将当前屏幕的内容保存在磁盘上。</p>
<p>1屏的内容占4000个字节，需要8个扇区，用0面0道的1~8扇区存储显存中的内容。程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov bx,0</span><br><span class="line"></span><br><span class="line">        mov al,8</span><br><span class="line">        mov ch,0</span><br><span class="line">        mov cl,1</span><br><span class="line">        mov dl,0</span><br><span class="line">        mov dh,0</span><br><span class="line">        mov ah,3</span><br><span class="line">        int 13h</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>FIN</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>