<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第-0-章-实模式和保护模式简介&quot;&gt;&lt;a href=&quot;#第-0-章-实模式和保护模式简介&quot; class=&quot;headerlink&quot; title=&quot;第 0 章 实模式和保护模式简介&quot;&gt;&lt;/a&gt;第 0 章 实模式和保护模式简介&lt;/h1&gt;&lt;h2 id=&quot;CPU-的工作模式&quot;&gt;&lt;a href=&quot;#CPU-的工作模式&quot; class=&quot;headerlink&quot; title=&quot;CPU 的工作模式&quot;&gt;&lt;/a&gt;CPU 的工作模式&lt;/h2&gt;&lt;p&gt;&lt;code&gt;实模式&lt;/code&gt;和&lt;code&gt;保护模式&lt;/code&gt;都是 CPU 的工作模式，而 CPU 的工作模式是指 &lt;strong&gt;CPU 的寻址方式&lt;/strong&gt;、寄存器大小等用来反映 CPU 在该环境下如何工作的概念。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>x86汇编语言：从实模式到保护模式 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Assembly-Language/" rel="tag">Assembly Language</a></div><div class="post-time">2022-02-14</div></div></div><div class="container post-header"><h1>x86汇编语言：从实模式到保护模式</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-0-%E7%AB%A0-%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">第 0 章 实模式和保护模式简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">CPU 的工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">实模式工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">保护模式工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">第 1 章 十六进制计数法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E5%86%85%E5%AD%98%E5%92%8C%E6%8C%87%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">第 2 章 处理器、内存和指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F"><span class="toc-number">3.0.1.</span> <span class="toc-text">处理器进行数学运算的简单原</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%AD%97%EF%BC%88double-word%EF%BC%89"><span class="toc-number">3.0.2.</span> <span class="toc-text">双字（double word）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E5%A4%9A%E5%AD%97%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98"><span class="toc-number">3.0.3.</span> <span class="toc-text">处理器多字访问内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8086-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.0.4.</span> <span class="toc-text">8086 的内存分段机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8086-%E6%8C%87%E4%BB%A4%E9%A2%84%E5%8F%96%E9%98%9F%E5%88%97"><span class="toc-number">3.0.5.</span> <span class="toc-text">8086 指令预取队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%92%8C%E6%B1%87%E7%BC%96%E8%BD%AF%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">第 3 章 汇编语言和汇编软件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">第 4 章 虚拟机的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">计算机的启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8A%A0%E7%94%B5%E5%92%8C%E5%A4%8D%E4%BD%8D"><span class="toc-number">5.1.1.</span> <span class="toc-text">计算机的加电和复位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.1.2.</span> <span class="toc-text">基本输入输出系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">硬盘及其工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA"><span class="toc-number">5.3.</span> <span class="toc-text">主引导扇区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E7%BC%96%E5%86%99%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">第 5 章 编写主引导扇区代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">计算机启动顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%8D%A1%E5%92%8C%E6%98%BE%E5%AD%98"><span class="toc-number">6.2.</span> <span class="toc-text">显卡和显存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%98%BE%E5%AD%98"><span class="toc-number">6.3.</span> <span class="toc-text">访问显存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%A0%87%E5%8F%B7%E7%9A%84%E6%B1%87%E7%BC%96%E5%9C%B0%E5%9D%80"><span class="toc-number">6.4.</span> <span class="toc-text">显示标号的汇编地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">第 6 章 相同的功能，不同的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NASM-%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84-%E5%92%8C-%E6%A0%87%E8%AE%B0"><span class="toc-number">7.1.</span> <span class="toc-text">NASM 编译器的$和$$标记</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E6%AF%94%E9%AB%98%E6%96%AF%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">8.</span> <span class="toc-text">第 7 章 比高斯更快的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">寻址方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-8-%E7%AB%A0-%E7%A1%AC%E7%9B%98%E5%92%8C%E6%98%BE%E5%8D%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">第 8 章 硬盘和显卡的访问与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">用户程序的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%A4%B4%E9%83%A8"><span class="toc-number">9.2.</span> <span class="toc-text">用户程序头部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.3.</span> <span class="toc-text">外围设备及其接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E7%AB%AF%E5%8F%A3%E5%92%8C%E7%AB%AF%E5%8F%A3%E8%AE%BF%E9%97%AE"><span class="toc-number">9.4.</span> <span class="toc-text">I&#x2F;O 端口和端口访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%A1%AC%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%AF%BB%E6%89%87%E5%8C%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">9.5.</span> <span class="toc-text">通过硬盘控制器端口读扇区数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LBA28-%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8C%E4%BB%8E%E7%A1%AC%E7%9B%98%E4%B8%8A%E8%AF%BB%E9%80%BB%E8%BE%91%E6%89%87%E5%8C%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">9.5.1.</span> <span class="toc-text">LBA28 模式下，从硬盘上读逻辑扇区的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%EF%BC%88%E5%99%A8%EF%BC%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">9.6.</span> <span class="toc-text">加载程序（器）的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%86%B3%E5%AE%9A%E5%8A%A0%E8%BD%BD%E4%BD%8D%E7%BD%AE"><span class="toc-number">9.6.1.</span> <span class="toc-text">初始化和决定加载位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.6.2.</span> <span class="toc-text">准备加载用户程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">9.6.3.</span> <span class="toc-text">过程调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.6.4.</span> <span class="toc-text">加载用户程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">9.6.5.</span> <span class="toc-text">用户程序重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%8E%A7%E5%88%B6%E6%9D%83%E4%BA%A4%E7%BB%99%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.6.6.</span> <span class="toc-text">将控制权交给用户程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">9.7.</span> <span class="toc-text">用户程序的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%A0%88%E5%88%87%E6%8D%A2"><span class="toc-number">9.7.1.</span> <span class="toc-text">初始化段寄存器和栈切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%BE%E7%A4%BA%E4%BE%8B%E7%A8%8B"><span class="toc-number">9.7.2.</span> <span class="toc-text">调用字符串显示例程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F%E6%98%BE%E7%A4%BA"><span class="toc-number">10.</span> <span class="toc-text">第 9 章 中断和动态时钟显示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">10.1.</span> <span class="toc-text">外部硬件中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">10.2.</span> <span class="toc-text">中断向量表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E3%80%81CMOS-RAM-%E5%92%8CBCD-%E7%BC%96%E7%A0%81"><span class="toc-number">10.3.</span> <span class="toc-text">实时时钟、CMOS RAM 和BCD 编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">10.4.</span> <span class="toc-text">内部中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">10.5.</span> <span class="toc-text">软中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIOS-%E4%B8%AD%E6%96%AD"><span class="toc-number">10.6.</span> <span class="toc-text">BIOS 中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-10-%E7%AB%A0-32%E4%BD%8Dx86%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">11.</span> <span class="toc-text">第 10 章 32位x86处理器编程架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IA-32-%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">IA-32 架构的寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="toc-number">11.2.</span> <span class="toc-text">线性地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">11.3.</span> <span class="toc-text">现代处理器的结构和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E4%BD%8D%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">11.4.</span> <span class="toc-text">32 位处理器的寻址方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IA-32-%E7%9A%84%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.5.</span> <span class="toc-text">IA-32 的指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%BD%8D%E6%8C%87%E4%BB%A4%E5%92%8C-32-%E4%BD%8D%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A0%81%E5%AF%B9%E6%AF%94"><span class="toc-number">11.5.1.</span> <span class="toc-text">16 位指令和 32 位指令的寻址方式和操作数类型编码对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E5%9C%A8-16-%E4%BD%8D%E5%92%8C-32-%E4%BD%8D%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">11.5.2.</span> <span class="toc-text">CPU 在 16 位和 32 位的切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">11.6.</span> <span class="toc-text">一般指令的扩展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-11-%E7%AB%A0-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">第 11 章 进入保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">12.1.</span> <span class="toc-text">全局描述符表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">12.2.</span> <span class="toc-text">段描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">12.2.1.</span> <span class="toc-text">为什么要使用段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%A0%BC%E5%BC%8F"><span class="toc-number">12.2.2.</span> <span class="toc-text">段描述符格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BD%8D"><span class="toc-number">12.2.3.</span> <span class="toc-text">段的属性位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.3.</span> <span class="toc-text">进入保护模式的主要步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B9%B6%E5%8A%A0%E8%BD%BD-GDTR"><span class="toc-number">12.3.1.</span> <span class="toc-text">安装存储器的段描述符并加载 GDTR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lgdt-%E6%8C%87%E4%BB%A4"><span class="toc-number">12.3.2.</span> <span class="toc-text">lgdt 指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%AC%AC-21-%E6%9D%A1%E5%9C%B0%E5%9D%80%E7%BA%BF-A20-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">12.4.</span> <span class="toc-text">关于第 21 条地址线 A20 的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Alt-A20-GATE"><span class="toc-number">12.4.1.</span> <span class="toc-text">Alt_A20_GATE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">12.5.</span> <span class="toc-text">保护模式下的内存访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90"><span class="toc-number">12.5.1.</span> <span class="toc-text">段选择子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%99%A8%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%92%8C-%E5%86%85%E5%AD%98%E7%9A%84%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">12.5.2.</span> <span class="toc-text">保护模式下，描述符高速缓存器的加载过程 和 内存的访问过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B9%B6%E4%B8%B2%E8%A1%8C%E5%8C%96%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">12.6.</span> <span class="toc-text">清空流水线并串行化处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%A0%88"><span class="toc-number">12.7.</span> <span class="toc-text">保护模式下的栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-12-%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-number">13.</span> <span class="toc-text">第 12 章 存储器的保护</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-32-%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.1.</span> <span class="toc-text">进入 32 位保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mov-ds-ax-%E5%92%8C-mov-ds-eax"><span class="toc-number">13.1.1.</span> <span class="toc-text">mov ds,ax 和 mov ds,eax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-GDT-%E5%B9%B6%E5%AE%89%E8%A3%85%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">13.1.2.</span> <span class="toc-text">创建 GDT 并安装段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%97%B6%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-number">13.1.3.</span> <span class="toc-text">修改段寄存器时的保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%B4%A2%E5%BC%95%E5%8F%B7"><span class="toc-number">13.1.3.1.</span> <span class="toc-text">检查索引号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E7%B1%BB%E5%88%AB%E6%A3%80%E6%9F%A5"><span class="toc-number">13.1.3.2.</span> <span class="toc-text">段的类别检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%97%B6%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-number">13.1.4.</span> <span class="toc-text">地址变换时的保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-number">13.1.4.1.</span> <span class="toc-text">代码段执行时的保护</span></a></li></ol></li></ol></li></ol></li></ol></details></div><div class="container post-content"><h1 id="第-0-章-实模式和保护模式简介"><a href="#第-0-章-实模式和保护模式简介" class="headerlink" title="第 0 章 实模式和保护模式简介"></a>第 0 章 实模式和保护模式简介</h1><h2 id="CPU-的工作模式"><a href="#CPU-的工作模式" class="headerlink" title="CPU 的工作模式"></a>CPU 的工作模式</h2><p><code>实模式</code>和<code>保护模式</code>都是 CPU 的工作模式，而 CPU 的工作模式是指 <strong>CPU 的寻址方式</strong>、寄存器大小等用来反映 CPU 在该环境下如何工作的概念。</p>
<h2 id="实模式工作原理"><a href="#实模式工作原理" class="headerlink" title="实模式工作原理"></a>实模式工作原理</h2><ul>
<li>实模式出现于早期 8088CPU 时期。当时由于 CPU 的性能有限，一共只有 20 位地址线（所以地址空间只有 1MB），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。</li>
<li>所以为了能够通过这些 16 位的寄存器去构成 20 位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：<code>(段基址：段偏移量)</code>。</li>
<li>其中第一个字段是段基址，它的值是由<strong>段寄存器</strong>提供的，第二字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的偏移。它的值就是由通用寄存器来提供的。</li>
<li>实模式的 “实” 更多地体现在<strong>其地址是真实的物理地址</strong>。</li>
</ul>
<h2 id="保护模式工作原理"><a href="#保护模式工作原理" class="headerlink" title="保护模式工作原理"></a>保护模式工作原理</h2><ul>
<li><p>随着 CPU 的发展，CPU 的地址线的个数也从原来的 20 根变为 32 根，所以可以访问的内存空间也从 1MB 变为现在 4GB，<strong>寄存器的位数也变为 32 位</strong>。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大空间的，更灵活也<strong>更安全</strong>的内存访问。</p>
</li>
<li><p>在保护模式下，CPU 的 32 条地址线全部有效，可寻址高达 4G 字节的物理地址空间；但是我们的内存寻址方式还是得兼容老办法，即 (段基址：段偏移量) 的表示方式。当然此时 CPU 中的通用寄存器都要换成 32 位寄存器 (除了段寄存器) 来保证寄存器能访问所有的 4GB 空间。</p>
</li>
<li><p>在保护模式下，地址的表示方式与实模式是一样的，都是<code>段基址 : 段内偏移</code>。不过，保护模式下<code>段</code>的概念发生了根本性的改变。实模式下的段值可以看作是地址的一部分，可直接参与转换计算。而保护模式下的段值（尽管仍然由原来的段寄存器表示）变成了一个索引（准确来说是 16 位的段选择子 / 段标识符 Selector，前 13 位为索引信息，后 3 位是硬件信息），指向了一个数据结构的一个表项（段表项），表项中详细定义了<code>段基址</code>、<code>界限</code>、<code>属性（权限）</code>等内容。这个数据结构是 <code>全局描述符表 (GDT)</code> 。它<strong>存放关于某个运行在内存中的程序的分段信息的，比如某个程序的代码段是从哪里开始，有多大；数据段又是从哪里开始，有多大</strong>。</p>
</li>
<li><p>全局描述符表中含有一个个表项，每一个表项称为 <code>段描述符</code>。而段寄存器在保护模式下存放的便是相当于一个数组索引的东西，通过这个索引，可以找到对应的表项。段描述符存放了段基址、段界限、内存段类型属性 (比如是数据段还是代码段，注意<strong>一个段描述符只能用来定义一个内存段</strong>) 等许多属性，段描述符格式具体信息见下图：</p>
<p><img src="/images/v2-1a08d48367745c2870e8818b7881b373_1440w.jpg" alt="img"></p>
</li>
<li><p>其中，段界限表示段边界的扩张最值，即最大扩展多少或最小扩展多少，用 20 位来表示，它的单位可以是字节，也可以是 4KB，这是由 G 位决定的 (G 为 1 时表示单位为 4KB)。实际段界限边界值 =(描述符中的段界限 + 1)*（段界限的单位大小 (即字节或 4KB))-1，如果偏移地址超过了段界限，CPU 会抛出异常。全局描述符表位于内存中，需要用专门的寄存器指向它后， CPU 才知道它在哪里。这个专门的寄存器便是 <code>GDTR</code> (一个 48 位的寄存器), 专门用来存储 GDT 的内存地址及大小。</p>
</li>
</ul>
<blockquote>
<p>保护模式有着不同的内存访问机制，简单地说就是传统的涉及段的几个寄存器如 CS,DS,ES,SS 等被解释为不同的内容 —— 实模式解释为段寄存器，保护模式解释为段选择子。</p>
</blockquote>
<blockquote>
<ul>
<li>实模式的缺点：无法支持多任务；程序的安全性无法得到保证。</li>
<li>在保护模式中，除了内存寻址空间大大提高；提供了硬件对多任务的支持；<strong>物理内存地址也不能直接被程序访问，程序内部的地址 (虚拟地址) 要由操作系统转化为物理地址去访问，程序对此一无所知。</strong></li>
<li>至此，进程 (程序的运行态) 有了严格的边界，任何其他进程根本没有办法访问不属于自己的物理内存区域，甚至在自己的虚拟地址范围内也不是可以任意访问的，因为有一些虚拟区域已经被放进一些公共系统运行库。这些区域也不能随便修改，若修改就会有出现 linux 中的段错误，或 Windows 中的非法内存访问对话框。</li>
</ul>
</blockquote>
<h1 id="第-1-章-十六进制计数法"><a href="#第-1-章-十六进制计数法" class="headerlink" title="第 1 章 十六进制计数法"></a>第 1 章 十六进制计数法</h1><p>无</p>
<h1 id="第-2-章-处理器、内存和指令"><a href="#第-2-章-处理器、内存和指令" class="headerlink" title="第 2 章 处理器、内存和指令"></a>第 2 章 处理器、内存和指令</h1><h3 id="处理器进行数学运算的简单原"><a href="#处理器进行数学运算的简单原" class="headerlink" title="处理器进行数学运算的简单原"></a>处理器进行数学运算的简单原</h3><p><img src="/images/image-20220203175006938.png" alt="image-20220203175006938"></p>
<ul>
<li>在处理器的底部或者四周，有大量的引脚，可以接受从外面来的电信号，或者向外发出电信号。</li>
<li>每个引脚都有自己的用处，在往电路板上安装的时候，不能接错。所以，处理器在生产的时候，都会故意缺一个角，这是一个参照标志，可以确保安装的人不会弄错。</li>
<li>处理器的引脚很多，其中有一部分是用来将参与运算的数字送入处理器内部。有些引脚是复用的，假如现在要进行加法运算，那么我们要重复使用这些引脚，来依次将被加数和加数送入。</li>
</ul>
<h3 id="双字（double-word）"><a href="#双字（double-word）" class="headerlink" title="双字（double word）"></a>双字（double word）</h3><p>寄存器数据宽度示意：</p>
<p><img src="/images/image-20220203175729346.png" alt="image-20220203175729346"></p>
<ul>
<li>32 位寄存器可以存放 4 个字节，这称为 1 个双字（double word），各个数位的编号分别是 0～31，其中 0～15 是低字，16～31 是高字。</li>
<li>同理，还有所谓的<code>四字</code>，<code>八字</code>。</li>
</ul>
<h3 id="处理器多字访问内存"><a href="#处理器多字访问内存" class="headerlink" title="处理器多字访问内存"></a>处理器多字访问内存</h3><p>经过精心的设计和安排，处理器能够按字节、字、双字和四字进行访问。换句话说，仅通过单次访问就能处理8 位、16 位、32 位或者64 位的二进制数。</p>
<blockquote>
<p>注意，是单次访问，而不是一个一个地取出每个字节，然后加以组合。</p>
</blockquote>
<p><img src="/images/image-20220203180323911.png" alt="image-20220203180323911"></p>
<p>处理器发出字长控制信号，以指示本次访问的字长是 8、16、32 还是 64 。如果字长是 8，而且给出的地址是 0002H，那么，本次访问只会影响到内存的一字节；<strong>如果字长是 16，给出的地址依然是 0002H，那么实际访问的将是地址 0002H 处的一个字</strong>，低 8 位在0002H 中，高 8 位在 0003H 中。</p>
<blockquote>
<p>这里可以联系<code>大小端存储</code>知识点，正是因为处理器支持<strong>多字访问内存</strong>，才方便各个硬件厂商使用大端/小端存储。</p>
</blockquote>
<h3 id="8086-的内存分段机制"><a href="#8086-的内存分段机制" class="headerlink" title="8086 的内存分段机制"></a>8086 的内存分段机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure>

<ul>
<li>如上，这里会将<code>1000:0</code>处存放的字型数据送入ax。</li>
<li>这里其实使用了 8086 的 <code>内存分段机制</code>，也就是：一个内存单元的地址实际上就可以用 <strong>段地址：偏移地址</strong> 来表示。</li>
<li>8086 的这种分段机制其实就是一种逻辑地址。这是 8086 为了解决 <code>物理地址变动</code> 的问题。</li>
</ul>
<ul>
<li>大多数时候，整个程序（包括代码段和数据段）在内存中的位置并不是我们能够决定的。你所运行的程序，在内存中被加载的位置完全是随机的。所以，我们不能使用绝对内存地址（物理地址）。为了程序能在内存中的任何地方正确执行，就只能在编写程序的时候使用相对地址或者逻辑地址了，当程序加载时，这些相对地址还要根据程序实际被加载的位置重新计算。</li>
<li>为了在硬件一级提供对“段地址：偏移地址”内存访问模式的支持，处理器至少要提供两个段寄存器，分别是代码段寄存器（Code Segment， CS）和数据段寄存器（Data Segment，DS）。对 CS 内容的改变将导致处理器从新的代码段开始执行。同样，在开始访问内存中的数据之前，也必须首先设置好 DS 寄存器，使之指向数据段。</li>
<li>当处理器访问内存时，它把指令中指定的内存地址看成是段内的偏移地址，而不是物理地址。这样，一旦处理器遇到一条访问内存的指令，它将把 DS 中的数据段起始地址和指令中提供的段内偏移相加，来得到访问内存所需要的物理地址。</li>
<li>所以，如果下次要执行程序时，代码段和数据段在内存中的位置就会发生变化，此时<strong>只要把它们的段地址分别传送到 CS 和 DS，就能够正确执行</strong>。</li>
</ul>
<h3 id="8086-指令预取队列"><a href="#8086-指令预取队列" class="headerlink" title="8086 指令预取队列"></a>8086 指令预取队列</h3><p>8086 处理器内部组成框图：</p>
<p><img src="/images/image-20220203193308489.png" alt="image-20220203193308489"></p>
<ul>
<li><code>数据暂存器</code>： 其实也是一种寄存器。</li>
<li>处理器能够自动运行，这是控制器的功劳。为了加快指令执行速度，8086 内部有一个 6 字节的 <code>指令预取队列</code>，在处理器忙着执行那些不需要访问内存的指令时，指令预取部件可以趁机访问内存预取指令。这时，多达 6 个字节的指令流可以排队等待解码和执行。</li>
</ul>
<h1 id="第-3-章-汇编语言和汇编软件"><a href="#第-3-章-汇编语言和汇编软件" class="headerlink" title="第 3 章 汇编语言和汇编软件"></a>第 3 章 汇编语言和汇编软件</h1><p>无</p>
<h1 id="第-4-章-虚拟机的安装和使用"><a href="#第-4-章-虚拟机的安装和使用" class="headerlink" title="第 4 章 虚拟机的安装和使用"></a>第 4 章 虚拟机的安装和使用</h1><p>每种操作系统都对它所管理的程序提出了种种格式上的要求。比如，它要求编译好的程序必须在文件的开始部分包含编译日期，是针对哪种操作系统编译的，程序的版本，第一条指令从哪里开始，数据段从哪里开始、有多长，代码段从哪里开始、有多长等等。</p>
<h2 id="计算机的启动过程"><a href="#计算机的启动过程" class="headerlink" title="计算机的启动过程"></a>计算机的启动过程</h2><h3 id="计算机的加电和复位"><a href="#计算机的加电和复位" class="headerlink" title="计算机的加电和复位"></a>计算机的加电和复位</h3><p>在处理器众多的引脚中，有一个是 <code>RESET</code>，用于接受复位信号。每当处理器加电，或者 RESET 引脚的电平由低变高时处理器都会执行一个 <code>硬件初始化</code>，以及一个可选的内部自测试（Build-in Self-Test， BIST），然后将内部所有寄存器的内容初始到一个预置的状态。</p>
<blockquote>
<ul>
<li>比如，当你按下主机箱面板上的 RESET 按钮时，就会导致 RESET 引脚电平的变化，从而使计算机热启动。</li>
<li>对于 8086 来说，复位将使代码段寄存器（CS）的内容为 0xFFFF，其他所有寄存器的内容都为 0x0000，包括指令指针寄存器（IP）。</li>
</ul>
</blockquote>
<h3 id="基本输入输出系统"><a href="#基本输入输出系统" class="headerlink" title="基本输入输出系统"></a>基本输入输出系统</h3><ul>
<li>8086 有 20 根地址线，但并非全都用来访问 DRAM，也就是内存条。 事实上，这些地址线经过分配，大部分（00000-9FFFF）用于访问 DRAM，剩余的部分（F0000-FFFFF）给了只读存储器 ROM 和外围的板卡。</li>
<li>8086 中，ROM 占据着整个内存空间顶端的 64KB，物理地址范围是 0xF0000～0xFFFFF，里面固化了开机时要执行的指令；DRAM 占据着较低端的 640KB，地址范围是 0x00000～0x9FFFF；中间还有一部分，分给了其他外围设备。</li>
<li>8086 加电或者复位时，CS=0xFFFF，IP=0x0000，所以它取的第一条指令位于物理地址 0xFFFF0，正好位于 ROM 中，那里固化了开机时需要执行的指令。0xFFFF0 离 1MB 内存的顶端（0xFFFFF）只有16 个字节的长度，一旦 IP 寄存器的值超过 0x000F，那么，它与 CS 一起形成的物理地址将溢出，这将回绕到内存的最低端。所以，<strong>ROM 中位于物理地址 0xFFFF0 的地方，通常是一个跳转指令</strong>。</li>
</ul>
<h2 id="硬盘及其工作原理"><a href="#硬盘及其工作原理" class="headerlink" title="硬盘及其工作原理"></a>硬盘及其工作原理</h2><p>硬盘的结构示意图：</p>
<p><img src="/images/image-20220208113801033.png" alt="image-20220208113801033"></p>
<ul>
<li><p>每个盘片都有两个磁头（Head），上面一个，下面一个，所以经常用磁头来指代盘面。</p>
</li>
<li><p>磁头都有编号，第 1 个盘片，上面的磁头编号为 0， 下面的磁头编号为 1；第 2 个盘片，上面的磁头编号为 2，下面的磁头编 号为 3，以此类推。</p>
</li>
<li><p>磁道，或者柱面，也要编号。编号是从盘面<strong>最边缘的那条磁道开始，向着圆心的方向</strong>，从 0 开始编号。</p>
<blockquote>
<p>为了加速数据在硬盘上的读写，尽量不移动磁头。这样，当 0 面的磁道不足以容纳要写入的数据时，应当把剩余的部分写在 1 面的同一磁道上。如果还写不下，那就继续把剩余的部分写在 2 面 的同一磁道上。换句话说，<strong>在硬盘上，数据的访问是以柱面来组织的</strong>。</p>
</blockquote>
</li>
<li><p>每条磁道能够划分为几个扇区，每个扇区都有一个编号，与磁头和磁道不同，<strong>扇区的编号是从 1 开始的</strong>。</p>
<blockquote>
<ul>
<li>扇区与扇区之间<strong>以间隙（空白）间隔开来</strong>，每个扇区以扇区头开始，然后是 512 个字节的数据区。</li>
<li>扇区头包含了每个扇区自己的信息， 主要有本扇区的磁道号、磁头号和扇区号，用来供硬盘定位机构使用。</li>
<li>现代的硬盘还会在扇区头部包括一个指示扇区是否健康的标志，以及用来替换该扇区的扇区地址。用于替换扇区的，是一些保留和隐藏的磁道。</li>
</ul>
</blockquote>
</li>
</ul>
<p>采用磁头、磁道和扇区这种模式来访问硬盘的方法称为 CHS 模式， 但不是很方便。想想看，如果有一大堆数据要写，还得注意磁头号、磁道号和扇区号不要超过界限。所以，后来引入了逻辑块地址（Logical Block Address，LBA）的概念。现在市场上销售的硬盘，无论是哪个厂家生产的，都支持 LBA 模式。</p>
<ul>
<li>LBA 模式不考虑扇区的物理位置（磁头号、磁道号），而是把它们全部组织起来统一编号。在这种编址方式下，原先的物理扇区被组织成逻辑扇区，且都有唯一的逻辑扇区号。</li>
<li>比如，某硬盘有 6 个磁头，每面有 1000 个磁道，每磁道有 17 个扇 区。那么： <ul>
<li>逻辑 0 扇区对应着 0 面 0 道 1 扇区； </li>
<li>逻辑 1 扇区对应着 0 面 0 道 2 扇区；</li>
<li>逻辑 16 扇区对应着 0 面 0 道 17 扇区； </li>
<li><strong>逻辑 17 扇区对应着 1 面 0 道 1 扇区</strong>； </li>
<li>逻辑 18 扇区对应着 1 面 0 道 2 扇区；</li>
</ul>
</li>
<li><strong>扇区在编号时，是以柱面为单位的</strong>。即，先是 0 面 0 道， 接着是 1 面 0 道，直到把所有盘面上的 0 磁道处理完，再接着处理下一个柱面。之所以这样做，是因为我们讲过，要加速硬盘的访问速度，最好是尽可能不移动磁头。</li>
</ul>
<h2 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h2><ul>
<li><strong>硬盘的第一个扇区是 0 面 0 道 1 扇区</strong>，或者说是 0 头 0 柱 1 扇区，这个扇区称为 <code>主引导扇区</code>。</li>
<li>如果计算机的设置是从硬盘启动，那么，ROM-BIOS 将读取硬盘主引导扇区的内容，将它加载到内存地址 0x0000:0x7c00 处（也就是物理地址0x07C00），然后用指令 <code>jmp 0x0000:0x7c00</code> 跳到那里执行。</li>
<li>主引导扇区的功能是继续从硬盘的其他部分读取更多的内容加以执行。像 Windows 这样的操作系统，就是采用这种接力的方法一步一步把自己运行起来的。</li>
</ul>
<h1 id="第-5-章-编写主引导扇区代码"><a href="#第-5-章-编写主引导扇区代码" class="headerlink" title="第 5 章 编写主引导扇区代码"></a>第 5 章 编写主引导扇区代码</h1><h2 id="计算机启动顺序"><a href="#计算机启动顺序" class="headerlink" title="计算机启动顺序"></a>计算机启动顺序</h2><p>计算机启动顺序：</p>
<ol>
<li>上电</li>
<li>读取 ROM 里面的 BIOS，用来检查硬件（Power On Self Test）</li>
<li>硬件检查通过</li>
<li><strong>BIOS 根据指定的顺序，检查引导设备的第一个扇区（即主引导记录），将这个扇区加载在内存地址 0x7c00 处</strong></li>
<li>主引导记录把操作权交给操作系统</li>
</ol>
<ul>
<li>处理器加电或者复位之后， 如果硬盘是首选的启动设备，那么，ROM-BIOS 将试图读取硬盘的 0 面 0 道 1 扇区。传统上，这就是 <code>主引导扇区</code>（Main Boot Sector，MBR）。</li>
<li>读取的主引导扇区数据有 512 字节，ROM-BIOS 程序将它加载到逻辑地址 0x0000:0x7c00 处，也就是物理地址 0x07c00 处，然后判断它是否有效。</li>
<li>一个有效的主引导扇区，其最后两字节应当是 0x55 和 0xAA。ROMBIOS 程序首先检测这两个标志，如果主引导扇区有效，则以一个段间转移指令 <code>jmp 0x0000:0x7c00</code> 跳到那里继续执行。</li>
<li>主引导扇区是由操作系统负责的。它把操作系统的自举代码加载到内存，也用 jmp 指令跳转到那里继续执行，直到操作系统完全启动。</li>
</ul>
<h2 id="显卡和显存"><a href="#显卡和显存" class="headerlink" title="显卡和显存"></a>显卡和显存</h2><ul>
<li><p>为了显示文字，通常需要两种硬件，一是<code>显示器</code>，二是<code>显卡</code>。</p>
<ul>
<li>显卡的职责是为显示器提供内容，并控制显示器的显示模式和状态，</li>
<li>显示器的职责是将那些内容以视觉可见的方式呈现在屏幕上。</li>
</ul>
</li>
<li><p>显卡都有自己的存储器，因为它位于显卡上，故称显示存储器（Video RAM：VRAM），简称<code>显存</code>，要显示的内容都预先写入显存。</p>
</li>
<li><p>显卡的工作是周期性地从显存中提取比特，并把它们按顺序显示在屏幕上。现在最流行的，是用 24 个比特，即 3 个字节，来对应一个像素 。</p>
</li>
<li><p>在不同的工作模式下，显卡对显存内容的解释是不同的。显卡的两种基本工作模式如下：</p>
<ul>
<li><code>文本模式</code></li>
<li><code>图形模式</code></li>
</ul>
<p><img src="/images/image-20220208140654063.png" alt="image-20220208140654063"></p>
</li>
<li><p>因为显示功能对于现代计算机来说实在是太重要了。8086 处理器中，0xA0000～0xEFFFF 这段地址空间由特定的外围设备来提供，其中就包括显卡。一直以来，0xB8000～0xBFFFF 这段物理地址空间，是留给显卡的。</p>
<p><strong>文本模式下显存到内存的映射</strong>如下：</p>
<p><img src="/images/image-20220208141112124.png" alt="image-20220208141112124"></p>
</li>
</ul>
<h2 id="访问显存"><a href="#访问显存" class="headerlink" title="访问显存"></a>访问显存</h2><ul>
<li><p>和访问主内存一样，为了访问显存，也需要使用逻辑地址，也就是 采用“段地址：偏移地址”的形式。</p>
</li>
<li><p>考虑到<strong>文本模式下</strong>显存的起始物理地址是0xB8000，这块内存可以看成是段地址为 0xB800。</p>
</li>
<li><p>屏幕上的每个字符对应着显存中的两个连续字节，前一个是字符的 ASCII 代码，后面是字符的显示属性，包括字符颜色（前景色）和底色 （背景色）。</p>
<blockquote>
<ul>
<li>Eg：字符“H”的 ASCII 代码是 0x48 ，其显示属性是 0x07；字符“e”的 ASCII 代码是 0x65，其显示属性是 0x07。</li>
<li>K 是闪烁位，为 0 时不闪烁，为 1 时闪烁；I 是亮度位， 为 0 时正常亮度，为 1 时呈高亮。</li>
<li>所以，字符属性 0x07 可以解释为黑底白字，无闪烁，无加亮。</li>
</ul>
<p><img src="/images/image-20220208142127968.png" alt="image-20220208142127968"></p>
<p><img src="/images/image-20220208142257464.png" alt="image-20220208142257464"></p>
</blockquote>
<blockquote>
<p>当屏幕上一片漆黑，什么内容都没有的时候，显 存里会是什么内容呢？实际上，这个时候，<strong>屏幕上显示的全是黑底白字的空格字符</strong>。</p>
</blockquote>
</li>
<li><p>eg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0xb800  ;指向文本模式的显示缓冲区</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">;显示字符串&quot;La&quot;</span><br><span class="line">mov byte [es:0x00],&#x27;L&#x27;</span><br><span class="line">mov byte [es:0x01],0x07</span><br><span class="line">mov byte [es:0x02],&#x27;a&#x27;</span><br><span class="line">mov byte [es:0x03],0x07</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="显示标号的汇编地址"><a href="#显示标号的汇编地址" class="headerlink" title="显示标号的汇编地址"></a>显示标号的汇编地址</h2><ul>
<li><p>处理器访问内存时，采用的是“段地址：偏移地址”的模式。为了支持这种内存访问模式，在源程序的编译阶段，编译器会把源程序整体上作为一个独立的段来处理，并<strong>从 0 开始计算和跟踪每一条指令的地址</strong>。因为该地址是在编译期间计算的，故称为<code>汇编地址 </code>。</p>
</li>
<li><p>在源程序编译期间，<strong>汇编地址指示该指令相对于程序或者段起始处的距离</strong>， 以字节计。当编译后的程序装入物理内存后，因为程序是整体加载入内存的，所以汇编地址又是该指令在内存段内的偏移地址。</p>
</li>
<li><p>对于指令<code>infi: jmp near infi</code>，行首带冒号的是标号是“infi”。假设这条指令的汇编地址是 0x0000012B， 故 infi 就代表数值 0x0000012B，或者说 <strong>infi 是 0x0000012B 的符号化表示</strong>。</p>
<blockquote>
<ul>
<li>实际上，这是一个 3 字节指令，操作码是 0xE9，后跟一个 16 位（两字节）的操作数。但是，该操作数并非目标位置的偏移地址，而是目标位置相对于当前指令处的<code>偏移量</code>（以字节为单位）。</li>
<li>在编译阶段，编译器是这么做的：用标号（目标位置）处的汇编地址减去当前指令的汇编地址，再减去当前指令的长度（3），就得到了 jmp near infi 指令的实际操作数。</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="第-6-章-相同的功能，不同的代码"><a href="#第-6-章-相同的功能，不同的代码" class="headerlink" title="第 6 章 相同的功能，不同的代码"></a>第 6 章 相同的功能，不同的代码</h1><h2 id="NASM-编译器的-和-标记"><a href="#NASM-编译器的-和-标记" class="headerlink" title="NASM 编译器的$和$$标记"></a>NASM 编译器的$和$$标记</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">times 510-($-$$) db 0</span><br></pre></td></tr></table></figure>

<ul>
<li>NASM 编译器提供了一个标记<code>$</code>，该标记等同于标号，你可以把它看成是一个隐藏在当前行行首的标号。因此，<code>jmp near $</code>的意 是，转移到当前指令继续执行，它和<code>infi: jmp near infi</code>是一样的，没有区别，但不需要使用标号，更不必为给标号起一个有意义的名字而伤脑筋。</li>
<li><code>$$</code>是NASM 编译器提供的另一个标记，代表当前<strong>段的起始汇编地址</strong>。当前程序没有定义节或段，就默认地自成一个汇编段，而且起始的汇编地址是0（程序起始处）。</li>
<li><code>($-$$)</code>： 用当前汇编地址减去程序开头的汇编地址（0），就是程序实体的大小。 </li>
</ul>
<h1 id="第-7-章-比高斯更快的计算"><a href="#第-7-章-比高斯更快的计算" class="headerlink" title="第 7 章 比高斯更快的计算"></a>第 7 章 比高斯更快的计算</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>简单地说，寻址方式就是如何找到要操作的数据，以及如何找到存放操作结果的地方。</p>
<ul>
<li>寄存器寻址</li>
<li>立即数寻址</li>
<li>内存寻址</li>
</ul>
<h1 id="第-8-章-硬盘和显卡的访问与控制"><a href="#第-8-章-硬盘和显卡的访问与控制" class="headerlink" title="第 8 章 硬盘和显卡的访问与控制"></a>第 8 章 硬盘和显卡的访问与控制</h1><h2 id="用户程序的结构"><a href="#用户程序的结构" class="headerlink" title="用户程序的结构"></a>用户程序的结构</h2><ul>
<li><p>处理器的工作模式是<strong>将内存分成逻辑上的段，指令的获取和数据的访问一律按“段地址：偏移地址”的方式进行</strong>。相对应地，一个规范的程序，应当包括代码段、数据段、附加段和栈段。</p>
</li>
<li><p>编译器不关心段的用途，可能也根本不知道段的用途，不知道它是数据段，还是代码段，或是栈段。事实上，这都不重要，<strong>段只用来分隔程序中的不同内容</strong>。</p>
</li>
<li><p>Intel 处理器要求段在内存中的起始物理地址起码是16 字节对齐的。 意思是该物理地址必须能被16 整除。 相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。 具体做法是，在段定义中使用 <code>align=</code> 子句，用于指定某个 SECTION 的汇编地址对齐方式。</p>
<blockquote>
<p>比如说， <code>align=16</code> 就表示段是 16 字节对齐的， <code>align=32</code> 就表示段是 32 字节对齐的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">section data1 align=16</span><br><span class="line">	db 0x55</span><br><span class="line"></span><br><span class="line">section data2 align=16</span><br><span class="line">	db 0xaa</span><br><span class="line">	</span><br><span class="line">section data3 align=16</span><br><span class="line">	db 0x99</span><br></pre></td></tr></table></figure>

<p>注意上面代码，段 data1 的起始汇编地址是 0。地址 0 本身就是 16 字节对齐的，符合 align 子句的要求。段 data2 也要求是 16 字节对齐的。于是，编译器将 0x00000010 作为段 data2 的汇编地址，并在两个段之间填充 15 字节的 0x00（段data1 只有 1 字节的长度）。</p>
</li>
<li><p>每个段都有一个汇编地址，它是相对于整个程序开头（0）的。为了方便取得该段的汇编地址，NASM 编译器可以使用 <code>section.段名称.start</code> 来获取段的汇编地址。</p>
</li>
<li><p>段定义语句还可以包含<code>vstart=c</code>子句。其功能是：引用段内的某个标号时，该标号处的汇编地址是从段的开头处(c)计算的。也就是说：<strong>vstart 指明段内汇编地址起始位置，该段内的汇编的地址都是从 vstart 开始算的</strong>。</p>
<blockquote>
<p>简单来说，<code>vstart=</code>子句影响了<code>段内标号</code>的汇编地址，决定了其是<strong>从程序开始计算</strong>还是<strong>从段内开始计算</strong>。</p>
</blockquote>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECTION mbr align=16 vstart=0x7c00</span><br><span class="line">		mov ax,0</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,ax</span><br><span class="line">@1:</span><br><span class="line">		cmp ax,0</span><br><span class="line">		jz direct</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="用户程序头部"><a href="#用户程序头部" class="headerlink" title="用户程序头部"></a>用户程序头部</h2><ul>
<li><p>加载器在加载用户程序的时候，需要知道用户程序的一些信息，用于知道如何加载该用户程序。约定把这些信息放在用户程序的开头，这就是<code>用户程序头部</code>。</p>
</li>
<li><p>用户程序头部<strong>在源程序以一个段的形式出现</strong>。用户程序头部起码要包含以下信息：</p>
<ul>
<li><code>用户程序的总长度</code>：加载器需要根据这一信息来决定读取多少个逻辑扇区。</li>
<li><code>应用程序的入口点</code>，包括段地址和偏移地址：第一条指令的段地址和偏移地址。</li>
<li><code>段重定位表项数</code>：有多少个需要重定位的段。</li>
<li><code> 段重定位表</code>：用户程序可能包含不止一个段，大程序会包含多个代码段和多个数据段。这些段如何使用，是用户程序自己的 事，程序加载到内存后，每个段的地址必须重新确定一下。</li>
</ul>
<p><img src="/images/image-20220209174758319.png" alt="image-20220209174758319"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code_1.start ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    realloc_tbl_len dw (header_end-code_1_segment)/4 ;段重定位表项个数[0x0a]</span><br><span class="line">    </span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_1_segment  dd section.code_1.start ;[0x0c]</span><br><span class="line">    code_2_segment  dd section.code_2.start ;[0x10]</span><br><span class="line">    data_1_segment  dd section.data_1.start ;[0x14]</span><br><span class="line">    data_2_segment  dd section.data_2.start ;[0x18]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    </span><br><span class="line">    header_end:</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION code_1 align=16 vstart=0         ;定义代码段1（16字节对齐）</span><br><span class="line">	...</span><br><span class="line">  start:</span><br><span class="line">         mov ax,[stack_segment]</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION code_2 align=16 vstart=0 </span><br><span class="line">	...</span><br><span class="line">SECTION data_1 align=16 vstart=0</span><br><span class="line">	...</span><br><span class="line">SECTION data_2 align=16 vstart=0</span><br><span class="line">	...</span><br><span class="line">SECTION stack align=16 vstart=0</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION trail align=16</span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="外围设备及其接口"><a href="#外围设备及其接口" class="headerlink" title="外围设备及其接口"></a>外围设备及其接口</h2><ul>
<li><p>加载器的下一个工作是从硬盘读取用户程序，说白了就是访问其他硬件。</p>
</li>
<li><p><strong>不同的硬件使用不同的 I/O 接口</strong>。USB 键盘使用名为 USB 的 I/O 接口，硬盘使用名为 SATA 的 I/O 接口，声卡使用名为 PCI 的  I/O 接口，等等。</p>
</li>
<li><p>不可能将所有的 I/O 接口直接和处理器相连，设备那么多，还有些设备现在没有发明出来，将来一定会有。怎么办？</p>
<p><strong>采用总线技术</strong>。总线可以认为是一排电线，所有的外围设备，包括处理器，都连接到这排电线上。每个连接到这排电线上的器件都必须有拥有电子开关，使它们随时能够同这排电线连接，或者从这排电线上断开（脱离）。这就好比是公共车道，当路面上有车时，你就必须退避一下，不能硬冲上去。因此，这排公共电线就称为<code>总线</code>。</p>
</li>
<li><p>每个设备的 I/O 接口都抢着和处理器说话，不发生冲突都难。怎么办？</p>
<p>使用<strong>输入输出控制设备集中器（I/O Controller Hub，ICH）芯片</strong>。该芯片的作用是连<strong>接不同的总线，并协调各个 I/O 接口对处理器的访问</strong>。在个人计算机上，这块芯片就是所谓的<code>南桥</code>。</p>
<blockquote>
<p>ICH 内部集成了一些常规的外围设备接口， 如 USB 、PATA（IDE）、SATA、老式总线接口（LPC）、时钟等。</p>
</blockquote>
</li>
<li><p>处理器通过局部总线连接到 ICH 内部的处理接口电路。然后，在 ICH 内部，又通过总线与各个 I/O 接口相连。</p>
<p><img src="/images/image-20220209154009257.png" alt="image-20220209154009257"></p>
</li>
<li><p>当处理器想同某个设备说话时，ICH 会接到通知。然后它负责提供相应的传输通道和其他辅助支持，并命令所有其他无关设备闭嘴。同样，当某个设备要跟处理器说话，情况也是一样。</p>
</li>
</ul>
<h2 id="I-O-端口和端口访问"><a href="#I-O-端口和端口访问" class="headerlink" title="I/O 端口和端口访问"></a>I/O 端口和端口访问</h2><ul>
<li><p>处理器是通过端口（Port）来和外围设备打交道的。<strong>本质上，端口就是一些寄存器</strong>，类似于处理器内部的寄存器。不同之处仅仅 在于，这些叫做端口的寄存器位于 I/O 接口电路中。</p>
</li>
<li><p>每个 I/O 接口都可能拥有好几个端口，分别用于不同的目的。</p>
<blockquote>
<p>比如，连接硬盘的 PATA/SATA 接口就有几个端口，分别是</p>
<ul>
<li>命令端口：当向该端口写入 0x20 时，表明是从硬盘读数据；写入 0x30 时，表明是向硬盘写数据</li>
<li>状态端口：处理器根据这个端口的数据来判断硬盘工作是否正常，操作是否成功，发生了哪种错误</li>
<li>参数端口：处理器通过这些端口告诉硬盘读写的扇区数量，以及起始的逻辑扇区号</li>
<li>数据端口：通过这个端口连续地取得要读出的数据，或者通过这个端口连续地发送要写入硬盘的数据</li>
</ul>
</blockquote>
</li>
<li><p>在一些计算机系统中，<strong>端口号是映射到内存地址空间的</strong>。比如 0xE0001～0xFFFFF 是从很多I/O 接口那里映射过来的，当访问这部分地址时，实际上是在访问 I/O 接口。</p>
</li>
<li><p>在另一些计算机系统中，端口是独立编址的，不和内存发生关系。</p>
<blockquote>
<ul>
<li>在这种计算机中，处理器的地址线既连接内存，也连接每一个I/O 接口。处理器还有一个特殊的引脚<code>M/IO#</code>，<code>#</code>表示低电平有效。</li>
<li>当处理器访问内存时，它会让 <code>M/IO#</code> 引脚呈高电平，此时和内存相关的电路就会打开。</li>
<li>当处理器访问 I/O 端口，那么<code>M/IO#</code>引脚呈低平，内存电路被禁止，同时打开某个I/O 接口。</li>
</ul>
</blockquote>
<p><img src="/images/image-20220209160244147.png" alt="image-20220209160244147"></p>
</li>
<li><p>访问端口：<strong>读取端口只能使用al，ax</strong>。bx，cx都不行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h ; 从60h号端口读入一个字节</span><br></pre></td></tr></table></figure>

<p>执行时与总线相关的操作流程：</p>
<ol>
<li>CPU通过地址线将地址信息60h发出</li>
<li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据</li>
<li>端口所在的芯片将60h端口中的数据通过数据线送入CPU</li>
</ol>
</li>
<li><p>写入端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out 0x37, al  ; 写0x37号端口（这是一个8位端口）</span><br><span class="line">out 0xf5, ax  ; 写0xf5号端口（这是一个16位端口）</span><br><span class="line">out dx, al    ; 这是一个8位端口，端口号在寄存器DX中</span><br><span class="line">out dx, ax    ; 这是一个16位端口，端口号在寄存器DX中</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="通过硬盘控制器端口读扇区数据"><a href="#通过硬盘控制器端口读扇区数据" class="headerlink" title="通过硬盘控制器端口读扇区数据"></a>通过硬盘控制器端口读扇区数据</h2><ul>
<li><strong>硬盘读写的基本单位是扇区</strong>。就是说，要读就至少读一个扇区，要写就至少写一个扇区，不可能仅读写一个扇区中的几个字节。这样一 来，就使得主机和硬盘之间的数据交换是成块的，所以硬盘是典型的块设备。</li>
<li>从硬盘读写数据，最经典的方式是向硬盘控制器分别发送<code>磁头号（Heads）</code>、 <code>柱面号(Cylinder)</code>和<code>扇区号(Sector)</code>，这称为<code>CHS 模式</code>。</li>
<li><code>LBA28 模式</code>：使用逻辑扇区进行访问。使用 28 个比特来表示逻辑扇区号，从逻辑扇区 0x0000000 到 0xFFFFFFF，共可以表示2^28＝268435456 个扇区。每个扇区有 512 字节，所以 LBA28 可以管理 128 GB 的硬盘。</li>
<li><code>LBA48 模式</code>：使用 48 个比特来表示逻辑扇区号，就可以管理 131072 TB 的硬盘容量了。</li>
</ul>
<h3 id="LBA28-模式下，从硬盘上读逻辑扇区的过程"><a href="#LBA28-模式下，从硬盘上读逻辑扇区的过程" class="headerlink" title="LBA28 模式下，从硬盘上读逻辑扇区的过程"></a>LBA28 模式下，从硬盘上读逻辑扇区的过程</h3><p>LBA28 模式下，从硬盘上读逻辑扇区的过程如下：</p>
<ol>
<li><p><strong>设置要读取的扇区数量</strong>。</p>
<p>这个数值要写入0x1f2 端口。这是 个8 位端口，因此每次只能读写255 个扇区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 0x1f2</span><br><span class="line">mov al, 0x01  ; 读取1个扇区</span><br><span class="line">out dx, al</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果写入的值为 0，则表示要读取 256 个扇区。每读一个扇区，这个数值就减一。因此，如果在读写过程中发生错误，该端口包含着尚未读取的扇区数。</p>
</blockquote>
</li>
<li><p><strong>设置起始LBA 扇区号</strong>。</p>
<ul>
<li><p>扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。</p>
</li>
<li><p>28 位的扇区号太长，需要将其分成4 段，分别写入端口0x1f3、0x1f4、0x1f5 和0x1f6 号端口。</p>
<ul>
<li>0x1f3 号端口存放的是 0～7 位</li>
<li>0x1f4 号端口存放的是 8～15 位</li>
<li>0x1f5 号端口存放的是 16～23 位</li>
<li>0x1f6 号端口存放的是 24～27 位</li>
</ul>
</li>
<li><p>假定我们要读写的起始逻辑扇区号为0x02</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 0x1f3</span><br><span class="line">mov al, 0x02</span><br><span class="line">out dx, al     ;LBA地址7～0</span><br><span class="line"></span><br><span class="line">inc dx         ;0x1f4</span><br><span class="line">mov al, 0x00</span><br><span class="line">out dx, al     ;LBA地址15～8</span><br><span class="line"></span><br><span class="line">inc dx         ;0x1f5</span><br><span class="line">out dx, al     ;LBA地址23～16</span><br><span class="line"></span><br><span class="line">inc dx         ;0x1f6</span><br><span class="line">mov al, 0xe0   ;LBA模式，主硬盘，以及LBA地址27～14</span><br><span class="line">out dx, al</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在现行的体系下，每个PATA/SATA 接口允许挂接两块硬盘，分别是主盘（Master）和从盘（Slave）</li>
<li>0x1f6 端口的低 4 位用于存放逻辑扇区号的24～27位，</li>
<li>第 4 位用于指示硬盘号，0 表示主盘，1 表示从盘。</li>
<li>高 3 位是“111”，表示 LBA 模式。</li>
</ul>
<p><img src="/images/image-20220209163506361.png" alt="image-20220209163506361"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>向端口 0x1f7 写入 0x20</strong>，请求硬盘读。</p>
<p>这也是一个 8 位端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 0x1f7</span><br><span class="line">mov al, 0x20</span><br><span class="line">out dx, al</span><br></pre></td></tr></table></figure></li>
<li><p><strong>等待读写操作完成</strong>。</p>
<ul>
<li><p>端口 0x1f7 既是命令端口，又是状态端口。在通过这个端口发送读写命令之后，硬盘就忙乎开了。在它内部操作期间，它将0x1f7 端口的第7位置“1”，表明自己很忙。 一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3位置“1”，意思是准备好了，请求主机发送或者接收数据。</p>
</li>
<li><p>端口 0x1f7 部分状态位的含义：</p>
<p><img src="/images/image-20220209164410414.png" alt="image-20220209164410414"></p>
</li>
<li><p>计算机处理器「等待读写操作硬盘完毕」这一步的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 0x1f7</span><br><span class="line">.waits:</span><br><span class="line">	in al, dx    ; 从硬盘的0x1f7端口读取数据</span><br><span class="line">	and al, 0x88 ; 0x88的二进制形式是10001000，意味着我们想保留住AL中的第7位和第3位，其他位清零</span><br><span class="line">	cmp al, 0x08 ; 如果AL是00001000（0x08），就说明可以退出等待状态，继续往下操作，否则继续等待。</span><br><span class="line">	jnz .waits.  ; 不忙，且硬盘已经准备好数据传输</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>连续取出数据</strong></p>
<ul>
<li><p>0x1f0 是硬盘接口的数据端口，而且还是一个 16 位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。</p>
</li>
<li><p>下面的代码假定是从硬盘读一个扇区（512 字节），读取的数据存放到由段寄存器 DS 指定的数据段， 偏移地址由寄存器BX 指定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov cx, 256    ; 总共要读取的字数</span><br><span class="line">mov dx, 0x1f0</span><br><span class="line">.readw:</span><br><span class="line">	in ax, dx</span><br><span class="line">	mov [bx], ax</span><br><span class="line">	add bx, 2</span><br><span class="line">	loop .readw</span><br></pre></td></tr></table></figure></li>
<li><p>0x1f1 端口是错误寄存器，包含硬盘驱动器最后一次执行命令 后的状态（错误原因）</p>
</li>
</ul>
</li>
</ol>
<h2 id="加载程序（器）的工作流程"><a href="#加载程序（器）的工作流程" class="headerlink" title="加载程序（器）的工作流程"></a>加载程序（器）的工作流程</h2><p>工作流程（具体流程可以往下看）：</p>
<ol>
<li><code>初始化和决定加载位置</code>：决定从哪个物理内存地址开始加载用户程序，确定用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少。</li>
<li><code>准备加载用户程序</code>：将主引导扇区程序定义成一个段。让段内所有元素的汇编地址都将从 0x7c00 开始计算。</li>
<li><code>读取用户程序的第一个扇区</code>：从硬盘上读取用户程序的第一扇区。第一扇区包括有用户程序头部，以及一部分实际的指令和数据。</li>
<li><code>加载用户程序</code>：根据用户程序头部的信息，将用户程序全部读入内存。</li>
<li><code>用户程序重定位</code>：计算和确定每个段的段地址。</li>
<li><code>将控制权交给用户程序</code>：现在，用户程序已经在内存中准备就绪，剩下的工作就是把处理器的控制权交给它。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">         ;代码清单8-1</span><br><span class="line">         ;文件名：c08_mbr.asm</span><br><span class="line">         ;文件说明：硬盘主引导扇区代码（加载程序） </span><br><span class="line">         ;创建日期：2011-5-5 18:17</span><br><span class="line">         </span><br><span class="line">         app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）</span><br><span class="line">                                         ;常数的声明不会占用汇编地址</span><br><span class="line">                                    </span><br><span class="line">SECTION mbr align=16 vstart=0x7c00       ;将主引导扇区程序定义成一个段                              </span><br><span class="line"></span><br><span class="line">         ;初始化栈段和栈指针 </span><br><span class="line">         mov ax,0      </span><br><span class="line">         mov ss,ax</span><br><span class="line">         mov sp,ax</span><br><span class="line">      </span><br><span class="line">         mov ax,[cs:phy_base]            ;获得用于加载用户程序的逻辑段地址，因为phy_base是双字单元，必须放在ax和bx两个寄存器中</span><br><span class="line">         mov dx,[cs:phy_base+0x02]</span><br><span class="line">         mov bx,16        </span><br><span class="line">         div bx                          ;执行后，ax就存储了「用于加载用户程序的段地址」,为0x1000</span><br><span class="line">         mov ds,ax                       ;令DS和ES指向该段以进行操作</span><br><span class="line">         mov es,ax                        </span><br><span class="line">    </span><br><span class="line">         ;以下读取程序的起始部分 </span><br><span class="line">         xor di,di</span><br><span class="line">         mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 </span><br><span class="line">         xor bx,bx                       ;加载到DS:0x0000处 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">      </span><br><span class="line">         ;以下判断整个程序有多大</span><br><span class="line">         mov dx,[2]</span><br><span class="line">         mov ax,[0]</span><br><span class="line">         mov bx,512                      ;每扇区512字节</span><br><span class="line">         div bx</span><br><span class="line">         cmp dx,0                        ;如果用户程序的大小正好是512的整数倍，做完除法后，AX中是用户程序实际占用的扇区数</span><br><span class="line">         jnz @1                          ;未除尽，意味着最后一个扇区因为没有填满，需要转移到后面的代码，去读剩余的扇区；</span><br><span class="line">         dec ax                          ;如果已经除尽了,因为已经读了一个扇区，扇区总数减1 </span><br><span class="line">   @1:</span><br><span class="line">         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 </span><br><span class="line">         jz direct</span><br><span class="line">         </span><br><span class="line">         ;读取剩余的扇区</span><br><span class="line">         push ds                         ;以下要用到并改变DS寄存器 </span><br><span class="line"></span><br><span class="line">         mov cx,ax                       ;循环次数（剩余扇区数）</span><br><span class="line">   @2:</span><br><span class="line">         mov ax,ds</span><br><span class="line">         add ax,0x20                     ;得到下一个以512字节为边界的段地址</span><br><span class="line">         mov ds,ax  </span><br><span class="line">                              </span><br><span class="line">         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 </span><br><span class="line">         inc si                          ;下一个逻辑扇区 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">         loop @2                         ;循环读，直到读完整个功能程序 </span><br><span class="line"></span><br><span class="line">         pop ds                          ;恢复数据段基址到用户程序头部段 </span><br><span class="line">      </span><br><span class="line">         ;计算入口点代码段基址，重定位用户程序入口点</span><br><span class="line">   direct:</span><br><span class="line">         mov dx,[0x08]                   ;偏移为0x06处的双字，存放了入口点代码段的汇编地址</span><br><span class="line">         mov ax,[0x06]</span><br><span class="line">         call calc_segment_base          ;计算代码段在内存中的段地址</span><br><span class="line">         mov [0x06],ax                   ;回填修正后的入口点代码段基址 </span><br><span class="line">      </span><br><span class="line">         ;开始处理段重定位表</span><br><span class="line">         mov cx,[0x0a]                   ;需要重定位的项目数量</span><br><span class="line">         mov bx,0x0c                     ;重定位表首地址</span><br><span class="line">          </span><br><span class="line"> realloc:</span><br><span class="line">         mov dx,[bx+0x02]                ;32位地址的高16位 </span><br><span class="line">         mov ax,[bx]</span><br><span class="line">         call calc_segment_base</span><br><span class="line">         mov [bx],ax                     ;回填段的基址</span><br><span class="line">         add bx,4                        ;下一个重定位项（每项占4个字节） </span><br><span class="line">         loop realloc </span><br><span class="line">      </span><br><span class="line">         jmp far [0x04]                  ;转移到用户程序,将控制权交给用户程序  </span><br><span class="line"> </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区</span><br><span class="line">                                         ;输入：DI:SI=起始逻辑扇区号</span><br><span class="line">                                         ;     DS:BX=目标缓冲区地址</span><br><span class="line">         push ax</span><br><span class="line">         push bx</span><br><span class="line">         push cx</span><br><span class="line">         push dx</span><br><span class="line">      </span><br><span class="line">         mov dx,0x1f2</span><br><span class="line">         mov al,1</span><br><span class="line">         out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f3</span><br><span class="line">         mov ax,si</span><br><span class="line">         out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f4</span><br><span class="line">         mov al,ah</span><br><span class="line">         out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f5</span><br><span class="line">         mov ax,di</span><br><span class="line">         out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f6</span><br><span class="line">         mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">         or al,ah                        ;LBA地址27~24</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f7</span><br><span class="line">         mov al,0x20                     ;读命令</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">  .waits:</span><br><span class="line">         in al,dx</span><br><span class="line">         and al,0x88</span><br><span class="line">         cmp al,0x08</span><br><span class="line">         jnz .waits                      ;不忙，且硬盘已准备好数据传输 </span><br><span class="line"></span><br><span class="line">         mov cx,256                      ;总共要读取的字数</span><br><span class="line">         mov dx,0x1f0</span><br><span class="line">  .readw:</span><br><span class="line">         in ax,dx</span><br><span class="line">         mov [bx],ax</span><br><span class="line">         add bx,2</span><br><span class="line">         loop .readw</span><br><span class="line"></span><br><span class="line">         pop dx</span><br><span class="line">         pop cx</span><br><span class="line">         pop bx</span><br><span class="line">         pop ax</span><br><span class="line">      </span><br><span class="line">         ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">calc_segment_base:                       ;计算16位段地址</span><br><span class="line">                                         ;输入：DX:AX=32位物理地址</span><br><span class="line">                                         ;返回：AX=16位段基地址 </span><br><span class="line">         push dx                          </span><br><span class="line">         </span><br><span class="line">         add ax,[cs:phy_base]            ;将用户程序在内存中物理起始地址的低16位加到AX中</span><br><span class="line">         adc dx,[cs:phy_base+0x02]</span><br><span class="line">         shr ax,4                        ;右移4位</span><br><span class="line">         ror dx,4</span><br><span class="line">         and dx,0xf000</span><br><span class="line">         or ax,dx</span><br><span class="line">         </span><br><span class="line">         pop dx</span><br><span class="line">         </span><br><span class="line">         ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">         phy_base: dd 0x10000             ;用户程序被加载的物理起始地址</span><br><span class="line">         </span><br><span class="line"> times 510-($-$$) db 0</span><br><span class="line"> db 0x55,0xaa</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>声明常数</code>：和其他伪指令 db、dw、dd 不同，<strong>用 equ 声明的数值不占用任何汇编地址，也不在运行时占用任何内存位置。它仅仅代表一个数值，就这么简单</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app_lba_start equ 100 ;声明常数，用标号app_lba_start 来代表数值100</span><br><span class="line"></span><br><span class="line">mov al, 100</span><br><span class="line">; 等价于</span><br><span class="line">mov al, app_lba_start</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="初始化和决定加载位置"><a href="#初始化和决定加载位置" class="headerlink" title="初始化和决定加载位置"></a>初始化和决定加载位置</h3><p>从大的方面来说，加载器要加载一个用户程序，并使之开始执行， 需要决定两件事：</p>
<ol>
<li>看看内存中的什么地方是空闲的，即从哪个物理内存地址开始加载用户程序；</li>
<li>用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少。</li>
</ol>
<h3 id="准备加载用户程序"><a href="#准备加载用户程序" class="headerlink" title="准备加载用户程序"></a>准备加载用户程序</h3><ul>
<li><p>将主引导扇区程序定义成一个段。段内所有元素的汇编地址都将从 0x7c00 开始计算。否则，因为主引导程序的实际加载地址是 0x0000:0x7c00，当我们引用一个标号时，还得手工加上那个落差 0x7c00。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECTION mbr align=16 vstart=0x7c00</span><br></pre></td></tr></table></figure></li>
<li><p>加载用户程序需要确定一个内存物理地址，初始化为0x10000 :<code>phy_base: dd 0x10000</code>。你完全可以把用户程序加载到其他地方，只要它是 16 字节对齐并且空闲的，这样<strong>将来才能形成一个有效的段地址</strong>。</p>
</li>
<li><p>然后将 phy_base 的高 16 位处在 phy_base＋0x02 处，放在寄存器 DX 中；低 16 位处在 phy_base 处，放在寄存器 AX 中。</p>
<p><img src="/images/image-20220209141859644-4387540.png" alt="image-20220209141859644"></p>
</li>
<li><p><code>div bx</code>：将物理地址 phy_base 变成 16 位的段地址，并传送到 DS 和 ES 寄存器。</p>
</li>
</ul>
<h3 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h3><p><code>过程调用</code>：又叫例程，或者子程序、子过程、子例程。处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。</p>
<p><img src="/images/image-20220209171338013.png" alt="image-20220209171338013"></p>
<h3 id="加载用户程序"><a href="#加载用户程序" class="headerlink" title="加载用户程序"></a>加载用户程序</h3><p>读取用户程序的第一扇区，包括有用户程序头部，以及一部分实际的指令和数据。为了将用户程序全部读入内存，需要知道它的大小，然后再进一步转换成它所用的扇区数。</p>
<h3 id="用户程序重定位"><a href="#用户程序重定位" class="headerlink" title="用户程序重定位"></a>用户程序重定位</h3><ul>
<li>用户程序在编写的时候是分段的。因此，加载器下一步的工作是<strong>计算和确定每个段的段地址</strong>。</li>
<li>用于加载用户程序的物理地址 phy_base 是16 字节对齐的，而用户程序中，每个段的汇编地址也是 16 字节对齐的。因此，每个段在内存中的起始地址也是 16 字节对齐的，将它们分别右移 4 位，就是它们各自的逻辑段地址。</li>
</ul>
<p><img src="/images/image-20220209182209766.png" alt="image-20220209182209766"></p>
<h3 id="将控制权交给用户程序"><a href="#将控制权交给用户程序" class="headerlink" title="将控制权交给用户程序"></a>将控制权交给用户程序</h3><ul>
<li>现在，用户程序已经在内存中准备就绪，剩下的工作就是把处理器 的控制权交给它。</li>
<li>交接工作很简单，加载器<strong>通过一个16 位的间接绝对远转移指令，跳转到用户程序入口点</strong>。</li>
</ul>
<h2 id="用户程序的工作流程"><a href="#用户程序的工作流程" class="headerlink" title="用户程序的工作流程"></a>用户程序的工作流程</h2><p>用户程序的工作流程：</p>
<ol>
<li>初始化段寄存器和栈切换</li>
<li>调用字符串显示例程</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">         ;代码清单8-2</span><br><span class="line">         ;文件名：c08.asm</span><br><span class="line">         ;文件说明：用户程序 </span><br><span class="line">         ;创建日期：2011-5-5 18:17</span><br><span class="line">         </span><br><span class="line">;====================================</span><br><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code_1.start ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    realloc_tbl_len dw (header_end-code_1_segment)/4</span><br><span class="line">                                            ;段重定位表项个数[0x0a]</span><br><span class="line">    </span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_1_segment  dd section.code_1.start ;[0x0c]</span><br><span class="line">    code_2_segment  dd section.code_2.start ;[0x10]</span><br><span class="line">    data_1_segment  dd section.data_1.start ;[0x14]</span><br><span class="line">    data_2_segment  dd section.data_2.start ;[0x18]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    </span><br><span class="line">    header_end:                </span><br><span class="line">    </span><br><span class="line">;====================================</span><br><span class="line">SECTION code_1 align=16 vstart=0         ;定义代码段1（16字节对齐） </span><br><span class="line">put_string:                              ;显示串(0结尾)。</span><br><span class="line">                                         ;输入：DS:BX=串地址</span><br><span class="line">         mov cl,[bx]</span><br><span class="line">         or cl,cl                        ;cl=0？ 判断是否为字符串的结尾\0</span><br><span class="line">         jz .exit                        ;是的，返回主程序 </span><br><span class="line">         call put_char</span><br><span class="line">         inc bx                          ;下一个字符 </span><br><span class="line">         jmp put_string</span><br><span class="line"></span><br><span class="line">   .exit:</span><br><span class="line">         ret</span><br><span class="line"></span><br><span class="line">;------------------------------------</span><br><span class="line">put_char:                                ;显示一个字符</span><br><span class="line">                                         ;输入：cl=字符ascii</span><br><span class="line">         push ax</span><br><span class="line">         push bx</span><br><span class="line">         push cx</span><br><span class="line">         push dx</span><br><span class="line">         push ds</span><br><span class="line">         push es</span><br><span class="line"></span><br><span class="line">         ;以下取当前光标位置</span><br><span class="line">         mov dx,0x3d4</span><br><span class="line">         mov al,0x0e</span><br><span class="line">         out dx,al                       ;通过索引端口告诉显卡，现在要操作0x0e 号寄存器</span><br><span class="line">         mov dx,0x3d5</span><br><span class="line">         in al,dx   ;通过数据端口从0x0e号端口读出1字节的数据，并传送到AH中，这是屏幕光标位置的高8位。</span><br><span class="line">         mov ah,al</span><br><span class="line"></span><br><span class="line">         mov dx,0x3d4</span><br><span class="line">         mov al,0x0f</span><br><span class="line">         out dx,al</span><br><span class="line">         mov dx,0x3d5</span><br><span class="line">         in al,dx                        ;从0x0f号寄存器读出光标位置的低8位 </span><br><span class="line">         mov bx,ax                       ;BX=代表光标位置的16位数</span><br><span class="line"></span><br><span class="line">         cmp cl,0x0d                     ;是否为回车符？</span><br><span class="line">         jnz .put_0a                     ;不是。看看是不是换行等字符 </span><br><span class="line">         mov ax,bx                       ;此句略显多余，但去掉后还得改书，麻烦 </span><br><span class="line">         mov bl,80                       </span><br><span class="line">         div bl                          ;用当前光标位置除以80，余数不要，就可以得到当前行的行号</span><br><span class="line">         mul bl                          ;再乘以80，就是当前行行首的光标数值</span><br><span class="line">         mov bx,ax</span><br><span class="line">         jmp .set_cursor                 ;设置光标在屏幕上的位置。</span><br><span class="line"></span><br><span class="line"> .put_0a:</span><br><span class="line">         cmp cl,0x0a                     ;换行符？</span><br><span class="line">         jnz .put_other                  ;不是，那就正常显示字符 </span><br><span class="line">         add bx,80                       ;向下一行，只需将BX的内容增加80，即可得到新的光标位置数据</span><br><span class="line">         jmp .roll_screen</span><br><span class="line"></span><br><span class="line"> .put_other:                             ;正常显示字符</span><br><span class="line">         mov ax,0xb800</span><br><span class="line">         mov es,ax                       ;ES指向显存</span><br><span class="line">         shl bx,1  ;一个字符在显存中对应两个字节,将光标位置乘以2，得到该字符在显存中的偏移地址</span><br><span class="line">         mov [es:bx],cl                  ;写入要显示的字符</span><br><span class="line"></span><br><span class="line">         ;以下将光标位置推进一个字符</span><br><span class="line">         shr bx,1                        ;将BX的内容除以2，恢复它的光标位置身份</span><br><span class="line">         add bx,1                        ;将光标推进到下一个位置</span><br><span class="line"></span><br><span class="line"> .roll_screen:</span><br><span class="line">         cmp bx,2000                     ;光标超出屏幕？滚屏</span><br><span class="line">         jl .set_cursor</span><br><span class="line"></span><br><span class="line">         mov ax,0xb800</span><br><span class="line">         mov ds,ax</span><br><span class="line">         mov es,ax</span><br><span class="line">         cld</span><br><span class="line">         mov si,0xa0                     ;0xa0:屏幕第2行第1列的位置</span><br><span class="line">         mov di,0x00                     ;0x00:屏幕第1行第1列的位置</span><br><span class="line">         mov cx,1920    ;1920=24行乘以80个字符/行，乘以每个字符占用的字节数2，再除以2字节/字</span><br><span class="line">         rep movsw</span><br><span class="line">         mov bx,3840                     ;清除屏幕最底一行。3840:第25行第1列在显存中的偏移地址</span><br><span class="line">         mov cx,80</span><br><span class="line"> .cls:</span><br><span class="line">         mov word[es:bx],0x0720</span><br><span class="line">         add bx,2</span><br><span class="line">         loop .cls</span><br><span class="line"></span><br><span class="line">         mov bx,1920   ;滚屏之后，光标应当位于最后一行的第1列，其数值为1920</span><br><span class="line"></span><br><span class="line"> .set_cursor:</span><br><span class="line">         mov dx,0x3d4 ;通过索引端口指定光标寄存器0x0e和0x0f，并分别将BX中的高8位和低8位通过数据段口0x3d5 写入它们</span><br><span class="line">         mov al,0x0e</span><br><span class="line">         out dx,al</span><br><span class="line">         mov dx,0x3d5</span><br><span class="line">         mov al,bh</span><br><span class="line">         out dx,al</span><br><span class="line">         mov dx,0x3d4</span><br><span class="line">         mov al,0x0f</span><br><span class="line">         out dx,al</span><br><span class="line">         mov dx,0x3d5</span><br><span class="line">         mov al,bl</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">         pop es</span><br><span class="line">         pop ds</span><br><span class="line">         pop dx</span><br><span class="line">         pop cx</span><br><span class="line">         pop bx</span><br><span class="line">         pop ax</span><br><span class="line"></span><br><span class="line">         ret</span><br><span class="line"></span><br><span class="line">;-----------------------------------</span><br><span class="line">  start:</span><br><span class="line">         ;初始执行时，DS和ES指向用户程序头部段</span><br><span class="line">         mov ax,[stack_segment]           ;设置到用户程序自己的堆栈 </span><br><span class="line">         mov ss,ax</span><br><span class="line">         mov sp,stack_end                 ;因为stack_end为256，所以这条指令和mov sp, 256等价</span><br><span class="line">         </span><br><span class="line">         mov ax,[data_1_segment]          ;设置到用户程序自己的数据段</span><br><span class="line">         mov ds,ax</span><br><span class="line"></span><br><span class="line">         mov bx,msg0</span><br><span class="line">         call put_string                  ;显示第一段信息 </span><br><span class="line"></span><br><span class="line">         push word [es:code_2_segment]</span><br><span class="line">         mov ax,begin</span><br><span class="line">         push ax                          ;可以直接push begin,80386+</span><br><span class="line">         </span><br><span class="line">         retf                             ;转移到代码段2执行 </span><br><span class="line">         </span><br><span class="line">  continue:</span><br><span class="line">         mov ax,[es:data_2_segment]       ;段寄存器DS切换到数据段2 </span><br><span class="line">         mov ds,ax</span><br><span class="line">         </span><br><span class="line">         mov bx,msg1</span><br><span class="line">         call put_string                  ;显示第二段信息 </span><br><span class="line"></span><br><span class="line">         jmp $ </span><br><span class="line"></span><br><span class="line">;===================================</span><br><span class="line">SECTION code_2 align=16 vstart=0          ;定义代码段2（16字节对齐）</span><br><span class="line"></span><br><span class="line">  begin:</span><br><span class="line">         push word [es:code_1_segment]</span><br><span class="line">         mov ax,continue</span><br><span class="line">         push ax                          ;可以直接push continue,80386+</span><br><span class="line">         </span><br><span class="line">         retf                             ;转移到代码段1接着执行 </span><br><span class="line">         </span><br><span class="line">;====================================</span><br><span class="line">SECTION data_1 align=16 vstart=0</span><br><span class="line"></span><br><span class="line">    msg0 db &#x27;  This is NASM - the famous Netwide Assembler. &#x27;</span><br><span class="line">         db &#x27;Back at SourceForge and in intensive development! &#x27;</span><br><span class="line">         db &#x27;Get the current versions from http://www.nasm.us/.&#x27;</span><br><span class="line">         db 0x0d,0x0a,0x0d,0x0a</span><br><span class="line">         db &#x27;  Example code for calculate 1+2+...+1000:&#x27;,0x0d,0x0a,0x0d,0x0a</span><br><span class="line">         db &#x27;     xor dx,dx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     xor ax,ax&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     xor cx,cx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;  @@:&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     inc cx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     add ax,cx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     adc dx,0&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     inc cx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     cmp cx,1000&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     jle @@&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     ... ...(Some other codes)&#x27;,0x0d,0x0a,0x0d,0x0a</span><br><span class="line">         db 0  ; 使用\0代表字符串的总结，就和C一样</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION data_2 align=16 vstart=0</span><br><span class="line"></span><br><span class="line">    msg1 db &#x27;  The above contents is written by LeeChung. &#x27;</span><br><span class="line">         db &#x27;2011-05-06&#x27;</span><br><span class="line">         db 0</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION stack align=16 vstart=0</span><br><span class="line">           </span><br><span class="line">         resb 256     ; 跳过256字节</span><br><span class="line"></span><br><span class="line">stack_end:  </span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION trail align=16</span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>resb 256</code>指令：保留 256 字节的栈空间。这条指令仅仅是跳过指定数量的字节，而不管里面的原始内容是什么。</p>
</blockquote>
<h3 id="初始化段寄存器和栈切换"><a href="#初始化段寄存器和栈切换" class="headerlink" title="初始化段寄存器和栈切换"></a>初始化段寄存器和栈切换</h3><ul>
<li>现在轮到用户程序在处理器上执行了。因为加载器已经完成了重定位工作，所以<strong>用户程序的头等大事是初始化处理器的各个段寄存器DS、ES、SS，以便访问专属于自己的数据</strong>。</li>
<li>在进入用户程序时，段寄存器 DS 和 ES 依然指向段 header，而栈段寄存器 SS 依然指向加载器的栈空间。所以需要从头部取得用户程序自己的栈段的段地址，并传送到段寄存器 SS 中。寄存器 DS 同理。</li>
</ul>
<h3 id="调用字符串显示例程"><a href="#调用字符串显示例程" class="headerlink" title="调用字符串显示例程"></a>调用字符串显示例程</h3><ul>
<li><p>光标在屏幕上的位置保存在显卡内部的两个光标寄存器中，每个寄存器是 8 位的，合起来形成一个 16 位的数值。比如，0 表示光标在屏幕上第 0 行第 0 列，80 表示它在第 1 行第 0 列，因为标准 VGA 文本模式是 25 行，每行 80 个字符。这样算来，当光标在屏幕右下角时，该值为 25 × 80 - 1 = 1999。<strong>光标寄存器是可读可写的</strong>。你可以从中读出光标的位置，也可以通过它设置光标的位置。能够通过写入一个数值来设定光标的位置。</p>
</li>
<li><p>显卡的操作非常复杂，内部的寄存器也不是一般地多。为了不过多占用主机的 I/O 空间，很多寄存器只能通过<code>索引寄存器</code>间接访问。索引寄存器的端口号是 <code>0x3d4</code>，可以向它写入一个值，用来指定内部的某个寄存器。</p>
<blockquote>
<p>比如，两个 8 位的光标寄存器，其索引值分别是 14（0x0e）和 15（0x0f），分别用于提供光标位置的高 8 位和低 8 位。</p>
</blockquote>
<p>指定了寄存器之后，要对它进行读写，这可以通过数据端口 0x3d5 来进行。</p>
</li>
<li><p>滚动屏幕内容，实质上就是将屏幕上第 2～25 行的内容整体往上提 一行，最后用黑底白字的空白字符填充第 25 行，使这一行什么也不显示。</p>
</li>
<li><p>流程：</p>
<p><img src="/images/image-20220210123105453.png" alt="image-20220210123105453"></p>
</li>
</ul>
<h1 id="第-9-章-中断和动态时钟显示"><a href="#第-9-章-中断和动态时钟显示" class="headerlink" title="第 9 章 中断和动态时钟显示"></a>第 9 章 中断和动态时钟显示</h1><p>中断就是打断处理器当前的执行流程，去执行另外一些和当前工作不相干的指令，执行完之后，还可以返回到原来的程序流程继续执行。</p>
<h2 id="外部硬件中断"><a href="#外部硬件中断" class="headerlink" title="外部硬件中断"></a>外部硬件中断</h2><ul>
<li><p>外部硬件中断是通过两个信号线引入处理器内部的。从很早的时候起，也就是 8086 处理器的时代，这两根线的名字就叫 <code>NMI</code> 和<code>INTR</code>。</p>
<ul>
<li>通过两个引脚来明确区分不同性质的中断，严重事件都必须无条件地加以处理，这种类型的中断是不会被阻断和屏蔽的，称为<code>非屏蔽中断</code>（Non Maskable Interrupt，NMI）。</li>
<li><code>可屏蔽中断</code>：是通过 INTR 引脚进入处理器内部的。</li>
</ul>
</li>
<li><p>Intel 处理器上的不可屏蔽中断示意图：</p>
<p><img src="/images/image-20220210141746732.png" alt="image-20220210141746732"></p>
<blockquote>
<ul>
<li>NMI 中断信号由 0 跳变到 1 后，至少要维持 4 个以上的时钟周期才算是有效的</li>
<li>在实模式下，NMI 被赋予了统一的中断号 2，不再进行细分。一旦发生 2 号中断，处理器和软件系统通常会放弃继续正常工作的念头，也不会试图纠正已经发生的问题和错误，很可能只是由软件系统给出一个提示信息。</li>
</ul>
</blockquote>
</li>
<li><p><code>中断控制器</code>：多个设备同时发出中断请求时，需要代理对它们进行仲裁，以决定让它们中的哪一个优先向处理器提出服务请求。这种中断代理称为中断控制器。</p>
<blockquote>
<p>在个人计算机中，用得最多的中断控制器就是 8259 芯片。</p>
</blockquote>
</li>
<li><p>单处理器系统的中断机制：</p>
<p><img src="/images/image-20220210143214999.png" alt="image-20220210143214999"></p>
<ul>
<li>第一块 8259 芯片的代理输出 INT 直接送到处理器的 INTR 引脚，这是主片（Master）；第二块 8259 芯片的INT 输出送到第一块的引脚2上，是从片（Slave），两块芯片之间形成级联（Cascade）关系。</li>
<li>在 8259 芯片内部，有中断屏蔽寄存器（Interrupt Mask Register， IMR），这是个 8 位寄存器，对应着该芯片的 8 个中断输入引脚，对应的位是 0 还是 1，决定了从该引脚来的中断信号是否能够通过 8259 送往处理器（0 表示允许，1 表示阻断）。</li>
<li>如此一来，两块 8259 芯片可以向处理器提供 15 个中断信号。</li>
</ul>
</li>
<li><p>中断能否被处理，除了要看 8259 芯片的脸色外，最终的决定权在处理器手中。处理器内部的标志寄存器的标志位 IF，就是中断标志（Interrupt Flag）。当 IF 为 0 时，所有从处理器 INTR 引脚来的中断信号都被忽略掉；当其为 1 时，处理器可以接受和响应中断。</p>
</li>
<li><p>IF 标志位可以通过两条指令 <code>cli</code> （CLear Interrupt flag）和 <code>sti</code>（SeT Interrupt flag） 来改变。</p>
</li>
<li><p>中断是有优先级的，中断的优先级和引脚是相关的，主片的 IR0 引脚优先级最高，IR7 引脚最低，从片也是如此。当然，还要考虑到从片是级联在主片的 IR2 引脚上。</p>
</li>
<li><p>当一个中断事件正在处理时，如果来了一个优先级更高的中断事件时，允许暂时中止当前的中断处理，先为优先级较高的中断事件服务，这称为<code>中断嵌套</code>。</p>
</li>
</ul>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><ul>
<li><p>每个中断在中断向量表中占 2 个字，分别是中断处理程序的偏移地址和段地址。中断 0 的入口点位于物理地址0x00000 处， 也就是逻辑地址 0x0000:0x0000；中断 1 的入口点位于物理地址 0x00004 处，即逻辑地址 0x0000:0x0004；其他中断以此类推。</p>
<p><img src="/images/image-20220210153133757.png" alt="image-20220210153133757"></p>
</li>
<li><p>处理器的中断流程：</p>
<ol>
<li><p><code>保护断点的现场</code>：首先要将标志寄存器 FLAGS 压栈，然后清除它的 IF 位和 TF 位。再将当前的代码段寄存器 CS 和指令指针寄存器 IP 压栈。</p>
</li>
<li><p><code>执行中断处理程序</code>：由于处理器已经拿到了中断号，它将该号码乘以 4（毕竟每个中断在中断向量表中占4 字节），就得到了该中断入口点在中断向量表中的偏移地址。接着，从表中依次取出中断程序的偏移地址和段地址，并分别传送到 IP 和 CS，自然地，处理器就开始执行中断处理程序了。</p>
<blockquote>
<p>由于 IF 标志被清除，在中断处理过程中，处理器将不再响应硬件中断。如果希望更高优先级的中断嵌套，可以在编写中断处理程序时，适时用 sti 指令开放中断。</p>
</blockquote>
</li>
<li><p><code>返回到断点接着执行</code>：所有中断处理程序的最后一条指令必须是中断返回指令iret。这将导致处理器依次从栈中弹出（恢复）IP、CS 和 FLAGS 的原始内容，于是转到主程序接着执行。</p>
<blockquote>
<p>由于中断处理过程返回时，已经恢复了 FLAGS 的原始内容，所以 IF 标志位也自动恢复。也就是说，可以接受新的中断。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>和可屏蔽中断不同，NMI 发生时，处理器不会从外部获得中断号， 它自动生成中断号码2，其他处理过程和可屏蔽中断相同。</p>
</li>
</ul>
<h2 id="实时时钟、CMOS-RAM-和BCD-编码"><a href="#实时时钟、CMOS-RAM-和BCD-编码" class="headerlink" title="实时时钟、CMOS RAM 和BCD 编码"></a>实时时钟、CMOS RAM 和BCD 编码</h2><ul>
<li><p>日期和时间信息是保存在 CMOS RAM 中的，通常有 128 字节，而日期和时间信息只占了一小部分容量，其他空间则用于保存整机的配置信息，比如各种硬件的类型和工作参数、开机密码和辅助存储设备的启动顺序等。</p>
<blockquote>
<p>这些参数的修改通常在 BIOS SETUP 开机程序中进行。要进入该程序，一般需要在开机时按DEL、ESC、F1、F2 或者F10 键。具体按哪个键，视计算机的厂家和品牌而定。</p>
</blockquote>
</li>
<li><p>CMOS RAM 中保存的日期和时间，通常是以二进制编码的十进制数 （Binary Coded Decimal，BCD），这是默认状态，如果需要，也可以设置成按正常的二进制数来表示。</p>
</li>
<li><p>CMOS RAM 的访问，需要通过两个端口来进行。0x70 或者 0x74 是 索引端口，用来指定 CMOS RAM 内的单元；0x71 或者0x75 是数据端口，用来读写相应单元里的内容。</p>
<blockquote>
<p>查看今天是星期几：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0x06</span><br><span class="line">out 0x70, al</span><br><span class="line">in al, 0x71</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h2><ul>
<li><strong>内部中断发生在处理器内部</strong>，是由执行的指令引起的。比如，当处理器检测到 div 或者 idiv 指令的除数为零时，或者除法的结果溢出时，将产生中断0（0 号中断），这就是除法错中断。</li>
<li>内部中断不受标志寄存器 IF 位的影响，也不需要中断识别总线周期，它们的中断类型是固定的，可以立即转入相应的处理过程。</li>
</ul>
<h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><ul>
<li><p><strong>软中断是由int 指令引起的中断处理</strong>。这类中断也不需要中断识别总线周期，中断号在指令中给出。</p>
</li>
<li><p><code>int3</code> 是断点中断指令，<strong>指令都是连续存放的，因此，所谓的断点，就是某条指令的起始地址</strong>。</p>
<ol>
<li>当需要设置断点时，可以将断点处那条指令的第 1 字节改成<code>0xcc</code>，原字节予以保存。</li>
<li>当处理器执行到 int3 时，即发生 3 号中断，转去执行相应的中断处理程序。中断处理程序的执行也要用到各个寄存器，这会破坏它们的内容，但push 指令不会。我们可以在该程序内先压栈所有相关寄存器和内存单元，然后分别取出予以显示，它们就是中断前的现场内容。</li>
<li>最后，再恢复那条指令的第 1 字节，并修改位于栈中的返回地址，执行 iret 指令。</li>
</ol>
</li>
<li><p>int 引发N号中断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int 0x00  ; 引发0号中断</span><br><span class="line">int 0x15  ; 引发0x15号中断</span><br><span class="line">int 0x16  ; 引发0x16号中断</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<code>int3</code> 和 <code>int 3</code> 不是一回事。前者的机器码为CC，后者则是CD 03，这就是通常所说的int n，其操作码为0xCD，第2 字节的操作数给出了中断号。</p>
</blockquote>
</li>
</ul>
<h2 id="BIOS-中断"><a href="#BIOS-中断" class="headerlink" title="BIOS 中断"></a>BIOS 中断</h2><ul>
<li>最有名的软中断是 BIOS 中断，之所以称为 BIOS 中断，是因为这些中断功能是在计算机加电之后，BIOS 程序执行期间建立起来的。换句话说，<strong>这些中断功能在加载和执行主引导扇区之前，就已经可以使用了</strong>。</li>
<li>BIOS 中断主要是为了方便地使用最基本的硬件访问功能。</li>
<li>每个外部设备接口，包括各种板卡，如网卡、显卡、键盘接口电路、硬件控制器等，都有自己的只读存储器，类似于 BIOS 芯片，这些 ROM 中提供了它自己的功能调用例程，以及本设备的初始化代码。按照规范，前两个单元的内容 是 0x55 和 0xAA，第三个单元是本 ROM 中以 512 字节为单位的代码长度；从第四个单元开始，就是实际的 ROM 代码。</li>
<li>从内存物理地址 A0000 开始，到 FFFFF 结束，有相当一部分空间是留给外围设备的。如果设备存在，那么，它自带的 ROM 会映射到分配给它的地址范围内。</li>
<li>在计算机启动期间，BIOS 程序会以 2KB 为单位搜索内存地址 C0000～E0000 之间的区域。当它发现某个区域的头两个字节是0x55 和 0xAA 时，那意味着该区域有 ROM 代码存在，是有效的。接着，它对该区域做累加和检查，看结果是否和第三个单元相符。如果相符，就从第四个单元进入。这时，处理器执行的是硬件自带的程序指令，这些指令初始化外部设备的相关寄存器和工作状态，最后，填写相关的中断向量表，使它们指向自带的中断处理过程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 使用软中断0x16从键盘读字符，需要在AH中指定0x00号功能。该中断返回后，AL中为字符的ASCII码</span><br><span class="line">mov ah,0x00</span><br><span class="line">int 0x16</span><br><span class="line"></span><br><span class="line">; 使用了int 0x10 的0x0e号功能，把从键盘取得的字符显示在屏幕上</span><br><span class="line">mov ah,0x0e</span><br><span class="line">mov bl,0x07</span><br><span class="line">int 0x10</span><br></pre></td></tr></table></figure>



<h1 id="第-10-章-32位x86处理器编程架构"><a href="#第-10-章-32位x86处理器编程架构" class="headerlink" title="第 10 章 32位x86处理器编程架构"></a>第 10 章 32位x86处理器编程架构</h1><ul>
<li><strong>处理器架构，是指一整套的硬件结构， 以及与之相适应的工作状态</strong>。决定了处理器的应用环境和工作模式。架构内的资源对程序员来说是可见的、可访问的，受程序的控制以改变处理器的运行状态；非架构的资源取决于具体的硬件实现。</li>
<li>Intel 32 位处理器架构简称IA-32（Intel Architecture，32-bit），是以 1978 年的 8086 处理器为基础发展起来的。</li>
</ul>
<h2 id="IA-32-架构的寄存器"><a href="#IA-32-架构的寄存器" class="headerlink" title="IA-32 架构的寄存器"></a>IA-32 架构的寄存器</h2><ul>
<li><p><strong>32 位通用寄存器的高 16 位是不可独立使用的，但低 16 位保持同 16 位处理器的兼容性</strong>。因此，在任何时候它们都可以照往常一样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 0x000000f5</span><br><span class="line">mov ah, 0x02</span><br><span class="line">mov al, 0x03</span><br><span class="line">add ax, si</span><br></pre></td></tr></table></figure></li>
<li><p>32 位 cpu <strong>地址线扩展成了 32 位，这和数据线的宽度是一致的</strong>。因此，在 32 位机里其实并不需要采用 “物理地址 = 段:偏移” 这种地址表达方式。原来在 16 位机里规定的每一个段不大于 64kb 在 32 位机里也不是必要的。也就是说，在 32 位模式下，对内存的访问从理论上来说不再需要分段，因为它有 32 根地址线，可以自由访问任何一个内存位置。</p>
</li>
<li><p>但是，IA-32 架构的处理器是基于分段模型的，因此，32 位处理器依然需要以段为单位访问内存，即使它工作在 32 位模式下。其次，考虑到程序通常都是功能化的模块，所以分段虽然不是必要的，但分段却能大大提高编程者管理程序的效率。</p>
<blockquote>
<p>不过，它也提供了一种变通的方案，即，<strong>只分一个段</strong>，段的基地址是 0x00000000，段的长度是 4GB。在这种情况下，可以视为不分段，即<code>平坦模型</code>（Flat Mode）。如果真的想访问 4G 以上内存，可以开启 PAE 模式。</p>
</blockquote>
</li>
<li><p>如何防止程序非法访问别人的内存？在 32 位模式下，处理器要求在加载程序时，先定义该程序所拥有的段，然后允许使用这些段。定义段时，除了基地址（起始地址）外，还附加了段界限、特权级别、类型等属性。当程序访问一个段时，处理器将用固件实施各种检查工作，以防止对内存的违规访问。</p>
</li>
<li><p>在 32 位模式下，传统的段寄存器，如 CS、SS、 DS、ES，保存的不再是16位段基地址，而是<strong>段的选择子</strong>，即，<strong>用于选择所要访问的段</strong>，因此，严格地说，它的新名字叫做<code>段选择器</code>。除了段选择器之外，每个段寄存器还包括一个不可见部分，称为<code>描述符高速缓存器</code>，里面有真正的段地址和各种访问属性。这部分内容程序不可访问，由处理器自动使用。</p>
<p><img src="/images/image-20220211122523340.png" alt="image-20220211122523340"></p>
</li>
</ul>
<h2 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h2><ul>
<li><p><code>虚拟8086模式</code>（V86 模式）：在这种模式下，IA-32 处理器被模拟成多个 8086 处理器并行工作。V86 模式是保护模式的一种，可以在保护模式下执行多个 8086 程序。现在，这种工作模式已经基本无用了。</p>
</li>
<li><p>内存的分配是不定长的，程序大时，就分配一大块内存；程序小时，就分配一小块。时间长了，就会出现<strong>内存空间碎片化</strong>，就有可能出现一种情况：内存空间是有的，但都是小块，无法分配给某个任务。</p>
</li>
<li><p><code>分页功能</code>：分页功能将物理内存空间划分成逻辑上的页。页的大小是固定的，一般为 4KB，通过使用页，可以简化内存管理。</p>
</li>
<li><p>当页功能开启时，段部件产生的地址就不再是物理地址了，而是<code>线性地址</code>（Linear Address），线性地址还要经页部件转换 后，才是物理地址。</p>
<p><img src="/images/image-20220211132517560.png" alt="image-20220211132517560"></p>
</li>
<li><p>IA-32 处理器上的每个任务都拥有 4GB 的虚拟内存空间，这是一段长 4GB 的平坦空间，就像一段平直的线段，因此叫线性地址空间。相应地，由段部件产生的地址，就对应着线性地址空间上的每一个点，这就是线性地址。</p>
</li>
</ul>
<h2 id="现代处理器的结构和特点"><a href="#现代处理器的结构和特点" class="headerlink" title="现代处理器的结构和特点"></a>现代处理器的结构和特点</h2><ul>
<li><p><code>流水线</code>：把一条指令的执行过程分解成若干个细小的步骤，并分配给相应的单元来完成。各个单元的执行是独立的、并行的。如此一来，各个步骤的执行在时间上就会重叠起来。</p>
</li>
<li><p><code>高速缓存</code>：高速缓存是处理器与内存（DRAM）之间的一个静态存储器（SRAM），容量较小，但速度可以与处理器匹配。</p>
<ul>
<li>寄存器的速度是最快的，原因在于它使用了触发器。触发器的工作速度是纳秒级别的。如果使用触发器作为内存的基本单元，那么这种内存称为<code>静态存储器</code>（SRAM）。</li>
<li>制作内存芯片的材料一般是电容和单个的晶体管，由于电容需要定时刷新，使得它的访问速度变得很慢，通常是几十个纳秒。这种内存称为<code>动态存储器</code>（DRAM）。</li>
<li>硬盘是机电设备，是机械和电子的混合体，它的速度最慢，通常在毫秒级。</li>
</ul>
</li>
<li><p><code>乱序执行</code>：</p>
<ul>
<li>为了实现流水线技术，需要将指令拆分成更小的可独立执行部分， 即拆分成<code>微操作</code>（microoperations），简写为μops。</li>
<li><code>add [memory], eax</code>可以拆分成 3 个微操作<ol>
<li>从内存中读数据</li>
<li>执行相加的动作</li>
<li>将相加的结果写回到内存中</li>
</ol>
</li>
<li>一旦将指令拆分成微操作，处理器就可以在必要的时候乱序执行 （Out-Of-Order Execution）程序。</li>
</ul>
</li>
<li><p><code>寄存器重命名</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [memory1]</span><br><span class="line">shl eax, 3</span><br><span class="line">mov [memory2], eax</span><br><span class="line"></span><br><span class="line">mov eax, [memory3]</span><br><span class="line">add eax, 2</span><br><span class="line">mov [memory4], eax</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面代码做了两件事：将 memory1 里的内容左移 3 次（乘以 8），并将 memory3 里的内容加 2。</p>
</li>
<li><p>如果我们为最后三条指令使用不同的寄存器，那么将更明显地看出这两件事的无关性。</p>
</li>
<li><p>处理器实际上也是这样做的。处理器为最后三条指令使用了另一个不同的临时寄存器，因此，左移（乘法）和加法可以并行地处理。</p>
</li>
<li><p>寄存器重命名的工作方式：每当指令写逻辑寄存器时，处理器就为那个逻辑寄存器分配一个新的临时寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [memory1]</span><br><span class="line">mov ebx, [memory2]</span><br><span class="line">add ebx, eax</span><br><span class="line">shl eax, 3</span><br><span class="line">mov [memory3], eax</span><br><span class="line">mov [memory4], ebx</span><br></pre></td></tr></table></figure>

<p>假定 memory1 的内容在高速缓存里，可以立即取得，但 memory2 的内容不在高速缓存中。在等待<code>mov ebx, [memory2]</code>这句指令执行时，可以先执行<code>shl eax, 3</code>，将结果储存在一个临时寄存器中，此时 EAX 寄存器中仍然是以前的内容。直到 EBX 寄存器中的内容就绪，然后同它一起做加法运算。</p>
<p>在所有的操作都完成之后，那个代表 EAX 寄存器最终结果的临时寄存器的内容被写入真实的 EAX 寄存器。</p>
</li>
</ul>
</li>
<li><p><code>分支目标预测</code>：</p>
<ul>
<li><p>在现代处理器中，流水线操作分为很多步骤，包括<code>取指令</code>、<code>译码</code>、 <code>寄存器分配</code>和<code>重命名</code>、<code>微操作排序</code>、<code>执行</code>和<code>引退</code>。</p>
</li>
<li><p>指令的流水线处理方式允许处理器同时做很多事情。在一条指令执行时，下一条指令正在获取和译码。</p>
</li>
<li><p>流水线的最大问题是代码中经常存在分支，如果遇到一条转移指令，则后面那些已经进入流水线的指令就都无效了。必须清空（Flush）流水线，从要转移到的目标位置处重新取指令放入流水线。</p>
</li>
<li><p>分支预测的核心问题是：<strong>条件转移指令的条件会不会成立</strong>。</p>
</li>
<li><p>预测逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xor si, si</span><br><span class="line">loop:</span><br><span class="line">	add si, 1</span><br><span class="line">	cmp si, 20</span><br><span class="line">	jnz loop</span><br></pre></td></tr></table></figure>

<p>当 jnz 指令第一次执行时，转移一定会发生。那么，处理器就可以预测，下一次它还会转移到标号 loop 处，而不是顺序往下执行。事实上，这个预测通常是很准的。</p>
</li>
<li><p>处理器内部有一个小容量的高速缓存器，叫<code>分支目标缓存器</code>（Branch Target Buffer，BTB）。当处理器执行了一条分支语句后，它会在 BTB 中记录当前指令的地址、分支目标的地址，以及本次分支预测的结果。下一次，在那条转移指令实际执行前，处理器会查找 BTB，看有没有最近的转移记录。如果能找到对应的条目，则<strong>推测执行和上一次相同的分支</strong>，把该分支的指令送入流水线。</p>
</li>
</ul>
</li>
</ul>
<h2 id="32-位处理器的寻址方式"><a href="#32-位处理器的寻址方式" class="headerlink" title="32 位处理器的寻址方式"></a>32 位处理器的寻址方式</h2><p>Intel 处理器的指令系统比较复杂，这种复杂性来源于两个方面：</p>
<ul>
<li>指令的数量较多</li>
<li>寻址方式也很多</li>
</ul>
<p>如下，16 位的内存寻址方式已经足够复杂了。</p>
<p><img src="/images/image-20220211182056721.png" alt="image-20220211182056721"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [bx]</span><br><span class="line">mov ax, [bx+di]</span><br><span class="line">mov al, [bx+si+0x02]</span><br></pre></td></tr></table></figure>



<p>当 32 位处理器出现后，寄存器和偏移地址的宽度都扩展了，要继续扩展原有的寻址方式。</p>
<p><img src="/images/image-20220211172501501-4571502.png" alt="image-20220211172501501"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [mem]            ;mem是一个32位的段内偏移地址</span><br><span class="line">add eax, [0x2008]         ;有效地址是0x00002008</span><br><span class="line">sub eax, [eax+0x08]       ;有效地址是32位的</span><br><span class="line">sub ecx, [eax+ebx*8+0x02] ;有效地址是32位的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 16 位模式下，内存寻址方式的操作数不允许使用栈指针寄存器SP。在 32 位模式下，允许在内存操作数中使用栈指针寄存器 ESP。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [sp]   ; wrong</span><br><span class="line">mov eax, [esp] ; right</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="IA-32-的指令格式"><a href="#IA-32-的指令格式" class="headerlink" title="IA-32 的指令格式"></a>IA-32 的指令格式</h2><p>为了保持兼容，<strong>让 16 位指令和 32 位指令共用相同的指令码，但通过不同的指令前缀，结合处理器当前的运行状态来决定该指令的寻址方式</strong>。</p>
<p><img src="/images/image-20220211174405214.png" alt="image-20220211174405214"></p>
<p><code>前缀</code>，比如重复前缀 （REP/REPE/ REPNE）、段超越前缀（如ES：）、总线封锁前缀 （LOCK）等。前缀是可选的，每个前缀的长度是 1 字节，每条指令可以有 1～4 个前缀，或者不使用前缀。</p>
<h3 id="16-位指令和-32-位指令的寻址方式和操作数类型编码对比"><a href="#16-位指令和-32-位指令的寻址方式和操作数类型编码对比" class="headerlink" title="16 位指令和 32 位指令的寻址方式和操作数类型编码对比"></a>16 位指令和 32 位指令的寻址方式和操作数类型编码对比</h3><p><img src="/images/image-20220211175206516.png" alt="image-20220211175206516"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dx, [bx+si+0x02]</span><br></pre></td></tr></table></figure>

<p>在 16 位指令编码格式中：</p>
<ul>
<li>操作码：传送指令的操作码为 0x8B。操作码之后是 1 字节的寻址方式和操作数类型部分。</li>
<li>寻址方式：<ul>
<li><code>01</code>：表示使用了基地址变址的寻址方式，而且带有 8 位偏移量</li>
<li><code>010</code>：表示目的操作数为寄存器 DX</li>
<li><code>000</code>：表示寻址方式为“BX+SI+8位偏移量”</li>
</ul>
</li>
<li>操作数类型：1 字节的偏移量0x02</li>
</ul>
<p>所以，这条指令的机器代码为：<code>8B 50 02</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov edx, [eax+0x02]</span><br></pre></td></tr></table></figure>

<p>在 32 位指令编码格式中：</p>
<ul>
<li>操作码：传送指令的操作码为 0x8B。操作码之后是 1 字节的寻址方式和操作数类型部分。</li>
<li>寻址方式：<ul>
<li><code>01</code>：表示使用了基址寻址方式，而且带有 8 位偏移量</li>
<li><code>010</code>：表示目的操作数为寄存器 EDX</li>
<li><code>000</code>：表示寻址方式为 EAX+8 位偏移量</li>
</ul>
</li>
<li>操作数类型：1 字节的偏移量0x02</li>
</ul>
<p>所以，这条指令的机器代码为：<code>8B 50 02</code></p>
<h3 id="CPU-在-16-位和-32-位的切换"><a href="#CPU-在-16-位和-32-位的切换" class="headerlink" title="CPU 在 16 位和 32 位的切换"></a>CPU 在 16 位和 32 位的切换</h3><p>发现，上面两条指令对应的机器码是一样的。都是<code>8B 50 02</code>。但是 32 位处理器可以执行 16 位和 32 位的程序。那么，当 CPU 收到指令<code>8B 50 02</code>时，怎么知道该执行的是 16 位的<code>mov dx, [bx+si+0x02]</code>，还是 32 位的<code>mov edx, [eax+0x02]</code>？</p>
<p>方法：</p>
<ul>
<li>当处理器运行在 16 位模式时，如果没有指令前缀 0x66，则认为指令是传统的 16 位寻址方式；若有指令前缀 0x66，则指令是新的 32 位寻址方式。</li>
<li>如果处理器当前运行在 32 位模式下且没有指令前缀 0x66， 则视为默认的 32 位寻址方式，否则就是传统的 16 位寻址方式。</li>
</ul>
<p>提供了伪指令<code>bits</code>，用于指明其后的指令应该被编译成 16 位的，还是 32 位的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bits 16</span><br><span class="line">mov cx, dx    ;89 D1</span><br><span class="line">mov eax, ebx  ;66 89 D8</span><br><span class="line"></span><br><span class="line">bits 32</span><br><span class="line">mov cx, dx    ;66 89 D1</span><br><span class="line">mov eax, ebx  ;89 D8</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这就是说，<strong>相同的机器指令，在 16 位模式下和 32 位模式下的解释和执行效果是不同的</strong>。</p>
</blockquote>
<h2 id="一般指令的扩展"><a href="#一般指令的扩展" class="headerlink" title="一般指令的扩展"></a>一般指令的扩展</h2><p>push 和 pop 支持立即数压栈操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push byte 0x55</span><br></pre></td></tr></table></figure>

<p>处理器不会真的压入一字节，<strong>要么压入字，要么压入双字</strong>。因此，</p>
<ul>
<li>在 16 位模式下，默认的操作数字长是 16，处理器在执行时，将该字节的符号位扩展到高 8 位，然后压入栈，压栈时使用 SP 寄存器，且先将 SP 的内容减去 2。这就是说，实际压入栈中的数值是 0x0055；</li>
<li>在 32 位模式下，压入的内容是该字节操作数符号位扩展到高 24 位的结果，即 0x00000055。压栈时使用 ESP 寄存器，且先将ESP 的内容减去 4。</li>
</ul>
<p>push 的其他指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push word 0xfffb</span><br><span class="line">push doword 0xfb</span><br><span class="line">push ax</span><br><span class="line">push edx</span><br><span class="line">push word [0x2000]</span><br><span class="line">push dword [ecx+esi*2+0x02]</span><br></pre></td></tr></table></figure>



<h1 id="第-11-章-进入保护模式"><a href="#第-11-章-进入保护模式" class="headerlink" title="第 11 章 进入保护模式"></a>第 11 章 进入保护模式</h1><h2 id="全局描述符表"><a href="#全局描述符表" class="headerlink" title="全局描述符表"></a>全局描述符表</h2><p>在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须<strong>先登记每个段的信息</strong>。</p>
<p>一个和段有关的信息需要 8 个字节来描述，所以称为<code>段描述符</code>（Segment Descriptor），段描述符包含：</p>
<ul>
<li>段的大小 (20 位)</li>
<li>段的起始地址 (32 位)</li>
<li>段的属性 (禁止写入，禁止执行， 系统专用等，12 位)</li>
</ul>
<p>每个段都需要一个描述符。为了存放这些描述符，需要在内存中开辟出一段空间。在这段空间里，<strong>所有的描述符都是挨在一起，集中存放的</strong>，这就构成一个<code>描述符表</code>。</p>
<p>80x86 中有两种描述符表：</p>
<ul>
<li>全局描述符表（Global Descriptor Table，GDT）</li>
<li>局部描述符表（Local Descriptor Table，LDT）</li>
</ul>
<p>最主要的描述符表是<code>全局描述符表</code>（Global Descriptor Table， GDT），所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。</p>
<p>在整个系统中，全局描述符表 GDT 只有一张 (一个处理器对应一个 GDT)；GDT 可以被放在内存的任何位置，但 <strong>CPU 必须知道 GDT 的入口</strong>。</p>
<p>CPU 如何知道 GDT 的入口呢？为了跟踪全局描述符表，处理器内部有一个 48 位的寄存器，称为<code>全局描述符表寄存器</code>（GDTR）。</p>
<blockquote>
<p>简单来说，<strong>GDTR 就是为了让 CPU 知道 GDT 在内存中的起始地址和结束地址。</strong></p>
</blockquote>
<p>全局描述符表寄存器分为 2 部分，分别是 32 位的<code>线性地址</code>和 16 位的<code>边界</code>：</p>
<ul>
<li><code>32位的线性基地址</code>：保存的是<strong>全局描述符表在内存中的起始线性地址</strong>（此时我们还没有涉及到分页，所以这里的线性地址等同于物理地址）</li>
<li><code>16位的表界限</code>：保存的是<strong>全局描述符表的边界</strong>，在数值上等于表的大小（总字节数）减去 1；（也就是说它保存了全局描述符表的大小）</li>
</ul>
<p><img src="/images/image-20220211184840508.png" alt="image-20220211184840508"></p>
<p>因为表界限是 16 位的，最大值是 0xFFFF，也就是十进制的 65535，也就是说表的最大为 65535+1=65536 字节（64KB）。又因为一个描述符占用 8 个字节，所以全局描述符表最多可以定义 8192 个描述符（65536/8=8192）。</p>
<p>理论上，全局描述符表可以位于内存中的任何地方。但是由于在进入保护模式之后，处理器立即要按新的内存访问模式工作，所以，<strong>必须在进入保护模式之前定义 GDT</strong>。</p>
<p>但是，在处理器刚上电的时候，处理器还处于实模式，而在实模式下只能访问 1MB 的内存，故 GDT 通常都定义在 1MB 以下的内存范围中。 当然，允许在进入保护模式之后换个位置重新定义 GDT。</p>
<p><img src="/images/image-20220212212944591.png" alt="image-20220212212944591"></p>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><h3 id="为什么要使用段描述符"><a href="#为什么要使用段描述符" class="headerlink" title="为什么要使用段描述符"></a>为什么要使用段描述符</h3><p>答：为了实现内存保护，必须使用和实模式不同的内存访问机制。而为了实现新的内存访问机制，需要用到段描述符。</p>
<p>在实模式下，程序能直接访问内存。在保护模式下，内存的访问机制完全不同，即<strong>必须通过描述符来进行</strong>。所以在访问之前，必须先在 GDT 内定义要访问的内存段。</p>
<p>那么为什么设计这种内存访问机制？通过 GDT 访问内存和直接访问内存有什么不同？</p>
<p>答：如果整个计算机系统中只有一个程序在工作，那当然是没有问题的。问题在于，会有很多程序共同在操作系统上运行。<strong>描述符不是由用户程序自己建立的</strong>，而是在加载程序时，由操作系统根据你的程序结构而建立的，而用户程序通常是无法建立和修改 GDT 的，也就只能老老实实地在自己的地盘上工作。在这种情况下，<strong>操作系统为你的程序建立了几个段，程序就只能在这些段内工作</strong>，超出这个范围，或者未按预定的方法访问这些段，都将被处理器阻止。</p>
<h3 id="段描述符格式"><a href="#段描述符格式" class="headerlink" title="段描述符格式"></a>段描述符格式</h3><p>段描述符格式如下，下面是低 32 位，上面是高 32 位：</p>
<p><img src="/images/image-20220212222908156.png" alt="image-20220212222908156"></p>
<p>可以看到，这 64 位中包含了 32 位的<code>段起始地址</code>，以及 20 位的<code>段边界</code>。</p>
<ul>
<li>把 32 位的段的地址分成了 3 段</li>
<li>把 20 位的段界限分成了 2 段</li>
</ul>
<p>为什么这么做？这是为了兼容 80286 而留下的后遗症。</p>
<blockquote>
<p>在实模式下，段真实的物理地址为段地址左移 4 位。在 32 位保护模式下，段地址是 32 位 的线性地址，<strong>如果未开启分页功能，线性地址就是物理地址</strong>。</p>
</blockquote>
<blockquote>
<p>段基地址可以是 0～4GB 范围内的任意地址，不过，还是建议应当选取那些 16 字节对齐的地址。尽管对于 Intel 处理器允许不对齐的地址，但是对齐能够使程序在访问代码和数据时的性能最大化。</p>
</blockquote>
<h3 id="段的属性位"><a href="#段的属性位" class="headerlink" title="段的属性位"></a>段的属性位</h3><ul>
<li><p>G 位是<strong>粒度位</strong>（Granularity），用于解释段界限的含义。</p>
<p>当 G 位是 0 时，段界限以字节为单位。此时，因为描述符中的界限值是 20 位，所以段的扩展范围是 1B～1MB。</p>
<p>当 G 位是 1 时，段界限以 4KB 为单位。此时，段的扩展范围是从 4KB～4GB。</p>
</li>
<li><p>S 位用于<strong>指定描述符的类型</strong>（Descriptor Type）。</p>
<p>当 S 位是 0 时， 表示是一个系统段。</p>
<p>当 S 位是 1 时， 表示是一个代码段或者数据段（栈段也是特殊的数据段）。</p>
</li>
<li><p>DPL 表示<strong>描述符的特权级</strong>（Descriptor Privilege Level，DPL）。共有 4 种处理器支持的特权级别，分别是0、 1、2、3。其中 0 是最高特权级别，3 是最低特权级别。</p>
<p>描述符的特权级用于<strong>指定要访问该段所必须具有的最低特权级</strong>。如果这里的数值是 2，那么，只有特权级别为 0、1 和 2 的程序才能访问该段，而特权级为 3 的程序访问该段时，处理器会予以阻止。</p>
<p>刚进入保护模式时执行的代码具有最高特权级 0（可以看成是从处理器那里继承来的）， 这些代码通常都是操作系统代码，因此它的特权级别最高。每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级，比如 3 特权级。</p>
<p>不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令（特权指令）只能由 0 特权级的程序来执行，为的就是安全。</p>
</li>
<li><p>P 是<strong>段存在位</strong>（Segment Present）。</p>
<p>P 位用于指示描述符所对应的<strong>段是否存在</strong>。</p>
<p>一般来说，描述符所指示的段都位于内存中。但是当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在， 这时，就应当把描述符的 P 位置为 0，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的程序使用（当前正在执行的），这时同样要把段描述符的 P 位清零。当再次轮到它执行时，再装入内存，然后将 P 位置1。</p>
<p>P 位是由处理器负责检查的。每当通过描述符访问内存中的段时， 如果 P 位是 0，处理器就会产生一个异常中断。通常该中断处理过程是由操作系统提供的，该处理过程的任务是将该段从硬盘换回内存，并将 P 位置 1。在多用户、多任务的系统中，这是一种常用的虚拟内存调度策略。当内存很小，运行的程序很多时，如果计算机的运行速度变慢，并伴随着繁忙的硬盘操作时，说明这种情况正在发生。</p>
</li>
<li><p>D/B 位是<code>默认的操作数大小</code>（Default Operation Size）或者<code>默认的栈指针大小</code>（Default Stack Pointer Size），又或者<code>上部边界标志</code>（Upper Bound）。</p>
<p>标志位主要是<strong>为了能够在 32 位处理器上兼容运行 16 位保护模式的程序</strong>。这种程序现在已经非常罕见了。现在的描述符应当将此位置为 1。</p>
</li>
<li><p>L 位是 <strong>64 位代码段标志</strong>（64-bit Code Segment），保留此位给 64 位处理器使用。目前，我们将此位置 0 即可。</p>
</li>
<li><p>TYPE 字段共 4 位，用于<strong>指示描述符的类别</strong>。</p>
<p>对于数据段来说，这 4 位分别是X、E、W、A 位；而对于代码段来说，这 4 位则分别是X、C、R、A 位。</p>
<p><img src="/images/image-20220212231925753.png" alt="image-20220212231925753"></p>
<p>X 表示是否可以执行（eXecutable）。因为数据段是不可执行的，所以X＝0；代码段总是可以执行的，因此X＝1。</p>
<p>对于数据段来说，E 位指示段的扩展方向。E＝0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段；E＝1 是向下扩展的，也就是向低地址方向扩展的，通常是栈段。W 位指示段的读写属性，说明段是否可写，W＝0 的段是不允许写入的，否则会引发处理器异常中断； W＝1 的段是可以正常写入的。</p>
<p>对于代码段来说，C 位指示段是否为特权级依从的（Conforming）。C＝0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用；C＝1 表示允许从低特权级的程序转移到该段执行。R 位指示代码段是否允许读出。代码段总是可以执行的，但是为了防止程序被破坏，它是不能写入的。至于是否有读出的可能，由 R 位指定。R＝0 表示不能读出，如果企图去读一个 R＝0 的代码段，会引发处理器异常中断；如果R＝1，则代码段是可以读出的，即可以把这个段的内容当成 ROM 一样使用。</p>
<blockquote>
<p>也许有人会问，既然代码段是不可读的，那处理器怎么从里面取指令执行呢？事实上，这里的 R 属性并非用来限制处理器，而是用来限制程序和指令的行为。一个典型的例子是使用段超越前缀“CS:”来访问代码段中的内容。</p>
</blockquote>
<p>数据段和代码段的 A 位是已访问（Accessed）位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置 1。对该位的清零是由软件（操作系统）负责的，通过定期监视该位的状态，就可以统计出该段的使用频率。当内存空间紧张时，可以把不经常使用的段退避到硬盘上，从而实现虚拟内存管理。</p>
</li>
<li><p>AVL 是软件可以使用的位（Available）。通常由操作系统来用，处理器并不使用它。如果你把它理解成“好吧，该安排的都安排了，最后多出这么一位，不知道干什么用好，就给软件用吧”，我也不反对，也许 Intel 公司也不会说些什么。</p>
</li>
</ul>
<h2 id="进入保护模式的主要步骤"><a href="#进入保护模式的主要步骤" class="headerlink" title="进入保护模式的主要步骤"></a>进入保护模式的主要步骤</h2><ol>
<li>安装段描述符，构造 GDT</li>
<li>用 lgdt 指令加载 GDTR</li>
<li>打开 A20</li>
<li>设置 CR0 的 PE 位为 1</li>
<li>跳转，真正进入保护保护模式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">         ;代码清单11-1</span><br><span class="line">         ;文件名：c11_mbr.asm</span><br><span class="line">         ;文件说明：硬盘主引导扇区代码 </span><br><span class="line">         ;创建日期：2011-5-16 19:54</span><br><span class="line"></span><br><span class="line">         ;设置堆栈段和栈指针，使栈段的逻辑段地址和代码段相同</span><br><span class="line">         mov ax,cs      </span><br><span class="line">         mov ss,ax</span><br><span class="line">         mov sp,0x7c00</span><br><span class="line">      </span><br><span class="line">         ;计算GDT所在的逻辑段地址:将线性基地址转换成逻辑地址 </span><br><span class="line">         mov ax,[cs:gdt_base+0x7c00]        ;低16位 </span><br><span class="line">         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 </span><br><span class="line">         mov bx,16        </span><br><span class="line">         div bx            </span><br><span class="line">         mov ds,ax                          ;令DS指向该段以进行操作</span><br><span class="line">         mov bx,dx                          ;段内起始偏移地址 </span><br><span class="line">      </span><br><span class="line">         ;创建#0描述符，它是空描述符，这是处理器的要求</span><br><span class="line">         mov dword [bx+0x00],0x00</span><br><span class="line">         mov dword [bx+0x04],0x00  </span><br><span class="line"></span><br><span class="line">         ;创建#1描述符，保护模式下的代码段描述符</span><br><span class="line">         mov dword [bx+0x08],0x7c0001ff     </span><br><span class="line">         mov dword [bx+0x0c],0x00409800     </span><br><span class="line"></span><br><span class="line">         ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） </span><br><span class="line">         mov dword [bx+0x10],0x8000ffff     </span><br><span class="line">         mov dword [bx+0x14],0x0040920b     </span><br><span class="line"></span><br><span class="line">         ;创建#3描述符，保护模式下的堆栈段描述符</span><br><span class="line">         mov dword [bx+0x18],0x00007a00</span><br><span class="line">         mov dword [bx+0x1c],0x00409600</span><br><span class="line"></span><br><span class="line">         ;初始化描述符表寄存器GDTR</span><br><span class="line">         mov word [cs: gdt_size+0x7c00],31  ;31:描述符表的界限（总字节数减一）   </span><br><span class="line">                                             </span><br><span class="line">         lgdt [cs: gdt_size+0x7c00]         ;从gdt_size处读取6个字节，就包括了gdt_base</span><br><span class="line">      </span><br><span class="line">         in al,0x92                         ;南桥芯片内的端口 </span><br><span class="line">         or al,0000_0010B</span><br><span class="line">         out 0x92,al                        ;打开A20</span><br><span class="line"></span><br><span class="line">         cli                                ;保护模式下中断机制尚未建立，应 </span><br><span class="line">                                            ;禁止中断 </span><br><span class="line">         mov eax,cr0</span><br><span class="line">         or eax,1                           ;将第1位置“1”,设置PE位</span><br><span class="line">         mov cr0,eax                        ;将修改之后的内容重新写回CR0,开启保护模式</span><br><span class="line">      </span><br><span class="line">         ;以下进入保护模式... ...</span><br><span class="line">         jmp dword 0x0008:flush             ;16位的描述符选择子：32位偏移</span><br><span class="line">                                            ;清空流水线并串行化处理器 </span><br><span class="line">         [bits 32] </span><br><span class="line"></span><br><span class="line">    flush:</span><br><span class="line">         mov cx,00000000000_10_0_00B   ;数据段的描述选择子【数据段是第3个，所以索引为2，即0x10】，从选择子的二进制形式可以看出，指定的描述符索引号是2，指定的描述符表是GDT，请求特权级RPL是00</span><br><span class="line">         mov ds,cx</span><br><span class="line"></span><br><span class="line">         ;以下在屏幕上显示&quot;Protect mode OK.&quot; </span><br><span class="line">         mov byte [0x00],&#x27;P&#x27;  </span><br><span class="line">         mov byte [0x02],&#x27;r&#x27;</span><br><span class="line">         mov byte [0x04],&#x27;o&#x27;</span><br><span class="line">         mov byte [0x06],&#x27;t&#x27;</span><br><span class="line">         mov byte [0x08],&#x27;e&#x27;</span><br><span class="line">         mov byte [0x0a],&#x27;c&#x27;</span><br><span class="line">         mov byte [0x0c],&#x27;t&#x27;</span><br><span class="line">         mov byte [0x0e],&#x27; &#x27;</span><br><span class="line">         mov byte [0x10],&#x27;m&#x27;</span><br><span class="line">         mov byte [0x12],&#x27;o&#x27;</span><br><span class="line">         mov byte [0x14],&#x27;d&#x27;</span><br><span class="line">         mov byte [0x16],&#x27;e&#x27;</span><br><span class="line">         mov byte [0x18],&#x27; &#x27;</span><br><span class="line">         mov byte [0x1a],&#x27;O&#x27;</span><br><span class="line">         mov byte [0x1c],&#x27;K&#x27;</span><br><span class="line"></span><br><span class="line">         ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 </span><br><span class="line">         mov cx,00000000000_11_0_00B         ;加载堆栈段选择子</span><br><span class="line">         mov ss,cx</span><br><span class="line">         mov esp,0x7c00</span><br><span class="line"></span><br><span class="line">         mov ebp,esp                        ;保存堆栈指针 </span><br><span class="line">         push byte &#x27;.&#x27;                      ;压入立即数（字节）</span><br><span class="line">         </span><br><span class="line">         sub ebp,4</span><br><span class="line">         cmp ebp,esp                        ;判断压入立即数时，ESP是否减4 </span><br><span class="line">         jnz ghalt                          </span><br><span class="line">         pop eax</span><br><span class="line">         mov [0x1e],al                      ;显示句点 </span><br><span class="line">      </span><br><span class="line">  ghalt:     </span><br><span class="line">         hlt                                ;已经禁止中断，将不会被唤醒 </span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">     </span><br><span class="line">         gdt_size:         dw 0</span><br><span class="line">         gdt_base:         dd 0x00007e00     ;GDT的物理地址 </span><br><span class="line">                             </span><br><span class="line">         times 510-($-$$) db 0</span><br><span class="line">         db 0x55,0xaa</span><br></pre></td></tr></table></figure>



<h3 id="安装存储器的段描述符并加载-GDTR"><a href="#安装存储器的段描述符并加载-GDTR" class="headerlink" title="安装存储器的段描述符并加载 GDTR"></a>安装存储器的段描述符并加载 GDTR</h3><p>在实模式下，主引导程序的加载位置是 0x0000:0x7c00，主引导扇区程序共 512（0x200）字节。所以，我们把 GDT 设在主引导程序之后，也就是物理地址 0x00007e00 处。</p>
<p><img src="/images/image-20220212221706130.png" alt="image-20220212221706130"></p>
<p>现在已经确定了 GDT 在内存中的起始位置，下一步的工作就是确定要访问的段，并在 GDT 中为这些段创建各自的描述符。</p>
<p>处理器规定，GDT 中的第一个描述符必须是空描述符，或者叫哑描述符或 NULL 描述符。（其实就是值为<code>0x00</code>）</p>
<blockquote>
<p>很多时候，寄存器和内存单元的初始值会为 0，再加上程序设计有问题，就会在无意中用全 0 的索引来选择描述符。因此，处理器要求将第一个描述符定义成空描述符。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;创建#1描述符，保护模式下的代码段描述符</span><br><span class="line">mov dword [bx+0x08],0x7c0001ff     </span><br><span class="line">mov dword [bx+0x0c],0x00409800 </span><br></pre></td></tr></table></figure>

<p>可以看出，此描述符：</p>
<ul>
<li>线性基地址为 0x00007c00</li>
<li>段界限为 0x001FF，粒度为字节（G=0）。该段的长度为 512 字节</li>
<li>属于存储器的段（S=1）</li>
<li>这是一个 32 位的段（D=1）</li>
<li>该段目前位于内存中（P=1）</li>
<li>段的特权级为 0（DPL=00）</li>
<li>这是一个只能执行的代码段（TYPE=1000）</li>
</ul>
<p>很明显，该描述符所指向的段，就是现在正在执行的主引导程序所在的区域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） </span><br><span class="line">mov dword [bx+0x10],0x8000ffff     </span><br><span class="line">mov dword [bx+0x14],0x0040920b    </span><br></pre></td></tr></table></figure>

<p>可以看出，此描述符：</p>
<ul>
<li>线性基地址为 0x000B 8000。</li>
<li>段界限为 0x0FFFF，粒度为字节（G=0）。该段的长度为 64KB</li>
<li>属于存储器的段（S=1）</li>
<li>这是一个 32 位的段（D=1）</li>
<li>该段目前位于内存中（P=1）</li>
<li>段的特权级为 0（DPL=00）</li>
<li>这是一个可读可写、向上扩展的数据段（TYPE=0010）</li>
</ul>
<p>很容易看出， 线性地址 0x000b8000 就是显存的起始地址，看起来，我们要用这个段来显示字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;创建#3描述符，保护模式下的堆栈段描述符</span><br><span class="line">mov dword [bx+0x18],0x00007a00</span><br><span class="line">mov dword [bx+0x1c],0x00409600</span><br></pre></td></tr></table></figure>

<p>可以看出，此描述符：</p>
<ul>
<li>线性基地址为 0x000B 0000。</li>
<li>段界限为 0x07A00，粒度为字节（G=0）。</li>
<li>属于存储器的段（S=1）</li>
<li>这是一个 32 位的段（D=1）</li>
<li>该段目前位于内存中（P=1）</li>
<li>段的特权级为 0（DPL=00）</li>
<li>这是一个可读可写、向下扩展的数据段，在这里是栈段（TYPE=0010）</li>
</ul>
<p>可以看出，这是用于安装栈段的描述符。</p>
<h3 id="lgdt-指令"><a href="#lgdt-指令" class="headerlink" title="lgdt 指令"></a>lgdt 指令</h3><p>作用：加载全局描述符的线性基地址和界限到 GDTR 寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt m48 ; lgdt m16&amp;m32</span><br></pre></td></tr></table></figure>

<p>在这 48 位的内存区域中，要求前 16 位是 GDT 的界限值，后 32 位是 GDT 的基地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdt_size         dw 0</span><br><span class="line">gdt_base         dd 0x00007e00     ;GDT的物理地址</span><br></pre></td></tr></table></figure>

<p>还记得吗，这是代码中事先定义了 6 字节的空间。前两个字节就是为了保存 GDT 的界限值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;初始化描述符表寄存器GDTR</span><br><span class="line">mov word [cs: gdt_size+0x7c00],31 ;描述符表的界限（总字节数减一），一个描述符占8字节，一共定义了4个段，4*8-1=31   </span><br><span class="line">lgdt [cs: gdt_size+0x7c00] ;从gdt_size处读取6个字节，就包括了gdt_base</span><br></pre></td></tr></table></figure>

<p>第一句写入界限值，第二句把 6 字节加载到 GDTR 寄存器。</p>
<h2 id="关于第-21-条地址线-A20-的问题"><a href="#关于第-21-条地址线-A20-的问题" class="headerlink" title="关于第 21 条地址线 A20 的问题"></a>关于第 21 条地址线 A20 的问题</h2><p>处理器的第 21 根地址线，编号为A20。</p>
<blockquote>
<ul>
<li>“A”是 Address 的首字符，就是地址，A0 是第一根地址线，A31 是第 32 根地址线，所以 A20 就是第 21 根地址线。</li>
<li>在 8086 处理器上运行程序不存在 A20 问题，因为它只有 20 根地址线。</li>
</ul>
</blockquote>
<p>在 8086 时代，实模式下的程序只能寻址 1MB 内存，那是因为它依赖 16 位的段地址左移 4 位，加上 16 位的偏移地址来访问内存。通过上述分段模式，能够表示的最大内存为：FFFFh:FFFFh=FFFF0h+FFFFh=10FFEFh。因为段寄存器只能保留16 位，当逻辑段地址达到最大值 0xFFFF 时，再加 1，结果为 0x100000，因进位而绕回到 0x0000。简单来说就是<strong>当访问 100000h~10FFEFh 之间的内存时，系统并不认为访问越界而产生异常，而是自动从重新 0 开始计</strong>。这种技术被称为 <code>wrap-around</code>（回绕）。</p>
<p>到了 80286，系统的地址总线发展为 24 根，这样能够访问的内存可以达到 2^24=16M。当时有很多程序其实是依赖回绕特性工作着。为了兼容，Intel 在设计 80286 时提出的目标是：在实模式下，系统所表现的行为应该和 8086 所表现的完全一样。</p>
<p>为了解决上述问题，IBM 使用键盘控制器上剩余的一些输出线来管理第 21 根地址线，被称为 <code>A20Gate</code>；</p>
<ul>
<li>如果 A20Gate 打开，则当程序员给出 100000H~10FFEFH 之间的地址的时候，系统将真正访问这块内存区域；</li>
<li>如果 A20Gate 被禁止，则当程序员给出 100000H~10FFEFH 之间的地址的时候，系统仍然使用 8086 的方式。</li>
</ul>
<p>绝大多数 IBM PC 兼容机<strong>默认的 A20Gate 是被禁止的</strong>。由于在当时没有更好的方法来解决这个问题，所以 IBM 使用了键盘控制器来操作 A20 Gate，但是这种操作太麻烦了，要使用一大堆指令。</p>
<h3 id="Alt-A20-GATE"><a href="#Alt-A20-GATE" class="headerlink" title="Alt_A20_GATE"></a>Alt_A20_GATE</h3><p>Alt_A20_GATE，又称 Fast A20。 通过端口 0x92 的 bit1 来打开 A20。</p>
<p>具体方法是：先从端口读出原数据，接着将 bit1 置 1，然后再写入该端口，这样就打开了 A20。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in al,0x92       ;南桥芯片内的端口 </span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al      ;打开A20</span><br></pre></td></tr></table></figure>



<h2 id="保护模式下的内存访问"><a href="#保护模式下的内存访问" class="headerlink" title="保护模式下的内存访问"></a>保护模式下的内存访问</h2><p>控制实模式和保护模式切换的开关原是在一个叫 CR0 的寄存器。CR0 是处理器内部的<code>控制寄存器</code>（Control Register，CR）。</p>
<p>CR0 是 32 位的寄存器，包含了一系列用于控制处理器操作模式和运行状态的标志位。它的第 1 位（位 0）是保护模式允许位 （Protection Enable，PE），是开启保护模式大门的门把手，如果把该位<strong>置 1，则处理器进入保护模式</strong>，按保护模式的规则开始运行。</p>
<ul>
<li>保护模式下的中断机制和实模式不同，因此，原有的中断向量表不再适用。</li>
<li>在保护模式下，BIOS 中断都不能再用，因为它们是实模式下的代码。在重新设置保护模式下的中断环境之前，必须关中断。</li>
</ul>
<p>在 32 位处理器上，获取内存的过程：每当引用一个段时，处理器自动将段地址左移 4 位， 并传送到<strong>描述符高速缓存器</strong>。此后，只要不改变段寄存器 DS 的内容，就一直使用描述符高速缓存器的内容作为段地址。</p>
<blockquote>
<p>在实模式下，段寄存器描述符高速缓存器的内容仅低 20 位有效，高 12 位全部是零。</p>
</blockquote>
<p>在保护模式下，实模式的 6 个段寄存器 CS、DS、ES、FS、GS 和 SS，叫做<code>段选择器</code>。</p>
<p>在保护模式下，尽管访问内存时也需要指定一个段，但传送到段选择器的内容不是逻辑段地址，而是<code>段选择子</code>。</p>
<h3 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h3><p>段选择子由三部分组成：</p>
<ul>
<li><code>描述符的索引号</code>：用来在描述符表中选择一个段描述符。</li>
<li><code>TI</code>：描述符表指示器（Table Indicator），TI ＝0 时，表示描述符在 GDT 中；TI＝1 时，描述符在 LDT 中。</li>
<li><code>RPL</code>：请求特权级，表示给出当前选择子的那个程序的特权级别，正是该程序要求访问这个内存段。每个程序都有特权级别。</li>
</ul>
<p><img src="/images/image-20220214143748597.png" alt="image-20220214143748597"></p>
<blockquote>
<p>因为全局描述符表最多可以定义 65536/8=8192 个描述符，所以将 3~15 作为描述符的索引，最多可以有 2^13=8192 个。</p>
</blockquote>
<h3 id="保护模式下，描述符高速缓存器的加载过程-和-内存的访问过程"><a href="#保护模式下，描述符高速缓存器的加载过程-和-内存的访问过程" class="headerlink" title="保护模式下，描述符高速缓存器的加载过程 和 内存的访问过程"></a>保护模式下，描述符高速缓存器的加载过程 和 内存的访问过程</h3><p>GDT 的线性基地址在 GDTR 中，又因为每个描述符占 8 字节，因此，描述符在表内的偏移地址是索引号乘以8。</p>
<p>当处理器在执行任何<strong>改变段选择器的指令</strong>时（比如pop、mov、jmp far、call far、iret、retf）：</p>
<ol>
<li>将指令中提供的段选择子中的索引号乘以 8 作为偏移地址，</li>
<li>跟 GDTR 中提供的线性基地址相加，以访问 GDT。</li>
<li>如果没有发现什么问题 （比如超出了 GDT 的界限），就自动将找到的描述符加载到不可见的描述符高速缓存部分。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） </span><br><span class="line">mov dword [bx+0x10],0x8000ffff     </span><br><span class="line">mov dword [bx+0x14],0x0040920b</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 加载数据段的描述选择子</span><br><span class="line">mov cx,00000000000_10_0_00B</span><br><span class="line">mov ds,cx</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220214150002372.png" alt="image-20220214150002372"></p>
<p>此后，每当有访问内存的指令时，就不再访问 GDT 中的描述符，<strong>直接用当前段寄存器描述符高速缓存器提供线性基地址</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov byte [0x00], &#x27;P&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220214150943255.png" alt="image-20220214150943255"></p>
<p>处理器取指令执行时，也是使用一样的方法：</p>
<p><img src="/images/image-20220214152748953.png" alt="image-20220214152748953"></p>
<h2 id="清空流水线并串行化处理器"><a href="#清空流水线并串行化处理器" class="headerlink" title="清空流水线并串行化处理器"></a>清空流水线并串行化处理器</h2><p>从实模式切换成保护模式时，存在两个问题：</p>
<ul>
<li>段寄存器的描述符高速缓存器可以用于实模式下，也一样被用于访问内存，此时仅低 20 位有效，高 12 位是全零。当处理器从实模式进入保护模式后，段寄存器的描述符高速缓存器的内容依然残留着，但不影响使用，程序可以继续执行。但是，这些残留的内容在保护模式下是无效的，迟早会在执行某些指令的时候出问题。因此，解决方式是：尽快刷新 CS、SS、 DS、ES、FS 和GS 的内容，包括它们的段选择器和描述符高速缓存器**。</li>
<li>在进入保护模式之前，很多指令已经进入了流水线。因为处理器工作在实模式下，所以它们都是按照 16 位操作数和地址长度进行译码的，即使是那些用 bits32 编译的指令，为了防止执行结果不正确，因此，解决方式是：<strong>清空流水线</strong>。还有那些通过乱序执行得到的中间结果也是无效的，所以必须清理掉，让处理器串化执行。</li>
</ul>
<p>为了达到上述目的，我们可以采用远转移指令 jmp 或者远过程调用指令 call。</p>
<ul>
<li>遇到这类指令，处理器一般会清空流水线并且串化执行；</li>
<li>另一方面，远转移会重新加载 CS，并刷新描述符高速缓存寄存器的内容。</li>
</ul>
<p>所以，强烈建议在设置了 PE 位后，立刻用 jmp 或者 call 转移到当前指令流的下一条指令上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; 以下进入保护模式... ...</span><br><span class="line">; 用32位远转移指令来转移到当前指令流的下一条指令，清空流水线并串行化处理器 </span><br><span class="line">jmp dword 0x0008:flush  ;0x0008（索引号为1，TI 位是0，RPL 为00）</span><br><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">flush:</span><br><span class="line">	mov cx,00000000000_10_000B  </span><br></pre></td></tr></table></figure>



<h2 id="保护模式下的栈"><a href="#保护模式下的栈" class="headerlink" title="保护模式下的栈"></a>保护模式下的栈</h2><p>栈是向下扩展的，因此，描述符中的段界限，和向上扩展的段含义不同。</p>
<ul>
<li>对于向上扩展的段，段内偏移量是从0 开始递增，偏移量的最大值是界限值和粒度的乘积；</li>
<li>而对于向下扩展的段来说，因为它经常用做栈段，而栈是从高地址向低地址方向推进的，故段内偏移量的最小值是界限值和粒度的乘积加一。</li>
</ul>
<p>在 32 位代码中，是用 ESP 作为栈指针的。因此，这里的段界限，用来和段粒度一起，决定 ESP 寄存器所能具有的最小值。即，栈操作时，必须符合条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ESP &gt; 段界限 * 粒度值</span><br></pre></td></tr></table></figure>



<h1 id="第-12-章-存储器的保护"><a href="#第-12-章-存储器的保护" class="headerlink" title="第 12 章 存储器的保护"></a>第 12 章 存储器的保护</h1><p>虚拟内存其实就是通过存储器的保护功能实现的：</p>
<p>当处理器访问一个实际上不存在的段时，会引发异常中断。操作系统可以利用这一点，通过接管异常处理过程，并用硬盘来进行段的换入和换出，从而实现在较小的内存空间运行尽可能大、尽可能多的程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">         ;代码清单12-1</span><br><span class="line">         ;文件名：c12_mbr.asm</span><br><span class="line">         ;文件说明：硬盘主引导扇区代码 </span><br><span class="line">         ;创建日期：2011-10-27 22:52</span><br><span class="line"></span><br><span class="line">         ;设置堆栈段和栈指针 </span><br><span class="line">         mov eax,cs      </span><br><span class="line">         mov ss,eax</span><br><span class="line">         mov sp,0x7c00</span><br><span class="line">      </span><br><span class="line">         ;计算GDT所在的逻辑段地址</span><br><span class="line">         mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位线性基地址 </span><br><span class="line">         xor edx,edx</span><br><span class="line">         mov ebx,16</span><br><span class="line">         div ebx                            ;分解成16位逻辑地址 </span><br><span class="line"></span><br><span class="line">         mov ds,eax                         ;令DS指向该段以进行操作</span><br><span class="line">         mov ebx,edx                        ;段内起始偏移地址 </span><br><span class="line"></span><br><span class="line">         ;创建0#描述符，它是空描述符，这是处理器的要求</span><br><span class="line">         mov dword [ebx+0x00],0x00000000</span><br><span class="line">         mov dword [ebx+0x04],0x00000000  </span><br><span class="line"></span><br><span class="line">         ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间</span><br><span class="line">         mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xfffff</span><br><span class="line">         mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 </span><br><span class="line"></span><br><span class="line">         ;创建保护模式下初始代码段描述符</span><br><span class="line">         mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 </span><br><span class="line">         mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 </span><br><span class="line"></span><br><span class="line">         ;创建以上代码段的别名描述符</span><br><span class="line">         mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节</span><br><span class="line">         mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符</span><br><span class="line"></span><br><span class="line">         mov dword [ebx+0x20],0x7c00fffe</span><br><span class="line">         mov dword [ebx+0x24],0x00cf9600</span><br><span class="line">         </span><br><span class="line">         ;初始化描述符表寄存器GDTR</span><br><span class="line">         mov word [cs: pgdt+0x7c00],39      ;描述符表的界限   </span><br><span class="line"> </span><br><span class="line">         lgdt [cs: pgdt+0x7c00]</span><br><span class="line">      </span><br><span class="line">         in al,0x92                         ;南桥芯片内的端口 </span><br><span class="line">         or al,0000_0010B</span><br><span class="line">         out 0x92,al                        ;打开A20</span><br><span class="line"></span><br><span class="line">         cli                                ;中断机制尚未工作</span><br><span class="line"></span><br><span class="line">         mov eax,cr0</span><br><span class="line">         or eax,1</span><br><span class="line">         mov cr0,eax                        ;设置PE位</span><br><span class="line">      </span><br><span class="line">         ;以下进入保护模式... ...</span><br><span class="line">         jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移</span><br><span class="line">                                             </span><br><span class="line">         [bits 32]                          </span><br><span class="line">  flush:                                     </span><br><span class="line">         mov eax,0x0018                      </span><br><span class="line">         mov ds,eax</span><br><span class="line">      </span><br><span class="line">         mov eax,0x0008                     ;加载数据段(0..4GB)选择子</span><br><span class="line">         mov es,eax</span><br><span class="line">         mov fs,eax</span><br><span class="line">         mov gs,eax</span><br><span class="line">      </span><br><span class="line">         mov eax,0x0020                     ;0000 0000 0010 0000</span><br><span class="line">         mov ss,eax</span><br><span class="line">         xor esp,esp                        ;ESP &lt;- 0</span><br><span class="line">      </span><br><span class="line">         mov dword [es:0x0b8000],0x072e0750 ;字符&#x27;P&#x27;、&#x27;.&#x27;及其显示属性</span><br><span class="line">         mov dword [es:0x0b8004],0x072e074d ;字符&#x27;M&#x27;、&#x27;.&#x27;及其显示属性</span><br><span class="line">         mov dword [es:0x0b8008],0x07200720 ;两个空白字符及其显示属性</span><br><span class="line">         mov dword [es:0x0b800c],0x076b076f ;字符&#x27;o&#x27;、&#x27;k&#x27;及其显示属性</span><br><span class="line"></span><br><span class="line">         ;开始冒泡排序 </span><br><span class="line">         mov ecx,pgdt-string-1              ;遍历次数=串长度-1 </span><br><span class="line">  @@1:</span><br><span class="line">         push ecx                           ;32位模式下的loop使用ecx </span><br><span class="line">         xor bx,bx                          ;32位模式下，偏移量可以是16位，也可以 </span><br><span class="line">  @@2:                                      ;是后面的32位 </span><br><span class="line">         mov ax,[string+bx] </span><br><span class="line">         cmp ah,al                          ;ah中存放的是源字的高字节 </span><br><span class="line">         jge @@3 </span><br><span class="line">         xchg al,ah </span><br><span class="line">         mov [string+bx],ax </span><br><span class="line">  @@3:</span><br><span class="line">         inc bx </span><br><span class="line">         loop @@2 </span><br><span class="line">         pop ecx </span><br><span class="line">         loop @@1</span><br><span class="line">      </span><br><span class="line">         mov ecx,pgdt-string</span><br><span class="line">         xor ebx,ebx                        ;偏移地址是32位的情况 </span><br><span class="line">  @@4:                                      ;32位的偏移具有更大的灵活性</span><br><span class="line">         mov ah,0x07</span><br><span class="line">         mov al,[string+ebx]</span><br><span class="line">         mov [es:0xb80a0+ebx*2],ax          ;演示0~4GB寻址。</span><br><span class="line">         inc ebx</span><br><span class="line">         loop @@4</span><br><span class="line">      </span><br><span class="line">         hlt </span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">     string           db &#x27;s0ke4or92xap3fv8giuzjcy5l1m7hd6bnqtw.&#x27;</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">     pgdt             dw 0</span><br><span class="line">                      dd 0x00007e00      ;GDT的物理地址</span><br><span class="line">;-------------------------------------------------------------------------------                             </span><br><span class="line">     times 510-($-$$) db 0</span><br><span class="line">     db 0x55,0xaa</span><br></pre></td></tr></table></figure>



<h2 id="进入-32-位保护模式"><a href="#进入-32-位保护模式" class="headerlink" title="进入 32 位保护模式"></a>进入 32 位保护模式</h2><h3 id="mov-ds-ax-和-mov-ds-eax"><a href="#mov-ds-ax-和-mov-ds-eax" class="headerlink" title="mov ds,ax 和 mov ds,eax"></a>mov ds,ax 和 mov ds,eax</h3><p>段寄存器（选择器）的值只能用内存单元或者通用寄存器来传送：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[bits 16]</span><br><span class="line">mov ds, ax  ; 8E D8</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">mov ds, ax  ; 66 8E D8</span><br></pre></td></tr></table></figure>

<p>现在的问题是，<code>mov ds, ax</code>用的很频繁，检查是 16 位还是 32 位需要消耗一个时钟周期，所以不能天天检查，于是，它们在 16 位模式和 32 位模式下的机器指令被设计为相同。即都是8E D8，不需要指令前缀。</p>
<p>但是 CPU 固执的认为：在 32 位模式下，源操作数是 16 位的寄存器 AX 时，应当添加指令前缀。于是，当在 32 位的时候，我们将<code>mov ds, ax</code>修改成<code>mov ds,eax</code>。</p>
<p>其他从通用寄存器到段寄存器的传送也符合这样的编译规则。</p>
<h3 id="创建-GDT-并安装段描述符"><a href="#创建-GDT-并安装段描述符" class="headerlink" title="创建 GDT 并安装段描述符"></a>创建 GDT 并安装段描述符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 </span><br><span class="line">mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 </span><br><span class="line"></span><br><span class="line">mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节</span><br><span class="line">mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符</span><br></pre></td></tr></table></figure>

<p>发现这两个描述符，描述和指向的是同一个段。其中一个是可读可写的，另一个是只读的。我们把另外的描述符称为<code>别名</code>（alias）</p>
<p><img src="/images/image-20220214225953045.png" alt="image-20220214225953045"></p>
<h3 id="修改段寄存器时的保护"><a href="#修改段寄存器时的保护" class="headerlink" title="修改段寄存器时的保护"></a>修改段寄存器时的保护</h3><p>处理器在变更段寄存器以及隐藏的描述符高速缓存器的内容时，要检查其代入值的合法性。</p>
<p>下面的指令都会修改段寄存器的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jmp dword 0x0010:flush</span><br><span class="line"></span><br><span class="line">mov ds, eax</span><br><span class="line">mov es, eax</span><br><span class="line">mov fs, eax</span><br><span class="line">mov gs, eax</span><br></pre></td></tr></table></figure>

<p>当这些指令执行时，处理器把指令中给出的选择子传送到段寄存器的选择器部分。但是，处理器的固件在完成传送之前，要确认选择子是正确的，并且该选择子选择的描述符也是正确的。</p>
<h4 id="检查索引号"><a href="#检查索引号" class="headerlink" title="检查索引号"></a>检查索引号</h4><p>GDT 的基地址和界限，都在寄存器 GDTR 中。描述符在内存中的地址，是用索引号乘以 8，再和描述符表的线性基地址相加得到的，而这个地址必须在描述符表的地址范围内。也就是说：<strong>索引号乘以 8 得到的数值，必须位于描述符表的边界范围之内</strong>。</p>
<p>如果检查到指定的段描述符，其位置超过表的边界时，处理器中止处理，产生<code>异常中断 13</code>，同时段寄存器中的原值不变。</p>
<p><img src="/images/image-20220214230715462.png" alt="image-20220214230715462"></p>
<h4 id="段的类别检查"><a href="#段的类别检查" class="headerlink" title="段的类别检查"></a>段的类别检查</h4><p>通过了上述检查，并从表中取得描述符后，紧接着还要<strong>对描述符的类别进行确认</strong>。</p>
<ol>
<li><p>首先，描述符的类别字段必须是有效的值。接着要确认段的类别。</p>
<p><img src="/images/130a3de5-image-20220212231925753.png" alt="image-20220212231925753"></p>
<blockquote>
<p>eg：若描述符的类别是只执行的代码段，则不允许加载到除 CS 之外的其他段寄存器中。</p>
</blockquote>
</li>
<li><p>然后，检查描述符的类别是否和段寄存器的用途匹配。</p>
<p><img src="/images/image-20220214232327724.png" alt="image-20220214232327724"></p>
</li>
<li><p>最后，要检查描述符中的 P 位。</p>
<ul>
<li>如果 P＝0，表明虽然描述符已被定义，但该段实际上并不存在于物理内存中。此时，处理器中止处理，引发异常中断11。</li>
<li>如果 P＝1，则处理器将描述符加载到段寄存器的描述符高速缓存器，同时置 A 位。</li>
</ul>
<blockquote>
<p>一般来说，对于异常中断11，应当定义一个中断处理程序，把该描述符所对应的段从硬盘等外部存储器调入内存，然后置 P 位。中断返回时，处理器将再次尝试刚才的操作。</p>
</blockquote>
</li>
</ol>
<p>显然，只有可以写入的数据段才能加载到 SS 的选择器，CS 寄存器只允许加载代码段描述符。</p>
<h3 id="地址变换时的保护"><a href="#地址变换时的保护" class="headerlink" title="地址变换时的保护"></a>地址变换时的保护</h3><h4 id="代码段执行时的保护"><a href="#代码段执行时的保护" class="headerlink" title="代码段执行时的保护"></a>代码段执行时的保护</h4><p>在 32 位模式下，段的信息在描述符表中。但是，一旦相应的描述符被加载到段寄存器的描述符高速缓存器，则处理器取指令和执行指令时，将不再访问描述符表，而是直接使用段寄存器的描述符高速缓存器，从中取得线性基地址，同指令指针寄存器 EIP 的内容相加，共同形成 32位的物理地址从内存中取得下一条指令。</p>
<p>在指令实际开始执行之前，处理器必须<strong>检验其存放地址的有效性，以防止执行超出允许范围之外的指令</strong>。</p>
<p>每个代码段都有自己的段界限，位于其描述符中。实际使用的段界限，其数值和粒度（G）位有关，</p>
<ul>
<li><p>如果 G＝0，实际使用的段界限为：描述符中的段界限值</p>
</li>
<li><p>如果 G＝1，实际使用的段界限为：<code>描述符中的段界限值*0x1000+0xFFF</code></p>
<blockquote>
<p>如果 G＝1，段的粒度是以 4KB 为单位的。对于以 4KB 为粒度的段，描述符中的界限值加 1，就是该段有多少个 4KB。 因此，其实际使用的段界限为 <code>(描述符中的段界限值+1)*0x1000-1</code>，化简得到：<code>描述符中的段界限值*0x1000+0xFFF</code></p>
</blockquote>
</li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>