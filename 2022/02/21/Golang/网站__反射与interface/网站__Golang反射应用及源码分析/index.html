<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;reflect-简介&quot;&gt;&lt;a href=&quot;#reflect-简介&quot; class=&quot;headerlink&quot; title=&quot;reflect 简介&quot;&gt;&lt;/a&gt;reflect 简介&lt;/h2&gt;&lt;p&gt;reflect 是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，&lt;strong&gt;反射就是程序在运行的时候能够“观察”并且修改自己的行为&lt;/strong&gt;。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Golang反射应用及源码分析 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-02-21</div></div></div><div class="container post-header"><h1>Golang反射应用及源码分析</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#reflect-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">reflect 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%8F%8D%E5%B0%84"><span class="toc-number">2.</span> <span class="toc-text">什么时候需要反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">反射的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.</span> <span class="toc-text">反射的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pair"><span class="toc-number">4.1.</span> <span class="toc-text">pair</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pair%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.</span> <span class="toc-text">pair与反射的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo"><span class="toc-number">6.</span> <span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%89%E5%A4%A7%E5%AE%9A%E5%BE%8B"><span class="toc-number">7.</span> <span class="toc-text">反射三大定律</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflection-goes-from-interface-value-to-reflection-object"><span class="toc-number">7.1.</span> <span class="toc-text">Reflection goes from interface value to reflection object.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflection-goes-from-reflection-object-to-interface-value"><span class="toc-number">7.2.</span> <span class="toc-text">Reflection goes from reflection object to interface value.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#To-modify-a-reflection-object-the-value-must-be-settable"><span class="toc-number">7.3.</span> <span class="toc-text">To modify a reflection object, the value must be settable.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">反射源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect-go-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">reflect.go 源码结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeOf"><span class="toc-number">8.1.1.</span> <span class="toc-text">TypeOf</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#value-go-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.</span> <span class="toc-text">value.go 源码结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ValueOf"><span class="toc-number">8.2.1.</span> <span class="toc-text">ValueOf</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD-TypeOf-%E5%92%8C-ValueOf"><span class="toc-number">9.1.</span> <span class="toc-text">reflect 的基本功能 TypeOf 和 ValueOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-relfect-Value-%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3-interface-%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">9.2.</span> <span class="toc-text">从 relfect.Value 中获取接口 interface 的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E7%9F%A5%E5%8E%9F%E6%9C%89%E7%B1%BB%E5%9E%8B%E3%80%90%E9%81%8D%E5%8E%86%E6%8E%A2%E6%B5%8B%E5%85%B6-Filed%E3%80%91"><span class="toc-number">9.3.</span> <span class="toc-text">未知原有类型【遍历探测其 Filed】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-reflect-Value-%E8%AE%BE%E7%BD%AE%E5%AE%9E%E9%99%85%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">9.4.</span> <span class="toc-text">通过 reflect.Value 设置实际变量的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-reflect-ValueOf-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">9.5.</span> <span class="toc-text">通过 reflect.ValueOf 来进行方法的调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="reflect-简介"><a href="#reflect-简介" class="headerlink" title="reflect 简介"></a>reflect 简介</h2><p>reflect 是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，<strong>反射就是程序在运行的时候能够“观察”并且修改自己的行为</strong>。</p>
<p>reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象。</p>
<p>反射作为一种元编程方式可以减少重复代码，但使用不当，也会使程序变得过于抽象，难以理解，且运行缓慢。因此我们需要对反射有一个基本的了解，以便能够恰当的使用反射。</p>
<h2 id="什么时候需要反射"><a href="#什么时候需要反射" class="headerlink" title="什么时候需要反射"></a>什么时候需要反射</h2><ul>
<li>不能预先确定参数的类型，可能是因为没有约定好，也可能是传入的参数类型有很多，且不能统一表示。</li>
<li>函数需要根据输入的参数来动态的执行不同的行为。</li>
</ul>
<h2 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h2><p>优点：</p>
<ul>
<li>可以在一定程度上避免硬编码，提供灵活性和通用性。</li>
<li>可以作为一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E9%A1%9E%E7%89%A9%E4%BB%B6">第一类对象</a>发现并修改源代码的结构（如代码块、类、方法、协议等）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>同样因为反射的概念和语法都比较抽象，滥用反射会使得代码难以被其他人读懂。</li>
<li>无法在编译时检查错误。代码在运行时存在 panic 的风险。</li>
<li>降低了代码运行的效率，反射出变量的类型需要额外的开销。</li>
</ul>
<h2 id="反射的本质"><a href="#反射的本质" class="headerlink" title="反射的本质"></a>反射的本质</h2><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>变量包括（type, value）两部分。</p>
<p>type 包括 static type 和 concrete type。</p>
<ul>
<li>static type 是你在编码是看见的类型 (如 int、string)，static type 在创建变量的时候就已经确定。</li>
<li>concrete type 是 runtime 系统看见的类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    Var--&gt;type;</span><br><span class="line">    Var--&gt;value;</span><br><span class="line">    type--&gt;staticType;</span><br><span class="line">    type--&gt;concreteType;</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure>

<p>此时，对于变量 r：</p>
<ul>
<li>value 为 tty</li>
<li>static type 为 io.Reader</li>
<li>concrete type 为 *os.File</li>
</ul>
<p><strong>类型断言能否成功，取决于变量的 concrete type</strong>，而不是 static type。因此，一个 reader 变量如果它的 concrete type 也实现了 write 方法的话，它也可以被类型断言为 writer。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>



<p>对于<code>interface&#123;&#125;</code>变量，其 static type 就是 <code>interface&#123;&#125;</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty2, err := os.OpenFile(<span class="string">&quot;/dev/tty&quot;</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r2 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r2 = tty2</span><br></pre></td></tr></table></figure>

<p>此时，对于变量 r2：</p>
<ul>
<li>value 为 tty2</li>
<li>static type 为 interface{}</li>
<li>concrete type 为 *os.File</li>
</ul>
<h2 id="pair与反射的关系"><a href="#pair与反射的关系" class="headerlink" title="pair与反射的关系"></a>pair与反射的关系</h2><p>众所周知，反射是针对 interface 类型的，只有 interface 类型才有反射一说。而所有的 interface 类型，其 static type 都为 <code>interface&#123;&#125;</code>。</p>
<p>因此，在 Golang 的实现中，每个 interface 变量都有一个对应 pair，pair 中记录了实际变量的值和类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value, type)</span><br></pre></td></tr></table></figure>

<p>value 是实际变量值，type 是实际变量的类型。一个 interface {} 类型的变量包含了 2 个指针：</p>
<ul>
<li>一个指针指向实际的值【对应 value】</li>
<li>一个指针指向值的类型【对应 concrete type】</li>
</ul>
<p>interface 及其 pair 的存在，是 Golang 中实现反射的前提。<strong>反射就是用来检测存储在接口变量内部 (值 value；类型 concrete type) pair 对的一种机制</strong>。</p>
<p>为了修改 value 和 concrete type，reflect 提供了 TypeOf 和 ValueOf 两个方法：</p>
<ul>
<li><code>func ValueOf(i interface&#123;&#125;) Value &#123;...&#125;</code>：获取 pair 中的 type</li>
<li><code>func TypeOf(i interface&#123;&#125;) Type &#123;...&#125;</code> ：获取 pair 中的 value</li>
</ul>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Spider <span class="keyword">interface</span> &#123;</span><br><span class="line">	Crawl() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ASpider <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ASpider)</span> <span class="title">Crawl</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunCrawl</span><span class="params">(spider Spider)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	reflectValue := reflect.ValueOf(spider)</span><br><span class="line">	method := reflectValue.MethodByName(<span class="string">&quot;Crawl&quot;</span>)</span><br><span class="line">	value := method.Call(<span class="literal">nil</span>)</span><br><span class="line">	ret := value[<span class="number">0</span>].Interface().(<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflect</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	a := &amp;ASpider&#123;&#125;</span><br><span class="line">	ret := RunCrawl(a)</span><br><span class="line">	fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射三大定律"><a href="#反射三大定律" class="headerlink" title="反射三大定律"></a>反射三大定律</h2><ul>
<li>Reflection goes from interface value to reflection object.</li>
<li>Reflection goes from reflection object to interface value.</li>
<li>To modify a reflection object, the value must be settable.</li>
</ul>
<h3 id="Reflection-goes-from-interface-value-to-reflection-object"><a href="#Reflection-goes-from-interface-value-to-reflection-object" class="headerlink" title="Reflection goes from interface value to reflection object."></a>Reflection goes from interface value to reflection object.</h3><p>从<code>接口值</code>反射到<code>反射对象</code>。</p>
<p>从 interface{} 变量可以反射出 reflect 对象，具体来说，通过 reflect.TypeOf 获取了变量的类型，reflect.ValueOf 获取了变量的值。</p>
<p>如果我们知道了一个变量的类型和值，那么就意味着我们知道了这个变量的全部信息。通过 type、value 提供的方法，可以获取变量实现的方法、类型的全部字段等等。</p>
<p><img src="/images/ohh5VZY1YMVYeKpe3kz7mTIinP.jpg" alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coder <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coder)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCoder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	coder := &amp;Coder&#123;Name: <span class="string">&quot;obgnail&quot;</span>&#125;</span><br><span class="line">	typ := reflect.TypeOf(coder)</span><br><span class="line">	val := reflect.ValueOf(coder)</span><br><span class="line"></span><br><span class="line">	typeOfStringer := reflect.TypeOf((*fmt.Stringer)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">	fmt.Println(<span class="string">&quot;kind of coder:&quot;</span>, typ.Kind()) <span class="comment">// kind of coder: ptr</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;type of coder:&quot;</span>, typ)  <span class="comment">// type of coder: *reflect_test.Coder</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;value of coder:&quot;</span>, val) <span class="comment">// value of coder: obgnail</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;implements stringer:&quot;</span>, typ.Implements(typeOfStringer)) <span class="comment">// implements stringer: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>(*fmt.Stringer)(nil)</code> 怎么理解？</p>
<p>答：<code>(*T)(nil)</code>其实是类型转换。正常的类型转换是<code>T(expr)</code>，如<code>string(a)</code>，但是取址符号<code>*</code>的优先级更高，因此<code>*T(expr)</code>需要写成<code>(*T)(expr)</code>所以<code>(*T)(nil)</code>就很好理解了，这里就是将 nil 转换为<code>*T</code>类型。所以，<code>var a *fmt.Stringer = (*fmt.Stringer)(nil)</code>就是返回一个实现了<code>*fmt.Stringer</code>接口的变量 a。</p>
</blockquote>
<h3 id="Reflection-goes-from-reflection-object-to-interface-value"><a href="#Reflection-goes-from-reflection-object-to-interface-value" class="headerlink" title="Reflection goes from reflection object to interface value."></a>Reflection goes from reflection object to interface value.</h3><p>从<code>反射对象</code> 变回 <code>interface&#123;&#125;对象</code></p>
<ul>
<li>具体来说，通过 Interface()方法 从反射对象获取interface{} 变量</li>
</ul>
<p><img src="/images/ShHZZTIRgd1Abr.jpg" alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coder <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coder)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCoder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	coder := &amp;Coder&#123;Name: <span class="string">&quot;obgnail&quot;</span>&#125;</span><br><span class="line">	val := reflect.ValueOf(coder)</span><br><span class="line">  c, ok := val.Interface().(*Coder)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(c.Name)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;type assert to *Coder err&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可见，第一第二定律是互逆的。通过 ValueOf 方法可以从 Interface 获取反射对象，反射对象调用 Interface() 可以获取 Interface 变量。Interface 变量可以用类型转换再得到原来的变量。</p>
<p><img src="/images/qqq.png" alt="img"></p>
<h3 id="To-modify-a-reflection-object-the-value-must-be-settable"><a href="#To-modify-a-reflection-object-the-value-must-be-settable" class="headerlink" title="To modify a reflection object, the value must be settable."></a>To modify a reflection object, the value must be settable.</h3><p>要更新一个 reflect.Value，那么<strong>它的值必须是可被更新的</strong>。否则将会导致 panic。</p>
<p>辅助判断:</p>
<ul>
<li>reflect.flag.mustBeAssignable 检查是否可以被设置</li>
<li>reflect.flag.mustBeExported 检查变量是否可以被导出，防止不可导出的的变量泄露</li>
<li>reflect.Value.assignTo 会返回一个新的反射对象，这个返回的反射对象指针会直接覆盖原反射变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectionLaw3V1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  v := reflect.ValueOf(i)</span><br><span class="line">  v.SetInt(<span class="number">10</span>)</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过获取变量的指针来更新值</span></span><br><span class="line"><span class="comment">// 相当于：</span></span><br><span class="line"><span class="comment">//   i := 1</span></span><br><span class="line"><span class="comment">//   v := &amp;i</span></span><br><span class="line"><span class="comment">//   *v = 10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectionLaw3V2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  v := reflect.ValueOf(&amp;i)</span><br><span class="line">  v.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射源码分析"><a href="#反射源码分析" class="headerlink" title="反射源码分析"></a>反射源码分析</h2><p>reflect 包的核心就在 type.go 和 value.go</p>
<ul>
<li>deep_equal.go 介绍了 deep equal 的概念和实现</li>
<li>make_func.go 则是在运行时修改函数的栈信息来实现类似多态的特性</li>
<li>swapper.go 则定义了一个通用的 swapper 方法，sort 包中的 swapper 就是用的这个</li>
</ul>
<h3 id="reflect-go-源码结构"><a href="#reflect-go-源码结构" class="headerlink" title="reflect.go 源码结构"></a>reflect.go 源码结构</h3><p><img src="/images/ups.png" alt="img"></p>
<h4 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h4><p>interface{} 类型在语言内部是通过 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L194">reflect.emptyInterface</a> 结体表示的，其中的 rtype 字段用于表示变量的类型，另一个 word 字段指向内部封装的数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// emptyInterface is the header for an interface&#123;&#125; value.</span></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于获取变量类型的 reflect.TypeOf 函数将传入的变量隐式转换成 reflect.emptyInterface 类型并获取其中存储的类型信息 reflect.rtype</p>
<p>reflect.TypeOf 的实现原理其实并不复杂，它只是将一个 interface{} 变量转换成了内部的 reflect.emptyInterface 表示，然后从中获取相应的类型信息</p>
<h3 id="value-go-源码结构"><a href="#value-go-源码结构" class="headerlink" title="value.go 源码结构"></a>value.go 源码结构</h3><p><img src="/images/it3g.png" alt="img"></p>
<h4 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h4><p>reflect.ValueOf 函数中先调用了 reflect.escapes 保证当前值逃逸到堆上，然后通过 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/reflect/value.go#L142">reflect.unpackEface</a> 从接口中获取 reflect.Value 结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueOf returns a new Value initialized to the concrete value</span></span><br><span class="line"><span class="comment">// stored in the interface i. ValueOf(nil) returns the zero Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	escapes(i)</span><br><span class="line">	<span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unpackEface converts the empty interface i to a Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">	e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	t := e.typ</span><br><span class="line">	<span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f := flag(t.Kind())</span><br><span class="line">	<span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">		f |= flagIndir</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="reflect-的基本功能-TypeOf-和-ValueOf"><a href="#reflect-的基本功能-TypeOf-和-ValueOf" class="headerlink" title="reflect 的基本功能 TypeOf 和 ValueOf"></a>reflect 的基本功能 TypeOf 和 ValueOf</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;type: &quot;</span>, reflect.TypeOf(num))    <span class="comment">// type:  float64</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;value: &quot;</span>, reflect.ValueOf(num))  <span class="comment">// value:  1.2345</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>reflect.TypeOf： 直接给到了我们想要的 type 类型，如 float64、int、各种 pointer、struct 等等真实的类型</li>
<li>reflect.ValueOf：直接给到了我们想要的具体的值，如 1.2345 这个具体数值，或者类似 &amp;{1 “Allen.Wu” 25} 这样的结构体 struct 的值</li>
<li>也就是说明反射可以将 “接口类型变量” 转换为 “反射类型对象”，反射类型指的是 reflect.Type 和 reflect.Value 这两种</li>
</ol>
<h3 id="从-relfect-Value-中获取接口-interface-的信息"><a href="#从-relfect-Value-中获取接口-interface-的信息" class="headerlink" title="从 relfect.Value 中获取接口 interface 的信息"></a>从 relfect.Value 中获取接口 interface 的信息</h3><p>已知类型后转换为其对应的类型的做法如下，直接通过 Interface 方法然后强制转换，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">realValue := value.Interface().(已知的类型)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">float64</span> = <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">	pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">	value := reflect.ValueOf(num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic</span></span><br><span class="line">	<span class="comment">// Golang 对类型要求非常严格，类型一定要完全符合</span></span><br><span class="line">	<span class="comment">// 如下两个，一个是*float64，一个是float64，如果弄混，则会panic</span></span><br><span class="line">	convertPointer := pointer.Interface().(*<span class="keyword">float64</span>)</span><br><span class="line">	convertValue := value.Interface().(<span class="keyword">float64</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(convertPointer)  <span class="comment">// 0xc42000e238</span></span><br><span class="line">	fmt.Println(convertValue)    <span class="comment">// 1.2345</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>转换的时候，如果转换的类型不完全符合，则直接 panic，类型要求非常严格！</li>
<li>转换的时候，要区分是指针还是指</li>
<li>也就是说反射可以将 “反射类型对象” 再重新转换为 “接口类型变量”</li>
</ol>
<h3 id="未知原有类型【遍历探测其-Filed】"><a href="#未知原有类型【遍历探测其-Filed】" class="headerlink" title="未知原有类型【遍历探测其 Filed】"></a>未知原有类型【遍历探测其 Filed】</h3><p>很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其 Filed 来得知</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Allen.Wu ReflectCallFunc&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	user := User&#123;<span class="number">1</span>, <span class="string">&quot;Allen.Wu&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">	DoFiledAndMethod(user)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过接口来获取任意参数，然后一一揭晓</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoFiledAndMethod</span><span class="params">(input <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	getType := reflect.TypeOf(input)</span><br><span class="line">	fmt.Println(<span class="string">&quot;get Type is :&quot;</span>, getType.Name())</span><br><span class="line"></span><br><span class="line">	getValue := reflect.ValueOf(input)</span><br><span class="line">	fmt.Println(<span class="string">&quot;get all Fields is:&quot;</span>, getValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取方法字段</span></span><br><span class="line">	<span class="comment">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span></span><br><span class="line">	<span class="comment">// 2. 再通过reflect.Type的Field获取其Field</span></span><br><span class="line">	<span class="comment">// 3. 最后通过Field的Interface()得到对应的value</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; getType.NumField(); i++ &#123;</span><br><span class="line">		field := getType.Field(i)</span><br><span class="line">		value := getValue.Field(i).Interface()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取方法</span></span><br><span class="line">	<span class="comment">// 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; getType.NumMethod(); i++ &#123;</span><br><span class="line">		m := getType.Method(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: %v\n&quot;</span>, m.Name, m.Type)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">get Type is : User</span></span><br><span class="line"><span class="comment">get all Fields is: &#123;1 Allen.Wu 25&#125;</span></span><br><span class="line"><span class="comment">Id: int = 1</span></span><br><span class="line"><span class="comment">Name: string = Allen.Wu</span></span><br><span class="line"><span class="comment">Age: int = 25</span></span><br><span class="line"><span class="comment">ReflectCallFunc: func(main.User)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通过运行结果可以得知获取未知类型的 interface 的具体变量及其类型的步骤为：</p>
<ol>
<li>先获取 interface 的 reflect.Type，然后通过 NumField 进行遍历</li>
<li>再通过 reflect.Type 的 Field 获取其 Field</li>
<li> 最后通过 Field 的 Interface () 得到对应的 value</li>
</ol>
<p>通过运行结果可以得知获取未知类型的 interface 的所属方法（函数）的步骤为：</p>
<ol>
<li>先获取 interface 的 reflect.Type，然后通过 NumMethod 进行遍历</li>
<li>再分别通过 reflect.Type 的 Method 获取对应的真实的方法（函数）</li>
<li>最后对结果取其 Name 和 Type 得知具体的方法名</li>
<li>也就是说反射可以将 “反射类型对象” 再重新转换为 “接口类型变量”</li>
<li>struct 或者 struct 的嵌套都是一样的判断处理方式</li>
</ol>
<h3 id="通过-reflect-Value-设置实际变量的值"><a href="#通过-reflect-Value-设置实际变量的值" class="headerlink" title="通过 reflect.Value 设置实际变量的值"></a>通过 reflect.Value 设置实际变量的值</h3><p>reflect.Value 是通过 reflect.ValueOf (X) 获得的，只有当 X 是指针的时候，才可以通过 reflec.Value 修改实际变量 X 的值，即：要修改反射类型的对象就一定要保证其值是 “addressable” 的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">float64</span> = <span class="number">1.2345</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;old value of pointer:&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值</span></span><br><span class="line">	pointer := reflect.ValueOf(&amp;num)</span><br><span class="line">	newValue := pointer.Elem()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, newValue.Type())</span><br><span class="line">	fmt.Println(<span class="string">&quot;settability of pointer:&quot;</span>, newValue.CanSet())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新赋值</span></span><br><span class="line">	newValue.SetFloat(<span class="number">77</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;new value of pointer:&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">	<span class="comment">////////////////////</span></span><br><span class="line">	<span class="comment">// 如果reflect.ValueOf的参数不是指针，会如何？</span></span><br><span class="line">	pointer = reflect.ValueOf(num)</span><br><span class="line">	<span class="comment">//newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">old value of pointer: <span class="number">1.2345</span></span><br><span class="line"><span class="keyword">type</span> of pointer: <span class="keyword">float64</span></span><br><span class="line">settability of pointer: <span class="literal">true</span></span><br><span class="line"><span class="built_in">new</span> value of pointer: <span class="number">77</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>需要传入的参数是 * float64 这个指针，然后可以通过 pointer.Elem () 去获取所指向的 Value，<strong>注意一定要是指针</strong>。</p>
</li>
<li><p>如果传入的参数不是指针，而是变量，那么</p>
<ul>
<li>通过 Elem 获取原始值对应的对象则直接 panic</li>
<li> 通过 CanSet 方法查询是否可以设置返回 false</li>
</ul>
</li>
<li><p>newValue.CantSet () 表示是否可以重新设置其值，如果输出的是 true 则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。</p>
</li>
<li><p>reflect.Value.Elem () 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的</p>
</li>
<li><p>也就是说如果要修改反射类型对象，其值必须是 “addressable”【对应的要传入的是指针，同时要通过 Elem 方法获取原始值对应的反射对象】</p>
</li>
<li><p>struct 或者 struct 的嵌套都是一样的判断处理方式</p>
</li>
</ol>
<h3 id="通过-reflect-ValueOf-来进行方法的调用"><a href="#通过-reflect-ValueOf-来进行方法的调用" class="headerlink" title="通过 reflect.ValueOf 来进行方法的调用"></a>通过 reflect.ValueOf 来进行方法的调用</h3><p>前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过 reflect 来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过 reflect 来搞定</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFuncHasArgs</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ReflectCallFuncHasArgs name: &quot;</span>, name, <span class="string">&quot;, age:&quot;</span>, age, <span class="string">&quot;and origal User.Name:&quot;</span>, u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">ReflectCallFuncNoArgs</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ReflectCallFuncNoArgs&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何通过反射来进行方法的调用？</span></span><br><span class="line"><span class="comment">// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user := User&#123;<span class="number">1</span>, <span class="string">&quot;Allen.Wu&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理</span></span><br><span class="line">	getValue := reflect.ValueOf(user)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一定要指定参数为正确的方法名</span></span><br><span class="line">	<span class="comment">// 2. 先看看带有参数的调用方法</span></span><br><span class="line">	methodValue := getValue.MethodByName(<span class="string">&quot;ReflectCallFuncHasArgs&quot;</span>)</span><br><span class="line">	args := []reflect.Value&#123;reflect.ValueOf(<span class="string">&quot;wudebao&quot;</span>), reflect.ValueOf(<span class="number">30</span>)&#125;</span><br><span class="line">	methodValue.Call(args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一定要指定参数为正确的方法名</span></span><br><span class="line">	<span class="comment">// 3. 再看看无参数的调用方法</span></span><br><span class="line">	methodValue = getValue.MethodByName(<span class="string">&quot;ReflectCallFuncNoArgs&quot;</span>)</span><br><span class="line">	args = <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>)</span><br><span class="line">	methodValue.Call(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu</span></span><br><span class="line"><span class="comment">ReflectCallFuncNoArgs</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol>
<li>要通过反射来调用起对应的方法，必须要先通过 reflect.ValueOf (interface) 来获取到 reflect.Value，得到 “反射类型对象” 后才能做下一步处理</li>
<li>reflect.Value.MethodByName 这.MethodByName，需要指定准确真实的方法名字，如果错误将直接 panic，MethodByName 返回一个函数值对应的 reflect.Value 方法的名字。</li>
<li>[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。</li>
<li>reflect.Value 的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果 reflect.Value’Kind 不是一个方法，那么将直接 panic。</li>
<li>本来可以用 u.ReflectCallFuncXXX 直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是 MethodByName，然后通过反射调用 methodValue.Call。</li>
</ol>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1VdhVlsKGFQ2g_JCY7U65ap05ZTyC_WMFup7sru-OlzI/edit">google docs</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1My4y117gQ">bilibili</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903559335526407">Golang 的反射 reflect 深入理解和示例</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>