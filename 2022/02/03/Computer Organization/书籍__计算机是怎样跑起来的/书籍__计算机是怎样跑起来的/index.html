<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第-1-章-计算机的三大原则&quot;&gt;&lt;a href=&quot;#第-1-章-计算机的三大原则&quot; class=&quot;headerlink&quot; title=&quot;第 1 章 计算机的三大原则&quot;&gt;&lt;/a&gt;第 1 章 计算机的三大原则&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;计算机是执行输入、运算、输出的机器&lt;/li&gt;
&lt;li&gt;程序是指令和数据的集合&lt;/li&gt;
&lt;li&gt;计算机的处理方式有时与人们的思维习惯不同&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;第-2-章-试着制造一台计算机吧&quot;&gt;&lt;a href=&quot;#第-2-章-试着制造一台计算机吧&quot; class=&quot;headerlink&quot; title=&quot;第 2 章 试着制造一台计算机吧&quot;&gt;&lt;/a&gt;第 2 章 试着制造一台计算机吧&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/image-20220129210716985.png&quot; alt=&quot;image-20220129210716985&quot;&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>计算机是怎样跑起来的 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Computer-Organization/" rel="tag">Computer Organization</a></div><div class="post-time">2022-02-03</div></div></div><div class="container post-header"><h1>计算机是怎样跑起来的</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">第 1 章 计算机的三大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E8%AF%95%E7%9D%80%E5%88%B6%E9%80%A0%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%A7"><span class="toc-number">2.</span> <span class="toc-text">第 2 章 试着制造一台计算机吧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E4%BD%93%E9%AA%8C%E4%B8%80%E6%AC%A1%E6%89%8B%E5%B7%A5%E6%B1%87%E7%BC%96"><span class="toc-number">3.</span> <span class="toc-text">第 3 章 体验一次手工汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E6%B1%87%E7%BC%96"><span class="toc-number">3.1.</span> <span class="toc-text">手工汇编</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E5%83%8F%E6%B2%B3%E6%B0%B4%E4%B8%80%E6%A0%B7%E6%B5%81%E5%8A%A8%E7%9D%80"><span class="toc-number">4.</span> <span class="toc-text">第 4 章 程序像河水一样流动着</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E4%B8%8A%E7%9C%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%B0%B1%E6%98%AFPC%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8E%E4%BD%8E%E5%9C%B0%E5%9D%80%E6%8C%87%E5%90%91%E9%AB%98%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">从汇编角度上看，顺序执行就是PC寄存器从低地址指向高地址的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.2.</span> <span class="toc-text">结构化程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%BF%A1%E5%8F%B7%E5%9B%BE%E7%A4%BA"><span class="toc-number">4.3.</span> <span class="toc-text">中断请求信号图示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">事件驱动是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E4%B8%8E%E7%AE%97%E6%B3%95%E6%88%90%E4%B8%BA%E5%A5%BD%E6%9C%8B%E5%8F%8B%E7%9A%84%E4%B8%83%E4%B8%AA%E8%A6%81%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">第 5 章 与算法成为好朋友的七个要点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">哨兵的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%88%90%E4%B8%BA%E5%A5%BD%E6%9C%8B%E5%8F%8B-%E7%9A%84%E4%B8%83%E4%B8%AA%E8%A6%81%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">第 6 章 与数据结构成为好朋友 的七个要点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E6%88%90%E4%B8%BA%E4%BC%9A%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84-%E7%A8%8B%E5%BA%8F%E5%91%98%E5%90%A7"><span class="toc-number">7.</span> <span class="toc-text">第 7 章 成为会使用面向对象编程的 程序员吧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-8-%E7%AB%A0-%E4%B8%80%E7%94%A8%E5%B0%B1%E4%BC%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.</span> <span class="toc-text">第 8 章 一用就会的数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E9%80%9A%E8%BF%87%E4%B8%83%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E7%90%86%E8%A7%A3-TCP-IP-%E7%BD%91%E7%BB%9C"><span class="toc-number">9.</span> <span class="toc-text">第 9 章 通过七个简单的实验理解 TCP&#x2F;IP 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FQDN-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.1.</span> <span class="toc-text">FQDN 是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-10-%E7%AB%A0-%E8%AF%95%E7%9D%80%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E5%90%A7"><span class="toc-number">10.</span> <span class="toc-text">第 10 章 试着加密数据吧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-11-%E7%AB%A0-XML-%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">11.</span> <span class="toc-text">第 11 章 XML 究竟是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-12-%E7%AB%A0-SE-%E8%B4%9F%E8%B4%A3%E7%9B%91%E7%AE%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">12.</span> <span class="toc-text">第 12 章 SE 负责监管计算机系统 的构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84-7-%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">12.1.</span> <span class="toc-text">瀑布模型中的 7 个阶段</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="第-1-章-计算机的三大原则"><a href="#第-1-章-计算机的三大原则" class="headerlink" title="第 1 章 计算机的三大原则"></a>第 1 章 计算机的三大原则</h2><ol>
<li>计算机是执行输入、运算、输出的机器</li>
<li>程序是指令和数据的集合</li>
<li>计算机的处理方式有时与人们的思维习惯不同</li>
</ol>
<h2 id="第-2-章-试着制造一台计算机吧"><a href="#第-2-章-试着制造一台计算机吧" class="headerlink" title="第 2 章 试着制造一台计算机吧"></a>第 2 章 试着制造一台计算机吧</h2><p><img src="/images/image-20220129210716985.png" alt="image-20220129210716985"></p>
<h2 id="第-3-章-体验一次手工汇编"><a href="#第-3-章-体验一次手工汇编" class="headerlink" title="第 3 章 体验一次手工汇编"></a>第 3 章 体验一次手工汇编</h2><p><img src="/images/image-20220129212021038.png" alt="image-20220129212021038"></p>
<ul>
<li>Z80 CPU 的 MREQ 引脚和 IORQ 引脚实现了一种能区分输入输出对象的机制，<strong>可以区分出使用着相同内存地址的内存和 I/O</strong>。</li>
<li>在汇编语言中，读写内存的指令不同于读写 I/O 的指令。<ul>
<li>一旦执行了读写内存的指令，比如 LD 指令，MREQ 引脚上的值就会变为 0，于是内存被选为输入输出的对象；</li>
<li>一旦执行了读写 I/O 的指令，比如 IN 或 OUT 指令， IORQ 引脚上的值就会变为 0，于是 I/O 被选为输入输出的对象。</li>
</ul>
</li>
</ul>
<h3 id="手工汇编"><a href="#手工汇编" class="headerlink" title="手工汇编"></a>手工汇编</h3><ul>
<li><p>在 CPU 的资料中，明确写有所有可以使用的助记符，以及助记符转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言编写的程序手工转换成机器语言的程序，这样的工作称为<code>手工汇编</code>。</p>
</li>
<li><p>从助记符到机器语言的转换方法：</p>
<table>
<thead>
<tr>
<th>助记符</th>
<th>机器语言</th>
<th>时钟周期数</th>
</tr>
</thead>
<tbody><tr>
<td>LD A, num</td>
<td>00111110 num</td>
<td>7</td>
</tr>
<tr>
<td>OUT (num), A</td>
<td>11010011 num</td>
<td>11</td>
</tr>
<tr>
<td>IN A,(num)</td>
<td>11011011 num</td>
<td>11</td>
</tr>
<tr>
<td>JP num</td>
<td>11000011 num</td>
<td>10</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="第-4-章-程序像河水一样流动着"><a href="#第-4-章-程序像河水一样流动着" class="headerlink" title="第 4 章 程序像河水一样流动着"></a>第 4 章 程序像河水一样流动着</h2><h3 id="从汇编角度上看，顺序执行就是PC寄存器从低地址指向高地址的过程"><a href="#从汇编角度上看，顺序执行就是PC寄存器从低地址指向高地址的过程" class="headerlink" title="从汇编角度上看，顺序执行就是PC寄存器从低地址指向高地址的过程"></a>从汇编角度上看，<code>顺序执行</code>就是PC寄存器从低地址指向高地址的过程</h3><p>程序基本上是从内存中的低地址开始，向着高地址流下去的 。我们把程序的这种流动称为“顺序执行”。</p>
<p><img src="/images/image-20220131211233773.png" alt="image-20220131211233773"></p>
<h3 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h3><p>其实就是：为了把程序编写得具备结构性，仅使用顺序执行、条件分支和循环表示程序的流程即可，而**不再使用跳转指令(goto)**。</p>
<h3 id="中断请求信号图示"><a href="#中断请求信号图示" class="headerlink" title="中断请求信号图示"></a>中断请求信号图示</h3><p><img src="/images/image-20220131212322470.png" alt="image-20220131212322470"></p>
<h3 id="事件驱动是什么？"><a href="#事件驱动是什么？" class="headerlink" title="事件驱动是什么？"></a>事件驱动是什么？</h3><ul>
<li>用户的操作等产生事件后，由事件决定程序的流程。</li>
<li>Windows 应用程序的运行就是由事件驱动的。例如， 选择“打开文件”菜单项就能打开一个窗口，在里面可以指定要打开文件的名称和存储位置。之所以能够这样是因为<strong>一旦触发了“选中了菜单项”这个事件，程序的流程就相应地流转到了处理打开窗口的那部分</strong>。</li>
<li>可以<strong>把事件驱动想象成是两个程序在对话</strong>。<ol>
<li>在程序中有 WinMain() 和 WndProc() 两个函数。WinMain() 是在程序启动时被调用的主例程（Main Routine）。而 WndProc() 并不会被程序本身调用，Windows 操作系统才是 WndProc() 的调用者。这种机制就使得 Windows 和编写的应用程序这两个程序之间可以进行对话。</li>
<li>通常把用户在应用程序中点击鼠标或者敲击键盘这样的操作称作 <code>事件</code>（Event）。负责检测事件的是 Windows。**Windows 通过调用应用程序的 WndProc() 函数通知应用程序事件的发生。而应用程序则根据事件的类型做出相应的处理。这种机制就是<code>事件驱动</code>**。</li>
<li>可以说事件驱动也是一种特殊的条件分支，它以从 Windows 送来的通知为条件， 根据通知的内容决定程序下一步的流程。</li>
</ol>
</li>
<li>事件驱动天然适合使用<code>状态模式</code>，因为一旦发送一个事件，程序就会自动执行，从一个状态流转到流转到另一个状态。简单来说：<strong>事件就是引起状态转化的原因</strong>。</li>
</ul>
<p>计算器应用程序的状态转化图</p>
<p><img src="/images/image-20220131213229884.png" alt="image-20220131213229884"></p>
<h2 id="第-5-章-与算法成为好朋友的七个要点"><a href="#第-5-章-与算法成为好朋友的七个要点" class="headerlink" title="第 5 章 与算法成为好朋友的七个要点"></a>第 5 章 与算法成为好朋友的七个要点</h2><h3 id="哨兵的使用"><a href="#哨兵的使用" class="headerlink" title="哨兵的使用"></a>哨兵的使用</h3><ul>
<li><code>哨兵</code> 指的是一种含有特殊值的数据，可用于标识数据的结尾等。</li>
<li>字符串的末尾用 <code>\0</code> 表示，链表的末尾用 -1 表示，像这种特殊的数据就是哨兵。</li>
</ul>
<p>示例：<br>假设有 100 个箱子，里面分别装有 一个写有任意数字的纸条，箱子上面标有 1～100 的序号。现在要从这 100 个箱子当中查找是否有箱子装有写着要查找数字的纸条。</p>
<ul>
<li><p>不使用哨兵：</p>
<p>从第一个箱子开始依次检查每个箱子中的纸条。每检查完一个纸条，还要再检查箱子的编号（用变量 N 表示），并进一步确认编号是否已超过最后一个编号了。</p>
<p><img src="/images/image-20220131215040120.png" alt="image-20220131215040120"></p>
</li>
<li><p>使用哨兵：</p>
<p>添加了一个 101 号箱子，其中预先放入的纸条上写有正要查找的数字。这种数据就被称为“哨兵”。 通过放入哨兵，就一定能找到要找的数据了。找到要找的数据后，如 果该箱子的编号还没有到 101 就意味着找到了实际的数据；如果该箱子 的编号是 101，则意味着找到的是哨兵，而没有找到实际的数据。</p>
<p><img src="/images/image-20220131215237619.png" alt="image-20220131215237619"></p>
</li>
<li><p>哨兵的功能就是：不必每回都要检查箱子的编号有没有到 100。</p>
</li>
</ul>
<h2 id="第-6-章-与数据结构成为好朋友-的七个要点"><a href="#第-6-章-与数据结构成为好朋友-的七个要点" class="headerlink" title="第 6 章 与数据结构成为好朋友 的七个要点"></a>第 6 章 与数据结构成为好朋友 的七个要点</h2><p>无 </p>
<h2 id="第-7-章-成为会使用面向对象编程的-程序员吧"><a href="#第-7-章-成为会使用面向对象编程的-程序员吧" class="headerlink" title="第 7 章 成为会使用面向对象编程的 程序员吧"></a>第 7 章 成为会使用面向对象编程的 程序员吧</h2><p>无</p>
<h2 id="第-8-章-一用就会的数据库"><a href="#第-8-章-一用就会的数据库" class="headerlink" title="第 8 章 一用就会的数据库"></a>第 8 章 一用就会的数据库</h2><p>无</p>
<h2 id="第-9-章-通过七个简单的实验理解-TCP-IP-网络"><a href="#第-9-章-通过七个简单的实验理解-TCP-IP-网络" class="headerlink" title="第 9 章 通过七个简单的实验理解 TCP/IP 网络"></a>第 9 章 通过七个简单的实验理解 TCP/IP 网络</h2><h3 id="FQDN-是什么"><a href="#FQDN-是什么" class="headerlink" title="FQDN 是什么"></a>FQDN 是什么</h3><ul>
<li>FQDN 为 <code>全域名</code>，（FQDN，Fully Qualified Domain Name）是指<strong>主机名加上全路径</strong>，全路径中列出了序列中所有域成员。</li>
<li>全域名可以从逻辑上准确地表示出主机在什么地方，也可以说全域名是主机名的一种完全表示形式。从全域名中包含的信息可以看出主机在域名树中的位置。例如，acmecompany 公司的 Web 服务器的全域名可以是 <a target="_blank" rel="noopener" href="http://www.acmecompany.com,而若/">www.acmecompany.com，而若</a> WWW 主机是在销售部子域，则它的全域名可以是 <a target="_blank" rel="noopener" href="http://www.sales.acmecompany.com/">www.sales.acmecompany.com</a> 。当给出的名字像 acmecompany 而不是 acmecompany. 时，他们通常是指主机名，而名字中带有句点的则认为是全域名。这种区别在理解和控制解析过程时是非常重要的。句点实际上指出了域名树的根。</li>
<li>全域名在实际中是非常有用的。电子邮件就使用全域名作为收信人的电子邮件地址，如 <a href="mailto:&#106;&#x61;&#110;&#105;&#x63;&#x65;&#x6a;&#x6f;&#x6e;&#101;&#115;&#x40;&#97;&#x63;&#109;&#x65;&#x63;&#111;&#109;&#112;&#x61;&#110;&#121;&#x2e;&#99;&#x6f;&#109;">&#106;&#x61;&#110;&#105;&#x63;&#x65;&#x6a;&#x6f;&#x6e;&#101;&#115;&#x40;&#97;&#x63;&#109;&#x65;&#x63;&#111;&#109;&#112;&#x61;&#110;&#121;&#x2e;&#99;&#x6f;&#109;</a>，其中收信人为 janicejones，跟在收信人名字后面是符号 @，@后面是邮件服务器的全域名，或者说是邮件服务器所在企业的域名，最后是顶层域名.com。. com 意味着 acmecompany 是一个商业机构。</li>
</ul>
<h2 id="第-10-章-试着加密数据吧"><a href="#第-10-章-试着加密数据吧" class="headerlink" title="第 10 章 试着加密数据吧"></a>第 10 章 试着加密数据吧</h2><p>无</p>
<h2 id="第-11-章-XML-究竟是什么"><a href="#第-11-章-XML-究竟是什么" class="headerlink" title="第 11 章 XML 究竟是什么"></a>第 11 章 XML 究竟是什么</h2><p>无</p>
<h2 id="第-12-章-SE-负责监管计算机系统-的构建"><a href="#第-12-章-SE-负责监管计算机系统-的构建" class="headerlink" title="第 12 章 SE 负责监管计算机系统 的构建"></a>第 12 章 SE 负责监管计算机系统 的构建</h2><p>SE 是 System Engineer（系统工程师）的缩略语。</p>
<h3 id="瀑布模型中的-7-个阶段"><a href="#瀑布模型中的-7-个阶段" class="headerlink" title="瀑布模型中的 7 个阶段"></a>瀑布模型中的 7 个阶段</h3><p><img src="/images/image-20220203171700359.png" alt="image-20220203171700359"></p>
<p>本身就是过年的时候瞎看的，抱着完全学不到东西的心态看的。实际上也没有学到什么东西。</p>
<p>FIN</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>