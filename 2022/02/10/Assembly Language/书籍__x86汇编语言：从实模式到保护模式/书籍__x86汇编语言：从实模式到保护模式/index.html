<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第-0-章-实模式和保护模式简介&quot;&gt;&lt;a href=&quot;#第-0-章-实模式和保护模式简介&quot; class=&quot;headerlink&quot; title=&quot;第 0 章 实模式和保护模式简介&quot;&gt;&lt;/a&gt;第 0 章 实模式和保护模式简介&lt;/h1&gt;&lt;h2 id=&quot;CPU-的工作模式&quot;&gt;&lt;a href=&quot;#CPU-的工作模式&quot; class=&quot;headerlink&quot; title=&quot;CPU 的工作模式&quot;&gt;&lt;/a&gt;CPU 的工作模式&lt;/h2&gt;&lt;p&gt;&lt;code&gt;实模式&lt;/code&gt;和&lt;code&gt;保护模式&lt;/code&gt;都是 CPU 的工作模式，而 CPU 的工作模式是指 &lt;strong&gt;CPU 的寻址方式&lt;/strong&gt;、寄存器大小等用来反映 CPU 在该环境下如何工作的概念。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>x86汇编语言：从实模式到保护模式 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Assembly-Language/" rel="tag">Assembly Language</a></div><div class="post-time">2022-02-10</div></div></div><div class="container post-header"><h1>x86汇编语言：从实模式到保护模式</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-0-%E7%AB%A0-%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">第 0 章 实模式和保护模式简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">CPU 的工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">实模式工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">保护模式工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">第 1 章 十六进制计数法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E5%86%85%E5%AD%98%E5%92%8C%E6%8C%87%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">第 2 章 处理器、内存和指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E5%8E%9F"><span class="toc-number">3.0.1.</span> <span class="toc-text">处理器进行数学运算的简单原</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%AD%97%EF%BC%88double-word%EF%BC%89"><span class="toc-number">3.0.2.</span> <span class="toc-text">双字（double word）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E5%A4%9A%E5%AD%97%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98"><span class="toc-number">3.0.3.</span> <span class="toc-text">处理器多字访问内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8086-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.0.4.</span> <span class="toc-text">8086 的内存分段机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8086-%E6%8C%87%E4%BB%A4%E9%A2%84%E5%8F%96%E9%98%9F%E5%88%97"><span class="toc-number">3.0.5.</span> <span class="toc-text">8086 指令预取队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%92%8C%E6%B1%87%E7%BC%96%E8%BD%AF%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">第 3 章 汇编语言和汇编软件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">第 4 章 虚拟机的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">计算机的启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8A%A0%E7%94%B5%E5%92%8C%E5%A4%8D%E4%BD%8D"><span class="toc-number">5.1.1.</span> <span class="toc-text">计算机的加电和复位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.1.2.</span> <span class="toc-text">基本输入输出系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">硬盘及其工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA"><span class="toc-number">5.3.</span> <span class="toc-text">主引导扇区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E7%BC%96%E5%86%99%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">第 5 章 编写主引导扇区代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">计算机启动顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%8D%A1%E5%92%8C%E6%98%BE%E5%AD%98"><span class="toc-number">6.2.</span> <span class="toc-text">显卡和显存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%98%BE%E5%AD%98"><span class="toc-number">6.3.</span> <span class="toc-text">访问显存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%A0%87%E5%8F%B7%E7%9A%84%E6%B1%87%E7%BC%96%E5%9C%B0%E5%9D%80"><span class="toc-number">6.4.</span> <span class="toc-text">显示标号的汇编地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">第 6 章 相同的功能，不同的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NASM-%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84-%E5%92%8C-%E6%A0%87%E8%AE%B0"><span class="toc-number">7.1.</span> <span class="toc-text">NASM 编译器的$和$$标记</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E6%AF%94%E9%AB%98%E6%96%AF%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">8.</span> <span class="toc-text">第 7 章 比高斯更快的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">寻址方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-8-%E7%AB%A0-%E7%A1%AC%E7%9B%98%E5%92%8C%E6%98%BE%E5%8D%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">第 8 章 硬盘和显卡的访问与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">用户程序的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%A4%B4%E9%83%A8"><span class="toc-number">9.2.</span> <span class="toc-text">用户程序头部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%85%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.3.</span> <span class="toc-text">外围设备及其接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E7%AB%AF%E5%8F%A3%E5%92%8C%E7%AB%AF%E5%8F%A3%E8%AE%BF%E9%97%AE"><span class="toc-number">9.4.</span> <span class="toc-text">I&#x2F;O 端口和端口访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%A1%AC%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%AF%BB%E6%89%87%E5%8C%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">9.5.</span> <span class="toc-text">通过硬盘控制器端口读扇区数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LBA28-%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8C%E4%BB%8E%E7%A1%AC%E7%9B%98%E4%B8%8A%E8%AF%BB%E9%80%BB%E8%BE%91%E6%89%87%E5%8C%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">9.5.1.</span> <span class="toc-text">LBA28 模式下，从硬盘上读逻辑扇区的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%EF%BC%88%E5%99%A8%EF%BC%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">9.6.</span> <span class="toc-text">加载程序（器）的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%86%B3%E5%AE%9A%E5%8A%A0%E8%BD%BD%E4%BD%8D%E7%BD%AE"><span class="toc-number">9.6.1.</span> <span class="toc-text">初始化和决定加载位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.6.2.</span> <span class="toc-text">准备加载用户程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">9.6.3.</span> <span class="toc-text">过程调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.6.4.</span> <span class="toc-text">加载用户程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">9.6.5.</span> <span class="toc-text">用户程序重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%8E%A7%E5%88%B6%E6%9D%83%E4%BA%A4%E7%BB%99%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.6.6.</span> <span class="toc-text">将控制权交给用户程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">9.7.</span> <span class="toc-text">用户程序的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%A0%88%E5%88%87%E6%8D%A2"><span class="toc-number">9.7.1.</span> <span class="toc-text">初始化段寄存器和栈切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%BE%E7%A4%BA%E4%BE%8B%E7%A8%8B"><span class="toc-number">9.7.2.</span> <span class="toc-text">调用字符串显示例程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F%E6%98%BE%E7%A4%BA"><span class="toc-number">10.</span> <span class="toc-text">第 9 章 中断和动态时钟显示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">10.1.</span> <span class="toc-text">外部硬件中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">10.2.</span> <span class="toc-text">中断向量表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E3%80%81CMOS-RAM-%E5%92%8CBCD-%E7%BC%96%E7%A0%81"><span class="toc-number">10.3.</span> <span class="toc-text">实时时钟、CMOS RAM 和BCD 编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">10.4.</span> <span class="toc-text">内部中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">10.5.</span> <span class="toc-text">软中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIOS-%E4%B8%AD%E6%96%AD"><span class="toc-number">10.6.</span> <span class="toc-text">BIOS 中断</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="第-0-章-实模式和保护模式简介"><a href="#第-0-章-实模式和保护模式简介" class="headerlink" title="第 0 章 实模式和保护模式简介"></a>第 0 章 实模式和保护模式简介</h1><h2 id="CPU-的工作模式"><a href="#CPU-的工作模式" class="headerlink" title="CPU 的工作模式"></a>CPU 的工作模式</h2><p><code>实模式</code>和<code>保护模式</code>都是 CPU 的工作模式，而 CPU 的工作模式是指 <strong>CPU 的寻址方式</strong>、寄存器大小等用来反映 CPU 在该环境下如何工作的概念。</p>
<h2 id="实模式工作原理"><a href="#实模式工作原理" class="headerlink" title="实模式工作原理"></a>实模式工作原理</h2><ul>
<li>实模式出现于早期 8088CPU 时期。当时由于 CPU 的性能有限，一共只有 20 位地址线（所以地址空间只有 1MB），以及 8 个 16 位的通用寄存器，以及 4 个 16 位的段寄存器。</li>
<li>所以为了能够通过这些 16 位的寄存器去构成 20 位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：<code>(段基址：段偏移量)</code>。</li>
<li>其中第一个字段是段基址，它的值是由<strong>段寄存器</strong>提供的，第二字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的偏移。它的值就是由通用寄存器来提供的。</li>
<li>实模式的 “实” 更多地体现在<strong>其地址是真实的物理地址</strong>。</li>
</ul>
<h2 id="保护模式工作原理"><a href="#保护模式工作原理" class="headerlink" title="保护模式工作原理"></a>保护模式工作原理</h2><ul>
<li><p>随着 CPU 的发展，CPU 的地址线的个数也从原来的 20 根变为 32 根，所以可以访问的内存空间也从 1MB 变为现在 4GB，<strong>寄存器的位数也变为 32 位</strong>。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大空间的，更灵活也<strong>更安全</strong>的内存访问。</p>
</li>
<li><p>在保护模式下，CPU 的 32 条地址线全部有效，可寻址高达 4G 字节的物理地址空间；但是我们的内存寻址方式还是得兼容老办法，即 (段基址：段偏移量) 的表示方式。当然此时 CPU 中的通用寄存器都要换成 32 位寄存器 (除了段寄存器) 来保证寄存器能访问所有的 4GB 空间。</p>
</li>
<li><p>在保护模式下，地址的表示方式与实模式是一样的，都是<code>段基址 : 段内偏移</code>。不过，保护模式下<code>段</code>的概念发生了根本性的改变。实模式下的段值可以看作是地址的一部分，可直接参与转换计算。而保护模式下的段值（尽管仍然由原来的段寄存器表示）变成了一个索引（准确来说是 16 位的段选择子 / 段标识符 Selector，前 13 位为索引信息，后 3 位是硬件信息），指向了一个数据结构的一个表项（段表项），表项中详细定义了<code>段基址</code>、<code>界限</code>、<code>属性（权限）</code>等内容。这个数据结构是 <code>全局描述符表 (GDT)</code> 。它<strong>存放关于某个运行在内存中的程序的分段信息的，比如某个程序的代码段是从哪里开始，有多大；数据段又是从哪里开始，有多大</strong>。</p>
</li>
<li><p>全局描述符表中含有一个个表项，每一个表项称为 <code>段描述符</code>。而段寄存器在保护模式下存放的便是相当于一个数组索引的东西，通过这个索引，可以找到对应的表项。段描述符存放了段基址、段界限、内存段类型属性 (比如是数据段还是代码段，注意<strong>一个段描述符只能用来定义一个内存段</strong>) 等许多属性，段描述符格式具体信息见下图：</p>
<p><img src="/images/v2-1a08d48367745c2870e8818b7881b373_1440w.jpg" alt="img"></p>
</li>
<li><p>其中，段界限表示段边界的扩张最值，即最大扩展多少或最小扩展多少，用 20 位来表示，它的单位可以是字节，也可以是 4KB，这是由 G 位决定的 (G 为 1 时表示单位为 4KB)。实际段界限边界值 =(描述符中的段界限 + 1)*（段界限的单位大小 (即字节或 4KB))-1，如果偏移地址超过了段界限，CPU 会抛出异常。全局描述符表位于内存中，需要用专门的寄存器指向它后， CPU 才知道它在哪里。这个专门的寄存器便是 <code>GDTR</code> (一个 48 位的寄存器), 专门用来存储 GDT 的内存地址及大小。</p>
</li>
</ul>
<blockquote>
<p>保护模式有着不同的内存访问机制，简单地说就是传统的涉及段的几个寄存器如 CS,DS,ES,SS 等被解释为不同的内容 —— 实模式解释为段寄存器，保护模式解释为段选择子。</p>
</blockquote>
<blockquote>
<ul>
<li>实模式的缺点：无法支持多任务；程序的安全性无法得到保证。</li>
<li>在保护模式中，除了内存寻址空间大大提高；提供了硬件对多任务的支持；<strong>物理内存地址也不能直接被程序访问，程序内部的地址 (虚拟地址) 要由操作系统转化为物理地址去访问，程序对此一无所知。</strong></li>
<li>至此，进程 (程序的运行态) 有了严格的边界，任何其他进程根本没有办法访问不属于自己的物理内存区域，甚至在自己的虚拟地址范围内也不是可以任意访问的，因为有一些虚拟区域已经被放进一些公共系统运行库。这些区域也不能随便修改，若修改就会有出现 linux 中的段错误，或 Windows 中的非法内存访问对话框。</li>
</ul>
</blockquote>
<h1 id="第-1-章-十六进制计数法"><a href="#第-1-章-十六进制计数法" class="headerlink" title="第 1 章 十六进制计数法"></a>第 1 章 十六进制计数法</h1><p>无</p>
<h1 id="第-2-章-处理器、内存和指令"><a href="#第-2-章-处理器、内存和指令" class="headerlink" title="第 2 章 处理器、内存和指令"></a>第 2 章 处理器、内存和指令</h1><h3 id="处理器进行数学运算的简单原"><a href="#处理器进行数学运算的简单原" class="headerlink" title="处理器进行数学运算的简单原"></a>处理器进行数学运算的简单原</h3><p><img src="/images/image-20220203175006938.png" alt="image-20220203175006938"></p>
<ul>
<li>在处理器的底部或者四周，有大量的引脚，可以接受从外面来的电信号，或者向外发出电信号。</li>
<li>每个引脚都有自己的用处，在往电路板上安装的时候，不能接错。所以，处理器在生产的时候，都会故意缺一个角，这是一个参照标志，可以确保安装的人不会弄错。</li>
<li>处理器的引脚很多，其中有一部分是用来将参与运算的数字送入处理器内部。有些引脚是复用的，假如现在要进行加法运算，那么我们要重复使用这些引脚，来依次将被加数和加数送入。</li>
</ul>
<h3 id="双字（double-word）"><a href="#双字（double-word）" class="headerlink" title="双字（double word）"></a>双字（double word）</h3><p>寄存器数据宽度示意：</p>
<p><img src="/images/image-20220203175729346.png" alt="image-20220203175729346"></p>
<ul>
<li>32 位寄存器可以存放 4 个字节，这称为 1 个双字（double word），各个数位的编号分别是 0～31，其中 0～15 是低字，16～31 是高字。</li>
<li>同理，还有所谓的<code>四字</code>，<code>八字</code>。</li>
</ul>
<h3 id="处理器多字访问内存"><a href="#处理器多字访问内存" class="headerlink" title="处理器多字访问内存"></a>处理器多字访问内存</h3><p>经过精心的设计和安排，处理器能够按字节、字、双字和四字进行访问。换句话说，仅通过单次访问就能处理8 位、16 位、32 位或者64 位的二进制数。</p>
<blockquote>
<p>注意，是单次访问，而不是一个一个地取出每个字节，然后加以组合。</p>
</blockquote>
<p><img src="/images/image-20220203180323911.png" alt="image-20220203180323911"></p>
<p>处理器发出字长控制信号，以指示本次访问的字长是 8、16、32 还是 64 。如果字长是 8，而且给出的地址是 0002H，那么，本次访问只会影响到内存的一字节；<strong>如果字长是 16，给出的地址依然是 0002H，那么实际访问的将是地址 0002H 处的一个字</strong>，低 8 位在0002H 中，高 8 位在 0003H 中。</p>
<blockquote>
<p>这里可以联系<code>大小端存储</code>知识点，正是因为处理器支持<strong>多字访问内存</strong>，才方便各个硬件厂商使用大端/小端存储。</p>
</blockquote>
<h3 id="8086-的内存分段机制"><a href="#8086-的内存分段机制" class="headerlink" title="8086 的内存分段机制"></a>8086 的内存分段机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[0]</span><br></pre></td></tr></table></figure>

<ul>
<li>如上，这里会将<code>1000:0</code>处存放的字型数据送入ax。</li>
<li>这里其实使用了 8086 的 <code>内存分段机制</code>，也就是：一个内存单元的地址实际上就可以用 <strong>段地址：偏移地址</strong> 来表示。</li>
<li>8086 的这种分段机制其实就是一种逻辑地址。这是 8086 为了解决 <code>物理地址变动</code> 的问题。</li>
<li>大多数时候，整个程序（包括代码段和数据段）在内存中的位置并不是我们能够决定的。你所运行的程序，在内存中被加载的位置完全是随机的。所以，我们不能使用绝对内存地址（物理地址）。为了程序能在内存中的任何地方正确执行，就只能在编写程序的时候使用相对地址或者逻辑地址了，当程序加载时，这些相对地址还要根据程序实际被加载的位置重新计算。</li>
<li>为了在硬件一级提供对“段地址：偏移地址”内存访问模式的支持，处理器至少要提供两个段寄存器，分别是代码段寄存器（Code Segment， CS）和数据段寄存器（Data Segment，DS）。对 CS 内容的改变将导致处理器从新的代码段开始执行。同样，在开始访问内存中的数据之前，也必须首先设置好 DS 寄存器，使之指向数据段。</li>
<li>当处理器访问内存时，它把指令中指定的内存地址看成是段内的偏移地址，而不是物理地址。这样，一旦处理器遇到一条访问内存的指令，它将把 DS 中的数据段起始地址和指令中提供的段内偏移相加，来得到访问内存所需要的物理地址。</li>
<li>所以，如果下次要执行程序时，代码段和数据段在内存中的位置就会发生变化，此时<strong>只要把它们的段地址分别传送到 CS 和 DS，就能够正确执行</strong>。</li>
</ul>
<h3 id="8086-指令预取队列"><a href="#8086-指令预取队列" class="headerlink" title="8086 指令预取队列"></a>8086 指令预取队列</h3><p>8086 处理器内部组成框图：</p>
<p><img src="/images/image-20220203193308489.png" alt="image-20220203193308489"></p>
<ul>
<li><code>数据暂存器</code>： 其实也是一种寄存器。</li>
<li>处理器能够自动运行，这是控制器的功劳。为了加快指令执行速度，8086 内部有一个 6 字节的 <code>指令预取队列</code>，在处理器忙着执行那些不需要访问内存的指令时，指令预取部件可以趁机访问内存预取指令。这时，多达 6 个字节的指令流可以排队等待解码和执行。</li>
</ul>
<h1 id="第-3-章-汇编语言和汇编软件"><a href="#第-3-章-汇编语言和汇编软件" class="headerlink" title="第 3 章 汇编语言和汇编软件"></a>第 3 章 汇编语言和汇编软件</h1><p>无</p>
<h1 id="第-4-章-虚拟机的安装和使用"><a href="#第-4-章-虚拟机的安装和使用" class="headerlink" title="第 4 章 虚拟机的安装和使用"></a>第 4 章 虚拟机的安装和使用</h1><p>每种操作系统都对它所管理的程序提出了种种格式上的要求。比如，它要求编译好的程序必须在文件的开始部分包含编译日期，是针对哪种操作系统编译的，程序的版本，第一条指令从哪里开始，数据段从哪里开始、有多长，代码段从哪里开始、有多长等等。</p>
<h2 id="计算机的启动过程"><a href="#计算机的启动过程" class="headerlink" title="计算机的启动过程"></a>计算机的启动过程</h2><h3 id="计算机的加电和复位"><a href="#计算机的加电和复位" class="headerlink" title="计算机的加电和复位"></a>计算机的加电和复位</h3><p>在处理器众多的引脚中，有一个是 <code>RESET</code>，用于接受复位信号。每当处理器加电，或者 RESET 引脚的电平由低变高时处理器都会执行一个 <code>硬件初始化</code>，以及一个可选的内部自测试（Build-in Self-Test， BIST），然后将内部所有寄存器的内容初始到一个预置的状态。</p>
<blockquote>
<ul>
<li>比如，当你按下主机箱面板上的 RESET 按钮时，就会导致 RESET 引脚电平的变化，从而使计算机热启动。</li>
<li>对于 8086 来说，复位将使代码段寄存器（CS）的内容为 0xFFFF，其他所有寄存器的内容都为 0x0000，包括指令指针寄存器（IP）。</li>
</ul>
</blockquote>
<h3 id="基本输入输出系统"><a href="#基本输入输出系统" class="headerlink" title="基本输入输出系统"></a>基本输入输出系统</h3><ul>
<li>8086 有 20 根地址线，但并非全都用来访问 DRAM，也就是内存条。 事实上，这些地址线经过分配，大部分（00000-9FFFF）用于访问 DRAM，剩余的部分（F0000-FFFFF）给了只读存储器 ROM 和外围的板卡。</li>
<li>8086 中，ROM 占据着整个内存空间顶端的 64KB，物理地址范围是 0xF0000～0xFFFFF，里面固化了开机时要执行的指令；DRAM 占据着较低端的 640KB，地址范围是 0x00000～0x9FFFF；中间还有一部分，分给了其他外围设备。</li>
<li>8086 加电或者复位时，CS=0xFFFF，IP=0x0000，所以它取的第一条指令位于物理地址 0xFFFF0，正好位于 ROM 中，那里固化了开机时需要执行的指令。0xFFFF0 离 1MB 内存的顶端（0xFFFFF）只有16 个字节的长度，一旦 IP 寄存器的值超过 0x000F，那么，它与 CS 一起形成的物理地址将溢出，这将回绕到内存的最低端。所以，<strong>ROM 中位于物理地址 0xFFFF0 的地方，通常是一个跳转指令</strong>。</li>
</ul>
<h2 id="硬盘及其工作原理"><a href="#硬盘及其工作原理" class="headerlink" title="硬盘及其工作原理"></a>硬盘及其工作原理</h2><p>硬盘的结构示意图：</p>
<p><img src="/images/image-20220208113801033.png" alt="image-20220208113801033"></p>
<ul>
<li><p>每个盘片都有两个磁头（Head），上面一个，下面一个，所以经常用磁头来指代盘面。</p>
</li>
<li><p>磁头都有编号，第 1 个盘片，上面的磁头编号为 0， 下面的磁头编号为 1；第 2 个盘片，上面的磁头编号为 2，下面的磁头编 号为 3，以此类推。</p>
</li>
<li><p>磁道，或者柱面，也要编号。编号是从盘面<strong>最边缘的那条磁道开始，向着圆心的方向</strong>，从 0 开始编号。</p>
<blockquote>
<p>为了加速数据在硬盘上的读写，尽量不移动磁头。这样，当 0 面的磁道不足以容纳要写入的数据时，应当把剩余的部分写在 1 面的同一磁道上。如果还写不下，那就继续把剩余的部分写在 2 面 的同一磁道上。换句话说，<strong>在硬盘上，数据的访问是以柱面来组织的</strong>。</p>
</blockquote>
</li>
<li><p>每条磁道能够划分为几个扇区，每个扇区都有一个编号，与磁头和磁道不同，<strong>扇区的编号是从 1 开始的</strong>。</p>
<blockquote>
<ul>
<li>扇区与扇区之间<strong>以间隙（空白）间隔开来</strong>，每个扇区以扇区头开始，然后是 512 个字节的数据区。</li>
<li>扇区头包含了每个扇区自己的信息， 主要有本扇区的磁道号、磁头号和扇区号，用来供硬盘定位机构使用。</li>
<li>现代的硬盘还会在扇区头部包括一个指示扇区是否健康的标志，以及用来替换该扇区的扇区地址。用于替换扇区的，是一些保留和隐藏的磁道。</li>
</ul>
</blockquote>
</li>
<li><p>采用磁头、磁道和扇区这种模式来访问硬盘的方法称为 CHS 模式， 但不是很方便。想想看，如果有一大堆数据要写，还得注意磁头号、磁道号和扇区号不要超过界限。所以，后来引入了逻辑块地址（Logical Block Address，LBA）的概念。现在市场上销售的硬盘，无论是哪个厂家生产的，都支持 LBA 模式。</p>
<blockquote>
<ul>
<li>LBA 模式不考虑扇区的物理位置（磁头号、磁道号），而是把它们全部组织起来统一编号。在这种编址方式下，原先的物理扇区被组织成逻辑扇区，且都有唯一的逻辑扇区号。</li>
<li>比如，某硬盘有 6 个磁头，每面有 1000 个磁道，每磁道有 17 个扇 区。那么： <ul>
<li>逻辑 0 扇区对应着 0 面 0 道 1 扇区； </li>
<li>逻辑 1 扇区对应着 0 面 0 道 2 扇区；</li>
<li>逻辑 16 扇区对应着 0 面 0 道 17 扇区； </li>
<li><strong>逻辑 17 扇区对应着 1 面 0 道 1 扇区</strong>； </li>
<li>逻辑 18 扇区对应着 1 面 0 道 2 扇区；</li>
</ul>
</li>
<li><strong>扇区在编号时，是以柱面为单位的</strong>。即，先是 0 面 0 道， 接着是 1 面 0 道，直到把所有盘面上的 0 磁道处理完，再接着处理下一个柱面。之所以这样做，是因为我们讲过，要加速硬盘的访问速度，最好是尽可能不移动磁头。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h2><ul>
<li><strong>硬盘的第一个扇区是 0 面 0 道 1 扇区</strong>，或者说是 0 头 0 柱 1 扇区，这个扇区称为 <code>主引导扇区</code>。</li>
<li>如果计算机的设置是从硬盘启动，那么，ROM-BIOS 将读取硬盘主引导扇区的内容，将它加载到内存地址 0x0000:0x7c00 处（也就是物理地址0x07C00），然后用指令 <code>jmp 0x0000:0x7c00</code> 跳到那里执行。</li>
<li>主引导扇区的功能是继续从硬盘的其他部分读取更多的内容加以执行。像 Windows 这样的操作系统，就是采用这种接力的方法一步一步把自己运行起来的。</li>
</ul>
<h1 id="第-5-章-编写主引导扇区代码"><a href="#第-5-章-编写主引导扇区代码" class="headerlink" title="第 5 章 编写主引导扇区代码"></a>第 5 章 编写主引导扇区代码</h1><h2 id="计算机启动顺序"><a href="#计算机启动顺序" class="headerlink" title="计算机启动顺序"></a>计算机启动顺序</h2><p>计算机启动顺序：</p>
<ol>
<li>上电</li>
<li>读取 ROM 里面的 BIOS，用来检查硬件（Power On Self Test）</li>
<li>硬件检查通过</li>
<li><strong>BIOS 根据指定的顺序，检查引导设备的第一个扇区（即主引导记录），将这个扇区加载在内存地址 0x7c00 处</strong></li>
<li>主引导记录把操作权交给操作系统</li>
</ol>
<ul>
<li>处理器加电或者复位之后， 如果硬盘是首选的启动设备，那么，ROM-BIOS 将试图读取硬盘的 0 面 0 道 1 扇区。传统上，这就是 <code>主引导扇区</code>（Main Boot Sector，MBR）。</li>
<li>读取的主引导扇区数据有 512 字节，ROM-BIOS 程序将它加载到逻辑地址 0x0000:0x7c00 处，也就是物理地址 0x07c00 处，然后判断它是否有效。</li>
<li>一个有效的主引导扇区，其最后两字节应当是 0x55 和 0xAA。ROMBIOS 程序首先检测这两个标志，如果主引导扇区有效，则以一个段间转移指令 <code>jmp 0x0000:0x7c00</code> 跳到那里继续执行。</li>
<li>主引导扇区是由操作系统负责的。它把操作系统的自举代码加载到内存，也用 jmp 指令跳转到那里继续执行，直到操作系统完全启动。</li>
</ul>
<h2 id="显卡和显存"><a href="#显卡和显存" class="headerlink" title="显卡和显存"></a>显卡和显存</h2><ul>
<li><p>为了显示文字，通常需要两种硬件，一是<code>显示器</code>，二是<code>显卡</code>。</p>
<ul>
<li>显卡的职责是为显示器提供内容，并控制显示器的显示模式和状态，</li>
<li>显示器的职责是将那些内容以视觉可见的方式呈现在屏幕上。</li>
</ul>
</li>
<li><p>显卡都有自己的存储器，因为它位于显卡上，故称显示存储器（Video RAM：VRAM），简称<code>显存</code>，要显示的内容都预先写入显存。</p>
</li>
<li><p>显卡的工作是周期性地从显存中提取比特，并把它们按顺序显示在屏幕上。现在最流行的，是用 24 个比特，即 3 个字节，来对应一个像素 。</p>
</li>
<li><p>在不同的工作模式下，显卡对显存内容的解释是不同的。显卡的两种基本工作模式如下：</p>
<ul>
<li><code>文本模式</code></li>
<li><code>图形模式</code></li>
</ul>
<p><img src="/images/image-20220208140654063.png" alt="image-20220208140654063"></p>
</li>
<li><p>因为显示功能对于现代计算机来说实在是太重要了。8086 处理器中，0xA0000～0xEFFFF 这段地址空间由特定的外围设备来提供，其中就包括显卡。一直以来，0xB8000～0xBFFFF 这段物理地址空间，是留给显卡的。</p>
<p><strong>文本模式下显存到内存的映射</strong>如下：</p>
<p><img src="/images/image-20220208141112124.png" alt="image-20220208141112124"></p>
</li>
</ul>
<h2 id="访问显存"><a href="#访问显存" class="headerlink" title="访问显存"></a>访问显存</h2><ul>
<li><p>和访问主内存一样，为了访问显存，也需要使用逻辑地址，也就是 采用“段地址：偏移地址”的形式。</p>
</li>
<li><p>考虑到<strong>文本模式下</strong>显存的起始物理地址是0xB8000，这块内存可以看成是段地址为 0xB800。</p>
</li>
<li><p>屏幕上的每个字符对应着显存中的两个连续字节，前一个是字符的 ASCII 代码，后面是字符的显示属性，包括字符颜色（前景色）和底色 （背景色）。</p>
<blockquote>
<ul>
<li>Eg：字符“H”的 ASCII 代码是 0x48 ，其显示属性是 0x07；字符“e”的 ASCII 代码是 0x65，其显示属性是 0x07。</li>
<li>K 是闪烁位，为 0 时不闪烁，为 1 时闪烁；I 是亮度位， 为 0 时正常亮度，为 1 时呈高亮。</li>
<li>所以，字符属性 0x07 可以解释为黑底白字，无闪烁，无加亮。</li>
</ul>
<p><img src="/images/image-20220208142127968.png" alt="image-20220208142127968"></p>
<p><img src="/images/image-20220208142257464.png" alt="image-20220208142257464"></p>
</blockquote>
<blockquote>
<p>当屏幕上一片漆黑，什么内容都没有的时候，显 存里会是什么内容呢？实际上，这个时候，<strong>屏幕上显示的全是黑底白字的空格字符</strong>。</p>
</blockquote>
</li>
<li><p>eg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0xb800  ;指向文本模式的显示缓冲区</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">;显示字符串&quot;La&quot;</span><br><span class="line">mov byte [es:0x00],&#x27;L&#x27;</span><br><span class="line">mov byte [es:0x01],0x07</span><br><span class="line">mov byte [es:0x02],&#x27;a&#x27;</span><br><span class="line">mov byte [es:0x03],0x07</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="显示标号的汇编地址"><a href="#显示标号的汇编地址" class="headerlink" title="显示标号的汇编地址"></a>显示标号的汇编地址</h2><ul>
<li><p>处理器访问内存时，采用的是“段地址：偏移地址”的模式。为了支持这种内存访问模式，在源程序的编译阶段，编译器会把源程序整体上作为一个独立的段来处理，并<strong>从 0 开始计算和跟踪每一条指令的地址</strong>。因为该地址是在编译期间计算的，故称为<code>汇编地址 </code>。</p>
</li>
<li><p>在源程序编译期间，<strong>汇编地址指示该指令相对于程序或者段起始处的距离</strong>， 以字节计。当编译后的程序装入物理内存后，因为程序是整体加载入内存的，所以汇编地址又是该指令在内存段内的偏移地址。</p>
</li>
<li><p>对于指令<code>infi: jmp near infi</code>，行首带冒号的是标号是“infi”。假设这条指令的汇编地址是 0x0000012B， 故 infi 就代表数值 0x0000012B，或者说 <strong>infi 是 0x0000012B 的符号化表示</strong>。</p>
<blockquote>
<ul>
<li>实际上，这是一个 3 字节指令，操作码是 0xE9，后跟一个 16 位（两字节）的操作数。但是，该操作数并非目标位置的偏移地址，而是目标位置相对于当前指令处的<code>偏移量</code>（以字节为单位）。</li>
<li>在编译阶段，编译器是这么做的：用标号（目标位置）处的汇编地址减去当前指令的汇编地址，再减去当前指令的长度（3），就得到了 jmp near infi 指令的实际操作数。</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="第-6-章-相同的功能，不同的代码"><a href="#第-6-章-相同的功能，不同的代码" class="headerlink" title="第 6 章 相同的功能，不同的代码"></a>第 6 章 相同的功能，不同的代码</h1><h2 id="NASM-编译器的-和-标记"><a href="#NASM-编译器的-和-标记" class="headerlink" title="NASM 编译器的$和$$标记"></a>NASM 编译器的$和$$标记</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">times 510-($-$$) db 0</span><br></pre></td></tr></table></figure>

<ul>
<li>NASM 编译器提供了一个标记<code>$</code>，该标记等同于标号，你可以把它看成是一个隐藏在当前行行首的标号。因此，<code>jmp near $</code>的意 是，转移到当前指令继续执行，它和<code>infi: jmp near infi</code>是一样的，没有区别，但不需要使用标号，更不必为给标号起一个有意义的名字而伤脑筋。</li>
<li><code>$$</code>是NASM 编译器提供的另一个标记，代表当前<strong>段的起始汇编地址</strong>。当前程序没有定义节或段，就默认地自成一个汇编段，而且起始的汇编地址是0（程序起始处）。</li>
<li><code>($-$$)</code>： 用当前汇编地址减去程序开头的汇编地址（0），就是程序实体的大小。 </li>
</ul>
<h1 id="第-7-章-比高斯更快的计算"><a href="#第-7-章-比高斯更快的计算" class="headerlink" title="第 7 章 比高斯更快的计算"></a>第 7 章 比高斯更快的计算</h1><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>简单地说，寻址方式就是如何找到要操作的数据，以及如何找到存放操作结果的地方。</p>
<ul>
<li>寄存器寻址</li>
<li>立即数寻址</li>
<li>内存寻址</li>
</ul>
<h1 id="第-8-章-硬盘和显卡的访问与控制"><a href="#第-8-章-硬盘和显卡的访问与控制" class="headerlink" title="第 8 章 硬盘和显卡的访问与控制"></a>第 8 章 硬盘和显卡的访问与控制</h1><h2 id="用户程序的结构"><a href="#用户程序的结构" class="headerlink" title="用户程序的结构"></a>用户程序的结构</h2><ul>
<li><p>处理器的工作模式是<strong>将内存分成逻辑上的段，指令的获取和数据的访问一律按“段地址：偏移地址”的方式进行</strong>。相对应地，一个规范的程序，应当包括代码段、数据段、附加段和栈段。</p>
</li>
<li><p>编译器不关心段的用途，可能也根本不知道段的用途，不知道它是数据段，还是代码段，或是栈段。事实上，这都不重要，<strong>段只用来分隔程序中的不同内容</strong>。</p>
</li>
<li><p>Intel 处理器要求段在内存中的起始物理地址起码是16 字节对齐的。 意思是该物理地址必须能被16 整除。 相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。 具体做法是，在段定义中使用 <code>align=</code> 子句，用于指定某个 SECTION 的汇编地址对齐方式。</p>
<blockquote>
<p>比如说， <code>align=16</code> 就表示段是 16 字节对齐的， <code>align=32</code> 就表示段是 32 字节对齐的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">section data1 align=16</span><br><span class="line">	db 0x55</span><br><span class="line"></span><br><span class="line">section data2 align=16</span><br><span class="line">	db 0xaa</span><br><span class="line">	</span><br><span class="line">section data3 align=16</span><br><span class="line">	db 0x99</span><br></pre></td></tr></table></figure>

<p>注意上面代码，段 data1 的起始汇编地址是 0。地址 0 本身就是 16 字节对齐的，符合 align 子句的要求。段 data2 也要求是 16 字节对齐的。于是，编译器将 0x00000010 作为段 data2 的汇编地址，并在两个段之间填充 15 字节的 0x00（段data1 只有 1 字节的长度）。</p>
</li>
<li><p>每个段都有一个汇编地址，它是相对于整个程序开头（0）的。为了方便取得该段的汇编地址，NASM 编译器可以使用 <code>section.段名称.start</code> 来获取段的汇编地址。</p>
</li>
<li><p>段定义语句还可以包含<code>vstart=c</code>子句。其功能是：引用段内的某个标号时，该标号处的汇编地址是从段的开头处(c)计算的。也就是说：<strong>vstart 指明段内汇编地址起始位置，该段内的汇编的地址都是从 vstart 开始算的</strong>。</p>
<blockquote>
<p>简单来说，<code>vstart=</code>子句影响了<code>段内标号</code>的汇编地址，决定了其是<strong>从程序开始计算</strong>还是<strong>从段内开始计算</strong>。</p>
</blockquote>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECTION mbr align=16 vstart=0x7c00</span><br><span class="line">		mov ax,0</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,ax</span><br><span class="line">@1:</span><br><span class="line">		cmp ax,0</span><br><span class="line">		jz direct</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="用户程序头部"><a href="#用户程序头部" class="headerlink" title="用户程序头部"></a>用户程序头部</h2><ul>
<li><p>加载器在加载用户程序的时候，需要知道用户程序的一些信息，用于知道如何加载该用户程序。约定把这些信息放在用户程序的开头，这就是<code>用户程序头部</code>。</p>
</li>
<li><p>用户程序头部<strong>在源程序以一个段的形式出现</strong>。用户程序头部起码要包含以下信息：</p>
<ul>
<li><code>用户程序的总长度</code>：加载器需要根据这一信息来决定读取多少个逻辑扇区。</li>
<li><code>应用程序的入口点</code>，包括段地址和偏移地址：第一条指令的段地址和偏移地址。</li>
<li><code>段重定位表项数</code>：有多少个需要重定位的段。</li>
<li><code> 段重定位表</code>：用户程序可能包含不止一个段，大程序会包含多个代码段和多个数据段。这些段如何使用，是用户程序自己的 事，程序加载到内存后，每个段的地址必须重新确定一下。</li>
</ul>
<p><img src="/images/image-20220209174758319.png" alt="image-20220209174758319"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code_1.start ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    realloc_tbl_len dw (header_end-code_1_segment)/4 ;段重定位表项个数[0x0a]</span><br><span class="line">    </span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_1_segment  dd section.code_1.start ;[0x0c]</span><br><span class="line">    code_2_segment  dd section.code_2.start ;[0x10]</span><br><span class="line">    data_1_segment  dd section.data_1.start ;[0x14]</span><br><span class="line">    data_2_segment  dd section.data_2.start ;[0x18]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    </span><br><span class="line">    header_end:</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION code_1 align=16 vstart=0         ;定义代码段1（16字节对齐）</span><br><span class="line">	...</span><br><span class="line">  start:</span><br><span class="line">         mov ax,[stack_segment]</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION code_2 align=16 vstart=0 </span><br><span class="line">	...</span><br><span class="line">SECTION data_1 align=16 vstart=0</span><br><span class="line">	...</span><br><span class="line">SECTION data_2 align=16 vstart=0</span><br><span class="line">	...</span><br><span class="line">SECTION stack align=16 vstart=0</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION trail align=16</span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="外围设备及其接口"><a href="#外围设备及其接口" class="headerlink" title="外围设备及其接口"></a>外围设备及其接口</h2><ul>
<li><p>加载器的下一个工作是从硬盘读取用户程序，说白了就是访问其他硬件。</p>
</li>
<li><p><strong>不同的硬件使用不同的 I/O 接口</strong>。USB 键盘使用名为 USB 的 I/O 接口，硬盘使用名为 SATA 的 I/O 接口，声卡使用名为 PCI 的  I/O 接口，等等。</p>
</li>
<li><p>不可能将所有的 I/O 接口直接和处理器相连，设备那么多，还有些设备现在没有发明出来，将来一定会有。怎么办？</p>
<p><strong>采用总线技术</strong>。总线可以认为是一排电线，所有的外围设备，包括处理器，都连接到这排电线上。每个连接到这排电线上的器件都必须有拥有电子开关，使它们随时能够同这排电线连接，或者从这排电线上断开（脱离）。这就好比是公共车道，当路面上有车时，你就必须退避一下，不能硬冲上去。因此，这排公共电线就称为<code>总线</code>。</p>
</li>
<li><p>每个设备的 I/O 接口都抢着和处理器说话，不发生冲突都难。怎么办？</p>
<p>使用<strong>输入输出控制设备集中器（I/O Controller Hub，ICH）芯片</strong>。该芯片的作用是连<strong>接不同的总线，并协调各个 I/O 接口对处理器的访问</strong>。在个人计算机上，这块芯片就是所谓的<code>南桥</code>。</p>
<blockquote>
<p>ICH 内部集成了一些常规的外围设备接口， 如 USB 、PATA（IDE）、SATA、老式总线接口（LPC）、时钟等。</p>
</blockquote>
</li>
<li><p>处理器通过局部总线连接到 ICH 内部的处理接口电路。然后，在 ICH 内部，又通过总线与各个 I/O 接口相连。</p>
<p><img src="/images/image-20220209154009257.png" alt="image-20220209154009257"></p>
</li>
<li><p>当处理器想同某个设备说话时，ICH 会接到通知。然后它负责提供相应的传输通道和其他辅助支持，并命令所有其他无关设备闭嘴。同样，当某个设备要跟处理器说话，情况也是一样。</p>
</li>
</ul>
<h2 id="I-O-端口和端口访问"><a href="#I-O-端口和端口访问" class="headerlink" title="I/O 端口和端口访问"></a>I/O 端口和端口访问</h2><ul>
<li><p>处理器是通过端口（Port）来和外围设备打交道的。<strong>本质上，端口就是一些寄存器</strong>，类似于处理器内部的寄存器。不同之处仅仅 在于，这些叫做端口的寄存器位于 I/O 接口电路中。</p>
</li>
<li><p>每个 I/O 接口都可能拥有好几个端口，分别用于不同的目的。</p>
<blockquote>
<p>比如，连接硬盘的 PATA/SATA 接口就有几个端口，分别是</p>
<ul>
<li>命令端口：当向该端口写入 0x20 时，表明是从硬盘读数据；写入 0x30 时，表明是向硬盘写数据</li>
<li>状态端口：处理器根据这个端口的数据来判断硬盘工作是否正常，操作是否成功，发生了哪种错误</li>
<li>参数端口：处理器通过这些端口告诉硬盘读写的扇区数量，以及起始的逻辑扇区号</li>
<li>数据端口：通过这个端口连续地取得要读出的数据，或者通过这个端口连续地发送要写入硬盘的数据</li>
</ul>
</blockquote>
</li>
<li><p>在一些计算机系统中，<strong>端口号是映射到内存地址空间的</strong>。比如 0xE0001～0xFFFFF 是从很多I/O 接口那里映射过来的，当访问这部分地址时，实际上是在访问 I/O 接口。</p>
</li>
<li><p>在另一些计算机系统中，端口是独立编址的，不和内存发生关系。</p>
<blockquote>
<ul>
<li>在这种计算机中，处理器的地址线既连接内存，也连接每一个I/O 接口。处理器还有一个特殊的引脚<code>M/IO#</code>，<code>#</code>表示低电平有效。</li>
<li>当处理器访问内存时，它会让 <code>M/IO#</code> 引脚呈高电平，此时和内存相关的电路就会打开。</li>
<li>当处理器访问 I/O 端口，那么<code>M/IO#</code>引脚呈低平，内存电路被禁止，同时打开某个I/O 接口。</li>
</ul>
</blockquote>
<p><img src="/images/image-20220209160244147.png" alt="image-20220209160244147"></p>
</li>
<li><p>访问端口：<strong>读取端口只能使用al，ax</strong>。bx，cx都不行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h ; 从60h号端口读入一个字节</span><br></pre></td></tr></table></figure>

<p>执行时与总线相关的操作流程：</p>
<ol>
<li>CPU通过地址线将地址信息60h发出</li>
<li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据</li>
<li>端口所在的芯片将60h端口中的数据通过数据线送入CPU</li>
</ol>
</li>
<li><p>写入端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out 0x37, al  ; 写0x37号端口（这是一个8位端口）</span><br><span class="line">out 0xf5, ax  ; 写0xf5号端口（这是一个16位端口）</span><br><span class="line">out dx, al    ; 这是一个8位端口，端口号在寄存器DX中</span><br><span class="line">out dx, ax    ; 这是一个16位端口，端口号在寄存器DX中</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="通过硬盘控制器端口读扇区数据"><a href="#通过硬盘控制器端口读扇区数据" class="headerlink" title="通过硬盘控制器端口读扇区数据"></a>通过硬盘控制器端口读扇区数据</h2><ul>
<li><strong>硬盘读写的基本单位是扇区</strong>。就是说，要读就至少读一个扇区，要写就至少写一个扇区，不可能仅读写一个扇区中的几个字节。这样一 来，就使得主机和硬盘之间的数据交换是成块的，所以硬盘是典型的块设备。</li>
<li>从硬盘读写数据，最经典的方式是向硬盘控制器分别发送<code>磁头号（Heads）</code>、 <code>柱面号(Cylinder)</code>和<code>扇区号(Sector)</code>，这称为<code>CHS 模式</code>。</li>
<li><code>LBA28 模式</code>：使用逻辑扇区进行访问。使用 28 个比特来表示逻辑扇区号，从逻辑扇区 0x0000000 到 0xFFFFFFF，共可以表示2^28＝268435456 个扇区。每个扇区有 512 字节，所以 LBA28 可以管理 128 GB 的硬盘。</li>
<li><code>LBA48 模式</code>：使用 48 个比特来表示逻辑扇区号，就可以管理 131072 TB 的硬盘容量了。</li>
</ul>
<h3 id="LBA28-模式下，从硬盘上读逻辑扇区的过程"><a href="#LBA28-模式下，从硬盘上读逻辑扇区的过程" class="headerlink" title="LBA28 模式下，从硬盘上读逻辑扇区的过程"></a>LBA28 模式下，从硬盘上读逻辑扇区的过程</h3><p>LBA28 模式下，从硬盘上读逻辑扇区的过程如下：</p>
<ol>
<li><p><strong>设置要读取的扇区数量</strong>。</p>
<p>这个数值要写入0x1f2 端口。这是 个8 位端口，因此每次只能读写255 个扇区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 0x1f2</span><br><span class="line">mov al, 0x01  ; 读取1个扇区</span><br><span class="line">out dx, al</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果写入的值为 0，则表示要读取 256 个扇区。每读一个扇区，这个数值就减一。因此，如果在读写过程中发生错误，该端口包含着尚未读取的扇区数。</p>
</blockquote>
</li>
<li><p><strong>设置起始LBA 扇区号</strong>。</p>
<ul>
<li><p>扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。</p>
</li>
<li><p>28 位的扇区号太长，需要将其分成4 段，分别写入端口0x1f3、0x1f4、0x1f5 和0x1f6 号端口。</p>
<ul>
<li>0x1f3 号端口存放的是 0～7 位</li>
<li>0x1f4 号端口存放的是 8～15 位</li>
<li>0x1f5 号端口存放的是 16～23 位</li>
<li>0x1f6 号端口存放的是 24～27 位</li>
</ul>
</li>
<li><p>假定我们要读写的起始逻辑扇区号为0x02</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 0x1f3</span><br><span class="line">mov al, 0x02</span><br><span class="line">out dx, al     ;LBA地址7～0</span><br><span class="line"></span><br><span class="line">inc dx         ;0x1f4</span><br><span class="line">mov al, 0x00</span><br><span class="line">out dx, al     ;LBA地址15～8</span><br><span class="line"></span><br><span class="line">inc dx         ;0x1f5</span><br><span class="line">out dx, al     ;LBA地址23～16</span><br><span class="line"></span><br><span class="line">inc dx         ;0x1f6</span><br><span class="line">mov al, 0xe0   ;LBA模式，主硬盘，以及LBA地址27～14</span><br><span class="line">out dx, al</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在现行的体系下，每个PATA/SATA 接口允许挂接两块硬盘，分别是主盘（Master）和从盘（Slave）</li>
<li>0x1f6 端口的低 4 位用于存放逻辑扇区号的24～27位，</li>
<li>第 4 位用于指示硬盘号，0 表示主盘，1 表示从盘。</li>
<li>高 3 位是“111”，表示 LBA 模式。</li>
</ul>
<p><img src="/images/image-20220209163506361.png" alt="image-20220209163506361"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>向端口 0x1f7 写入 0x20</strong>，请求硬盘读。</p>
<p>这也是一个 8 位端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 0x1f7</span><br><span class="line">mov al, 0x20</span><br><span class="line">out dx, al</span><br></pre></td></tr></table></figure></li>
<li><p><strong>等待读写操作完成</strong>。</p>
<ul>
<li><p>端口 0x1f7 既是命令端口，又是状态端口。在通过这个端口发送读写命令之后，硬盘就忙乎开了。在它内部操作期间，它将0x1f7 端口的第7位置“1”，表明自己很忙。 一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3位置“1”，意思是准备好了，请求主机发送或者接收数据。</p>
</li>
<li><p>端口 0x1f7 部分状态位的含义：</p>
<p><img src="/images/image-20220209164410414.png" alt="image-20220209164410414"></p>
</li>
<li><p>计算机处理器「等待读写操作硬盘完毕」这一步的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 0x1f7</span><br><span class="line">.waits:</span><br><span class="line">	in al, dx    ; 从硬盘的0x1f7端口读取数据</span><br><span class="line">	and al, 0x88 ; 0x88的二进制形式是10001000，意味着我们想保留住AL中的第7位和第3位，其他位清零</span><br><span class="line">	cmp al, 0x08 ; 如果AL是00001000（0x08），就说明可以退出等待状态，继续往下操作，否则继续等待。</span><br><span class="line">	jnz .waits.  ; 不忙，且硬盘已经准备好数据传输</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>连续取出数据</strong></p>
<ul>
<li><p>0x1f0 是硬盘接口的数据端口，而且还是一个 16 位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。</p>
</li>
<li><p>下面的代码假定是从硬盘读一个扇区（512 字节），读取的数据存放到由段寄存器 DS 指定的数据段， 偏移地址由寄存器BX 指定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov cx, 256    ; 总共要读取的字数</span><br><span class="line">mov dx, 0x1f0</span><br><span class="line">.readw:</span><br><span class="line">	in ax, dx</span><br><span class="line">	mov [bx], ax</span><br><span class="line">	add bx, 2</span><br><span class="line">	loop .readw</span><br></pre></td></tr></table></figure></li>
<li><p>0x1f1 端口是错误寄存器，包含硬盘驱动器最后一次执行命令 后的状态（错误原因）</p>
</li>
</ul>
</li>
</ol>
<h2 id="加载程序（器）的工作流程"><a href="#加载程序（器）的工作流程" class="headerlink" title="加载程序（器）的工作流程"></a>加载程序（器）的工作流程</h2><p>工作流程（具体流程可以往下看）：</p>
<ol>
<li><code>初始化和决定加载位置</code>：决定从哪个物理内存地址开始加载用户程序，确定用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少。</li>
<li><code>准备加载用户程序</code>：将主引导扇区程序定义成一个段。让段内所有元素的汇编地址都将从 0x7c00 开始计算。</li>
<li><code>读取用户程序的第一个扇区</code>：从硬盘上读取用户程序的第一扇区。第一扇区包括有用户程序头部，以及一部分实际的指令和数据。</li>
<li><code>加载用户程序</code>：根据用户程序头部的信息，将用户程序全部读入内存。</li>
<li><code>用户程序重定位</code>：计算和确定每个段的段地址。</li>
<li><code>将控制权交给用户程序</code>：现在，用户程序已经在内存中准备就绪，剩下的工作就是把处理器的控制权交给它。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">         ;代码清单8-1</span><br><span class="line">         ;文件名：c08_mbr.asm</span><br><span class="line">         ;文件说明：硬盘主引导扇区代码（加载程序） </span><br><span class="line">         ;创建日期：2011-5-5 18:17</span><br><span class="line">         </span><br><span class="line">         app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）</span><br><span class="line">                                         ;常数的声明不会占用汇编地址</span><br><span class="line">                                    </span><br><span class="line">SECTION mbr align=16 vstart=0x7c00       ;将主引导扇区程序定义成一个段                              </span><br><span class="line"></span><br><span class="line">         ;初始化栈段和栈指针 </span><br><span class="line">         mov ax,0      </span><br><span class="line">         mov ss,ax</span><br><span class="line">         mov sp,ax</span><br><span class="line">      </span><br><span class="line">         mov ax,[cs:phy_base]            ;获得用于加载用户程序的逻辑段地址，因为phy_base是双字单元，必须放在ax和bx两个寄存器中</span><br><span class="line">         mov dx,[cs:phy_base+0x02]</span><br><span class="line">         mov bx,16        </span><br><span class="line">         div bx                          ;执行后，ax就存储了「用于加载用户程序的段地址」,为0x1000</span><br><span class="line">         mov ds,ax                       ;令DS和ES指向该段以进行操作</span><br><span class="line">         mov es,ax                        </span><br><span class="line">    </span><br><span class="line">         ;以下读取程序的起始部分 </span><br><span class="line">         xor di,di</span><br><span class="line">         mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 </span><br><span class="line">         xor bx,bx                       ;加载到DS:0x0000处 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">      </span><br><span class="line">         ;以下判断整个程序有多大</span><br><span class="line">         mov dx,[2]</span><br><span class="line">         mov ax,[0]</span><br><span class="line">         mov bx,512                      ;每扇区512字节</span><br><span class="line">         div bx</span><br><span class="line">         cmp dx,0                        ;如果用户程序的大小正好是512的整数倍，做完除法后，AX中是用户程序实际占用的扇区数</span><br><span class="line">         jnz @1                          ;未除尽，意味着最后一个扇区因为没有填满，需要转移到后面的代码，去读剩余的扇区；</span><br><span class="line">         dec ax                          ;如果已经除尽了,因为已经读了一个扇区，扇区总数减1 </span><br><span class="line">   @1:</span><br><span class="line">         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 </span><br><span class="line">         jz direct</span><br><span class="line">         </span><br><span class="line">         ;读取剩余的扇区</span><br><span class="line">         push ds                         ;以下要用到并改变DS寄存器 </span><br><span class="line"></span><br><span class="line">         mov cx,ax                       ;循环次数（剩余扇区数）</span><br><span class="line">   @2:</span><br><span class="line">         mov ax,ds</span><br><span class="line">         add ax,0x20                     ;得到下一个以512字节为边界的段地址</span><br><span class="line">         mov ds,ax  </span><br><span class="line">                              </span><br><span class="line">         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 </span><br><span class="line">         inc si                          ;下一个逻辑扇区 </span><br><span class="line">         call read_hard_disk_0</span><br><span class="line">         loop @2                         ;循环读，直到读完整个功能程序 </span><br><span class="line"></span><br><span class="line">         pop ds                          ;恢复数据段基址到用户程序头部段 </span><br><span class="line">      </span><br><span class="line">         ;计算入口点代码段基址，重定位用户程序入口点</span><br><span class="line">   direct:</span><br><span class="line">         mov dx,[0x08]                   ;偏移为0x06处的双字，存放了入口点代码段的汇编地址</span><br><span class="line">         mov ax,[0x06]</span><br><span class="line">         call calc_segment_base          ;计算代码段在内存中的段地址</span><br><span class="line">         mov [0x06],ax                   ;回填修正后的入口点代码段基址 </span><br><span class="line">      </span><br><span class="line">         ;开始处理段重定位表</span><br><span class="line">         mov cx,[0x0a]                   ;需要重定位的项目数量</span><br><span class="line">         mov bx,0x0c                     ;重定位表首地址</span><br><span class="line">          </span><br><span class="line"> realloc:</span><br><span class="line">         mov dx,[bx+0x02]                ;32位地址的高16位 </span><br><span class="line">         mov ax,[bx]</span><br><span class="line">         call calc_segment_base</span><br><span class="line">         mov [bx],ax                     ;回填段的基址</span><br><span class="line">         add bx,4                        ;下一个重定位项（每项占4个字节） </span><br><span class="line">         loop realloc </span><br><span class="line">      </span><br><span class="line">         jmp far [0x04]                  ;转移到用户程序,将控制权交给用户程序  </span><br><span class="line"> </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区</span><br><span class="line">                                         ;输入：DI:SI=起始逻辑扇区号</span><br><span class="line">                                         ;     DS:BX=目标缓冲区地址</span><br><span class="line">         push ax</span><br><span class="line">         push bx</span><br><span class="line">         push cx</span><br><span class="line">         push dx</span><br><span class="line">      </span><br><span class="line">         mov dx,0x1f2</span><br><span class="line">         mov al,1</span><br><span class="line">         out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f3</span><br><span class="line">         mov ax,si</span><br><span class="line">         out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f4</span><br><span class="line">         mov al,ah</span><br><span class="line">         out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f5</span><br><span class="line">         mov ax,di</span><br><span class="line">         out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f6</span><br><span class="line">         mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">         or al,ah                        ;LBA地址27~24</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f7</span><br><span class="line">         mov al,0x20                     ;读命令</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">  .waits:</span><br><span class="line">         in al,dx</span><br><span class="line">         and al,0x88</span><br><span class="line">         cmp al,0x08</span><br><span class="line">         jnz .waits                      ;不忙，且硬盘已准备好数据传输 </span><br><span class="line"></span><br><span class="line">         mov cx,256                      ;总共要读取的字数</span><br><span class="line">         mov dx,0x1f0</span><br><span class="line">  .readw:</span><br><span class="line">         in ax,dx</span><br><span class="line">         mov [bx],ax</span><br><span class="line">         add bx,2</span><br><span class="line">         loop .readw</span><br><span class="line"></span><br><span class="line">         pop dx</span><br><span class="line">         pop cx</span><br><span class="line">         pop bx</span><br><span class="line">         pop ax</span><br><span class="line">      </span><br><span class="line">         ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">calc_segment_base:                       ;计算16位段地址</span><br><span class="line">                                         ;输入：DX:AX=32位物理地址</span><br><span class="line">                                         ;返回：AX=16位段基地址 </span><br><span class="line">         push dx                          </span><br><span class="line">         </span><br><span class="line">         add ax,[cs:phy_base]            ;将用户程序在内存中物理起始地址的低16位加到AX中</span><br><span class="line">         adc dx,[cs:phy_base+0x02]</span><br><span class="line">         shr ax,4                        ;右移4位</span><br><span class="line">         ror dx,4</span><br><span class="line">         and dx,0xf000</span><br><span class="line">         or ax,dx</span><br><span class="line">         </span><br><span class="line">         pop dx</span><br><span class="line">         </span><br><span class="line">         ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">         phy_base: dd 0x10000             ;用户程序被加载的物理起始地址</span><br><span class="line">         </span><br><span class="line"> times 510-($-$$) db 0</span><br><span class="line"> db 0x55,0xaa</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>声明常数</code>：和其他伪指令 db、dw、dd 不同，<strong>用 equ 声明的数值不占用任何汇编地址，也不在运行时占用任何内存位置。它仅仅代表一个数值，就这么简单</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app_lba_start equ 100 ;声明常数，用标号app_lba_start 来代表数值100</span><br><span class="line"></span><br><span class="line">mov al, 100</span><br><span class="line">; 等价于</span><br><span class="line">mov al, app_lba_start</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="初始化和决定加载位置"><a href="#初始化和决定加载位置" class="headerlink" title="初始化和决定加载位置"></a>初始化和决定加载位置</h3><p>从大的方面来说，加载器要加载一个用户程序，并使之开始执行， 需要决定两件事：</p>
<ol>
<li>看看内存中的什么地方是空闲的，即从哪个物理内存地址开始加载用户程序；</li>
<li>用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少。</li>
</ol>
<h3 id="准备加载用户程序"><a href="#准备加载用户程序" class="headerlink" title="准备加载用户程序"></a>准备加载用户程序</h3><ul>
<li><p>将主引导扇区程序定义成一个段。段内所有元素的汇编地址都将从 0x7c00 开始计算。否则，因为主引导程序的实际加载地址是 0x0000:0x7c00，当我们引用一个标号时，还得手工加上那个落差 0x7c00。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECTION mbr align=16 vstart=0x7c00</span><br></pre></td></tr></table></figure></li>
<li><p>加载用户程序需要确定一个内存物理地址，初始化为0x10000 :<code>phy_base: dd 0x10000</code>。你完全可以把用户程序加载到其他地方，只要它是 16 字节对齐并且空闲的，这样<strong>将来才能形成一个有效的段地址</strong>。</p>
</li>
<li><p>然后将 phy_base 的高 16 位处在 phy_base＋0x02 处，放在寄存器 DX 中；低 16 位处在 phy_base 处，放在寄存器 AX 中。</p>
<p><img src="/images/image-20220209141859644-4387540.png" alt="image-20220209141859644"></p>
</li>
<li><p><code>div bx</code>：将物理地址 phy_base 变成 16 位的段地址，并传送到 DS 和 ES 寄存器。</p>
</li>
</ul>
<h3 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h3><p><code>过程调用</code>：又叫例程，或者子程序、子过程、子例程。处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。</p>
<p><img src="/images/image-20220209171338013.png" alt="image-20220209171338013"></p>
<h3 id="加载用户程序"><a href="#加载用户程序" class="headerlink" title="加载用户程序"></a>加载用户程序</h3><p>读取用户程序的第一扇区，包括有用户程序头部，以及一部分实际的指令和数据。为了将用户程序全部读入内存，需要知道它的大小，然后再进一步转换成它所用的扇区数。</p>
<h3 id="用户程序重定位"><a href="#用户程序重定位" class="headerlink" title="用户程序重定位"></a>用户程序重定位</h3><ul>
<li>用户程序在编写的时候是分段的。因此，加载器下一步的工作是<strong>计算和确定每个段的段地址</strong>。</li>
<li>用于加载用户程序的物理地址 phy_base 是16 字节对齐的，而用户程序中，每个段的汇编地址也是 16 字节对齐的。因此，每个段在内存中的起始地址也是 16 字节对齐的，将它们分别右移 4 位，就是它们各自的逻辑段地址。</li>
</ul>
<p><img src="/images/image-20220209182209766.png" alt="image-20220209182209766"></p>
<h3 id="将控制权交给用户程序"><a href="#将控制权交给用户程序" class="headerlink" title="将控制权交给用户程序"></a>将控制权交给用户程序</h3><ul>
<li>现在，用户程序已经在内存中准备就绪，剩下的工作就是把处理器 的控制权交给它。</li>
<li>交接工作很简单，加载器<strong>通过一个16 位的间接绝对远转移指令，跳转到用户程序入口点</strong>。</li>
</ul>
<h2 id="用户程序的工作流程"><a href="#用户程序的工作流程" class="headerlink" title="用户程序的工作流程"></a>用户程序的工作流程</h2><p>用户程序的工作流程：</p>
<ol>
<li>初始化段寄存器和栈切换</li>
<li>调用字符串显示例程</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">         ;代码清单8-2</span><br><span class="line">         ;文件名：c08.asm</span><br><span class="line">         ;文件说明：用户程序 </span><br><span class="line">         ;创建日期：2011-5-5 18:17</span><br><span class="line">         </span><br><span class="line">;====================================</span><br><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code_1.start ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    realloc_tbl_len dw (header_end-code_1_segment)/4</span><br><span class="line">                                            ;段重定位表项个数[0x0a]</span><br><span class="line">    </span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_1_segment  dd section.code_1.start ;[0x0c]</span><br><span class="line">    code_2_segment  dd section.code_2.start ;[0x10]</span><br><span class="line">    data_1_segment  dd section.data_1.start ;[0x14]</span><br><span class="line">    data_2_segment  dd section.data_2.start ;[0x18]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    </span><br><span class="line">    header_end:                </span><br><span class="line">    </span><br><span class="line">;====================================</span><br><span class="line">SECTION code_1 align=16 vstart=0         ;定义代码段1（16字节对齐） </span><br><span class="line">put_string:                              ;显示串(0结尾)。</span><br><span class="line">                                         ;输入：DS:BX=串地址</span><br><span class="line">         mov cl,[bx]</span><br><span class="line">         or cl,cl                        ;cl=0？ 判断是否为字符串的结尾\0</span><br><span class="line">         jz .exit                        ;是的，返回主程序 </span><br><span class="line">         call put_char</span><br><span class="line">         inc bx                          ;下一个字符 </span><br><span class="line">         jmp put_string</span><br><span class="line"></span><br><span class="line">   .exit:</span><br><span class="line">         ret</span><br><span class="line"></span><br><span class="line">;------------------------------------</span><br><span class="line">put_char:                                ;显示一个字符</span><br><span class="line">                                         ;输入：cl=字符ascii</span><br><span class="line">         push ax</span><br><span class="line">         push bx</span><br><span class="line">         push cx</span><br><span class="line">         push dx</span><br><span class="line">         push ds</span><br><span class="line">         push es</span><br><span class="line"></span><br><span class="line">         ;以下取当前光标位置</span><br><span class="line">         mov dx,0x3d4</span><br><span class="line">         mov al,0x0e</span><br><span class="line">         out dx,al                       ;通过索引端口告诉显卡，现在要操作0x0e 号寄存器</span><br><span class="line">         mov dx,0x3d5</span><br><span class="line">         in al,dx   ;通过数据端口从0x0e号端口读出1字节的数据，并传送到AH中，这是屏幕光标位置的高8位。</span><br><span class="line">         mov ah,al</span><br><span class="line"></span><br><span class="line">         mov dx,0x3d4</span><br><span class="line">         mov al,0x0f</span><br><span class="line">         out dx,al</span><br><span class="line">         mov dx,0x3d5</span><br><span class="line">         in al,dx                        ;从0x0f号寄存器读出光标位置的低8位 </span><br><span class="line">         mov bx,ax                       ;BX=代表光标位置的16位数</span><br><span class="line"></span><br><span class="line">         cmp cl,0x0d                     ;是否为回车符？</span><br><span class="line">         jnz .put_0a                     ;不是。看看是不是换行等字符 </span><br><span class="line">         mov ax,bx                       ;此句略显多余，但去掉后还得改书，麻烦 </span><br><span class="line">         mov bl,80                       </span><br><span class="line">         div bl                          ;用当前光标位置除以80，余数不要，就可以得到当前行的行号</span><br><span class="line">         mul bl                          ;再乘以80，就是当前行行首的光标数值</span><br><span class="line">         mov bx,ax</span><br><span class="line">         jmp .set_cursor                 ;设置光标在屏幕上的位置。</span><br><span class="line"></span><br><span class="line"> .put_0a:</span><br><span class="line">         cmp cl,0x0a                     ;换行符？</span><br><span class="line">         jnz .put_other                  ;不是，那就正常显示字符 </span><br><span class="line">         add bx,80                       ;向下一行，只需将BX的内容增加80，即可得到新的光标位置数据</span><br><span class="line">         jmp .roll_screen</span><br><span class="line"></span><br><span class="line"> .put_other:                             ;正常显示字符</span><br><span class="line">         mov ax,0xb800</span><br><span class="line">         mov es,ax                       ;ES指向显存</span><br><span class="line">         shl bx,1  ;一个字符在显存中对应两个字节,将光标位置乘以2，得到该字符在显存中的偏移地址</span><br><span class="line">         mov [es:bx],cl                  ;写入要显示的字符</span><br><span class="line"></span><br><span class="line">         ;以下将光标位置推进一个字符</span><br><span class="line">         shr bx,1                        ;将BX的内容除以2，恢复它的光标位置身份</span><br><span class="line">         add bx,1                        ;将光标推进到下一个位置</span><br><span class="line"></span><br><span class="line"> .roll_screen:</span><br><span class="line">         cmp bx,2000                     ;光标超出屏幕？滚屏</span><br><span class="line">         jl .set_cursor</span><br><span class="line"></span><br><span class="line">         mov ax,0xb800</span><br><span class="line">         mov ds,ax</span><br><span class="line">         mov es,ax</span><br><span class="line">         cld</span><br><span class="line">         mov si,0xa0                     ;0xa0:屏幕第2行第1列的位置</span><br><span class="line">         mov di,0x00                     ;0x00:屏幕第1行第1列的位置</span><br><span class="line">         mov cx,1920    ;1920=24行乘以80个字符/行，乘以每个字符占用的字节数2，再除以2字节/字</span><br><span class="line">         rep movsw</span><br><span class="line">         mov bx,3840                     ;清除屏幕最底一行。3840:第25行第1列在显存中的偏移地址</span><br><span class="line">         mov cx,80</span><br><span class="line"> .cls:</span><br><span class="line">         mov word[es:bx],0x0720</span><br><span class="line">         add bx,2</span><br><span class="line">         loop .cls</span><br><span class="line"></span><br><span class="line">         mov bx,1920   ;滚屏之后，光标应当位于最后一行的第1列，其数值为1920</span><br><span class="line"></span><br><span class="line"> .set_cursor:</span><br><span class="line">         mov dx,0x3d4 ;通过索引端口指定光标寄存器0x0e和0x0f，并分别将BX中的高8位和低8位通过数据段口0x3d5 写入它们</span><br><span class="line">         mov al,0x0e</span><br><span class="line">         out dx,al</span><br><span class="line">         mov dx,0x3d5</span><br><span class="line">         mov al,bh</span><br><span class="line">         out dx,al</span><br><span class="line">         mov dx,0x3d4</span><br><span class="line">         mov al,0x0f</span><br><span class="line">         out dx,al</span><br><span class="line">         mov dx,0x3d5</span><br><span class="line">         mov al,bl</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">         pop es</span><br><span class="line">         pop ds</span><br><span class="line">         pop dx</span><br><span class="line">         pop cx</span><br><span class="line">         pop bx</span><br><span class="line">         pop ax</span><br><span class="line"></span><br><span class="line">         ret</span><br><span class="line"></span><br><span class="line">;-----------------------------------</span><br><span class="line">  start:</span><br><span class="line">         ;初始执行时，DS和ES指向用户程序头部段</span><br><span class="line">         mov ax,[stack_segment]           ;设置到用户程序自己的堆栈 </span><br><span class="line">         mov ss,ax</span><br><span class="line">         mov sp,stack_end                 ;因为stack_end为256，所以这条指令和mov sp, 256等价</span><br><span class="line">         </span><br><span class="line">         mov ax,[data_1_segment]          ;设置到用户程序自己的数据段</span><br><span class="line">         mov ds,ax</span><br><span class="line"></span><br><span class="line">         mov bx,msg0</span><br><span class="line">         call put_string                  ;显示第一段信息 </span><br><span class="line"></span><br><span class="line">         push word [es:code_2_segment]</span><br><span class="line">         mov ax,begin</span><br><span class="line">         push ax                          ;可以直接push begin,80386+</span><br><span class="line">         </span><br><span class="line">         retf                             ;转移到代码段2执行 </span><br><span class="line">         </span><br><span class="line">  continue:</span><br><span class="line">         mov ax,[es:data_2_segment]       ;段寄存器DS切换到数据段2 </span><br><span class="line">         mov ds,ax</span><br><span class="line">         </span><br><span class="line">         mov bx,msg1</span><br><span class="line">         call put_string                  ;显示第二段信息 </span><br><span class="line"></span><br><span class="line">         jmp $ </span><br><span class="line"></span><br><span class="line">;===================================</span><br><span class="line">SECTION code_2 align=16 vstart=0          ;定义代码段2（16字节对齐）</span><br><span class="line"></span><br><span class="line">  begin:</span><br><span class="line">         push word [es:code_1_segment]</span><br><span class="line">         mov ax,continue</span><br><span class="line">         push ax                          ;可以直接push continue,80386+</span><br><span class="line">         </span><br><span class="line">         retf                             ;转移到代码段1接着执行 </span><br><span class="line">         </span><br><span class="line">;====================================</span><br><span class="line">SECTION data_1 align=16 vstart=0</span><br><span class="line"></span><br><span class="line">    msg0 db &#x27;  This is NASM - the famous Netwide Assembler. &#x27;</span><br><span class="line">         db &#x27;Back at SourceForge and in intensive development! &#x27;</span><br><span class="line">         db &#x27;Get the current versions from http://www.nasm.us/.&#x27;</span><br><span class="line">         db 0x0d,0x0a,0x0d,0x0a</span><br><span class="line">         db &#x27;  Example code for calculate 1+2+...+1000:&#x27;,0x0d,0x0a,0x0d,0x0a</span><br><span class="line">         db &#x27;     xor dx,dx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     xor ax,ax&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     xor cx,cx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;  @@:&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     inc cx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     add ax,cx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     adc dx,0&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     inc cx&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     cmp cx,1000&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     jle @@&#x27;,0x0d,0x0a</span><br><span class="line">         db &#x27;     ... ...(Some other codes)&#x27;,0x0d,0x0a,0x0d,0x0a</span><br><span class="line">         db 0  ; 使用\0代表字符串的总结，就和C一样</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION data_2 align=16 vstart=0</span><br><span class="line"></span><br><span class="line">    msg1 db &#x27;  The above contents is written by LeeChung. &#x27;</span><br><span class="line">         db &#x27;2011-05-06&#x27;</span><br><span class="line">         db 0</span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION stack align=16 vstart=0</span><br><span class="line">           </span><br><span class="line">         resb 256     ; 跳过256字节</span><br><span class="line"></span><br><span class="line">stack_end:  </span><br><span class="line"></span><br><span class="line">;====================================</span><br><span class="line">SECTION trail align=16</span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>resb 256</code>指令：保留 256 字节的栈空间。这条指令仅仅是跳过指定数量的字节，而不管里面的原始内容是什么。</p>
</blockquote>
<h3 id="初始化段寄存器和栈切换"><a href="#初始化段寄存器和栈切换" class="headerlink" title="初始化段寄存器和栈切换"></a>初始化段寄存器和栈切换</h3><ul>
<li>现在轮到用户程序在处理器上执行了。因为加载器已经完成了重定位工作，所以<strong>用户程序的头等大事是初始化处理器的各个段寄存器DS、ES、SS，以便访问专属于自己的数据</strong>。</li>
<li>在进入用户程序时，段寄存器 DS 和 ES 依然指向段 header，而栈段寄存器 SS 依然指向加载器的栈空间。所以需要从头部取得用户程序自己的栈段的段地址，并传送到段寄存器 SS 中。寄存器 DS 同理。</li>
</ul>
<h3 id="调用字符串显示例程"><a href="#调用字符串显示例程" class="headerlink" title="调用字符串显示例程"></a>调用字符串显示例程</h3><ul>
<li><p>光标在屏幕上的位置保存在显卡内部的两个光标寄存器中，每个寄存器是 8 位的，合起来形成一个 16 位的数值。比如，0 表示光标在屏幕上第 0 行第 0 列，80 表示它在第 1 行第 0 列，因为标准 VGA 文本模式是 25 行，每行 80 个字符。这样算来，当光标在屏幕右下角时，该值为 25 × 80 - 1 = 1999。<strong>光标寄存器是可读可写的</strong>。你可以从中读出光标的位置，也可以通过它设置光标的位置。能够通过写入一个数值来设定光标的位置。</p>
</li>
<li><p>显卡的操作非常复杂，内部的寄存器也不是一般地多。为了不过多占用主机的 I/O 空间，很多寄存器只能通过<code>索引寄存器</code>间接访问。索引寄存器的端口号是 <code>0x3d4</code>，可以向它写入一个值，用来指定内部的某个寄存器。</p>
<blockquote>
<p>比如，两个 8 位的光标寄存器，其索引值分别是 14（0x0e）和 15（0x0f），分别用于提供光标位置的高 8 位和低 8 位。</p>
</blockquote>
<p>指定了寄存器之后，要对它进行读写，这可以通过数据端口 0x3d5 来进行。</p>
</li>
<li><p>滚动屏幕内容，实质上就是将屏幕上第 2～25 行的内容整体往上提 一行，最后用黑底白字的空白字符填充第 25 行，使这一行什么也不显示。</p>
</li>
<li><p>流程：</p>
<p><img src="/images/image-20220210123105453.png" alt="image-20220210123105453"></p>
</li>
</ul>
<h1 id="第-9-章-中断和动态时钟显示"><a href="#第-9-章-中断和动态时钟显示" class="headerlink" title="第 9 章 中断和动态时钟显示"></a>第 9 章 中断和动态时钟显示</h1><p>中断就是打断处理器当前的执行流程，去执行另外一些和当前工作不相干的指令，执行完之后，还可以返回到原来的程序流程继续执行。</p>
<h2 id="外部硬件中断"><a href="#外部硬件中断" class="headerlink" title="外部硬件中断"></a>外部硬件中断</h2><ul>
<li><p>外部硬件中断是通过两个信号线引入处理器内部的。从很早的时候起，也就是 8086 处理器的时代，这两根线的名字就叫 <code>NMI</code> 和<code>INTR</code>。</p>
<ul>
<li>通过两个引脚来明确区分不同性质的中断，严重事件都必须无条件地加以处理，这种类型的中断是不会被阻断和屏蔽的，称为<code>非屏蔽中断</code>（Non Maskable Interrupt，NMI）。</li>
<li><code>可屏蔽中断</code>：是通过 INTR 引脚进入处理器内部的。</li>
</ul>
</li>
<li><p>Intel 处理器上的不可屏蔽中断示意图：</p>
<p><img src="/images/image-20220210141746732.png" alt="image-20220210141746732"></p>
<blockquote>
<ul>
<li>NMI 中断信号由 0 跳变到 1 后，至少要维持 4 个以上的时钟周期才算是有效的</li>
<li>在实模式下，NMI 被赋予了统一的中断号 2，不再进行细分。一旦发生 2 号中断，处理器和软件系统通常会放弃继续正常工作的念头，也不会试图纠正已经发生的问题和错误，很可能只是由软件系统给出一个提示信息。</li>
</ul>
</blockquote>
</li>
<li><p><code>中断控制器</code>：多个设备同时发出中断请求时，需要代理对它们进行仲裁，以决定让它们中的哪一个优先向处理器提出服务请求。这种中断代理称为中断控制器。</p>
<blockquote>
<p>在个人计算机中，用得最多的中断控制器就是 8259 芯片。</p>
</blockquote>
</li>
<li><p>单处理器系统的中断机制：</p>
<p><img src="/images/image-20220210143214999.png" alt="image-20220210143214999"></p>
<ul>
<li>第一块 8259 芯片的代理输出 INT 直接送到处理器的 INTR 引脚，这是主片（Master）；第二块 8259 芯片的INT 输出送到第一块的引脚2上，是从片（Slave），两块芯片之间形成级联（Cascade）关系。</li>
<li>在 8259 芯片内部，有中断屏蔽寄存器（Interrupt Mask Register， IMR），这是个 8 位寄存器，对应着该芯片的 8 个中断输入引脚，对应的位是 0 还是 1，决定了从该引脚来的中断信号是否能够通过 8259 送往处理器（0 表示允许，1 表示阻断）。</li>
<li>如此一来，两块 8259 芯片可以向处理器提供 15 个中断信号。</li>
</ul>
</li>
<li><p>中断能否被处理，除了要看 8259 芯片的脸色外，最终的决定权在处理器手中。处理器内部的标志寄存器的标志位 IF，就是中断标志（Interrupt Flag）。当 IF 为 0 时，所有从处理器 INTR 引脚来的中断信号都被忽略掉；当其为 1 时，处理器可以接受和响应中断。</p>
</li>
<li><p>IF 标志位可以通过两条指令 <code>cli</code> （CLear Interrupt flag）和 <code>sti</code>（SeT Interrupt flag） 来改变。</p>
</li>
<li><p>中断是有优先级的，中断的优先级和引脚是相关的，主片的 IR0 引脚优先级最高，IR7 引脚最低，从片也是如此。当然，还要考虑到从片是级联在主片的 IR2 引脚上。</p>
</li>
<li><p>当一个中断事件正在处理时，如果来了一个优先级更高的中断事件时，允许暂时中止当前的中断处理，先为优先级较高的中断事件服务，这称为<code>中断嵌套</code>。</p>
</li>
</ul>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><ul>
<li><p>每个中断在中断向量表中占 2 个字，分别是中断处理程序的偏移地址和段地址。中断 0 的入口点位于物理地址0x00000 处， 也就是逻辑地址 0x0000:0x0000；中断 1 的入口点位于物理地址 0x00004 处，即逻辑地址 0x0000:0x0004；其他中断以此类推。</p>
<p><img src="/images/image-20220210153133757.png" alt="image-20220210153133757"></p>
</li>
<li><p>处理器的中断流程：</p>
<ol>
<li><p><code>保护断点的现场</code>：首先要将标志寄存器 FLAGS 压栈，然后清除它的 IF 位和 TF 位。再将当前的代码段寄存器 CS 和指令指针寄存器 IP 压栈。</p>
</li>
<li><p><code>执行中断处理程序</code>：由于处理器已经拿到了中断号，它将该号码乘以 4（毕竟每个中断在中断向量表中占4 字节），就得到了该中断入口点在中断向量表中的偏移地址。接着，从表中依次取出中断程序的偏移地址和段地址，并分别传送到 IP 和 CS，自然地，处理器就开始执行中断处理程序了。</p>
<blockquote>
<p>由于 IF 标志被清除，在中断处理过程中，处理器将不再响应硬件中断。如果希望更高优先级的中断嵌套，可以在编写中断处理程序时，适时用 sti 指令开放中断。</p>
</blockquote>
</li>
<li><p><code>返回到断点接着执行</code>：所有中断处理程序的最后一条指令必须是中断返回指令iret。这将导致处理器依次从栈中弹出（恢复）IP、CS 和 FLAGS 的原始内容，于是转到主程序接着执行。</p>
<blockquote>
<p>由于中断处理过程返回时，已经恢复了 FLAGS 的原始内容，所以 IF 标志位也自动恢复。也就是说，可以接受新的中断。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>和可屏蔽中断不同，NMI 发生时，处理器不会从外部获得中断号， 它自动生成中断号码2，其他处理过程和可屏蔽中断相同。</p>
</li>
</ul>
<h2 id="实时时钟、CMOS-RAM-和BCD-编码"><a href="#实时时钟、CMOS-RAM-和BCD-编码" class="headerlink" title="实时时钟、CMOS RAM 和BCD 编码"></a>实时时钟、CMOS RAM 和BCD 编码</h2><ul>
<li><p>日期和时间信息是保存在 CMOS RAM 中的，通常有 128 字节，而日期和时间信息只占了一小部分容量，其他空间则用于保存整机的配置信息，比如各种硬件的类型和工作参数、开机密码和辅助存储设备的启动顺序等。</p>
<blockquote>
<p>这些参数的修改通常在 BIOS SETUP 开机程序中进行。要进入该程序，一般需要在开机时按DEL、ESC、F1、F2 或者F10 键。具体按哪个键，视计算机的厂家和品牌而定。</p>
</blockquote>
</li>
<li><p>CMOS RAM 中保存的日期和时间，通常是以二进制编码的十进制数 （Binary Coded Decimal，BCD），这是默认状态，如果需要，也可以设置成按正常的二进制数来表示。</p>
</li>
<li><p>CMOS RAM 的访问，需要通过两个端口来进行。0x70 或者 0x74 是 索引端口，用来指定 CMOS RAM 内的单元；0x71 或者0x75 是数据端口，用来读写相应单元里的内容。</p>
<blockquote>
<p>查看今天是星期几：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0x06</span><br><span class="line">out 0x70, al</span><br><span class="line">in al, 0x71</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h2><ul>
<li><strong>内部中断发生在处理器内部</strong>，是由执行的指令引起的。比如，当处理器检测到 div 或者 idiv 指令的除数为零时，或者除法的结果溢出时，将产生中断0（0 号中断），这就是除法错中断。</li>
<li>内部中断不受标志寄存器 IF 位的影响，也不需要中断识别总线周期，它们的中断类型是固定的，可以立即转入相应的处理过程。</li>
</ul>
<h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><ul>
<li><p><strong>软中断是由int 指令引起的中断处理</strong>。这类中断也不需要中断识别总线周期，中断号在指令中给出。</p>
</li>
<li><p><code>int3</code> 是断点中断指令，<strong>指令都是连续存放的，因此，所谓的断点，就是某条指令的起始地址</strong>。</p>
<ol>
<li>当需要设置断点时，可以将断点处那条指令的第 1 字节改成<code>0xcc</code>，原字节予以保存。</li>
<li>当处理器执行到 int3 时，即发生 3 号中断，转去执行相应的中断处理程序。中断处理程序的执行也要用到各个寄存器，这会破坏它们的内容，但push 指令不会。我们可以在该程序内先压栈所有相关寄存器和内存单元，然后分别取出予以显示，它们就是中断前的现场内容。</li>
<li>最后，再恢复那条指令的第 1 字节，并修改位于栈中的返回地址，执行 iret 指令。</li>
</ol>
</li>
<li><p>int 引发N号中断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int 0x00  ; 引发0号中断</span><br><span class="line">int 0x15  ; 引发0x15号中断</span><br><span class="line">int 0x16  ; 引发0x16号中断</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<code>int3</code> 和 <code>int 3</code> 不是一回事。前者的机器码为CC，后者则是CD 03，这就是通常所说的int n，其操作码为0xCD，第2 字节的操作数给出了中断号。</p>
</blockquote>
</li>
</ul>
<h2 id="BIOS-中断"><a href="#BIOS-中断" class="headerlink" title="BIOS 中断"></a>BIOS 中断</h2><ul>
<li>最有名的软中断是 BIOS 中断，之所以称为 BIOS 中断，是因为这些中断功能是在计算机加电之后，BIOS 程序执行期间建立起来的。换句话说，<strong>这些中断功能在加载和执行主引导扇区之前，就已经可以使用了</strong>。</li>
<li>BIOS 中断主要是为了方便地使用最基本的硬件访问功能。</li>
<li></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>