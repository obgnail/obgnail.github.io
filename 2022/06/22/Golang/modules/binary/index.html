<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;encoding/binary 包实现了对&lt;strong&gt;数据与 byte 之间的转换&lt;/strong&gt;，以及 &lt;strong&gt;varint 的编解码&lt;/strong&gt;。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>binary | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-06-22</div></div></div><div class="container post-header"><h1>binary</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84-byte-%E5%BA%8F%E5%88%97%E5%8C%96%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">数据的 byte 序列化转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uvarint-%E5%92%8C-varint-%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">uvarint 和 varint 的编解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#demo"><span class="toc-number">4.</span> <span class="toc-text">demo</span></a></li></ol></details></div><div class="container post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>encoding/binary 包实现了对<strong>数据与 byte 之间的转换</strong>，以及 <strong>varint 的编解码</strong>。</p>
<p>编码：</p>
<ul>
<li>func Write(w io.Writer, order ByteOrder, data interface{}) error</li>
<li>func PutUvarint(buf []byte, x uint64) int</li>
<li>func PutVarint(buf []byte, x int64) int</li>
</ul>
<p>解码：</p>
<ul>
<li>func Uvarint(buf []byte) (uint64, int)</li>
<li>func Varint(buf []byte) (int64, int)</li>
<li>func ReadUvarint(r io.ByteReader) (uint64, error)</li>
<li>func ReadVarint(r io.ByteReader) (int64, error)</li>
</ul>
<h2 id="数据的-byte-序列化转换"><a href="#数据的-byte-序列化转换" class="headerlink" title="数据的 byte 序列化转换"></a>数据的 byte 序列化转换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read从r中读出字节数据并反序列化成结构数据。data必须是固定长的数据值或固定长数据的slice。从r中读出的数据可以使用特殊的字节序来解码，并顺序写入value的字段。当填充结构体时，使用(_)名的字段将被跳过。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read</span><span class="params">(r io.Reader, order ByteOrder, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Write将data序列化成字节流写入w中。data必须是固定长度的数据值或固定长数据的slice，或指向此类数据的指针。写入w的字节流可用特殊的字节序来编码。另外，结构体中的(_)名的字段讲忽略。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, order ByteOrder, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Size将返回数据系列化之后的字节长度，数据必须是固定长数据类型、slice和结构体及其指针。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Size</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>



<h2 id="uvarint-和-varint-的编解码"><a href="#uvarint-和-varint-的编解码" class="headerlink" title="uvarint 和 varint 的编解码"></a>uvarint 和 varint 的编解码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将uint64类型放入buf中，并返回写入的字节数。如果buf过小，PutUvarint将抛出panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutUvalint</span><span class="params">(buf []<span class="keyword">byte</span>, x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int64类型放入buf中，并返回写入的字节数。如果buf过小，PutVarint将抛出panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutVarint</span><span class="params">(buf []<span class="keyword">byte</span>, x <span class="keyword">int64</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从buf中解码并返回一个uint64的数据,及解码的字节数(&gt;0)。如果出错,则返回数据0和一个小于等于0的字节数n,其意义为:</span></span><br><span class="line"><span class="comment">// 1)n == 0: buf太小</span></span><br><span class="line"><span class="comment">// 2)n &lt; 0: 数据太大,超出uint64最大范围,且-n为已解析字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Uvarint</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">uint64</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从buf中解码并返回一个int64的数据,及解码的字节数(&gt;0).如果出错,则返回数据0和一个小于等于0的字节数n,其意义为:</span></span><br><span class="line"><span class="comment">// 1) n == 0: buf太小</span></span><br><span class="line"><span class="comment">// 2) n &lt; 0: 数据太大,超出64位,且-n为已解析字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Varint</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int64</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从r中解析并返回一个uint64类型的数据及出现的错误.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadUvarint</span><span class="params">(r io.ByteReader)</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从r中解析并返回一个int64类型的数据及出现的错误.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadVarint</span><span class="params">(r io.ByteReader)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br></pre></td></tr></table></figure>



<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> binary_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBinary1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pi <span class="keyword">float64</span></span><br><span class="line">	b := []<span class="keyword">byte</span>&#123;<span class="number">0x18</span>, <span class="number">0x2d</span>, <span class="number">0x44</span>, <span class="number">0x54</span>, <span class="number">0xfb</span>, <span class="number">0x21</span>, <span class="number">0x09</span>, <span class="number">0x40</span>&#125;</span><br><span class="line">	buf := bytes.NewBuffer(b)</span><br><span class="line">	err := binary.Read(buf, binary.LittleEndian, &amp;pi)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;binary.Read failed:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(pi) <span class="comment">// 3.141592653589793</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBinary2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	pi := math.Pi</span><br><span class="line"></span><br><span class="line">	err := binary.Write(buf, binary.LittleEndian, pi)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(buf.Bytes()) <span class="comment">// [24 45 68 84 251 33 9 64]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBinary3</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">	p := &amp;a</span><br><span class="line">	b := [<span class="number">10</span>]<span class="keyword">int64</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">	s := <span class="string">&quot;adsa&quot;</span></span><br><span class="line">	bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(binary.Size(a))  <span class="comment">// -1</span></span><br><span class="line">	fmt.Println(binary.Size(p))  <span class="comment">// -1</span></span><br><span class="line">	fmt.Println(binary.Size(b))  <span class="comment">// 80</span></span><br><span class="line">	fmt.Println(binary.Size(s))  <span class="comment">// -1</span></span><br><span class="line">	fmt.Println(binary.Size(bs)) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> binary_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBinary</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	u16 := <span class="number">1234</span></span><br><span class="line">	sbuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">	ret := binary.PutUvarint(sbuf, <span class="keyword">uint64</span>(u16))</span><br><span class="line">	fmt.Println(ret, <span class="built_in">len</span>(strconv.Itoa(u16)), sbuf) <span class="comment">// 2 4 [210 9 0 0]</span></span><br><span class="line"></span><br><span class="line">	u64 := <span class="number">0x1020304040302010</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line">	ret = binary.PutUvarint(buf, <span class="keyword">uint64</span>(u64))</span><br><span class="line">	<span class="comment">// 转成二进制来传输数据，比直接转字符串之后转[]byte这种方式传更节省传输空间</span></span><br><span class="line">	fmt.Println(ret, <span class="built_in">len</span>(strconv.Itoa(u64)), buf) <span class="comment">// 9 19 [144 192 192 129 132 136 140 144 16 0]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBinary</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	i16 := <span class="number">1234</span></span><br><span class="line">	i64 := <span class="number">-1234567890</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line">	sbuf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">	ret := binary.PutVarint(buf, <span class="keyword">int64</span>(i16))</span><br><span class="line">	fmt.Println(ret, <span class="built_in">len</span>(strconv.Itoa(i16)), sbuf) <span class="comment">// 2 4 [0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">	ret = binary.PutVarint(buf, <span class="keyword">int64</span>(i64))</span><br><span class="line">	fmt.Println(ret, <span class="built_in">len</span>(strconv.Itoa(i64)), buf) <span class="comment">// 5 11 [163 139 176 153 9 0 0 0 0 0]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBinary</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	sbuf := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">	buf := []<span class="keyword">byte</span>&#123;<span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">140</span>, <span class="number">144</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">	bbuf := []<span class="keyword">byte</span>&#123;<span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">129</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">140</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">	num, ret := binary.Uvarint(sbuf)</span><br><span class="line">	fmt.Println(num, ret) <span class="comment">// 0 0</span></span><br><span class="line"></span><br><span class="line">	num, ret = binary.Uvarint(buf)</span><br><span class="line">	fmt.Println(num, ret) <span class="comment">// 9077982472708112 8</span></span><br><span class="line"></span><br><span class="line">	num, ret = binary.Uvarint(bbuf)</span><br><span class="line">	fmt.Println(num, ret) <span class="comment">// 0 -11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBinary</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sbuf []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> buf []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">129</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">140</span>, <span class="number">144</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> bbuf []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">129</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">140</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">	num, ret := binary.Varint(sbuf)</span><br><span class="line">	fmt.Println(num, ret) <span class="comment">//0 0</span></span><br><span class="line"></span><br><span class="line">	num, ret = binary.Varint(buf)</span><br><span class="line">	fmt.Println(num, ret) <span class="comment">//580990878187261960 9</span></span><br><span class="line"></span><br><span class="line">	num, ret = binary.Varint(bbuf)</span><br><span class="line">	fmt.Println(num, ret) <span class="comment">//0 -11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBinary</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sbuf []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> buf []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">129</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">140</span>, <span class="number">144</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> bbuf []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">129</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">140</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">	num, err := binary.ReadUvarint(bytes.NewBuffer(sbuf))</span><br><span class="line">	fmt.Println(num, err) <span class="comment">//0 EOF</span></span><br><span class="line"></span><br><span class="line">	num, err = binary.ReadUvarint(bytes.NewBuffer(buf))</span><br><span class="line">	fmt.Println(num, err) <span class="comment">//1161981756374523920 &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">	num, err = binary.ReadUvarint(bytes.NewBuffer(bbuf))</span><br><span class="line">	fmt.Println(num, err) <span class="comment">//4620746270195064848 binary: varint overflows a 64-bit integer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBinary</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sbuf []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> buf []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">129</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">140</span>, <span class="number">144</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> bbuf []<span class="keyword">byte</span> = []<span class="keyword">byte</span>&#123;<span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">129</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">140</span>, <span class="number">144</span>, <span class="number">192</span>, <span class="number">192</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">	num, err := binary.ReadVarint(bytes.NewBuffer(sbuf))</span><br><span class="line">	fmt.Println(num, err) <span class="comment">//0 EOF</span></span><br><span class="line"></span><br><span class="line">	num, err = binary.ReadVarint(bytes.NewBuffer(buf))</span><br><span class="line">	fmt.Println(num, err) <span class="comment">//580990878187261960 &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">	num, err = binary.ReadVarint(bytes.NewBuffer(bbuf))</span><br><span class="line">	fmt.Println(num, err) <span class="comment">//2310373135097532424 binary: varint overflows a 64-bit integer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>