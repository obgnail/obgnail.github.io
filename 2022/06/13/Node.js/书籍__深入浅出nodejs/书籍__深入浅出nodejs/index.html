<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;chrome浏览器和Node的组件构成："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>深入浅出nodejs | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Node-js/" rel="tag">Node.js</a></div><div class="post-time">2022-06-13</div></div></div><div class="container post-header"><h1>深入浅出nodejs</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">node特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="toc-number">1.1.1.</span> <span class="toc-text">异步IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%9B%9E%E8%B0%83"><span class="toc-number">1.1.2.</span> <span class="toc-text">事件和回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">单线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">模块机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#commonJS"><span class="toc-number">2.1.</span> <span class="toc-text">commonJS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node%E3%80%81W3C%E3%80%81commonJS%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">Node、W3C、commonJS的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commonJS%E7%9A%84%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.2.</span> <span class="toc-text">commonJS的模块规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node%E6%A8%A1%E5%9D%97%E4%BC%98%E5%85%88%E4%BB%8E%E7%BC%93%E5%AD%98%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.2.</span> <span class="toc-text">Node模块优先从缓存加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90%E5%92%8C%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.3.</span> <span class="toc-text">模块的路径分析和文件定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%A0%87%E8%AF%86%E7%AC%A6%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">模块标识符分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">模块的搜索路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96require-%E9%80%9F%E5%BA%A6"><span class="toc-number">2.3.3.</span> <span class="toc-text">优化require()速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Module%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91"><span class="toc-number">2.3.4.</span> <span class="toc-text">Module对象与模块编译</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">2.4.</span> <span class="toc-text">核心模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NPM"><span class="toc-number">3.</span> <span class="toc-text">NPM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85"><span class="toc-number">3.1.</span> <span class="toc-text">全局安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85"><span class="toc-number">3.2.</span> <span class="toc-text">本地安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NPM-%E9%92%A9%E5%AD%90%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">NPM 钩子命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-IO"><span class="toc-number">4.</span> <span class="toc-text">异步 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">4.1.</span> <span class="toc-text">轮询技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#read"><span class="toc-number">4.1.1.</span> <span class="toc-text">read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">4.1.2.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-number">4.1.3.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-number">4.1.4.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kqueue"><span class="toc-number">4.1.5.</span> <span class="toc-text">kqueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E6%83%B3%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5-IO"><span class="toc-number">4.2.</span> <span class="toc-text">理想的非阻塞异步 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-epoll-%E6%AF%94-read-%E5%A5%BD%EF%BC%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">为什么说 epoll 比 read 好？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E6%83%B3%E7%9A%84%E5%BC%82%E6%AD%A5-IO"><span class="toc-number">4.2.2.</span> <span class="toc-text">理想的异步 IO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-%E7%9A%84%E5%BC%82%E6%AD%A5-IO"><span class="toc-number">4.3.</span> <span class="toc-text">Node 的异步 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.3.1.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85"><span class="toc-number">4.3.2.</span> <span class="toc-text">观察者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.3.3.</span> <span class="toc-text">请求对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%B8%AA%E5%BC%82%E6%AD%A5-IO-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">整个异步 IO 的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E9%9D%9E-IO-%E7%9A%84%E5%BC%82%E6%AD%A5-API"><span class="toc-number">5.</span> <span class="toc-text">四个非 IO 的异步 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-%E3%80%81setInterval"><span class="toc-number">5.1.</span> <span class="toc-text">setTimeout()、setInterval()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#process-nextTick"><span class="toc-number">5.2.</span> <span class="toc-text">process.nextTick()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setImmediate"><span class="toc-number">5.3.</span> <span class="toc-text">setImmediate()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">web 服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">事件的发布订阅模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%BC%82%E6%AD%A5%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%96%B9%E6%A1%88"><span class="toc-number">8.</span> <span class="toc-text">多异步之间的协作方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise-A"><span class="toc-number">9.</span> <span class="toc-text">promise&#x2F;A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">9.1.</span> <span class="toc-text">Promise 中的多异步操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97-async"><span class="toc-number">10.</span> <span class="toc-text">流程控制模块 async</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#series"><span class="toc-number">10.1.</span> <span class="toc-text">series</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parallel"><span class="toc-number">10.2.</span> <span class="toc-text">parallel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waterfall"><span class="toc-number">10.3.</span> <span class="toc-text">waterfall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">10.4.</span> <span class="toc-text">auto</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer"><span class="toc-number">11.</span> <span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">12.1.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">12.2.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-number">12.3.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-number">12.4.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS"><span class="toc-number">12.5.</span> <span class="toc-text">HTTPS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BD%91%E7%AB%99%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%9F%9F%E5%90%8D"><span class="toc-number">13.</span> <span class="toc-text">为什么很多网站的静态资源使用独立的域名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">14.</span> <span class="toc-text">Node 单进程单线程的弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%98%E8%BF%81"><span class="toc-number">15.</span> <span class="toc-text">服务模型的变迁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node-%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">16.</span> <span class="toc-text">node 多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">16.1.</span> <span class="toc-text">Node 进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.2.</span> <span class="toc-text">进程间通信的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E4%BC%A0%E9%80%92"><span class="toc-number">16.3.</span> <span class="toc-text">句柄传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E4%BC%A0%E9%80%92%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.4.</span> <span class="toc-text">句柄传递的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cluster-%E6%A8%A1%E5%9D%97"><span class="toc-number">17.</span> <span class="toc-text">cluster 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">18.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web-%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">19.</span> <span class="toc-text">web 项目常用的目录结构</span></a></li></ol></details></div><div class="container post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>chrome浏览器和Node的组件构成：</p>
<p><img src="/images/image-20210421145803885.png" alt="image-20210421145803885"></p>
<p>Node的结构和Chrome十分相似，他们都是基于时间驱动的异步架构。</p>
<ul>
<li>浏览器通过事件驱动来服务界面上的交互</li>
<li>Node通过事件驱动来服务IO</li>
</ul>
<p><img src="/images/image-20220610165424808.png" alt="image-20220610165424808"></p>
<h3 id="node特点"><a href="#node特点" class="headerlink" title="node特点"></a>node特点</h3><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。因此node是一个IO密集型语言。</p>
<p>前端JS加载Ajax:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">&#x27;/url&#x27;</span>, &#123;</span><br><span class="line">  <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;my book&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;suceess&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;failed&#x27;</span>);)</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20210421152818791.png" alt="image-20210421152818791"></p>
<p>后端node加载文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;/path&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err,file</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;发起文件读取&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里的“发起读取文件”是在“读取文件完成”之前输出的。</p>
<p><img src="/images/image-20210421153427379.png" alt="image-20210421153427379"></p>
<p>因为Node底层构建了很多异步的API，所以我们可以在语言层面很自然的使用并行IO操作。<strong>每个调用之间无须等待之前的IO调用结束</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个读取任务的耗时，取决与最慢的那个文件读取耗时</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;/path1&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err,file</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">fs.readFile(<span class="string">&#x27;/path2&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err,file</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="事件和回调"><a href="#事件和回调" class="headerlink" title="事件和回调"></a>事件和回调</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  req.setEncoding(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">  <span class="comment">// 监听请求的data事件</span></span><br><span class="line">  req.on(<span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">trunk</span>) </span>&#123;</span><br><span class="line">    postData += trunk;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 监听请求的end事件</span></span><br><span class="line">  req.on(<span class="string">&#x27;end&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    res.end(postData);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动完成&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>node这种代码的编写顺序与执行顺序无关，这可能造成阅读上的障碍。在流程控制方面，因为穿插了异步方法和回调函数，者与常规的同步方式相比，变得不那么一目了然。</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><ul>
<li>线程之间无法共享状态</li>
<li>没有死锁问题</li>
</ul>
<p>单线程缺点：</p>
<ul>
<li>无法利用多核CPU</li>
<li>错误会引起整个应用退出</li>
<li>大量计算占用CPU，导致无法继续调用异步IO，已完成的异步IO无法及时回调。</li>
</ul>
<h2 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h2><h3 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h3><p>commonJS的目的：让JS能在任何地方运行。为了弥补JS没有标准的缺陷，以达到具备开发大型应用分基础能力。</p>
<p>早期JS缺乏标准：</p>
<ul>
<li>没有模块系统</li>
<li>标准库较少</li>
<li>没有标准接口</li>
<li>缺乏包管理系统</li>
</ul>
<h4 id="Node、W3C、commonJS的关系"><a href="#Node、W3C、commonJS的关系" class="headerlink" title="Node、W3C、commonJS的关系"></a>Node、W3C、commonJS的关系</h4><p><img src="/images/image-20210421161932985.png" alt="image-20210421161932985"></p>
<h4 id="commonJS的模块规范"><a href="#commonJS的模块规范" class="headerlink" title="commonJS的模块规范"></a>commonJS的模块规范</h4><p>模块引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>模块定义：在Node中，一个文件就是一个模块，将方法挂载搭到exports对象上作为属性，就可以定义导出的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="built_in">exports</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  args = <span class="built_in">arguments</span>;</span><br><span class="line">  l = args.length;</span><br><span class="line">  <span class="keyword">while</span> (i&lt; l) &#123;</span><br><span class="line">    sum += args[i++]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在另一个文件中，通过require方法引入模块后，就能调用定义的属性方法了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// program.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);</span><br><span class="line"><span class="built_in">exports</span>.increment = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用math的add方法</span></span><br><span class="line">  <span class="keyword">return</span> math.add(val,<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>模块标识：其实就是传递给require方法的参数。他必须符合小驼峰的字符串，或者是以<code>.</code>,<code>..</code>开头的相对路径或绝对路径</p>
<p><img src="/images/image-20210421164426807.png" alt="image-20210421164426807"></p>
<h3 id="Node模块优先从缓存加载"><a href="#Node模块优先从缓存加载" class="headerlink" title="Node模块优先从缓存加载"></a>Node模块优先从缓存加载</h3><p>在node中引入模块，有三个步骤</p>
<ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>
<blockquote>
<p>node对引入过的模块都会进行缓存。不用与前端浏览器缓存静态脚本文件，node缓存的是编译和执行之后的对象。</p>
</blockquote>
<p>在node中，模块分成<code>核心模块</code>，<code>文件模块</code>两类。</p>
<ul>
<li><code>核心模块</code>：node提供的模块。核心模块在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分的核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行两个步骤可以省略掉。并且在路径分析中优先判断，所以她的<strong>加载速度是最快的</strong>。</li>
<li><code>文件模块</code>：用户编写的模块。运行时动态加载。需要完整额路径分析，文件定位，编译执行过程。速度慢。</li>
</ul>
<h3 id="模块的路径分析和文件定位"><a href="#模块的路径分析和文件定位" class="headerlink" title="模块的路径分析和文件定位"></a>模块的路径分析和文件定位</h3><h4 id="模块标识符分类"><a href="#模块标识符分类" class="headerlink" title="模块标识符分类"></a>模块标识符分类</h4><ul>
<li><p>核心模块。如果试图加载一个和核心模块标识符相同的自定义模块，那是不会成功的。必须选择一个不同的标识符或者换用路径的方式</p>
</li>
<li><p>以<code>.</code>或者<code>..</code>开头的相对路径文件模块。在分析路径模块是，require方法会将路径转为真实路径，并<strong>以真实路径作为索引，将编译执行后的结果存放到缓存中</strong>。</p>
</li>
<li><p>以<code>/</code>开头的绝对路径文件模块。</p>
</li>
<li><p>非路径形式的文件模块，如自定义的connect模块。自定义模块可能是一个文件，可能是一个包。这类模块的查找是最费时的，最慢的。</p>
</li>
</ul>
<h4 id="模块的搜索路径"><a href="#模块的搜索路径" class="headerlink" title="模块的搜索路径"></a>模块的搜索路径</h4><p>模块路径是node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&#x27;/home/liangbo/research/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/home/liangbo/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/home/node_modules&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/node_modules&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>生成规则：<strong>沿路径向上逐级递归，直到根目录下的node_modules目录</strong></p>
<ol>
<li>当前文件目录下的node_modules目录</li>
<li>父目录下的node_modules目录</li>
<li>父目录的父目录下的node_modules目录</li>
</ol>
<p>可以看出文件路径越深，查找速度越慢。这是自定义模块加载最慢的原因。</p>
<h4 id="优化require-速度"><a href="#优化require-速度" class="headerlink" title="优化require()速度"></a>优化require()速度</h4><p>require可以不添加文件名后缀。这种情况下，node会按照<code>.js</code>、<code>.json</code>、<code>.node</code>顺序补足，依次尝试。</p>
<p>在尝试过程中，会调用fs模块同步阻塞的判断文件是否存在，因为node是单线程的，所以会有性能问题。所以可以给json文件和node文件传递给require()的是否带上后缀名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入math.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);</span><br></pre></td></tr></table></figure>



<p>require()如果找到的不是文件，而是目录，这么就会当成一个包来解析</p>
<ol>
<li>首先查找该目录下的package.json文件，使用JSON.parse()解析出包描述对象。从中取出main属性指定的文件名进行定位</li>
<li>如果main属性指定的文件名错误，或者压根没有package.json文件，node就会将index当作默认文件名，然后依次查找<code>index.js</code>、<code>index.json</code>、<code>index.node</code></li>
<li>如果没有找到任何目标文件，抛出异常错误。</li>
</ol>
<h4 id="Module对象与模块编译"><a href="#Module对象与模块编译" class="headerlink" title="Module对象与模块编译"></a>Module对象与模块编译</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="built_in">this</span>.parent = parent;</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">    parent.children.push(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">this</span>.filename = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">this</span>.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。</p>
<p>对于不同分文件扩展名，其载入方法也有所不同：</p>
<ul>
<li>js文件：通过fs模块同步读取文件后编译执行。</li>
<li>node文件：这是用C/C++编写的动态库文件，可以通过dlopen方法加载。(.node 的扩展名只是为了看起来更加自然一点。实际上在 windows 下它是一个 .dll 文件，在 *nix 下是一个 .so 文件)</li>
<li>json文件：通过fs模块同步读取文件后，使用JSON.parse()解析，返回结果。</li>
<li>其他：都被当成js文件加载。</li>
</ul>
<p>每个编译成功的模块都会将其文件路径作为索引缓存再<code>Module._cache</code>对象上，以提高二次引入的性能。</p>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>Node 的核心模块在编译成可执行文件的过程中被编译进了二进制文件。</p>
<p>核心模块其实分成 C/C++ 编写的和 JS 编写的两部分。其中 C/C++ 文件存放在 Node 项目的 src 目录下， JS 文件存放在 lib 目录下。</p>
<p>这些由 C/C++ 编写的部分称为 <code>内建模块</code>，因为他们通常不被用户直接调用。</p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><blockquote>
<p>CommonJS 包规范时理论，NPM 是其中一种实践。对于 Node 而言，NPM 帮助完成了第三方模块的发布、安装和依赖等。</p>
</blockquote>
<p>CommonJS 规范下包目录的结构：</p>
<ul>
<li>package.json：包描述文件</li>
<li>bin：二进制目录</li>
<li>lib：JS 代码目录</li>
<li>doc：文档目录</li>
<li>test：单元测试用例目录</li>
</ul>
<p>package.json 的重要的内容</p>
<ul>
<li>name：包名。不能出现空格。</li>
<li>decription</li>
<li>version</li>
<li>keywords：关键词数组。NPM 中主要用来做分类搜索，一个好的关键词数组有利于用户快速找到你编写的包。</li>
<li>respositories：托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。</li>
<li><strong>dependencies</strong>：使用当前包所需要依赖的包列表。NPM 会通过这个属性自动加载依赖的包。</li>
<li>os：操作系统支持列表。如果设置为空，则不对操作系统做任何假设。</li>
<li>cpu：如果设置为空，则不对 cpu 架构做任何假设。</li>
<li>builtin：标志当前包是否是内建在底层系统的标准组件。</li>
<li><strong>implements</strong>：实现规范列表。说明当前包实现了 CommonJS 的哪些规范。</li>
<li>bin：一些包作者希望包可以作为命令行工具使用。配置好 bin 字段后，通过 npm install package_name -g 命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。</li>
<li><strong>main</strong>：模块引入方法 require() 在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，require() 方法会查找包目录下的 index.js、index.node、index.json 文件作为默认入口。</li>
<li><strong>devDependencies</strong>：一些模块只在开发时需要依赖，配置这个属性，可以提示包的后续开发者安装依赖包。</li>
<li><strong>scripts</strong>：脚本说明对象。主要被包管理器用来安装、编译、测试、卸载包。</li>
</ul>
<p>scripts 示例</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;scripts&#x27;: &#123;</span><br><span class="line">    <span class="attr">&quot;install&quot;</span>: <span class="string">&quot;install.js&quot;</span>，</span><br><span class="line">    <span class="string">&quot;uninstall&quot;</span>: <span class="string">&quot;uninstall.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;build.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: <span class="string">&quot;make-doc.js&quot;</span>，</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;test.js&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure>

<p>注意：全局模式并不是将一个模块包安装为一个全局包，并不意味着可以重任何地方通过 <code>require()</code> 来引用它。实际上， <code>-g</code> 是<strong>将一个包安装为全局可用的可执行命令</strong>。它根据包描述文件中的 <code>bin</code> 字段配置，将实际脚本链接到与 Node 可以执行文件相同的路径下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;bin&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;express&quot;</span>: <span class="string">&quot;./bin/express&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，<strong>通过全局模式安装的模块就是通过软链接的方式将 bin 字段配置的可执行文件链接到 Node 的可执行目录下。</strong></p>
<h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><p>对于一些没有发布到 NPM 上的包，或是因为网络原因导致无法直接安装的包，可以通过将包下载到本地，然后本地安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;tarball file&gt;</span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br></pre></td></tr></table></figure>

<p>如上，<code>npm install XXX</code> 可以是：</p>
<ul>
<li>包含 package.json 的存档文件</li>
<li>URL 地址</li>
<li>一个目录下有 package.json 文件的目录位置。</li>
</ul>
<p>非官方源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install XXX --registry=http://XXXX</span><br></pre></td></tr></table></figure>

<p>设置镜像源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://XXXX</span><br></pre></td></tr></table></figure>



<h3 id="NPM-钩子命令"><a href="#NPM-钩子命令" class="headerlink" title="NPM 钩子命令"></a>NPM 钩子命令</h3><p>C/C++ 模块是编译后才能使用的。package.json 中 scripts 字段就是让包在安装或者卸载的时候提供钩子机制。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;preinstall.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;install&quot;</span>: <span class="string">&quot;install.js&quot;</span>，</span><br><span class="line">    <span class="string">&quot;uninstall&quot;</span>: <span class="string">&quot;uninstall.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;test.js&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面字段中，</p>
<ul>
<li>执行 <code>npm install &lt;package&gt;</code> 时，preinstall 指向的脚本将会被执行。接着 install 指向的脚本会被执行。</li>
<li>执行 <code>npm uninstall &lt;package&gt;</code> 时，uninstall 指向的脚本会被执行。</li>
<li>执行 <code>npm test</code> 时，test 指向的脚本会被执行。</li>
</ul>
<h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h2><h3 id="轮询技术"><a href="#轮询技术" class="headerlink" title="轮询技术"></a>轮询技术</h3><p><strong>不同的轮询技术，只是改变了等待 IO 期间 CPU的状态</strong>。等待期间 CPU 要么用于遍历文件描述符的状态，要么用于休眠等待事件发生。</p>
<p>所以，轮询技术满足了非阻塞 IO 确保获取完整数据的需求，但是<strong>对于应用程序而言，它仍然只能算是一种同步</strong>，因为应用程序仍然需要等待 IO 完全返回，依旧花费了很多时间等待。</p>
<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>最原始、性能最低的一种，通过重复调用来检查 IO 的状态来完成完整数据的读取。在得到最终数据前，CPU 一直耗用在等待上。</p>
<p><img src="/images/image-20220601174614934.png" alt="image-20220601174614934"></p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>在 read 的基础上进行改进。通过对文件描述符上的事件来进行判断。</p>
<p>select 轮询具有一个较弱的限制，那就是由于他采用一个 1024 长度的数组来存储状态，所以它最多可以同时检查 1024 个文件描述符。</p>
<p><img src="/images/image-20220601174734934.png" alt="image-20220601174734934"></p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>采用链表的方式避免数组长度的限制。他能避免不需要的检查。但是单文件描述符较多的时候，他的性能还是十分低下的。poll 和 select 相似，但是性能限制有所改善。</p>
<p><img src="/images/image-20220601175444726.png" alt="image-20220601175444726"></p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>Linux 下效率最高的 IO 事件通知机制。在进入轮询的时候如果没有检查到 IO 事件，将会进行休眠，知道事件发生将它唤醒。他是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费 CPU，执行效率高。</p>
<p><img src="/images/image-20220601175648271.png" alt="image-20220601175648271"></p>
<h4 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h4><p>实现方式与 epoll 类似，不过它仅在 FreeBSD 系统下存在。</p>
<h3 id="理想的非阻塞异步-IO"><a href="#理想的非阻塞异步-IO" class="headerlink" title="理想的非阻塞异步 IO"></a>理想的非阻塞异步 IO</h3><h4 id="为什么说-epoll-比-read-好？"><a href="#为什么说-epoll-比-read-好？" class="headerlink" title="为什么说 epoll 比 read 好？"></a>为什么说 epoll 比 read 好？</h4><p><strong>不同的轮询技术只是改变了 CPU 在等待 IO 期间，CPU 的状态</strong>。使用 read 的情况，CPU 一直没空。而使用 epoll 的情况，CPU 很多时间都是在休眠。因此，我们就可以利用 CPU 的空闲时间去做另外的事情。</p>
<h4 id="理想的异步-IO"><a href="#理想的异步-IO" class="headerlink" title="理想的异步 IO"></a>理想的异步 IO</h4><p>异步 IO 一定要紧抓 <code>应用层</code> 和 <code>系统内核</code> 两个实体。</p>
<p><img src="/images/image-20220601181522788.png" alt="image-20220601181522788"></p>
<h3 id="Node-的异步-IO"><a href="#Node-的异步-IO" class="headerlink" title="Node 的异步 IO"></a>Node 的异步 IO</h3><p>事件循环是一个典型的生产者/消费者模型。</p>
<p><strong>异步 IO、网络请求等是事件的生产者，源源不断的为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环从观察者那里取出事件并处理</strong>。</p>
<blockquote>
<p>事件驱动的实质：通过<code>主循环</code>加<code>事件触发</code>的方式来运行整个程序。</p>
</blockquote>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>Node 在启动时，会创建一个类似于 while true 的循环，每执行一次循环体的过程，我们称为 <code>Tick</code>。</p>
<p>每个 tick 的过程就是检查是否有事件待处理。如果有，就取出事件及其相关的回调函数，如果存在关联的回调函数，就在执行它们。然后进入下一个循环，如果不再有事件处理，就退出进程。</p>
<p><img src="/images/image-20220601183802213.png" alt="image-20220601183802213"></p>
<h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>在每次事件循环中，有一个或者多个观察者，去询问是否有事件要处理。</p>
<p>浏览器也是采用类似的机制。事件可能来自用户的点击或者加载某些文件时产生，而<strong>这些事件都有对应的观察者</strong>。在 Node 中，事件主要来源于网络请求、文件 IO 等，这些事件对应的观察者有 <code>文件 IO 观察者</code>、<code>网络 IO 观察者</code> 等。</p>
<blockquote>
<p>观察者将事件进行了分类。</p>
</blockquote>
<h4 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h4><p>异步 IO 的回调函数，是由 Node 调用的。从 JavaScript 发起调用到内核执行完 IO 操作的过渡过程中，存在一种中间产物，名为 <code>请求对象</code>。所有的状态都保存在请求对象中，包括送入线程池等待执行以及 IO 操作完毕后的回调处理。</p>
<h3 id="整个异步-IO-的流程"><a href="#整个异步-IO-的流程" class="headerlink" title="整个异步 IO 的流程"></a>整个异步 IO 的流程</h3><p><code>事件循环</code>、<code>观察者</code>、<code>请求对象</code>、<code>IO 线程池</code> 四者共同构成了 Node 异步 IO 模型的基本要素。</p>
<ul>
<li>windows 下通过 IOCP 来向系统内核发送 IO 调用和从内核获取已完成的 IO 操作，配以事件循环，以此完成异步 IO 的过程</li>
<li>Linux 下通过 epoll 实现这个过程</li>
<li>FreeBSD 下通过 kqueue 实现</li>
<li>Splaris 下通过 Event ports 实现</li>
</ul>
<p><img src="/images/image-20220602141544672.png" alt="image-20220602141544672"></p>
<h2 id="四个非-IO-的异步-API"><a href="#四个非-IO-的异步-API" class="headerlink" title="四个非 IO 的异步 API"></a>四个非 IO 的异步 API</h2><h3 id="setTimeout-、setInterval"><a href="#setTimeout-、setInterval" class="headerlink" title="setTimeout()、setInterval()"></a>setTimeout()、setInterval()</h3><p>setTimeout()、setInterval() 分别用于单次和多次定时执行任务。</p>
<p><code>实现原理</code>：和异步 IO 比较类似，只是不需要 IO 线程池的参与。调用 setTimeout() 和 setInterval() 创建的定时器会被插入到<code>定时器观察者</code>内部的一个红黑树中。每次 Tick 执行时，会从该红黑树中迭代去除定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，他的回调函数将立即执行。</p>
<p>setInterval() 和 setTimeout() 的区别是：重复性的检查和执行。</p>
<p><img src="/images/image-20220602142802210.png" alt="image-20220602142802210"></p>
<blockquote>
<p>定时器的问题在于：它并非精确的。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。譬如通过 setTimeout() 设定一个任务在 10ms 后执行，但是在 9ms 后，有一个任务占用了 5ms 的 CPU 时间片，再次轮到定时器执行时，时间就已经过期 4ms。</p>
</blockquote>
<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do some thing</span></span><br><span class="line">&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码为：立即启动一个异步任务。</p>
<p>采用定时器需要动用红黑树，创建定时器对象和迭代等操作，很浪费性能，时间复杂度为 <code>O(lg(n))</code>。</p>
<p>这时候使用 process.nextTick() 比较好。它只会见回调函数放入队列中，在下一轮 Tick 时取出执行，时间复杂度为 <code>O(1)</code>。</p>
<h3 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;nextTick延迟执行&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setImmediate&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;正常执行&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常执行</span></span><br><span class="line"><span class="comment">// nextTick延迟执行</span></span><br><span class="line"><span class="comment">// setImmediate</span></span><br></pre></td></tr></table></figure>

<p>在每一轮循环检查中，时间循环对观察者的检查是有先后顺序的，process.nextTick() 属于 idle 观察者，setImmediate() 属于 check 观察者。</p>
<p>优先级：<code>idle 观察者 &gt; IO 观察者 &gt; check 观察者</code>。</p>
<blockquote>
<p>事件循环模型需要应对海量请求，海量请求同时作用在单线程上，就需要防止任何一个计算耗费过多的 CPU 时间片。建议对 CPU 的耗用不要超过 10ms，或者将大量的计算分解为诸多的小量计算，通过 setImmediate() 进行调度。</p>
</blockquote>
<h2 id="web-服务器"><a href="#web-服务器" class="headerlink" title="web 服务器"></a>web 服务器</h2><p><img src="/images/image-20220602145755863.png" alt="image-20220602145755863"></p>
<h2 id="事件的发布订阅模式"><a href="#事件的发布订阅模式" class="headerlink" title="事件的发布订阅模式"></a>事件的发布订阅模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>).EventEmitter; </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">event.on(<span class="string">&quot;event1&quot;</span>,<span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">event.emit(<span class="string">&quot;event1&quot;</span>,<span class="string">&quot;i am message&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>继承 events：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; EventEmitter &#125; <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; inherits &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Steam</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherits(Steam, EventEmitter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> steam = <span class="keyword">new</span> Steam()</span><br><span class="line">steam.on(<span class="string">&quot;event1&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(message) &#125;)</span><br><span class="line">steam.emit(<span class="string">&quot;event1&quot;</span>, <span class="string">&quot;i am message&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用 once() 实现单飞：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; EventEmitter &#125; <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> EventEmitter()</span><br><span class="line"><span class="keyword">var</span> status = <span class="string">&#x27;ready&#x27;</span></span><br><span class="line"><span class="keyword">var</span> select = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">	proxy.once(<span class="string">&#x27;selected&#x27;</span>, callback)</span><br><span class="line">	<span class="keyword">if</span> (status === <span class="string">&#x27;ready&#x27;</span>) &#123;</span><br><span class="line">		status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">		db.select(<span class="string">&quot;SQL&quot;</span>, <span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">			proxy.emit(<span class="string">&#x27;selected&#x27;</span>, results)</span><br><span class="line">			status = <span class="string">&#x27;ready&#x27;</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>once() 方法，将所有请求的回调都压入事件队列中，执行一次就会将监视器移除，保证每个回调都只会被执行一次。</p>
</blockquote>
<h2 id="多异步之间的协作方案"><a href="#多异步之间的协作方案" class="headerlink" title="多异步之间的协作方案"></a>多异步之间的协作方案</h2><p>一般而言，事件和监听器的关系是一对多，但是在异步编程中，也会出现事件和监听器的关系是多对一的情况，也就是说一个业务逻辑可能依赖两个通过回调或事件传递的结果。这时就需要多个异步之间的协作。</p>
<p>比如说，<code>渲染页面</code>的功能需要如下步骤：</p>
<ol>
<li>读取模板（template）</li>
<li>读取数据（data）</li>
<li>读取本地化资源（resources）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> results = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  results[key] = value;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">if</span> (count === <span class="number">3</span>) &#123;</span><br><span class="line">    render(results);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取模板</span></span><br><span class="line">fs.readFile(template_path, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">&quot;template&quot;</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取本地化资源</span></span><br><span class="line">l10n.get(<span class="function"><span class="keyword">function</span> (<span class="params">err, resources</span>) </span>&#123;</span><br><span class="line">  done(<span class="string">&quot;resources&quot;</span>, resources);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码并不能保证 template，data，resources 三个函数顺序执行。</p>
<p>可以修改成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> after = <span class="function"><span class="keyword">function</span> (<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> results = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    results[key] = value;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count === times) &#123;</span><br><span class="line">      callback(results);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = after(times, render);</span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.Emitter();</span><br><span class="line">emitter.on(<span class="string">&quot;done&quot;</span>, done);</span><br><span class="line"></span><br><span class="line">fs.readFile(template_path, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">  emitter.emit(<span class="string">&quot;done&quot;</span>, <span class="string">&quot;template&quot;</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  emitter.emit(<span class="string">&quot;done&quot;</span>, <span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">l10n.get(<span class="function"><span class="keyword">function</span> (<span class="params">err, resources</span>) </span>&#123;</span><br><span class="line">  emitter.emit(<span class="string">&quot;done&quot;</span>, <span class="string">&quot;resources&quot;</span>, resources);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>



<h2 id="promise-A"><a href="#promise-A" class="headerlink" title="promise/A"></a>promise/A</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// done</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// error</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// progress</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promisify = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    result += chunk;</span><br><span class="line">    deferred.progress(chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    deferred.resolve(result);</span><br><span class="line">  &#125;);</span><br><span class="line">  res.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    deferred.reject(err);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>



<h3 id="Promise-中的多异步操作"><a href="#Promise-中的多异步操作" class="headerlink" title="Promise 中的多异步操作"></a>Promise 中的多异步操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = readFile(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> promise2 = readFile(<span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">deferred.all([promise1, promise2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>



<h2 id="流程控制模块-async"><a href="#流程控制模块-async" class="headerlink" title="流程控制模块 async"></a>流程控制模块 async</h2><h3 id="series"><a href="#series" class="headerlink" title="series"></a>series</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;file2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码相当于:</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(err);</span><br><span class="line">  &#125;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;file2.txt &#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    callback(<span class="literal">null</span>, [content, data]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="parallel"><a href="#parallel" class="headerlink" title="parallel"></a>parallel</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallel([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, callback);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;file2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码相当于:</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">  results[index] = value;</span><br><span class="line">  counter--;</span><br><span class="line">  <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">    callback(<span class="literal">null</span>, results);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 只传递第一个异常</span></span><br><span class="line"><span class="keyword">var</span> hasErr = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> fail = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasErr) &#123;</span><br><span class="line">    hasErr = <span class="literal">true</span>;</span><br><span class="line">    callback(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">fs.readFile(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> fail(err);</span><br><span class="line">  &#125;</span><br><span class="line">  done(<span class="number">0</span>, content);</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">&#x27;file2.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> fail(err);</span><br><span class="line">  &#125;</span><br><span class="line">  done(<span class="number">1</span>, data);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<h3 id="waterfall"><a href="#waterfall" class="headerlink" title="waterfall"></a>waterfall</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">arg1, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 =&gt; file2.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">arg1, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 =&gt; file3.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// result =&gt; file4.txt</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码相当于:</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;file1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(err);</span><br><span class="line">  &#125;</span><br><span class="line">  fs.readFile(data1, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    fs.readFile(data2, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data3</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback(err);</span><br><span class="line">      &#125;</span><br><span class="line">      callback(<span class="literal">null</span>, data3);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>



<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>业务场景如下：</p>
<ol>
<li>读取配置文件</li>
<li>根据配置文件连接 MongoDB</li>
<li>根据配置文件连接 Redis</li>
<li>编译静态文件</li>
<li>上传静态文件到 CDN</li>
<li>启动服务器</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">readConfig</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="attr">connectMongoDB</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="attr">connectRedis</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="attr">complieAsserts</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="attr">uploadAsserts</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="attr">startup</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deps = &#123;</span><br><span class="line">  <span class="attr">readConfig</span>: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// read config file</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">connectMongoDB</span>: [<span class="string">&#x27;readConfig&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// connect to mongodb</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">connectRedis</span>: [<span class="string">&#x27;readConfig&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// connect to redis</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">complieAsserts</span>: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// complie asserts</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">uploadAsserts</span>: [<span class="string">&#x27;complieAsserts&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// upload to assert</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">startup</span>: [<span class="string">&#x27;connectMongoDB&#x27;</span>, <span class="string">&#x27;connectRedis&#x27;</span>, <span class="string">&#x27;uploadAsserts&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// startup</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.auto(deps); </span><br></pre></td></tr></table></figure>



<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer 对象的内存分配不是在 V8 的堆内存中，而是在 Node 的 C++ 层面实现内存的申请的。因为处理大量的字节数据不能频繁申请内存，为此 Node 在内存的伤应用的是<strong>在C++ 层面申请内存，在 JavaScript 中分配内存</strong>的策略。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    socket.write(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  socket.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;close connection&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  socket.write(<span class="string">&quot;welcome \n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8124</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;server bound&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client = net.connect(&#123; <span class="attr">port</span>: <span class="number">8124</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//&#x27;connect&#x27; listener</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;client connected&#x27;</span>);</span><br><span class="line">  client.write(<span class="string">&#x27;world!\r\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  client.end();</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;client disconnected&#x27;</span>);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>代码分成 <code>服务器事件</code> 和 <code>连接事件</code></p>
<p>服务器事件对于通过 net.createServer () 创建的服务器而言，它是一个 EventEmitter 实例，它的自定义事件有如下几种。</p>
<ul>
<li>listening：在调用 server.listen() 绑定端口或者 Domain Socket 后触发，简洁写法 server.listen(port, listeningListener)，通过 listen() 方法的第二个参数传入。</li>
<li>connection：每个客户端套接字连接到服务器端时触发，简洁写法为通过 net.createServer()，最后一个参数传递。</li>
<li>close：当服务器关闭时触发，在调用 server.close() 后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。</li>
<li>error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听 error 事件，服务器将会抛出异常。</li>
</ul>
<p>连接事件服务器可以同时与多个客户端保持连接，对于每个连接而言是典型的可写可读 Stream 对象。Stream 对象可以用于服务器端和客户端之间的通信，既可以通过 data 事件从一端读取另一端发来的数据，也可以通过 write() 方法从一端向另一端发送数据。它具有如下自定义事件。</p>
<ul>
<li>data：当一端调用 write() 发送数据时，另一端会触发 data 事件，事件传递的数据即是 write() 发送的数据。</li>
<li>end：当连接中的任意一端发送了 FIN 数据时，将会触发该事件。</li>
<li>connect：该事件用于客户端，当套接字与服务器端连接成功时会被触发。</li>
<li>drain：当任意一端调用 write() 发送数据时，当前这端会触发该事件。</li>
<li>error：当异常发生时，触发该事件。</li>
<li>close：当套接字完全关闭时，触发该事件。</li>
<li>timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了。</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">&quot;dgram&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> server = dgram.createSocket(<span class="string">&quot;udp4&quot;</span>);</span><br><span class="line">server.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg, rinfo</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;server got: &quot;</span> + msg + <span class="string">&quot; from &quot;</span> +</span><br><span class="line">    rinfo.address + <span class="string">&quot;:&quot;</span> + rinfo.port);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&quot;listening&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> address = server.address();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;server listening &quot;</span> +</span><br><span class="line">    address.address + <span class="string">&quot;:&quot;</span> + address.port);</span><br><span class="line">&#125;);</span><br><span class="line">server.bind(<span class="number">41234</span>); </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> Buffer(<span class="string">&quot;ศ入റ出Node.js&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> client = dgram.createSocket(<span class="string">&quot;udp4&quot;</span>);</span><br><span class="line">client.send(message, <span class="number">0</span>, message.length, <span class="number">41234</span>, <span class="string">&quot;localhost&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, bytes</span>) </span>&#123;</span><br><span class="line">  client.close();</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>UDP 套接字相对 TCP 套接字使用起来更简单，它只是一个 EventEmitter 的实例，而非 Stream 的实例。它具备如下自定义事件：</p>
<ul>
<li>message: 当 UDP 套接字监听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息 Buffer 对象和一个远程地址消息。</li>
<li>listening: 当 UDP 套接字开始监听时触发该事件。</li>
<li>close: 调用 close() 方法时触发该事件，并不再触发 message 事件。如需再次触发 message 事件，重新绑定即可。</li>
<li>error: 当异常发生时触发该事件，如果不监听，异常将直接抛出，使进程退出。</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>); </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">  res.end(<span class="string">&#x27;Hello World\n&#x27;</span>);</span><br><span class="line">&#125;).listen(<span class="number">1337</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://127.0.0.1:1337/&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> options = &#123; <span class="attr">hostname</span>: <span class="string">&quot;127.0.0.1&quot;</span>, <span class="attr">port</span>: <span class="number">1337</span>, <span class="attr">path</span>: <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> req = http.request(options, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;STATUS: &quot;</span> + res.statusCode);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;HEADERS: &quot;</span> + <span class="built_in">JSON</span>.stringify(res.headers));</span><br><span class="line">  res.setEncoding(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">  res.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// res.end() 会先用 req.write() 发送数据，然后发送信号告知服务器这次响应结束</span></span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>

<p>HTTP 服务的事件：</p>
<ul>
<li>connection 事件：在开始 HTTP 请求和响应前，客户端与服务器端需要建立 TCP 连接，这个连接可能因为开启了 keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次 connection 事件；</li>
<li>request 事件： 建立 TCP 连接后，http 模块底层将在数据流中抽象出 HTTP 请求和 HTTP 响应，当请求数据发送到服务器端，在解析出 HTTP 请求头后，将会触发该事件；在 res.end() 后，TCP 连接可能将用于下一次请求响应；</li>
<li>close 事件：与 TCP 服务器的行为一致，调用 server.close() 方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给 server.close() 传递一个回调函数来快速注册该事件；</li>
<li>checkContinue 事件： 某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带 Expect: 100-continue 的请求到服务器，服务器将会触发 checkContinue 事件；如果没有为服务器监听这个事件，服务器将会自动响应客户端 100 Continue 的状态码，表示接受数据上传；如果客户端应该继续发送请求正文，则处理此事件涉及调用 response.writeContinue()，或者如果客户端不应该继续发送请求正文，则生成适当的 HTTP 响应（例如 400 Bad Request）。两个事件之间互斥。当客户端收到 100 Continue 后重新发起请求时，才会触发 request 事件；</li>
<li>connect 事件：客户端发起 CONNECT 请求时触发，而发起 CONNECT 请求通常在 HTTP 代理时出现；如果不监听该事件，发起该请求的连接将会关闭；</li>
<li>upgrade 事件：客户端要求升级连接接的协议时，需要和服务器端协商，客户端会在请求头中带上 Upgrade 字段，服务器端会在接收到这样的请求时触发该事件。如果不监听该事件，发起该请求的连接将会关闭；</li>
<li>clientError 事件：连接的客户端触发 error 事件时，这个错误会传递到服务器端，此时触发该事件。</li>
</ul>
<p>HTTP 客户端事件：</p>
<ul>
<li>response：与服务器端的 request 事件对应的客户端在请求发出后得到服务器端响应时， 会触发该事件；</li>
<li>socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事件；</li>
<li>connect：当客户端向服务器端发送 CONNECT 请求时，如果服务器端响应了 200 状态码，客户端将会触发改事件；</li>
<li>upgrade：客户端向服务器端发起 Upgrade 请求时，如果服务器端响应了 101 Switching Protocols 状态，客户端将会触发该事件；</li>
<li>continue：客户端向服务器端发起 Expect: 100-continue 头信息，以试图发送较大数据量， 如果服务器端响应 100 Continue 状态，客户端将触发该事件。</li>
</ul>
<p>Node 和浏览器一样，会对同一个域名下的请求有并发限制。默认为 5。可以通过改写 agent 下的 maxSockets 属性进行修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> agent = <span class="keyword">new</span> http.Agent(&#123;</span><br><span class="line">  <span class="attr">maxSockets</span>: <span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="attr">hostname</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">1334</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="attr">agent</span>: agent</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>Node 很适合做 WebSocket</p>
<ul>
<li>WebSocket 客户端就是基于事件的编程模型。</li>
<li>WebSocket 保持了客户端和服务端的长连接，而 Node 事件驱动的方式十分擅长与大量的客户端保持高并发连接。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ws</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;)</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">ws</span> =&gt;</span> &#123;</span><br><span class="line">  ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Received message =&gt; <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  ws.send(<span class="string">&#x27;Hello! Message From Server!!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.js</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;ws://localhost:8080&#x27;</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="keyword">new</span> WebSocket(url)</span><br><span class="line"></span><br><span class="line">connection.onopen = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  connection.send(<span class="string">&#x27;Message From Client&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection.onerror = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`WebSocket error: <span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>自己模拟实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://127.0.0.1:12010/updates&#x27;</span>);</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每 50ms 发送一次数据</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (socket.bufferedAmount == <span class="number">0</span>)</span><br><span class="line">      socket.send(getUpdateData());</span><br><span class="line">  &#125;, <span class="number">50</span>);</span><br><span class="line">&#125;;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO：event.data</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>发起协议切换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebSocket = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 伪代码，解析ws://127.0.0.1:12010/updates，用于请求</span></span><br><span class="line">  <span class="built_in">this</span>.options = parseUrl(url);</span><br><span class="line">  <span class="built_in">this</span>.connect();</span><br><span class="line">&#125;;</span><br><span class="line">WebSocket.prototype.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;;</span><br><span class="line">WebSocket.prototype.setSocket = <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.socket = socket;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">WebSocket.prototype.connect = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">this</span> = that;</span><br><span class="line">  <span class="keyword">var</span> key = <span class="keyword">new</span> Buffer(<span class="built_in">this</span>.options.protocolVersion + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Date</span>.now()).toString(<span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> shasum = crypto.createHash(<span class="string">&#x27;sha1&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> expected = shasum.update(key + <span class="string">&#x27;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#x27;</span>).digest(<span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="built_in">this</span>.options.port, <span class="comment">// 12010</span></span><br><span class="line">    <span class="attr">host</span>: <span class="built_in">this</span>.options.hostname, <span class="comment">// 127.0.0.1</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;Upgrade&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Upgrade&#x27;</span>: <span class="string">&#x27;websocket&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Sec-WebSocket-Version&#x27;</span>: <span class="built_in">this</span>.options.protocolVersion,</span><br><span class="line">      <span class="string">&#x27;Sec-WebSocket-Key&#x27;</span>: key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> req = http.request(options);</span><br><span class="line">  req.end();</span><br><span class="line">  req.on(<span class="string">&#x27;upgrade&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res, socket, upgradeHead</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 连接成功</span></span><br><span class="line">    that.setSocket(socket);</span><br><span class="line">    <span class="comment">// 触发 open 事件</span></span><br><span class="line">    that.onopen();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务器响应行为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">  res.end(<span class="string">&#x27;Hello World\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">12010</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在收到upgrade请求后，告之客户端运行切换协议</span></span><br><span class="line">server.on(<span class="string">&#x27;upgrade&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, socket, upgradeHead</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> head = <span class="keyword">new</span> Buffer(upgradeHead.length);</span><br><span class="line">  upgradeHead.copy(head);</span><br><span class="line">  <span class="keyword">var</span> key = req.headers[<span class="string">&#x27;sec-websocket-key&#x27;</span>];</span><br><span class="line">  <span class="keyword">var</span> shasum = crypto.createHash(<span class="string">&#x27;sha1&#x27;</span>);</span><br><span class="line">  key = shasum.update(key + <span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span>).digest(<span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> headers = [</span><br><span class="line">    <span class="string">&#x27;HTTP/1.1 101 Switching Protocols&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Upgrade: websocket&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection: Upgrade&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-WebSocket-Accept: &#x27;</span> + key,</span><br><span class="line">    <span class="string">&#x27;Sec-WebSocket-Protocol: &#x27;</span> + protocol</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// 让数据立即发送</span></span><br><span class="line">  socket.setNoDelay(<span class="literal">true</span>);</span><br><span class="line">  socket.write(headers.concat(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).join(<span class="string">&#x27;\r\n&#x27;</span>));</span><br><span class="line">  <span class="comment">// 建立服务端websocket连接</span></span><br><span class="line">  <span class="keyword">var</span> websocket = <span class="keyword">new</span> WebSocket();</span><br><span class="line">  websocket.setSocket(socket);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="attr">hostname</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="attr">key</span>: fs.readFileSync(<span class="string">&#x27;./keys/client.key&#x27;</span>),</span><br><span class="line">  <span class="attr">cert</span>: fs.readFileSync(<span class="string">&#x27;./keys/client.crt&#x27;</span>),</span><br><span class="line">  <span class="attr">ca</span>: [fs.readFileSync(<span class="string">&#x27;./keys/ca.crt&#x27;</span>)]</span><br><span class="line">&#125;;</span><br><span class="line">options.agent = <span class="keyword">new</span> https.Agent(options);</span><br><span class="line"><span class="keyword">var</span> req = https.request(options, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  res.setEncoding(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">req.end();</span><br><span class="line">req.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="为什么很多网站的静态资源使用独立的域名"><a href="#为什么很多网站的静态资源使用独立的域名" class="headerlink" title="为什么很多网站的静态资源使用独立的域名"></a>为什么很多网站的静态资源使用独立的域名</h2><ul>
<li>静态资源是不在意 cookie 的，使用独立域名可以避免发送 cookie</li>
<li>可以突破浏览器下载线程数量的限制，因为域名不同，可以将下载线程数翻倍。</li>
</ul>
<h2 id="Node-单进程单线程的弊端"><a href="#Node-单进程单线程的弊端" class="headerlink" title="Node 单进程单线程的弊端"></a>Node 单进程单线程的弊端</h2><ul>
<li>没有充分利用多核 CPU。</li>
<li>进程的健壮性和稳定性问题：一旦单线程删抛出的异常没有被捕获，将引起整个进程的崩溃。</li>
</ul>
<blockquote>
<p>严格来说，Node 并非是真正的单线程架构。Node 本身有 IO 线程存在，这些 IO 线程由底层的 libuv 处理。这部分线程对于 JS 开发者来说是透明的，只在 C++ 扩展开发时才会关注到。JS 代码永远运行在 V8 上，是单线程的。</p>
</blockquote>
<h2 id="服务模型的变迁"><a href="#服务模型的变迁" class="headerlink" title="服务模型的变迁"></a>服务模型的变迁</h2><ol>
<li><code>同步</code>。</li>
<li><code>复制进程</code>。每个连接都需要一个进程来服务。</li>
<li><code>多线程</code>。一个线程服务一个请求。</li>
<li><code>事件驱动</code>。</li>
</ol>
<h2 id="node-多进程"><a href="#node-多进程" class="headerlink" title="node 多进程"></a>node 多进程</h2><p>面对单进程单线程对多核使用不足的问题，Node 的解决方案是：<code>启动多进程</code>。理想状态下是每个进程各自利用一个 CPU，实现多核 CPU 的利用。</p>
<p>Node 提供了 child_process 模块来创建子进程，方法有：</p>
<ul>
<li><strong>exec</strong>：child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</li>
<li><strong>execFile</strong>：启动一个子进程来执行可执行文件。如果该文件是 JS 文件，必须在首行添加 <code>#!/usr/bin/env node</code></li>
<li><strong>spawn</strong>：child_process.spawn 使用指定的命令行参数创建新进程。</li>
<li><strong>fork</strong>：child_process.fork 是 spawn() 的特殊形式，用于在子进程中运行的模块，如 <code>fork(&#39;./son.js&#39;)</code> 相当于 <code>spawn(&#39;node&#39;, [&#39;./son.js&#39;])</code> 。与 spawn 方法不同的是，fork 会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>回调/异常</th>
<th>进程类型</th>
<th>执行类型</th>
<th>可设置超时</th>
</tr>
</thead>
<tbody><tr>
<td>spawn()</td>
<td>N</td>
<td>任意</td>
<td>命令</td>
<td>N</td>
</tr>
<tr>
<td>exec()</td>
<td>Y</td>
<td>任意</td>
<td>命令</td>
<td>Y</td>
</tr>
<tr>
<td>execFile()</td>
<td>Y</td>
<td>任意</td>
<td>可执行文件</td>
<td>Y</td>
</tr>
<tr>
<td>fork()</td>
<td>N</td>
<td>Node</td>
<td>JS 文件</td>
<td>N</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">  res.end(<span class="string">&#x27;Hello World\n&#x27;</span>);</span><br><span class="line">&#125;).listen(<span class="built_in">Math</span>.round((<span class="number">1</span> + <span class="built_in">Math</span>.random()) * <span class="number">1000</span>), <span class="string">&#x27;127.0.0.1&#x27;</span>); </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).fork;</span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i++) &#123;</span><br><span class="line">  fork(<span class="string">&#x27;./worker.js&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220613140941528.png" alt="image-20220613140941528"></p>
<p>通过 fork() 复制的进程都是一个独立的进程，这个进程中有着独立而全新的 V8 实例。它需要至少 30ms 的启动时间和至少 10MB 的内存。</p>
<h3 id="Node-进程间通信"><a href="#Node-进程间通信" class="headerlink" title="Node 进程间通信"></a>Node 进程间通信</h3><p>创建子进程后，为了实现父子进程之间的通信，父进程和子进程之间会创建 IPC 通道，IPC 通道被抽象为 steam 对象。通过 IPC 通道，父子进程之间就能通过 message 和 send 传递消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> n = cp.fork(__dirname + <span class="string">&#x27;/sub.js&#x27;</span>);</span><br><span class="line">n.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;PARENT got message:&#x27;</span>, m);</span><br><span class="line">&#125;);</span><br><span class="line">n.send(&#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sub.js</span></span><br><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;CHILD got message:&#x27;</span>, m);</span><br><span class="line">&#125;);</span><br><span class="line">process.send(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;); </span><br></pre></td></tr></table></figure>



<h3 id="进程间通信的原理"><a href="#进程间通信的原理" class="headerlink" title="进程间通信的原理"></a>进程间通信的原理</h3><p>实现进程间通信的技术有很多，比如命名管道、匿名管道、socke、信号量、共享内存、消息队列、Domain Socket 等。</p>
<p>Node 中实现 IPC 通道的是 <code>管道(pipe)</code>。windows 下由命名管道实现，*nix 系统由 Unix Domain Socket 实现。</p>
<p><img src="/images/image-20220613153840296.png" alt="image-20220613153840296"></p>
<p>父进程在实际创建子进程之前，会创建 IPC 通道并监听它，然后才会创建子子进程，并且通过环境变量(<code>NODE_CHANNEL_FD</code>)告诉子进程这个 IPC 通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的 IPC 通道，从而完成父子进程之间的连接。</p>
<p><img src="/images/image-20220613154136639.png" alt="image-20220613154136639"></p>
<h3 id="句柄传递"><a href="#句柄传递" class="headerlink" title="句柄传递"></a>句柄传递</h3><p>就像上面说的，管道在 unix 系统由 Unix Domain Socket 实现。在一个主机启动多个服务器进程，让这些进程监听同一个端口号是不可能的 ，这是因为服务器的套接字文件描述符不相同，一个 socket 一个描述符只能用一个端口。</p>
<p>怎么解决端口占用问题？此时可以使用代理：<strong>主进程监听主端口（80），主进程接受所有的网络请求，再讲这些请求分别代理到不同的进程上</strong>。</p>
<p><img src="/images/image-20220613155309639.png" alt="image-20220613155309639"></p>
<p>但是使用代理的话，会消耗多一倍的端口。</p>
<p>node 为了解决这个问题加了一个<strong>进程间发送句柄</strong>的功能。send() 方法不仅可以发送信息还可以发送句柄，句柄 (文件描述符) 其实是<strong>指针</strong>，指向内核中的文件信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="string">&#x27;use stirct&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; createServer &#125; = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer()</span><br><span class="line"><span class="keyword">const</span> child = fork(<span class="string">&#x27;./child.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  child.send(<span class="string">&#x27;socket&#x27;</span>, socket)</span><br><span class="line">&#125;)</span><br><span class="line">.listen(<span class="number">1337</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message, socket</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (message === <span class="string">&#x27;socket&#x27;</span>) &#123;</span><br><span class="line">    socket.end(<span class="string">&#x27;Child handled it.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:1337</span><br><span class="line">Child handled it.</span><br></pre></td></tr></table></figure>



<h3 id="句柄传递的原理"><a href="#句柄传递的原理" class="headerlink" title="句柄传递的原理"></a>句柄传递的原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> child1 = cp.fork(<span class="string">&#x27;child.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> child2 = cp.fork(<span class="string">&#x27;child.js&#x27;</span>);</span><br><span class="line"><span class="comment">// Open up the server object and send the handle</span></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>).createServer();</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  child1.send(<span class="string">&#x27;server&#x27;</span>, server);</span><br><span class="line">  child2.send(<span class="string">&#x27;server&#x27;</span>, server);</span><br><span class="line">  <span class="comment">// 关掉</span></span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">  res.end(<span class="string">&#x27;handled by child, pid is &#x27;</span> + process.pid + <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, tcp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">&#x27;server&#x27;</span>) &#123;</span><br><span class="line">    tcp.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">      server.emit(<span class="string">&#x27;connection&#x27;</span>, socket);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &quot;http://127.0.0.1:1337/&quot;</span><br><span class="line">handled by child, pid is 24852</span><br><span class="line">$ curl &quot;http://127.0.0.1:1337/&quot;</span><br><span class="line">handled by child, pid is 24851 </span><br></pre></td></tr></table></figure>

<p>首先，主进程将请求发送给工作进程：</p>
<p><img src="/images/image-20220613161744840.png" alt="image-20220613161744840"></p>
<p>主进程发送完句柄柄关闭监听之后：</p>
<p><img src="/images/image-20220613161820522.png" alt="image-20220613161820522"></p>
<p>send() 方法将消息发送到 IPC 管道前，将消息组装成两个对象，一个参数是 handle，另一个是 message。</p>
<p>message 参数如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  cmd: <span class="string">&quot;NODE_HANDLE&quot;</span>,</span><br><span class="line">  type: <span class="string">&quot;net.Server&quot;</span>,</span><br><span class="line">  msg: message,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送到 IPC 管道中的实际上是我们要发送的句柄文件描述符</strong>。message 对象在写入到 IPC 管道时也会通过 <code>JSON.stringify()</code> 进行序列化，所以最终发送到 IPC 通道中的信息到是字符串。</p>
<p>连接了 IPC 通道的子进程可以读取到父进程发来的消息，将字符串通过 JSON.parse() 解析还原为对象后，才触发 message 事件将消息体传递给应用层。</p>
<p><img src="/images/image-20220613211523218.png" alt="image-20220613211523218"></p>
<h2 id="cluster-模块"><a href="#cluster-模块" class="headerlink" title="cluster 模块"></a>cluster 模块</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cluster.js</span></span><br><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">  <span class="attr">exec</span>: <span class="string">&quot;worker.js&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i++) &#123;</span><br><span class="line">  cluster.fork();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> numCPUs = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="comment">// Fork workers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line">  cluster.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">worker, code, signal</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;worker &#x27;</span> + worker.process.pid + <span class="string">&#x27; died&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Workers can share any TCP connection</span></span><br><span class="line">  <span class="comment">// In this case its a HTTP server</span></span><br><span class="line">  http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line">assert.equal(<span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">100</span>), <span class="number">100</span>); </span><br></pre></td></tr></table></figure>

<p>assert 模块常用方法：</p>
<ul>
<li>ok</li>
<li>equal</li>
<li>notEqual</li>
<li>deepEqual</li>
<li>notDeepEqual</li>
<li>strictEqual：相当于 <code>===</code></li>
<li>notStrictEqual</li>
<li>throws：代码块是否抛出异常</li>
<li>doesNotThrow</li>
<li>ifError：是否为一个假值(null、undefined、0、‘’、false)</li>
</ul>
<p>性能测试：</p>
<p>使用 suite 组织每组测试，在测试套件中调用 add() 来添加被测试的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Benchmark = <span class="built_in">require</span>(<span class="string">&#x27;benchmark&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> suite = <span class="keyword">new</span> Benchmark.Suite();</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">suite.add(<span class="string">&#x27;nativeMap&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(callback);</span><br><span class="line">&#125;).add(<span class="string">&#x27;customMap&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    ret.push(callback(arr[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;).on(<span class="string">&#x27;cycle&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target));</span><br><span class="line">&#125;).on(<span class="string">&#x27;complete&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Fastest is &#x27;</span> + <span class="built_in">this</span>.filter(<span class="string">&#x27;fastest&#x27;</span>).pluck(<span class="string">&#x27;name&#x27;</span>));</span><br><span class="line">&#125;).run(); </span><br></pre></td></tr></table></figure>



<h2 id="web-项目常用的目录结构"><a href="#web-项目常用的目录结构" class="headerlink" title="web 项目常用的目录结构"></a>web 项目常用的目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── History.md   // 项目改动历史</span><br><span class="line">├── INSTALL.md   // 安装说明</span><br><span class="line">├── Makefile     // Makefile文件</span><br><span class="line">├── benchmark    // 基准测试</span><br><span class="line">├── controllers  // 控制器</span><br><span class="line">├── lib          // 没有模块化的文件目录</span><br><span class="line">├── middlewares  // 中间件</span><br><span class="line">├── package.json // 包描述文件，项目依赖配置等</span><br><span class="line">├── proxy        // 数据代理目录，类似MVC中的M</span><br><span class="line">├── test         // 测试目录</span><br><span class="line">├── tools        // 工具目录</span><br><span class="line">├── views        // 视图目录</span><br><span class="line">├── routes.js    // 路由注册表</span><br><span class="line">├── dispatch.js  // 多进程管理</span><br><span class="line">├── README.md    // 项目说明文件</span><br><span class="line">├── assets       // 静态文件目录</span><br><span class="line">├── assets.json  // 静态文件与CDN路径的映射文件</span><br><span class="line">├── bin          // 可执行脚本</span><br><span class="line">├── config       // 配置目录</span><br><span class="line">├── logs         // 日志目录</span><br><span class="line">└── app.js       // 工作进程</span><br></pre></td></tr></table></figure>



</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>