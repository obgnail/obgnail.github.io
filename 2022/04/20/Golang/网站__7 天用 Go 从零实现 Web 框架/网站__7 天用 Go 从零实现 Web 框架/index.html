<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;http-Handler&quot;&gt;&lt;a href=&quot;#http-Handler&quot; class=&quot;headerlink&quot; title=&quot;http.Handler&quot;&gt;&lt;/a&gt;http.Handler&lt;/h2&gt;&lt;p&gt;标准库提供的 API 如下："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>7 天用 Go 从零实现 Web 框架 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-04-20</div></div></div><div class="container post-header"><h1>7 天用 Go 从零实现 Web 框架</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#http-Handler"><span class="toc-number">1.</span> <span class="toc-text">http.Handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87-Context"><span class="toc-number">2.</span> <span class="toc-text">上下文 Context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91%E8%B7%AF%E7%94%B1-Router"><span class="toc-number">3.</span> <span class="toc-text">前缀树路由 Router</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie-%E6%A0%91%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">Trie 树简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie-%E6%A0%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">Trie 树实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Router"><span class="toc-number">3.3.</span> <span class="toc-text">Router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-%E4%B8%8E-handle-%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">Context 与 handle 的变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%8E%A7%E5%88%B6-Group"><span class="toc-number">4.</span> <span class="toc-text">分组控制 Group</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%B5%8C%E5%A5%97"><span class="toc-number">4.1.</span> <span class="toc-text">分组嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Demo"><span class="toc-number">4.2.</span> <span class="toc-text">使用 Demo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6-Middleware"><span class="toc-number">5.</span> <span class="toc-text">中间件 Middleware</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-HTML-Template"><span class="toc-number">6.</span> <span class="toc-text">模板 (HTML Template)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6-Serve-Static-Files"><span class="toc-number">6.1.</span> <span class="toc-text">静态文件 (Serve Static Files)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93"><span class="toc-number">6.2.</span> <span class="toc-text">HTML 模板渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D-Panic-Recover"><span class="toc-number">7.</span> <span class="toc-text">错误恢复 (Panic Recover)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="http-Handler"><a href="#http-Handler" class="headerlink" title="http.Handler"></a>http.Handler</h2><p>标准库提供的 API 如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;:9999&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler echoes r.URL.Path</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler echoes r.URL.Header</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们希望的 API 如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;gee&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gee.New()</span><br><span class="line">	r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> k, v := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">			fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc defines the request handler used by gee</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine implement the interface of ServeHTTP</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	router <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Engine&#123;router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">addRoute</span><span class="params">(method <span class="keyword">string</span>, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">	log.Printf(<span class="string">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class="line">	engine.router[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET defines the method to add GET request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">GET</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	engine.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST defines the method to add POST request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">POST</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run defines the method to start a http server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">Run</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	key := req.Method + <span class="string">&quot;-&quot;</span> + req.URL.Path</span><br><span class="line">	<span class="keyword">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class="line">		handler(w, req)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="上下文-Context"><a href="#上下文-Context" class="headerlink" title="上下文 Context"></a>上下文 Context</h2><p>我们期待的 API：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gee.New()</span><br><span class="line">	r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// expect /hello?name=geektutu</span></span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Query(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gee.H&#123;</span><br><span class="line">			<span class="string">&quot;username&quot;</span>: c.PostForm(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">			<span class="string">&quot;password&quot;</span>: c.PostForm(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// origin objects</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line">	<span class="comment">// request info</span></span><br><span class="line">	Path   <span class="keyword">string</span></span><br><span class="line">	Method <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// response info</span></span><br><span class="line">	StatusCode <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContext</span><span class="params">(w http.ResponseWriter, req *http.Request)</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">		Writer: w,</span><br><span class="line">		Req:    req,</span><br><span class="line">		Path:   req.URL.Path,</span><br><span class="line">		Method: req.Method,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">PostForm</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Req.FormValue(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Query</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Req.URL.Query().Get(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Status</span><span class="params">(code <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	c.StatusCode = code</span><br><span class="line">	c.Writer.WriteHeader(code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">SetHeader</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	c.Writer.Header().Set(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">String</span><span class="params">(code <span class="keyword">int</span>, format <span class="keyword">string</span>, values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	c.Writer.Write([]<span class="keyword">byte</span>(fmt.Sprintf(format, values...)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">JSON</span><span class="params">(code <span class="keyword">int</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	encoder := json.NewEncoder(c.Writer)</span><br><span class="line">	<span class="keyword">if</span> err := encoder.Encode(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(c.Writer, err.Error(), <span class="number">500</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Data</span><span class="params">(code <span class="keyword">int</span>, data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	c.Status(code)</span><br><span class="line">	c.Writer.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">HTML</span><span class="params">(code <span class="keyword">int</span>, html <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	c.Writer.Write([]<span class="keyword">byte</span>(html))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码最开头，给 <code>map[string]interface&#123;&#125;</code> 起了一个别名 <code>gee.H</code>，构建 JSON 数据时，显得更简洁。</li>
<li><code>Context</code> 目前只包含了 <code>http.ResponseWriter</code> 和 <code>*http.Request</code>，另外提供了对 Method 和 Path 这两个常用属性的直接访问。</li>
<li>提供了访问 Query 和 PostForm 参数的方法。</li>
<li>提供了快速构造 String/Data/JSON/HTML 响应的方法。</li>
</ul>
<h2 id="前缀树路由-Router"><a href="#前缀树路由-Router" class="headerlink" title="前缀树路由 Router"></a>前缀树路由 Router</h2><ul>
<li>使用 Trie 树实现动态路由 (dynamic route) 解析。</li>
<li>支持两种模式<code>:name</code> 和 <code>*filepath</code></li>
</ul>
<h3 id="Trie-树简介"><a href="#Trie-树简介" class="headerlink" title="Trie 树简介"></a>Trie 树简介</h3><p>想支持类似于 <code>/hello/:name</code> 这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而非某一条固定的路由。例如 <code>/hello/:name</code>，可以匹配 <code>/hello/geektutu</code>、<code>hello/jack</code> 等。</p>
<p>动态路由有很多种实现方式，支持的规则、性能等有很大的差异。例如开源的路由实现 <code>gorouter</code> 支持在路由规则中嵌入正则表达式，例如 <code>/p/[0-9A-Za-z]+</code>，即路径中的参数仅匹配数字和字母；另一个开源实现 <code>httprouter</code> 就不支持正则表达式。著名的 Web 开源框架 <code>gin</code> 在早期的版本，并没有实现自己的路由，而是直接使用了 <code>httprouter</code>，后来不知道什么原因，放弃了 <code>httprouter</code>，自己实现了一个版本。</p>
<p><img src="/images/trie_eg.jpg" alt="trie tree"></p>
<p>实现动态路由最常用的数据结构，被称为 <code>前缀树</code> (Trie 树)。看到名字你大概也能知道前缀树长啥样了：每一个节点的所有的子节点都拥有相同的前缀。这种结构非常适用于路由匹配，比如我们定义了如下路由规则：</p>
<ul>
<li>/:lang/doc</li>
<li>/:lang/tutorial</li>
<li>/:lang/intro</li>
<li>/about</li>
<li>/p/blog</li>
<li>/p/related</li>
</ul>
<p>我们用前缀树来表示，是这样的。</p>
<p><img src="/images/trie_router.jpg" alt="trie tree"></p>
<p>HTTP 请求的路径恰好是由 <code>/</code> 分隔的多段构成的，因此，每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。</p>
<p>接下来我们实现的动态路由具备以下两个功能。</p>
<ul>
<li>参数匹配<code>:</code>。例如 <code>/p/:lang/doc</code>，可以匹配 <code>/p/c/doc</code> 和 <code>/p/go/doc</code>。</li>
<li>通配 <code>*</code>。例如 <code>/static/*filepath</code>，可以匹配 <code>/static/fav.ico</code>，也可以匹配 <code>/static/js/jQuery.js</code>，这种模式常用于静态服务器，能够递归地匹配子路径。</li>
</ul>
<h3 id="Trie-树实现"><a href="#Trie-树实现" class="headerlink" title="Trie 树实现"></a>Trie 树实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	pattern  <span class="keyword">string</span>  <span class="comment">// 待匹配路由，例如 /p/:lang</span></span><br><span class="line">	part     <span class="keyword">string</span>  <span class="comment">// 路由中的一部分，例如 :lang</span></span><br><span class="line">	children []*node <span class="comment">// 子节点，例如 [doc, tutorial, intro]</span></span><br><span class="line">	isWild   <span class="keyword">bool</span>    <span class="comment">// 是否精确匹配，part 含有 : 或 * 时为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与普通的树不同，为了实现动态路由匹配，加上了 <code>isWild</code> 这个参数。即当我们匹配 <code>/p/go/doc/</code> 这个路由时，第一层节点，<code>p</code> 精准匹配到了 <code>p</code>，第二层节点，<code>go</code> 模糊匹配到<code>:lang</code>，那么将会把 <code>lang</code> 这个参数赋值为 <code>go</code>，继续下一层匹配。我们将匹配的逻辑，包装为一个辅助函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个匹配成功的节点，用于插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">matchChild</span><span class="params">(part <span class="keyword">string</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		<span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">			<span class="keyword">return</span> child</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有匹配成功的节点，用于查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">matchChildren</span><span class="params">(part <span class="keyword">string</span>)</span> []*<span class="title">node</span></span> &#123;</span><br><span class="line">	nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">		<span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, child)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于路由来说，最重要的当然是注册与匹配了。</p>
<p>开发服务时，注册路由规则，映射 handler；访问时，匹配路由规则，查找到对应的 handler。因此，Trie 树需要支持节点的插入与查询。</p>
<p>插入功能很简单，递归查找每一层的节点，如果没有匹配到当前 <code>part</code> 的节点，则新建一个，有一点需要注意，<code>/p/:lang/doc</code> 只有在第三层节点，即 <code>doc</code> 节点，<code>pattern</code> 才会设置为 <code>/p/:lang/doc</code>。<code>p</code> 和<code>:lang</code> 节点的 <code>pattern</code> 属性皆为空。因此，当匹配结束时，我们可以使用 <code>n.pattern == &quot;&quot;</code> 来判断路由规则是否匹配成功。例如，<code>/p/python</code> 虽能成功匹配到<code>:lang</code>，但<code>:lang</code> 的 <code>pattern</code> 值为空，因此匹配失败。</p>
<p>查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到了 <code>*</code>，匹配失败，或者匹配到了第 <code>len(parts)</code> 层节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">insert</span><span class="params">(pattern <span class="keyword">string</span>, parts []<span class="keyword">string</span>, height <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) == height &#123;</span><br><span class="line">		n.pattern = pattern</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	part := parts[height]</span><br><span class="line">	child := n.matchChild(part)</span><br><span class="line">	<span class="keyword">if</span> child == <span class="literal">nil</span> &#123;</span><br><span class="line">		child = &amp;node&#123;part: part, isWild: part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> || part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>&#125;</span><br><span class="line">		n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">	&#125;</span><br><span class="line">	child.insert(pattern, parts, height+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">search</span><span class="params">(parts []<span class="keyword">string</span>, height <span class="keyword">int</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> n.pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	part := parts[height]</span><br><span class="line">	children := n.matchChildren(part)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> children &#123;</span><br><span class="line">		result := child.search(parts, height+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> result</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>Trie 树的插入与查找都成功实现了，接下来我们将 Trie 树应用到路由中去吧。我们使用 roots 来存储每种请求方式的 Trie 树根节点。使用 handlers 存储每种请求方式的 HandlerFunc 。getRoute 函数中，还解析了<code>:</code> 和 <code>*</code> 两种匹配符的参数，返回一个 map 。例如 <code>/p/go/doc</code> 匹配到 <code>/p/:lang/doc</code>，解析结果为：<code>&#123;lang: &quot;go&quot;&#125;</code>，<code>/static/css/geektutu.css</code> 匹配到 <code>/static/*filepath</code>，解析结果为 <code>&#123;filepath: &quot;css/geektutu.css&quot;&#125;</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">	roots    <span class="keyword">map</span>[<span class="keyword">string</span>]*node</span><br><span class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// roots key eg, roots[&#x27;GET&#x27;] roots[&#x27;POST&#x27;]</span></span><br><span class="line"><span class="comment">// handlers key eg, handlers[&#x27;GET-/p/:lang/doc&#x27;], handlers[&#x27;POST-/p/book&#x27;]</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRouter</span><span class="params">()</span> *<span class="title">router</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">		roots:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*node),</span><br><span class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only one * is allowed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePattern</span><span class="params">(pattern <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	vs := strings.Split(pattern, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">	parts := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> vs &#123;</span><br><span class="line">		<span class="keyword">if</span> item != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			parts = <span class="built_in">append</span>(parts, item)</span><br><span class="line">			<span class="keyword">if</span> item[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">addRoute</span><span class="params">(method <span class="keyword">string</span>, pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	parts := parsePattern(pattern)</span><br><span class="line"></span><br><span class="line">	key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">	_, ok := r.roots[method]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		r.roots[method] = &amp;node&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r.roots[method].insert(pattern, parts, <span class="number">0</span>)</span><br><span class="line">	r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">getRoute</span><span class="params">(method <span class="keyword">string</span>, path <span class="keyword">string</span>)</span> <span class="params">(*node, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	searchParts := parsePattern(path)</span><br><span class="line">	params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	root, ok := r.roots[method]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := root.search(searchParts, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		parts := parsePattern(n.pattern)</span><br><span class="line">		<span class="keyword">for</span> index, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">			<span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123;</span><br><span class="line">				params[part[<span class="number">1</span>:]] = searchParts[index]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">len</span>(part) &gt; <span class="number">1</span> &#123;</span><br><span class="line">				params[part[<span class="number">1</span>:]] = strings.Join(searchParts[index:], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n, params</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Context-与-handle-的变化"><a href="#Context-与-handle-的变化" class="headerlink" title="Context 与 handle 的变化"></a>Context 与 handle 的变化</h3><p>在 HandlerFunc 中，希望能够访问到解析的参数，因此，需要对 Context 对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到 <code>Params</code> 中，通过 <code>c.Param(&quot;lang&quot;)</code> 的方式获取到对应的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// origin objects</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line">	<span class="comment">// request info</span></span><br><span class="line">	Path   <span class="keyword">string</span></span><br><span class="line">	Method <span class="keyword">string</span></span><br><span class="line">	Params <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// response info</span></span><br><span class="line">	StatusCode <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Param</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	value, _ := c.Params[key]</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">handle</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Params = params</span><br><span class="line">		key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">		r.handlers[key](c)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>router.go</code> 的变化比较小，比较重要的一点是，在调用匹配到的 <code>handler</code> 前，将解析出来的路由参数赋值给了 <code>c.Params</code>。这样就能够在 <code>handler</code> 中，通过 <code>Context</code> 对象访问到具体的值了。</p>
<p>测试用例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTestRouter</span><span class="params">()</span> *<span class="title">router</span></span> &#123;</span><br><span class="line">	r := newRouter()</span><br><span class="line">	r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/hello/:name&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/hello/b/c&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/hi/:name&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	r.addRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/assets/*filepath&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestParsePattern</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	ok := reflect.DeepEqual(parsePattern(<span class="string">&quot;/p/:name&quot;</span>), []<span class="keyword">string</span>&#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;:name&quot;</span>&#125;)</span><br><span class="line">	ok = ok &amp;&amp; reflect.DeepEqual(parsePattern(<span class="string">&quot;/p/*&quot;</span>), []<span class="keyword">string</span>&#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;*&quot;</span>&#125;)</span><br><span class="line">	ok = ok &amp;&amp; reflect.DeepEqual(parsePattern(<span class="string">&quot;/p/*name/*&quot;</span>), []<span class="keyword">string</span>&#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;*name&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;test parsePattern failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetRoute</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	r := newTestRouter()</span><br><span class="line">	n, ps := r.getRoute(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/hello/geektutu&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;nil shouldn&#x27;t be returned&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n.pattern != <span class="string">&quot;/hello/:name&quot;</span> &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;should match /hello/:name&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ps[<span class="string">&quot;name&quot;</span>] != <span class="string">&quot;geektutu&quot;</span> &#123;</span><br><span class="line">		t.Fatal(<span class="string">&quot;name should be equal to &#x27;geektutu&#x27;&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;matched path: %s, params[&#x27;name&#x27;]: %s\n&quot;</span>, n.pattern, ps[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分组控制-Group"><a href="#分组控制-Group" class="headerlink" title="分组控制 Group"></a>分组控制 Group</h2><h3 id="分组嵌套"><a href="#分组嵌套" class="headerlink" title="分组嵌套"></a>分组嵌套</h3><p>一个 Group 对象需要具备哪些属性呢？首先是前缀 (prefix)，比如 <code>/</code>，或者 <code>/api</code>；要支持分组嵌套，那么需要知道当前分组的父亲 (parent) 是谁；当然了，按照我们一开始的分析，中间件是应用在分组上的，那还需要存储应用在该分组上的中间件 (middlewares)。还记得，我们之前调用函数 <code>(*Engine).addRoute()</code> 来映射所有的路由规则和 Handler 。如果 Group 对象需要直接映射路由规则的话，比如我们想在使用框架时，这么调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r := gee.New()</span><br><span class="line">v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">v1.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么 Group 对象，还需要有访问 <code>Router</code> 的能力，为了方便，我们可以在 Group 中，保存一个指针，指向 <code>Engine</code>，整个框架的所有资源都是由 <code>Engine</code> 统一协调的，那么就可以通过 <code>Engine</code> 间接地访问各种接口了。</p>
<p>所以，最后的 Group 的定义是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	prefix      <span class="keyword">string</span></span><br><span class="line">	middlewares []HandlerFunc <span class="comment">// support middleware</span></span><br><span class="line">	parent      *RouterGroup  <span class="comment">// support nesting</span></span><br><span class="line">	engine      *Engine       <span class="comment">// all groups share a Engine instance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以进一步地抽象，将 <code>Engine</code> 作为最顶层的分组，也就是说 <code>Engine</code> 拥有 <code>RouterGroup</code> 所有的能力。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	*RouterGroup</span><br><span class="line">	router *router</span><br><span class="line">	groups []*RouterGroup <span class="comment">// store all groups</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们就可以将和路由有关的函数，都交给 <code>RouterGroup</code> 实现了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">	engine := &amp;Engine&#123;router: newRouter()&#125;</span><br><span class="line">	engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;</span><br><span class="line">	engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;</span><br><span class="line">	<span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Group is defined to create a new RouterGroup</span></span><br><span class="line"><span class="comment">// remember all groups share the same Engine instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Group</span><span class="params">(prefix <span class="keyword">string</span>)</span> *<span class="title">RouterGroup</span></span> &#123;</span><br><span class="line">	engine := group.engine</span><br><span class="line">	newGroup := &amp;RouterGroup&#123;</span><br><span class="line">		prefix: group.prefix + prefix,</span><br><span class="line">		parent: group,</span><br><span class="line">		engine: engine,</span><br><span class="line">	&#125;</span><br><span class="line">	engine.groups = <span class="built_in">append</span>(engine.groups, newGroup)</span><br><span class="line">	<span class="keyword">return</span> newGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">addRoute</span><span class="params">(method <span class="keyword">string</span>, comp <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	pattern := group.prefix + comp</span><br><span class="line">	log.Printf(<span class="string">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class="line">	group.engine.router.addRoute(method, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET defines the method to add GET request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">GET</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	group.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST defines the method to add POST request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">POST</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class="line">	group.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以仔细观察下 <code>addRoute</code> 函数，调用了 <code>group.engine.router.addRoute</code> 来实现了路由的映射。由于 <code>Engine</code> 从某种意义上继承了 <code>RouterGroup</code> 的所有属性和方法，因为 (*Engine).engine 是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由。</p>
<h3 id="使用-Demo"><a href="#使用-Demo" class="headerlink" title="使用 Demo"></a>使用 Demo</h3><p>测试框架的 Demo 就可以这样写了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gee.New()</span><br><span class="line">	r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Index Page&lt;/h1&gt;&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">			c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		v1.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">			<span class="comment">// expect /hello?name=geektutu</span></span><br><span class="line">			c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Query(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	v2 := r.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		v2.GET(<span class="string">&quot;/hello/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">			<span class="comment">// expect /hello/geektutu</span></span><br><span class="line">			c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Param(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">		&#125;)</span><br><span class="line">		v2.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gee.H&#123;</span><br><span class="line">				<span class="string">&quot;username&quot;</span>: c.PostForm(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">				<span class="string">&quot;password&quot;</span>: c.PostForm(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 curl 简单测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&quot;http://localhost:9999/v1/hello?name=geektutu&quot;</span></span><br><span class="line">hello geektutu, you<span class="string">&#x27;re at /v1/hello</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ curl &quot;http://localhost:9999/v2/hello/geektutu&quot;</span></span><br><span class="line"><span class="string">hello geektutu, you&#x27;</span>re at /hello/geektutu</span><br></pre></td></tr></table></figure>



<h2 id="中间件-Middleware"><a href="#中间件-Middleware" class="headerlink" title="中间件 Middleware"></a>中间件 Middleware</h2><p>中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件，<code>c.Next()</code> 表示等待执行其他的中间件或用户的 <code>Handler</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger</span><span class="params">()</span> <span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Start timer</span></span><br><span class="line">		t := time.Now()</span><br><span class="line">		<span class="comment">// Process request</span></span><br><span class="line">		c.Next()</span><br><span class="line">		<span class="comment">// Calculate resolution time</span></span><br><span class="line">		log.Printf(<span class="string">&quot;[%d] %s in %v&quot;</span>, c.StatusCode, c.Req.RequestURI, time.Since(t))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，支持设置多个中间件，依次进行调用。</p>
<p>给 <code>Context</code> 添加了 2 个参数，定义了 <code>Next</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// origin objects</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line">	<span class="comment">// request info</span></span><br><span class="line">	Path   <span class="keyword">string</span></span><br><span class="line">	Method <span class="keyword">string</span></span><br><span class="line">	Params <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// response info</span></span><br><span class="line">	StatusCode <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// middleware</span></span><br><span class="line">	handlers []HandlerFunc</span><br><span class="line">	index    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContext</span><span class="params">(w http.ResponseWriter, req *http.Request)</span> *<span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">		Path:   req.URL.Path,</span><br><span class="line">		Method: req.Method,</span><br><span class="line">		Req:    req,</span><br><span class="line">		Writer: w,</span><br><span class="line">		index:  <span class="number">-1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Next</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.index++</span><br><span class="line">	s := <span class="built_in">len</span>(c.handlers)</span><br><span class="line">	<span class="keyword">for</span> ; c.index &lt; s; c.index++ &#123;</span><br><span class="line">		c.handlers[c.index](c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>index</code> 是记录当前执行到第几个中间件，当在中间件中调用 <code>Next</code> 方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在 <code>Next</code> 方法之后定义的部分。如果我们将用户在映射路由时定义的 <code>Handler</code> 添加到 <code>c.handlers</code> 列表中，结果会怎么样呢？想必你已经猜到了。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>定义 <code>Use</code> 函数，将中间件应用到某个 Group 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use is defined to add middleware to the group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Use</span><span class="params">(middlewares ...HandlerFunc)</span></span> &#123;</span><br><span class="line">	group.middlewares = <span class="built_in">append</span>(group.middlewares, middlewares...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> middlewares []HandlerFunc</span><br><span class="line">	<span class="keyword">for</span> _, group := <span class="keyword">range</span> engine.groups &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(req.URL.Path, group.prefix) &#123;</span><br><span class="line">			middlewares = <span class="built_in">append</span>(middlewares, group.middlewares...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c := newContext(w, req)</span><br><span class="line">	c.handlers = middlewares</span><br><span class="line">	engine.router.handle(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServeHTTP 函数也有变化，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过 URL 的前缀来判断。得到中间件列表后，赋值给 <code>c.handlers</code></p>
<p>handle 函数中，将从路由匹配得到的 Handler 添加到 <code>c.handlers</code> 列表中，执行 <code>c.Next()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span> <span class="title">handle</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">	n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">		key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">		c.Params = params</span><br><span class="line">		c.handlers = <span class="built_in">append</span>(c.handlers, r.handlers[key])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.handlers = <span class="built_in">append</span>(c.handlers, <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">			c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	c.Next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Demo：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onlyForV2</span><span class="params">()</span> <span class="title">gee</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Start timer</span></span><br><span class="line">		t := time.Now()</span><br><span class="line">		<span class="comment">// if a server error occurred</span></span><br><span class="line">		c.Fail(<span class="number">500</span>, <span class="string">&quot;Internal Server Error&quot;</span>)</span><br><span class="line">		<span class="comment">// Calculate resolution time</span></span><br><span class="line">		log.Printf(<span class="string">&quot;[%d] %s in %v for group v2&quot;</span>, c.StatusCode, c.Req.RequestURI, time.Since(t))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gee.New()</span><br><span class="line">	r.Use(gee.Logger()) <span class="comment">// global midlleware</span></span><br><span class="line">	r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	v2 := r.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">	v2.Use(onlyForV2()) <span class="comment">// v2 group middleware</span></span><br><span class="line">	&#123;</span><br><span class="line">		v2.GET(<span class="string">&quot;/hello/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">			<span class="comment">// expect /hello/geektutu</span></span><br><span class="line">			c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Param(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="模板-HTML-Template"><a href="#模板-HTML-Template" class="headerlink" title="模板 (HTML Template)"></a>模板 (HTML Template)</h2><ul>
<li>实现静态资源服务 (Static Resource)。</li>
<li>支持 HTML 模板渲染。</li>
</ul>
<h3 id="静态文件-Serve-Static-Files"><a href="#静态文件-Serve-Static-Files" class="headerlink" title="静态文件 (Serve Static Files)"></a>静态文件 (Serve Static Files)</h3><p>将所有的静态文件放在 <code>/usr/web</code> 目录下，那么 <code>filepath</code> 的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create static handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">createStaticHandler</span><span class="params">(relativePath <span class="keyword">string</span>, fs http.FileSystem)</span> <span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	absolutePath := path.Join(group.prefix, relativePath)</span><br><span class="line">	fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">		file := c.Param(<span class="string">&quot;filepath&quot;</span>)</span><br><span class="line">		<span class="comment">// Check if file exists and/or if we have permission to access it</span></span><br><span class="line">		<span class="keyword">if</span> _, err := fs.Open(file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.Status(http.StatusNotFound)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fileServer.ServeHTTP(c.Writer, c.Req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serve static files</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Static</span><span class="params">(relativePath <span class="keyword">string</span>, root <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	handler := group.createStaticHandler(relativePath, http.Dir(root))</span><br><span class="line">	urlPattern := path.Join(relativePath, <span class="string">&quot;/*filepath&quot;</span>)</span><br><span class="line">	<span class="comment">// Register GET handlers</span></span><br><span class="line">	group.GET(urlPattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们给 <code>RouterGroup</code> 添加了 2 个方法，<code>Static</code> 这个方法是暴露给用户的。用户可以将磁盘上的某个文件夹 <code>root</code> 映射到路由 <code>relativePath</code>。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r := gee.New()</span><br><span class="line">r.Static(<span class="string">&quot;/assets&quot;</span>, <span class="string">&quot;/usr/geektutu/blog/static&quot;</span>)</span><br><span class="line"><span class="comment">// 或相对路径 r.Static(&quot;/assets&quot;, &quot;./static&quot;)</span></span><br><span class="line">r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>用户访问 <code>localhost:9999/assets/js/geektutu.js</code>，最终返回 <code>/usr/geektutu/blog/static/js/geektutu.js</code>。</p>
<h3 id="HTML-模板渲染"><a href="#HTML-模板渲染" class="headerlink" title="HTML 模板渲染"></a>HTML 模板渲染</h3><p>Go 语言内置了 <code>text/template</code> 和 <code>html/template</code> 2 个模板标准库，其中 <a target="_blank" rel="noopener" href="https://golang.org/pkg/html/template/">html/template</a> 为 HTML 提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。gee 框架的模板渲染直接使用了 <code>html/template</code> 提供的能力。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	*RouterGroup</span><br><span class="line">	router        *router</span><br><span class="line">	groups        []*RouterGroup     <span class="comment">// store all groups</span></span><br><span class="line">	htmlTemplates *template.Template <span class="comment">// for html render</span></span><br><span class="line">	funcMap       template.FuncMap   <span class="comment">// for html render</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">SetFuncMap</span><span class="params">(funcMap template.FuncMap)</span></span> &#123;</span><br><span class="line">	engine.funcMap = funcMap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">LoadHTMLGlob</span><span class="params">(pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	engine.htmlTemplates = template.Must(template.New(<span class="string">&quot;&quot;</span>).Funcs(engine.funcMap).ParseGlob(pattern))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先为 Engine 示例添加了 <code>*template.Template</code> 和 <code>template.FuncMap</code> 对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p>
<p>另外，给用户分别提供了设置自定义渲染函数 <code>funcMap</code> 和加载模板的方法。</p>
<p>接下来，对原来的 <code>(*Context).HTML()</code> 方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// engine pointer</span></span><br><span class="line">	engine *Engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">HTML</span><span class="params">(code <span class="keyword">int</span>, name <span class="keyword">string</span>, data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">	c.Status(code)</span><br><span class="line">	<span class="keyword">if</span> err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Fail(<span class="number">500</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>Context</code> 中添加了成员变量 <code>engine *Engine</code>，这样就能够通过 Context 访问 Engine 中的 HTML 模板。实例化 Context 时，还需要给 <code>c.engine</code> 赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	c := newContext(w, req)</span><br><span class="line">	c.handlers = middlewares</span><br><span class="line">	c.engine = engine</span><br><span class="line">	engine.router.handle(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Demo</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatAsDate</span><span class="params">(t time.Time)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	year, month, day := t.Date()</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d-%02d-%02d&quot;</span>, year, month, day)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gee.New()</span><br><span class="line">	r.Use(gee.Logger())</span><br><span class="line">	r.SetFuncMap(template.FuncMap&#123;</span><br><span class="line">		<span class="string">&quot;FormatAsDate&quot;</span>: FormatAsDate,</span><br><span class="line">	&#125;)</span><br><span class="line">	r.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br><span class="line">	r.Static(<span class="string">&quot;/assets&quot;</span>, <span class="string">&quot;./static&quot;</span>)</span><br><span class="line"></span><br><span class="line">	stu1 := &amp;student&#123;Name: <span class="string">&quot;Geektutu&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line">	stu2 := &amp;student&#123;Name: <span class="string">&quot;Jack&quot;</span>, Age: <span class="number">22</span>&#125;</span><br><span class="line">	r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;css.tmpl&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">&quot;/students&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;arr.tmpl&quot;</span>, gee.H&#123;</span><br><span class="line">			<span class="string">&quot;title&quot;</span>:  <span class="string">&quot;gee&quot;</span>,</span><br><span class="line">			<span class="string">&quot;stuArr&quot;</span>: [<span class="number">2</span>]*student&#123;stu1, stu2&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/date&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;custom_func.tmpl&quot;</span>, gee.H&#123;</span><br><span class="line">			<span class="string">&quot;title&quot;</span>: <span class="string">&quot;gee&quot;</span>,</span><br><span class="line">			<span class="string">&quot;now&quot;</span>:   time.Date(<span class="number">2019</span>, <span class="number">8</span>, <span class="number">17</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="错误恢复-Panic-Recover"><a href="#错误恢复-Panic-Recover" class="headerlink" title="错误恢复 (Panic Recover)"></a>错误恢复 (Panic Recover)</h2><ul>
<li>实现错误处理机制。</li>
</ul>
<p>对一个 Web 框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p>
<p>我们添加一个非常简单的错误处理机制，即在此类错误发生时，向用户返回 Internal Server Error，并且在日志中打印必要的错误信息，方便进行错误定位。</p>
<p>我们之前实现了中间件机制，错误处理也可以作为一个中间件，增强 gee 框架的能力。</p>
<p>新增文件 gee/recovery.go，在这个文件中实现中间件 <code>Recovery</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recovery</span><span class="params">()</span> <span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				message := fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, err)</span><br><span class="line">				log.Printf(<span class="string">&quot;%s\n\n&quot;</span>, trace(message))</span><br><span class="line">				c.Fail(http.StatusInternalServerError, <span class="string">&quot;Internal Server Error&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">	engine := New()</span><br><span class="line">	engine.Use(Logger(), Recovery())</span><br><span class="line">	<span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Recovery</code> 的实现非常简单，使用 defer 挂载上错误恢复的函数，在这个函数中调用 *recover ()*，捕获 panic，并且将堆栈信息打印在日志中，向用户返回 Internal Server Error。</p>
<p>trace() 函数，这个函数是用来获取触发 panic 的堆栈信息，完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print stack trace for debug</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pcs [<span class="number">32</span>]<span class="keyword">uintptr</span></span><br><span class="line">	n := runtime.Callers(<span class="number">3</span>, pcs[:]) <span class="comment">// skip first 3 caller</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> str strings.Builder</span><br><span class="line">	str.WriteString(message + <span class="string">&quot;\nTraceback:&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, pc := <span class="keyword">range</span> pcs[:n] &#123;</span><br><span class="line">		fn := runtime.FuncForPC(pc)</span><br><span class="line">		file, line := fn.FileLine(pc)</span><br><span class="line">		str.WriteString(fmt.Sprintf(<span class="string">&quot;\n\t%s:%d&quot;</span>, file, line))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Demo</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;gee&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gee.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Hello Geektutu\n&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// index out of range for testing Recovery()</span></span><br><span class="line">	r.GET(<span class="string">&quot;/panic&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">		names := []<span class="keyword">string</span>&#123;<span class="string">&quot;geektutu&quot;</span>&#125;</span><br><span class="line">		c.String(http.StatusOK, names[<span class="number">100</span>])</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://geektutu.com/post/gee.html">7 天用 Go 从零实现 Web 框架 Gee 教程</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>