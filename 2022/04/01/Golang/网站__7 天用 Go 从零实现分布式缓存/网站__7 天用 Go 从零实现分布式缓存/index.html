<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;设计一个分布式缓存系统，需要考虑资源控制、淘汰策略、并发、分布式节点通信等各个方面的问题。而且，针对不同的应用场景，还需要在不同的特性之间权衡，例如，是否需要支持缓存更新？还是假定缓存在淘汰之前是不允许改变的。不同的权衡对应着不同的实现。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>7 天用 Go 从零实现分布式缓存 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-04-01</div></div></div><div class="container post-header"><h1>7 天用 Go 从零实现分布式缓存</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.</span> <span class="toc-text">LRU 缓存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">核心数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">2.2.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">2.3.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E-%E4%BF%AE%E6%94%B9"><span class="toc-number">2.4.</span> <span class="toc-text">新增 &#x2F; 修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">单机并发缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99"><span class="toc-number">3.1.</span> <span class="toc-text">支持并发读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84-Group"><span class="toc-number">3.2.</span> <span class="toc-text">主体结构 Group</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83-Getter"><span class="toc-number">3.2.1.</span> <span class="toc-text">回调 Getter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Group-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">Group 的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Group-%E7%9A%84-Get-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">Group 的 Get 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">4.</span> <span class="toc-text">HTTP 服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">5.</span> <span class="toc-text">一致性哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">数据倾斜问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.</span> <span class="toc-text">Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%8A%82%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">分布式节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1-PeerPicker"><span class="toc-number">6.2.</span> <span class="toc-text">抽象 PeerPicker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9%E4%B8%8E-HTTP-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.3.</span> <span class="toc-text">节点选择与 HTTP 客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">6.4.</span> <span class="toc-text">实现主流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">7.</span> <span class="toc-text">防止缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">7.1.</span> <span class="toc-text">缓存雪崩、缓存击穿与缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#singleflight-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.</span> <span class="toc-text">singleflight 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#singleflight-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">singleflight 的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Protobuf-%E9%80%9A%E4%BF%A1"><span class="toc-number">8.</span> <span class="toc-text">使用 Protobuf 通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>设计一个分布式缓存系统，需要考虑资源控制、淘汰策略、并发、分布式节点通信等各个方面的问题。而且，针对不同的应用场景，还需要在不同的特性之间权衡，例如，是否需要支持缓存更新？还是假定缓存在淘汰之前是不允许改变的。不同的权衡对应着不同的实现。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/groupcache">groupcache</a> 是 Go 语言版的 memcached，目的是在某些特定场合替代 memcached。groupcache 的作者也是 memcached 的作者。无论是了解单机缓存还是分布式缓存，深入学习这个库的实现都是非常有意义的。</p>
<p><code>GeeCache</code> 基本上模仿了 <a target="_blank" rel="noopener" href="https://github.com/golang/groupcache">groupcache</a> 的实现，为了将代码量限制在 500 行左右（groupcache 约 3000 行），裁剪了部分功能。但总体实现上，还是与 groupcache 非常接近的。支持特性有：</p>
<ul>
<li>单机缓存和基于 HTTP 的分布式缓存</li>
<li>最近最少访问 (Least Recently Used, LRU) 缓存策略</li>
<li>使用 Go 锁机制防止缓存击穿</li>
<li>使用一致性哈希选择节点，实现负载均衡</li>
<li>使用 protobuf 优化节点间二进制通信</li>
</ul>
<h2 id="LRU-缓存淘汰策略"><a href="#LRU-缓存淘汰策略" class="headerlink" title="LRU 缓存淘汰策略"></a>LRU 缓存淘汰策略</h2><p>LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高。LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了，则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。</p>
<h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><p><img src="/images/lru.jpg" alt="implement lru algorithm with golang"></p>
<p>这张图很好地表示了 LRU 算法最核心的 2 个数据结构</p>
<ul>
<li>绿色的是字典 (map)，存储键和值的映射关系。这样根据某个键 (key) 查找对应的值 (value) 的复杂是 <code>O(1)</code>，在字典中插入一条记录的复杂度也是 <code>O(1)</code>。</li>
<li>红色的是双向链表 (double linked list) 实现的队列。将所有的值放到双向链表中，这样，当访问到某个值时，将其移动到队尾的复杂度是 <code>O(1)</code>，在队尾新增一条记录以及删除一条记录的复杂度均为 <code>O(1)</code>。</li>
</ul>
<p>包含字典和双向链表的结构体类型 Cache：</p>
<ul>
<li>在这里我们直接使用 Go 语言标准库实现的双向链表 <code>list.List</code>。</li>
<li>字典的定义是 <code>map[string]*list.Element</code>，键是字符串，值是双向链表中对应节点的指针。</li>
<li><code>maxBytes</code> 是允许使用的最大内存，<code>nbytes</code> 是当前已使用的内存，<code>OnEvicted</code> 是某条记录被移除时的回调函数，可以为 nil。</li>
<li>键值对 <code>entry</code> 是双向链表节点的数据类型，在链表中仍保存每个值对应的 key 的好处在于，淘汰队首节点时，需要用 key 从字典中删除对应的映射。</li>
<li>为了通用性，我们允许值是实现了 <code>Value</code> 接口的任意类型，该接口只包含了一个方法 <code>Len() int</code>，用于返回值所占用的内存大小。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lru</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache is a LRU cache. It is not safe for concurrent access.</span></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">	maxBytes <span class="keyword">int64</span></span><br><span class="line">	nbytes   <span class="keyword">int64</span></span><br><span class="line">	ll       *list.List</span><br><span class="line">	cache    <span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element</span><br><span class="line">	<span class="comment">// optional and executed when an entry is purged.</span></span><br><span class="line">	OnEvicted <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, value Value)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	key   <span class="keyword">string</span></span><br><span class="line">	value Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value use Len to count how many bytes it takes</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the Constructor of Cache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxBytes <span class="keyword">int64</span>, onEvicted <span class="keyword">func</span>(<span class="keyword">string</span>, Value)</span>) *<span class="title">Cache</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">		maxBytes:  maxBytes,</span><br><span class="line">		ll:        list.New(),</span><br><span class="line">		cache:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.Element),</span><br><span class="line">		OnEvicted: onEvicted,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找主要有 2 个步骤，第一步是从字典中找到对应的双向链表的节点，第二步，将该节点移动到队尾。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get look ups a key&#x27;s value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value Value, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class="line">		c.ll.MoveToFront(ele)</span><br><span class="line">		kv := ele.Value.(*entry)</span><br><span class="line">		<span class="keyword">return</span> kv.value, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果键对应的链表节点存在，则将对应节点移动到队尾，并返回查找到的值。</li>
<li><code>c.ll.MoveToFront(ele)</code>，即将链表中的节点 <code>ele</code> 移动到队尾（双向链表作为队列，队首队尾是相对的，在这里约定 front 为队尾）</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>缓存淘汰。即移除最近最少访问的节点（队首）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveOldest removes the oldest item</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">RemoveOldest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ele := c.ll.Back()  <span class="comment">// 取到队首节点</span></span><br><span class="line">	<span class="keyword">if</span> ele != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.ll.Remove(ele)</span><br><span class="line">		kv := ele.Value.(*entry)</span><br><span class="line">		<span class="built_in">delete</span>(c.cache, kv.key)</span><br><span class="line">		c.nbytes -= <span class="keyword">int64</span>(<span class="built_in">len</span>(kv.key)) + <span class="keyword">int64</span>(kv.value.Len())</span><br><span class="line">		<span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.OnEvicted(kv.key, kv.value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="新增-修改"><a href="#新增-修改" class="headerlink" title="新增 / 修改"></a>新增 / 修改</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add adds a value to the cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">string</span>, value Value)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ele, ok := c.cache[key]; ok &#123; <span class="comment">// 如果键存在，则更新对应节点的值，并将该节点移到队尾。</span></span><br><span class="line">		c.ll.MoveToFront(ele)</span><br><span class="line">		kv := ele.Value.(*entry)</span><br><span class="line">		c.nbytes += <span class="keyword">int64</span>(value.Len()) - <span class="keyword">int64</span>(kv.value.Len())</span><br><span class="line">		kv.value = value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 不存在则是新增场景，首先队尾添加新节点 `&amp;entry&#123;key, value&#125;`, 并字典中添加 key 和节点的映射关系。</span></span><br><span class="line">		ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)</span><br><span class="line">		c.cache[key] = ele</span><br><span class="line">		c.nbytes += <span class="keyword">int64</span>(<span class="built_in">len</span>(key)) + <span class="keyword">int64</span>(value.Len())</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 如果超过了设定的最大值 `c.maxBytes`，则移除最少访问的节点。</span></span><br><span class="line">	<span class="keyword">for</span> c.maxBytes != <span class="number">0</span> &amp;&amp; c.maxBytes &lt; c.nbytes &#123;</span><br><span class="line">		c.RemoveOldest()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，为了方便测试，我们实现 <code>Len()</code> 用来获取添加了多少条数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Len the number of cache entries</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.ll.Len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRemoveoldest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	k1, k2, k3 := <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;k3&quot;</span></span><br><span class="line">	v1, v2, v3 := <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;value2&quot;</span>, <span class="string">&quot;v3&quot;</span></span><br><span class="line">	<span class="built_in">cap</span> := <span class="built_in">len</span>(k1 + k2 + v1 + v2)</span><br><span class="line">	lru := New(<span class="keyword">int64</span>(<span class="built_in">cap</span>), <span class="literal">nil</span>)</span><br><span class="line">	lru.Add(k1, String(v1))</span><br><span class="line">	lru.Add(k2, String(v2))</span><br><span class="line">	lru.Add(k3, String(v3))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := lru.Get(<span class="string">&quot;key1&quot;</span>); ok || lru.Len() != <span class="number">2</span> &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;Removeoldest key1 failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="单机并发缓存"><a href="#单机并发缓存" class="headerlink" title="单机并发缓存"></a>单机并发缓存</h2><ul>
<li>使用 sync.Mutex 互斥锁实现 LRU 缓存的并发控制。</li>
<li>实现 GeeCache 核心数据结构 Group，<strong>缓存不存在时，调用回调函数获取源数据。</strong></li>
</ul>
<h3 id="支持并发读写"><a href="#支持并发读写" class="headerlink" title="支持并发读写"></a>支持并发读写</h3><p>使用 <code>sync.Mutex</code> 封装 LRU 的几个方法，使之支持并发的读写。</p>
<p>在这之前，我们抽象了一个<strong>只读数据结构</strong> <code>ByteView</code> 用来表示缓存值，是 GeeCache 主要的数据结构之一。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geecache</span><br><span class="line"></span><br><span class="line"><span class="comment">// A ByteView holds an immutable view of bytes.</span></span><br><span class="line"><span class="keyword">type</span> ByteView <span class="keyword">struct</span> &#123;</span><br><span class="line">	b []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lru.Cache 的实现中，要求被缓存对象必须实现 Value 接口，即 `Len() int` 方法，返回其所占的内存大小。</span></span><br><span class="line"><span class="comment">// Len returns the view&#x27;s length</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(v.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `b` 是只读的，使用 `ByteSlice()` 方法返回一个拷贝，防止缓存值被外部程序修改</span></span><br><span class="line"><span class="comment">// ByteSlice returns a copy of the data as a byte slice.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">ByteSlice</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cloneBytes(v.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String returns the data as a string, making a copy if necessary.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(v.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cloneBytes</span><span class="params">(b []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">	<span class="built_in">copy</span>(c, b)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以为 lru.Cache 添加并发特性了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geecache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;geecache/lru&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu         sync.Mutex</span><br><span class="line">	lru        *lru.Cache</span><br><span class="line">	cacheBytes <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">add</span><span class="params">(key <span class="keyword">string</span>, value ByteView)</span></span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">  <span class="comment">// 延迟初始化 (Lazy Initialization)，主要用于提高性能，并减少程序内存要求。</span></span><br><span class="line">	<span class="keyword">if</span> c.lru == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.lru = lru.New(c.cacheBytes, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.lru.Add(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span> <span class="title">get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value ByteView, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.lru == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> v, ok := c.lru.Get(key); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> v.(ByteView), ok</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="主体结构-Group"><a href="#主体结构-Group" class="headerlink" title="主体结构 Group"></a>主体结构 Group</h3><p>Group 是 GeeCache 最核心的数据结构，负责与用户的交互，并且控制缓存值存储和获取的流程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                            是</span><br><span class="line">接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴</span><br><span class="line">                |  否                         是</span><br><span class="line">                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵</span><br><span class="line">                            |  否</span><br><span class="line">                            |-----&gt; 调用`回调函数`，获取值并添加到缓存 --&gt; 返回缓存值 ⑶</span><br></pre></td></tr></table></figure>

<p>我们将在 <code>geecache.go</code> 中实现主体结构 Group，那么 GeeCache 的代码结构的雏形已经形成了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">geecache/</span><br><span class="line">    |--lru/</span><br><span class="line">        |--lru.go  // lru 缓存淘汰策略</span><br><span class="line">    |--byteview.go // 缓存值的抽象与封装</span><br><span class="line">    |--cache.go    // 并发控制</span><br><span class="line">    |--geecache.go // 负责与外部交互，控制缓存存储和获取的主流程</span><br></pre></td></tr></table></figure>

<p>接下来我们将实现流程 ⑴ 和 ⑶，远程交互的部分后续再实现。</p>
<h4 id="回调-Getter"><a href="#回调-Getter" class="headerlink" title="回调 Getter"></a>回调 Getter</h4><p>如果缓存不存在，应从数据源（文件，数据库等）获取数据并添加到缓存中。GeeCache 是否应该支持多种数据源的配置呢？</p>
<p>不应该，一是数据源的种类太多，没办法一一实现；二是扩展性不好。如何从源头获取数据，应该是用户决定的事情，我们就把这件事交给用户好了。因此，我们设计了一个回调函数 (callback)，在缓存不存在时，调用这个函数，得到源数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Getter loads data for a key.</span></span><br><span class="line"><span class="keyword">type</span> Getter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get(key <span class="keyword">string</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A GetterFunc implements Getter with a function.</span></span><br><span class="line"><span class="keyword">type</span> GetterFunc <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get implements Getter interface function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f GetterFunc)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数类型实现某一个接口，称之为 <code>接口型函数</code>，方便使用者在调用时既能够传入函数作为参数，也能够传入实现了该接口的结构体作为参数。</p>
</blockquote>
<p>写一个测试用例来保证回调函数能够正常工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f Getter = GetterFunc(<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">byte</span>(key), <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	expect := []<span class="keyword">byte</span>(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> v, _ := f.Get(<span class="string">&quot;key&quot;</span>); !reflect.DeepEqual(v, expect) &#123;</span><br><span class="line">		t.Errorf(<span class="string">&quot;callback failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义一个函数类型 F，并且实现接口 A 的方法，然后在这个方法中调用自己。这是 Go 语言中将其他函数（参数返回值定义与 F 一致）转换为接口 A 的常用技巧。</p>
</blockquote>
<h4 id="Group-的定义"><a href="#Group-的定义" class="headerlink" title="Group 的定义"></a>Group 的定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Group is a cache namespace and associated data loaded spread over</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	name      <span class="keyword">string</span></span><br><span class="line">	getter    Getter  <span class="comment">// 缓存未命中时获取源数据的回调 (callback)</span></span><br><span class="line">	mainCache cache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	mu     sync.RWMutex</span><br><span class="line">	groups = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Group)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewGroup create a new instance of Group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroup</span><span class="params">(name <span class="keyword">string</span>, cacheBytes <span class="keyword">int64</span>, getter Getter)</span> *<span class="title">Group</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> getter == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil Getter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	g := &amp;Group&#123;</span><br><span class="line">		name:      name,</span><br><span class="line">		getter:    getter,</span><br><span class="line">		mainCache: cache&#123;cacheBytes: cacheBytes&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	groups[name] = g</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetGroup returns the named group previously created with NewGroup, or</span></span><br><span class="line"><span class="comment">// nil if there&#x27;s no such group.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetGroup</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Group</span></span> &#123;</span><br><span class="line">  <span class="comment">// 只读锁 RLock()，因为不涉及任何冲突变量的写操作。</span></span><br><span class="line">	mu.RLock()</span><br><span class="line">	g := groups[name]</span><br><span class="line">	mu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Group-的-Get-方法"><a href="#Group-的-Get-方法" class="headerlink" title="Group 的 Get 方法"></a>Group 的 Get 方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get value for a key from cache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class="string">&quot;key is required&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> v, ok := g.mainCache.get(key); ok &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;[GeeCache] hit&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> g.load(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">load</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value ByteView, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> g.getLocally(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getLocally</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	bytes, err := g.getter.Get(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	value := ByteView&#123;b: cloneBytes(bytes)&#125;</span><br><span class="line">	g.populateCache(key, value)</span><br><span class="line">	<span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">populateCache</span><span class="params">(key <span class="keyword">string</span>, value ByteView)</span></span> &#123;</span><br><span class="line">	g.mainCache.add(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Get 方法实现了上述所说的流程 ⑴ 和 ⑶。</li>
<li>流程 ⑴ ：从 mainCache 中查找缓存，如果存在则返回缓存值。</li>
<li>流程 ⑶ ：缓存不存在，则调用 load 方法，load 调用 getLocally（分布式场景下会调用 getFromPeer 从其他节点获取），getLocally 调用用户回调函数 <code>g.getter.Get()</code> 获取源数据，并且将源数据添加到缓存 mainCache 中（通过 populateCache 方法）</li>
</ul>
<p>测试用例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;Tom&quot;</span>:  <span class="string">&quot;630&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Jack&quot;</span>: <span class="string">&quot;589&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Sam&quot;</span>:  <span class="string">&quot;567&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	loadCounts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(db))</span><br><span class="line">	gee := NewGroup(<span class="string">&quot;scores&quot;</span>, <span class="number">2</span>&lt;&lt;<span class="number">10</span>, GetterFunc(</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class="line">			<span class="keyword">if</span> v, ok := db[key]; ok &#123;</span><br><span class="line">				<span class="keyword">if</span> _, ok := loadCounts[key]; !ok &#123;</span><br><span class="line">					loadCounts[key] = <span class="number">0</span></span><br><span class="line">				&#125;</span><br><span class="line">				loadCounts[key] += <span class="number">1</span></span><br><span class="line">				<span class="keyword">return</span> []<span class="keyword">byte</span>(v), <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%s not exist&quot;</span>, key)</span><br><span class="line">		&#125;))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> db &#123;</span><br><span class="line">		<span class="keyword">if</span> view, err := gee.Get(k); err != <span class="literal">nil</span> || view.String() != v &#123;</span><br><span class="line">			t.Fatal(<span class="string">&quot;failed to get value of Tom&quot;</span>)</span><br><span class="line">		&#125; <span class="comment">// load from callback function</span></span><br><span class="line">		<span class="keyword">if</span> _, err := gee.Get(k); err != <span class="literal">nil</span> || loadCounts[k] &gt; <span class="number">1</span> &#123;</span><br><span class="line">			t.Fatalf(<span class="string">&quot;cache %s miss&quot;</span>, k)</span><br><span class="line">		&#125; <span class="comment">// cache hit</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> view, err := gee.Get(<span class="string">&quot;unknown&quot;</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fatalf(<span class="string">&quot;the value of unknow should be empty, but %s got&quot;</span>, view)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HTTP-服务端"><a href="#HTTP-服务端" class="headerlink" title="HTTP 服务端"></a>HTTP 服务端</h2><p>分布式缓存需要实现节点间通信，建立基于 HTTP 的通信机制是比较常见和简单的做法。</p>
<p>首先我们创建一个结构体 <code>HTTPPool</code>，作为承载节点间 HTTP 通信的核心数据结构（包括服务端和客户端，今天只实现服务端）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geecache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultBasePath = <span class="string">&quot;/_geecache/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTPPool implements PeerPicker for a pool of HTTP peers.</span></span><br><span class="line"><span class="keyword">type</span> HTTPPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// this peer&#x27;s base URL, e.g. &quot;https://example.net:8000&quot;</span></span><br><span class="line">	self     <span class="keyword">string</span>     <span class="comment">// 记录自己的地址（主机名/IP和端口）</span></span><br><span class="line">	basePath <span class="keyword">string</span>     <span class="comment">// 节点间通讯地址的前缀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewHTTPPool initializes an HTTP pool of peers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPPool</span><span class="params">(self <span class="keyword">string</span>)</span> *<span class="title">HTTPPool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;HTTPPool&#123;</span><br><span class="line">		self:     self,</span><br><span class="line">		basePath: defaultBasePath,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Log info with server name</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">Log</span><span class="params">(format <span class="keyword">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;[Server %s] %s&quot;</span>, p.self, fmt.Sprintf(format, v...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP handle all http requests</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !strings.HasPrefix(r.URL.Path, p.basePath) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;HTTPPool serving unexpected path: &quot;</span> + r.URL.Path)</span><br><span class="line">	&#125;</span><br><span class="line">	p.Log(<span class="string">&quot;%s %s&quot;</span>, r.Method, r.URL.Path)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// /&lt;basepath&gt;/&lt;groupname&gt;/&lt;key&gt; required</span></span><br><span class="line">	parts := strings.SplitN(r.URL.Path[<span class="built_in">len</span>(p.basePath):], <span class="string">&quot;/&quot;</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">2</span> &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;bad request&quot;</span>, http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	groupName := parts[<span class="number">0</span>]</span><br><span class="line">	key := parts[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	group := GetGroup(groupName)</span><br><span class="line">	<span class="keyword">if</span> group == <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;no such group: &quot;</span>+groupName, http.StatusNotFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	view, err := group.Get(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/octet-stream&quot;</span>)</span><br><span class="line">	w.Write(view.ByteSlice())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试用例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;geecache&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;Tom&quot;</span>:  <span class="string">&quot;630&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Jack&quot;</span>: <span class="string">&quot;589&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Sam&quot;</span>:  <span class="string">&quot;567&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	geecache.NewGroup(<span class="string">&quot;scores&quot;</span>, <span class="number">2</span>&lt;&lt;<span class="number">10</span>, geecache.GetterFunc(</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class="line">			<span class="keyword">if</span> v, ok := db[key]; ok &#123;</span><br><span class="line">				<span class="keyword">return</span> []<span class="keyword">byte</span>(v), <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%s not exist&quot;</span>, key)</span><br><span class="line">		&#125;))</span><br><span class="line"></span><br><span class="line">	addr := <span class="string">&quot;localhost:9999&quot;</span></span><br><span class="line">	peers := geecache.NewHTTPPool(addr)</span><br><span class="line">	log.Println(<span class="string">&quot;geecache is running at&quot;</span>, addr)</span><br><span class="line">	log.Fatal(http.ListenAndServe(addr, peers))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。</p>
<ul>
<li>计算节点 / 机器 (通常使用节点的名称、编号和 IP 地址) 的哈希值，放置在环上。</li>
<li>计算 key 的哈希值，放置在环上，顺时针寻找到的第一个节点，就是应选取的节点 / 机器。</li>
</ul>
<p><img src="/images/add_peer.jpg" alt="一致性哈希添加节点 consistent hashing add peer"></p>
<p>环上有 peer2，peer4，peer6 三个节点，<code>key11</code>，<code>key2</code>，<code>key27</code> 均映射到 peer2，<code>key23</code> 映射到 peer4。此时，如果新增节点 / 机器 peer8，假设它新增位置如图所示，那么只有 <code>key27</code> 从 peer2 调整到 peer8，其余的映射均没有发生改变。</p>
<p>也就是说，一致性哈希算法，在新增 / 删除节点时，只需要重新定位该节点附近的一小部分数据，而不需要重新定位所有的节点，这就解决了上述的问题。</p>
<h3 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h3><p>如果服务器的节点过少，容易引起 key 的倾斜。例如上面例子中的 peer2，peer4，peer6 分布在环的上半部分，下半部分是空的。那么映射到环下半部分的 key 都会被分配给 peer2，key 过度向 peer2 倾斜，缓存节点间负载不均。</p>
<p>为了解决这个问题，引入了虚拟节点的概念，一个真实节点对应多个虚拟节点。</p>
<p>假设 1 个真实节点对应 3 个虚拟节点，那么 peer1 对应的虚拟节点是 peer1-1、 peer1-2、 peer1-3（通常以添加编号的方式实现），其余节点也以相同的方式操作。</p>
<ul>
<li>第一步，计算虚拟节点的 Hash 值，放置在环上。</li>
<li>第二步，计算 key 的 Hash 值，在环上顺时针寻找到应选取的虚拟节点，例如是 peer2-1，那么就对应真实节点 peer2。</li>
</ul>
<p>虚拟节点扩充了节点的数量，解决了节点较少的情况下数据容易倾斜的问题。而且代价非常小，只需要增加一个字典 (map) 维护真实节点与虚拟节点的映射关系即可。</p>
<h3 id="Go-语言实现"><a href="#Go-语言实现" class="headerlink" title="Go 语言实现"></a>Go 语言实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> consistenthash</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;hash/crc32&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash maps bytes to uint32</span></span><br><span class="line"><span class="keyword">type</span> Hash <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">uint32</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map constains all hashed keys</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	hash     Hash   <span class="comment">// Hash 函数</span></span><br><span class="line">	replicas <span class="keyword">int</span>    <span class="comment">// 虚拟节点倍数</span></span><br><span class="line">	keys     []<span class="keyword">int</span>  <span class="comment">// 哈希环 Sorted</span></span><br><span class="line">  hashMap  <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>  <span class="comment">// 虚拟节点与真实节点的映射表(键是虚拟节点的哈希值，值是真实节点的名称。)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates a Map instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(replicas <span class="keyword">int</span>, fn Hash)</span> *<span class="title">Map</span></span> &#123;</span><br><span class="line">	m := &amp;Map&#123;</span><br><span class="line">		replicas: replicas,</span><br><span class="line">		hash:     fn,</span><br><span class="line">		hashMap:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> m.hash == <span class="literal">nil</span> &#123;</span><br><span class="line">		m.hash = crc32.ChecksumIEEE</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义了函数类型 <code>Hash</code>，采取依赖注入的方式，允许用于替换成自定义的 Hash 函数，也方便测试时替换，默认为 <code>crc32.ChecksumIEEE</code> 算法。</li>
<li>构造函数 <code>New()</code> 允许自定义虚拟节点倍数和 Hash 函数。</li>
</ul>
<p>添加真实节点 / 机器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add adds some keys to the hash.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Add</span><span class="params">(keys ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.replicas; i++ &#123;</span><br><span class="line">			hash := <span class="keyword">int</span>(m.hash([]<span class="keyword">byte</span>(strconv.Itoa(i) + key)))</span><br><span class="line">			m.keys = <span class="built_in">append</span>(m.keys, hash)</span><br><span class="line">			m.hashMap[hash] = key</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Ints(m.keys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Add</code> 函数允许传入 0 或 多个真实节点的名称。</li>
<li>对每一个真实节点 <code>key</code>，对应创建 <code>m.replicas</code> 个虚拟节点，虚拟节点的名称是：<code>strconv.Itoa(i) + key</code>，即通过添加编号的方式区分不同虚拟节点。</li>
<li>使用 <code>m.hash()</code> 计算虚拟节点的哈希值，使用 <code>append(m.keys, hash)</code> 添加到环上。</li>
<li>在 <code>hashMap</code> 中增加虚拟节点和真实节点的映射关系。</li>
<li>最后一步，环上的哈希值排序。</li>
</ul>
<p>选择节点的 <code>Get()</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get gets the closest item in the hash to the provided key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(m.keys) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hash := <span class="keyword">int</span>(m.hash([]<span class="keyword">byte</span>(key)))</span><br><span class="line">	<span class="comment">// Binary search for appropriate replica.</span></span><br><span class="line">	idx := sort.Search(<span class="built_in">len</span>(m.keys), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> m.keys[i] &gt;= hash</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m.hashMap[m.keys[idx%<span class="built_in">len</span>(m.keys)]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步，计算 key 的哈希值。</li>
<li>第二步，顺时针找到第一个匹配的虚拟节点的下标 <code>idx</code>，从 m.keys 中获取到对应的哈希值。如果 <code>idx == len(m.keys)</code>，说明应选择 <code>m.keys[0]</code>，因为 <code>m.keys</code> 是一个环状结构，所以用取余数的方式来处理这种情况。</li>
<li>第三步，通过 <code>hashMap</code> 映射得到真实的节点。</li>
</ul>
<p>测试用例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> consistenthash</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHashing</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	hash := New(<span class="number">3</span>, <span class="function"><span class="keyword">func</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">		i, _ := strconv.Atoi(<span class="keyword">string</span>(key))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">uint32</span>(i)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Given the above hash function, this will give replicas with &quot;hashes&quot;:</span></span><br><span class="line">	<span class="comment">// 2, 4, 6, 12, 14, 16, 22, 24, 26</span></span><br><span class="line">	hash.Add(<span class="string">&quot;6&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">	testCases := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;2&quot;</span>:  <span class="string">&quot;2&quot;</span>,</span><br><span class="line">		<span class="string">&quot;11&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">		<span class="string">&quot;23&quot;</span>: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">		<span class="string">&quot;27&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> testCases &#123;</span><br><span class="line">		<span class="keyword">if</span> hash.Get(k) != v &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;Asking for %s, should have yielded %s&quot;</span>, k, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adds 8, 18, 28</span></span><br><span class="line">	hash.Add(<span class="string">&quot;8&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 27 should now map to 8.</span></span><br><span class="line">	testCases[<span class="string">&quot;27&quot;</span>] = <span class="string">&quot;8&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> testCases &#123;</span><br><span class="line">		<span class="keyword">if</span> hash.Get(k) != v &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;Asking for %s, should have yielded %s&quot;</span>, k, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要进行测试，那么我们需要明确地知道每一个传入的 key 的哈希值，那使用默认的 <code>crc32.ChecksumIEEE</code> 算法显然达不到目的。所以在这里使用了自定义的 Hash 算法。自定义的 Hash 算法只处理数字，传入字符串表示的数字，返回对应的数字即可。</p>
<ul>
<li>一开始，有 2/4/6 三个真实节点，对应的虚拟节点的哈希值是 02/12/22、04/14/24、06/16/26。</li>
<li>那么用例 2/11/23/27 选择的虚拟节点分别是 02/12/24/02，也就是真实节点 2/2/4/2。</li>
<li>添加一个真实节点 8，对应虚拟节点的哈希值是 08/18/28，此时，用例 27 对应的虚拟节点从 <code>02</code> 变更为 <code>28</code>，即真实节点 8。</li>
</ul>
<h2 id="分布式节点"><a href="#分布式节点" class="headerlink" title="分布式节点"></a>分布式节点</h2><ul>
<li>注册节点 (Register Peers)，借助一致性哈希算法选择节点。</li>
<li>实现 HTTP 客户端，与远程节点的服务端通信</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                            是</span><br><span class="line">接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴</span><br><span class="line">                |  否                         是</span><br><span class="line">                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵</span><br><span class="line">                            |  否</span><br><span class="line">                            |-----&gt; 调用`回调函数`，获取值并添加到缓存 --&gt; 返回缓存值 ⑶</span><br></pre></td></tr></table></figure>

<p>进一步细化流程 ⑵：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用一致性哈希选择节点        是                                    是</span><br><span class="line">    |-----&gt; 是否是远程节点 -----&gt; HTTP 客户端访问远程节点 --&gt; 成功？-----&gt; 服务端返回返回值</span><br><span class="line">                    |  否                                    ↓  否</span><br><span class="line">                    |----------------------------&gt; 回退到本地节点处理。</span><br></pre></td></tr></table></figure>



<h3 id="抽象-PeerPicker"><a href="#抽象-PeerPicker" class="headerlink" title="抽象 PeerPicker"></a>抽象 PeerPicker</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geecache</span><br><span class="line"></span><br><span class="line"><span class="comment">// PeerPicker is the interface that must be implemented to locate</span></span><br><span class="line"><span class="comment">// the peer that owns a specific key.</span></span><br><span class="line"><span class="keyword">type</span> PeerPicker <span class="keyword">interface</span> &#123;</span><br><span class="line">	PickPeer(key <span class="keyword">string</span>) (peer PeerGetter, ok <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PeerGetter is the interface that must be implemented by a peer.</span></span><br><span class="line"><span class="keyword">type</span> PeerGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get(group <span class="keyword">string</span>, key <span class="keyword">string</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这里，抽象出 2 个接口，PeerPicker 的 <code>PickPeer()</code> 方法用于根据传入的 key 选择相应节点 PeerGetter。</li>
<li>接口 PeerGetter 的 <code>Get()</code> 方法用于从对应 group 查找缓存值。PeerGetter 就对应于上述流程中的 HTTP 客户端。</li>
</ul>
<h3 id="节点选择与-HTTP-客户端"><a href="#节点选择与-HTTP-客户端" class="headerlink" title="节点选择与 HTTP 客户端"></a>节点选择与 HTTP 客户端</h3><p>接下来要为 <code>HTTPPool</code> 实现客户端的功能。</p>
<p>首先创建具体的 HTTP 客户端类 <code>httpGetter</code>，实现 PeerGetter 接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> httpGetter <span class="keyword">struct</span> &#123;</span><br><span class="line">	baseURL <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpGetter)</span> <span class="title">Get</span><span class="params">(group <span class="keyword">string</span>, key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	u := fmt.Sprintf(</span><br><span class="line">		<span class="string">&quot;%v%v/%v&quot;</span>,</span><br><span class="line">		h.baseURL,</span><br><span class="line">		url.QueryEscape(group),</span><br><span class="line">		url.QueryEscape(key),</span><br><span class="line">	)</span><br><span class="line">	res, err := http.Get(u)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;server returned: %v&quot;</span>, res.Status)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bytes, err := ioutil.ReadAll(res.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;reading response body: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bytes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ PeerGetter = (*httpGetter)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>baseURL 表示将要访问的远程节点的地址，例如 <code>http://example.com/_geecache/</code>。</li>
<li>使用 <code>http.Get()</code> 方式获取返回值，并转换为 <code>[]bytes</code> 类型。</li>
</ul>
<p>第二步，为 HTTPPool 添加节点选择的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultBasePath = <span class="string">&quot;/_geecache/&quot;</span></span><br><span class="line">	defaultReplicas = <span class="number">50</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// HTTPPool implements PeerPicker for a pool of HTTP peers.</span></span><br><span class="line"><span class="keyword">type</span> HTTPPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// this peer&#x27;s base URL, e.g. &quot;https://example.net:8000&quot;</span></span><br><span class="line">	self        <span class="keyword">string</span></span><br><span class="line">	basePath    <span class="keyword">string</span></span><br><span class="line">	mu          sync.Mutex <span class="comment">// guards peers and httpGetters</span></span><br><span class="line">	peers       *consistenthash.Map</span><br><span class="line">	httpGetters <span class="keyword">map</span>[<span class="keyword">string</span>]*httpGetter <span class="comment">// keyed by e.g. &quot;http://10.0.0.2:8008&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新增成员变量 <code>peers</code>，类型是一致性哈希算法的 <code>Map</code>，用来根据具体的 key 选择节点。</li>
<li>新增成员变量 <code>httpGetters</code>，映射远程节点与对应的 httpGetter。每一个远程节点对应一个 httpGetter，因为 httpGetter 与远程节点的地址 <code>baseURL</code> 有关。</li>
</ul>
<p>第三步，实现 PeerPicker 接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set updates the pool&#x27;s list of peers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">Set</span><span class="params">(peers ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">	p.peers = consistenthash.New(defaultReplicas, <span class="literal">nil</span>)</span><br><span class="line">	p.peers.Add(peers...)</span><br><span class="line">	p.httpGetters = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*httpGetter, <span class="built_in">len</span>(peers))</span><br><span class="line">	<span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">		p.httpGetters[peer] = &amp;httpGetter&#123;baseURL: peer + p.basePath&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PickPeer picks a peer according to key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">PickPeer</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(PeerGetter, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> peer := p.peers.Get(key); peer != <span class="string">&quot;&quot;</span> &amp;&amp; peer != p.self &#123;</span><br><span class="line">		p.Log(<span class="string">&quot;Pick peer %s&quot;</span>, peer)</span><br><span class="line">		<span class="keyword">return</span> p.httpGetters[peer], <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ PeerPicker = (*HTTPPool)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Set()</code> 方法实例化了一致性哈希算法，并且添加了传入的节点。</li>
<li>并为每一个节点创建了一个 HTTP 客户端 <code>httpGetter</code>。</li>
<li><code>PickerPeer()</code> 包装了一致性哈希算法的 <code>Get()</code> 方法，根据具体的 key，选择节点，返回节点对应的 HTTP 客户端。</li>
</ul>
<p>至此，HTTPPool 既具备了提供 HTTP 服务的能力，也具备了根据具体的 key，创建 HTTP 客户端从远程节点获取缓存值的能力。</p>
<h3 id="实现主流程"><a href="#实现主流程" class="headerlink" title="实现主流程"></a>实现主流程</h3><p>最后，我们需要将上述新增的功能集成在主流程 (geecache.go) 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Group is a cache namespace and associated data loaded spread over</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	name      <span class="keyword">string</span></span><br><span class="line">	getter    Getter</span><br><span class="line">	mainCache cache</span><br><span class="line">	peers     PeerPicker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterPeers registers a PeerPicker for choosing remote peer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">RegisterPeers</span><span class="params">(peers PeerPicker)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> g.peers != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;RegisterPeerPicker called more than once&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	g.peers = peers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">load</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value ByteView, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> g.peers != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> value, err = g.getFromPeer(peer, key); err == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			log.Println(<span class="string">&quot;[GeeCache] Failed to get from peer&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> g.getLocally(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getFromPeer</span><span class="params">(peer PeerGetter, key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	bytes, err := peer.Get(g.name, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ByteView&#123;b: bytes&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新增 <code>RegisterPeers()</code> 方法，将实现了 PeerPicker 接口的 HTTPPool 注入到 Group 中。</li>
<li>新增 <code>getFromPeer()</code> 方法，使用实现了 PeerGetter 接口的 httpGetter 从访问远程节点，获取缓存值。</li>
<li>修改 load 方法，使用 <code>PickPeer()</code> 方法选择节点，若非本机节点，则调用 <code>getFromPeer()</code> 从远程获取。若是本机节点或失败，则回退到 <code>getLocally()</code>。</li>
</ul>
<p>测试用例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;Tom&quot;</span>:  <span class="string">&quot;630&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Jack&quot;</span>: <span class="string">&quot;589&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Sam&quot;</span>:  <span class="string">&quot;567&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createGroup</span><span class="params">()</span> *<span class="title">geecache</span>.<span class="title">Group</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> geecache.NewGroup(<span class="string">&quot;scores&quot;</span>, <span class="number">2</span>&lt;&lt;<span class="number">10</span>, geecache.GetterFunc(</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class="line">			<span class="keyword">if</span> v, ok := db[key]; ok &#123;</span><br><span class="line">				<span class="keyword">return</span> []<span class="keyword">byte</span>(v), <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%s not exist&quot;</span>, key)</span><br><span class="line">		&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startCacheServer</span><span class="params">(addr <span class="keyword">string</span>, addrs []<span class="keyword">string</span>, gee *geecache.Group)</span></span> &#123;</span><br><span class="line">	peers := geecache.NewHTTPPool(addr)</span><br><span class="line">	peers.Set(addrs...)</span><br><span class="line">	gee.RegisterPeers(peers)</span><br><span class="line">	log.Println(<span class="string">&quot;geecache is running at&quot;</span>, addr)</span><br><span class="line">	log.Fatal(http.ListenAndServe(addr[<span class="number">7</span>:], peers))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startAPIServer</span><span class="params">(apiAddr <span class="keyword">string</span>, gee *geecache.Group)</span></span> &#123;</span><br><span class="line">	http.Handle(<span class="string">&quot;/api&quot;</span>, http.HandlerFunc(</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">			key := r.URL.Query().Get(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">			view, err := gee.Get(key)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/octet-stream&quot;</span>)</span><br><span class="line">			w.Write(view.ByteSlice())</span><br><span class="line"></span><br><span class="line">		&#125;))</span><br><span class="line">	log.Println(<span class="string">&quot;fontend server is running at&quot;</span>, apiAddr)</span><br><span class="line">	log.Fatal(http.ListenAndServe(apiAddr[<span class="number">7</span>:], <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> port <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> api <span class="keyword">bool</span></span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">8001</span>, <span class="string">&quot;Geecache server port&quot;</span>)</span><br><span class="line">	flag.BoolVar(&amp;api, <span class="string">&quot;api&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Start a api server?&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	apiAddr := <span class="string">&quot;http://localhost:9999&quot;</span></span><br><span class="line">	addrMap := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">8001</span>: <span class="string">&quot;http://localhost:8001&quot;</span>,</span><br><span class="line">		<span class="number">8002</span>: <span class="string">&quot;http://localhost:8002&quot;</span>,</span><br><span class="line">		<span class="number">8003</span>: <span class="string">&quot;http://localhost:8003&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> addrs []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> addrMap &#123;</span><br><span class="line">		addrs = <span class="built_in">append</span>(addrs, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gee := createGroup()</span><br><span class="line">	<span class="keyword">if</span> api &#123;</span><br><span class="line">		<span class="keyword">go</span> startAPIServer(apiAddr, gee)</span><br><span class="line">	&#125;</span><br><span class="line">	startCacheServer(addrMap[port], []<span class="keyword">string</span>(addrs), gee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 函数的代码比较多，但是逻辑是非常简单的。</p>
<ul>
<li><code>startCacheServer()</code> 用来启动缓存服务器：创建 HTTPPool，添加节点信息，注册到 gee 中，启动 HTTP 服务（共 3 个端口，8001/8002/8003），用户不感知。</li>
<li><code>startAPIServer()</code> 用来启动一个 API 服务（端口 9999），与用户进行交互，用户感知。</li>
<li><code>main()</code> 函数需要命令行传入 <code>port</code> 和 <code>api</code> 2 个参数，用来在指定端口启动 HTTP 服务。</li>
</ul>
<h2 id="防止缓存击穿"><a href="#防止缓存击穿" class="headerlink" title="防止缓存击穿"></a>防止缓存击穿</h2><h3 id="缓存雪崩、缓存击穿与缓存穿透"><a href="#缓存雪崩、缓存击穿与缓存穿透" class="headerlink" title="缓存雪崩、缓存击穿与缓存穿透"></a>缓存雪崩、缓存击穿与缓存穿透</h3><ul>
<li><strong>缓存雪崩</strong>：缓存在同一时刻全部失效，造成瞬时 DB 请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。</li>
<li><strong>缓存击穿</strong>：一个存在的 key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时 DB 请求量大、压力骤增。</li>
<li><strong>缓存穿透</strong>：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。</li>
</ul>
<h3 id="singleflight-的实现"><a href="#singleflight-的实现" class="headerlink" title="singleflight 的实现"></a>singleflight 的实现</h3><p>我们并发了 N 个请求 <code>?key=Tom</code>，8003 节点向 8001 同时发起了 N 次请求。假设对数据库的访问没有做任何限制的，很可能向数据库也发起 N 次请求，容易导致缓存击穿和穿透。即使对数据库做了防护，HTTP 请求是非常耗费资源的操作，针对相同的 key，8003 节点向 8001 发起三次请求也是没有必要的。那这种情况下，我们如何做到只向远端节点发起一次请求呢？</p>
<p>使用 singleflight 来解决这个问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleflight</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">	wg  sync.WaitGroup</span><br><span class="line">	val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex       <span class="comment">// protects m</span></span><br><span class="line">	m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>call</code> 代表正在进行中，或已经结束的请求。使用 <code>sync.WaitGroup</code> 锁避免重入。</li>
<li><code>Group</code> 是 singleflight 的主数据结构，管理不同 key 的请求 (call)。</li>
</ul>
<p>实现 <code>Do</code> 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">		c.wg.Wait()</span><br><span class="line">		<span class="keyword">return</span> c.val, c.err</span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">new</span>(call)</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)</span><br><span class="line">	g.m[key] = c</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	c.val, c.err = fn()</span><br><span class="line">	c.wg.Done()</span><br><span class="line"></span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	<span class="built_in">delete</span>(g.m, key)</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.val, c.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Do 方法，接收 2 个参数，第一个参数是 <code>key</code>，第二个参数是一个函数 <code>fn</code>。Do 的作用就是，针对相同的 key，无论 Do 被调用多少次，函数 <code>fn</code> 都只会被调用一次，等待 fn 调用结束了，返回返回值或错误。</p>
<p><code>g.mu</code> 是保护 Group 的成员变量 <code>m</code> 不被并发读写而加上的锁。为了便于理解 <code>Do</code> 函数，我们将 <code>g.mu</code> 暂时去掉。并且把 <code>g.m</code> 延迟初始化的部分去掉，延迟初始化的目的很简单，提高内存使用效率。</p>
<p>剩下的逻辑就很清晰了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">		c.wg.Wait()   <span class="comment">// 如果请求正在进行中，则等待</span></span><br><span class="line">		<span class="keyword">return</span> c.val, c.err  <span class="comment">// 请求结束，返回结果</span></span><br><span class="line">	&#125;</span><br><span class="line">	c := <span class="built_in">new</span>(call)</span><br><span class="line">	c.wg.Add(<span class="number">1</span>)       <span class="comment">// 发起请求前加锁</span></span><br><span class="line">	g.m[key] = c      <span class="comment">// 添加到 g.m，表明 key 已经有对应的请求在处理</span></span><br><span class="line"></span><br><span class="line">	c.val, c.err = fn() <span class="comment">// 调用 fn，发起请求</span></span><br><span class="line">	c.wg.Done()         <span class="comment">// 请求结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(g.m, key)    <span class="comment">// 更新 g.m</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> c.val, c.err <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发协程之间不需要消息传递，非常适合 <code>sync.WaitGroup</code>。</p>
<ul>
<li>wg.Add (1) 锁加 1。</li>
<li>wg.Wait () 阻塞，直到锁被释放。</li>
<li>wg.Done () 锁减 1。</li>
</ul>
<h3 id="singleflight-的使用"><a href="#singleflight-的使用" class="headerlink" title="singleflight 的使用"></a>singleflight 的使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	name      <span class="keyword">string</span></span><br><span class="line">	getter    Getter</span><br><span class="line">	mainCache cache</span><br><span class="line">	peers     PeerPicker</span><br><span class="line">	<span class="comment">// use singleflight.Group to make sure that</span></span><br><span class="line">	<span class="comment">// each key is only fetched once</span></span><br><span class="line">	loader *singleflight.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroup</span><span class="params">(name <span class="keyword">string</span>, cacheBytes <span class="keyword">int64</span>, getter Getter)</span> *<span class="title">Group</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	g := &amp;Group&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">		loader:    &amp;singleflight.Group&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">load</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value ByteView, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// each key is only fetched once (either locally or remotely)</span></span><br><span class="line">	<span class="comment">// regardless of the number of concurrent callers.</span></span><br><span class="line">	viewi, err := g.loader.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> g.peers != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</span><br><span class="line">				<span class="keyword">if</span> value, err = g.getFromPeer(peer, key); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				log.Println(<span class="string">&quot;[GeeCache] Failed to get from peer&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> g.getLocally(key)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> viewi.(ByteView), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 <code>geecache.go</code> 中的 <code>Group</code>，添加成员变量 loader，并更新构建函数 <code>NewGroup</code>。</li>
<li>修改 <code>load</code> 函数，将原来的 load 的逻辑，使用 <code>g.loader.Do</code> 包裹起来即可，这样确保了并发场景下针对相同的 key，<code>load</code> 过程只会调用一次。</li>
</ul>
<h2 id="使用-Protobuf-通信"><a href="#使用-Protobuf-通信" class="headerlink" title="使用 Protobuf 通信"></a>使用 Protobuf 通信</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> geecachepb;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="keyword">group</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> key = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bytes</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GroupCache</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Get(Request) <span class="keyword">returns</span> (Response)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，修改 <code>peers.go</code> 中的 <code>PeerGetter</code> 接口，参数使用 <code>geecachepb.pb.go</code> 中的数据类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pb <span class="string">&quot;geecache/geecachepb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PeerGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get(in *pb.Request, out *pb.Response) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，修改 <code>geecache.go</code> 和 <code>http.go</code> 中使用了 <code>PeerGetter</code> 接口的地方。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pb <span class="string">&quot;geecache/geecachepb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getFromPeer</span><span class="params">(peer PeerGetter, key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</span><br><span class="line">	req := &amp;pb.Request&#123;</span><br><span class="line">		Group: g.name,</span><br><span class="line">		Key:   key,</span><br><span class="line">	&#125;</span><br><span class="line">	res := &amp;pb.Response&#123;&#125;</span><br><span class="line">	err := peer.Get(req, res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ByteView&#123;b: res.Value&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	pb <span class="string">&quot;geecache/geecachepb&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/golang/protobuf/proto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// Write the value to the response body as a proto message.</span></span><br><span class="line">	body, err := proto.Marshal(&amp;pb.Response&#123;Value: view.ByteSlice()&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/octet-stream&quot;</span>)</span><br><span class="line">	w.Write(body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpGetter)</span> <span class="title">Get</span><span class="params">(in *pb.Request, out *pb.Response)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	u := fmt.Sprintf(</span><br><span class="line">		<span class="string">&quot;%v%v/%v&quot;</span>,</span><br><span class="line">		h.baseURL,</span><br><span class="line">		url.QueryEscape(in.GetGroup()),</span><br><span class="line">		url.QueryEscape(in.GetKey()),</span><br><span class="line">	)</span><br><span class="line">    res, err := http.Get(u)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> err = proto.Unmarshal(bytes, out); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decoding response body: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ServeHTTP()</code> 中使用 <code>proto.Marshal()</code> 编码 HTTP 响应。</li>
<li><code>Get()</code> 中使用 <code>proto.Unmarshal()</code> 解码 HTTP 响应。</li>
</ul>
<p>总结：</p>
<ul>
<li>为了解决资源限制的问题，实现了 LRU 缓存淘汰算法；</li>
<li>实现了单机并发，并给用户提供了自定义数据源的回调函数；</li>
<li>实现了 HTTP 服务端；</li>
<li>实现了一致性哈希算法，解决远程节点的挑选问题；</li>
<li>创建 HTTP 客户端，实现了多节点间的通信；</li>
<li>实现了 singleflight 解决缓存击穿的问题；</li>
<li>使用 protobuf 库，优化了节点间通信的性能。</li>
</ul>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://geektutu.com/post/geecache.html">7 天用 Go 从零实现分布式缓存 GeeCache</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>