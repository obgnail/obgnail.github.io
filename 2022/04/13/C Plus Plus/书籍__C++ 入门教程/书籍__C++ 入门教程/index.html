<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;从-C-到-C&quot;&gt;&lt;a href=&quot;#从-C-到-C&quot; class=&quot;headerlink&quot; title=&quot;从 C 到 C++&quot;&gt;&lt;/a&gt;从 C 到 C++&lt;/h2&gt;&lt;h3 id=&quot;命名空间&quot;&gt;&lt;a href=&quot;#命名空间&quot; class=&quot;headerlink&quot; title=&quot;命名空间&quot;&gt;&lt;/a&gt;命名空间&lt;/h3&gt;&lt;p&gt;C++ 语言引入命名空间（Namespace）这一概念主要是为了避免命名冲突，其关键字为 namespace。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>C++ 入门教程 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/C-Plus-Plus/" rel="tag">C Plus Plus</a></div><div class="post-time">2022-04-13</div></div></div><div class="container post-header"><h1>C++ 入门教程</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-C-%E5%88%B0-C"><span class="toc-number">1.</span> <span class="toc-text">从 C 到 C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cout-%E5%92%8C-cin"><span class="toc-number">1.2.</span> <span class="toc-text">cout 和 cin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%EF%BC%88Reference%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">引用（Reference）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数引用参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.3.2.</span> <span class="toc-text">函数引用返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-cast"><span class="toc-number">1.4.1.</span> <span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-cast"><span class="toc-number">1.4.2.</span> <span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reinterpret-cast"><span class="toc-number">1.4.3.</span> <span class="toc-text">reinterpret_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">1.4.4.</span> <span class="toc-text">dynamic_cast</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%88inline%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">内联函数（inline）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%92%8C-delete-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">new 和 delete 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88try-%E5%92%8C-catch%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">异常处理（try 和 catch）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">C++ 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">类的定义和声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">类的信息隐藏机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E9%80%89%E6%8B%A9%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">成员选择符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB-class-%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93-struct-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">类 class 和结构体 struct 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E6%9D%A5%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.</span> <span class="toc-text">通过引用来传递和返回类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8"><span class="toc-number">2.7.</span> <span class="toc-text">参数初始化表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.</span> <span class="toc-text">使用默认参数的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%99%90%E5%88%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.9.</span> <span class="toc-text">利用构造函数限制对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%9E%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.10.</span> <span class="toc-text">转型构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.12.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88-this"><span class="toc-number">2.13.</span> <span class="toc-text">常量指针 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E-new-%E5%92%8C-delete-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.14.</span> <span class="toc-text">类与 new 和 delete 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E-const-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.15.</span> <span class="toc-text">类与 const 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E-static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.16.</span> <span class="toc-text">类与 static 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">2.17.</span> <span class="toc-text">友元函数和友元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F"><span class="toc-number">3.</span> <span class="toc-text">继承和派生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95%E5%8F%8A%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">继承的语法及方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">改变基类成员在派生类中的访问属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E9%9A%90%E8%97%8F"><span class="toc-number">3.3.</span> <span class="toc-text">名字隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.</span> <span class="toc-text">间接继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">继承机制下的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">3.6.</span> <span class="toc-text">派生类构造函数调用规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">继承机制下的析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">3.8.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">3.9.</span> <span class="toc-text">虚基类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">4.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">虚函数的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%B8%B8%E8%A7%84%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">4.2.</span> <span class="toc-text">虚函数和常规函数被调用时有什么不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.3.</span> <span class="toc-text">多态的概念及前提条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%A1%A8-vtable"><span class="toc-number">4.4.</span> <span class="toc-text">虚成员函数表 vtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">静态成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%E5%92%8C%E9%81%AE%E8%94%BD"><span class="toc-number">4.7.</span> <span class="toc-text">重载、覆盖和遮蔽</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">4.7.1.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">4.7.2.</span> <span class="toc-text">覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%AE%E8%94%BD"><span class="toc-number">4.7.3.</span> <span class="toc-text">遮蔽</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E5%92%8C%E7%BA%AF%E8%99%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">抽象基类和纯虚成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeid-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.9.</span> <span class="toc-text">typeid 操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.1.</span> <span class="toc-text">基本操作符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">用顶层函数重载操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6-VS-%E7%B1%BB%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.3.</span> <span class="toc-text">顶层函数重载操作符 VS 类重载操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text">重载输入与输出操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.5.</span> <span class="toc-text">重载赋值操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.6.</span> <span class="toc-text">重载下标操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.7.</span> <span class="toc-text">函数调用操作符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.8.</span> <span class="toc-text">重载自增与自减操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BD%AC%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.9.</span> <span class="toc-text">重载转型操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.10.</span> <span class="toc-text">内存管理操作符重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">String 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">string 类型变量的定义和简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#erase%EF%BC%9A%E5%88%A0%E9%99%A4%E5%AD%90%E4%B8%B2"><span class="toc-number">6.2.1.</span> <span class="toc-text">erase：删除子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert%EF%BC%9A%E6%8F%92%E5%85%A5%E5%AD%90%E4%B8%B2"><span class="toc-number">6.2.2.</span> <span class="toc-text">insert：插入子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replace%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2"><span class="toc-number">6.2.3.</span> <span class="toc-text">replace：替换子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#swap%EF%BC%9A%E4%BA%A4%E6%8D%A2"><span class="toc-number">6.2.4.</span> <span class="toc-text">swap：交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#substr%EF%BC%9A%E6%8F%90%E5%8F%96%E5%AD%90%E4%B8%B2"><span class="toc-number">6.2.5.</span> <span class="toc-text">substr：提取子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%AD%90%E4%B8%B2"><span class="toc-number">6.2.6.</span> <span class="toc-text">find：查找子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-first-of%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%B1%E5%90%8C%E5%85%B7%E6%9C%89%E7%9A%84%E5%AD%97%E7%AC%A6%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">6.2.7.</span> <span class="toc-text">find_first_of：查找子串和字符串共同具有的字符在字符串中出现的位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">7.</span> <span class="toc-text">输入与输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">7.1.</span> <span class="toc-text">输入输出类的层次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%B1%BB%E5%B1%82%E6%AC%A1"><span class="toc-number">7.1.1.</span> <span class="toc-text">输入输出流类层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E7%B1%BB%E5%B1%82%E6%AC%A1"><span class="toc-number">7.1.2.</span> <span class="toc-text">缓冲类层次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.2.</span> <span class="toc-text">标准输出流对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E6%A0%87%E8%AF%86%E5%92%8C%E6%93%8D%E7%BA%B5%E5%99%A8"><span class="toc-number">7.3.</span> <span class="toc-text">格式标识和操纵器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">7.4.</span> <span class="toc-text">标准输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">输入相关的成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#get"><span class="toc-number">7.5.1.</span> <span class="toc-text">get()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getline"><span class="toc-number">7.5.2.</span> <span class="toc-text">getline()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eof"><span class="toc-number">7.5.3.</span> <span class="toc-text">eof()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ignore"><span class="toc-number">7.5.4.</span> <span class="toc-text">ignore()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peek"><span class="toc-number">7.5.5.</span> <span class="toc-text">peek()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#putback"><span class="toc-number">7.5.6.</span> <span class="toc-text">putback()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">7.6.</span> <span class="toc-text">文本文件的读写操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">7.7.</span> <span class="toc-text">二进制文件读写操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="从-C-到-C"><a href="#从-C-到-C" class="headerlink" title="从 C 到 C++"></a>从 C 到 C++</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>C++ 语言引入命名空间（Namespace）这一概念主要是为了避免命名冲突，其关键字为 namespace。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Li &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Han &#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定所使用的变量时需要用到<code>::</code> 操作符，<code>::</code> 操作符是<code>域解析操作符</code>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Li::flag = <span class="number">0</span>;</span><br><span class="line">Han::flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>还可以采用 using 声明（using declaration），含义是<strong>将默认的 namespace 设置成 Li</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Li::flag;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">flagHan::flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>C++ 语言是以 C 语言为基础的，它继承了所有的 C 语言函数库，但 C++ 对这些标准库都重新命名了。标准 C 头文件（如 math.h）重命名为 cmath，去掉头文件的<code>.h</code>，并在前面加上 <code>c</code>。因此在 C++ 中如需使用 math.h 头文件则可以按照如下方式使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>



<h3 id="cout-和-cin"><a href="#cout-和-cin" class="headerlink" title="cout 和 cin"></a>cout 和 cin</h3><p>当使用 <code>cin&gt;&gt;val;</code> 输入变量时，如果输入一个变量到 val 中，则该表达式返回 true，否则返回 false。利用这一特性，我们可以连续输入数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input a number :&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += val;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Please input next number :&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The sum of all number is sum = &quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序从标准输入中不断地读取数据并存入到 val 变量中，每读入一个数据就求一次和，直至用户输入文件结束符标识时，程序才会输出之前用户输入所有数据之和。</p>
<h3 id="引用（Reference）"><a href="#引用（Reference）" class="headerlink" title="引用（Reference）"></a>引用（Reference）</h3><p><strong>引用本质是指针的语法糖</strong>。只是在声明的时候用 <code>&amp;</code> 取代了 <code>*</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型标识符 &amp; 引用名 = 被引用对象</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;   <span class="comment">// 10 10</span></span><br><span class="line">cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b &lt;&lt;endl;  <span class="comment">// 0018FDB4 0018FDB4</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;   <span class="comment">// 20 20</span></span><br></pre></td></tr></table></figure>

<p>变量 a 和变量 b 都是指向同一地址的，也即变量 b 是变量 a 的另一个名字，也可以理解为 0018FDB4 空间拥有两个名字：a 和 b。</p>
<p>如果我们不希望通过引用来改变原始变量的值时，我们可以按照如下的方式声明引用，这种引用方式成为<code>常引用</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 类型标识符 &amp; 引用名 = 被引用的变量名</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">b = <span class="number">20</span>;   <span class="comment">// compile error</span></span><br><span class="line">a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>引用的这一特性使得它用于函数传递参数或函数返回值时非常有用。</p>
<h4 id="函数引用参数"><a href="#函数引用参数" class="headerlink" title="函数引用参数"></a>函数引用参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">  cout &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; endl;  <span class="comment">// 10 20</span></span><br><span class="line">  <span class="built_in">swap</span>(num1, num2);</span><br><span class="line">  cout &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; endl;  <span class="comment">// 20 10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数引用返回值"><a href="#函数引用返回值" class="headerlink" title="函数引用返回值"></a>函数引用返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valplus</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> num2;</span><br><span class="line">  num2 = <span class="built_in">valplus</span>(num1);</span><br><span class="line">  cout &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; endl;  <span class="comment">// 15 15</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valplus</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">  a = a + <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valplus() 函数采用的是普通的传值返回，也即将变量 a 的结果加上 5 之后，将结果拷贝到一个临时存储空间，然后再从临时存储空间拷贝给 num2 变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">valplus</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> num2;</span><br><span class="line">  num2 = <span class="built_in">valplus</span>(num1);</span><br><span class="line">  cout &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; endl;  <span class="comment">// 15 15</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">valplus</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">  a = a + <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valplus() 函数在将 a 变量加上 5 之后，其运算结果是直接拷贝给 num2 的，<strong>中间没有经过拷贝给临时空间，再从临时存储空间中拷贝出来的这么一个过程</strong>。这就是普通的传值返回和引用返回的区别。</p>
<p>注意要避免野指针的写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">valplus</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = a + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(type)expr;                  <span class="comment">// C语言风格的强制类型转换</span></span><br><span class="line">cast-name&lt;type&gt;(expression)  <span class="comment">// 现代 C++ 风格的类型转换</span></span><br></pre></td></tr></table></figure>

<p>在 C++ 语言中新增了四个关键字 static_cast、const_cast、reinterpret_cast 和 dynamic_cast。这四个关键字都是用于强制类型转换的。</p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>static_cast 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。例如将整型数据转换为浮点型数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 语言所采用的类型转换方式：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> result = (<span class="keyword">double</span>)a / (<span class="keyword">double</span>)b;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static_cast 关键字的使用：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> result = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(b);</span><br></pre></td></tr></table></figure>

<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>在 C 语言中，const 限定符通常被用来限定变量，用于表示该变量的值不能被修改。而 <strong>const_cast 则正是用于强制去掉这种不能被修改的常数特性</strong>。</p>
<p>但需要特别注意的是，<strong>const_cast 不是用于去除变量的常量性</strong>，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">*p = <span class="number">20</span>;                     <span class="comment">//compile error(*p因为具有常量性，其值是不能被修改的)</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(a);  <span class="comment">//compile error(const_cast强制转换对象必须为指针或引用)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">  <span class="keyword">int</span> *q;</span><br><span class="line">  q = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);  <span class="comment">// 去除了底层const</span></span><br><span class="line">  *q = <span class="number">20</span>; <span class="comment">//fine</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *q &lt;&lt; endl; <span class="comment">// 10 20 20</span></span><br><span class="line">  cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q &lt;&lt; endl;  <span class="comment">// 002CFAF4 002CFAF4 002CFAF4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<strong>此时 a 的值为 10</strong>。其实这是一件好事，我们要庆幸 a 变量最终的值没有变成 20！变量 a 一开始就被声明为一个常量变量，不管后面的程序怎么处理，它就是一个常量，就是不会变化的。毕竟将变量 a 声明为常量就是不希望修改它，如果后面能修改，这就太恐怖了。</p>
<p>我们称 <code>*q=20;</code> 语句为<code>未定义行为语句</code>，所谓的未定义行为是指在标准的 C++ 规范中并没有明确规定这种语句的具体行为，该语句的具体行为由编译器来自行决定如何处理。对于这种未定义行为的语句我们应该尽量予以避免！</p>
<p>使用 const_cast 来强制去掉引用的常量性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="title">Search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> &amp;p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(<span class="built_in">Search</span>(a, <span class="number">10</span>, val));</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found the val in array a&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hvae found the val in array a and the val = &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="title">Search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == val)</span><br><span class="line">      <span class="keyword">return</span> a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>const_cast 关键字的意义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="title">Search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> *p;</span><br><span class="line">  p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(<span class="built_in">Search</span>(a, <span class="number">10</span>, val));</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found the val in array a&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hvae found the val in array a and the val = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="title">Search</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == val)</span><br><span class="line">      <span class="keyword">return</span> &amp;a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Search() 函数的返回值是 const 指针，当我们在 a 数组中找到了 val 值的时候，我们会返回 val 的地址，最关键的是 a 数组在 main() 函数中并不是 const，因此就算我们去掉返回值的常量性有可能会造成 a 数组被修改，也依然是安全的。</p>
<p><strong>const_cast 的目的，在于某些变量原本不是 const 的，但由于某种特殊原因，无意间被变成了 const 的</strong>。例如使用了一个 const 引用指向了一个本来不是 const 的对象。结果写了一些代码之后发现它实际上需要被修改。这在平时的工作中不会遇到因为你可以直接把 const 引用修改成非 const 的，但 C++ 中可能的情况太多，尤其考虑到很多复用的时候，有时还是会出现本不该是 const 的对象被 const 引用了这种情况。尤其是使用模板，比较复杂的情况。</p>
<p>也就是说，<strong>使用 const_cast 通常是一种无奈之举</strong>。</p>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>reinterpret_cast 主要有三种强制转换用途：</p>
<ul>
<li>改变指针或引用的类型</li>
<li>将指针或引用转换为一个足够长度的整形</li>
<li>将整型转换为指针或引用类型</li>
</ul>
<p>在使用 reinterpret_cast 强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// 将整型指针通过 reinterpret_cast 强制转换成了双精度浮点型指针。</span></span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>

<p>reinterpret_cast 可以将指针或引用转换为一个足够长度的整形，此中的足够长度具体长度需要多少则取决于操作系统，如果是 32 位的操作系统，就需要 4 个字节及以上的整型，如果是 64 位的操作系统，则需要 8 个字节及以上的整型。  </p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p>dynamic_cast 用于类的继承层次之间的强制类型转换。</p>
<p>相比 static_cast，dynamic_cast 会在运行时检查类型转换是否合法，具有一定的安全性。由于运行时的检查，所以会额外消耗一些性能。dynamic_cast 使用场景与 static 相似，在类层次结构中使用时，上行转换和 static_cast 没有区别，都是安全的；下行转换时，dynamic_cast 会检查转换的类型，相比 static_cast 更安全。</p>
<h3 id="内联函数（inline）"><a href="#内联函数（inline）" class="headerlink" title="内联函数（inline）"></a>内联函数（inline）</h3><p>关键字 inline，用于将一个函数声明为 内联函数。在程序编译时，编译器会将内联函数调用处<strong>用函数体替换</strong>，这一点类似于 C 语言中的宏扩展。所以，通常会将一些频繁被调用的短小函数声明为内联函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline 关键字与函数体放在一起才行</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>; <span class="comment">// 此时inline毫无作用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span>  <span class="comment">// fine</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="new-和-delete-操作符"><a href="#new-和-delete-操作符" class="headerlink" title="new 和 delete 操作符"></a>new 和 delete 操作符</h3><p>在 C 语言中，动态分配和释放内存的函数是 malloc、calloc 和 free，在 C++ 语言中，函数是 new、new[]、delete 和 delete[] 操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为 p 指针分配了一个 int 型的空间。new 操作符根据请求分配的数据类型来推断所需的空间大小。</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// new[] 则是为了分配一个数组的空间。</span></span><br><span class="line"><span class="keyword">int</span> *A = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>

<p>编写 C++ 程序时，应尽量使用 new、new[]、delete 和 delete[] 操作符进行动态内存分配和释放，而不要使用 C 语言中内存分配和释放的函数，因为这些操作符可以使用 C++ 的一些特性，如类的构造函数和析构函数，能够更好地管理 C++ 程序的内存。</p>
<h3 id="异常处理（try-和-catch）"><a href="#异常处理（try-和-catch）" class="headerlink" title="异常处理（try 和 catch）"></a>异常处理（try 和 catch）</h3><p>一个数组越界的异常捕获程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个值作为抛出异常的返回值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">index</span> &#123;</span></span><br><span class="line">  underflow,</span><br><span class="line">  overflow</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">array_index</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *A = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    A[i] = i;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">array_index</span>(A, <span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">array_index</span>(A, <span class="number">10</span>, <span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">array_index</span>(A, <span class="number">10</span>, <span class="number">15</span>) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (index e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == underflow) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;index underflow!&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e == overflow) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;index overflow!&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于返回数组 index 下标的数值，如果出现异常则抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">array_index</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> underflow;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> overflow;</span><br><span class="line">  <span class="keyword">return</span> A[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new 和 delete 动态分配内存操作符，如果 new 或 new[] 不能成功分配所请求的，将会抛出一个 bad_alloc 异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(bad_alloc) &#123;</span><br><span class="line">    cerr&lt;&lt;<span class="string">&quot;allocate failure!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，<strong>异常通常是通过函数返回值获得</strong>，但这样一来，函数是否产生异常则需要通过检测函数的返回值才能得知。而在 C++ 中，当函数抛出一个返回值时，即使不用 try 和 catch 语句，异常还是会被处理的，系统会自动调用默认处理函数 unexpected() 来执行。</p>
<h2 id="C-类和对象"><a href="#C-类和对象" class="headerlink" title="C++ 类和对象"></a>C++ 类和对象</h2><h3 id="类的定义和声明"><a href="#类的定义和声明" class="headerlink" title="类的定义和声明"></a>类的定义和声明</h3><p>有两种方法可以给出成员函数的定义：</p>
<ul>
<li>在类内部进行函数的声明和定义，此种方式我们成为 inline，也即内联定义。inline 是 C++ 关键字，专门用于表示内联；</li>
<li>在类内进行函数声明，在类外部进行函数定义。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> id_num;     <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> sex;       <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;age = a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> id_num;     <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> sex;       <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类外部定义set_age函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">student::set_age</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在类外部定义get_age函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">student::get_age</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类内声明函数，如果在函数声明时使用 inline 关键字，可以将类内声明类外定义的函数强制转换为内联函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> id_num;     <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> sex;       <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类外部定义set_age函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">student::set_age</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在类外部定义get_age函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">student::get_age</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类的信息隐藏机制"><a href="#类的信息隐藏机制" class="headerlink" title="类的信息隐藏机制"></a>类的信息隐藏机制</h3><p>三个关键字分别是：private、protected 和 public</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::setprice</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">  price = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">book::getprice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  book Alice;</span><br><span class="line">  Alice.<span class="built_in">setprice</span>(<span class="number">29.9</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The price of Alice is $&quot;</span> &lt;&lt; Alice.<span class="built_in">getprice</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="成员选择符"><a href="#成员选择符" class="headerlink" title="成员选择符"></a>成员选择符</h3><p>访问成员变量或成员函数可以通过成员选择符<code>.</code> 或指针操作符 <code>-&gt;</code> 来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::setprice</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">  price = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">book::getprice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  book Alice;</span><br><span class="line">  Alice.<span class="built_in">setprice</span>(<span class="number">29.9</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The price of Alice is $&quot;</span> &lt;&lt; Alice.<span class="built_in">getprice</span>() &lt;&lt; endl;</span><br><span class="line">  book *Harry = <span class="keyword">new</span> book;</span><br><span class="line">  Harry-&gt;<span class="built_in">setprice</span>(<span class="number">49.9</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The price of Harry is $&quot;</span> &lt;&lt; Harry-&gt;<span class="built_in">getprice</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类-class-和结构体-struct-区别"><a href="#类-class-和结构体-struct-区别" class="headerlink" title="类 class 和结构体 struct 区别"></a>类 class 和结构体 struct 区别</h3><ul>
<li>在 C 语言中，struct 是只能定义数据成员，而不能定义成员函数的。而在 C++ 中，struct 类似于 class，既可以定义数据成员，又可以定义成员函数。</li>
<li><strong>在 C++ 中，struct 与 class 基本是通用的</strong>，唯一不同的是如果使用 class 关键字，类中定义的成员变量或成员函数默认都是 private 属性的，而采用 struct 关键字，结构体中定义的成员变量或成员函数默认都是 public 属性的。</li>
<li>在 C++ 中，没有抛弃 C 语言中的 struct 关键字，其意义就在于给 C 语言程序开发人员有一个归属感，并且能让 C++ 编译器兼容以前用 C 语言开发出来的项目。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> * title;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;title&lt;&lt;<span class="string">&quot;, price: &quot;</span>&lt;&lt;price&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    book Alice;</span><br><span class="line">    Alice.price = <span class="number">29.9</span>;     <span class="comment">//It’s OK</span></span><br><span class="line">    Alice.title = <span class="string">&quot;Alice in wonderland&quot;</span>;  <span class="comment">//It’s OK</span></span><br><span class="line">    Alice.<span class="built_in">display</span>();        <span class="comment">//It’s OK</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> * title;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;title&lt;&lt;<span class="string">&quot;, price: &quot;</span>&lt;&lt;price&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    book Alice;</span><br><span class="line">    Alice.price = <span class="number">29.9</span>;     <span class="comment">//compile error</span></span><br><span class="line">    Alice.title = <span class="string">&quot;Alice in wonderland&quot;</span>;  <span class="comment">// compile error</span></span><br><span class="line">    Alice.<span class="built_in">display</span>();        <span class="comment">// compile error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过引用来传递和返回类对象"><a href="#通过引用来传递和返回类对象" class="headerlink" title="通过引用来传递和返回类对象"></a>通过引用来传递和返回类对象</h3><p>因为引用表达更加简练直观，因此较少使用指针来传递对象或作为函数返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span> *a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">gettitle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> *title;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::setprice</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">  price = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">book::getprice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::settitle</span><span class="params">(<span class="keyword">char</span> *a)</span> </span>&#123;</span><br><span class="line">  title = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">book::gettitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(book &amp;b)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The price of &quot;</span> &lt;&lt; b.<span class="built_in">gettitle</span>() &lt;&lt; <span class="string">&quot; is $&quot;</span> &lt;&lt; b.<span class="built_in">getprice</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">book &amp;<span class="title">init</span><span class="params">(<span class="keyword">char</span> *t, <span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> book b;</span><br><span class="line">  b.<span class="built_in">settitle</span>(t);</span><br><span class="line">  b.<span class="built_in">setprice</span>(p);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  book Alice;</span><br><span class="line">  Alice.<span class="built_in">settitle</span>(<span class="string">&quot;Alice in Wonderland&quot;</span>);</span><br><span class="line">  Alice.<span class="built_in">setprice</span>(<span class="number">29.9</span>);</span><br><span class="line">  <span class="built_in">display</span>(Alice);   <span class="comment">// The price of Alice in Wonderland is $29.9</span></span><br><span class="line">  </span><br><span class="line">  book Harry;</span><br><span class="line">  Harry = <span class="built_in">init</span>(<span class="string">&quot;Harry Potter&quot;</span>, <span class="number">49.9</span>);</span><br><span class="line">  <span class="built_in">display</span>(Harry);   <span class="comment">// The price of Harry Potter is $49.9</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是类中一种特殊的成员函数，其特殊之处有三点：</p>
<ul>
<li>构造函数的函数名必须与类名相同；</li>
<li>构造函数无返回值；</li>
<li>当我们创建类对象的时候，构造函数会被自动调用，而无需我们主动调用。</li>
</ul>
<p>一个类中可以有多个构造函数，构造函数之间构成<code>函数重载</code>的关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="comment">// 第一个没有参数的构造函数 book()，其定义就在类内部；</span></span><br><span class="line">    <span class="built_in">book</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span> *a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">gettitle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> *title;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二个构造函数 book(char * a, double p) 在类内部声明，类外部定义。</span></span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p) &#123;</span><br><span class="line">  title = a;</span><br><span class="line">  price = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当没有任何自定义的构造函数时，系统会创建默认的构造函数：<code>book() &#123;&#125;</code>。</p>
<h3 id="参数初始化表"><a href="#参数初始化表" class="headerlink" title="参数初始化表"></a>参数初始化表</h3><p>参数初始化表：说明一个类的数据成员的初始值，在构造函数体执行前，首先用初始值列表中的值初始化数据成员。未经初始值列表初始化的成员将被默认初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">book</span>()&#123;&#125;</span><br><span class="line">      <span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p);</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span>* a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">char</span> * <span class="title">gettitle</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在函数首部与函数体之间增添了一个: 冒号并加上 title(a),price(p) 语句，等同于在函数体内部写 title = a; price = p; 语句</span></span><br><span class="line"><span class="comment">// 这种初始化对象的方式就称为参数初始化表。</span></span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p):<span class="built_in">title</span>(a),<span class="built_in">price</span>(p)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>参数初始化表还有一个很重要的作用，那就是为 const 成员变量初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能在函数体内部初始化 const 变量：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Array</span>() &#123;</span><br><span class="line">          length = <span class="number">0</span>; <span class="comment">//compile error</span></span><br><span class="line">          num = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> length;</span><br><span class="line">      <span class="keyword">int</span> * num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>length 加了 const 关键字修饰。此时默认构造函数再为 length 赋值为 0，这是无法通过编译的。</p>
<p>初始化 const 成员变量的唯一方法只有利用参数初始化表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(): <span class="built_in">length</span>(<span class="number">0</span>) &#123; num = <span class="literal">NULL</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> * num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用参数初始化表还需要注意的是，参数初始化顺序与初始化表列出表量的顺序无关，参数初始化顺序只与成员变量在类中声明的顺序有关。</p>
<h3 id="使用默认参数的构造函数"><a href="#使用默认参数的构造函数" class="headerlink" title="使用默认参数的构造函数"></a>使用默认参数的构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">book</span>()&#123;&#125;</span><br><span class="line">  		<span class="comment">// 默认参数</span></span><br><span class="line">      <span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p = <span class="number">5.0</span>);</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在定义函数的时候可以不指定默认参数</span></span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p)  &#123;</span><br><span class="line">    title = a;</span><br><span class="line">    price = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The price of &quot;</span>&lt;&lt;title&lt;&lt;<span class="string">&quot; is $&quot;</span>&lt;&lt;price&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">book <span class="title">Harry</span><span class="params">(<span class="string">&quot;Harry Potter&quot;</span>, <span class="number">49.9</span>)</span></span>;</span><br><span class="line">    Harry.<span class="built_in">display</span>();</span><br><span class="line">    <span class="function">book <span class="title">Gone</span><span class="params">(<span class="string">&quot;Gone with the Wind&quot;</span>)</span></span>;  <span class="comment">// 没有指定p参数</span></span><br><span class="line">    Gone.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>默认带参构造函数所带来的歧义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">book</span>()&#123;&#125;</span><br><span class="line">      <span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p = <span class="number">5.0</span>);</span><br><span class="line">      <span class="built_in">book</span>(<span class="keyword">char</span> *a);</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span>* a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">char</span> * <span class="title">gettitle</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在定义函数的时候可以不指定默认参数</span></span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p) &#123;</span><br><span class="line">    title = a;</span><br><span class="line">    price = p;</span><br><span class="line">&#125;</span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span> *a) &#123;</span><br><span class="line">    title = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The price of &quot;</span>&lt;&lt;title&lt;&lt;<span class="string">&quot; is $&quot;</span>&lt;&lt;price&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">book <span class="title">Harry</span><span class="params">(<span class="string">&quot;Harry potter&quot;</span>, <span class="number">49.9</span>)</span></span>;</span><br><span class="line">    Harry.<span class="built_in">display</span>();</span><br><span class="line">  	<span class="comment">// 此时我们创建对象有两个与之匹配的构造函数可以调用，</span></span><br><span class="line">  	<span class="comment">// 分别是 book(char *a); 和 book(char* a, double p = 5.0);，</span></span><br><span class="line">    <span class="comment">// 此时该调用哪一个呢？无法得知，编译器只能报错了。</span></span><br><span class="line">    <span class="function">book <span class="title">Gone</span><span class="params">(<span class="string">&quot;Gone with the Wind&quot;</span>)</span></span>; <span class="comment">//compile error</span></span><br><span class="line">    Gone.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常而言，在设计类的构造函数的时候最好不要同时使用构造函数的重载和带参数的构造函数，以避免上述问题。</p>
<h3 id="利用构造函数限制对象的创建"><a href="#利用构造函数限制对象的创建" class="headerlink" title="利用构造函数限制对象的创建"></a>利用构造函数限制对象的创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p);</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span>* a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">char</span> * <span class="title">gettitle</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p);</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span>* a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">char</span> * <span class="title">gettitle</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  		<span class="comment">// 将构造函数设置为private，使其无法在类外进行访问</span></span><br><span class="line">      <span class="built_in">book</span>()&#123;&#125;</span><br><span class="line">      <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="转型构造函数"><a href="#转型构造函数" class="headerlink" title="转型构造函数"></a>转型构造函数</h3><p>带参数的构造函数中有两种比较常见的构造函数：<code>拷贝构造函数</code>和<code>转型构造函数</code>。</p>
<p>转型构造函数<strong>用于类型间的转换</strong>，将其它数据类型转变为类的对象类型。</p>
<p>转型构造函数只有一个参数：</p>
<ul>
<li>如果该参数是 <code>int</code> 型，则将 int 型对象转换为类对象，</li>
<li>如果该参数类型为 <code>char*</code> 类型，则将字符串常量转换为类对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 将 int 型转换为类对象类型</span></span><br><span class="line">      <span class="built_in">Age</span>(<span class="keyword">int</span> a)&#123;age = a;&#125;</span><br><span class="line">  <span class="keyword">private</span> :</span><br><span class="line">      <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  		<span class="comment">// 默认构造函数</span></span><br><span class="line">      <span class="built_in">student</span>()&#123;&#125;</span><br><span class="line">  		<span class="comment">// 将字符串常量转换为类对象类型</span></span><br><span class="line">      <span class="built_in">student</span>(<span class="keyword">char</span> * n)&#123;name = n;&#125;</span><br><span class="line">  <span class="keyword">private</span> :</span><br><span class="line">      <span class="keyword">char</span> * name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们在程序设计过程中有一个以类对象作为函数参数的函数，函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(student s)</span></span>; <span class="comment">//函数声明</span></span><br></pre></td></tr></table></figure>

<p>如果我们设计了如下程序以调用该函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * name = “Harry Potter”;</span><br><span class="line"><span class="built_in">fun</span>(name);</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们在 student 类中定义了 <code>student(char * n);</code> 这样一个转型构造函数 ，该函数可以将字符串常量转换为 student 类的对象。在我们运行 <code>fun(name);</code> 语句时，<strong>编译器会自动调用转型构造函数将 name 转换为 student 类的对象</strong>，然后调用 <code>void fun(student s);</code> 函数。</p>
<p>这一系列的过程都是编译器自动完成的，我们称此时的 student 类的转型构造函数 <code>student(char * n);</code> 支持隐式类型转换。</p>
<p>隐式类型转换可能会带来一些难以觉察的细微错误。有时候为了避免这种错误，我们希望直接强制关闭掉这种隐式类型转换，在 C++ 中，通过关键字 <code>explicit</code> 可以实现该功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">student</span>()&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">student</span><span class="params">(<span class="keyword">char</span> * n)</span></span>&#123;name = n;&#125;</span><br><span class="line">  <span class="keyword">private</span> :</span><br><span class="line">      <span class="keyword">char</span> * name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就算使用了 explicit，我们也可以使用显式的强制转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * name = “Harry Potter”;</span><br><span class="line"><span class="built_in">func</span>(<span class="keyword">static_cast</span>&lt;student&gt;(name));  <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">student</span>(name));               <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>



<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>
<ul>
<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>
<li>复制对象把它作为参数传递给函数。</li>
<li>复制对象，并从函数返回这个对象。</li>
</ul>
<p>为什么拷贝构造函数的参数一定要是对象的引用呢？答：如果不是引用，而是通过传值的方式将实参传递给形参，这中间本身就要经历一次对象的拷贝的过程，而对象拷贝则必须调用拷贝构造函数，如此一来则会形成一个死循环，无解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型1</span></span><br><span class="line"><span class="built_in">book</span>(book &amp;b);</span><br><span class="line"><span class="comment">// 原型2</span></span><br><span class="line"><span class="built_in">book</span>(<span class="keyword">const</span> book &amp;b); <span class="comment">// 规定在创建新对象的时候不得修改被拷贝的对象</span></span><br></pre></td></tr></table></figure>

<p>如果类的设计人员不在类中显示的声明一个拷贝构造函数，则系统会自动地为类生成一个拷贝构造函数，自动生成的拷贝构造函数功能简单，只能将源对象的所有成员变量一一复制给当前创建的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">book</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">book</span>(book &amp;b);</span><br><span class="line">    <span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p = <span class="number">5.0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> *title;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动生成的拷贝构造函数</span></span><br><span class="line">book::<span class="built_in">book</span>(book &amp;b) &#123;</span><br><span class="line">  price = b.price;</span><br><span class="line">  title = b.title;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p) &#123;</span><br><span class="line">  title = a;</span><br><span class="line">  price = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The price of &quot;</span> &lt;&lt; title &lt;&lt; <span class="string">&quot; is $&quot;</span> &lt;&lt; price &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数用途：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>() &#123;</span><br><span class="line">      length = <span class="number">0</span>;</span><br><span class="line">      num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> *A, <span class="keyword">int</span> n);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setnum</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">getaddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">int</span> *A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">  num = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  length = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    num[i] = A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::setnum</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; length)</span><br><span class="line">    num[index] = value;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;index out of range!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    cout &lt;&lt; num[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">Array::getaddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> A[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="function">Array <span class="title">arr1</span><span class="params">(A, <span class="number">5</span>)</span></span>;</span><br><span class="line">  arr1.<span class="built_in">display</span>();   <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">  </span><br><span class="line">  <span class="function">Array <span class="title">arr2</span><span class="params">(arr1)</span></span>; <span class="comment">// 调用自动生成的拷贝构造函数</span></span><br><span class="line">  arr2.<span class="built_in">display</span>();   <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">  </span><br><span class="line">  arr2.<span class="built_in">setnum</span>(<span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">  arr2.<span class="built_in">display</span>();   <span class="comment">// 1 2 8 4 5</span></span><br><span class="line">  arr1.<span class="built_in">display</span>();   <span class="comment">// 1 2 8 4 5</span></span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; arr1.<span class="built_in">getaddress</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr2.<span class="built_in">getaddress</span>() &lt;&lt; endl;  <span class="comment">// 00331F58 00331F58</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 arr1 对象初始化 arr2 对象，因为我们在类中没有显示地定义一个拷贝构造函数，因此系统会自动为我们生成一个拷贝构造函数，该拷贝构造函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动生成的拷贝构造函数</span></span><br><span class="line">Array::<span class="built_in">Array</span>(Array &amp;a) &#123;</span><br><span class="line">  length = a.length;</span><br><span class="line">  num = a.num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过系统自动生成的拷贝构造函数完成 arr2 对象的创建，同样的 arr2 也是有 5 个元素的数组，打印出来的结果是 <code>1 2 3 4 5</code>，同样没有问题。</p>
<p>避免拷贝构造函数生成的队形和函数参数使用同一块内存空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array::<span class="built_in">Array</span>(Array &amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a.num != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        length = a.length;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">            num[i] = a.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于类会自动生成拷贝构造函数，因此有些时候为了不让对象发生拷贝行为，我们可以显示声明一个拷贝构造函数，并将其设置为 private 属性。这跟通过将默认构造函数设置成 private 属性限制对象的创建时一样的道理。当然，禁止对象发生拷贝的需求较少。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数就是用于回收创建对象时所消耗的各种资源。与构造函数类似，析构函数也是一个成员函数。析构函数与普通成员函数相比，有如下特征：</p>
<ul>
<li>无返回值；</li>
<li>没有参数，不能被重载，因此一个类也只能含有一个析构函数；</li>
<li>函数名必须为 <code>~类名</code> 的形式，符号 “~” 与类名之间可以有空格。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>() &#123;</span><br><span class="line">      length = <span class="number">0</span>;</span><br><span class="line">      num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> *A, <span class="keyword">int</span> n);</span><br><span class="line">    <span class="built_in">Array</span>(Array &amp;a);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setnum</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">getaddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line">    ~<span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::~<span class="built_in">Array</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (num != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">delete</span>[] num;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(Array &amp;a) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.num != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    length = a.length;</span><br><span class="line">    num = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">      num[i] = a.num[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">int</span> *A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">  num = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  length = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    num[i] = A[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::setnum</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; length)</span><br><span class="line">    num[index] = value;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;index out of range!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    cout &lt;&lt; num[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">Array::getaddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> A[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="function">Array <span class="title">arr1</span><span class="params">(A, <span class="number">5</span>)</span></span>;</span><br><span class="line">  arr1.<span class="built_in">display</span>();</span><br><span class="line">  <span class="function">Array <span class="title">arr2</span><span class="params">(arr1)</span></span>;</span><br><span class="line">  arr2.<span class="built_in">display</span>();</span><br><span class="line">  arr2.<span class="built_in">setnum</span>(<span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">  arr1.<span class="built_in">display</span>();</span><br><span class="line">  arr2.<span class="built_in">display</span>();</span><br><span class="line">  cout &lt;&lt; arr1.<span class="built_in">getaddress</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr2.<span class="built_in">getaddress</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数的调用顺序：与构造函数调用顺序是反转过来的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">test</span>(<span class="keyword">int</span> i)&#123;num = i;cout&lt;&lt;num&lt;&lt;<span class="string">&quot; Constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">      ~<span class="built_in">test</span>()&#123;cout&lt;&lt;num&lt;&lt;<span class="string">&quot; Destructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">test <span class="title">t0</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">test <span class="title">t2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">test <span class="title">t3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0  Constructor</span></span><br><span class="line"><span class="comment">// 1  Constructor</span></span><br><span class="line"><span class="comment">// 2  Constructor</span></span><br><span class="line"><span class="comment">// 3  Constructor</span></span><br><span class="line"><span class="comment">// 3  Destructor</span></span><br><span class="line"><span class="comment">// 2  Destructor</span></span><br><span class="line"><span class="comment">// 1  Destructor</span></span><br><span class="line"><span class="comment">// 0  Destructor</span></span><br></pre></td></tr></table></figure>



<h3 id="常量指针-this"><a href="#常量指针-this" class="headerlink" title="常量指针 this"></a>常量指针 this</h3><p>this 是 C++ 的一个关键字，this 指针指向调用本函数的对象，其值为该对象的首地址。通过该指针，我们可以在成员函数的函数体内访问对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">book</span>()&#123;<span class="keyword">this</span>-&gt;price = <span class="number">0.0</span>; <span class="keyword">this</span>-&gt;title = <span class="literal">NULL</span>;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">book</span>()&#123;price = <span class="number">0.0</span>; title = <span class="literal">NULL</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面两个代码的效果是一样的。</p>
<h3 id="类与-new-和-delete-操作符"><a href="#类与-new-和-delete-操作符" class="headerlink" title="类与 new 和 delete 操作符"></a>类与 new 和 delete 操作符</h3><p>虽然 malloc() 函数具有分配存储空间的功能，但是这些函数除了分配存储空间外，不会调用类的构造函数。而 C++ 语言提供的 new 和 new[] 操作符则不会如此，使用它们为对象分配存储空间的同时，它们也会调用相应的构造函数。</p>
<p>操作符 delete 和 delete[] 在释放对象存储空间的同时也会调用析构函数，而 free() 函数则不会调用析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">test</span>(<span class="keyword">int</span> i = <span class="number">1</span>)&#123;num = i;cout&lt;&lt;num&lt;&lt;<span class="string">&quot; Constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">      ~<span class="built_in">test</span>()&#123;cout&lt;&lt;num&lt;&lt;<span class="string">&quot; Destructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test *t0 = <span class="keyword">new</span> <span class="built_in">test</span>(<span class="number">0</span>);</span><br><span class="line">    test *t1 = <span class="keyword">new</span> test[<span class="number">5</span>];</span><br><span class="line">    test *t2 = (test *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(test));  <span class="comment">//malloc() 没有调用构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t0;</span><br><span class="line">    <span class="keyword">delete</span>[] t1;</span><br><span class="line">    <span class="built_in">free</span>(t2);   <span class="comment">// free() 也没有调用析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 Constructor</span></span><br><span class="line"><span class="comment">// 1 Constructor</span></span><br><span class="line"><span class="comment">// 1 Constructor</span></span><br><span class="line"><span class="comment">// 1 Constructor</span></span><br><span class="line"><span class="comment">// 1 Constructor</span></span><br><span class="line"><span class="comment">// 1 Constructor</span></span><br><span class="line"><span class="comment">// 0 Destructor</span></span><br><span class="line"><span class="comment">// 1 Destructor</span></span><br><span class="line"><span class="comment">// 1 Destructor</span></span><br><span class="line"><span class="comment">// 1 Destructor</span></span><br><span class="line"><span class="comment">// 1 Destructor</span></span><br><span class="line"><span class="comment">// 1 Destructor</span></span><br></pre></td></tr></table></figure>



<h3 id="类与-const-关键字"><a href="#类与-const-关键字" class="headerlink" title="类与 const 关键字"></a>类与 const 关键字</h3><p>借助 const 关键字可以定义 const 类型的成员变量、成员函数、常对象以及对象的常引用。</p>
<ul>
<li><code>const 成员变量</code>：其用法和普通的 const 变量用法相似，在定义时只需在前面加上 const 关键字即可。const 成员变量的初始化只有唯一的一条途径：参数初始化表。这个在前面已经提到过，不记得的话可以再去翻看参数初始化表那一小节。</li>
<li><code>const 成员函数</code>：<strong>可以使用类中的所有成员变量，但是不能修改变量的值</strong>，这种措施主要还是为了保护数据而设置的。</li>
<li><code>const 对象</code>：常对象。一旦将对象定义为常对象之后，该对象就只能调用类中的常成员函数了。</li>
<li><code>对象的 const 引用</code>：避免对对象本身做修改</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">book</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p = <span class="number">5.0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span>* a)</span></span>;</span><br><span class="line">  	<span class="comment">// 常成员函数可以访问类中的任何成员变量，但是不能修改任何成员变量。</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">gettitle</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">book::getprice</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">book::gettitle</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要将 getprice，gettitle 函数定义成常成员函数呢？这两个函数的功能就是为了返回 price() 和 title() 的，功能单一，并且不希望修改这两个变量的，如此，定义成常成员函数是非常保险的一种做法，可以避免在这两个函数内部修改成员变量。如果需要修改这两个变量则只需通过 setprice() 和 settitle() 函数完成，因此设置为 const 是非常合适的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	    <span class="built_in">book</span>() &#123;&#125;</span><br><span class="line">      <span class="built_in">book</span>(book &amp;b);</span><br><span class="line">      <span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p = <span class="number">5.0</span>);</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">  		<span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span>* a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">char</span> * <span class="title">gettitle</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	    <span class="keyword">double</span> price;</span><br><span class="line">  		<span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br><span class="line">book::<span class="built_in">book</span>(book &amp;b) &#123;</span><br><span class="line">	price = b.price;</span><br><span class="line">	title = b.title;</span><br><span class="line">&#125;</span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p) &#123;</span><br><span class="line">	title = a;</span><br><span class="line">	price = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::display</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;The price of &quot;</span>&lt;&lt;title&lt;&lt;<span class="string">&quot; is $&quot;</span>&lt;&lt;price&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::setprice</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">	price = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">book::getprice</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::settitle</span><span class="params">(<span class="keyword">char</span>* a)</span> </span>&#123;</span><br><span class="line">	title = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">book::gettitle</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> book <span class="title">Alice</span><span class="params">(<span class="string">&quot;Alice in Wonderland&quot;</span>,<span class="number">29.9</span>)</span></span>;</span><br><span class="line">	Alice.<span class="built_in">display</span>();</span><br><span class="line">	Alice.<span class="built_in">setprice</span>(<span class="number">51.0</span>); <span class="comment">//compile error</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些时候我们在程序设计过程中要求修改常对象中的某个成员变量，这个时候如果是普通的成员变量是不能被修改的。为了满足这一需求，C++ 提供了 mutable 关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> var;</span><br></pre></td></tr></table></figure>

<p>通过这样的声明将变量 var 声明为可变的成员变量，此时如果要修改常对象的该变量时，只需要通过常对象调用 const 成员函数修改该变量即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	    <span class="built_in">book</span>() &#123;&#125;</span><br><span class="line">      <span class="built_in">book</span>(book &amp;b);</span><br><span class="line">      <span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p = <span class="number">5.0</span>);</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">  		<span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span>* a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">char</span> * <span class="title">gettitle</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	    <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br><span class="line">book::<span class="built_in">book</span>(book &amp;b) &#123;</span><br><span class="line">	price = b.price;</span><br><span class="line">	title = b.title;</span><br><span class="line">&#125;</span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p) &#123;</span><br><span class="line">	title = a;</span><br><span class="line">	price = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::setprice</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">	price = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">book::getprice</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::settitle</span><span class="params">(<span class="keyword">char</span>* a)</span> </span>&#123;</span><br><span class="line">	title = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">book::gettitle</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 display 函数声明为顶层函数，其函数形参为 book 类对象的常引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> book &amp;b)</span> </span>&#123;</span><br><span class="line">	b.<span class="built_in">setprice</span>(<span class="number">59.9</span>); <span class="comment">// compile error</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;The price of &quot;</span>&lt;&lt;b.<span class="built_in">gettitle</span>()&lt;&lt;<span class="string">&quot; is $&quot;</span>&lt;&lt;b.<span class="built_in">getprice</span>()&lt;&lt;endl;  <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">book <span class="title">Alice</span><span class="params">(<span class="string">&quot;Alice in Wonderland&quot;</span>,<span class="number">29.9</span>)</span></span>;</span><br><span class="line">	<span class="built_in">display</span>(Alice);</span><br><span class="line">	<span class="function">book <span class="title">Harry</span><span class="params">(<span class="string">&quot;Harry potter&quot;</span>, <span class="number">49.9</span>)</span></span>;</span><br><span class="line">	<span class="built_in">display</span>(Harry);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类与-static-关键字"><a href="#类与-static-关键字" class="headerlink" title="类与 static 关键字"></a>类与 static 关键字</h3><p>普通的成员变量和成员函数都是属于对象的。类中的成员变量或成员函数一旦与 static 关键字相结合，则该成员变量或成员函数就是属于类的，而不是再是属于任何一个对象的，当然任何一个对象都可以共享该成员变量及成员函数。</p>
<ul>
<li><code>静态成员变量</code>：静态成员变量属于类而不属于任何一个对象，如此一来可以实现数据共享功能。如果其中有任何一个修改该静态成员变量，所有其他的调用静态成员变量都会跟着一起改变。静态成员变量不会影响类及其对象的大小，也即 sizeof 结果不会受到影响。</li>
<li><code>静态成员函数</code>：静态成员函数只能访问 static 成员变量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">student</span>()&#123;count ++;&#125;</span><br><span class="line">    ~<span class="built_in">student</span>()&#123;count --;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 C++ 语法中规定静态成员变量会被默认初始化为 0，类外定义可有可无。</span></span><br><span class="line"><span class="comment">// 实际上在一些编译器中，如果不加上类外的定义，会出现一些不可知的情况，故在实际设计程序的时候最好还是将类外定义加上。</span></span><br><span class="line"><span class="keyword">int</span> student::count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> test::num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  test one;</span><br><span class="line">  test two;</span><br><span class="line">  test three;</span><br><span class="line">  cout &lt;&lt; test::num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; one.num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; two.num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; three.num &lt;&lt; endl; <span class="comment">// 1 1 1 1</span></span><br><span class="line">  test::num = <span class="number">5</span>; <span class="comment">// 法1</span></span><br><span class="line">  cout &lt;&lt; test::num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; one.num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; two.num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; three.num &lt;&lt; endl; <span class="comment">// 5 5 5 5</span></span><br><span class="line">  one.num = <span class="number">8</span>;   <span class="comment">// 法2</span></span><br><span class="line">  cout &lt;&lt; test::num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; one.num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; two.num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; three.num &lt;&lt; endl; <span class="comment">// 8 8 8 8</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">test</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;num = a; plus = b;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getnum</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> num;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> num+plus;&#125;  <span class="comment">//compile error</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setnum</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;num = a;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setplus</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;plus = a;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">      <span class="keyword">int</span> plus;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> test::num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test one;</span><br><span class="line">    one.<span class="built_in">setnum</span>(<span class="number">5</span>);</span><br><span class="line">    cout&lt;&lt;test::<span class="built_in">getnum</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问静态成员变量和静态成员函数首选的方法是通过类来访问，毕竟静态成员变量和静态成员函数都是属于类的，与类相关联，而不是属于类的对象。由于静态成员变量和静态成员函数都是属于类，而不是属于对象，因此静态成员函数内部也不存在 this 指针。</p>
<p>在静态成员函数内部可以声明静态变量，注意不是静态成员变量。如果在静态成员函数内部声明一个静态变量，则该类的所有对象将共享这个变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test::add</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    num += a;</span><br><span class="line">    count += a;</span><br><span class="line">    cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test one,two,three;</span><br><span class="line">    one.<span class="built_in">add</span>(<span class="number">5</span>);    <span class="comment">// 5 5</span></span><br><span class="line">    two.<span class="built_in">add</span>(<span class="number">4</span>);    <span class="comment">// 9 4</span></span><br><span class="line">    three.<span class="built_in">add</span>(<span class="number">11</span>); <span class="comment">// 20 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h3><p>友元：友元类向外部提供其非公有成员访问权限的一种机制。友元的访问权限与成员函数一样。</p>
<p>通过 friend 关键字，我们可以将不属于当前类的一个函数在当前类中加以声明，该函数便可以成为当前类的友元函数。友元函数可以访问这个类中的私有成员。</p>
<p><strong>为了保证数据的安全，友元函数的使用宁缺毋滥</strong>。如果不是能够极大提高程序运行效率的情况，最好不要用友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">book</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p);</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(book &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> *title;</span><br><span class="line">&#125;;</span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p) &#123;</span><br><span class="line">  title = a;</span><br><span class="line">  price = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 借助 friend 关键字，在 display 函数体内，我们就能访问 private 属性的 title 和 price 成员变量。这就是友元函数的作用。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(book &amp;b)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The price of &quot;</span> &lt;&lt; b.title &lt;&lt; <span class="string">&quot; is $&quot;</span> &lt;&lt; b.price &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">book <span class="title">Alice</span><span class="params">(<span class="string">&quot;Alice in Wonderland&quot;</span>, <span class="number">29.9</span>)</span></span>;</span><br><span class="line">  <span class="built_in">display</span>(Alice);  <span class="comment">// The price of Alice in Wonderland is $29.9</span></span><br><span class="line">  <span class="function">book <span class="title">Harry</span><span class="params">(<span class="string">&quot;Harry potter&quot;</span>, <span class="number">49.9</span>)</span></span>;</span><br><span class="line">  <span class="built_in">display</span>(Harry);  <span class="comment">// The price of Harry potter is $49.9</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了顶层函数可以被定义为友元函数之外，其它类的成员函数同样可以声明为本类的友元函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">date</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">date</span>(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(time &amp;t)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">time</span>(<span class="keyword">int</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> h);</span><br><span class="line">  	<span class="comment">// 该函数既能访问 date 类中的私有成员变量，同时又能访问 time 类中的私有成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">date::display</span><span class="params">(time &amp;t)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    <span class="keyword">int</span> minute;</span><br><span class="line">    <span class="keyword">int</span> hour;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">time::<span class="built_in">time</span>(<span class="keyword">int</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> h) &#123;</span><br><span class="line">  second = s;</span><br><span class="line">  minute = m;</span><br><span class="line">  hour = h;</span><br><span class="line">&#125;</span><br><span class="line">date::<span class="built_in">date</span>(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d) &#123;</span><br><span class="line">  year = y;</span><br><span class="line">  month = m;</span><br><span class="line">  day = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">date::display</span><span class="params">(time &amp;t)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The time is:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; year &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; t.hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t.minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">date <span class="title">d</span><span class="params">(<span class="number">2015</span>, <span class="number">1</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">  <span class="function">time <span class="title">t</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  d.<span class="built_in">display</span>(t);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>date 类的定义必须出现在 time 类之前，这么做是为了使得 display() 函数的函数声明能够在声明为友元函数之前；</li>
<li>display() 函数的形参为 time 类对象的引用，而 time 类又必须定义在 date 类之后，如此一来只能先将 time 类声明在 date 类之前了，如 <code>class time;</code> 这一语句即是为了声明 time 类；</li>
<li>display() 函数的定义需要放到 time 类定义的后面，这是因为 display() 函数中必须用到 time 类中的私有成员变量，因此在使用之前，这些成员变量必须先声明出来。</li>
</ol>
<p>友元类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">date</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">date</span>(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(time &amp;t)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将 date 类声明为 time 类的友元类。</span></span><br><span class="line">  	<span class="comment">// 此时 date 类中的所有成员函数都将转化为 time 类的友元函数，可以访问 time 类中的所有成员。</span></span><br><span class="line">    <span class="keyword">friend</span> date;</span><br><span class="line">    <span class="built_in">time</span>(<span class="keyword">int</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> h);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    <span class="keyword">int</span> minute;</span><br><span class="line">    <span class="keyword">int</span> hour;</span><br><span class="line">&#125;;</span><br><span class="line">time::<span class="built_in">time</span>(<span class="keyword">int</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> h) &#123;</span><br><span class="line">  second = s;</span><br><span class="line">  minute = m;</span><br><span class="line">  hour = h;</span><br><span class="line">&#125;</span><br><span class="line">date::<span class="built_in">date</span>(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d) &#123;</span><br><span class="line">  year = y;</span><br><span class="line">  month = m;</span><br><span class="line">  day = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">date::display</span><span class="params">(time &amp;t)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The time is:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; year &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; t.hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t.minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">date <span class="title">d</span><span class="params">(<span class="number">2015</span>, <span class="number">1</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">  <span class="function">time <span class="title">t</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  d.<span class="built_in">display</span>(t);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="继承和派生"><a href="#继承和派生" class="headerlink" title="继承和派生"></a>继承和派生</h2><p>继承和派生代指的是 C++ 中类和类之间的关系，它们是同一个概念，只是站的角度不同。</p>
<ul>
<li>继承指的是一个类从另一个类获取成员变量和成员方法的过程；</li>
<li>派生指的是一个类将自己的成员变量和成员方法赋予另一个类的过程。</li>
</ul>
<p>继承和派生的含义与现实世界中的继承关系类似，继承指的是儿子接收父亲的产业，派生是父亲把产业传承给儿子。</p>
<h3 id="继承的语法及方式"><a href="#继承的语法及方式" class="headerlink" title="继承的语法及方式"></a>继承的语法及方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">language</span> &#123;</span>cpp, java, python,javascript, php, ruby&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span> *a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">gettitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> *title;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// public 指明继承方式属于公有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">codingbook</span> :</span> <span class="keyword">public</span> book &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setlang</span><span class="params">(language lang)</span></span>;</span><br><span class="line">    <span class="function">language <span class="title">getlang</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lang; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    language lang;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继承方式有三种：public、protected 和 private。在未指定的情况下编译器会默认继承方式为 protected 或 private 方式。</p>
<p>public 继承方式：</p>
<ul>
<li>基类中所有 public 成员在派生类中为 public 属性；</li>
<li>基类中所有 protected 成员在派生类中为 protected 属性；</li>
<li>基类中所有 private 成员在派生类中不可访问。</li>
</ul>
<p>protected 继承方式：</p>
<ul>
<li>基类中的所有 public 成员在派生类中为 protected 属性；</li>
<li>基类中的所有 protected 成员在派生类中为 protected 属性；</li>
<li>基类中的所有 private 成员在派生类中仍然不可访问。</li>
</ul>
<p>private 继承方式：</p>
<ul>
<li>基类中的所有 public 成员在派生类中均为 private 属性；</li>
<li>基类中的所有 protected 成员在派生类中均为 private 属性；</li>
<li>基类中的所有 private 成员在派生类中均不可访问。</li>
</ul>
<p>例如 book 类的公有的 setprice() 和 settitle() 成员函数继承到 codingbook 类后，这两个成员变量的属性仍将是 public 属性。</p>
<h3 id="改变基类成员在派生类中的访问属性"><a href="#改变基类成员在派生类中的访问属性" class="headerlink" title="改变基类成员在派生类中的访问属性"></a>改变基类成员在派生类中的访问属性</h3><p>使用 using 声明可以改变基类成员在派生类中的访问属性。</p>
<p>我们知道基类的公有成员经过公有继承，在派生类中其属性为 public 的，但是通过 using 声明，我们可以将其改为 private 或 protected 属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">language</span> &#123;</span>cpp, java, python,javascript, php, ruby&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span>* a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">char</span> * <span class="title">gettitle</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">codingbook</span>:</span> <span class="keyword">public</span> book &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setlang</span><span class="params">(language lang)</span></span>;</span><br><span class="line">      <span class="function">language <span class="title">getlang</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> lang;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      language lang;</span><br><span class="line">  		<span class="comment">// 通过 using 声明后，由 public 属性变为了 private 属性了。</span></span><br><span class="line">      <span class="keyword">using</span> book::setprice;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    codingbook think;</span><br><span class="line">    think.<span class="built_in">setlang</span>(cpp);</span><br><span class="line">    think.<span class="built_in">settitle</span>(<span class="string">&quot;Thinking in C++&quot;</span>);</span><br><span class="line">    think.<span class="built_in">setprice</span>(<span class="number">78.9</span>);  <span class="comment">//compile error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="名字隐藏"><a href="#名字隐藏" class="headerlink" title="名字隐藏"></a>名字隐藏</h3><p>如果派生类中新增一个成员变量，该成员变量与基类中的成员变量同名，则新增的成员变量就会遮蔽从基类中继承过来的成员变量。同理，如果派生类中新增的成员函数与基类中的成员函数同名，则该新增的成员函数就会遮蔽从基类中继承过来的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basic</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;x = a;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">sety</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;y = b;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> basic &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">char</span> *a)</span></span>&#123;x = a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">getx</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    derived d1;</span><br><span class="line">    d1.<span class="built_in">setx</span>(<span class="string">&quot;class&quot;</span>);   <span class="comment">//OK</span></span><br><span class="line">    d1.<span class="built_in">setx</span>(<span class="number">50</span>);        <span class="comment">//compile error</span></span><br><span class="line">    d1.basic::<span class="built_in">setx</span>(<span class="number">50</span>); <span class="comment">//OK</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在派生类 derived 中，setx(char *) 与基类继承过来的 setx(int) 函数同名，派生类新增的函数 setx(char *) 遮蔽了从基类继承而来的 setx(int) 函数。如此一来，通过 d1.setx(50) 调用 setx(int) 是不成功的，故而出现编译错误。</p>
<h3 id="间接继承"><a href="#间接继承" class="headerlink" title="间接继承"></a>间接继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;x = a;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">sety</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;y = b;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> z;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setz</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;z = c;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="继承机制下的构造函数"><a href="#继承机制下的构造函数" class="headerlink" title="继承机制下的构造函数"></a>继承机制下的构造函数</h3><p>当我们创建一个派生类对象的时候，基类构造函数将会被自动调用，用于初始化派生类从基类中继承过来的成员变量。而派生类中新增的成员变量则需要重新定义构造函数用于初始化了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">book</span>();</span><br><span class="line">    <span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p = <span class="number">5.0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span> *a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">gettitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">char</span> *title;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book_derived</span> :</span> <span class="keyword">public</span> book &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span> *a, <span class="keyword">double</span> p) &#123;</span><br><span class="line">  title = a;</span><br><span class="line">  price = p;</span><br><span class="line">&#125;</span><br><span class="line">book::<span class="built_in">book</span>() &#123;</span><br><span class="line">  title = <span class="string">&quot;NoTitle&quot;</span>;</span><br><span class="line">  price = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::setprice</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">  price = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">book::getprice</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::settitle</span><span class="params">(<span class="keyword">char</span> *a)</span> </span>&#123;</span><br><span class="line">  title = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">book::gettitle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The price of &quot;</span> &lt;&lt; title &lt;&lt; <span class="string">&quot; is $&quot;</span> &lt;&lt; price &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book_derived::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;The price of &quot;</span> &lt;&lt; <span class="built_in">gettitle</span>() &lt;&lt; <span class="string">&quot; is $&quot;</span> &lt;&lt; <span class="built_in">getprice</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  book_derived b;</span><br><span class="line">  b.<span class="built_in">display</span>();  <span class="comment">// The price of NoTitle is $0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">language</span> &#123;</span> none, cpp, java, python, javascript, php, ruby &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	    <span class="built_in">book</span>();</span><br><span class="line">      <span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p = <span class="number">5.0</span>);</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setprice</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getprice</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span>* a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">char</span> * <span class="title">gettitle</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	    <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">char</span> * title;</span><br><span class="line">&#125;;</span><br><span class="line">book::<span class="built_in">book</span>(<span class="keyword">char</span>* a, <span class="keyword">double</span> p) &#123;</span><br><span class="line">	title = a;</span><br><span class="line">	price = p;</span><br><span class="line">&#125;</span><br><span class="line">book::<span class="built_in">book</span>() &#123;</span><br><span class="line">	title = <span class="string">&quot;NoTitle&quot;</span>;</span><br><span class="line">	price = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::setprice</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">	price = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">book::getprice</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::settitle</span><span class="params">(<span class="keyword">char</span>* a)</span> </span>&#123;</span><br><span class="line">	title = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">book::gettitle</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;The price of &quot;</span>&lt;&lt;title&lt;&lt;<span class="string">&quot; is $&quot;</span>&lt;&lt;price&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">codingbook</span>:</span> <span class="keyword">public</span> book &#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">  	<span class="built_in">codingbook</span>():<span class="built_in">book</span>() &#123; lang = none; &#125;</span><br><span class="line">    <span class="built_in">codingbook</span>(language lang, <span class="keyword">char</span> * t, <span class="keyword">double</span> p);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setlang</span><span class="params">(language lang)</span></span>;</span><br><span class="line">    <span class="function">language <span class="title">getlang</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lang; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">  	language lang;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">codingbook::setlang</span><span class="params">(language lang)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;lang = lang;</span><br><span class="line">&#125;</span><br><span class="line">codingbook::<span class="built_in">codingbook</span>(language lang, <span class="keyword">char</span> * t, <span class="keyword">double</span> p):<span class="built_in">book</span>(t,p) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;lang = lang;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">codingbook::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	book::<span class="built_in">display</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;The language is &quot;</span>&lt;&lt;lang&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 codingbook 类的默认构造函数，默认构造函数先会调用基类的默认构造函数将 title 和 price 进行初始化，之后才会执行自身函数体中的内容</span></span><br><span class="line">	codingbook cpp;</span><br><span class="line">	cpp.<span class="built_in">display</span>();</span><br><span class="line">  </span><br><span class="line">	<span class="function">codingbook <span class="title">java</span><span class="params">(java, <span class="string">&quot;Thinking in Java&quot;</span>, <span class="number">59.9</span>)</span></span>;</span><br><span class="line">	java.<span class="built_in">display</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The price of NoTitle is $0</span></span><br><span class="line"><span class="comment">// The language is 0</span></span><br><span class="line"><span class="comment">// The price of Thinking in Java is $59.9</span></span><br><span class="line"><span class="comment">// The language is 2</span></span><br></pre></td></tr></table></figure>

<p>book 类中有一个默认构造函数和一个带参数的构造函数，codingbook 类中同样声明了两个构造函数，一个默认构造函数和一个带参数的构造函数，默认构造函数显式调用基类的默认构造函数，带参构造函数显式调用基类的带参构造函数。</p>
<h3 id="派生类构造函数调用规则"><a href="#派生类构造函数调用规则" class="headerlink" title="派生类构造函数调用规则"></a>派生类构造函数调用规则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">base</span>(<span class="keyword">int</span> a)&#123;x = a; y = <span class="number">0</span>;&#125;</span><br><span class="line">      <span class="built_in">base</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;x = a; y = b;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">derived</span>()&#123;z = <span class="number">0</span>;&#125;</span><br><span class="line">      <span class="built_in">derived</span>(<span class="keyword">int</span> c)&#123;z = c;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>base 基类拥有两个成员变量 x 和 y，同时定义了两个带参数的构造函数。如此一来，base 类就不会自动生成默认构造函数了。derived 派生类中新增了成员变量 z，并且定义了一个带参构造函数和一个默认构造函数。但是如此定义，编译器会提示语法错误，因为派生类的构造函数没有显式调用基类构造函数。</p>
<p>解决这个问题的方法有两种，一个是在 base 基类中定义一个默认构造函数，另外一种方法是 derived 派生类的构造函数显式调用基类的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">base</span>()&#123;x = <span class="number">0</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">      <span class="built_in">base</span>(<span class="keyword">int</span> a)&#123;x = a; y = <span class="number">0</span>;&#125;</span><br><span class="line">      <span class="built_in">base</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;x = a; y = b;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">derived</span>():<span class="built_in">base</span>()&#123;z = <span class="number">0</span>;&#125;</span><br><span class="line">      <span class="built_in">derived</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):<span class="built_in">base</span>(a,b)&#123;z = c;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    derived A;</span><br><span class="line">    <span class="function">derived <span class="title">B</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="继承机制下的析构函数"><a href="#继承机制下的析构函数" class="headerlink" title="继承机制下的析构函数"></a>继承机制下的析构函数</h3><p>创建派生类对象时，构造函数的调用顺序是按照继承顺序，先执行基类构造函数，然后再执行派生类的构造函数。</p>
<p>但是对于析构函数，其调用顺序是正好相反的，即先执行派生类的构造函数，然后再执行基类的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">A</span>() &#123; cout&lt;&lt;<span class="string">&quot;A constructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">		~<span class="built_in">A</span>() &#123; cout&lt;&lt;<span class="string">&quot;A destructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">B</span>() &#123; cout&lt;&lt;<span class="string">&quot;B constructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">		~<span class="built_in">B</span>() &#123; cout&lt;&lt;<span class="string">&quot;B destructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">C</span>() &#123; cout&lt;&lt;<span class="string">&quot;C constructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">		~<span class="built_in">C</span>() &#123; cout&lt;&lt;<span class="string">&quot;C destructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	C test;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A constructor</span></span><br><span class="line"><span class="comment">// B constructor</span></span><br><span class="line"><span class="comment">// C constructor</span></span><br><span class="line"><span class="comment">// C destructor</span></span><br><span class="line"><span class="comment">// B destructor</span></span><br><span class="line"><span class="comment">// A destructor</span></span><br></pre></td></tr></table></figure>



<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>单继承中，派生类是对基类的特例化，例如编程类书籍是书籍中的特例。而多继承中，派生类是所有基类的一种组合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">teacher</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">settitle</span><span class="params">(<span class="keyword">char</span> *a)</span> </span>&#123; title = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">gettitle</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> title; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *title; <span class="comment">//职称</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cadre</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setpost</span><span class="params">(<span class="keyword">char</span> *a)</span> </span>&#123; post = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getpost</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> post; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *post; <span class="comment">//职务</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">teacher_cadre</span> :</span> <span class="keyword">public</span> cadre, <span class="keyword">public</span> teacher &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setwages</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; wages = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getwages</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> wages; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> wages; <span class="comment">//工资</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; x = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; x = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; x = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C test;</span><br><span class="line">  test.<span class="built_in">setx</span>(<span class="number">10</span>);</span><br><span class="line">  test.B::<span class="built_in">setx</span>(<span class="number">20</span>);</span><br><span class="line">  test.A::<span class="built_in">setx</span>(<span class="number">30</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><p><code>菱形继承结构</code>：类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A 派生 B 然后派生 D 这一路，另一份来自 A 派生 C 然后派生 D 这一条路。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B &amp; C;</span><br><span class="line">    B &amp; C --&gt; D;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; x = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sety</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; y = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setz</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; z = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类 A 中的成员变量及成员函数继承到类 D 中均会产生两份，这样的命名冲突非常的棘手，通过域解析操作符已经无法分清具体的变量了。为此，C++ 提供了虚继承这一方式解决命名冲突问题。<code>虚继承</code>只需要在继承属性前加上 virtual 关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setx</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; x = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sety</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; y = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setz</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; z = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  D test;</span><br><span class="line">  test.<span class="built_in">setx</span>(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; test.<span class="built_in">getx</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 B 和类 C 都以虚继承的方式继承类 A，如此操作之后，类 D 只会得到一份来自类 A 的数据。</p>
<p>主函数中定义了类 D 的对象 test，然后通过该对象调用从类 A 间接继承来的 setx () 和 getx () 成员函数，因为 B 和 C 继承自类 A 采用的是虚继承，故通过 D 调用 setx () 和 getx () 不会有命名冲突问题，因为 D 类只得到了一份 A 的数据。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是面向对象设计语言重要的机制之一，代指同一名字的事物可以完成不同的功能。</p>
<p>多态机制可以细分为<code>编译时多态</code>和<code>运行时多态</code>。</p>
<ul>
<li>编译时多态主要指重载的函数，程序编译时就能根据实参确定应该调用哪个函数；</li>
<li>运行时多态应用在具有继承关系的多个类中，与虚函数等概念有关。</li>
</ul>
<h3 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a>虚函数的作用</h3><p>虚函数的作用：主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。</p>
<p>我们先来看一个例子，直观上感觉下常规（非虚）函数在面向对象编程中的局限性，请看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;I&#x27;m eating generic food.&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;I&#x27;m eating a rat.&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这段 C++ 语言代码定义了 <code>Animal</code>和 <code>Cat</code>两个类，其中 <code>Cat</code> 继承了 <code>Animal</code>，我们可以在 main () 函数中使用这两个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal *animal = <span class="keyword">new</span> Animal;</span><br><span class="line">Cat *cat = <span class="keyword">new</span> Cat;</span><br><span class="line"></span><br><span class="line">animal-&gt;<span class="built_in">eat</span>(); <span class="comment">// 输出： &quot;I&#x27;m eating generic food.&quot;</span></span><br><span class="line">cat-&gt;<span class="built_in">eat</span>();    <span class="comment">// 输出： &quot;I&#x27;m eating a rat.&quot;</span></span><br></pre></td></tr></table></figure>

<p>到这里一切都挺好的，动物吃食物，猫吃老鼠，即使不使用 <code>virtual</code> 关键字定义虚函数也完全没有问题。</p>
<p>现在稍稍修改下这段 C++ 语言代码，引入另外一个函数 <code>func()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal *xyz)</span> </span>&#123;</span><br><span class="line">    xyz-&gt;<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 main () 函数中调用 <code>func()</code> 函数，相关的 C++ 语言代码示例如下，请看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal *animal = <span class="keyword">new</span> Animal;</span><br><span class="line">Cat *cat = <span class="keyword">new</span> Cat;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(animal); <span class="comment">// 输出： &quot;I&#x27;m eating generic food.&quot;</span></span><br><span class="line"><span class="built_in">func</span>(cat);    <span class="comment">// 输出： &quot;I&#x27;m eating generic food.&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意第二个 func () 函数调用，我们传递了一个 <code>Cat</code> 对象指针给它，但是输出的却不是 “I’m eating a rat.”！仔细观察一下，发现 func () 函数的参数类型是 <code>Animal *xyz</code>，那么为了让 func () 函数也能输出 “I’m eating a rat.”，只能重载 func () 函数了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal *xyz)</span> </span>&#123;</span><br><span class="line">    xyz-&gt;<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Cat *xyz)</span> </span>&#123;</span><br><span class="line">    xyz-&gt;<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 func () 函数能够根据输入参数类型的不同，输出不同的内容了。可是我们不可能为每个派生类都重载一遍 func () 函数。</p>
<p>在 C++ 语言中，重写基类中的常规（非虚）函数当然是可以的，但是从上面的例子可以看出，重写常规函数实现多态有时会带来非常麻烦的问题，要避免这样的问题可以使用 virtual function（虚函数）。现在，我们在 <code>Animal</code> 基类的 eat() 成员函数前加上 <code>virtual</code> 关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;I&#x27;m eating generic food.&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;I&#x27;m eating a rat.&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时无需重载 func () 函数，<strong>仅保留一份</strong> func () 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal *xyz)</span> </span>&#123;</span><br><span class="line">    xyz-&gt;<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再执行下面的 C++ 语言代码，输出就不同了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(animal); <span class="comment">// 输出： &quot;I&#x27;m eating generic food.&quot;</span></span><br><span class="line"><span class="built_in">func</span>(cat);    <span class="comment">// 输出： &quot;I&#x27;m eating a rat.&quot;</span></span><br></pre></td></tr></table></figure>

<p>基类中的虚函数允许派生类重写功能，<strong>编译器会保证派生类对象使用的是自己重写的功能，即使对象是通过基类指针访问的</strong>，</p>
<p>例如前文中的 <code>func (Animal *xyz)</code> 函数，<code>func (cat)</code> 输出的实际上是 Cat 类重写的功能。这是一个非常有用的特性，调用者甚至都不需要知道 Cat 等派生类的实现，因为<strong>只需使用基类 Animal 指针就能够轻易的调用所有派生类的重写功能</strong>。</p>
<p>基类的虚函数可以完全被重写，也可以部分的被重写，所谓的 “部分被重写”，其实就是派生类在重写基类虚函数时，也可以调用基类虚函数的功能。</p>
<h3 id="虚函数和常规函数被调用时有什么不同"><a href="#虚函数和常规函数被调用时有什么不同" class="headerlink" title="虚函数和常规函数被调用时有什么不同"></a>虚函数和常规函数被调用时有什么不同</h3><p>常规的<strong>非虚函数是静态解析</strong>的，即在编译时即可根据指针指向的对象确定是否被调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eat() 函数不是虚函数</span></span><br><span class="line"></span><br><span class="line">Animal *animal = <span class="keyword">new</span> Animal;</span><br><span class="line">Cat *cat = <span class="keyword">new</span> Cat;</span><br><span class="line"></span><br><span class="line">animal-&gt;<span class="built_in">eat</span>(); <span class="comment">// 输出： &quot;I&#x27;m eating generic food.&quot;</span></span><br><span class="line">cat-&gt;<span class="built_in">eat</span>();    <span class="comment">// 输出： &quot;I&#x27;m eating a rat.&quot;</span></span><br></pre></td></tr></table></figure>

<p>此时编译器在编译时就能确定 <code>animal-&gt;eat()</code> 调用的是 <code>Animal::eat()</code> 函数，<code>cat-&gt;eat()</code> 调用的是 <code>Cat::eat()</code> 函数。在 <code>func(Animal *xyz)</code> 函数中，因为其形参是 <code>Animal* </code>指针类型，所以即使传入的是 cat 对象指针，在 <code>func()</code> 函数内部也会被强制转换为<code> Animal *</code> 指针，因此 <code>func(cat)</code> 调用的仍然是 <code>Animal::eat()</code> 函数。</p>
<p>而虚函数就不同了，<strong>虚函数是动态解析</strong>的，也即在程序被编译后，运行时才<strong>根据对象的类型，而不是指向对象的指针类型</strong>决定其是否被调用，这就是说为的 “动态绑定”。</p>
<p>在 C++ 语言中，如果某个类有虚函数，那么大多数编译器都会自动的为其对象维护一个隐藏的 “虚指针（virtul-pointer）”，虚指针指向一个全局 “虚表（virtual-table）”，虚表中存放若干函数指针，这些函数指针指向类中的虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfoo1</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfoo2</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> prv_i1, prv_i2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然，类 A 有两个常规函数以及两个 int 型的成员变量，此外，它还有两个虚函数，因此编译器会创建一个虚表，虚表中存放的是函数指针，它们分别指向类 A 的虚函数，如下图所示：</p>
<p><img src="/images/974578424.png" alt="类A的虚表和虚函数"></p>
<p>注意，虚表是属于类的，而不是对象的，也就是说，即使有成千上万个 A 对象，虚表也仅有一个，这些对象共用一个类虚表。编译器会自动的为每个对象创建一个隐藏的 <code>虚指针</code>(<code>__vptr</code>)，它指向类 A 的虚表，如下图所示：</p>
<p><img src="/images/650620554.png" alt="隐藏的虚指针vptr"></p>
<p><strong>如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址</strong>。</p>
<p>C++ 语言这样实现虚函数机制的<strong>空间开销是微乎其微的</strong>，事实上，每一个对象只需要一个额外的 “虚指针”<code>__vptr</code> 就能够调用类的虚函数。同样的，<strong>时间开销</strong>也很小：相比于常规函数的调用，虚函数的调用只不过多出了额外的两个步骤：</p>
<ol>
<li>获取虚表指针，得到虚表</li>
<li>从虚表中取出虚函数的地址</li>
</ol>
<h3 id="多态的概念及前提条件"><a href="#多态的概念及前提条件" class="headerlink" title="多态的概念及前提条件"></a>多态的概念及前提条件</h3><p>编译期绑定是指在程序编译时就将函数名与函数入口地址绑定到一起，运行期绑定是指在程序运行时才将函数名与函数入口地址绑定到一起，而在运行期绑定的函数我们称其是多态的。</p>
<p>换句话说，运行期绑定指的是函数名与函数入口地址在程序编译时无法绑定到一起，只有等运行的时候才确定函数名与哪一个函数入口绑定到一起。</p>
<p>要想形成多态必须具备以下三个条件：</p>
<ul>
<li>必须存在继承关系；</li>
<li>继承关系中必须有同名的虚函数；</li>
<li>存在基类类型的指针或引用，通过该指针或引用调用虚函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;I&#x27;m base class!&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;I&#x27;m derived class!&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个基类类型的指针 p 和派生类对象 test，</span></span><br><span class="line"><span class="comment">// p 指针指向派生类对象 test，然后通过指针调用 display 函数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base * p;</span><br><span class="line">    derived test;</span><br><span class="line">    p = &amp;test;</span><br><span class="line">    p-&gt;<span class="built_in">display</span>();   <span class="comment">// I&#x27;m base class!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现派生类的 display() 函数的返回值竟然是 <code>I&#39;m base class!</code></p>
<p>在 display() 函数前各添加了一个 virtual 关键字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  		<span class="comment">// 通过 virtual 关键字声明为虚函数，具有多态特性</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;I&#x27;m base class!&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;I&#x27;m derived class!&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	base * p = <span class="keyword">new</span> base;</span><br><span class="line">    p-&gt;<span class="built_in">display</span>();   <span class="comment">// I&#x27;m base class!</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">  </span><br><span class="line">    p = <span class="keyword">new</span> derived;</span><br><span class="line">    p-&gt;<span class="built_in">display</span>();   <span class="comment">// I&#x27;m derived class!</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对照三个多态的构成条件来分析一下：</p>
<ul>
<li>多态需要继承关系，derived 类继承自 base 类，因此 base 类和 derived 类构成继承关系；</li>
<li>多态需要同名的虚函数，base 类和 derived 类中都有 display() 函数，同名满足，同时通过添加关键字 virtual 后，display() 函数成为虚函数；</li>
<li>多态需要通过基类类型的指针或引用来调用虚函数，在主函数中，p 即为基类类型指针，并且将该指针指向派生类对象，然后调用 display() 函数。</li>
</ul>
<p>我们在基类和派生类中的 display() 函数声明时都加上了 virtual 关键字，以表示将其声明为虚函数，而实际上这是不需要的。我们只需要将基类中的 display() 函数通过 virtual 关键字声明为虚函数，即使派生类中 display() 函数声明时未注明 virtual 关键字，它在所有的派生类中都将自动成为虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="comment">// 有没有virtual都没有区别</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;I&#x27;m derived class!&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 C++ 中，只有类中的成员函数能被声明为虚函数，而对于顶层函数则不能声明为虚函数。原因很简单，声明虚函数是为了构成多态，而构成多态的第一个条件就是需要继承关系，顶层函数很明显是不具有继承关系的，因此也就不能被声明为虚函数了。</p>
<h3 id="虚成员函数表-vtable"><a href="#虚成员函数表-vtable" class="headerlink" title="虚成员函数表 vtable"></a>虚成员函数表 vtable</h3><p>多态的底层实现机制：</p>
<p>C++ 通过虚成员函数表 vtable 实现多态，虚函数表中存储的是类中虚函数的入口地址。普通类中是没有虚函数表的，只有在具有虚函数的类中（无论是自身添加的虚函数还是继承过来的虚函数）才会具有虚函数表。通常，虚函数表的首地址将会被存入对象的最前面（在 32 位的操作系统中，存储地址是用 4 个字节，因此这个首地址就会占用对象的前四个字节的空间）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base b;</span><br><span class="line">    derived d;</span><br><span class="line">    base *p;</span><br><span class="line">    p = &amp;b;</span><br><span class="line">    p-&gt;<span class="built_in">v1</span>();</span><br><span class="line">    p-&gt;<span class="built_in">v2</span>();</span><br><span class="line">  </span><br><span class="line">    p = &amp;d;</span><br><span class="line">    p-&gt;<span class="built_in">v1</span>();</span><br><span class="line">    p-&gt;<span class="built_in">v2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个类中各有两个虚函数 v1 和 v2，我们将其函数入口地址找到列于下表中：</p>
<table>
<thead>
<tr>
<th>虚成员函数</th>
<th>函数入口地址</th>
</tr>
</thead>
<tbody><tr>
<td>base::v1</td>
<td>00D15834</td>
</tr>
<tr>
<td>base::v2</td>
<td>00D15838</td>
</tr>
<tr>
<td>derived::v1</td>
<td>00D15844</td>
</tr>
<tr>
<td>derived::v2</td>
<td>00D15848</td>
</tr>
</tbody></table>
<p>虚函数表里存储的就是虚函数的入口地址。我们再来看主函数，函数中先定义了 base 类对象 b，因为 b 类中有虚函数，因此存在虚函数表，而虚函数表的首地址就存储在对象所在存储空间的最前，具体情况可以见下图。当然声明 derived 对象 d 之后，情况也跟下图中一样，同样在对象存储空间中包含虚成员函数表地址。</p>
<p><img src="/images/1006095427-0.png" alt="img"></p>
<p>之后定义了一个基类类型的指针 p，当通过 p 调用虚函数 v1 或 v2 时，系统会先去 p 所指向的对象的前四个字节中寻找到虚函数表地址，之后在内存中找到该虚函数表，然后在表中找到对应函数的入口地址，就可以访问这个函数。</p>
<p>当 p 指针指向的是基类对象时，基类的虚函数表将会被访问，基类中虚函数将会被调用。当 p 指针指向的是派生类对象时，访问的是派生类的虚函数表，派生类的虚函数表中存的是派生类中的虚函数入口地址，因此调用的是派生类中的虚函数。</p>
<p>使用多态会降低程序运行效率，使用多态的程序会使用更多的存储空间，存储虚函数表等内容，而且在调用函数时需要去虚函数表中查询函数入口地址，这会增加程序运行时间。在设计程序时，程序设计人员可以选择性的使用多态，对于有需要的函数使用多态，对于其它的函数则不要采用多态。</p>
<p>通常情况下，如果一个类需要作为基类，并且期望在派生类中修改某成员函数的功能，并且在使用类对象的时候会采用指针或引用的形式访问该函数，则将该函数声明为虚函数。</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>构造函数是不能声明为虚函数的，因为在执行构造函数前对象尚未完成创建，虚函数表尚不存在，此时就无法去查询虚函数表，因此也就无法得知该调用哪一个构造函数了。</p>
<p>析构函数则用于销毁对象时完成相应的资源释放工作，析构函数可以被声明为虚函数。</p>
<p>下面代码，说明析构函数设计成虚函数的必要性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">base</span>();</span><br><span class="line">      ~<span class="built_in">base</span>();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> * a;</span><br><span class="line">&#125;;</span><br><span class="line">base::<span class="built_in">base</span>() &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base constructor!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line">base::~<span class="built_in">base</span>() &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base destructor!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">derived</span>();</span><br><span class="line">      ~<span class="built_in">derived</span>();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> * b;</span><br><span class="line">&#125;;</span><br><span class="line">derived::<span class="built_in">derived</span>() &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;derived constructor!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">&#125;</span><br><span class="line">derived::~<span class="built_in">derived</span>() &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;derived destructor!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base* p;</span><br><span class="line">    p = <span class="keyword">new</span> derived;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base constructor!</span></span><br><span class="line"><span class="comment">// derived constructor!</span></span><br><span class="line"><span class="comment">// base destructor!</span></span><br></pre></td></tr></table></figure>

<p>程序打印出了 “base destructor!” 字符串，这说明基类的析构函数被调用了，a 指针所指向的 10 个整型内存空间被释放了。但是之后却并未调用派生类的析构函数，这意味着 b 指针所指向的 1000 个整型存储空间没有被释放，如此一来就造成了内存泄露。</p>
<p>修改后基类的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">base</span>();</span><br><span class="line">      <span class="keyword">virtual</span> ~<span class="built_in">base</span>();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> * a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改基类的定义后，程序运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base constructor!</span><br><span class="line">derived constructor!</span><br><span class="line">derived destructor!</span><br><span class="line">base destructor!</span><br></pre></td></tr></table></figure>

<p>在主函数中，基类指针 p 指向的是派生类对象，当 delete 释放 p 指针所指向的存储空间时，会执行派生类的析构函数，派生类的析构函数执行完之后会紧接着执行基类的析构函数，以释放从基类继承过来的成员变量所消耗的资源。如此一来就不会存在内存泄漏问题了。</p>
<blockquote>
<p>通常来说，如果派生类中存在一个指向动态分配内存的成员变量，并且派生类的析构函数中定义了释放该动态分配内存的代码，则应该将基类的析构函数声明为虚函数。</p>
</blockquote>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>静态成员函数不能声明为虚函数。</p>
<p>将构造函数和静态成员函数声明为虚函数则会出现编译错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="title">test</span><span class="params">()</span></span>&#123;a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];&#125; <span class="comment">//error</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;          <span class="comment">//ok</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;         <span class="comment">//ok</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;  <span class="comment">//compile error</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">test</span>()&#123;<span class="keyword">delete</span>[] a;&#125; <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> * a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="重载、覆盖和遮蔽"><a href="#重载、覆盖和遮蔽" class="headerlink" title="重载、覆盖和遮蔽"></a>重载、覆盖和遮蔽</h3><p><code>函数签名</code>：包括函数名、函数参数的个数和顺序以及各个参数的数据类型。</p>
<p>需要注意的是，函数签名并不包含函数返回值部分，如果两个函数仅仅只有函数返回值不同，那么系统是无法区分这两个函数的，此时编译器会提示语法错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span></span><br></pre></td></tr></table></figure>



<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>函数重载是编译期绑定，它并不是多态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">      <span class="built_in">base</span>();</span><br><span class="line">      <span class="built_in">base</span>(<span class="keyword">int</span> a);</span><br><span class="line">      <span class="built_in">base</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">      <span class="built_in">base</span>(base &amp;);</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">      <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">double</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p><strong>继承层次中，父类与子类同名函数要么是覆盖，要么是遮蔽</strong>。</p>
<p><strong>函数覆盖说的就是多态</strong>。覆盖是一种函数间的表现关系，而多态描述的是函数的一种性质，二者所描述的其实是同一种语法现象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vir1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vir2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">vir1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">vir2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base * p;</span><br><span class="line">    p = <span class="keyword">new</span> derived;</span><br><span class="line">    p-&gt;<span class="built_in">vir1</span>();</span><br><span class="line">    p-&gt;<span class="built_in">vir2</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子就是一个覆盖，派生类中的 vir1() 函数覆盖了基类中的 vir1() 函数，派生类中的 vir2() 函数覆盖了基类中的 vir2() 函数。</p>
<p>如果上面没有关键字 virtual，则就是遮蔽。</p>
<h4 id="遮蔽"><a href="#遮蔽" class="headerlink" title="遮蔽"></a>遮蔽</h4><p>函数遮蔽同样要求构成继承关系，遮蔽理解起来很简单，只要派生类与基类中具有相同函数名（注意不是相同函数签名，只需要相同函数名就可以了）并且不构成覆盖关系即为遮蔽。</p>
<p>遮蔽可以分为两种情况，一种是非虚函数之间，另一种则是虚函数之间。</p>
<p>我们通过程序示例来分别介绍这两种遮蔽情况。</p>
<p>下面代码没有虚函数，base 类和 derived 类构成继承关系，因为构成继承关系的两个类中有同名函数，因此构成了函数遮蔽：派生类中的 vir1 () 函数遮蔽了基类中的 vir1 () 函数，派生类中的 vir2 () 函数遮蔽了基类中的 vir1 () 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">vir1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;base vir1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">vir2</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;base vir2&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">vir1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;derived vir1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">vir2</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;derived vir2&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base * p;</span><br><span class="line">    p = <span class="keyword">new</span> derived;</span><br><span class="line">    p-&gt;<span class="built_in">vir1</span>();       <span class="comment">// base vir1</span></span><br><span class="line">    p-&gt;<span class="built_in">vir2</span>();       <span class="comment">// base vir2</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">  </span><br><span class="line">    derived d;</span><br><span class="line">    d.<span class="built_in">vir1</span>();        <span class="comment">// derived vir1</span></span><br><span class="line">    d.<span class="built_in">vir2</span>(<span class="number">5</span>);       <span class="comment">// derived vir2</span></span><br><span class="line">    d.base::<span class="built_in">vir1</span>();  <span class="comment">// base vir1</span></span><br><span class="line">    d.base::<span class="built_in">vir2</span>();  <span class="comment">// base vir2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vir1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;base vir1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vir2</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;base vir2&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vir1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;derived vir1&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vir2</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;derived vir2&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base * p;</span><br><span class="line">    p = <span class="keyword">new</span> derived;</span><br><span class="line">    p-&gt;<span class="built_in">vir1</span>();  <span class="comment">// derived vir1</span></span><br><span class="line">    p-&gt;<span class="built_in">vir2</span>();  <span class="comment">// base vir2</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">  </span><br><span class="line">    derived d;</span><br><span class="line">    d.<span class="built_in">vir1</span>();        <span class="comment">// derived vir1</span></span><br><span class="line">    d.<span class="built_in">vir2</span>(<span class="number">5</span>);       <span class="comment">// derived vir2</span></span><br><span class="line">    d.base::<span class="built_in">vir1</span>();  <span class="comment">// base vir1</span></span><br><span class="line">    d.base::<span class="built_in">vir2</span>();  <span class="comment">// base vir2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抽象基类和纯虚成员函数"><a href="#抽象基类和纯虚成员函数" class="headerlink" title="抽象基类和纯虚成员函数"></a>抽象基类和纯虚成员函数</h3><p>纯虚成员函数的声明语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数返回类型 函数名 (函数参数) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>纯虚成员函数没有函数体，只有函数声明，在纯虚函数声明结尾加上 “=0” 表明此函数为纯虚成员函数。</p>
<p><strong>包含纯虚成员函数的类即为抽象基类</strong>，之所以说它抽象，那是因为它无法实例化，也即无法用于创建对象。</p>
<p>一个纯虚成员函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚成员函数外，同样可以包含其它成员函数或成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base b; <span class="comment">//compile error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>纯虚成员函数可以被派生类继承，如果派生类不重新定义抽象基类中的所有（有多个则要重新定义多个）纯虚成员函数，则派生类同样会成为抽象基类，也不能用于创建对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">      <span class="built_in">base</span>()&#123;x = <span class="number">0</span>;&#125;</span><br><span class="line">      <span class="built_in">base</span>(<span class="keyword">int</span> a)&#123;x = a;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived1</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">derived1</span>(<span class="keyword">int</span> a)&#123; y = a;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived2</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">derived2</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b):<span class="built_in">base</span>(a)&#123; z = b;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="built_in">getx</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base b;           <span class="comment">//compile error</span></span><br><span class="line">    <span class="function">derived1 <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;   <span class="comment">//compile error</span></span><br><span class="line">  </span><br><span class="line">    <span class="function">derived2 <span class="title">d2</span><span class="params">(<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">    d2.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公共接口是指一系列成员函数的集合，支持该接口的类必须以合适的方式重新定义这些成员函数，否则就无法创建对象。C++ 中可以通过抽象基类来实现公共接口。</p>
<h3 id="typeid-操作符"><a href="#typeid-操作符" class="headerlink" title="typeid 操作符"></a>typeid 操作符</h3><p>typeid 操作符用于判断表达式的类型，注意它和 sizeof 一样是一个操作符而不是函数。如果需要使用 typeid 操作符，最好加上 typeinfo 头文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">double</span> b;</span><br><span class="line"><span class="keyword">char</span> * c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>表达式</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>typeid(a) == typeid(int)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(a) == typeid(float)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(a) == typeid(int *)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(b) == typeid(double)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(b) == typeid(float)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(b) == typeid(long double)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(c) == typeid(char *)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(c) == typeid(char)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(c) == typeid(string)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(d) == typeid(long)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(d) == typeid(int)</td>
<td>false</td>
</tr>
</tbody></table>
<p>操作符 typeid 返回的是一个 type_info 类（用于描述数据类型的一个系统类）对象的引用。这个操作符可以用于表达式和类型名（包括自定的数据类型，比如类）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;derived&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  base * p = <span class="keyword">new</span> derived; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>表达式</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>typeid(p) == typeid(base*)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(p) == typeid(derived*)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(*p) == typeid(base)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(*p) == typeid(derived)</td>
<td>true</td>
</tr>
</tbody></table>
<p>对于表达式 <code>typeid (p)</code>，因为 p 是 <code>base*</code> 类型的指针，因此 <code>typeid (p) == typeid (base*)</code> 为真，而 <code>typeid (p) == typeid (derived*)</code> 为假。</p>
<p>而对于表达式 <code>typeid (*p)</code>，因为 base 类具有多态性，因而在计算 <code>typeid (*p)</code> 时会根据运行时 p 所指向的实际类型去计算，而本例中 p 指向的是派生类对象，因此表达式 <code>typeid (*p) == typeid (derived)</code> 为真，<code>typeid (*p) == typeid (base)</code> 为假。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;base&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;derived&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base * p = <span class="keyword">new</span> derived; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>表达式</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>typeid(p) == typeid(base*)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(p) == typeid(derived*)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(*p) == typeid(base)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(*p) == typeid(derived)</td>
<td>false</td>
</tr>
</tbody></table>
<p>对于表达式 <code>typeid (p)</code>，同样，因为 p 是 <code>base*</code> 类型的指针，因此 <code>typeid (p) == typeid (base*)</code> 为真，而 <code>typeid (p) == typeid (derived*)</code> 为假。</p>
<p>而对于表达式 <code>typeid (*p)</code>，由于此时的基类不具有多态性，因而 <code>*p</code> 将会采用编译期类型来计算，编译期 <code>*p</code> 是 base 对象，因此表达式 <code>typeid (*p) == typeid (derived)</code> 为假，<code>typeid (*p) == typeid (base)</code> 为真。</p>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="基本操作符重载"><a href="#基本操作符重载" class="headerlink" title="基本操作符重载"></a>基本操作符重载</h3><p>在 C++ 中可以重载的操作符有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\+ - * / % ^ &amp; | ~ ! = &lt; &gt; += -= *= /= %= ^= &amp;= |= </span><br><span class="line">&lt;&lt; &gt;&gt; &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || ++ -- , -&gt;* -&gt; () [] </span><br><span class="line">new new[] delete delete[]</span><br></pre></td></tr></table></figure>

<p>上述操作符中，<code>[ ]</code> 操作符是下标操作符，<code>( )</code> 操作符是函数调用操作符。自增自减操作符的前置和后置形式都可以重载。长度运算符 <code>sizeof</code>、条件运算符<code>:?</code>、成员选择符<code>.</code>、对象选择符<code>.*</code> 和域解析操作符<code>::</code> 不能被重载。</p>
<p>示例，重载复数类的四则运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( a + bi ) + ( c + di ) = ( a + c ) + ( b + d )i</span><br><span class="line">( a + bi ) – ( c + di ) = ( a – c ) + ( b – d )i</span><br><span class="line">( a + bi ) * ( c + di ) = ( ac – bd ) + ( ad + bc )i</span><br><span class="line">( a + bi ) / ( c + di ) = ( ac + bd ) / ( c2 + d2 ) + [ ( bc – ad ) / ( c2 + d2 ) ]i</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a);</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b);</span><br><span class="line">    complex <span class="keyword">operator</span>+(<span class="keyword">const</span> complex &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    complex <span class="keyword">operator</span>-(<span class="keyword">const</span> complex &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    complex <span class="keyword">operator</span>/(<span class="keyword">const</span> complex &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real; <span class="comment">//复数的实部</span></span><br><span class="line">    <span class="keyword">double</span> imag; <span class="comment">//复数的虚部</span></span><br><span class="line">&#125;;</span><br><span class="line">complex::<span class="built_in">complex</span>() &#123;</span><br><span class="line">  real = <span class="number">0.0</span>;</span><br><span class="line">  imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a) &#123;</span><br><span class="line">  real = a;</span><br><span class="line">  imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">  real = a;</span><br><span class="line">  imag = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印复数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot; i &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载加法操作符</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> complex &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">  complex B;</span><br><span class="line">  B.real = real + A.real;</span><br><span class="line">  B.imag = imag + A.imag;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载减法操作符</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>-(<span class="keyword">const</span> complex &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">  complex B;</span><br><span class="line">  B.real = real - A.real;</span><br><span class="line">  B.imag = imag - A.imag;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载乘法操作符</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>*(<span class="keyword">const</span> complex &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">  complex B;</span><br><span class="line">  B.real = real * A.real - imag * A.imag;</span><br><span class="line">  B.imag = imag * A.real + real * A.imag;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载除法操作符</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>/(<span class="keyword">const</span> complex &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">  complex B;</span><br><span class="line">  <span class="keyword">double</span> square = A.real * A.real + A.imag * A.imag;</span><br><span class="line">  B.real = (real * A.real + imag * A.imag) / square;</span><br><span class="line">  B.imag = (imag * A.real - real * A.imag) / square;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">-5.8</span>)</span></span>;</span><br><span class="line">  <span class="function">complex <span class="title">c2</span><span class="params">(<span class="number">8.4</span>, <span class="number">6.7</span>)</span></span>;</span><br><span class="line">  complex c3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//复数的加法</span></span><br><span class="line">  c3 = c1 + c2;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span>;</span><br><span class="line">  c3.<span class="built_in">display</span>();  <span class="comment">// c1 + c2 = 12.7 + 0.9 i </span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//复数的减法</span></span><br><span class="line">  c3 = c1 - c2;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c1 - c2 = &quot;</span>;</span><br><span class="line">  c3.<span class="built_in">display</span>(); <span class="comment">// c1 - c2 = -4.1 + -12.5 i </span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//复数的乘法</span></span><br><span class="line">  c3 = c1 * c2;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c1 * c2 = &quot;</span>;</span><br><span class="line">  c3.<span class="built_in">display</span>(); <span class="comment">// c1 * c2 = 74.98 + -19.91 i </span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//复数的除法</span></span><br><span class="line">  c3 = c1 / c2;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c1 / c2 = &quot;</span>;</span><br><span class="line">  c3.<span class="built_in">display</span>(); <span class="comment">// c1 / c2 = -0.0237332 + -0.671546 i</span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载操作符不能改变操作符的优先级和语法特性。</p>
<h3 id="用顶层函数重载操作符"><a href="#用顶层函数重载操作符" class="headerlink" title="用顶层函数重载操作符"></a>用顶层函数重载操作符</h3><ul>
<li>以操作符重载函数声明为类成员函数时，二元操作符的函数参数为一个，一元操作符重载函数不需要函数参数。</li>
<li>以顶层函数的形式重载操作符时，二元操作符重载函数必须有两个参数，一元操作符重载必须有一个参数。</li>
</ul>
<p>将操作符重载函数声明为顶层函数时，必须至少有一个类对象参数，否则编译器无法区分操作符是系统内建的还是程序设计人员自己定义的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a);</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getreal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getimag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> imag; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setreal</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123; real = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setimag</span><span class="params">(<span class="keyword">double</span> b)</span> </span>&#123; imag = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real; <span class="comment">//复数的实部</span></span><br><span class="line">    <span class="keyword">double</span> imag; <span class="comment">//复数的虚部</span></span><br><span class="line">&#125;;</span><br><span class="line">complex::<span class="built_in">complex</span>() &#123;</span><br><span class="line">  real = <span class="number">0.0</span>;</span><br><span class="line">  imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a) &#123;</span><br><span class="line">  real = a;</span><br><span class="line">  imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">  real = a;</span><br><span class="line">  imag = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印复数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot; i &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载加法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>+(<span class="keyword">const</span> complex &amp;A, <span class="keyword">const</span> complex &amp;B) &#123;</span><br><span class="line">  complex C;</span><br><span class="line">  C.<span class="built_in">setreal</span>(A.<span class="built_in">getreal</span>() + B.<span class="built_in">getreal</span>());</span><br><span class="line">  C.<span class="built_in">setimag</span>(A.<span class="built_in">getimag</span>() + B.<span class="built_in">getimag</span>());</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载减法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>-(<span class="keyword">const</span> complex &amp;A, <span class="keyword">const</span> complex &amp;B) &#123;</span><br><span class="line">  complex C;</span><br><span class="line">  C.<span class="built_in">setreal</span>(A.<span class="built_in">getreal</span>() - B.<span class="built_in">getreal</span>());</span><br><span class="line">  C.<span class="built_in">setimag</span>(A.<span class="built_in">getimag</span>() - B.<span class="built_in">getimag</span>());</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载乘法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex &amp;A, <span class="keyword">const</span> complex &amp;B) &#123;</span><br><span class="line">  complex C;</span><br><span class="line">  C.<span class="built_in">setreal</span>(A.<span class="built_in">getreal</span>() * B.<span class="built_in">getreal</span>() - A.<span class="built_in">getimag</span>() * B.<span class="built_in">getimag</span>());</span><br><span class="line">  C.<span class="built_in">setimag</span>(A.<span class="built_in">getimag</span>() * B.<span class="built_in">getreal</span>() + A.<span class="built_in">getreal</span>() * B.<span class="built_in">getimag</span>());</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载除法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>/(<span class="keyword">const</span> complex &amp;A, <span class="keyword">const</span> complex &amp;B) &#123;</span><br><span class="line">  complex C;</span><br><span class="line">  <span class="keyword">double</span> square = A.<span class="built_in">getreal</span>() * A.<span class="built_in">getreal</span>() + A.<span class="built_in">getimag</span>() * A.<span class="built_in">getimag</span>();</span><br><span class="line">  C.<span class="built_in">setreal</span>((A.<span class="built_in">getreal</span>() * B.<span class="built_in">getreal</span>() + A.<span class="built_in">getimag</span>() * B.<span class="built_in">getimag</span>()) / square);</span><br><span class="line">  C.<span class="built_in">setimag</span>((A.<span class="built_in">getimag</span>() * B.<span class="built_in">getreal</span>() - A.<span class="built_in">getreal</span>() * B.<span class="built_in">getimag</span>()) / square);</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">-5.8</span>)</span></span>;</span><br><span class="line">  <span class="function">complex <span class="title">c2</span><span class="params">(<span class="number">8.4</span>, <span class="number">6.7</span>)</span></span>;</span><br><span class="line">  complex c3;</span><br><span class="line"></span><br><span class="line">  c3 = c1 + c2;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span>;</span><br><span class="line">  c3.<span class="built_in">display</span>();  <span class="comment">// c1 + c2 = 12.7 + 0.9 i </span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  c3 = c1 - c2;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c1 - c2 = &quot;</span>;</span><br><span class="line">  c3.<span class="built_in">display</span>();  <span class="comment">// c1 - c2 = -4.1 + -12.5 i</span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  c3 = c1 * c2;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c1 * c2 = &quot;</span>;</span><br><span class="line">  c3.<span class="built_in">display</span>();  <span class="comment">// c1 * c2 = 74.98 + -19.91 i </span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  c3 = c1 / c2;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c1 / c2 = &quot;</span>;</span><br><span class="line">  c3.<span class="built_in">display</span>();  <span class="comment">// c1 / c2 = -0.0525609 + -1.48724 i</span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>指针操作符 <code>-&gt;</code>、下标操作符 <code>[]</code>、函数调用操作符 <code>()</code> 和赋值操作符 <code>=</code> 只能以成员函数的形式进行操作符重载。</p>
</blockquote>
<h3 id="顶层函数重载操作符-VS-类重载操作符"><a href="#顶层函数重载操作符-VS-类重载操作符" class="headerlink" title="顶层函数重载操作符 VS 类重载操作符"></a>顶层函数重载操作符 VS 类重载操作符</h3><p>类重载操作符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a);</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b);</span><br><span class="line">    complex <span class="keyword">operator</span>+(<span class="keyword">const</span> complex&amp; A) <span class="keyword">const</span>;</span><br><span class="line">    complex <span class="keyword">operator</span>-(<span class="keyword">const</span> complex&amp; A) <span class="keyword">const</span>;</span><br><span class="line">    complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex&amp; A) <span class="keyword">const</span>;</span><br><span class="line">    complex <span class="keyword">operator</span>/(<span class="keyword">const</span> complex&amp; A) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real;  <span class="comment">//复数的实部</span></span><br><span class="line">    <span class="keyword">double</span> imag;  <span class="comment">//复数的虚部</span></span><br><span class="line">&#125;;</span><br><span class="line">complex::<span class="built_in">complex</span>() &#123;</span><br><span class="line">    real = <span class="number">0.0</span>;</span><br><span class="line">    imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a) &#123;</span><br><span class="line">    real = a;</span><br><span class="line">    imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">    real = a;</span><br><span class="line">    imag = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印复数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot; i &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载加法操作符</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> complex&amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">    complex B;</span><br><span class="line">    B.real = real + A.real;</span><br><span class="line">    B.imag = imag + A.imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载减法操作符</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>-(<span class="keyword">const</span> complex&amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">    complex B;</span><br><span class="line">    B.real = real - A.real;</span><br><span class="line">    B.imag = imag - A.imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载乘法操作符</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>*(<span class="keyword">const</span> complex&amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">    complex B;</span><br><span class="line">    B.real = real * A.real - imag * A.imag;</span><br><span class="line">    B.imag = imag * A.real + real * A.imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载除法操作符</span></span><br><span class="line">complex complex::<span class="keyword">operator</span>/(<span class="keyword">const</span> complex&amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">    complex B;</span><br><span class="line">    <span class="keyword">double</span> square = A.real * A.real + A.imag * A.imag;</span><br><span class="line">    B.real = (real * A.real + imag * A.imag) / square;</span><br><span class="line">    B.imag = (imag * A.real - real * A.imag) / square;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    complex c1, <span class="built_in">c2</span>(<span class="number">15.5</span>, <span class="number">23.1</span>);</span><br><span class="line">    c1 = c2 + <span class="number">13.5</span>;  <span class="comment">// ok</span></span><br><span class="line">    c1 = <span class="number">13.5</span> + c2;  <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现：<code>c1 = c2 + 13.5;</code> 是可以的，<code>c1 = 13.5 + c2;</code> 会引发 error。</p>
<ul>
<li>前者：可以理解成 <code>c1 = c2.operator+(13.5);</code>，因为我们在类中定义了只带一个参数的构造函数 <code>complex(double a);</code>，这个构造函数可以视为转型构造函数，它可以将 double 类型转换为一个 complex 类对象。所以相当于两个复数类对象相加。当然，如果在类中没有定义 <code>complex(double a);</code>，那么这一句也是有语法问题的，</li>
<li>后者：可以理解成 <code>c1 = 13.5.operator+(c2);</code>，13.5 只是一个 double 类型的常数，它不是类对象，因此也不可能有调用 operator+() 的能力。</li>
</ul>
<p>顶层函数重载操作符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a);</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getreal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getimag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> imag; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setreal</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123; real = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setimag</span><span class="params">(<span class="keyword">double</span> b)</span> </span>&#123; imag = b; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real;  <span class="comment">//复数的实部</span></span><br><span class="line">    <span class="keyword">double</span> imag;  <span class="comment">//复数的虚部</span></span><br><span class="line">&#125;;</span><br><span class="line">complex::<span class="built_in">complex</span>() &#123;</span><br><span class="line">    real = <span class="number">0.0</span>;</span><br><span class="line">    imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a) &#123;</span><br><span class="line">    real = a;</span><br><span class="line">    imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">    real = a;</span><br><span class="line">    imag = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印复数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot; i &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载加法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>+(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    C.<span class="built_in">setreal</span>(A.<span class="built_in">getreal</span>() + B.<span class="built_in">getreal</span>());</span><br><span class="line">    C.<span class="built_in">setimag</span>(A.<span class="built_in">getimag</span>() + B.<span class="built_in">getimag</span>());</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载减法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>-(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    C.<span class="built_in">setreal</span>(A.<span class="built_in">getreal</span>() - B.<span class="built_in">getreal</span>());</span><br><span class="line">    C.<span class="built_in">setimag</span>(A.<span class="built_in">getimag</span>() - B.<span class="built_in">getimag</span>());</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载乘法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    C.<span class="built_in">setreal</span>(A.<span class="built_in">getreal</span>() * B.<span class="built_in">getreal</span>() - A.<span class="built_in">getimag</span>() * B.<span class="built_in">getimag</span>());</span><br><span class="line">    C.<span class="built_in">setimag</span>(A.<span class="built_in">getimag</span>() * B.<span class="built_in">getreal</span>() + A.<span class="built_in">getreal</span>() * B.<span class="built_in">getimag</span>());</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载除法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>/(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    <span class="keyword">double</span> square = A.<span class="built_in">getreal</span>() * A.<span class="built_in">getreal</span>() + A.<span class="built_in">getimag</span>() * A.<span class="built_in">getimag</span>();</span><br><span class="line">    C.<span class="built_in">setreal</span>((A.<span class="built_in">getreal</span>() * B.<span class="built_in">getreal</span>() + A.<span class="built_in">getimag</span>() * B.<span class="built_in">getimag</span>()) / square);</span><br><span class="line">    C.<span class="built_in">setimag</span>((A.<span class="built_in">getimag</span>() * B.<span class="built_in">getreal</span>() - A.<span class="built_in">getreal</span>() * B.<span class="built_in">getimag</span>()) / square);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    complex c1, <span class="built_in">c2</span>(<span class="number">15.5</span>, <span class="number">23.1</span>);</span><br><span class="line">    c1 = c2 + <span class="number">13.5</span>;  <span class="comment">// ok</span></span><br><span class="line">    c1 = <span class="number">13.5</span> + c2;  <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>c1 = c2 + 13.5;</code> 可以理解成 <code>c1 = operator+(c2, 13.5);</code>。因为我们在顶层函数中定义了 <code>complex operator+(const complex &amp; A, const complex &amp;B)</code> 函数，系统在执行 <code>c1 = operator+(c2, 13.5);</code> 时找到了对应的顶层函数，虽然参数不对，但可以通过类的构造函数将 13.5 转换成 complex 类对象，如此就满足 operator+() 函数的调用条件了，故而这一句是没有问题的。</li>
<li><code>c1 = 13.5 + c2;</code> 同理。</li>
</ul>
<blockquote>
<p>总结：以类成员函数的形式进行操作符重载，操作符左侧的操作数必须为类对象；而以顶层函数的形式进行操作符重载，只要类中定义了相应的转型构造函数，操作符左侧或右侧的操作数均可以不是类对象，但其中必须至少有一个类对象，否则调用的就是系统内建的操作符而非自己定义的操作符重载函数了。</p>
</blockquote>
<h3 id="重载输入与输出操作符"><a href="#重载输入与输出操作符" class="headerlink" title="重载输入与输出操作符"></a>重载输入与输出操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a);</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b);</span><br><span class="line">    <span class="keyword">friend</span> complex <span class="keyword">operator</span>+(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B);</span><br><span class="line">    <span class="keyword">friend</span> complex <span class="keyword">operator</span>-(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B);</span><br><span class="line">    <span class="keyword">friend</span> complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B);</span><br><span class="line">    <span class="keyword">friend</span> complex <span class="keyword">operator</span>/(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B);</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, complex&amp; A);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, complex&amp; A);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real;  <span class="comment">//复数的实部</span></span><br><span class="line">    <span class="keyword">double</span> imag;  <span class="comment">//复数的虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>() &#123;</span><br><span class="line">    real = <span class="number">0.0</span>;</span><br><span class="line">    imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a) &#123;</span><br><span class="line">    real = a;</span><br><span class="line">    imag = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">    real = a;</span><br><span class="line">    imag = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印复数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot; i &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载加法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>+(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    C.real = A.real + B.real;</span><br><span class="line">    C.imag = A.imag + B.imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载减法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>-(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    C.real = A.real - B.real;</span><br><span class="line">    C.imag = A.imag - B.imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载乘法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>*(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    C.real = A.real * B.real - A.imag * B.imag;</span><br><span class="line">    C.imag = A.imag * B.real + A.real * B.imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载除法操作符</span></span><br><span class="line">complex <span class="keyword">operator</span>/(<span class="keyword">const</span> complex&amp; A, <span class="keyword">const</span> complex&amp; B) &#123;</span><br><span class="line">    complex C;</span><br><span class="line">    <span class="keyword">double</span> square = A.real * A.real + A.imag * A.imag;</span><br><span class="line">    C.real = (A.real * B.real + A.imag * B.imag) / square;</span><br><span class="line">    C.imag = (A.imag * B.real - A.real * B.imag) / square;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输入操作符</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, complex&amp; A) &#123;</span><br><span class="line">    in &gt;&gt; A.real &gt;&gt; A.imag;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输出操作符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, complex&amp; A) &#123;</span><br><span class="line">    out &lt;&lt; A.real &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; A.imag &lt;&lt; <span class="string">&quot; i &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">-5.8</span>)</span></span>;</span><br><span class="line">    <span class="function">complex <span class="title">c2</span><span class="params">(<span class="number">8.4</span>, <span class="number">6.7</span>)</span></span>;</span><br><span class="line">    complex c3;</span><br><span class="line"></span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1 + c2 = &quot;</span> &lt;&lt; c3 &lt;&lt; endl;  <span class="comment">// c1 + c2 = 12.7 + 0.9 i </span></span><br><span class="line"></span><br><span class="line">    c3 = c1 - c2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1 - c2 = &quot;</span> &lt;&lt; c3 &lt;&lt; endl;  <span class="comment">// c1 - c2 = -4.1 + -12.5 i</span></span><br><span class="line"></span><br><span class="line">    c3 = c1 * c2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1 * c2 = &quot;</span> &lt;&lt; c3 &lt;&lt; endl;  <span class="comment">// c1 * c2 = 74.98 + -19.91 i </span></span><br><span class="line"></span><br><span class="line">    c3 = c1 / c2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1 / c2 = &quot;</span> &lt;&lt; c3 &lt;&lt; endl;  <span class="comment">// c1 / c2 = -0.0525609 + -1.48724 i</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重载赋值操作符"><a href="#重载赋值操作符" class="headerlink" title="重载赋值操作符"></a>重载赋值操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>() &#123;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span>* A, <span class="keyword">int</span> n);</span><br><span class="line">    <span class="built_in">Array</span>(Array&amp; a);</span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; a);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setnum</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">getaddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span>* num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(Array&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.num != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        length = a.length;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            num[i] = a.num[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值操作符</span></span><br><span class="line">Array&amp; Array::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;a) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] num;</span><br><span class="line">        <span class="keyword">if</span> (a.num != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            length = a.length;</span><br><span class="line">            num = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">                num[i] = a.num[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">int</span>* A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    num = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    length = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        num[i] = A[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::setnum</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; length)</span><br><span class="line">        num[index] = value;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index out of range!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        cout &lt;&lt; num[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">Array::getaddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(A, <span class="number">5</span>)</span></span>;</span><br><span class="line">    arr1.<span class="built_in">display</span>();   <span class="comment">// 1 2 3 4 5 </span></span><br><span class="line"></span><br><span class="line">    <span class="function">Array <span class="title">arr2</span><span class="params">(arr1)</span></span>;</span><br><span class="line">    arr2.<span class="built_in">display</span>();   <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    arr2.<span class="built_in">setnum</span>(<span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">    arr1.<span class="built_in">display</span>();   <span class="comment">// 1 2 3 4 5 </span></span><br><span class="line">    arr2.<span class="built_in">display</span>();   <span class="comment">// 1 2 8 4 5</span></span><br><span class="line">    cout &lt;&lt; arr1.<span class="built_in">getaddress</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr2.<span class="built_in">getaddress</span>() &lt;&lt; endl;  <span class="comment">// 0x7ff16c501d30 0x7ff16c501d50</span></span><br><span class="line"></span><br><span class="line">    arr1 = arr2;</span><br><span class="line">    arr1.<span class="built_in">display</span>();   <span class="comment">// 1 2 8 4 5 </span></span><br><span class="line">    arr2.<span class="built_in">display</span>();   <span class="comment">// 1 2 8 4 5 </span></span><br><span class="line">    </span><br><span class="line">    arr2.<span class="built_in">setnum</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    arr1.<span class="built_in">display</span>();   <span class="comment">// 1 2 8 4 5 </span></span><br><span class="line">    arr2.<span class="built_in">display</span>();   <span class="comment">// 1 2 8 9 5 </span></span><br><span class="line">    cout &lt;&lt; arr1.<span class="built_in">getaddress</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr2.<span class="built_in">getaddress</span>() &lt;&lt; endl;  <span class="comment">// 0x7ff16c501d30 0x7ff16c501d50</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重载下标操作符"><a href="#重载下标操作符" class="headerlink" title="重载下标操作符"></a>重载下标操作符</h3><p>下标操作符 <code>[ ]</code> 必须要以类的成员函数的形式进行重载。其在类中的声明格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 &amp; operator [] (参数)</span><br><span class="line">或</span><br><span class="line">const 返回类型 &amp; operator [] (参数)</span><br></pre></td></tr></table></figure>

<p>如果使用第一种声明方式，操作符重载函数不仅可以访问对象，同时还可以修改对象。如果使用第二种声明方式，则操作符重载函数只能访问对象，不能修改对象。</p>
<p>示例：在我们访问数组时，通过下标去访问数组中的元素并不具有检查边界溢出功能，我们可以重载下标操作符使之具有相应的功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>() &#123;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> n);</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span>) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span>* num;</span><br><span class="line">&#125;;</span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (bad_alloc) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;allocate storage failure!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    length = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;out of bounds&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;out of bounds&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">A</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; A.<span class="built_in">getlength</span>(); i++)</span><br><span class="line">            A[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            cout &lt;&lt; A[i] &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (string s) &#123;</span><br><span class="line">        cerr &lt;&lt; s &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// out of bounds, i = 5</span></span><br></pre></td></tr></table></figure>

<p>两个版本的重载下标操作符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; <span class="keyword">operator</span>[]( <span class="keyword">int</span> );</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[]( <span class="keyword">int</span> )<span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<p>第一个下标操作符重载函数最后面不带 const，加上 const 意味着该成员函数是常成员函数，如果第一个函数后面也加上了 const，则两个函数仅有返回值不相同，这个不足以用于区分函数，编译器会提示语法错误。</p>
<h3 id="函数调用操作符重载"><a href="#函数调用操作符重载" class="headerlink" title="函数调用操作符重载"></a>函数调用操作符重载</h3><p>声明语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 operator ()(参数列表);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>() &#123;</span><br><span class="line">        len1 = <span class="number">0</span>;</span><br><span class="line">        len2 = <span class="number">0</span>;</span><br><span class="line">        num = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n);</span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlen1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> len1; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getlen2</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> len2; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len1;</span><br><span class="line">    <span class="keyword">int</span> len2;</span><br><span class="line">    <span class="keyword">int</span>* num;</span><br><span class="line">&#125;;</span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = m * n;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (bad_alloc) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;allocate storage failure!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len1 = m;</span><br><span class="line">    len2 = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">Array::operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= len1)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;1 out of bounds!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt;= len2)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;2 out of bounds!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> num[i * len2 + j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">Array::operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= len1)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;1 out of bounds!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt;= len2)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;2 out of bounds!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> num[i * len2 + j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">A</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; A.<span class="built_in">getlen1</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; A.<span class="built_in">getlen2</span>(); j++)</span><br><span class="line">            <span class="built_in">A</span>(i, j) = i * A.<span class="built_in">getlen2</span>() + j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; A.<span class="built_in">getlen1</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; A.<span class="built_in">getlen2</span>(); j++)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">A</span>(i, j) &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">A</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (string s) &#123;</span><br><span class="line">        cerr &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">A</span>(<span class="number">2</span>, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (string s) &#123;</span><br><span class="line">        cerr &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-1-2-3-4-5-6-7-8-9-10-11-</span></span><br><span class="line"><span class="comment">// 1 out of bounds!</span></span><br><span class="line"><span class="comment">// 2 out of bounds!</span></span><br></pre></td></tr></table></figure>

<p>主函数的异常捕获语句中，我们先运行的是 A(5, 3)，故而是第一个边界越界了，因此先抛出 “1 out of bounds!” 异常，然后又运行 A(2, 6)，此时为第二个边界越界，抛出 “2 out of bounds!” 异常。</p>
<p>有了这两个函数调用操作符重载函数，我们就可以用 A (i,j) 的形式访问二维数组中的数据了。当我们用 A (i,j) 的形式访问二维数组中的数据时，A (i,j) 会调用类中的函数调用操作符重载函数，此时 A (i,j) 可以理解为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="built_in"><span class="keyword">operator</span></span>()(i, j)</span><br></pre></td></tr></table></figure>



<h3 id="重载自增与自减操作符"><a href="#重载自增与自减操作符" class="headerlink" title="重载自增与自减操作符"></a>重载自增与自减操作符</h3><p>自增运算符 <code>++</code> 与自减运算符 <code>--</code> 都是一元操作符，其前置和后置两种形式都可以被重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stopwatch</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stopwatch</span>() &#123;</span><br><span class="line">        min = <span class="number">0</span>;</span><br><span class="line">        sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setzero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min = <span class="number">0</span>;</span><br><span class="line">        sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">stopwatch <span class="title">run</span><span class="params">()</span></span>;            <span class="comment">// 运行</span></span><br><span class="line">    stopwatch <span class="keyword">operator</span>++();     <span class="comment">// ++i</span></span><br><span class="line">    stopwatch <span class="keyword">operator</span>++(<span class="keyword">int</span>);  <span class="comment">// i++</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> stopwatch&amp;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> min;  <span class="comment">//分钟</span></span><br><span class="line">    <span class="keyword">int</span> sec;  <span class="comment">//秒钟</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 秒针向前进一秒</span></span><br><span class="line"><span class="function">stopwatch <span class="title">stopwatch::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++sec;</span><br><span class="line">    <span class="keyword">if</span> (sec == <span class="number">60</span>) &#123;</span><br><span class="line">        min++;</span><br><span class="line">        sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">stopwatch stopwatch::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个函数中，参数 n 是没有意义的，它的存在只是为了区分是前置还是后置形式</span></span><br><span class="line">stopwatch stopwatch::<span class="keyword">operator</span>++(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    stopwatch s = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> stopwatch&amp; s) &#123;</span><br><span class="line">    out &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; s.min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; s.sec;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stopwatch s1, s2;</span><br><span class="line">    s1 = s2++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; s1 &quot;</span> &lt;&lt; s1 &lt;&lt; endl;  <span class="comment">//  s1 00:00</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; s2 &quot;</span> &lt;&lt; s2 &lt;&lt; endl;  <span class="comment">//  s2 00:01</span></span><br><span class="line">    s1.<span class="built_in">setzero</span>();</span><br><span class="line">    s2.<span class="built_in">setzero</span>();</span><br><span class="line">    s1 = ++s2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; s1 &quot;</span> &lt;&lt; s1 &lt;&lt; endl;  <span class="comment">//  s1 00:01</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; s2 &quot;</span> &lt;&lt; s2 &lt;&lt; endl;  <span class="comment">//  s2 00:01</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重载转型操作符"><a href="#重载转型操作符" class="headerlink" title="重载转型操作符"></a>重载转型操作符</h3><p>转型构造函数可以将其它类型的参数转换为类类型。如果我们要进行相反的转换过程，<strong>将类类型转换为其它数据类型</strong>，则需重载转型操作符。</p>
<p>转型操作符重载函数的声明语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 类型名();</span><br></pre></td></tr></table></figure>

<p>转型操作符重载函数需要注意：</p>
<ul>
<li>函数没有返回类型；</li>
<li>虽然没有返回类型但是函数体中必须有 return 语句，其返回类型是由类型名来指定的；</li>
<li>转型操作符重载函数只能以类的成员函数的形式进行重载，而不能以友元函数或顶层函数的形式进行重载。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clock</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">clock</span>() &#123; hour = min = ap = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">clock</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> ap);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hour;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">int</span> ap;  <span class="comment">// 0表示am, 1表示pm</span></span><br><span class="line">&#125;;</span><br><span class="line">clock::<span class="built_in">clock</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> ap) &#123;</span><br><span class="line">    hour = h;</span><br><span class="line">    min = m;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ap = ap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转型操作符重载函数</span></span><br><span class="line"><span class="comment">// 将类类型的时间转换为一个整形</span></span><br><span class="line"><span class="function">clock::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time = hour;</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">12</span>)</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ap == <span class="number">1</span>)</span><br><span class="line">        time += <span class="number">12</span>;</span><br><span class="line">    time *= <span class="number">100</span>;</span><br><span class="line">    time += min;</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">clock <span class="title">c</span><span class="params">(<span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  	<span class="comment">// 将对象c赋给一个整形变量time</span></span><br><span class="line">    <span class="keyword">int</span> time = c;</span><br><span class="line">    cout &lt;&lt; time &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="内存管理操作符重载"><a href="#内存管理操作符重载" class="headerlink" title="内存管理操作符重载"></a>内存管理操作符重载</h3><p>内存管理操作符 new、new[]、delete 和 delete[] 同样也可以进行操作符重载，其重载形式既可以是类成员函数的形式，又可以是顶层函数的形式。</p>
<p>操作符 new 的重载函数有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * 类名::<span class="function"><span class="keyword">operator</span> <span class="title">new</span> <span class="params">( <span class="keyword">size_t</span> size )</span> </span>&#123;</span><br><span class="line">  <span class="comment">//以类成员函数的形式重载new操作符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">( <span class="keyword">size_t</span> size )</span> </span>&#123;</span><br><span class="line">  <span class="comment">//以顶层函数的形式重载new操作符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delete 操作符也有两种重载形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> 类名::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//以类成员函数的形式重载delete操作符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以顶层函数的形式重载delete操作符</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>当我们以类成员函数的形式重载了 new 和 delete 操作符时，其使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C * c = <span class="keyword">new</span> C;   <span class="comment">//分配内存空间</span></span><br><span class="line"><span class="keyword">delete</span> c;        <span class="comment">//释放内存空间</span></span><br></pre></td></tr></table></figure>



<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>string 是 C++ 中常用的一个类，类中提供有很多实用的处理字符串的方法，例如 length()、erase() 等。此外，string 类还重载了一些运算符，赋予其处理字符串的能力，例如 string 类重载了 + 操作符，使其具有连接两个字符串的能力。</p>
<h3 id="string-类型变量的定义和简单使用"><a href="#string-类型变量的定义和简单使用" class="headerlink" title="string 类型变量的定义和简单使用"></a>string 类型变量的定义和简单使用</h3><p>C++ 中提供了一个 string 内建数据类型，它可以替代 C 语言中的 char* 数组。使用 string 数据类型时，需要在程序中包含头文件 <code>&lt;string&gt;</code>。</p>
<p>几种定义 string 类型变量的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1;</span><br><span class="line">    string s2 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    string s3 = s2;</span><br><span class="line">    <span class="function">string <span class="title">s4</span> <span class="params">(<span class="number">10</span>, <span class="string">&#x27;s&#x27;</span>)</span></span>;  <span class="comment">// 初始化为 10 个&#x27;s&#x27; 字符组成的字符串，即 &quot;ssssssssss&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换为 char 数组字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string filename = <span class="string">&quot;input.txt&quot;</span>;</span><br><span class="line">ifstream in;</span><br><span class="line"><span class="comment">// 转换函数 c_str()，该函数将 string 类型的变量转换为一个 const 的字符串数组的指针。</span></span><br><span class="line">in.<span class="built_in">open</span>(filename.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<p>string 类型变量的输入与输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string 类型字符串的连接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接用 “+” 或者 “+=” 进行字符串的连接</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 = <span class="string">&quot;first&quot;</span>;</span><br><span class="line">    s2 = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    s3 = s1 + s2;</span><br><span class="line">    cout&lt;&lt; s3 &lt;&lt;endl;</span><br><span class="line">    s2 += s1;</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    s1 += <span class="string">&quot;third&quot;</span>;</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    s1 += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>==</code>、<code>!=</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>&lt;</code> 和 <code>&gt;</code> 操作符都可以用于进行 string 类型字符串的比较，这些操作符两边都可以是 string 字符串，也可以一边是 string 字符串另一边是字符串数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;secondsecondthird&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;secondthird&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>( s1 == s2 )</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot; == &quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>( s1 != s2 )</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot; != &quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>( s1 &lt; s2 )</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot; &lt; &quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>( s1 &gt; s2 )</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot; &gt; &quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// !=</span></span><br><span class="line"><span class="comment">// &lt;</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1;</span><br><span class="line">    s1 = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">length</span>(); i++)</span><br><span class="line">        cout &lt;&lt; s1[i] &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s1[<span class="number">5</span>] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-2-3-4-5-6-7-8-9-0-</span></span><br><span class="line"><span class="comment">// 1234557890</span></span><br></pre></td></tr></table></figure>



<h4 id="erase：删除子串"><a href="#erase：删除子串" class="headerlink" title="erase：删除子串"></a>erase：删除子串</h4><p>erase() 函数可以删除 string 类型变量中的一个子字符串：</p>
<p>erase () 函数有两个参数：</p>
<ul>
<li>第一个参数是要删除的子字符串的起始下标，</li>
<li>第二参数是要删除子字符串的长度，如果第二个参数不指名的话，则是直接从第一个参数获取起始下标，然后一直删除至字符串结束。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 = s2 = s3 = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">    s2.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line">    s3.<span class="built_in">erase</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;  <span class="comment">// 1234567890</span></span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;  <span class="comment">// 12345</span></span><br><span class="line">    cout&lt;&lt; s3 &lt;&lt;endl;  <span class="comment">// 1234590</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="insert：插入子串"><a href="#insert：插入子串" class="headerlink" title="insert：插入子串"></a>insert：插入子串</h4><p>insert() 函数可以在 string 字符串中指定的位置插入另一个字符串。</p>
<p>insert () 函数同样有两个参数，</p>
<ul>
<li>第一个参数表示插入位置，</li>
<li>第二参数表示要插入的字符串，第二个参数既可以是 string 变量，又可以是 C 风格的字符串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 = s2 = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">    s3 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">5</span>, s3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;     <span class="comment">// 12345aaa567890</span></span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot;aaa&quot;</span>); </span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;     <span class="comment">// 12345aaa567890</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="replace：替换子串"><a href="#replace：替换子串" class="headerlink" title="replace：替换子串"></a>replace：替换子串</h4><p>replace() 函数可以用一个指定的字符串来替换 string 类型变量中的一个子字符串。</p>
<p>replace () 函数有三个参数，</p>
<ul>
<li>第一个参数表示待替换的子字符串的其实下标，</li>
<li>第二个参数表示待替换子字符串的长度，</li>
<li>第三个参数表示要替换子字符串的字符串。第三个参数同样可以是 string 类型变量或 C 风格字符串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 = s2 = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">    s3 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    s1.<span class="built_in">replace</span>(<span class="number">5</span>, <span class="number">4</span>, s3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;    <span class="comment">// 12345aaa0</span></span><br><span class="line">    s2.<span class="built_in">replace</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;    <span class="comment">// 12345aaa0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="swap：交换"><a href="#swap：交换" class="headerlink" title="swap：交换"></a>swap：交换</h4><p>swap() 函数可以用于将两个 string 类型变量的值互换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;aaaaaa&quot;</span>;</span><br><span class="line">    s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;  <span class="comment">// aaaaaa</span></span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;  <span class="comment">// string</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="substr：提取子串"><a href="#substr：提取子串" class="headerlink" title="substr：提取子串"></a>substr：提取子串</h4><p>substr() 函数可以提取 string 字符串中的子字符串，</p>
<p>该函数有两个参数，</p>
<ul>
<li>第一个参数为需要提取的子字符串的起始下标，</li>
<li>第二个参数是需要提取的子字符串的长度。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;first second third&quot;</span>;</span><br><span class="line">    string s2;</span><br><span class="line">    s2 = s1.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;  <span class="comment">// first second third</span></span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;  <span class="comment">// second</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="find：查找子串"><a href="#find：查找子串" class="headerlink" title="find：查找子串"></a>find：查找子串</h4><p>find() 函数可以在字符串中查找子字符串中出现的位置。</p>
<p>该函数有两个参数，</p>
<ul>
<li>第一个参数是待查找的子字符串，</li>
<li>第二个参数是表示开始查找的位置，如果第二个参数不指名的话则默认从 0 开始查找，也即从字符串首开始查找。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;first second third&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.<span class="built_in">find</span>(s2,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.<span class="built_in">length</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Found at index : &quot;</span>&lt;&lt; index &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Not found&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Found at index : 6</span></span><br></pre></td></tr></table></figure>



<p>rfind() 函数与 find() 函数很类似，同样是在字符串中查找子字符串。</p>
<p>不同的是，find() 函数是从第二个参数开始往后查找，而 rfind() 函数则是最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值 4294967295。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;first second third&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.<span class="built_in">rfind</span>(s2,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.<span class="built_in">length</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Found at index : &quot;</span>&lt;&lt; index &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Not found&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Found at index : 6</span></span><br></pre></td></tr></table></figure>



<h4 id="find-first-of：查找子串和字符串共同具有的字符在字符串中出现的位置"><a href="#find-first-of：查找子串和字符串共同具有的字符在字符串中出现的位置" class="headerlink" title="find_first_of：查找子串和字符串共同具有的字符在字符串中出现的位置"></a>find_first_of：查找子串和字符串共同具有的字符在字符串中出现的位置</h4><p>find_first_of() 函数是用于查找子字符串和字符串共同具有的字符在字符串中出现的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;first second second third&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;asecond&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.<span class="built_in">find_first_of</span>(s2);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; s1.<span class="built_in">length</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found at index : &quot;</span> &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not found&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 和 s2 共同具有的字符是&#x27;s&#x27;，该字符在 s1 中首次出现的下标是 3，故查找结果返回 3</span></span><br><span class="line"><span class="comment">// Found at index : 3</span></span><br></pre></td></tr></table></figure>

<p> find_first_not_of() 函数则相反，它查找的是在 s1 字符串但不在 s2 字符串中的首位字符的下标，如果查找不成功则返回无穷大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;secondasecondthird&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;asecond&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.<span class="built_in">find_first_not_of</span>(s2);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; s1.<span class="built_in">length</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found at index : &quot;</span> &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not found&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 s1 但是不在 s2 中的首字符是 &#x27;t&#x27;，其所在下标为 13，故而返回下标 13</span></span><br><span class="line"><span class="comment">// Found at index : 13</span></span><br></pre></td></tr></table></figure>



<h2 id="输入与输出流"><a href="#输入与输出流" class="headerlink" title="输入与输出流"></a>输入与输出流</h2><p>输入输出类层次可以分为<code>输入输出流类层次</code>和<code>缓冲类层次</code></p>
<h3 id="输入输出类的层次"><a href="#输入输出类的层次" class="headerlink" title="输入输出类的层次"></a>输入输出类的层次</h3><h4 id="输入输出流类层次"><a href="#输入输出流类层次" class="headerlink" title="输入输出流类层次"></a>输入输出流类层次</h4><p><img src="/images/105J25R6-0.png" alt="img"></p>
<p>在 C++ 中，输入输出流层次是从 ios_basic 类开始的，该类作为所有类的基类，之后它派生出了 basic_ios 类，这两个类是整个输入输出流类层次的基类，但是它们在功能上有些区别：</p>
<ul>
<li>ios_basic 和 basic_ios 都在一定程度上描述了流的基本性质，</li>
<li>但是 ios_basic 并没有考虑流的字符集，而 basic_ios 在描述流的基本性质时考虑了此点。</li>
</ul>
<p>basic_ios 类派生出了 basic_istream 和 basic_ostream 类，其中 basic_istream 类用于描述输入流，而 basic_ostream 用于描述输出流。 basic_istream 和 basic_ostream 类分别继承了 ios_base 和 basic_ios 类中的成员函数，并且增添了自己的成员函数，例如分别对左移操作符和右移操作符的重载函数。</p>
<p>basic_iostream 类同时继承了 basic_istream 类和 basic_ostream 类，该类并没有新增成员变量，在成员函数方面，它也只是增添了构造函数和析构函数。</p>
<p>而 basic_ifstream 和 basic_ofstream 类分别继承自 basic_istream 类和 basic_ostream 类，basic_ifstream 和 basic_ofstream 类主要是对文件进行读写操作。</p>
<p>在 C++ 中，输入和输出并不是直接进行读和写操作的，通常读和写操作是通过一个缓冲区来进行的。当计算机收到写字符的请求时，计算机并不会将等待写入的字符直接写入到输出流中，而是将其先写到缓冲区中，然后定期地将缓冲区中的字符写入到输出流中，此过程我们称之为<code>清扫缓冲区</code>，通常缓冲区满或者换行符会带动一次将缓冲区中的字符写到输出流中。读入操作也同样会经过缓冲区，也有类似的过程。</p>
<h4 id="缓冲类层次"><a href="#缓冲类层次" class="headerlink" title="缓冲类层次"></a>缓冲类层次</h4><p>在缓冲类层次中，所有缓冲类都从公共基类 basic_streambuf 类派生而来。</p>
<p><img src="/images/105J22N9-1.png" alt="img"></p>
<p>字符流缓冲类 basic_stringbuf 和文件缓冲类 basic_filebuf，这两个类为输入输出类提供输入输出服务，它们从 basic_streambuf 类中继承了对缓冲区读写操作的函数。</p>
<p>在程序中声明头文件，就相当于在程序中声明了相关的类，可以说头文件是程序与类库的接口，在大致了解了输入输出类层次之后，我们来看一下头文件的用途。</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>iosfwd</td>
<td>包含一些基本的类声明</td>
</tr>
<tr>
<td>iostream</td>
<td>声明了 cin、cout 等对象</td>
</tr>
<tr>
<td>ios</td>
<td>声明了 ios_base 类和 basic_ios 类</td>
</tr>
<tr>
<td>streambuf</td>
<td>声明了 basic_streambuf 类</td>
</tr>
<tr>
<td>istream</td>
<td>声明了 basic_istream 类和 basic_iostream 类</td>
</tr>
<tr>
<td>ostream</td>
<td>声明了 basic_ostream 类</td>
</tr>
<tr>
<td>iomanip</td>
<td>声明了用于格式化处理的操纵符</td>
</tr>
<tr>
<td>sstream</td>
<td>声明了 basic_stringbuf 类和 stringstream 类</td>
</tr>
<tr>
<td>fstream</td>
<td>声明了 basic_filebuf 类和 fstream 类</td>
</tr>
</tbody></table>
<p>在这些头文件中我们常用头文件有：iostream、fstream、strstream、iomanip。</p>
<ul>
<li>iostream 包含了对输入输出流进行操作所需要的基本信息，</li>
<li>fstream 用于对文件的读写操作，</li>
<li>strstream 用于输入输出字符串，</li>
<li>iomanip 用于格式化输入输出。</li>
</ul>
<h3 id="标准输出流对象"><a href="#标准输出流对象" class="headerlink" title="标准输出流对象"></a>标准输出流对象</h3><p>标准输出：其实就是向标准输出设备进行输出。通常来讲，我们可以将标准输出设备理解为显示器。</p>
<p>系统声明的三个标准输出流对象 cout、cerr 和 clog 中，cerr 和 clog 对象都是标准错误流，不同的是，cerr 是直接将错误信息输出到显示器，而 clog 是将错误信息先写入到缓冲区，待清扫缓冲区时，再将错误内容输出到显示器中。与 cerr 和 clog 对象不同，cout 对象则非错误流，而只是普通的输出流，该对象在进行输出时，也会经过先缓冲区，然后再输出到显示器。</p>
<h3 id="格式标识和操纵器"><a href="#格式标识和操纵器" class="headerlink" title="格式标识和操纵器"></a>格式标识和操纵器</h3><p>我们通常需要将输出数据以某种格式显示出来，例如我们希望将时间显示为 “dd:dd:dd” 的形式，如此一来就需要借助格式标识符来控制 cout 对象的输出格式。</p>
<p>在 ios_base 类中，系统已经定义了很多格式标识符，通过这些标识符，我们可以很好地进行格式化控制，具体见下表。除此之外，ios_base 类中还定义有 width() 和 precision() 等函数，这些函数同样可以辅助我们进行格式化控制。</p>
<table>
<thead>
<tr>
<th>格式标识符</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>boolalpha</td>
<td>以 true 和 false 的形式读写 bool 类型变量</td>
</tr>
<tr>
<td>dec</td>
<td>以十进制的方式进行读写</td>
</tr>
<tr>
<td>oct</td>
<td>以八进制的方式进行读写</td>
</tr>
<tr>
<td>hex</td>
<td>以十六进制的方式进行读写</td>
</tr>
<tr>
<td>internal</td>
<td>放在正负号或基数标识之后</td>
</tr>
<tr>
<td>left</td>
<td>左对齐</td>
</tr>
<tr>
<td>right</td>
<td>右对齐</td>
</tr>
<tr>
<td>fixed</td>
<td>以定点方式表示浮点数</td>
</tr>
<tr>
<td>scientific</td>
<td>用科学计数法表示浮点数</td>
</tr>
<tr>
<td>showbase</td>
<td>输出时显示基数</td>
</tr>
<tr>
<td>showpoint</td>
<td>必须显示小数点</td>
</tr>
<tr>
<td>showpos</td>
<td>对非负数显示 + 号</td>
</tr>
<tr>
<td>skipws</td>
<td>忽略空格</td>
</tr>
<tr>
<td>unitbuf</td>
<td>写操作完成后清扫所有的缓冲区</td>
</tr>
<tr>
<td>uppercase</td>
<td>用大写字母表示十六进制</td>
</tr>
<tr>
<td>adjustfield</td>
<td>格式标识必须是 left、right 或 internal</td>
</tr>
<tr>
<td>basefield</td>
<td>格式标识必须是 dec、oct 或 hex</td>
</tr>
<tr>
<td>floatfield</td>
<td>格式标识必须是 scientific 或 fixed</td>
</tr>
</tbody></table>
<p>有了表中所列标识符，我们的确可以进行格式控制，但除了能够直接调用这些格式标识符之外，我们还可以借助类中提供的成员函数，具体成员函数见下表。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>flags()</td>
<td>返回当前的格式标识</td>
</tr>
<tr>
<td>flags( val )</td>
<td>将格式标识设置为 val，并返回旧值</td>
</tr>
<tr>
<td>setf ( val )</td>
<td>将 val 设置为当前的格式标识，并返回旧的格式标识</td>
</tr>
<tr>
<td>setf ( val, ios_base::basefield )</td>
<td>将 val 设置为当前的格式标识，并返回旧的格式标识，且要求 val 为 iso_base::dec、ios_base::hex 或 ios_base::oct 三者之一</td>
</tr>
<tr>
<td>setf ( val, ios_base::adjustfield )</td>
<td>将 val 设置为当前的格式标识，并返回旧的格式标识，且要求 val 为 iso_base::left、ios_base::internal 或 ios_base::right 三者之一</td>
</tr>
<tr>
<td>setf ( ios_base::internal, ios_base::adjustfield )</td>
<td>在符号与数据之间填充字符，并返回旧标识</td>
</tr>
<tr>
<td>setf ( ios_base::scientific, ios_base::floatfield )</td>
<td>设置科学计数法并返回旧标识</td>
</tr>
<tr>
<td>setf ( ios_base::fixed, ios_base::floatfield )</td>
<td>设置定点计数法并返回旧标识</td>
</tr>
<tr>
<td>setf ( 0, ios_base::floatfield )</td>
<td>设置默认浮点数表示法并返回旧标识</td>
</tr>
<tr>
<td>unsetf ( val )</td>
<td>清楚指定的标识并返回旧标识</td>
</tr>
</tbody></table>
<p> 这些函数都是 ios_base 类的成员函数，可以通过对象直接调用，而 cout 是 basic_ostream 的一个对象，basic_ostream 继承自 ios_base，因此 cout 可以调用这些函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::fmtflags old_val =</span><br><span class="line">        cout.<span class="built_in">flags</span>(ios_base::left | ios_base::hex | ios_base::uppercase |</span><br><span class="line">                   ios_base::showbase);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt; <span class="number">150</span>; i++)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">unsetf</span>(ios_base::left | ios_base::hex | ios_base::uppercase);</span><br><span class="line">    cout.<span class="built_in">setf</span>(old_val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt; <span class="number">150</span>; i++)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">unsetf</span>(old_val);</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::hex | ios_base::uppercase);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; hex &quot;</span> &lt;&lt; <span class="number">170</span> &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">unsetf</span>(ios_base::hex | ios_base::uppercase);</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::oct);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; oct &quot;</span> &lt;&lt; <span class="number">170</span> &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">unsetf</span>(ios_base::oct);</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::dec);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; dec &quot;</span> &lt;&lt; <span class="number">170</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用 flags() 函数设置输出格式，格式设置为左对齐和大写的十六进制，之后将 100<del>149 的数字全部输出，输出完之后将刚才设置的格式全部取消，然后重新设置为原始的格式 old_val，再将数字 100</del>149 的数字重新输出一遍。之后我们演示的是将 170 按照十六进制、八进制和十进制的形式输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="number">-100</span> &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::left, ios_base::adjustfield);</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="number">-100</span> &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">unsetf</span>(ios_base::left);</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios_base::right, ios_base::adjustfield);</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">6</span>);</span><br><span class="line">    cout &lt;&lt; <span class="number">-100</span> &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">unsetf</span>(ios_base::right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   -100</span></span><br><span class="line"><span class="comment">// -100  </span></span><br><span class="line"><span class="comment">//   -100</span></span><br></pre></td></tr></table></figure>

<p>我们调用成员函数 width() 控制输出的宽度为 6 个字符的位置，之后分别设置左对齐和右对齐，然后输出 -100</p>
<p>当然，这些格式化控制除了可以使用格式标识来控制外，我们还可以使用操纵器来控制，下面就来简单了解一下操纵器。</p>
<p>操作器其本质是函数，它可以直接改变流的格式。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; &quot; hex &quot; &lt;&lt; 170 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; oct &lt;&lt; &quot; oct &quot; &lt;&lt; 170 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; dec &lt;&lt; &quot; dec &quot; &lt;&lt; 170 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>本例中 hex、oct、dec 和 uppercase 都是操纵器，它可以与输入或输出操作符一起使用。</p>
<p>C++ 标准库中预定义了一些操纵器，使用其中带参数的操纵器则需要包含头文件 <code>&lt;iomanip&gt;</code>，下标中列出了一些带参数的操纵器。</p>
<table>
<thead>
<tr>
<th>格式标识符</th>
<th>作用对象</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>setbase( int n )</td>
<td>basic_ostream</td>
<td>将 n 设置为基数（默认值为 0）</td>
</tr>
<tr>
<td>setfill( char_type c )</td>
<td>basic_ostream</td>
<td>设置填充字符为 c</td>
</tr>
<tr>
<td>setprecision( int n )</td>
<td>basic_ostream</td>
<td>设置精度为 n</td>
</tr>
<tr>
<td>setw( int n )</td>
<td>basic_ostream</td>
<td>设置域宽为 n</td>
</tr>
<tr>
<td>setiosflags( val )</td>
<td>ios_base</td>
<td>设置指定的标识</td>
</tr>
<tr>
<td>resetiosflags( val )</td>
<td>ios_base</td>
<td>清楚指定的标识</td>
</tr>
</tbody></table>
<p>表中列出的最后两个函数，其参数值为标识，即为格式标识符的组合。</p>
<h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3><p>输入的过程是这样的：键盘输入完数据后按下回车键，该行数据就被写入输入缓冲区中，之后输入操作符从缓冲区中提取数据，在提取的过程中会忽略空格、Tab 键以及换行符等空白字符。如果输入流处于正常状态，则 cin 的返回值为 true，否则返回的是 false。当 cin 遇到错误的字符或文件结束符时，输入就会处于非正常状态，此时返回值为 0，终止所有数据输入操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; hex &gt;&gt; a) &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The end!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输入相关的成员函数"><a href="#输入相关的成员函数" class="headerlink" title="输入相关的成员函数"></a>输入相关的成员函数</h3><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p>get() 函数每次从输入流中读入一个字符，put() 函数将其输出。get() 函数在遇到空格、Tab 键以及换行符时，并不会像 cin 那样直接进行忽略，而是将它们当成一个字符。</p>
<p>get() 函数有三种重载形式：不带参数、带一个参数和带有三个参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">while</span> ((a = cin.<span class="built_in">get</span>()) != EOF) &#123;</span><br><span class="line">        cout.<span class="built_in">put</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带有一个参数的 get() 函数，其参数是一个 char 型变量，用于存放读入的单个字符。同时函数的返回值不再是读入的字符，而是 bool 类型，读取成功时函数返回一个非 0 值，当读取失败则返回 0，相当于 false，此时则停止读入字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">while</span> (cin.<span class="built_in">get</span>(a)) &#123;</span><br><span class="line">        cout.<span class="built_in">put</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带有三个参数的 get() 函数第一个参数是字符数组或字符指针，用于将读入的字符串存入到字符数组或指针所指向的内存空间；第二个参数为读入字符个数；最后一个参数为读取的终止字符。如果未读满指定的个数就碰到了终止字符，则会提前终止读入字符。函数读取成功返回一个非 0 值，读入失败或遇到文件终止符则返回 0，即为 false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> (cin.<span class="built_in">get</span>(a, <span class="number">10</span>, <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h4><p>getline() 函数和带三个参数的 get() 函数类似，getline() 函数的三个参数与 get() 函数的三个参数含义是相同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">    cin.<span class="built_in">getline</span>( a, <span class="number">10</span>, <span class="string">&#x27;7&#x27;</span> );</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>( a, <span class="number">10</span>, <span class="string">&#x27;7&#x27;</span> );</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>( a, <span class="number">10</span> );</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getline() 读取输入的字符时，终止字符是不被读入的，碰到一个终止字符就终止本次读入操作，同时指针向后移动一位，指向终止字符的后一个字符，以便下次从终止字符后面的一个字符继续读入。</p>
<p>而带三个参数的 get() 函数碰到终止字符则停止读入，指针并不会向后移一位，下次读入的时候仍从终止字符处开始读取，如果这一次读取的终止字符与上一次读入时的终止字符相同，则本次读入将不能读到字符。这就是 getline() 函数和带三个参数的 get () 函数的差别。</p>
<h4 id="eof"><a href="#eof" class="headerlink" title="eof()"></a>eof()</h4><p>eof() 函数可以用于判断读入数据是否遇到文件结束符，如果遇到文件结束符则返回 true，否则返回 false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">while</span> (!cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cin.<span class="built_in">get</span>(a);</span><br><span class="line">        cout.<span class="built_in">put</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ignore"><a href="#ignore" class="headerlink" title="ignore()"></a>ignore()</h4><p>ignore(int n, char) 函数用于忽略输入的 n 个字符或在遇到指定的字符时提前终止忽略行为。ignore() 函数的两个参数都带有默认值，n 的默认值为 1，第二个参数 char 默认值为 EOF。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">    cin.<span class="built_in">get</span>( a, <span class="number">10</span>, <span class="string">&#x27;7&#x27;</span> );</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    cin.<span class="built_in">get</span>( a, <span class="number">10</span>, <span class="string">&#x27;7&#x27;</span> );</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">get</span>( a, <span class="number">10</span> );</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><p>peek() 函数没有参数，它用于返回当前指针所指的字符，并且不会移动指针。如果当前指针所指向的是文件结束符，则该函数返回 -1（EOF）。</p>
<h4 id="putback"><a href="#putback" class="headerlink" title="putback()"></a>putback()</h4><p>putback (char) 函数是将 get() 或 getline() 函数读取到的字符重新插入到缓冲区当前指针所指位置，后面仍然会读取该字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">    cin.<span class="built_in">get</span>( a, <span class="number">10</span>, <span class="string">&#x27;7&#x27;</span> );</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    cin.<span class="built_in">get</span>( a, <span class="number">10</span>, <span class="string">&#x27;7&#x27;</span> );</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">putback</span>(a[<span class="number">8</span>]);</span><br><span class="line">    cin.<span class="built_in">putback</span>(a[<span class="number">7</span>]);</span><br><span class="line">    cin.<span class="built_in">get</span>( a, <span class="number">10</span> );</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="文本文件的读写操作"><a href="#文本文件的读写操作" class="headerlink" title="文本文件的读写操作"></a>文本文件的读写操作</h3><p>计算机上的文件其实是数据的集合，对文件的读写归根结底还是对数据的读写操作。</p>
<p>文件可以大致分为两种，分别是文本文件和二进制文件：</p>
<ul>
<li>文本文件中的每一个字节存放的都是一个 ASCII 码，代表一个字符；</li>
<li>二进制文件是将内存中的数据按照其在内存中的存储形式原样存放在磁盘上。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先是从 input.txt 文件中读取数据存入到数组 A[3][10] 中，然后再将 A[3][10] 数组中的数据打印到显示器，之后再将数据写入到 output.txt 文件中。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>, ios::in)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Open input file error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ofstream <span class="title">output</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!output) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Open output file error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            input &gt;&gt; A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            cout &lt;&lt; A[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            output &lt;&lt; A[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output &lt;&lt; <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    input.<span class="built_in">close</span>();</span><br><span class="line">    output.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为程序中使用了 cout 和 cerr 对象，因此必须包含 <code>&lt;iostream&gt;</code> 头文件。此外，文件操作还需要引入 <code>&lt;fstream&gt;</code> 头文件。</p>
<p>ifstream 类和 ofstream 类中都有一个 open() 成员函数，它可以用类的对象调用。open() 函数有两个参数，第一个参数是需要打开的文件名，这个参数可以是字符指针、字符数组或 string 类型，第二个参数是输入输出格式。下表列出了一些输入输出格式。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>以输入方式打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>以输出方式打开文件，如果文件不存在则新建，如果文件存在就将其原有内容全部清空</td>
</tr>
<tr>
<td>ios::app</td>
<td>输出的数据追加到文件末尾</td>
</tr>
<tr>
<td>ios::ate</td>
<td>打开一个文件，并将指针定位到文件末尾</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>打开一个文件，如果文件不存在则新建，如果存在，则清空原有文件中的内容</td>
</tr>
<tr>
<td>ios::binary</td>
<td>以二进制方式打开文件，如果不指定则默认采用文本方式打开文件</td>
</tr>
<tr>
<td>ios::in | ios::out</td>
<td>以输出和输入方式打开文件</td>
</tr>
<tr>
<td>ios::in | ios::binary</td>
<td>以输入方式打开一个二进制文件</td>
</tr>
<tr>
<td>ios::out| ios::binary</td>
<td>以输出方式打开一个二进制文件</td>
</tr>
</tbody></table>
<p>open() 函数如果打开失败则返回 0，也即 false，否则返回一个非零值。当然 ifstream 类和 ofstream 类中的构造函数中已经包含了 open() 函数的功能，因此为了方便，我们通常会在创建对象时就将参数列出，利用带参数的构造函数打开文件，本例中使用的就是这种方式。例如 <code>ifstream input(&quot;input.txt&quot;, ios::in );</code>，我们通常都会使用这种方式，因为这种方式方便。</p>
<h3 id="二进制文件读写操作"><a href="#二进制文件读写操作" class="headerlink" title="二进制文件读写操作"></a>二进制文件读写操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">3</span>][<span class="number">10</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> B[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            cout &lt;&lt; A[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//*******************************************</span></span><br><span class="line">    <span class="function">ofstream <span class="title">output</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!output) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Open output file error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    output.<span class="built_in">write</span>((<span class="keyword">char</span>*)A, <span class="built_in"><span class="keyword">sizeof</span></span>(A));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// output.write ( ( char * ) &amp; A [ i ][ j ], sizeof( A [ i ][ j ] )</span></span><br><span class="line">            <span class="comment">// );</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output.<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">//*******************************************</span></span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Open input file error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    input.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;B, <span class="built_in"><span class="keyword">sizeof</span></span>(B));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// input.read ( ( char * ) &amp; B[ i ][ j ], sizeof( B[ i ][ j ] ));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            cout &lt;&lt; B[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//*******************************************</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    input.<span class="built_in">seekg</span>(<span class="number">20</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), ios::beg);</span><br><span class="line">    input.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;temp, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    cout &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">    input.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统提供了一些操作文件读写指针位置的成员函数，我们可以使用这些函数，将文件读写指针移动到指定位置并操作其中的数据，具体函数见下表。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>gcount()</td>
<td>返回最后一次输入所读入的字节数</td>
</tr>
<tr>
<td>tellg()</td>
<td>返回输入指针的当前位置</td>
</tr>
<tr>
<td>seekg (文件中的位置)</td>
<td>将输入文件中指针移动到指定的位置</td>
</tr>
<tr>
<td>seekg (位移量， 参照位置)</td>
<td>以参照位置为标准移动指针</td>
</tr>
<tr>
<td>tellp()</td>
<td>返回输出文件指针当前位置</td>
</tr>
<tr>
<td>seekp (文件中的位置)</td>
<td>将输出文件中指针移动到指定的位置</td>
</tr>
<tr>
<td>seekp (位移量， 参照位置)</td>
<td>以参照位置为为标准移动指针</td>
</tr>
</tbody></table>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.weixueyuan.net/cpp/rumen/">C++ 入门教程</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>