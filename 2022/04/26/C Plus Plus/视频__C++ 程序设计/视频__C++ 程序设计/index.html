<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;初始化列表方案&quot;&gt;&lt;a href=&quot;#初始化列表方案&quot; class=&quot;headerlink&quot; title=&quot;初始化列表方案&quot;&gt;&lt;/a&gt;初始化列表方案&lt;/h2&gt;&lt;p&gt;c++ 使用 &lt;code&gt;&amp;#123;&amp;#125;&lt;/code&gt; 作为初始化的方案。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>C++ 程序设计 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/C-Plus-Plus/" rel="tag">C Plus Plus</a></div><div class="post-time">2022-04-26</div></div></div><div class="container post-header"><h1>C++ 程序设计</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%96%B9%E6%A1%88"><span class="toc-number">1.</span> <span class="toc-text">初始化列表方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">2.</span> <span class="toc-text">const与指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E5%92%8CC-%E5%AF%B9%E4%BA%8E%E5%B8%B8%E9%87%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A7%A3%E9%87%8A"><span class="toc-number">2.1.</span> <span class="toc-text">C和C++对于常量的不同解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%BC%BA%E8%BD%AC%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">指针类型强转的不安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E4%B8%AD%E7%9A%84const"><span class="toc-number">2.3.</span> <span class="toc-text">C中的const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8Cconst"><span class="toc-number">3.1.</span> <span class="toc-text">引用和const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">右值与右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">数组的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text">指针的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.</span> <span class="toc-text">指针和引用的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%98%AF%E6%8C%87%E9%92%88%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">3.6.</span> <span class="toc-text">引用是指针的语法糖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%83%BD%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E8%80%8CC%E4%B8%8D%E8%83%BD%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.</span> <span class="toc-text">C++能使用函数重载而C不能原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">5.</span> <span class="toc-text">函数模板的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null%E5%9C%A8C%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">null在C和C++的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template%E5%92%8Cusing%E7%BB%84%E5%90%88"><span class="toc-number">7.</span> <span class="toc-text">template和using组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8"><span class="toc-number">8.</span> <span class="toc-text">类的内存存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.1.</span> <span class="toc-text">类在编译时的加载顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%92%8C-C-%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">C 和 C++ 本质区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">9.1.</span> <span class="toc-text">构造函数的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">const 成员方法的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%9D%91"><span class="toc-number">10.</span> <span class="toc-text">构造函数和赋值拷贝函数使用浅拷贝的坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%B1%BB%E7%9A%84-6-%E4%B8%AA%E7%BC%BA%E7%9C%81%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">C++ 类的 6 个缺省函数</span></a></li></ol></details></div><div class="container post-content"><h2 id="初始化列表方案"><a href="#初始化列表方案" class="headerlink" title="初始化列表方案"></a>初始化列表方案</h2><p>c++ 使用 <code>&#123;&#125;</code> 作为初始化的方案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ar[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> br[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>* <span class="title">s</span><span class="params">(<span class="literal">NULL</span>)</span></span>;  <span class="comment">// 使用()作为初始化方案</span></span><br><span class="line">  <span class="keyword">double</span> dx&#123;<span class="number">12.23</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，<code>()</code> 也是可以作为初始化方案的，但是容易和函数调用混淆，所以不推荐。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// ok</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>;  <span class="comment">// 会被误以为是函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h2><h3 id="C和C-对于常量的不同解释"><a href="#C和C-对于常量的不同解释" class="headerlink" title="C和C++对于常量的不同解释"></a>C和C++对于常量的不同解释</h3><p>先看 C 的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 因为n是【常变量】，常变量也是变量，而数组的n必须是常量，所以error</span></span><br><span class="line">  <span class="keyword">int</span> ar[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">// error</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;n; <span class="comment">// 找出n对应的内存地址，然后指针类型强转（更改内存的解析方案)，解析出5，赋给p。</span></span><br><span class="line">  *p = <span class="number">100</span>; <span class="comment">// 更改p的指向，重新指向100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">  b = n;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(n,b,*p); <span class="comment">// 5 5 100</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看 C++ 的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ar[n] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">// cpp为了保证n的常性，在【编译期间】(不是预编译期间)就会将n直接替换成5.也就是说，在编译后，还没有执行的时候，这句代码就是int ar[5]=&#123;1,2,3,4,5&#125;;所以不会报错</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;n;</span><br><span class="line">  *p = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">  b = n;  <span class="comment">// 同理，这句代码其实是 拿5这个字面常量给b，也就是b=5;</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(n,b,*p); <span class="comment">// 5 5 100</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指针类型强转的不安全问题"><a href="#指针类型强转的不安全问题" class="headerlink" title="指针类型强转的不安全问题"></a>指针类型强转的不安全问题</h3><p><code>const int d = 4;</code> 中的 d 并不是完全不可修改的，可以使用 <code>指针类型强转</code> 来修改。当然，这种方式是不安全的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 普通的解引用修改变量值</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span>* p1 = &amp;a;</span><br><span class="line">  *p1 = <span class="number">200</span>  <span class="comment">// 此时a被修改成200</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 错误的解引用修改变量值</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">int</span>* p2 = &amp;b;  <span class="comment">// error,因为b是常变量，不可修改。而p2却可以通过解引用修改b值，这是不合理的。</span></span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// 正确的解引用修改变量值</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* p3 = &amp;c; <span class="comment">// ok，因为此时p3已经被封锁了解引用功能</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 不安全的解引用修改变量值</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span>* p4 = (<span class="keyword">int</span>*)&amp;b;  <span class="comment">// 指针类型强转</span></span><br><span class="line">  *p4 = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(b); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么理解 <code>int* p4 = (int*)&amp;b;</code>？</p>
<ul>
<li><code>&amp;b</code> 的类型为 <code>const int*</code>，之后我们使用 <code>(int*)</code>的指针类型强转，强制将 <code>const int*</code> 修改成 <code>int *</code>。</li>
<li><code>int* p2 = &amp;b;</code> 错误的原因也可以解释为：<code>&amp;b</code> 的指针类型是 <code>const int*</code>，我们却使用 <code>int *</code>类型的变量 p2 去接收，类型不匹配。</li>
</ul>
<h3 id="C中的const"><a href="#C中的const" class="headerlink" title="C中的const"></a>C中的const</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> ip = &amp;a;</span><br><span class="line">  </span><br><span class="line">  *ip = <span class="number">0x33333333</span>;  <span class="comment">// error</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0x98765432</span>;</span><br><span class="line">  ip = &amp;b            <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/const.drawio.png" alt="const.drawio"></p>
<p>根据上图，就可以解释下面代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* s = &amp;a;  <span class="comment">// 不能通过解引用修改a在内存地址中的值。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span>* p1 = s;             <span class="comment">// error。新建一个指针p1，该指针可以通过解引用修改内存地址中的值。这和【不能通过解引用修改a在内存地址中的值】的限制冲突</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* p2 = s;       <span class="comment">// ok</span></span><br><span class="line">  <span class="keyword">int</span>* <span class="keyword">const</span> p3 = s;       <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">const</span> *p4 = s; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span>* <span class="keyword">const</span> s = &amp;a;  <span class="comment">// 不能修改s在内存地址中的值。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span>* p1 = s;             <span class="comment">// ok。新建一个指针p1，其值为s（注意不是s的内存地址）。这和【不能修改s在内存地址中的值】这个限制不冲突</span></span><br><span class="line">  <span class="keyword">int</span>* p1 = &amp;s;            <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">int</span>* p1 = (<span class="keyword">int</span> *) &amp;s;    <span class="comment">// ok</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* p2 = s;       <span class="comment">// ok</span></span><br><span class="line">  <span class="keyword">int</span>* <span class="keyword">const</span> p3 = s;       <span class="comment">// ok</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p4 = s; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>利用没有空引用的特性，<strong>对比使用指针作为参数，使用引用作为参数可以不需要进行空指针判断</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用引用避免</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap_Int</span><span class="params">(<span class="keyword">int</span> *ap, <span class="keyword">int</span> *bp)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(ap != <span class="literal">NULL</span> &amp;&amp; bp != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">int</span> tmp = *ap;</span><br><span class="line">  *ap = *bp;</span><br><span class="line">  *bp = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">Swap</span>(a, b);</span><br><span class="line">  <span class="built_in">Swap_Int</span>(&amp;a, &amp;b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引用和const"><a href="#引用和const" class="headerlink" title="引用和const"></a>引用和const</h3><p>低层 const，常引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span>&amp; b = a;</span><br><span class="line">  b += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span>&amp; c = a;  <span class="comment">// 常引用</span></span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  c += <span class="number">100</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顶层 const：因为引用本身是不占内存空间的，所以顶层 const 没有太大意义，此 const 会自动被编译器忽略：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span>&amp; <span class="keyword">const</span> c = a; <span class="comment">// ok, 等同于 int &amp; c = a;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const 变量的引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span>&amp; x = a;  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> &amp;y = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="右值与右值引用"><a href="#右值与右值引用" class="headerlink" title="右值与右值引用"></a>右值与右值引用</h3><ul>
<li>左值：可以取地址的值</li>
<li>右值：无法取地址的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; a = <span class="number">10</span>; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b = <span class="number">10</span>;  <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值引用</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; r = <span class="number">10</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 可以认为右值引用是下面代码的语法糖：</span></span><br><span class="line"><span class="comment">// int tmp = 10;</span></span><br><span class="line"><span class="comment">// int &amp;r = tmp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; rc = a; <span class="comment">// error,因为c是左值</span></span><br></pre></td></tr></table></figure>



<h3 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> &amp;br[<span class="number">5</span>];   <span class="comment">// error</span></span><br><span class="line">  <span class="built_in"><span class="keyword">int</span></span> (&amp;cr)[<span class="number">5</span>]; <span class="comment">// ok，是数组的别名</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>int &amp;br[5];</code>：从右向左解释：</p>
<ol>
<li><code>br[5]</code>：是一个数组</li>
<li><code>&amp;br[5]</code>：数组的元素是一个引用</li>
<li><code>int &amp;br[5]</code>：数组的元素是一个整型类型的引用。</li>
</ol>
<p>引用是不开辟内存空间的，那又怎么能在数组的元素中存放呢？所以有问题。</p>
<p><code>int (&amp;cr)[5];</code>：先解释括号，从左向右解释：</p>
<ol>
<li><code>(&amp;cr)</code>：是一个引用。</li>
<li><code>(&amp;cr)[5]</code>：是一个数组的引用。</li>
<li><code>int (&amp;cr)[5]</code>：是一个整型类型数组的引用。</li>
</ol>
<h3 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> *ip = &amp;a;</span><br><span class="line">  <span class="keyword">int</span> *&amp;ps = ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ol>
<li>从语法规则上讲，指针变量存储某个实例（变量或对象）的地址，引用是某个实例的别名。</li>
<li>程序为指针变量分配内存区域，而不为引用分配内存区域。</li>
<li>解引用：指针使用时要在前加 <code>*</code>，引用可以直接使用。</li>
<li>指针变量的值可以发生改变，存储不同实例的地址，引用在定义时就被初始化，之后无法改变（不能是其他实例的引用）</li>
<li>指针变量的值可以为空（NULL）；没有空引用。</li>
<li>指针变量作为形参时需要测试它的合法性（判空NULL）；引用不需要判空</li>
<li>对指针变量使用 <code>sizeof</code> 得到的是指针变量的大小。对引用变量使用 <code>sizeof</code> 得到的是变量的大小</li>
<li>理论上指针的级数没有限制；但引用只有一级。即不存在引用的引用，但可以有指针的指针</li>
<li>对指针变量的操作，会使指针变量指向下一个实体（变量或对象）的地址；而不是改变所指实体（变量或对象）的内容。对引用的操作直接反应到所引用的实体（变量或对象）。</li>
</ol>
<h3 id="引用是指针的语法糖"><a href="#引用是指针的语法糖" class="headerlink" title="引用是指针的语法糖"></a>引用是指针的语法糖</h3><p>引用的本质：<strong>一个自身为常性的指针</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* ip = &amp;x;</span><br><span class="line">  x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span>&amp; b = a;</span><br><span class="line">  <span class="built_in">func</span>(a);</span><br><span class="line">  <span class="built_in">func</span>(b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过编译，上面代码变成如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* ip = x;</span><br><span class="line">  *x = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> * <span class="keyword">const</span> b = &amp;a;</span><br><span class="line">  <span class="built_in">func</span>(&amp;a);</span><br><span class="line">  <span class="built_in">func</span>(b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-能使用函数重载而C不能原因"><a href="#C-能使用函数重载而C不能原因" class="headerlink" title="C++能使用函数重载而C不能原因"></a>C++能使用函数重载而C不能原因</h2><p>C++ 使用了 <code>名字修饰</code>：C 或者 C++ 函数在内部(编译和链接)通过修饰名识别。修饰名是编译器在编译函数定义或者原型时生成的字符串。</p>
<p>在 C 中我们定义了以下的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_max</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面两个函数都会在编译期间加一个下划线，变成：</span></span><br><span class="line"><span class="keyword">int</span> _my_max(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">int</span> _my_max(<span class="keyword">char</span> a, <span class="keyword">char</span> b);</span><br></pre></td></tr></table></figure>

<p>如此一来，C 是无法区分出这两个函数的。</p>
<p>在 C++ 中，如果使用 <code>__cdecl</code> 调用，约定：</p>
<ul>
<li>以 <code>?</code> 标识函数名的开始，后跟函数名</li>
<li>函数名后面以 <code>@@YA</code> 标识参数表的开始，后跟参数表</li>
<li>参数表以代号表示</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在编译链接后，变成：</span></span><br><span class="line"><span class="keyword">int</span> ?my_max@@YAHHH@<span class="built_in">Z</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">int</span> ?my_max@@YANNN@<span class="built_in">Z</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br></pre></td></tr></table></figure>

<p>简单来说，C++能够重载函数的根本原因：<strong>将形参的类型作为函数名的一部分</strong>。</p>
<p>这也能解释为什么形参中的 <code>const</code> 是无效的，无法构成函数重载。因为 C++ 在编译链接期间，不会将 形参中的 const 作为函数名的一部分。</p>
<h2 id="函数模板的本质"><a href="#函数模板的本质" class="headerlink" title="函数模板的本质"></a>函数模板的本质</h2><p>函数模板的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;模板参数表&gt;</span><br><span class="line">返回类型 函数名(形参表) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">my_max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="built_in">my_max</span>(<span class="number">12</span>, <span class="number">23</span>);</span><br><span class="line">  <span class="keyword">char</span> y = <span class="built_in">my_max</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  <span class="keyword">double</span> z = <span class="built_in">my_max</span>(<span class="number">12.21</span>, <span class="number">23.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数模板的本质：<code>模板实参推演</code>。</p>
<p>代码在编译期间，其实就已经知道了调用这个函数的全部地方。根据实参的类型，我们就可以推演出即将调用这个函数的形参的所有的类型。然后根据这些类型，生成新的函数代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所以上面的函数模板就会生成三份的my_max</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T;</span><br><span class="line">T my_max&lt;<span class="keyword">int</span>&gt;(T a, T b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> T;</span><br><span class="line">T my_max&lt;<span class="keyword">char</span>&gt;(T a, T b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> T;</span><br><span class="line">T my_max&lt;<span class="keyword">double</span>&gt;(T a, T b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="null在C和C-的区别"><a href="#null在C和C-的区别" class="headerlink" title="null在C和C++的区别"></a>null在C和C++的区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NULL</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">define</span> NULL ((void*)0)</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 C 中，NULL 是将 0 地址转为空指针</li>
<li>在 C++ 中，NULL 是 0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">void</span> *vp = &amp;a;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> *ip = vp;   <span class="comment">// c中，将空指针赋给int*</span></span><br><span class="line">  <span class="keyword">char</span> *cp = vp;  <span class="comment">// c中，将空指针赋给char*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">void</span> *vp = &amp;a;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> *ip = (<span class="keyword">int</span>*) vp; <span class="comment">// c++更为严格，不允许空指针赋给int *，必须强转</span></span><br><span class="line">  <span class="keyword">char</span> *cp = (<span class="keyword">char</span>*) vp;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 所以，如果null还是((void*)0)的话，下面的代码是错误的,必须加上强转</span></span><br><span class="line">  <span class="keyword">int</span> *p = <span class="literal">NULL</span>;  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="literal">NULL</span>; <span class="comment">// ok</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 也就是说，我们赋值一个NULL给int*就很麻烦，为了保持 int *p = NULL;这种语法不变，就将NULL改成了0</span></span><br><span class="line">  <span class="keyword">char</span> *cp = <span class="literal">NULL</span>;  <span class="comment">// 等同于 char *cp = 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦 NULL 被设计成 0，问题又来了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>* a)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func(char* a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">0</span>);     <span class="comment">// func(int a)</span></span><br><span class="line">  <span class="built_in">func</span>(<span class="literal">NULL</span>);  <span class="comment">// func(int a)。发现不走func(char* a)这个函数。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，C++ 引入了 <code>指针空值常量(nullptr)</code>。</p>
<h2 id="template和using组合"><a href="#template和using组合" class="headerlink" title="template和using组合"></a>template和using组合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> pointer = _T*;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  pointer&lt;<span class="keyword">int</span>&gt; p = &amp;a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  pointer&lt;<span class="keyword">char</span>&gt; cp = &amp;ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类的内存存储"><a href="#类的内存存储" class="headerlink" title="类的内存存储"></a>类的内存存储</h2><p>一个 class 实例化出了多个实例对象，这些实例对象的属性都是不同的，但是方法却是相同的。所以我们抽象出一个 <code>公共代码区</code> 用于存放方法。</p>
<p>也即是说：为每个对象分配一个数据区；而代码区（存放成员函数的区域）为各对象类共用。</p>
<p>既然所有的对象都共用代码区的代码，那么如何区分是哪个对象调用了函数，答案就是：<code>this</code>。具体的方式就是：<strong>在编译成员方法的时候，编译器会自动添加一个 this 作为第一个参数。待对象调用该方法的时候，就会传递 this 给该方法</strong>。</p>
<p>其实这一点可以对比 python。python 在编写成员函数的时候，需要手动传入一个 self。</p>
<p>这是由于 python 是脚本语言，无法在编译期间自动加上 this 指针，所以需要我们在编写成员函数的时候自己加上去。但是哦我们依旧可以使用 <code>猴子补丁</code> 的方式添加、替换一个新的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, salary</span>):</span></span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span>(<span class="params">self</span>):</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount)</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_print</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">111</span>,self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_displayCount</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">222</span>,self.empCount)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 猴子补丁</span></span><br><span class="line">Employee.my_print = my_print</span><br><span class="line">Employee.displayCount = my_displayCount</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = Employee(<span class="string">&quot;XXX&quot;</span>,<span class="number">123123</span>)</span><br><span class="line">    a.my_print()  <span class="comment"># 111 XXX</span></span><br><span class="line">    a.displayCount() <span class="comment"># 222 1</span></span><br><span class="line">    Employee.displayEmployee(a) <span class="comment"># Name :  XXX , Salary:  123123</span></span><br></pre></td></tr></table></figure>

<p>由此观之，方法和函数其实本质上没有区别。具体的区别只有两个：</p>
<ul>
<li>方法的位于类的命名空间中，必须通过 <code>Employee.displayEmployee(a)</code> 或者 <code>a.my_print()</code> 才能调用。</li>
<li>方法的第一个参数是 tihs 指针。</li>
</ul>
<p>下面将介绍 C++ 是如何在编译类的时候为成员方法添加 this 指针的。</p>
<h3 id="类在编译时的加载顺序"><a href="#类在编译时的加载顺序" class="headerlink" title="类在编译时的加载顺序"></a>类在编译时的加载顺序</h3><ol>
<li>识别和记录类体中属性的名称，类型和访问限定，与属性在类体中的位置无关。</li>
<li>识别和记录类体中函数原型（返回类型+函数名+参数列表），形参的默认值，访问限定。不识别函数体</li>
<li>改写在类中定义函数的参数列表和函数体，改写对象调用成员函数的形式：+this；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Good</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">RegisterGoods</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在编译时，Good类会被改写成：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Good</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">RegisterGoods</span><span class="params">(Good* <span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-和-C-本质区别"><a href="#C-和-C-本质区别" class="headerlink" title="C 和 C++ 本质区别"></a>C 和 C++ 本质区别</h2><ul>
<li>C：有存储空间，即可操作(可读可写)</li>
<li>C++：有存储空间，不一定有对象。必须通过构造函数，在存储空间中创建对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c：有存储空间，即可操作。风险程序员自己承担。</span></span><br><span class="line"><span class="keyword">int</span> main &#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">// 有a对应的内存空间</span></span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">20</span>];  <span class="comment">// 有str对应的内存空间</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 我们可对a、str对应的内存空间进行任意的操作，包括危险操作，不合法操作等等，这一切都需要程序员自己控制。</span></span><br><span class="line">  <span class="keyword">new</span>(str) <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);   <span class="comment">// 明明已经给内存空间分配了数据，还是可以重新初始化</span></span><br><span class="line"> 	<span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;str[<span class="number">4</span>]; <span class="comment">// 就算内存空间储存的是char类型属性，我们还是可以强行解释为int类型，风险自己承担</span></span><br><span class="line">  *p = <span class="number">10</span>;   <span class="comment">// 强行修改内存空间的数据</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++：有存储空间，不一定有对象。必须通过构造函数，在存储空间中创建对象。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">int</span> real;</span><br><span class="line">  	<span class="keyword">int</span> image;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过构造函数，在存储空间中创建对象</span></span><br><span class="line">  Complex c1;</span><br><span class="line">  Complex c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造函数的本质"><a href="#构造函数的本质" class="headerlink" title="构造函数的本质"></a>构造函数的本质</h3><p>所以我们就知道了构造函数的本质：申请内存空间，然后在这个内存空间中创建对象，初始化对象的属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="keyword">int</span> real;</span><br><span class="line">  	<span class="keyword">int</span> image;</span><br><span class="line">  	<span class="built_in">Complex</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Complex c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数类似于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="keyword">int</span> real;</span><br><span class="line">  	<span class="keyword">int</span> image;</span><br><span class="line">  	<span class="built_in">Complex</span>(Complex c, real = <span class="number">0</span>, image = <span class="number">0</span>) &#123;</span><br><span class="line">      c.real = real;</span><br><span class="line">      c.image = image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Complex c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="const-成员方法的作用"><a href="#const-成员方法的作用" class="headerlink" title="const 成员方法的作用"></a>const 成员方法的作用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">int</span> real;</span><br><span class="line">  	<span class="keyword">int</span> image;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      cout &lt;&lt; read &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; image &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Complex ca&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> Complex cc&#123;<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  ca.<span class="built_in">Print</span>();  <span class="comment">// ok</span></span><br><span class="line">  cc.<span class="built_in">Print</span>();  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员方法在编译后就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">int</span> real;</span><br><span class="line">  	<span class="keyword">int</span> image;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Complex * <span class="keyword">const</span> <span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="keyword">this</span>-&gt;real &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;image &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Complex ca&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> Complex cc&#123;<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  Complex::<span class="built_in">Print</span>(&amp;ca);  <span class="comment">// ok</span></span><br><span class="line">  Complex::<span class="built_in">Print</span>(&amp;cc);  <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>&amp;cc</code> 的类型是 <code>const Complex * </code>，而 Print 的第一个参数类型是 <code>const Complex * const</code> ，类型不匹配。所以需要使用 <code>常方法</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">int</span> real;</span><br><span class="line">  	<span class="keyword">int</span> image;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      cout &lt;&lt; read &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; image &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后，变成：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">int</span> real;</span><br><span class="line">  	<span class="keyword">int</span> image;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> Complex * <span class="keyword">const</span> <span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="keyword">this</span>-&gt;read &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;image &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Complex cc&#123;<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  Complex::<span class="built_in">Print</span>(&amp;cc);  <span class="comment">// 类型匹配，ok</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="构造函数和赋值拷贝函数使用浅拷贝的坑"><a href="#构造函数和赋值拷贝函数使用浅拷贝的坑" class="headerlink" title="构造函数和赋值拷贝函数使用浅拷贝的坑"></a>构造函数和赋值拷贝函数使用浅拷贝的坑</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="comment">// 成员属性包含指针</span></span><br><span class="line">  	<span class="keyword">char</span> * str;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="comment">// good：构造函数为深拷贝</span></span><br><span class="line">  	<span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="literal">nullptr</span>): <span class="built_in">str</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(p) + <span class="number">1</span>;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        <span class="built_in">strcpy_s</span>(str, len, p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// bad: 赋值拷贝函数使用浅拷贝，此时被拷贝的对象和新建的对象指向同一个地址</span></span><br><span class="line">  	<span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; s) &#123;</span><br><span class="line">      str = s.str;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">      &#125;</span><br><span class="line">      str = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;zxc&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function">MuString <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">  s1.<span class="built_in">Print</span>();</span><br><span class="line">  s2.<span class="built_in">Print</span>();</span><br><span class="line">  <span class="function">MyString <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，赋值拷贝函数使用了浅拷贝，此时被拷贝的对象和新建的对象指向同一个地址。<strong>一旦有一个对象，则另一个对象也就同时不可使用了</strong>。必须改为深拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; s): <span class="built_in">str</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s.str) + <span class="number">1</span>;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        <span class="built_in">strcpy_s</span>(str, len, str);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果自定义类中，使用了指针，必须自定义 <code>构造函数</code> 和 <code>拷贝构造函数</code>，且必须使用 <code>深拷贝</code>。</p>
</blockquote>
<h2 id="C-类的-6-个缺省函数"><a href="#C-类的-6-个缺省函数" class="headerlink" title="C++ 类的 6 个缺省函数"></a>C++ 类的 6 个缺省函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="comment">// Int() &#123;&#125;                                     // 缺省的构造函数</span></span><br><span class="line">  	<span class="comment">// Int(const Int &amp;it):value(it.value) &#123;&#125;        // 缺省的赋值构造函数</span></span><br><span class="line">  	<span class="comment">// ~Int() &#123;&#125;                                    // 缺省的析构函数</span></span><br><span class="line">  	<span class="comment">// Int operator=() &#123;&#125;                           // 缺省的赋值函数</span></span><br><span class="line">  	<span class="comment">// Int* operator&amp;() &#123;return *this;&#125;             // 缺省的取地址函数</span></span><br><span class="line">  	<span class="comment">// const Int* operator&amp;() const &#123;return this;&#125;  // 缺省的取地址常函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>