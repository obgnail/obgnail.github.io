<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;认识-Shadowsocks&quot;&gt;&lt;a href=&quot;#认识-Shadowsocks&quot; class=&quot;headerlink&quot; title=&quot;认识 Shadowsocks&quot;&gt;&lt;/a&gt;认识 Shadowsocks&lt;/h2&gt;&lt;p&gt;Shadowsocks 是一个能骗过防火墙的网络代理工具。它把要传输的原数据经过加密后再传输，网络中的防火墙由于不知道要传输的原内容是什么而只好放行，于是就完成了防火墙穿透，也即是所谓的“翻墙”。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>你也能写个Shadowsocks | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-04-28</div></div></div><div class="container post-header"><h1>你也能写个Shadowsocks</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86-Shadowsocks"><span class="toc-number">1.</span> <span class="toc-text">认识 Shadowsocks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shadowsocks-%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">Shadowsocks 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ss-local"><span class="toc-number">2.1.</span> <span class="toc-text">ss-local</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ss-server"><span class="toc-number">2.2.</span> <span class="toc-text">ss-server</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shadowsocks-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.</span> <span class="toc-text">Shadowsocks 的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOCKS5-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.</span> <span class="toc-text">SOCKS5 协议介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.1.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.2.</span> <span class="toc-text">响应连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.3.</span> <span class="toc-text">和目标服务建立连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91"><span class="toc-number">4.4.</span> <span class="toc-text">数据转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH-%E4%BB%A3%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">SSH 代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSH-%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">SSH 代理机制介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8-SSH-%E4%BB%A3%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">为什么不使用 SSH 代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lightsocks-%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">Lightsocks 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%B7%B7%E6%B7%86"><span class="toc-number">6.1.</span> <span class="toc-text">实现数据混淆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-local-%E7%AB%AF"><span class="toc-number">6.2.</span> <span class="toc-text">实现 local 端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-server-%E7%AB%AF"><span class="toc-number">6.3.</span> <span class="toc-text">实现 server 端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="认识-Shadowsocks"><a href="#认识-Shadowsocks" class="headerlink" title="认识 Shadowsocks"></a>认识 Shadowsocks</h2><p>Shadowsocks 是一个能骗过防火墙的网络代理工具。它把要传输的原数据经过加密后再传输，网络中的防火墙由于不知道要传输的原内容是什么而只好放行，于是就完成了防火墙穿透，也即是所谓的“翻墙”。</p>
<p>在自由的网络环境下，在本机上访问服务时是直接和远程服务建立连接传输数据，流程如图：</p>
<p><img src="/images/32371367-8c231024-c05e-11e7-87a8-f977577a6b89.png" alt="自由网络环境下的传输流程"></p>
<p>但在受限的网络环境下会有防火墙，本机电脑和远程服务之间传输的数据都必须通过防火墙的检查，流程如图：</p>
<p><img src="/images/32371437-d8cb8852-c05e-11e7-9872-a6708bbe65ba.png" alt="受限网络环境下的传输流程"></p>
<p>如果防火墙发现你在传输受限的内容，就把拦截本次传输，就会导致在本机无法访问远程服务。</p>
<p>而 Shadowsocks 所做的就是把传输的数据加密，防火墙得到的数据是加密后的数据，防火墙不知道传输的原内容是什么，于是防火墙就放行本次请求，于是在本机就访问到了远程服务，流程如图：</p>
<p><img src="/images/32371932-cdc55044-c060-11e7-9b0e-c1a7fec2b428.png" alt="shadowsocks下的传输流程"></p>
<p>也就是说使用 Shadowsocks 的前提是：</p>
<ul>
<li>一台在防火墙之外的服务器；</li>
<li>在本机需要安装 Shadowsocks 本地端，用于加密传输数据；</li>
<li>服务器需要安装 Shadowsocks 服务端，用于解密加密后的传输数据，解密出原数据后发送到目标服务器。</li>
</ul>
<h2 id="Shadowsocks-原理"><a href="#Shadowsocks-原理" class="headerlink" title="Shadowsocks 原理"></a>Shadowsocks 原理</h2><p>Shadowsocks 由两部分组成，运行在本地的 ss-local 和运行在防火墙之外服务器上的 ss-server，下面来分别详细介绍它们的职责。</p>
<p><img src="/images/3a56e17b16d9aef7baf3b7c668eb883e.png" alt="img"></p>
<h3 id="ss-local"><a href="#ss-local" class="headerlink" title="ss-local"></a>ss-local</h3><p>ss-local 的职责是在本机启动和监听着一个服务，本地软件的网络请求都先发送到 ss-local，ss-local 收到来自本地软件的网络请求后，把要传输的原数据根据用户配置的加密方法和密码进行加密，再转发到墙外的服务器去。</p>
<h3 id="ss-server"><a href="#ss-server" class="headerlink" title="ss-server"></a>ss-server</h3><p>ss-server 的职责是在墙外服务器启动和监听一个服务，该服务监听来自本机的 ss-local 的请求。在收到来自 ss-local 转发过来的数据时，会先根据用户配置的加密方法和密码对数据进行对称解密，以获得加密后的数据的原内容。同时还会解 SOCKS5 协议，读出本次请求真正的目标服务地址 (例如 Google 服务器地址)，再把解密后得到的原数据转发到真正的目标服务。</p>
<p>当真正的目标服务返回了数据时，ss-server 端会把返回的数据加密后转发给对应的 ss-local 端，ss-local 端收到数据再解密后，转发给本机的软件。这是一个对称相反的过程。</p>
<p>由于 ss-local 和 ss-server 端都需要用对称加密算法对数据进行加密和解密，因此这两端的加密方法和密码必须配置为一样。Shadowsocks 提供了一系列标准可靠的对称算法可供用户选择，例如 rc4、aes、des、chacha20 等等。Shadowsocks 对数据加密后再传输的目的是为了混淆原数据，让途中的防火墙无法得出传输的原数据。但其实用这些安全性高计算量大的对称加密算法去实现混淆有点“杀鸡用牛刀”。</p>
<h2 id="Shadowsocks-的本质"><a href="#Shadowsocks-的本质" class="headerlink" title="Shadowsocks 的本质"></a>Shadowsocks 的本质</h2><p><strong>Shadowsocks 本质上是 SOCKS5 协议的加密版本</strong>，融合了代理控制和安全保证，可以选择多种加密和混淆方式，体积小、速度快、抗干扰能力强，不仅部署简单，而且对服务器的配置要求较低。</p>
<p>Shadowsocks 使用自行设计的协议进行加密通信，规避了早期 SSH 代理容易被注入并还原原始数据的问题，因此可以很好的保障通讯链路中的数据安全。</p>
<h2 id="SOCKS5-协议介绍"><a href="#SOCKS5-协议介绍" class="headerlink" title="SOCKS5 协议介绍"></a>SOCKS5 协议介绍</h2><p>Shadowsocks 的数据传输是建立在 SOCKS5 协议之上的，<strong>SOCKS5 是 TCP/IP 层面的网络代理协议</strong>。</p>
<p>ss-server 端解密出来的数据就是采用 SOCKS5 协议封装的，通过 SOCKS5 协议 ss-server 端能读出本机软件想访问的服务的真正地址以及要传输的原数据，下面来详细介绍 SOCKS5 协议的通信细节。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>客户端向服务端连接连接，客户端发送的数据包如下：</p>
<table>
<thead>
<tr>
<th align="left">VER</th>
<th align="left">NMETHODS</th>
<th align="left">METHODS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1 字节</td>
<td align="left">1 字节</td>
<td align="left">1 - 255 字节</td>
</tr>
</tbody></table>
<p>其中各个字段的含义如下：</p>
<ul>
<li><code>VER</code>：代表 SOCKS 的版本，SOCKS5 默认为 <code>0x05</code>，其固定长度为 1 个字节；</li>
<li><code>NMETHODS</code>：表示第三个字段 METHODS 的长度，它的长度也是 1 个字节；</li>
<li><code>METHODS</code>：表示客户端支持的验证方式，可以有多种，他的长度是 1-255 个字节。</li>
</ul>
<p>目前支持的验证方式共有：</p>
<ul>
<li><code>0x00</code>：NO AUTHENTICATION REQUIRED（不需要验证）</li>
<li><code>0x01</code>：GSSAPI</li>
<li><code>0x02</code>：USERNAME/PASSWORD（用户名密码）</li>
<li><code>0x03</code>: to X’7F’ IANA ASSIGNED</li>
<li><code>0x80</code>: to X’FE’ RESERVED FOR PRIVATE METHODS</li>
<li><code>0xFF</code>: NO ACCEPTABLE METHODS（都不支持，没法连接了）</li>
</ul>
<h3 id="响应连接"><a href="#响应连接" class="headerlink" title="响应连接"></a>响应连接</h3><p>服务端收到客户端的验证信息之后，就要回应客户端，服务端需要客户端提供哪种验证方式的信息。服务端回应的包格式如下：</p>
<table>
<thead>
<tr>
<th align="left">VER</th>
<th align="left">METHOD</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1 字节</td>
<td align="left">1 字节</td>
</tr>
</tbody></table>
<p>其中各个字段的含义如下：</p>
<ul>
<li><code>VER</code>：代表 SOCKS 的版本，SOCKS5 默认为 <code>0x05</code>，其固定长度为 1 个字节；</li>
<li><code>METHOD</code>：代表服务端需要客户端按此验证方式提供的验证信息，其值长度为 1 个字节，可为上面六种验证方式之一。</li>
</ul>
<p>举例说明，比如服务端不需要验证的话，可以这么回应客户端：</p>
<table>
<thead>
<tr>
<th align="left">VER</th>
<th align="left">METHOD</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0x05</code></td>
<td align="left"><code>0x00</code></td>
</tr>
</tbody></table>
<h3 id="和目标服务建立连接"><a href="#和目标服务建立连接" class="headerlink" title="和目标服务建立连接"></a>和目标服务建立连接</h3><p>客户端发起的连接由服务端验证通过后，客户端下一步应该告诉真正目标服务的地址给服务器，服务器得到地址后再去请求真正的目标服务。也就是说客户端需要把 Google 服务的地址 <code>google.com:80</code> 告诉服务端，服务端再去请求 <code>google.com:80</code>。<br>目标服务地址的格式为 (IP 或域名)+ 端口，客户端需要发送的包格式如下：</p>
<table>
<thead>
<tr>
<th align="left">VER</th>
<th align="left">CMD</th>
<th align="left">RSV</th>
<th align="left">ATYP</th>
<th align="left">DST.ADDR</th>
<th align="left">DST.PORT</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left"><code>0x00</code></td>
<td align="left">1</td>
<td align="left">Variable</td>
<td align="left">2</td>
</tr>
</tbody></table>
<p>各个字段的含义如下：</p>
<ul>
<li><code>VER</code>：代表 SOCKS 协议的版本，SOCKS 默认为 0x05，其值长度为 1 个字节；</li>
<li><code>CMD</code>：：代表客户端请求的类型，值长度也是 1 个字节，有三种类型；<ul>
<li><code>CONNECT</code>： <code>0x01</code>；</li>
<li><code>BIND</code>： <code>0x02</code>；</li>
<li><code>UDP</code>： ASSOCIATE <code>0x03</code>；</li>
</ul>
</li>
<li><code>RSV</code>：保留字，值长度为 1 个字节；</li>
<li><code>ATYP</code>：代表请求的远程服务器地址类型，值长度 1 个字节，有三种类型；<ul>
<li><code>IPV4</code>： address: <code>0x01</code>；</li>
<li><code>DOMAINNAME</code>: <code>0x03</code>；</li>
<li><code>IPV6</code>： address: <code>0x04</code>；</li>
</ul>
</li>
<li><code>DST.ADDR</code>：代表远程服务器的地址，根据 <code>ATYP</code> 进行解析，值长度不定；分别是 4 个字节的 IPv4 地址、1 个字节的域名长度和域名、16 个字节的 IPv4 地址；</li>
<li><code>DST.PORT</code>：代表远程服务器的端口，要访问哪个端口的意思，值长度 2 个字节。</li>
</ul>
<p>服务端在得到来自客户端告诉的目标服务地址后，便和目标服务进行连接，不管连接成功与否，服务器都应该把连接的结果告诉客户端。在连接成功的情况下，服务端返回的包格式如下：</p>
<table>
<thead>
<tr>
<th align="left">VER</th>
<th align="left">REP</th>
<th align="left">RSV</th>
<th align="left">ATYP</th>
<th align="left">BND.ADDR</th>
<th align="left">BND.PORT</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left"><code>0x00</code></td>
<td align="left">1</td>
<td align="left">Variable</td>
<td align="left">2</td>
</tr>
</tbody></table>
<p>各个字段的含义如下：</p>
<ul>
<li><code>VER</code>：代表 SOCKS 协议的版本，SOCKS 默认为 0x05，其值长度为 1 个字节；</li>
<li><code>REP</code>：代表响应状态码，值长度也是 1 个字节，有以下几种类型<ul>
<li><code>0x00</code> succeeded</li>
<li><code>0x01</code> general SOCKS server failure</li>
<li><code>0x02</code> connection not allowed by ruleset</li>
<li><code>0x03</code> Network unreachable</li>
<li><code>0x04</code> Host unreachable</li>
<li><code>0x05</code> Connection refused</li>
<li><code>0x06</code> TTL expired</li>
<li><code>0x07</code> Command not supported</li>
<li><code>0x08</code> Address type not supported</li>
<li><code>0x09</code> to <code>0xFF</code> unassigned</li>
</ul>
</li>
<li><code>RSV</code>：保留字，值长度为 1 个字节</li>
<li><code>ATYP</code>：代表请求的远程服务器地址类型，值长度 1 个字节，有三种类型<ul>
<li>IP V4 address： <code>0x01</code></li>
<li>DOMAINNAME： <code>0x03</code></li>
<li>IP V6 address： <code>0x04</code></li>
</ul>
</li>
<li><code>BND.ADDR</code>：表示绑定地址，值长度不定。</li>
<li><code>BND.PORT</code>： 表示绑定端口，值长度 2 个字节</li>
</ul>
<h3 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h3><p>客户端在收到来自服务器成功的响应后，就会开始发送数据了，服务端在收到来自客户端的数据后，会转发到目标服务。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SOCKS5 协议的目的其实就是为了把来自原本应该在本机直接请求目标服务的流程，放到了服务端去代理客户端访问。<br>其运行流程总结如下：</p>
<ol>
<li>本机和代理服务端协商和建立连接；</li>
<li>本机告诉代理服务端目标服务的地址；</li>
<li>代理服务端去连接目标服务，成功后告诉本机；</li>
<li>本机开始发送原本应发送到目标服务的数据给代理服务端，由代理服务端完成数据转发。</li>
</ol>
<h2 id="SSH-代理"><a href="#SSH-代理" class="headerlink" title="SSH 代理"></a>SSH 代理</h2><h3 id="SSH-代理机制介绍"><a href="#SSH-代理机制介绍" class="headerlink" title="SSH 代理机制介绍"></a>SSH 代理机制介绍</h3><p>SSH（Secure SHell）是一种在非安全网络环境中提供安全远程登录及其它安全网络服务的协议。OpenSSH 是 SSH 协议的免费开源实现，相比于 Telnet、rlogin 和 FTP 等明文传输协议，<strong>OpenSSH 会对所有流量（包括密码）进行加密</strong>，以有效的消除窃听、连接劫持和其他攻击。此外，OpenSSH 提供了安全的隧道功能和多种身份验证方法，并支持所有 SSH 协议版本。</p>
<h3 id="为什么不使用-SSH-代理"><a href="#为什么不使用-SSH-代理" class="headerlink" title="为什么不使用 SSH 代理"></a>为什么不使用 SSH 代理</h3><p>SSH 代理是通过 SSH 协议创建端到端安全的加密通道，进而能够基于 SOCKS 代理协议和端口转发功能实现代理服务。虽然 SSH 隧道中的数据安全性得到了保证，但由于创建隧道和数据传输过程中，SSH 协议本身的特征非常明显，所以容易被攻击者进行链路劫持，进而<strong>获取通讯原始数据</strong>。</p>
<p>Shadowsocks 是将 SOCKS5 客户端与服务端的连接提前到本地进行，Shadowsocks 客户端和服务端之间则利用基于<strong>预共享密钥机制</strong>（加密方式是预先约定好的，不需要进行协商）的多种加密算法，并参考 TOR 项目中的可插拔传输（Pluggable Transport，PT）技术对其进行二次混淆加密，很好的实现了去特征化，使得传输的流量全部加密且看起来只是普通的 TCP 或 UDP 数据包，从而能够进一步保证通讯数据的安全性。</p>
<h2 id="Lightsocks-实现"><a href="#Lightsocks-实现" class="headerlink" title="Lightsocks 实现"></a>Lightsocks 实现</h2><p>要实现 Lightsocks 需要实现两部分：运行在本地的 lightsocks-local，和运行在墙外代理服务器上 lightsocks-server。</p>
<h3 id="实现数据混淆"><a href="#实现数据混淆" class="headerlink" title="实现数据混淆"></a>实现数据混淆</h3><p>在 Shadowsocks 中是采用的标准的<strong>对称加密</strong>算法去实现数据混淆的，对称算法在加密和解密过程中需要大量计算。为了简单起见，Lightsocks 将采用最简单高效的方法去实现数据混淆，具体原理如下。</p>
<p>这个数据混淆算法和对称加密很相似，两端都需要有同样的密钥。这个密钥有如下要求：</p>
<ul>
<li>由 256 个 byte 组成，也就是一个数组，在 Golang 中类型表示为 <code>[256]byte</code>；</li>
<li>这个数组必须由 0～255 这 256 个数字组成，一个都不能差；</li>
<li>这个数组中第 <code>I</code> 个的值不能等于 <code>I</code>；</li>
</ul>
<p>例如以下为一个合法的密钥 (上为索引，下为值)：</p>
<table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
<th align="left">7</th>
<th align="left">8</th>
<th align="left">9</th>
<th align="left">10</th>
<th align="left">11</th>
<th align="left">12</th>
<th align="left">13</th>
<th align="left">14</th>
<th align="left">15</th>
<th align="left">16</th>
<th align="left">17</th>
<th align="left">18</th>
<th align="left">19</th>
<th align="left">20</th>
<th align="left">21</th>
<th align="left">22</th>
<th align="left">23</th>
<th align="left">24</th>
<th align="left">25</th>
<th align="left">26</th>
<th align="left">27</th>
<th align="left">28</th>
<th align="left">29</th>
<th align="left">30</th>
<th align="left">31</th>
<th align="left">32</th>
<th align="left">33</th>
<th align="left">34</th>
<th align="left">35</th>
<th align="left">36</th>
<th align="left">37</th>
<th align="left">38</th>
<th align="left">39</th>
<th align="left">40</th>
<th align="left">41</th>
<th align="left">42</th>
<th align="left">43</th>
<th align="left">44</th>
<th align="left">45</th>
<th align="left">46</th>
<th align="left">47</th>
<th align="left">48</th>
<th align="left">49</th>
<th align="left">50</th>
<th align="left">51</th>
<th align="left">52</th>
<th align="left">53</th>
<th align="left">54</th>
<th align="left">55</th>
<th align="left">56</th>
<th align="left">57</th>
<th align="left">58</th>
<th align="left">59</th>
<th align="left">60</th>
<th align="left">61</th>
<th align="left">62</th>
<th align="left">63</th>
<th align="left">64</th>
<th align="left">65</th>
<th align="left">66</th>
<th align="left">67</th>
<th align="left">68</th>
<th align="left">69</th>
<th align="left">70</th>
<th align="left">71</th>
<th align="left">72</th>
<th align="left">73</th>
<th align="left">74</th>
<th align="left">75</th>
<th align="left">76</th>
<th align="left">77</th>
<th align="left">78</th>
<th align="left">79</th>
<th align="left">80</th>
<th align="left">81</th>
<th align="left">82</th>
<th align="left">83</th>
<th align="left">84</th>
<th align="left">85</th>
<th align="left">86</th>
<th align="left">87</th>
<th align="left">88</th>
<th align="left">89</th>
<th align="left">90</th>
<th align="left">91</th>
<th align="left">92</th>
<th align="left">93</th>
<th align="left">94</th>
<th align="left">95</th>
<th align="left">96</th>
<th align="left">97</th>
<th align="left">98</th>
<th align="left">99</th>
<th align="left">100</th>
<th align="left">101</th>
<th align="left">102</th>
<th align="left">103</th>
<th align="left">104</th>
<th align="left">105</th>
<th align="left">106</th>
<th align="left">107</th>
<th align="left">108</th>
<th align="left">109</th>
<th align="left">110</th>
<th align="left">111</th>
<th align="left">112</th>
<th align="left">113</th>
<th align="left">114</th>
<th align="left">115</th>
<th align="left">116</th>
<th align="left">117</th>
<th align="left">118</th>
<th align="left">119</th>
<th align="left">120</th>
<th align="left">121</th>
<th align="left">122</th>
<th align="left">123</th>
<th align="left">124</th>
<th align="left">125</th>
<th align="left">126</th>
<th align="left">127</th>
<th align="left">128</th>
<th align="left">129</th>
<th align="left">130</th>
<th align="left">131</th>
<th align="left">132</th>
<th align="left">133</th>
<th align="left">134</th>
<th align="left">135</th>
<th align="left">136</th>
<th align="left">137</th>
<th align="left">138</th>
<th align="left">139</th>
<th align="left">140</th>
<th align="left">141</th>
<th align="left">142</th>
<th align="left">143</th>
<th align="left">144</th>
<th align="left">145</th>
<th align="left">146</th>
<th align="left">147</th>
<th align="left">148</th>
<th align="left">149</th>
<th align="left">150</th>
<th align="left">151</th>
<th align="left">152</th>
<th align="left">153</th>
<th align="left">154</th>
<th align="left">155</th>
<th align="left">156</th>
<th align="left">157</th>
<th align="left">158</th>
<th align="left">159</th>
<th align="left">160</th>
<th align="left">161</th>
<th align="left">162</th>
<th align="left">163</th>
<th align="left">164</th>
<th align="left">165</th>
<th align="left">166</th>
<th align="left">167</th>
<th align="left">168</th>
<th align="left">169</th>
<th align="left">170</th>
<th align="left">171</th>
<th align="left">172</th>
<th align="left">173</th>
<th align="left">174</th>
<th align="left">175</th>
<th align="left">176</th>
<th align="left">177</th>
<th align="left">178</th>
<th align="left">179</th>
<th align="left">180</th>
<th align="left">181</th>
<th align="left">182</th>
<th align="left">183</th>
<th align="left">184</th>
<th align="left">185</th>
<th align="left">186</th>
<th align="left">187</th>
<th align="left">188</th>
<th align="left">189</th>
<th align="left">190</th>
<th align="left">191</th>
<th align="left">192</th>
<th align="left">193</th>
<th align="left">194</th>
<th align="left">195</th>
<th align="left">196</th>
<th align="left">197</th>
<th align="left">198</th>
<th align="left">199</th>
<th align="left">200</th>
<th align="left">201</th>
<th align="left">202</th>
<th align="left">203</th>
<th align="left">204</th>
<th align="left">205</th>
<th align="left">206</th>
<th align="left">207</th>
<th align="left">208</th>
<th align="left">209</th>
<th align="left">210</th>
<th align="left">211</th>
<th align="left">212</th>
<th align="left">213</th>
<th align="left">214</th>
<th align="left">215</th>
<th align="left">216</th>
<th align="left">217</th>
<th align="left">218</th>
<th align="left">219</th>
<th align="left">220</th>
<th align="left">221</th>
<th align="left">222</th>
<th align="left">223</th>
<th align="left">224</th>
<th align="left">225</th>
<th align="left">226</th>
<th align="left">227</th>
<th align="left">228</th>
<th align="left">229</th>
<th align="left">230</th>
<th align="left">231</th>
<th align="left">232</th>
<th align="left">233</th>
<th align="left">234</th>
<th align="left">235</th>
<th align="left">236</th>
<th align="left">237</th>
<th align="left">238</th>
<th align="left">239</th>
<th align="left">240</th>
<th align="left">241</th>
<th align="left">242</th>
<th align="left">243</th>
<th align="left">244</th>
<th align="left">245</th>
<th align="left">246</th>
<th align="left">247</th>
<th align="left">248</th>
<th align="left">249</th>
<th align="left">250</th>
<th align="left">251</th>
<th align="left">252</th>
<th align="left">253</th>
<th align="left">254</th>
<th align="left">255</th>
</tr>
</thead>
<tbody><tr>
<td align="left">186</td>
<td align="left">118</td>
<td align="left">82</td>
<td align="left">201</td>
<td align="left">235</td>
<td align="left">236</td>
<td align="left">180</td>
<td align="left">66</td>
<td align="left">228</td>
<td align="left">96</td>
<td align="left">43</td>
<td align="left">90</td>
<td align="left">203</td>
<td align="left">200</td>
<td align="left">34</td>
<td align="left">104</td>
<td align="left">41</td>
<td align="left">222</td>
<td align="left">165</td>
<td align="left">74</td>
<td align="left">240</td>
<td align="left">20</td>
<td align="left">244</td>
<td align="left">67</td>
<td align="left">114</td>
<td align="left">191</td>
<td align="left">220</td>
<td align="left">147</td>
<td align="left">196</td>
<td align="left">183</td>
<td align="left">229</td>
<td align="left">123</td>
<td align="left">208</td>
<td align="left">19</td>
<td align="left">127</td>
<td align="left">187</td>
<td align="left">84</td>
<td align="left">148</td>
<td align="left">56</td>
<td align="left">170</td>
<td align="left">133</td>
<td align="left">160</td>
<td align="left">202</td>
<td align="left">21</td>
<td align="left">53</td>
<td align="left">78</td>
<td align="left">59</td>
<td align="left">64</td>
<td align="left">120</td>
<td align="left">27</td>
<td align="left">167</td>
<td align="left">175</td>
<td align="left">39</td>
<td align="left">10</td>
<td align="left">4</td>
<td align="left">132</td>
<td align="left">89</td>
<td align="left">230</td>
<td align="left">152</td>
<td align="left">73</td>
<td align="left">221</td>
<td align="left">88</td>
<td align="left">141</td>
<td align="left">158</td>
<td align="left">251</td>
<td align="left">79</td>
<td align="left">225</td>
<td align="left">87</td>
<td align="left">14</td>
<td align="left">23</td>
<td align="left">68</td>
<td align="left">250</td>
<td align="left">199</td>
<td align="left">168</td>
<td align="left">218</td>
<td align="left">60</td>
<td align="left">40</td>
<td align="left">169</td>
<td align="left">75</td>
<td align="left">86</td>
<td align="left">153</td>
<td align="left">134</td>
<td align="left">83</td>
<td align="left">49</td>
<td align="left">128</td>
<td align="left">231</td>
<td align="left">217</td>
<td align="left">239</td>
<td align="left">226</td>
<td align="left">177</td>
<td align="left">57</td>
<td align="left">24</td>
<td align="left">234</td>
<td align="left">63</td>
<td align="left">7</td>
<td align="left">112</td>
<td align="left">166</td>
<td align="left">211</td>
<td align="left">254</td>
<td align="left">179</td>
<td align="left">157</td>
<td align="left">215</td>
<td align="left">227</td>
<td align="left">224</td>
<td align="left">233</td>
<td align="left">81</td>
<td align="left">172</td>
<td align="left">26</td>
<td align="left">122</td>
<td align="left">219</td>
<td align="left">48</td>
<td align="left">151</td>
<td align="left">232</td>
<td align="left">50</td>
<td align="left">108</td>
<td align="left">44</td>
<td align="left">0</td>
<td align="left">192</td>
<td align="left">65</td>
<td align="left">76</td>
<td align="left">109</td>
<td align="left">252</td>
<td align="left">248</td>
<td align="left">47</td>
<td align="left">154</td>
<td align="left">33</td>
<td align="left">209</td>
<td align="left">115</td>
<td align="left">31</td>
<td align="left">15</td>
<td align="left">45</td>
<td align="left">206</td>
<td align="left">247</td>
<td align="left">124</td>
<td align="left">77</td>
<td align="left">8</td>
<td align="left">182</td>
<td align="left">144</td>
<td align="left">1</td>
<td align="left">72</td>
<td align="left">131</td>
<td align="left">52</td>
<td align="left">245</td>
<td align="left">198</td>
<td align="left">238</td>
<td align="left">5</td>
<td align="left">188</td>
<td align="left">116</td>
<td align="left">55</td>
<td align="left">216</td>
<td align="left">155</td>
<td align="left">2</td>
<td align="left">178</td>
<td align="left">189</td>
<td align="left">162</td>
<td align="left">136</td>
<td align="left">243</td>
<td align="left">184</td>
<td align="left">58</td>
<td align="left">69</td>
<td align="left">70</td>
<td align="left">99</td>
<td align="left">36</td>
<td align="left">25</td>
<td align="left">35</td>
<td align="left">174</td>
<td align="left">195</td>
<td align="left">18</td>
<td align="left">205</td>
<td align="left">30</td>
<td align="left">190</td>
<td align="left">142</td>
<td align="left">210</td>
<td align="left">113</td>
<td align="left">145</td>
<td align="left">101</td>
<td align="left">97</td>
<td align="left">161</td>
<td align="left">100</td>
<td align="left">91</td>
<td align="left">242</td>
<td align="left">138</td>
<td align="left">93</td>
<td align="left">171</td>
<td align="left">98</td>
<td align="left">237</td>
<td align="left">212</td>
<td align="left">255</td>
<td align="left">80</td>
<td align="left">102</td>
<td align="left">119</td>
<td align="left">204</td>
<td align="left">107</td>
<td align="left">105</td>
<td align="left">111</td>
<td align="left">11</td>
<td align="left">29</td>
<td align="left">146</td>
<td align="left">129</td>
<td align="left">117</td>
<td align="left">135</td>
<td align="left">176</td>
<td align="left">163</td>
<td align="left">207</td>
<td align="left">103</td>
<td align="left">22</td>
<td align="left">246</td>
<td align="left">125</td>
<td align="left">150</td>
<td align="left">106</td>
<td align="left">126</td>
<td align="left">197</td>
<td align="left">249</td>
<td align="left">62</td>
<td align="left">51</td>
<td align="left">193</td>
<td align="left">32</td>
<td align="left">3</td>
<td align="left">110</td>
<td align="left">46</td>
<td align="left">85</td>
<td align="left">71</td>
<td align="left">159</td>
<td align="left">139</td>
<td align="left">12</td>
<td align="left">164</td>
<td align="left">95</td>
<td align="left">121</td>
<td align="left">140</td>
<td align="left">241</td>
<td align="left">253</td>
<td align="left">130</td>
<td align="left">173</td>
<td align="left">213</td>
<td align="left">54</td>
<td align="left">143</td>
<td align="left">16</td>
<td align="left">94</td>
<td align="left">9</td>
<td align="left">61</td>
<td align="left">156</td>
<td align="left">214</td>
<td align="left">28</td>
<td align="left">17</td>
<td align="left">37</td>
<td align="left">42</td>
<td align="left">181</td>
<td align="left">149</td>
<td align="left">185</td>
<td align="left">223</td>
<td align="left">92</td>
<td align="left">38</td>
<td align="left">13</td>
<td align="left">194</td>
<td align="left">6</td>
<td align="left">137</td>
</tr>
</tbody></table>
<p>如果原数据为 <code>[5,0,1,2,3]</code>，则采用以上密钥加密后变成 <code>[236,186,118,82,201]</code>。如果加密后的数据为 <code>[186,118,82,201,235]</code>，则采用以上密钥解密得到的原数据为 <code>[0,1,2,3,4]</code></p>
<p>聪明的你肯定看懂了其中的规律：把 1～255 这 256 个数字确定一种一对一的映射关系，加密是从一个数字得到对应的一个数字，而解密则是反向的过程，而这个密钥的作用正是描述这个映射关系。这其实就是中学学的<strong>反函数</strong>。</p>
<p>为什么要这样设计数据混淆算法呢？在数据传输时，数据是以 byte 为最小单位流式传输的。一个 byte 的取值只可能是 0～255。该混淆算法可以直接对一个个 byte 进行加解密，而无需像标准的对称算法那样只能对一大块数据进行加密。再加上本算法的加解密 N byte 数据的算法复杂度为 N（直接通过数组索引访问），非常适合流式加密。</p>
<p>以上加密算法虽然破绽很多，但足以实现高效的数据混淆，骗过防火墙。</p>
<p>目前采用对称加密算法实现数据混淆的 Shadowsocks 已经能被一些防火墙通过机器学习算法通过特征分析识别出传输的原内容适合合法，而 Lightsocks 的这套混淆算法目前还不能被轻易的识别出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机产生一个以上密钥匙</span></span><br><span class="line"><span class="keyword">package</span> core</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> PasswordLength = <span class="number">256</span></span><br><span class="line"><span class="keyword">type</span> Password [PasswordLength]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 更新随机种子，防止生成一样的随机密码</span></span><br><span class="line">	rand.Seed(time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生 256个byte随机组合的 密码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandPassword</span><span class="params">()</span> *<span class="title">Password</span></span> &#123;</span><br><span class="line">	<span class="comment">// 随机生成一个由  0~255 组成的 byte 数组</span></span><br><span class="line">	intArr := rand.Perm(PasswordLength)</span><br><span class="line">	password := &amp;Password&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> intArr &#123;</span><br><span class="line">		password[i] = <span class="keyword">byte</span>(v)</span><br><span class="line">		<span class="keyword">if</span> i == v &#123;</span><br><span class="line">			<span class="comment">// 确保不会出现如何一个byte位出现重复</span></span><br><span class="line">			<span class="keyword">return</span> RandPassword()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> password</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对数据进行加密解密</span></span><br><span class="line"><span class="keyword">package</span> core</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cipher <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 编码用的密码</span></span><br><span class="line">	encodePassword *Password</span><br><span class="line">	<span class="comment">// 解码用的密码</span></span><br><span class="line">	decodePassword *Password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cipher *Cipher)</span> <span class="title">encode</span><span class="params">(bs []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> bs &#123;</span><br><span class="line">		bs[i] = cipher.encodePassword[v]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码加密后的数据到原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cipher *Cipher)</span> <span class="title">decode</span><span class="params">(bs []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> bs &#123;</span><br><span class="line">		bs[i] = cipher.decodePassword[v]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个编码解码器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(encodePassword *Password)</span> *<span class="title">Cipher</span></span> &#123;</span><br><span class="line">	decodePassword := &amp;Password&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> encodePassword &#123;</span><br><span class="line">		encodePassword[i] = v</span><br><span class="line">		decodePassword[v] = <span class="keyword">byte</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Cipher&#123;</span><br><span class="line">		encodePassword: encodePassword,</span><br><span class="line">		decodePassword: decodePassword,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 再使用以上的 Cipher 去封装一个加密传输的 SecureSocket，以方便直接加解密 TCP Socket 中的流式数据</span></span><br><span class="line"><span class="keyword">package</span> core</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	BufSize = <span class="number">1024</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密传输的 TCP Socket</span></span><br><span class="line"><span class="keyword">type</span> SecureSocket <span class="keyword">struct</span> &#123;</span><br><span class="line">	Cipher     *Cipher</span><br><span class="line">	ListenAddr *net.TCPAddr</span><br><span class="line">	RemoteAddr *net.TCPAddr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从输入流里读取加密过的数据，解密后把原数据放到bs里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(secureSocket *SecureSocket)</span> <span class="title">DecodeRead</span><span class="params">(conn *net.TCPConn, bs []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	n, err = conn.Read(bs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	secureSocket.Cipher.decode(bs[:n])</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把放在bs里的数据加密后立即全部写入输出流</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(secureSocket *SecureSocket)</span> <span class="title">EncodeWrite</span><span class="params">(conn *net.TCPConn, bs []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	secureSocket.Cipher.encode(bs)</span><br><span class="line">	<span class="keyword">return</span> conn.Write(bs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从src中源源不断的读取原数据加密后写入到dst，直到src中没有数据可以再读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(secureSocket *SecureSocket)</span> <span class="title">EncodeCopy</span><span class="params">(dst *net.TCPConn, src *net.TCPConn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, BufSize)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		readCount, errRead := src.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> errRead != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> errRead != io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span> errRead</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> readCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">			writeCount, errWrite := secureSocket.EncodeWrite(dst, buf[<span class="number">0</span>:readCount])</span><br><span class="line">			<span class="keyword">if</span> errWrite != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errWrite</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> readCount != writeCount &#123;</span><br><span class="line">				<span class="keyword">return</span> io.ErrShortWrite</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从src中源源不断的读取加密后的数据解密后写入到dst，直到src中没有数据可以再读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(secureSocket *SecureSocket)</span> <span class="title">DecodeCopy</span><span class="params">(dst *net.TCPConn, src *net.TCPConn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, BufSize)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		readCount, errRead := secureSocket.DecodeRead(src, buf)</span><br><span class="line">		<span class="keyword">if</span> errRead != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> errRead != io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span> errRead</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> readCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">			writeCount, errWrite := dst.Write(buf[<span class="number">0</span>:readCount])</span><br><span class="line">			<span class="keyword">if</span> errWrite != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errWrite</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> readCount != writeCount &#123;</span><br><span class="line">				<span class="keyword">return</span> io.ErrShortWrite</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和远程的socket建立连接，他们之间的数据传输会加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(secureSocket *SecureSocket)</span> <span class="title">DialRemote</span><span class="params">()</span> <span class="params">(*net.TCPConn, error)</span></span> &#123;</span><br><span class="line">	remoteConn, err := net.DialTCP(<span class="string">&quot;tcp&quot;</span>, <span class="literal">nil</span>, secureSocket.RemoteAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;连接到远程服务器 %s 失败:%s&quot;</span>, secureSocket.RemoteAddr, err))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> remoteConn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 SecureSocket 用于 local 端和 server 端之间进行 TCP 通信，并且只使用 SecureSocket 通信时中间传输的数据会被加密，防火墙无法读到原数据。</p>
<h3 id="实现-local-端"><a href="#实现-local-端" class="headerlink" title="实现 local 端"></a>实现 local 端</h3><p>运行在本机的 local 端的职责是把本机程序发送给它的数据经过加密后转发给墙外的代理服务器，总体工作流程如下：</p>
<ol>
<li>监听来自本机浏览器的代理请求；</li>
<li>转发前加密数据；</li>
<li>转发 socket 数据到墙外代理服务端；</li>
<li>把服务端返回的数据转发给用户的浏览器。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现以上功能的 local 端</span></span><br><span class="line"><span class="keyword">package</span> local</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gwuhaolin/lightsocks/core&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LsLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">	*core.SecureSocket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个本地端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(password *core.Password, listenAddr, remoteAddr *net.TCPAddr)</span> *<span class="title">LsLocal</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;LsLocal&#123;</span><br><span class="line">		SecureSocket: &amp;core.SecureSocket&#123;</span><br><span class="line">			Cipher:     core.NewCipher(password),</span><br><span class="line">			ListenAddr: listenAddr,</span><br><span class="line">			RemoteAddr: remoteAddr,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地端启动监听，接收来自本机浏览器的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(local *LsLocal)</span> <span class="title">Listen</span><span class="params">(didListen <span class="keyword">func</span>(listenAddr net.Addr)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	listener, err := net.ListenTCP(<span class="string">&quot;tcp&quot;</span>, local.ListenAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> didListen != <span class="literal">nil</span> &#123;</span><br><span class="line">		didListen(listener.Addr())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		userConn, err := listener.AcceptTCP()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// userConn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class="line">		userConn.SetLinger(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">go</span> local.handleConn(userConn)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(local *LsLocal)</span> <span class="title">handleConn</span><span class="params">(userConn *net.TCPConn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> userConn.Close()</span><br><span class="line"></span><br><span class="line">	proxyServer, err := local.DialRemote()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> proxyServer.Close()</span><br><span class="line">	<span class="comment">// Conn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class="line">	proxyServer.SetLinger(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行转发</span></span><br><span class="line">	<span class="comment">// 从 proxyServer 读取数据发送到 localUser</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := local.DecodeCopy(userConn, proxyServer)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作</span></span><br><span class="line">			userConn.Close()</span><br><span class="line">			proxyServer.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 从 localUser 发送数据发送到 proxyServer，这里因为处在翻墙阶段出现网络错误的概率更大</span></span><br><span class="line">	local.EncodeCopy(proxyServer, userConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现-server-端"><a href="#实现-server-端" class="headerlink" title="实现 server 端"></a>实现 server 端</h3><p>运行在墙外代理服务器的 server 端职责如下：</p>
<ol>
<li>监听来自本地代理客户端的请求；</li>
<li>解密本地代理客户端请求的数据，解析 SOCKS5 协议，连接用户浏览器真正想要连接的远程服务器；</li>
<li>转发用户浏览器真正想要连接的远程服务器返回的数据的加密后的内容到本地代理客户端。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gwuhaolin/lightsocks/core&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LsServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*core.SecureSocket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个服务端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(password *core.Password, listenAddr *net.TCPAddr)</span> *<span class="title">LsServer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;LsServer&#123;</span><br><span class="line">		SecureSocket: &amp;core.SecureSocket&#123;</span><br><span class="line">			Cipher:     core.NewCipher(password),</span><br><span class="line">			ListenAddr: listenAddr,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行服务端并且监听来自本地代理客户端的请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lsServer *LsServer)</span> <span class="title">Listen</span><span class="params">(didListen <span class="keyword">func</span>(listenAddr net.Addr)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	listener, err := net.ListenTCP(<span class="string">&quot;tcp&quot;</span>, lsServer.ListenAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> didListen != <span class="literal">nil</span> &#123;</span><br><span class="line">		didListen(listener.Addr())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		localConn, err := listener.AcceptTCP()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// localConn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class="line">		localConn.SetLinger(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">go</span> lsServer.handleConn(localConn)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解 SOCKS5 协议</span></span><br><span class="line"><span class="comment">// https://www.ietf.org/rfc/rfc1928.txt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lsServer *LsServer)</span> <span class="title">handleConn</span><span class="params">(localConn *net.TCPConn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> localConn.Close()</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	   The localConn connects to the dstServer, and sends a ver</span></span><br><span class="line"><span class="comment">	   identifier/method selection message:</span></span><br><span class="line"><span class="comment">		          +----+----------+----------+</span></span><br><span class="line"><span class="comment">		          |VER | NMETHODS | METHODS  |</span></span><br><span class="line"><span class="comment">		          +----+----------+----------+</span></span><br><span class="line"><span class="comment">		          | 1  |    1     | 1 to 255 |</span></span><br><span class="line"><span class="comment">		          +----+----------+----------+</span></span><br><span class="line"><span class="comment">	   The VER field is set to X&#x27;05&#x27; for this ver of the protocol.  The</span></span><br><span class="line"><span class="comment">	   NMETHODS field contains the number of method identifier octets that</span></span><br><span class="line"><span class="comment">	   appear in the METHODS field.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 第一个字段VER代表Socks的版本，Socks5默认为0x05，其固定长度为1个字节</span></span><br><span class="line">	_, err := lsServer.DecodeRead(localConn, buf)</span><br><span class="line">	<span class="comment">// 只支持版本5</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || buf[<span class="number">0</span>] != <span class="number">0x05</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	   The dstServer selects from one of the methods given in METHODS, and</span></span><br><span class="line"><span class="comment">	   sends a METHOD selection message:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		          +----+--------+</span></span><br><span class="line"><span class="comment">		          |VER | METHOD |</span></span><br><span class="line"><span class="comment">		          +----+--------+</span></span><br><span class="line"><span class="comment">		          | 1  |   1    |</span></span><br><span class="line"><span class="comment">		          +----+--------+</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 不需要验证，直接验证通过</span></span><br><span class="line">	lsServer.EncodeWrite(localConn, []<span class="keyword">byte</span>&#123;<span class="number">0x05</span>, <span class="number">0x00</span>&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		          +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">		          |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span></span><br><span class="line"><span class="comment">		          +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">		          | 1  |  1  | X&#x27;00&#x27; |  1   | Variable |    2     |</span></span><br><span class="line"><span class="comment">		          +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取真正的远程服务的地址</span></span><br><span class="line">	n, err := lsServer.DecodeRead(localConn, buf)</span><br><span class="line">	<span class="comment">// n 最短的长度为7 情况为 ATYP=3 DST.ADDR占用1字节 值为0x0</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || n &lt; <span class="number">7</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CMD代表客户端请求的类型，值长度也是1个字节，有三种类型</span></span><br><span class="line">	<span class="comment">// CONNECT X&#x27;01&#x27;</span></span><br><span class="line">	<span class="keyword">if</span> buf[<span class="number">1</span>] != <span class="number">0x01</span> &#123;</span><br><span class="line">		<span class="comment">// 目前只支持 CONNECT</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> dIP []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">// aType 代表请求的远程服务器地址类型，值长度1个字节，有三种类型</span></span><br><span class="line">	<span class="keyword">switch</span> buf[<span class="number">3</span>] &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x01</span>:</span><br><span class="line">		<span class="comment">//	IP V4 address: X&#x27;01&#x27;</span></span><br><span class="line">		dIP = buf[<span class="number">4</span> : <span class="number">4</span>+net.IPv4len]</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x03</span>:</span><br><span class="line">		<span class="comment">//	DOMAINNAME: X&#x27;03&#x27;</span></span><br><span class="line">		ipAddr, err := net.ResolveIPAddr(<span class="string">&quot;ip&quot;</span>, <span class="keyword">string</span>(buf[<span class="number">5</span>:n<span class="number">-2</span>]))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		dIP = ipAddr.IP</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x04</span>:</span><br><span class="line">		<span class="comment">//	IP V6 address: X&#x27;04&#x27;</span></span><br><span class="line">		dIP = buf[<span class="number">4</span> : <span class="number">4</span>+net.IPv6len]</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	dPort := buf[n<span class="number">-2</span>:]</span><br><span class="line">	dstAddr := &amp;net.TCPAddr&#123;</span><br><span class="line">		IP:   dIP,</span><br><span class="line">		Port: <span class="keyword">int</span>(binary.BigEndian.Uint16(dPort)),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接真正的远程服务</span></span><br><span class="line">	dstServer, err := net.DialTCP(<span class="string">&quot;tcp&quot;</span>, <span class="literal">nil</span>, dstAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> dstServer.Close()</span><br><span class="line">		<span class="comment">// Conn被关闭时直接清除所有数据 不管没有发送的数据</span></span><br><span class="line">		dstServer.SetLinger(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 响应客户端连接成功</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		          +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">		          |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |</span></span><br><span class="line"><span class="comment">		          +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">		          | 1  |  1  | X&#x27;00&#x27; |  1   | Variable |    2     |</span></span><br><span class="line"><span class="comment">		          +----+-----+-------+------+----------+----------+</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">// 响应客户端连接成功</span></span><br><span class="line">		lsServer.EncodeWrite(localConn, []<span class="keyword">byte</span>&#123;<span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行转发</span></span><br><span class="line">	<span class="comment">// 从 localUser 读取数据发送到 dstServer</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := lsServer.DecodeCopy(dstServer, localConn)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 在 copy 的过程中可能会存在网络超时等 error 被 return，只要有一个发生了错误就退出本次工作</span></span><br><span class="line">			localConn.Close()</span><br><span class="line">			dstServer.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 从 dstServer 读取数据发送到 localUser，这里因为处在翻墙阶段出现网络错误的概率更大</span></span><br><span class="line">	lsServer.EncodeCopy(localConn, dstServer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是实现一个轻量级 Shadowsocks 的核心代码。其它一些零碎的代码，例如启动入口、配置读写等，可以去 <a target="_blank" rel="noopener" href="https://github.com/gwuhaolin/lightsocks">lightsocks</a> 项目中阅读完整代码。</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://wuhaolin.cn/2017/11/03/%E4%BD%A0%E4%B9%9F%E8%83%BD%E5%86%99%E4%B8%AA%20Shadowsocks/">你也能写个 Shadowsocks</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/shadowsocks/shadowsocks-go">shadowsocks-go</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/gwuhaolin/lightsocks">lightsocks</a></li>
<li><a target="_blank" rel="noopener" href="https://www.secrss.com/articles/18469">Shadowsocks 基于二次混淆加密传输的数据保密性原理分析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ietf.org/rfc/rfc1928.txt">SOCKS5 协议规范 rfc1928</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>