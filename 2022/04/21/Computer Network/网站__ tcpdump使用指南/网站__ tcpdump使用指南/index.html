<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;tcpdump核心参数图解&quot;&gt;&lt;a href=&quot;#tcpdump核心参数图解&quot; class=&quot;headerlink&quot; title=&quot;tcpdump核心参数图解&quot;&gt;&lt;/a&gt;tcpdump核心参数图解&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/image-20220421105202058.png&quot; alt=&quot;image-20220421105202058&quot;&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>tcpdump使用指南 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Computer-Network/" rel="tag">Computer Network</a></div><div class="post-time">2022-04-21</div></div></div><div class="container post-header"><h1>tcpdump使用指南</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpdump%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">tcpdump核心参数图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3tcpdump%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-number">2.</span> <span class="toc-text">理解tcpdump的输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">输出内容结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flags-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">Flags 标识符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99"><span class="toc-number">3.</span> <span class="toc-text">常规过滤规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-IP-%E5%9C%B0%E5%9D%80%E8%BF%87%E6%BB%A4%EF%BC%9Ahost"><span class="toc-number">3.1.</span> <span class="toc-text">基于 IP 地址过滤：host</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BD%91%E6%AE%B5%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%EF%BC%9Anet"><span class="toc-number">3.2.</span> <span class="toc-text">基于网段进行过滤：net</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%EF%BC%9Aport"><span class="toc-number">3.3.</span> <span class="toc-text">基于端口进行过滤：port</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%EF%BC%9Aproto"><span class="toc-number">3.4.</span> <span class="toc-text">基于协议进行过滤：proto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC-IP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%88%E6%9C%AC%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">3.5.</span> <span class="toc-text">基本 IP 协议的版本进行过滤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">可选参数解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%8D%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%E6%8F%90%E5%8D%87%E9%80%9F%E5%BA%A6"><span class="toc-number">4.1.</span> <span class="toc-text">设置不解析域名提升速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">过滤结果输出到文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%8C%85%E6%95%B0%E6%8D%AE"><span class="toc-number">4.3.</span> <span class="toc-text">从文件中读取包数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-number">4.4.</span> <span class="toc-text">控制详细内容的输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%97%B6%E9%97%B4%E7%9A%84%E6%98%BE%E7%A4%BA"><span class="toc-number">4.5.</span> <span class="toc-text">控制时间的显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%A4%B4%E9%83%A8"><span class="toc-number">4.6.</span> <span class="toc-text">显示数据包的头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%8C%87%E5%AE%9A%E7%BD%91%E5%8D%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.7.</span> <span class="toc-text">过滤指定网卡的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E7%89%B9%E5%AE%9A%E6%B5%81%E5%90%91%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">4.8.</span> <span class="toc-text">过滤特定流向的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%82%E6%95%B0"><span class="toc-number">4.9.</span> <span class="toc-text">其他常用的一些参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">4.10.</span> <span class="toc-text">对输出内容进行控制的参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99%E7%BB%84%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">过滤规则组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99"><span class="toc-number">6.</span> <span class="toc-text">特殊过滤规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8C%85%E5%A4%A7%E5%B0%8F%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">6.1.</span> <span class="toc-text">基于包大小进行过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE-mac-%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">根据 mac 地址进行过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E9%80%9A%E8%BF%87%E6%8C%87%E5%AE%9A%E7%BD%91%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">6.3.</span> <span class="toc-text">过滤通过指定网关的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%B9%BF%E6%92%AD-%E5%A4%9A%E6%92%AD%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">6.4.</span> <span class="toc-text">过滤广播 &#x2F; 多播数据包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%B2%BE%E7%A1%AE%E6%8A%93%E5%8C%85"><span class="toc-number">7.</span> <span class="toc-text">如何精确抓包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">8.</span> <span class="toc-text">抓包实战应用例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96-HTTP-%E7%9A%84-User-Agent"><span class="toc-number">8.1.</span> <span class="toc-text">提取 HTTP 的 User-Agent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8F%96-HTTP-GET-%E5%92%8C-POST-%E8%AF%B7%E6%B1%82"><span class="toc-number">8.2.</span> <span class="toc-text">抓取 HTTP GET 和 POST 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E5%8F%91%E5%8C%85%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84-IP"><span class="toc-number">8.3.</span> <span class="toc-text">找出发包数最多的 IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8F%96-DNS-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="toc-number">8.4.</span> <span class="toc-text">抓取 DNS 请求和响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E5%89%B2-pcap-%E6%96%87%E4%BB%B6"><span class="toc-number">8.5.</span> <span class="toc-text">切割 pcap 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96-HTTP-POST-%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81"><span class="toc-number">8.6.</span> <span class="toc-text">提取 HTTP POST 请求中的密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96-HTTP-%E8%AF%B7%E6%B1%82%E7%9A%84-URL"><span class="toc-number">8.7.</span> <span class="toc-text">提取 HTTP 请求的 URL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8F%96-HTTP-%E6%9C%89%E6%95%88%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">8.8.</span> <span class="toc-text">抓取 HTTP 有效数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88-Wireshark-%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">8.9.</span> <span class="toc-text">结合 Wireshark 进行分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="tcpdump核心参数图解"><a href="#tcpdump核心参数图解" class="headerlink" title="tcpdump核心参数图解"></a>tcpdump核心参数图解</h2><p><img src="/images/image-20220421105202058.png" alt="image-20220421105202058"></p>
<ul>
<li>option 可选参数：将在后边一一解释。</li>
<li>proto 类过滤器：根据协议进行过滤，可识别的关键词有： tcp, udp, icmp, ip, ip6, arp, rarp, ether, wlan, fddi, tr, decnet</li>
<li>type 类过滤器：可识别的关键词有：host, net, port, portrange，这些词后边需要再接参数。</li>
<li>direction 类过滤器：根据数据流向进行过滤，可识别的关键字有：src, dst，同时你可以使用逻辑运算符进行组合，比如 src or dst</li>
</ul>
<p>eg：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 192.168.10.100</span><br><span class="line">tcpdump src host 192.168.10.100</span><br><span class="line">tcpdump tcp src host 192.168.10.100</span><br></pre></td></tr></table></figure>



<h2 id="理解tcpdump的输出"><a href="#理解tcpdump的输出" class="headerlink" title="理解tcpdump的输出"></a>理解tcpdump的输出</h2><h3 id="输出内容结构"><a href="#输出内容结构" class="headerlink" title="输出内容结构"></a>输出内容结构</h3><p>tcpdump 输出的内容虽然多，却很规律。</p>
<p>这里以我随便抓取的一个 tcp 包为例来看一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21:26:49.013621 IP 172.20.20.1.15605 &gt; 172.20.20.2.5920: Flags [P.], seq 49:97, ack 106048, win 4723, length 48</span><br></pre></td></tr></table></figure>

<ol>
<li>第一列：时分秒毫秒 21:26:49.013621</li>
<li>第二列：网络协议 IP</li>
<li>第三列：发送方的 ip 地址 + 端口号，其中 172.20.20.1 是 ip，而 15605 是端口号</li>
<li>第四列：箭头 &gt;， 表示数据流向</li>
<li>第五列：接收方的 ip 地址 + 端口号，其中 172.20.20.2 是 ip，而 5920 是端口号</li>
<li>第六列：冒号</li>
<li>第七列：数据包内容，包括 Flags 标识符，seq 号，ack 号，win 窗口，数据长度 length，其中 [P.] 表示 PUSH 标志位为 1，更多标识符见下面</li>
</ol>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump host 220.181.38.251</span><br><span class="line">tcpdump: data link type PKTAP</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on pktap, link-type PKTAP (Apple DLT_PKTAP), capture size 262144 bytes</span><br><span class="line">11:20:09.398749 IP 192.168.1.108 &gt; 220.181.38.251: ICMP echo request, id 62798, seq 0, length 64</span><br><span class="line">11:20:09.450709 IP 220.181.38.251 &gt; 192.168.1.108: ICMP echo reply, id 62798, seq 0, length 64</span><br><span class="line">11:20:10.402392 IP 192.168.1.108 &gt; 220.181.38.251: ICMP echo request, id 62798, seq 1, length 64</span><br><span class="line">11:20:10.454855 IP 220.181.38.251 &gt; 192.168.1.108: ICMP echo reply, id 62798, seq 1, length 64</span><br><span class="line">11:20:11.405310 IP 192.168.1.108 &gt; 220.181.38.251: ICMP echo request, id 62798, seq 2, length 64</span><br><span class="line">11:20:11.455789 IP 220.181.38.251 &gt; 192.168.1.108: ICMP echo reply, id 62798, seq 2, length 64</span><br></pre></td></tr></table></figure>



<h3 id="Flags-标识符"><a href="#Flags-标识符" class="headerlink" title="Flags 标识符"></a>Flags 标识符</h3><p>使用 tcpdump 抓包后，会遇到的 TCP 报文 Flags，有以下几种：</p>
<ul>
<li><code>[S]</code> : SYN（开始连接）</li>
<li><code>[P]</code> : PSH（推送数据）</li>
<li><code>[F]</code> : FIN （结束连接）</li>
<li><code>[R]</code> : RST（重置连接）</li>
<li><code>[.]</code> : 没有 Flag （意思是除上面四种类型外的其他情况，有可能是 ACK 也有可能是 URG）</li>
</ul>
<h2 id="常规过滤规则"><a href="#常规过滤规则" class="headerlink" title="常规过滤规则"></a>常规过滤规则</h2><h3 id="基于-IP-地址过滤：host"><a href="#基于-IP-地址过滤：host" class="headerlink" title="基于 IP 地址过滤：host"></a>基于 IP 地址过滤：host</h3><p>使用 <code>host</code> 就可以指定 host ip 进行过滤</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 192.168.10.100</span><br></pre></td></tr></table></figure>

<p>数据包的 ip 可以再细分为源 ip 和目标 ip 两种</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据源ip进行过滤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i: 指定网络接口，如常见的 eth0，lo(其实就是ifconfig输出的网卡)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth2 src 192.168.10.100</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据目标ip进行过滤</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth2 dst 192.168.10.200</span></span><br></pre></td></tr></table></figure>



<h3 id="基于网段进行过滤：net"><a href="#基于网段进行过滤：net" class="headerlink" title="基于网段进行过滤：net"></a>基于网段进行过滤：net</h3><p>若你的 ip 范围是一个网段，可以直接这样指定</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump net 192.168.10.0/24</span></span><br></pre></td></tr></table></figure>

<p>网段同样可以再细分为源网段和目标网段</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据源网段进行过滤</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump src net 192.168</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据目标网段进行过滤</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump dst net 192.168</span></span><br></pre></td></tr></table></figure>



<h3 id="基于端口进行过滤：port"><a href="#基于端口进行过滤：port" class="headerlink" title="基于端口进行过滤：port"></a>基于端口进行过滤：port</h3><p>使用 <code>port</code> 就可以指定特定端口进行过滤</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump port 8088</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据源端口进行过滤</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump src port 8088</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据目标端口进行过滤</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump dst port 8088</span></span><br></pre></td></tr></table></figure>

<p>如果你想要同时指定两个端口你可以这样写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump port 80 or port 8088</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以简写成这样</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump port 80 or 8088</span></span><br></pre></td></tr></table></figure>

<p>如果你的想抓取的不再是一两个端口，而是一个范围，一个一个指定就非常麻烦了，此时你可以这样指定一个端口段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump portrange 8000-8080</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump src portrange 8000-8080</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump dst portrange 8000-8080</span></span><br></pre></td></tr></table></figure>

<p>对于一些常见协议的默认端口，我们还可以直接使用协议名，而不用具体的端口号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> http == 80，https == 443</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump tcp port http</span></span><br></pre></td></tr></table></figure>



<h3 id="基于协议进行过滤：proto"><a href="#基于协议进行过滤：proto" class="headerlink" title="基于协议进行过滤：proto"></a>基于协议进行过滤：proto</h3><p>常见的网络协议有：tcp, udp, icmp, http, ip, ipv6 等</p>
<p>若你只想查看 icmp 的包，可以直接这样写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump icmp</span></span><br></pre></td></tr></table></figure>

<p>protocol 可选值：ip, ip6, arp, rarp, atalk, aarp, decnet, sca, lat, mopdl, moprc, iso, stp, ipx, or netbeui</p>
<h3 id="基本-IP-协议的版本进行过滤"><a href="#基本-IP-协议的版本进行过滤" class="headerlink" title="基本 IP 协议的版本进行过滤"></a>基本 IP 协议的版本进行过滤</h3><p>查看 tcp 的包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump tcp</span></span><br></pre></td></tr></table></figure>

<p>ip 根据版本的不同，可以再细分为 IPv4 和 IPv6 两种，如果是 IPv6 的 tcp 包 ，就这样写：（友情提示：数字 6 表示的是 tcp 在 ip 报文中的编号。）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&#x27;ip6 proto tcp&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ip6 proto 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&#x27;ip6 protochain tcp&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ip6 protochain 6</span></span><br></pre></td></tr></table></figure>

<p>关于上面这几个命令示例，有两点需要注意：</p>
<ol>
<li>跟在 proto 和 protochain 后面的如果是 tcp, udp, icmp ，那么过滤器需要用引号包含，这是因为 tcp,udp, icmp 是 tcpdump 的关键字。</li>
<li>跟在 ip 和 ip6 关键字后面的 proto 和 protochain 是两个新面孔，看起来用法类似，它们是否等价，又有什么区别呢？<ul>
<li>proto 后面跟的 <code>&lt;protocol&gt;</code> 的关键词是固定的，只能是 ip, ip6, arp, rarp, atalk, aarp, decnet, sca, lat, mopdl, moprc, iso, stp, ipx, or netbeui 这里面的其中一个。</li>
<li>而 protochain 后面跟的 protocol 要求就没有那么严格，它可以是任意词，只要 tcpdump 的 IP 报文头部里的 protocol 字段为 <code>&lt;protocol&gt;</code> 就能匹配上。</li>
</ul>
</li>
</ol>
<p>理论上来讲，下面两种写法效果是一样的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&#x27;ip &amp;&amp; tcp&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&#x27;ip proto tcp&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>同样的，这两种写法也是一样的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&#x27;ip6 &amp;&amp; tcp&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&#x27;ip6 proto tcp&#x27;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="可选参数解析"><a href="#可选参数解析" class="headerlink" title="可选参数解析"></a>可选参数解析</h2><h3 id="设置不解析域名提升速度"><a href="#设置不解析域名提升速度" class="headerlink" title="设置不解析域名提升速度"></a>设置不解析域名提升速度</h3><ul>
<li><code>-n</code>：不把 ip 转化成域名，直接显示 ip，避免执行 DNS lookups 的过程，速度会快很多</li>
<li><code>-nn</code>：不把协议和端口号转化成名字，速度也会快很多。</li>
<li><code>-N</code>：不打印出 host 的域名部分.。比如，，如果设置了此选现，tcpdump 将会打印 ‘nic’ 而不是 ‘nic.ddn.mil’.</li>
</ul>
<h3 id="过滤结果输出到文件"><a href="#过滤结果输出到文件" class="headerlink" title="过滤结果输出到文件"></a>过滤结果输出到文件</h3><p>使用 tcpdump 工具抓到包后，往往需要再借助其他的工具进行分析，比如常见的 wireshark 。而要使用 wireshark ，我们得将 tcpdump 抓到的包数据生成到文件中，最后再使用 wireshark 打开它即可。</p>
<p>使用 <code>-w</code> 参数后接一个以 <code>.pcap</code> 后缀命令的文件名，就可以将 tcpdump 抓到的数据保存到文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump icmp -w icmp.pcap</span></span><br></pre></td></tr></table></figure>



<h3 id="从文件中读取包数据"><a href="#从文件中读取包数据" class="headerlink" title="从文件中读取包数据"></a>从文件中读取包数据</h3><p>使用 <code>-w</code> 是写入数据到文件，而使用 <code>-r</code> 是从文件中读取数据。</p>
<p>读取后，我们照样可以使用上述的过滤器语法进行过滤分析。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump icmp -r all.pcap</span></span><br></pre></td></tr></table></figure>



<h3 id="控制详细内容的输出"><a href="#控制详细内容的输出" class="headerlink" title="控制详细内容的输出"></a>控制详细内容的输出</h3><ul>
<li><code>-v</code>：产生详细的输出。比如包的 TTL，id 标识，数据包长度，以及 IP 包的一些选项。同时它还会打开一些附加的包完整性检测，比如对 IP 或 ICMP 包头部的校验和。</li>
<li><code>-vv</code>：产生比 - v 更详细的输出。比如 NFS 回应包中的附加域将会被打印，SMB 数据包也会被完全解码。（摘自网络，目前我还未使用过）</li>
<li><code>-vvv</code>：产生比 - vv 更详细的输出。比如 telent 时所使用的 SB, SE 选项将会被打印，如果 telnet 同时使用的是图形界面，其相应的图形选项将会以 16 进制的方式打印出来</li>
</ul>
<h3 id="控制时间的显示"><a href="#控制时间的显示" class="headerlink" title="控制时间的显示"></a>控制时间的显示</h3><ul>
<li><code>-t</code>：在每行的输出中不输出时间</li>
<li><code>-tt</code>：在每行的输出中会输出时间戳</li>
<li><code>-ttt</code>：输出每两行打印的时间间隔 (以毫秒为单位)</li>
<li><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印（此种选项，输出的时间最直观）</li>
</ul>
<h3 id="显示数据包的头部"><a href="#显示数据包的头部" class="headerlink" title="显示数据包的头部"></a>显示数据包的头部</h3><ul>
<li><code>-x</code>：以 16 进制的形式打印每个包的头部数据（但不包括数据链路层的头部）</li>
<li><code>-xx</code>：以 16 进制的形式打印每个包的头部数据（包括数据链路层的头部）</li>
<li><code>-X</code>：以 16 进制和 ASCII 码形式打印出每个包的数据 (但不包括连接层的头部)，这在分析一些新协议的数据包很方便。</li>
<li><code>-XX</code>：以 16 进制和 ASCII 码形式打印出每个包的数据 (包括连接层的头部)，这在分析一些新协议的数据包很方便。</li>
</ul>
<h3 id="过滤指定网卡的数据包"><a href="#过滤指定网卡的数据包" class="headerlink" title="过滤指定网卡的数据包"></a>过滤指定网卡的数据包</h3><ul>
<li><code>-i</code>：指定要过滤的网卡接口，如果要查看所有网卡，可以 <code>-i any</code></li>
</ul>
<h3 id="过滤特定流向的数据包"><a href="#过滤特定流向的数据包" class="headerlink" title="过滤特定流向的数据包"></a>过滤特定流向的数据包</h3><ul>
<li><code>-Q</code>： 选择是入方向还是出方向的数据包，可选项有：in, out, inout，也可以使用 –direction=[direction] 这种写法</li>
</ul>
<h3 id="其他常用的一些参数"><a href="#其他常用的一些参数" class="headerlink" title="其他常用的一些参数"></a>其他常用的一些参数</h3><ul>
<li><code>-A</code>：以 ASCII 码方式显示每一个数据包 (不显示链路层头部信息). 在抓取包含网页数据的数据包时，可方便查看数据</li>
<li><code>-l</code> : 基于行的输出，便于你保存查看，或者交给其它工具分析</li>
<li><code>-q</code> : 简洁地打印输出。即打印很少的协议相关信息，从而输出行都比较简短.</li>
<li><code>-c</code> : 捕获 count 个包 tcpdump 就退出</li>
<li><code>-s</code> : tcpdump 默认只会截取前 <code>96</code> 字节的内容，要想截取所有的报文内容，可以使用 <code>-s number</code>， <code>number</code> 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。</li>
<li><code>-S</code> : 使用绝对序列号，而不是相对序列号</li>
<li><code>-C</code>：file-size，tcpdump 在把原始数据包直接保存到文件中之前，检查此文件大小是否超过 file-size. 如果超过了，将关闭此文件，另创一个文件继续用于原始数据包的记录。新创建的文件名与 - w 选项指定的文件名一致，但文件名后多了一个数字。该数字会从 1 开始随着新创建文件的增多而增加. file-size 的单位是百万字节 (nt: 这里指 1,000,000 个字节，并非 1,048,576 个字节，后者是以 1024 字节为 1k, 1024k 字节为 1M 计算所得，即 1M=1024 ＊ 1024 ＝ 1,048,576)</li>
<li><code>-F</code>：使用 file 文件作为过滤条件表达式的输入，此时命令行上的输入将被忽略.</li>
</ul>
<h3 id="对输出内容进行控制的参数"><a href="#对输出内容进行控制的参数" class="headerlink" title="对输出内容进行控制的参数"></a>对输出内容进行控制的参数</h3><ul>
<li><code>-D</code> : 显示所有可用网络接口的列表</li>
<li><code>-e</code> : 每行的打印输出中将包括数据包的数据链路层头部信息</li>
<li><code>-E</code> : 揭秘 IPSEC 数据</li>
<li><code>-L</code> ：列出指定网络接口所支持的数据链路层的类型后退出</li>
<li><code>-Z</code>：后接用户名，在抓包时会受到权限的限制。如果以 root 用户启动 tcpdump，tcpdump 将会有超级用户权限。</li>
<li><code>-d</code>：打印出易读的包匹配码</li>
<li><code>-dd</code>：以 C 语言的形式打印出包匹配码.</li>
<li><code>-ddd</code>：以十进制数的形式打印出包匹配码</li>
</ul>
<h2 id="过滤规则组合"><a href="#过滤规则组合" class="headerlink" title="过滤规则组合"></a>过滤规则组合</h2><p>抓一个来自 <code>10.5.2.3</code>，发往任意主机的 3389 端口的包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump src 10.5.2.3 and dst port 3389</span></span><br></pre></td></tr></table></figure>

<p>当你在使用多个过滤器进行组合时，有可能需要用到括号，而括号在 shell 中是特殊符号，因为你需要使用引号将其包含。例子如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&#x27;src 10.0.2.4 and (dst port 3389 or 22)&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>而在单个过滤器里，常常会判断一条件是否成立，这时候，就要使用下面两个符号</p>
<ul>
<li><code>=</code>：判断二者相等</li>
<li><code>==</code>：判断二者相等</li>
<li><code>!=</code>：判断二者不相等</li>
</ul>
<p>当你使用这两个符号时，tcpdump 还提供了一些关键字的接口来方便我们进行判断，比如</p>
<ul>
<li>if：表示网卡接口名、</li>
<li>proc：表示进程名</li>
<li>pid：表示进程 id</li>
<li>svc：表示 service class</li>
<li>dir：表示方向，in 和 out</li>
<li>eproc：表示 effective process name</li>
<li>epid：表示 effective process ID</li>
</ul>
<p>比如我现在要过滤来自进程名为 <code>nc</code> 发出的流经 en0 网卡的数据包，或者不流经 en0 的入方向数据包，可以这样子写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&quot;( if=en0 and proc=nc ) || (if != en0 and dir=in)&quot;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="特殊过滤规则"><a href="#特殊过滤规则" class="headerlink" title="特殊过滤规则"></a>特殊过滤规则</h2><p>tcp 的首部有一个标志位</p>
<p><img src="/images/image-20220421110907717.png" alt="image-20220421110907717"></p>
<p>cpdump 支持我们根据数据包的标志位进行过滤</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proto [ expr:size ]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>proto</code>：可以是熟知的协议之一（如 ip，arp，tcp，udp，icmp，ipv6）</li>
<li><code>expr</code>：可以是数值，也可以是一个表达式，表示与指定的协议头开始处的字节偏移量。</li>
<li><code>size</code>：是可选的，表示从字节偏移量开始取的字节数量。</li>
</ul>
<p>接下来，我将举几个例子，让人明白它的写法，不过在那之前，有几个点需要你明白，这在后面的例子中会用到：</p>
<p>tcpflags 可以理解为是一个别名常量，相当于 13，它代表着与指定的协议头开头相关的字节偏移量，也就是标志位，所以 tcp [tcpflags] 等价于 tcp [13] ，对应下图中的报文位置。</p>
<p><img src="/images/20200628222034.png" alt="img"></p>
<p>tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg 这些同样可以理解为别名常量，分别代表 1，2，4，8，16，32，64。这些数字是如何计算出来的呢？以 tcp-syn 为例，你可以参照下面这张图，计算出来的值 是就是 2</p>
<p><img src="/images/20200628222010.png" alt="img"></p>
<p>由于数字不好记忆，所以一般使用这样的 “别名常量” 表示。</p>
<p>因此当下面这个表达式成立时，就代表这个包是一个 syn 包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp[tcpflags] == tcp-syn</span><br></pre></td></tr></table></figure>

<p>要抓取特定数据包，方法有很多种。</p>
<p>下面以最常见的 syn 包为例，演示一下如何用 tcpdump 抓取到 syn 包，而其他的类型的包也是同样的道理。</p>
<p>据我总结，主要有三种写法：</p>
<p>1、第一种写法：使用数字表示偏移量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 <span class="string">&quot;tcp[13] &amp; 2 != 0&quot;</span></span> </span><br></pre></td></tr></table></figure>

<p>2、第二种写法：使用别名常量表示偏移量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 <span class="string">&quot;tcp[tcpflags] &amp; tcp-syn != 0&quot;</span></span> </span><br></pre></td></tr></table></figure>

<p>3、第三种写法：使用混合写法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 <span class="string">&quot;tcp[tcpflags] &amp; 2 != 0&quot;</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 <span class="string">&quot;tcp[13] &amp; tcp-syn != 0&quot;</span></span> </span><br></pre></td></tr></table></figure>



<p>如果我想同时捕获多种类型的包呢，比如 syn + ack 包</p>
<p>1、第一种写法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 <span class="string">&#x27;tcp[13] == 2 or tcp[13] == 16&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>2、第二种写法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 <span class="string">&#x27;tcp[tcpflags] == tcp-syn or tcp[tcpflags] == tcp-ack&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>3、第三种写法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 <span class="string">&quot;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&quot;</span></span> </span><br></pre></td></tr></table></figure>

<p>4、第四种写法：注意这里是 单个等号，而不是像上面一样两个等号，18（syn+ack） = 2（syn） + 16（ack）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 <span class="string">&#x27;tcp[13] = 18&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 <span class="string">&#x27;tcp[tcpflags] = 18&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>tcp 中有 类似 tcp-syn 的别名常量，其他协议也是有的，比如 icmp 协议，可以使用的别名常量有</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">icmp-echoreply, icmp-unreach, icmp-sourcequench, </span><br><span class="line">icmp-redirect, icmp-echo, icmp-routeradvert,</span><br><span class="line">icmp-routersolicit, icmp-timx-ceed, icmp-paramprob, </span><br><span class="line">icmp-tstamp, icmp-tstampreply,icmp-ireq, </span><br><span class="line">icmp-ireqreply, icmp-maskreq, icmp-maskreply</span><br></pre></td></tr></table></figure>



<h3 id="基于包大小进行过滤"><a href="#基于包大小进行过滤" class="headerlink" title="基于包大小进行过滤"></a>基于包大小进行过滤</h3><p>若你想查看指定大小的数据包，也是可以的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump less 32</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump greater 64</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump &lt;= 128</span></span><br></pre></td></tr></table></figure>



<h3 id="根据-mac-地址进行过滤"><a href="#根据-mac-地址进行过滤" class="headerlink" title="根据 mac 地址进行过滤"></a>根据 mac 地址进行过滤</h3><p>例子如下，其中 ehost 是记录在 /etc/ethers 里的 name</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ether host [ehost]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ether dst	[ehost]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ether src	[ehost]</span></span><br></pre></td></tr></table></figure>



<h3 id="过滤通过指定网关的数据包"><a href="#过滤通过指定网关的数据包" class="headerlink" title="过滤通过指定网关的数据包"></a>过滤通过指定网关的数据包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump gateway [host]</span></span><br></pre></td></tr></table></figure>



<h3 id="过滤广播-多播数据包"><a href="#过滤广播-多播数据包" class="headerlink" title="过滤广播 / 多播数据包"></a>过滤广播 / 多播数据包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ether broadcast</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ether multicast</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ip broadcast</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ip multicast</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ip6 multicast</span></span><br></pre></td></tr></table></figure>



<h2 id="如何精确抓包"><a href="#如何精确抓包" class="headerlink" title="如何精确抓包"></a>如何精确抓包</h2><p>先给你抛出一个问题：如果我只想抓取 HTTP 的 POST 请求该如何写呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -s 0 -A -vv <span class="string">&#x27;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4]&#x27;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>tcp[n]</code>：表示 tcp 报文里 第 n 个字节</p>
</li>
<li><p><code>tcp[n:c]</code>：表示 tcp 报文里从第 n 个字节开始取 c 个字节，tcp [12:1] 表示从报文的第 12 个字节（因为有第 0 个字节，所以这里的 12 其实表示的是 13）开始算起取一个字节，也就是 8 个 bit。查看 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">tcp 的报文首部结构</a>，可以得知这 8 个 bit 其实就是下图中的红框圈起来的位置，而在这里我们只要前面 4 个 bit，也就是实际数据在整个报文首部中的偏移量。</p>
<p><img src="/images/20200629085659.png" alt="img"></p>
</li>
<li><p><code>&amp;</code>：位与运算符。</p>
</li>
<li><p><code>&gt;&gt;</code>：位右移操作</p>
</li>
<li><p><code>0xf0</code>：是 10 进制的 240 的 16 进制表示，但对于位操作来说，10 进制和 16 进制都将毫无意义，我们需要的是二进制，将其转换成二进制后是：11110000，这个数有什么特点呢？前面个 4bit 全部是 1，后面 4 个 bit 全部是 0，往后看你就知道这个特点有什么用了。</p>
</li>
</ul>
<p>分解完后，再慢慢合并起来看</p>
<p>1、<code>tcp[12:1] &amp; 0xf0</code> 其实并不直观，但是我们将它换一种写法，就好看多了，假设 tcp 报文中的 第 12 个字节是这样组成的 <code>10110000</code>，那么这个表达式就可以变成 10110110 &amp;&amp; 11110000 = 10110000，得到了 10110000 后，再进入下一步。</p>
<p>2、<code>tcp[12:1] &amp; 0xf0) &gt;&gt; 2</code> ：如果你不理解 tcp 报文首部里的数据偏移，请先点击这个前往我的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzMzMzOTI3Nw==&mid=2247488180&idx=1&sn=09526224732ebfcccb52847f27298c70&chksm=e8867256dff1fb40c9f47bafd0e87a9237c5a9ebf33c8a3d0a598276b496d29cdaa3fbff8d26&token=1970357830&lang=zh_CN#rd">上一篇文章</a>，搞懂数据偏移的意义，否则我保证你这里会绝对会听懵了。</p>
<p><code>tcp[12:1] &amp; 0xf0) &gt;&gt; 2</code> 这个表达式实际是 <code>(tcp[12:1] &amp; 0xf0) &gt;&gt; 4 ) &lt;&lt; 2</code> 的简写形式。所以要搞懂 <code>tcp[12:1] &amp; 0xf0) &gt;&gt; 2</code> 只要理解了 <code>(tcp[12:1] &amp; 0xf0) &gt;&gt; 4 ) &lt;&lt; 2</code> 就行了 。</p>
<p>从上一步我们算出了 <code>tcp[12:1] &amp; 0xf0</code> 的值其实是一个字节，也就是 8 个 bit，但是你再回去看下上面的 tcp 报文首部结构图，表示数据偏移量的只有 4 个 bit，也就是说 上面得到的值 10110000，前面 4 位（1011）才是正确的偏移量，那么为了得到 1011，只需要将 10110000 右移 4 位即可，也就是 <code>tcp[12:1] &amp; 0xf0) &gt;&gt; 4</code>，至此我们是不是已经得出了实际数据的正确位置呢，很遗憾还没有，前一篇文章里我们讲到 Data Offset 的单位是 4 个字节，因为要将 1011 乘以 4 才可以，除以 4 在位运算中相当于左移 2 位，也就是 <code>&lt;&lt;2</code>，与前面的 <code>&gt;&gt;4</code> 结合起来一起算的话，最终的运算可以简化为 <code>&gt;&gt;2</code>。</p>
<p>至此，我们终于得出了实际数据开始的位置是 <code>tcp[12:1] &amp; 0xf0) &gt;&gt; 2</code> （单位是字节）。</p>
<p>找到了数据的起点后，可别忘了我们的目的是从数据中打到 HTTP 请求的方法，是 GET 呢 还是 POST ，或者是其他的？</p>
<p>有了上面的经验，我们自然懂得使用 <code>tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4]</code> 从数据开始的位置再取出四个字节，然后将结果与 <code>GET</code> （注意 GET 最后还有个空格）的 16 进制写法（也就是 <code>0x47455420</code>）进行比对。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x47   --&gt;   71    --&gt;  G</span><br><span class="line">0x45   --&gt;   69    --&gt;  E</span><br><span class="line">0x54   --&gt;   84    --&gt;  T</span><br><span class="line">0x20   --&gt;   32    --&gt;  空格</span><br></pre></td></tr></table></figure>

<p><img src="/images/20200629130407.png" alt="img"></p>
<p>如果相等，则该表达式为 True，tcpdump 认为这就是我们所需要抓的数据包，将其输出到我们的终端屏幕上。</p>
<h2 id="抓包实战应用例子"><a href="#抓包实战应用例子" class="headerlink" title="抓包实战应用例子"></a>抓包实战应用例子</h2><h3 id="提取-HTTP-的-User-Agent"><a href="#提取-HTTP-的-User-Agent" class="headerlink" title="提取 HTTP 的 User-Agent"></a>提取 HTTP 的 User-Agent</h3><p>从 HTTP 请求头中提取 HTTP 的 User-Agent：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -nn -A -s1500 -l | grep <span class="string">&quot;User-Agent:&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>egrep</code> 可以同时提取 User-Agent 和主机名（或其他头文件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -nn -A -s1500 -l | egrep -i <span class="string">&#x27;User-Agent:|Host:&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="抓取-HTTP-GET-和-POST-请求"><a href="#抓取-HTTP-GET-和-POST-请求" class="headerlink" title="抓取 HTTP GET 和 POST 请求"></a>抓取 HTTP GET 和 POST 请求</h3><p>抓取 HTTP GET 请求包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -s 0 -A -vv <span class="string">&#x27;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420&#x27;</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ tcpdump -vvAls0 | grep <span class="string">&#x27;GET&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以抓取 HTTP POST 请求包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -s 0 -A -vv <span class="string">&#x27;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f5354&#x27;</span></span><br><span class="line"><span class="comment"># or </span></span><br><span class="line">$ tcpdump -vvAls0 | grep <span class="string">&#x27;POST&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：该方法不能保证抓取到 HTTP POST 有效数据流量，因为一个 POST 请求会被分割为多个 TCP 数据包。</p>
<h3 id="找出发包数最多的-IP"><a href="#找出发包数最多的-IP" class="headerlink" title="找出发包数最多的 IP"></a>找出发包数最多的 IP</h3><p>找出一段时间内发包最多的 IP，或者从一堆报文中找出发包最多的 IP，可以使用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -nnn -t -c 200 | cut -f 1,2,3,4 -d <span class="string">&#x27;.&#x27;</span> | sort | uniq -c | sort -nr | head -n 20</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cut -f 1,2,3,4 -d ‘.’</strong> : 以 <code>.</code> 为分隔符，打印出每行的前四列。即 IP 地址。</li>
<li><strong>sort | uniq -c</strong> : 排序并计数</li>
<li><strong>sort -nr</strong> : 按照数值大小逆向排序</li>
</ul>
<h3 id="抓取-DNS-请求和响应"><a href="#抓取-DNS-请求和响应" class="headerlink" title="抓取 DNS 请求和响应"></a>抓取 DNS 请求和响应</h3><p>DNS 的默认端口是 53，因此可以通过端口进行过滤</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i any -s0 port 53</span></span><br></pre></td></tr></table></figure>



<h3 id="切割-pcap-文件"><a href="#切割-pcap-文件" class="headerlink" title="切割 pcap 文件"></a>切割 pcap 文件</h3><p>当抓取大量数据并写入文件时，可以自动切割为多个大小相同的文件。例如，下面的命令表示每 3600 秒创建一个新文件 <code>capture-(hour).pcap</code>，每个文件大小不超过 <code>200*1000000</code> 字节：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump  -w /tmp/capture-%H.pcap -G 3600 -C 200</span><br></pre></td></tr></table></figure>

<p>这些文件的命名为 <code>capture-&#123;1-24&#125;.pcap</code>，24 小时之后，之前的文件就会被覆盖。</p>
<h3 id="提取-HTTP-POST-请求中的密码"><a href="#提取-HTTP-POST-请求中的密码" class="headerlink" title="提取 HTTP POST 请求中的密码"></a>提取 HTTP POST 请求中的密码</h3><p>从 HTTP POST 请求中提取密码和主机名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -s 0 -A -n -l | egrep -i <span class="string">&quot;POST /|pwd=|passwd=|password=|Host:&quot;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="提取-HTTP-请求的-URL"><a href="#提取-HTTP-请求的-URL" class="headerlink" title="提取 HTTP 请求的 URL"></a>提取 HTTP 请求的 URL</h3><p>提取 HTTP 请求的主机名和路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -s 0 -v -n -l | egrep -i <span class="string">&quot;POST /|GET /|Host:&quot;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="抓取-HTTP-有效数据包"><a href="#抓取-HTTP-有效数据包" class="headerlink" title="抓取 HTTP 有效数据包"></a>抓取 HTTP 有效数据包</h3><p>抓取 80 端口的 HTTP 有效数据包，排除 TCP 连接建立过程的数据包（SYN / FIN / ACK）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump <span class="string">&#x27;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&#x27;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="结合-Wireshark-进行分析"><a href="#结合-Wireshark-进行分析" class="headerlink" title="结合 Wireshark 进行分析"></a>结合 Wireshark 进行分析</h3><p>通常 <code>Wireshark</code>（或 tshark）比 tcpdump 更容易分析应用层协议。一般的做法是在远程服务器上先使用 <code>tcpdump</code> 抓取数据并写入文件，然后再将文件拷贝到本地工作站上用 <code>Wireshark</code> 分析。</p>
<p>还有一种更高效的方法，可以通过 ssh 连接将抓取到的数据实时发送给 Wireshark 进行分析。以 MacOS 系统为例，可以通过 <code>brew cask install wireshark</code> 来安装，然后通过下面的命令来分析：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh root@remotesystem <span class="string">&#x27;tcpdump -s0 -c 1000 -nn -w - not port 22&#x27;</span> | /Applications/Wireshark.app/Contents/MacOS/Wireshark -k -i -</span></span><br></pre></td></tr></table></figure>

<p>例如，如果想分析 DNS 协议，可以使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh root@remotesystem <span class="string">&#x27;tcpdump -s0 -c 1000 -nn -w - port 53&#x27;</span> | /Applications/Wireshark.app/Contents/MacOS/Wireshark -k -i -</span></span><br></pre></td></tr></table></figure>

<p>抓取到的数据：</p>
<p><img src="/images/20200210170101.png" alt="img"></p>
<p><code>-c</code> 选项用来限制抓取数据的大小。如果不限制大小，就只能通过 <code>ctrl-c</code> 来停止抓取，这样一来不仅关闭了 tcpdump，也关闭了 wireshark。</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wongbingming/p/13212306.html">tcpdump使用指南</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>