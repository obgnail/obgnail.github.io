<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;Go包管理工具演变&quot;&gt;&lt;a href=&quot;#Go包管理工具演变&quot; class=&quot;headerlink&quot; title=&quot;Go包管理工具演变&quot;&gt;&lt;/a&gt;Go包管理工具演变&lt;/h2&gt;&lt;p&gt;&lt;code&gt;GOPATH&lt;/code&gt; -&amp;gt; &lt;code&gt;GO VENDOR&lt;/code&gt; -&amp;gt; &lt;code&gt;GO Modules&lt;/code&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Go包管理 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-04-21</div></div></div><div class="container post-header"><h1>Go包管理</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%BC%94%E5%8F%98"><span class="toc-number">1.</span> <span class="toc-text">Go包管理工具演变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E5%8F%A4%E8%80%81%E7%9A%84-GOPATH"><span class="toc-number">1.1.</span> <span class="toc-text">1. 最古老的 GOPATH</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GOPATH-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">GOPATH 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GOPATH-%E6%9C%80%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">GOPATH 最大的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-go-vendor-%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%87%E6%B8%A1"><span class="toc-number">1.2.</span> <span class="toc-text">2. go vendor 模式的过渡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#go-vendor-%E6%90%9C%E7%B4%A2%E5%8C%85%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">go vendor 搜索包的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-vendor-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">go vendor 的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-go-mod-%E7%9A%84%E6%A8%AA%E7%A9%BA%E5%87%BA%E4%B8%96"><span class="toc-number">1.3.</span> <span class="toc-text">3. go mod 的横空出世</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GO111MODULE"><span class="toc-number">1.3.1.</span> <span class="toc-text">GO111MODULE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-vendor"><span class="toc-number">2.</span> <span class="toc-text">go vendor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go-vendor-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">go vendor 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-vendor-%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">go vendor 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-vendor-%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.3.</span> <span class="toc-text">go vendor 使用建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-vendor-%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.</span> <span class="toc-text">go vendor 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-vendor-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">go vendor 命令参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-vendor-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">go vendor 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.6.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.6.2.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-vendor-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.</span> <span class="toc-text">go vendor 常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-Modules"><span class="toc-number">3.</span> <span class="toc-text">Go Modules</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-Modules-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">Go Modules 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quick-start"><span class="toc-number">3.2.</span> <span class="toc-text">quick start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-mod-%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">go.mod 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-sum-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">go.sum 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-mod-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.5.</span> <span class="toc-text">go mod 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mod%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.</span> <span class="toc-text">mod基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-amp-A"><span class="toc-number">3.7.</span> <span class="toc-text">Q&amp;A</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%9A%84%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%88%B0%E5%93%AA%E9%87%8C%E4%BA%86%EF%BC%9F%E8%BF%98%E5%9C%A8-GOPATH-%E9%87%8C%E5%90%97%EF%BC%9F"><span class="toc-number">3.7.1.</span> <span class="toc-text">依赖的包下载到哪里了？还在 GOPATH 里吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%8C%85%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AF%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E7%9A%84%EF%BC%9F"><span class="toc-number">3.7.2.</span> <span class="toc-text">依赖包的版本是怎么控制的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E6%8A%8A%E9%A1%B9%E7%9B%AE%E6%94%BE%E5%9C%A8-GOPATH-src-%E4%B8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">3.7.3.</span> <span class="toc-text">可以把项目放在 $GOPATH&#x2F;src 下吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%8C%85%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A4%B1%E6%95%88%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E6%AF%94%E5%A6%82-golang-org-x-%E2%80%A6-%E4%B8%8B%E7%9A%84%E5%8C%85%E9%83%BD%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">3.7.4.</span> <span class="toc-text">依赖包中的地址失效了怎么办？比如 golang.org&#x2F;x&#x2F;… 下的包都无法下载怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-%E7%94%9F%E6%88%90%E7%9A%84-go-mod-%E7%9A%84%E6%A8%A1%E5%9D%97%E5%90%8D%E7%A7%B0%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">3.7.5.</span> <span class="toc-text">init 生成的 go.mod 的模块名称有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%89%8D%E8%80%81%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E7%94%A8%E6%96%B0%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">3.7.6.</span> <span class="toc-text">以前老项目如何用新的包管理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="Go包管理工具演变"><a href="#Go包管理工具演变" class="headerlink" title="Go包管理工具演变"></a>Go包管理工具演变</h2><p><code>GOPATH</code> -&gt; <code>GO VENDOR</code> -&gt; <code>GO Modules</code></p>
<h3 id="1-最古老的-GOPATH"><a href="#1-最古老的-GOPATH" class="headerlink" title="1. 最古老的 GOPATH"></a>1. 最古老的 GOPATH</h3><p>GOPATH 可以将其理解为<code>工作目录</code>，在这个工作目录下，通常有如下的目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── pkg</span><br><span class="line">└── src</span><br></pre></td></tr></table></figure>

<ul>
<li>bin：存放编译后生成的二进制可执行文件</li>
<li>pkg：存放编译后生成的 <code>.a</code> 文件</li>
<li>src：存放项目的源代码，可以是你自己写的代码，也可以是你 go get 下载的包</li>
</ul>
<h4 id="GOPATH-模式"><a href="#GOPATH-模式" class="headerlink" title="GOPATH 模式"></a>GOPATH 模式</h4><p>将你的包或者别人的包全部放在 <code>$GOPATH/src</code> 目录下进行管理的方式，我们称之为 GOPATH 模式。</p>
<p>在这个模式下，使用 go install 时，生成的可执行文件会放在 <code>$GOPATH/bin</code> 下</p>
<p><img src="/images/1147362-20200523085603704-1157662340.png" alt="img"></p>
<p>如果你安装的是一个库，则会生成 <code>.a</code> 文件到 <code>$GOPATH/pkg</code> 下对应的平台目录中（由 GOOS 和 GOARCH 组合而成），生成 <code>.a</code> 为后缀的文件。</p>
<p><img src="/images/1147362-20200523085603939-2102125559.png" alt="img"></p>
<h4 id="GOPATH-最大的问题"><a href="#GOPATH-最大的问题" class="headerlink" title="GOPATH 最大的问题"></a>GOPATH 最大的问题</h4><p><strong>GOPATH 根本没有版本的概念</strong>。</p>
<p>使用 GOPATH 一定会碰到的问题：</p>
<ul>
<li>你无法在你的项目中，使用指定版本的包，因为不同版本的包的导入方法也都一样</li>
<li>其他人运行你的开发的程序时，无法保证他下载的包版本是你所期望的版本，当对方使用了其他版本，有可能导致程序无法正常运行</li>
<li>在本地，一个包只能保留一个版本，意味着你在本地开发的所有项目，都得用同一个版本的包，这几乎是不可能的。</li>
</ul>
<h3 id="2-go-vendor-模式的过渡"><a href="#2-go-vendor-模式的过渡" class="headerlink" title="2. go vendor 模式的过渡"></a>2. go vendor 模式的过渡</h3><p>为了解决 GOPATH 方案下不同项目下无法使用多个版本库的问题，Go v1.5 开始支持 vendor 。</p>
<p>以前使用 GOPATH 的时候，所有的项目都共享一个 GOPATH，需要导入依赖的时候，都来这里找，正所谓一山不容二虎，在 GOPATH 模式下只能有一个版本的第三方库。</p>
<p>解决的思路就是，<strong>在每个项目下都创建一个 vendor 目录，每个项目所需的依赖都只会下载到自己 vendor 目录下，项目之间的依赖包互不影响。在编译时，会提升 vendor 目录的依赖包搜索路径的优先级（相较于 GOPATH）</strong>。</p>
<h4 id="go-vendor-搜索包的优先级"><a href="#go-vendor-搜索包的优先级" class="headerlink" title="go vendor 搜索包的优先级"></a>go vendor 搜索包的优先级</h4><p>其搜索包的优先级顺序，由高到低是这样的</p>
<ul>
<li>当前包下的 vendor 目录</li>
<li>向上级目录查找 vendor 目录，直到找到 src 下的 vendor 目录</li>
<li>在 GOROOT 目录下查找</li>
<li>在 GOPATH 下面查找依赖包</li>
</ul>
<h4 id="go-vendor-的问题"><a href="#go-vendor-的问题" class="headerlink" title="go vendor 的问题"></a>go vendor 的问题</h4><ul>
<li>如果多个项目用到了同一个包的同一个版本，这个包会存在于该机器上的不同目录下，不仅对磁盘空间是一种浪费，而且没法对第三方包进行集中式的管理（分散在各个角落）。</li>
<li>并且如果要分享开源你的项目，你需要将你的所有的依赖包悉数上传，别人使用的时候，除了你的项目源码外，还有所有的依赖包全部下载下来，才能保证别人使用的时候，不会因为版本问题导致项目不能如你预期那样正常运行。</li>
</ul>
<p>这些看似不是问题的问题，会给我们的开发使用过程变得非常难受。</p>
<h3 id="3-go-mod-的横空出世"><a href="#3-go-mod-的横空出世" class="headerlink" title="3. go mod 的横空出世"></a>3. go mod 的横空出世</h3><p>go modules 在 v1.11 版本正式推出，在最新发布的 v1.14 版本中，官方正式发话，称其已经足够成熟，可以应用于生产上。</p>
<blockquote>
<p>从 v1.11 开始，<code>go env</code> 多了个环境变量： <code>GO111MODULE</code> ，这里的 111，其实就是 v1.11 的象征标志， go 里好像很喜欢这样的命名方式，比如当初 vendor 出现的时候，也多了个 <code>GO15VENDOREXPERIMENT</code>环境变量，其中 15，表示的 vendor 是在 v1.5 时才诞生的。</p>
</blockquote>
<h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h4><p><code>GO111MODULE</code> 是一个开关，通过它可以开启或关闭 go mod 模式。</p>
<p>它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是 <code>auto</code>。</p>
<ol>
<li><code>GO111MODULE=off</code>：禁用模块支持，编译时会从 <code>GOPATH</code> 和 <code>vendor</code> 文件夹中查找包。</li>
<li><code>GO111MODULE=on</code>：启用模块支持，编译时会忽略 <code>GOPATH</code> 和 <code>vendor</code> 文件夹，只根据 <code>go.mod</code> 下载依赖。</li>
<li><code>GO111MODULE=auto</code>：如果当前目录不在 <code>$GOPATH/src</code> 并且当前目录（或者父目录）下有 <code>go.mod</code> 文件，则使用 <code>GO111MODULE</code>， 否则仍旧使用 GOPATH mode。</li>
</ol>
<p>go mod 出现后， GOPATH（肯定没人使用了） 和 GOVENDOR 将会且正在被逐步淘汰，但是若你的项目仍然要使用那些即将过时的包依赖管理方案，请注意将 GO111MODULE 置为 off。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go env -w GO111MODULE=<span class="string">&quot;off&quot;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="go-vendor"><a href="#go-vendor" class="headerlink" title="go vendor"></a>go vendor</h2><h3 id="go-vendor-简介"><a href="#go-vendor-简介" class="headerlink" title="go vendor 简介"></a>go vendor 简介</h3><p><a target="_blank" rel="noopener" href="https://github.com/kardianos/govendor">govendor</a> 是一个基于 <code>vendor</code> 目录机制的包管理工具。</p>
<p>在执行 <code>go build</code> 或 <code>go run</code> 命令时，会按照以下顺序去查找包：</p>
<ol>
<li>在当前vendor目录（如果当前目录存在vendor目录的话）查找依赖包；</li>
<li>如果当前目录不存在vendor目录，则到上一级目录继续查找；</li>
<li>重复步骤2，直到到达<code>$GOPATH/src</code>目录，查找vendor目录中是否存在依赖包；</li>
<li>如果没有查找到依赖包，则继续在<code>$GOROOT</code>目录查找；</li>
<li>如果还是没有查找到，则继续在<code>$GOPATH/src</code>目录查找。</li>
</ol>
<h3 id="go-vendor-功能"><a href="#go-vendor-功能" class="headerlink" title="go vendor 功能"></a>go vendor 功能</h3><ul>
<li>支持从项目源码中分析出依赖的包，并从 <code>$GOPATH</code> 复制到项目的 <code>vendor</code> 目录下；</li>
<li>支持包的指定版本，并用 <code>vendor/vendor.json</code> 进行包和版本管理；</li>
<li>支持用 <code>govendor add/update</code> 命令从 <code>$GOPATH</code> 中复制依赖包；</li>
<li>如果忽略了 <code>vendor/*/</code> 文件，可用 <code>govendor sync</code> 恢复依赖包；</li>
<li>可直接用 <code>govendor fetch</code> 添加或更新依赖包；</li>
<li>可用 <code>govendor migrate</code> 从其他 <code>vendor</code> 包管理工具中一键迁移到 <code>govendor</code>；</li>
<li>支持 Linux，macOS，Windows，甚至现有所有操作系统；</li>
<li>支持 Git、Hg、SVN，BZR（必须指定一个路径）；</li>
</ul>
<h3 id="go-vendor-使用建议"><a href="#go-vendor-使用建议" class="headerlink" title="go vendor 使用建议"></a>go vendor 使用建议</h3><ul>
<li>一个库工程（不包含 <code>main</code> 的 <code>package</code>）不应该在自己的版本控制中存储外部的包在 <code>vendor</code> 目录中，除非有特殊原因并且知道为什么要这么做。</li>
<li>在一个应用中，（包含 <code>main</code> 的 <code>package</code>），建议只有一个 <code>vendor</code> 目录，且在代码库一级目录。</li>
</ul>
<h3 id="go-vendor-命令"><a href="#go-vendor-命令" class="headerlink" title="go vendor 命令"></a>go vendor 命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>init</td>
<td>创建 vendor 目录和 vendor.json 文件</td>
</tr>
<tr>
<td>list</td>
<td>列出过滤依赖包及其状态</td>
</tr>
<tr>
<td>add</td>
<td>从 $GOPATH 复制包到项目 vendor 目录</td>
</tr>
<tr>
<td>update</td>
<td>从 $GOPATH 更新依赖包到项目 vendor 目录</td>
</tr>
<tr>
<td>remove</td>
<td>从 vendor 目录移除依赖的包</td>
</tr>
<tr>
<td>status</td>
<td>列出所有缺失、过期和修改过的包</td>
</tr>
<tr>
<td>fetch</td>
<td>从远程仓库添加或更新包到项目 vendor 目录(不会存储到 $GOPATH)</td>
</tr>
<tr>
<td>sync</td>
<td>根据 vendor.json 拉取相匹配的包到 vendor 目录</td>
</tr>
<tr>
<td>migrate</td>
<td>从其他基于 vendor 实现的包管理工具中一键迁移</td>
</tr>
<tr>
<td>get</td>
<td>与 go get 类似，将包下载到 $GOPATH，再将依赖包复制到 vendor 目录</td>
</tr>
<tr>
<td>license</td>
<td>列出所有依赖包的 LICENSE</td>
</tr>
<tr>
<td>shell</td>
<td>可一次性运行多个 govendor 命令</td>
</tr>
</tbody></table>
<h3 id="go-vendor-命令参数"><a href="#go-vendor-命令参数" class="headerlink" title="go vendor 命令参数"></a>go vendor 命令参数</h3><p>支持命令参数的子命令有：<code>list</code>、<code>add</code>、<code>update</code>、<code>remove</code>、<code>fetch</code></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>+local</td>
<td>I</td>
<td>本地包，即项目内部编写的包</td>
</tr>
<tr>
<td>+external</td>
<td>e</td>
<td>外部包，即在 GOPATH 中、却不在项目 vendor 目录</td>
</tr>
<tr>
<td>+vendor</td>
<td>v</td>
<td>已在 vendor 目录下的包</td>
</tr>
<tr>
<td>+std</td>
<td>s</td>
<td>标准库里的包</td>
</tr>
<tr>
<td>+excluded</td>
<td>x</td>
<td>明确被排除的外部包</td>
</tr>
<tr>
<td>+unused</td>
<td>u</td>
<td>未使用的包，即在 vendor 目录下，但项目中并未引用到</td>
</tr>
<tr>
<td>+missing</td>
<td>m</td>
<td>被引用了但却找不到的包</td>
</tr>
<tr>
<td>+program</td>
<td>p</td>
<td>主程序包，即可被编译为执行文件的包</td>
</tr>
<tr>
<td>+outside</td>
<td></td>
<td>相当于状态为 +external +missing</td>
</tr>
<tr>
<td>+all</td>
<td></td>
<td>所有包</td>
</tr>
</tbody></table>
<p>eg：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将远程库ones-ai-api-common的preview3分支的代码，拉到本地的vender目录中</span></span><br><span class="line">govendor fetch github.com/bangwork/ones-ai-api-common/utils/rediscache@preview3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用本地库ones-ai-api-common的代码，拉到本地的vendor目录中</span></span><br><span class="line">govendor update github.com/bangwork/ones-ai-api-common/...</span><br></pre></td></tr></table></figure>



<h3 id="go-vendor-使用"><a href="#go-vendor-使用" class="headerlink" title="go vendor 使用"></a>go vendor 使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/kardianos/govendor</span><br></pre></td></tr></table></figure>

<p>为了方便快捷使用 <code>govendor</code>，建议将 <code>$GOPATH/bin</code> 添加到 PATH 中。Linux/macOS 如下设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$GOPATH</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在项目根目录下执行以下命令进行 <code>vendor</code> 初始化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor init</span><br></pre></td></tr></table></figure>

<p>项目根目录下即会自动生成 <code>vendor</code> 目录和 <code>vendor.json</code> 文件。此时 <code>vendor.json</code> 文件内容为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;comment&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;ignore&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;package&quot;</span>: [],</span><br><span class="line">	<span class="attr">&quot;rootPath&quot;</span>: <span class="string">&quot;govendor-example&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="go-vendor-常用命令"><a href="#go-vendor-常用命令" class="headerlink" title="go vendor 常用命令"></a>go vendor 常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.将已被引用且在 `$GOPATH` 下的所有包复制到 `vendor` 目录</span></span><br><span class="line">govendor add +external</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.仅从 `$GOPATH` 中复制指定包</span></span><br><span class="line">govendor add gopkg.in/yaml.v2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.列出代码中所有被引用到的包及其状态</span></span><br><span class="line">govendor list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.列出一个包被哪些包引用</span></span><br><span class="line">govendor list -v fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.从远程仓库添加或更新某个包(不会在 `$GOPATH` 也存一份)</span></span><br><span class="line">govendor fetch golang.org/x/net/context</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.安装指定版本的包</span></span><br><span class="line">govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</span><br><span class="line">govendor fetch golang.org/x/net/context@v1   <span class="comment"># Get latest v1.*.* tag or branch.</span></span><br><span class="line">govendor fetch golang.org/x/net/context@=v1  <span class="comment"># Get the tag or branch named &quot;v1&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.只格式化项目自身代码(`vendor` 目录下的不变动)</span></span><br><span class="line">govendor fmt +<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.只构建编译项目内部的包</span></span><br><span class="line">govendor install +<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.只测试项目内部的测试案例</span></span><br><span class="line">govendor <span class="built_in">test</span> +<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10.构建所有 `vendor` 包</span></span><br><span class="line">govendor install +vendor,^program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11.拉取所有依赖的包到 `vendor` 目录(包括 `$GOPATH` 存在或不存在的包)</span></span><br><span class="line">govendor fetch +out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12.包已在 `vendor` 目录，但想从 `$GOPATH` 更新</span></span><br><span class="line">govendor update +vendor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13.已修改了 `$GOPATH` 里的某个包，现在想将已修改且未提交的包更新到 `vendor`</span></span><br><span class="line">govendor update -uncommitted &lt;updated-package-import-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 14.Fork 了某个包，但尚未合并，该如何引用到最新的代码包，此时将从 `myfork` 拉取代码，而不是 `normal`。</span></span><br><span class="line">govendor fetch github.com/normal/pkg::github.com/myfork/pkg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 15.`vendor.json` 中记录了依赖包信息，该如何拉取更新</span></span><br><span class="line">govendor sync</span><br></pre></td></tr></table></figure>



<h2 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h2><h3 id="Go-Modules-简介"><a href="#Go-Modules-简介" class="headerlink" title="Go Modules 简介"></a>Go Modules 简介</h3><p>开发过前端的同学对 node modules 一定印象深刻，得益于前端混乱的包管理，一个普通的 web 前端，其 node modules 往往非常巨大，而且它是每工程的，也就是说如果有 2 个前端工程，就会有两份巨大的 node moudles，里面有成千上万个文件，常常造成 IDE 挂死，也非常浪费硬盘。</p>
<p>那么，vendor 是不是到后期也会变成这样呢？同样的库，同样的版本，就因为在不同的工程里用了，就要在 vendor 里单独搞一份，不浪费吗？所以这些基于 vendor 的包管理工具，都会有这个问题。</p>
<p>相比之下 maven 这种本地缓存库的管理方式就好很多。</p>
<p>Golang 1.11 版本引入的 go mod ，其思想类似 maven：摒弃 vendor 和 GOPATH，拥抱本地库。</p>
<h3 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h3><p>go mod 不再依靠 $GOPATH，使得它可以脱离 GOPATH 来创建项目</p>
<p>我们在家目录下创建一个 go_test 的目录，用来创建项目</p>
<p><img src="/images/1147362-20200523085604482-87483501.png" alt="img"></p>
<p>接下来，进入项目目录，执行如下命令进行 go modules 的初始化</p>
<p><img src="/images/1147362-20200523085604764-1640862567.png" alt="img"></p>
<p>接下来很重要的一点，我们要看看 go install 把下载的包安装到哪里了？</p>
<p><img src="/images/1147362-20200523085605302-1959767225.png" alt="img"></p>
<p>上面我们观察到，在使用 go modules 模式后，项目目录下会多生成两个文件也就是 <code>go.mod</code> 和 <code>go.sum</code> 。</p>
<p><img src="/images/1147362-20200523085605609-1146641350.png" alt="img"></p>
<h3 id="go-mod-文件"><a href="#go-mod-文件" class="headerlink" title="go.mod 文件"></a>go.mod 文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module github.com/BingmingWong/module-test</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    example.com/apple v0.1.2</span><br><span class="line">    example.com/banana v1.2.3</span><br><span class="line">    example.com/banana/v2 v2.3.4</span><br><span class="line">    example.com/pear // indirect</span><br><span class="line">    example.com/strawberry // incompatible</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">exclude example.com/banana v1.2.4</span><br><span class="line">replace（</span><br><span class="line">    golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac</span><br><span class="line">    golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d</span><br><span class="line">    golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>module</code>：指定包的名字（路径）。即：模块的引用路径</li>
<li><code>go</code>：项目使用的 go 版本</li>
<li><code>require</code>：指定的依赖项模块。即：项目所需的直接依赖包及其版本</li>
<li><code>exclude</code>： 可以忽略依赖项模块。即：忽略指定版本的依赖包</li>
<li><code>replace</code>：指定的依赖项模块。由于在国内访问 golang.org/x 的各个包都需要翻墙，你可以在 go.mod 中使用 replace 替换成 github 上对应的库。</li>
</ul>
<h3 id="go-sum-文件"><a href="#go-sum-文件" class="headerlink" title="go.sum 文件"></a>go.sum 文件</h3><p>go.sum 文件：包含特定模块版本内容的预期加密哈希。</p>
<p>go 命令使用 go.sum 文件确保这些模块的未来下载检索与第一次下载相同的位，以确保项目所依赖的模块不会出现意外更改，无论是出于恶意、意外还是其他原因。 go.mod 和 go.sum 都应检入版本控制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat go.sum</span><br><span class="line">github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=</span><br><span class="line">github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=</span><br><span class="line">github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=</span><br><span class="line">github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=</span><br></pre></td></tr></table></figure>

<p>每一行都是由 <code>模块路径</code>，<code>模块版本</code>，<code>哈希检验值</code> 组成，其中哈希检验值是用来保证当前缓存的模块不会被篡改。hash 是以 <code>h1:</code> 开头的字符串，表示生成 checksum 的算法是第一版的 hash 算法（sha256）。</p>
<p>值得注意的是，为什么有的包只有一行</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span> <span class="tag">&lt;<span class="name">version</span>&gt;</span>/go.mod <span class="tag">&lt;<span class="name">hash</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而有的包却有两行呢</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span> <span class="tag">&lt;<span class="name">version</span>&gt;</span> <span class="tag">&lt;<span class="name">hash</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span> <span class="tag">&lt;<span class="name">version</span>&gt;</span>/go.mod <span class="tag">&lt;<span class="name">hash</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那些有两行的包，区别就在于 hash 值不一行，一个是 <code>h1:hash</code>，一个是 <code>go.mod h1:hash</code></p>
<p>而 <code>h1:hash</code> 和 <code>go.mod h1:hash</code> 两者，要不就是同时存在，要不就是只存在 <code>go.mod h1:hash</code>。那什么情况下会不存在 <code>h1:hash</code> 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的<code>h1 hash</code>，就会出现不存在 <code>h1 hash</code>，只存在 <code>go.mod h1:hash</code> 的情况。</p>
<p>go.mod 和 go.sum 是 go modules 版本管理的指导性文件，因此 go.mod 和 go.sum 文件都应该提交到你的 Git 仓库中去，避免其他人使用你写项目时，重新生成的 go.mod 和 go.sum 与你开发的基准版本的不一致。</p>
<blockquote>
<p>go.sum 不需要手工维护，所以可以不用太关注。 </p>
</blockquote>
<h3 id="go-mod-命令"><a href="#go-mod-命令" class="headerlink" title="go mod 命令"></a>go mod 命令</h3><p>golang 提供了 <code>go mod</code> 命令来管理包。go mod 有以下命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>download</td>
<td>download modules to local cache（下载依赖包，默认为 <code>$GOPATH/pkg/mod</code> 目录）</td>
</tr>
<tr>
<td>edit</td>
<td>edit go.mod from tools or scripts（编辑 go.mod 文件）</td>
</tr>
<tr>
<td>graph</td>
<td>print module requirement graph （打印模块依赖图）</td>
</tr>
<tr>
<td>init</td>
<td>initialize new module in current directory（在当前目录初始化 mod）</td>
</tr>
<tr>
<td>tidy</td>
<td>add missing and remove unused modules（拉取缺少的模块，移除不用的模块）</td>
</tr>
<tr>
<td>vendor</td>
<td>make vendored copy of dependencies（将依赖复制到 vendor 下）</td>
</tr>
<tr>
<td>verify</td>
<td>verify dependencies have expected content （验证依赖是否正确，模块是否被篡改过）</td>
</tr>
<tr>
<td>why</td>
<td>explain why packages or modules are needed（解释为什么需要依赖）</td>
</tr>
</tbody></table>
<p>执行 <code>go run </code>运行代码会发现 go mod 会自动查找依赖自动下载，接着我们查看 go.mod 内容</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="keyword">go</span>.mod</span><br><span class="line"></span><br><span class="line">module hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.12</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com/labstack/echo v3<span class="number">.3</span><span class="number">.10</span>+incompatible <span class="comment">// indirect</span></span><br><span class="line">	github.com/labstack/gommon v0<span class="number">.2</span><span class="number">.8</span> <span class="comment">// indirect</span></span><br><span class="line">	github.com/mattn/<span class="keyword">go</span>-colorable v0<span class="number">.1</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">	github.com/mattn/<span class="keyword">go</span>-isatty v0<span class="number">.0</span><span class="number">.7</span> <span class="comment">// indirect</span></span><br><span class="line">	github.com/valyala/fasttemplate v1<span class="number">.0</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">	golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190313024323</span>-a1f597ede03a <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>go module 安装 package 的原則是先拉最新的 release tag，若无tag则拉最新的commit</p>
<p> go 会自动生成一个 go.sum 文件来记录 dependency tree：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat go.sum</span><br><span class="line">github.com/labstack/<span class="built_in">echo</span> v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg=</span><br><span class="line">github.com/labstack/<span class="built_in">echo</span> v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s=</span><br><span class="line">github.com/labstack/gommon v0.2.8 h1:JvRqmeZcfrHC5u6uVleB4NxxNbzx6gpbJiQknDbKQu0=</span><br><span class="line">github.com/labstack/gommon v0.2.8/go.mod h1:/tj9csK2iPSBvn+3NLM9e52usepMtrd5ilFYA+wQNJ4=</span><br><span class="line">github.com/mattn/go-colorable v0.1.1 h1:G1f5SKeVxmagw/IyvzvtZE4Gybcc4Tr1tf7I8z0XgOg=</span><br><span class="line">github.com/mattn/go-colorable v0.1.1/go.mod h1:FuOcm+DKB9mbwrcAfNl7/TZVBZ6rcnceauSikq3lYCQ=</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>再次执行 <code>go run </code> 发现跳过了检查并安装依赖的步骤。</p>
<p>可以使用命令 <code>go list -m -u all</code> 来检查可以升级的 package，使用<code>go get -u need-upgrade-package</code> 升级后会将新的依赖版本更新到 go.mod * 也可以使用 <code>go get -u</code> 升级所有依赖</p>
<h3 id="mod基本操作"><a href="#mod基本操作" class="headerlink" title="mod基本操作"></a>mod基本操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个moudle，模块名为你项目名</span></span><br><span class="line">go mod init 模块名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载modules到本地cache</span></span><br><span class="line">go mod download</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑go.mod文件 选项有`-json`、`-require`和`-exclude`，可以使用帮助go help mod edit</span></span><br><span class="line">go mod edit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以文本模式打印模块需求图</span></span><br><span class="line">go mod graph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除错误或者不使用的modules</span></span><br><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成vendor目录</span></span><br><span class="line">go mod vendor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证依赖是否正确</span></span><br><span class="line">go mod verify</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找依赖</span></span><br><span class="line">go mod why</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go mod init      <span class="comment"># 初始化go.mod</span></span><br><span class="line">go mod tidy      <span class="comment"># 更新依赖文件</span></span><br><span class="line">go mod download  <span class="comment"># 下载依赖文件</span></span><br><span class="line">go mod vendor    <span class="comment"># 将依赖转移至本地的vendor文件</span></span><br><span class="line">go mod edit      <span class="comment"># 手动修改依赖文件</span></span><br><span class="line">go mod graph     <span class="comment"># 打印依赖图</span></span><br><span class="line">go mod verify    <span class="comment"># 校验依赖</span></span><br></pre></td></tr></table></figure>



<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h4 id="依赖的包下载到哪里了？还在-GOPATH-里吗？"><a href="#依赖的包下载到哪里了？还在-GOPATH-里吗？" class="headerlink" title="依赖的包下载到哪里了？还在 GOPATH 里吗？"></a>依赖的包下载到哪里了？还在 GOPATH 里吗？</h4><p>不在。使用 Go 的包管理方式，依赖的第三方包被下载到了 <code>$GOPATH/pkg/mod</code> 路径下。</p>
<h4 id="依赖包的版本是怎么控制的？"><a href="#依赖包的版本是怎么控制的？" class="headerlink" title="依赖包的版本是怎么控制的？"></a>依赖包的版本是怎么控制的？</h4><p>在上一个问题里，可以看到最终下载在 <code>$GOPATH/pkg/mod</code> 下的包中最后会有一个版本号 v1.0.5，也就是说，<code>$GOPATH/pkg/mod</code>里可以保存相同包的不同版本。</p>
<p>版本是在 go.mod 中指定的。如果，在 go.mod 中没有指定，go 命令会自动下载代码中的依赖的最新版本。如果，在 go.mod 用 require 语句指定包和版本 ，go 命令会根据指定的路径和版本下载包，指定版本时可以用 <code>latest</code>，这样它会自动下载指定包的最新版本。</p>
<h4 id="可以把项目放在-GOPATH-src-下吗？"><a href="#可以把项目放在-GOPATH-src-下吗？" class="headerlink" title="可以把项目放在 $GOPATH/src 下吗？"></a>可以把项目放在 $GOPATH/src 下吗？</h4><p>可以。但是 go 会根据 GO111MODULE 的值而采取不同的处理方式，默认情况下，<code>GO111MODULE=auto</code> 自动模式</p>
<ul>
<li>auto 自动模式下，项目在 <code>$GOPATH/src</code> 里会使用 <code>$GOPATH/src</code> 的依赖包，在 $GOPATH/src 外，就使用 go.mod 里 require 的包</li>
<li>on 开启模式，1.12后，无论在 <code>$GOPATH/src</code> 里还是在外面，都会使用 go.mod 里 require 的包</li>
<li>off 关闭模式，就是老规矩。</li>
</ul>
<h4 id="依赖包中的地址失效了怎么办？比如-golang-org-x-…-下的包都无法下载怎么办？"><a href="#依赖包中的地址失效了怎么办？比如-golang-org-x-…-下的包都无法下载怎么办？" class="headerlink" title="依赖包中的地址失效了怎么办？比如 golang.org/x/… 下的包都无法下载怎么办？"></a>依赖包中的地址失效了怎么办？比如 golang.org/x/… 下的包都无法下载怎么办？</h4><p>在 go 快速发展的过程中，有一些依赖包地址变更了。以前的做法：</p>
<ol>
<li>修改源码，用新路径替换 import 的地址</li>
<li>git clone 或 go get 新包后，copy 到 $GOPATH/src 里旧的路径下</li>
</ol>
<p>无论什么方法，都不便于维护，特别是多人协同开发时。使用 go.mod 就简单了，在 go.mod 文件里用 replace 替换包，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace golang.org/x/text =&gt; github.com/golang/text latest</span><br></pre></td></tr></table></figure>

<p>这样，go 会用 github.com/golang/text 替代 golang.org/x/text，原理就是下载 github.com/golang/text 的最新版本到 <code>$GOPATH/pkg/mod/golang.org/x/text </code>下。</p>
<h4 id="init-生成的-go-mod-的模块名称有什么用？"><a href="#init-生成的-go-mod-的模块名称有什么用？" class="headerlink" title="init 生成的 go.mod 的模块名称有什么用？"></a>init 生成的 go.mod 的模块名称有什么用？</h4><p>本例里，用 <code>go mod init hello</code> 生成的 go.mod 文件里的第一行会申明 <code>module hello</code>。</p>
<p>因为我们的项目已经不在 <code>$GOPATH/src </code>里了，那么引用自己怎么办？就用模块名+路径。</p>
<p>例如，在项目下新建目录 utils，创建一个tools.go文件:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> “fmt”</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintText</span><span class="params">(text <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在根目录下的 hello.go 文件就可以 <code>import “hello/utils”</code> 引用 utils</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;hello/utils&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/astaxie/beego&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    utils.PrintText(<span class="string">&quot;Hi&quot;</span>)</span><br><span class="line">    beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="以前老项目如何用新的包管理"><a href="#以前老项目如何用新的包管理" class="headerlink" title="以前老项目如何用新的包管理"></a>以前老项目如何用新的包管理</h4><ol>
<li>如果用 auto 模式，把项目移动到 <code>$GOPATH/src</code> 外</li>
<li>进入目录，运行 <code>go mod init + 模块名称</code></li>
<li><code>go build</code> 或者 <code>go run</code> 一次</li>
</ol>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wongbingming/p/12941021.html">Go Modules 前世今生及入门使用</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>