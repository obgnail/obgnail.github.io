<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Unix domain socket (UDS)，用于实现同一主机上的进程间通信。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Unix domain socket 简介 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Computer-Network/" rel="tag">Computer Network</a></div><div class="post-time">2022-03-29</div></div></div><div class="container post-header"><h1>Unix domain socket 简介</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPC-%E4%B8%8E-UDS"><span class="toc-number">2.</span> <span class="toc-text">IPC 与 UDS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">共享内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">3.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#quick-start"><span class="toc-number">5.</span> <span class="toc-text">quick start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#demo%EF%BC%9Ahttp-unix-socket-%E9%80%9A%E4%BF%A1"><span class="toc-number">6.</span> <span class="toc-text">demo：http+unix socket 通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#demo%EF%BC%9Apython-version"><span class="toc-number">7.</span> <span class="toc-text">demo：python version</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Unix domain socket (UDS)，用于实现同一主机上的进程间通信。</p>
<blockquote>
<p>A <code>Unix domain socket</code> or <code>IPC socket</code> (inter-process communication socket) is a data communications endpoint for exchanging data between processes executing on the same host operating system.</p>
</blockquote>
<p>socket 原本是为网络通讯设计的，但后来在 socket 的框架上发展出一种 IPC 机制，就是 UNIX domain socket。</p>
<p>虽然网络 socket 也可用于同一台主机的进程间通讯 (通过 loopback 地址 127.0.0.1)，但是 UNIX domain socket 用于 IPC 更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是<strong>将应用层数据从一个进程拷贝到另一个进程</strong>。这是因为，<strong>IPC 机制本质上是可靠的通讯</strong>，而网络协议是为不可靠的通讯设计的。</p>
<p>Unix domain socket 是 POSIX 标准中的一个组件，所以不要被名字迷惑，linux 系统也是支持它的。</p>
<h2 id="IPC-与-UDS"><a href="#IPC-与-UDS" class="headerlink" title="IPC 与 UDS"></a>IPC 与 UDS</h2><ul>
<li><code>IPC</code> (inter-process communication) ：进程间通信。这是一种通讯方式或通讯机制。进程间通信包括同一设备上的不同进程和不同设备上的不同进程。不同设备上的不同进程通信就涉及到网络。Socket 在网络通信领域广泛应用 被称为 Network Socket。</li>
<li><code>UDS</code> 是 IPC 的其中一种解决方案。UNIX domain socket 是全双工的，API 接口语义丰富，相比其它 IPC 机制有明显的优越性，目前已成为使用最广泛的 IPC 机制，比如 X Window 服务器和 GUI 程序之间就是通过 UNIX domain socket 通讯的。</li>
</ul>
<p>进程间通信有几种稳定、有效的方式几乎被所有的操作系统采用：</p>
<ul>
<li>共享内存（Shared Memory）</li>
<li>管道（Pipe）</li>
<li>Unix Domain Socket </li>
<li>RPC（Remote Procedure Calls 远程调用）</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>进程一与进程二通过 “共享内存” 通信</p>
<ol>
<li>step1：进程一在内存中申请一块共享区域，申请的共享区域与某个特定 key 绑定。</li>
<li>step2：将共享区域映射到进程一的空间（这样才能进一步操作）。</li>
<li>step3：进程二调用 api 通入同一个 key 将共享区域映射到进程二。</li>
<li>step4：对共享区域读写进程信息交换。</li>
<li>step5：完成通信后，各个进程撤销之前的映射操作</li>
<li>step6：删除共享区域，回收内存。</li>
</ol>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>UNIX Domain Socket 经常用于两个没有亲缘关系的进程。</p>
<ul>
<li>UDS 传输不需要经过网络协议栈，不需要打包拆包等操作，只是数据的拷贝过程。</li>
<li>UDS 有 SOCK_DGRAM (流套接字)  或 SOCK_STREAM (数据包套接字) 两种工作模式，类似于 UDP 和 TCP，但是面向消息的 UNIX Domain Socket 也是<code>可靠</code>的，消息既不会丢失也不会顺序错乱。</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>如果熟悉 Socket 的话，UDS 也是同样的方式，区别如下:</p>
<ul>
<li>UDS 不需要 IP 和 Port，而是通过一个文件名来表示（通过文件路径来表示 “网络地址”）</li>
<li>domain 为 AF_UNIX</li>
<li>UDS 中使用 sockaddr_un 表示 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family; <span class="comment">/* AF_UNIX */</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[UNIX_PATH_MAX];   <span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务端： socket -&gt; bind -&gt; listen -&gt; accet -&gt; recv/send -&gt; close<br>客户端： socket -&gt; connect -&gt; recv/send -&gt; close</p>
<h2 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h2><p>go 中原生的 net 包包含了对 unix socket 通信的封装，关键语句为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端：</span></span><br><span class="line"><span class="keyword">const</span> sockAddr=<span class="string">&quot;file path&quot;</span></span><br><span class="line">client, err := net.Dial(<span class="string">&quot;unix&quot;</span>, sockAddr)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">const</span> sockAddr=<span class="string">&quot;file path&quot;</span></span><br><span class="line">l, err := net.Listen(<span class="string">&quot;unix&quot;</span>, sockAddr)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;accept error:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> handler(conn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn *net.UnixConn)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意同 tcp 方式不同在于，这里的地址不再是一个类似 127.0.0.1:xxx 这样的端口号，而是一个 <code>.sock</code> 文件的地址，文件地址可以自己选定。</p>
<p>设定地址和 sock 文件名后，服务端启动成功后会在对应目录生成该 sock 文件。由于已经存在该文件，服务会启动失败，因此在每次启动前都应该先移除该文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.Remove(sockAddr)</span><br></pre></td></tr></table></figure>



<h2 id="demo：http-unix-socket-通信"><a href="#demo：http-unix-socket-通信" class="headerlink" title="demo：http+unix socket 通信"></a>demo：http+unix socket 通信</h2><p>由于 http 协议位于应用程序，tcp 位于传输层，<strong>socket 位于两层之间</strong>，因此 http 和 unix socket 是并不冲突的，虽然只依靠 unix socket 就能实现两个进程间的通信，但是考虑到原有项目是基于 http 的，因此还是需要保留 http 调用方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sockAddr = <span class="string">&quot;D:/GoCode/go/src/http_unix_socket_demo/http.sock&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.New()</span><br><span class="line">	router.GET(<span class="string">&quot;/testGet&quot;</span>, handlerGet)</span><br><span class="line">	os.Remove(sockAddr)</span><br><span class="line">  </span><br><span class="line">	unixAddr, err := net.ResolveUnixAddr(<span class="string">&quot;unix&quot;</span>, sockAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	listener, err := net.ListenUnix(<span class="string">&quot;unix&quot;</span>, unixAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;listening error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;listening...&quot;</span>)</span><br><span class="line">	http.Serve(listener, router)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerGet</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;resp&quot;</span>: <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestClientGet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	httpc := http.Client&#123;</span><br><span class="line">		Transport: &amp;http.Transport&#123;</span><br><span class="line">			DialContext: <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, _, _ <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">				<span class="keyword">return</span> net.Dial(<span class="string">&quot;unix&quot;</span>, sockAddr)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := httpc.Get(<span class="string">&quot;http://http.sock/testGet&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		t.Fail()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="demo：python-version"><a href="#demo：python-version" class="headerlink" title="demo：python version"></a>demo：python version</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">server_address = <span class="string">&#x27;./uds_socket&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make sure the socket does not already exist</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.unlink(server_address)</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(server_address):</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a UDS socket</span></span><br><span class="line">sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind the socket to the address</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;starting up on &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(server_address))</span><br><span class="line"></span><br><span class="line">sock.bind(server_address)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Listen for incoming connections</span></span><br><span class="line">sock.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Wait for a connection</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting for a connection&#x27;</span>)</span><br><span class="line">    connection, client_address = sock.accept()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;connection from&#x27;</span>, client_address)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Receive the data in small chunks and retransmit it</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = connection.recv(<span class="number">16</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;received &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;sending data back to the client&#x27;</span>)</span><br><span class="line">                connection.sendall(data)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;no data from&#x27;</span>, client_address)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># Clean up the connection</span></span><br><span class="line">        connection.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a UDS socket</span></span><br><span class="line">sock = socket.socket(family=socket.AF_UNIX, <span class="built_in">type</span>=socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect the socket to the port where the server is listening</span></span><br><span class="line">server_address = <span class="string">&#x27;./uds_socket&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;connecting to &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(server_address))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sock.connect(server_address)</span><br><span class="line"><span class="keyword">except</span> socket.error <span class="keyword">as</span> msg:</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Send data</span></span><br><span class="line">    message = <span class="string">b&#x27;This is the message.  It will be repeated.&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;sending &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(message))</span><br><span class="line">    sock.sendall(message)</span><br><span class="line"></span><br><span class="line">    amount_received = <span class="number">0</span></span><br><span class="line">    amount_expected = <span class="built_in">len</span>(message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> amount_received &lt; amount_expected:</span><br><span class="line">        data = sock.recv(<span class="number">16</span>)</span><br><span class="line">        amount_received += <span class="built_in">len</span>(data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;received &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;closing socket&#x27;</span>)</span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure>



<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/8359028.html">Unix domain socket 简介</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33399567/article/details/107691339">golang 中基于 http 和 unix socket 的通信代码实现（服务端基于 gin 框架）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangcaisheng_/article/details/50592687">进程间通信简介（一）</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000038476761">unix domain socket 浅析</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>