<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="RPC（Remote Procedure Call）远程过程调用，它可以使一台主机上的进程调用另一台主机的进程，由以访为其他若干个主机提供服务，也就是我们常说的 C/S 服务，Server 与 Client 之间通过 rpc 方式进行通信。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>net_rpc | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-03-29</div></div></div><div class="container post-header"><h1>net_rpc</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Server-%E5%92%8C-Client"><span class="toc-number">1.</span> <span class="toc-text">Server 和 Client</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#server"><span class="toc-number">1.1.</span> <span class="toc-text">server</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Server-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">Server 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-server-Server-Register-rcvr-interface-error"><span class="toc-number">1.1.2.</span> <span class="toc-text">func (server *Server) Register(rcvr interface{}) error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">监听器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">服务端处理请求的相关方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#client"><span class="toc-number">1.2.</span> <span class="toc-text">client</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Client-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">Client 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA-Client"><span class="toc-number">1.2.2.</span> <span class="toc-text">新建一个 Client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">连接服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.4.</span> <span class="toc-text">调用服务端的服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD-Client"><span class="toc-number">1.2.5.</span> <span class="toc-text">关闭 Client</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84-JSON-RPC"><span class="toc-number">2.</span> <span class="toc-text">go 语言标准库中的 JSON-RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5-Server-%E7%AB%AF"><span class="toc-number">2.1.</span> <span class="toc-text">连接 Server 端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-CLient"><span class="toc-number">2.2.</span> <span class="toc-text">创建 CLient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">处理客户端连接请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo%EF%BC%9Arpc-%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">Demo：rpc 通信的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Http-%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">1. Http 方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TCP-%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">2. TCP 方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-jsonrpc-%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3. jsonrpc 方式</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>RPC（Remote Procedure Call）远程过程调用，它可以使一台主机上的进程调用另一台主机的进程，由以访为其他若干个主机提供服务，也就是我们常说的 C/S 服务，Server 与 Client 之间通过 rpc 方式进行通信。</p>
<p>Go 标准包中已经提供了对 RPC 的支持，支持三个级别的 RPC：TCP、HTTP、JSONRPC。Go 的 RPC 包与传统的 RPC 系统不同，他只支持 Go 开发的服务器与客户端之间的交互，因为在内部，它们采用了 Gob 来编码。</p>
<p>Go RPC 的函数要满足下面的条件才能够被远程调用，不然会被忽略：</p>
<ul>
<li>函数必须是导出的，即首字母为大写。</li>
<li>必须有两个导出类型的参数。</li>
<li>第一个参数是接收的参数，第二个参数是返回给客户端的参数，第二个参数必须是指针类型的。</li>
<li>函数还要有一个 error 类型返回值。方法的返回值，如果非 nil，将被作为字符串回传，在客户端看来就和 errors.New 创建的一样。如果返回了错误，回复的参数将不会被发送给客户端。</li>
</ul>
<p>举个例子，正确的 RPC 函数格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t *T) MethidName(argType T1, replyType *T2) error</span><br></pre></td></tr></table></figure>

<p>T、T1 和 T2 类型都必须能被 encoding/gob 包编解码</p>
<p>任何 RPC 都需要通过网络来传递数据，Go RPC 可以利用 HTTP 和 TCP 来传递数据</p>
<h2 id="Server-和-Client"><a href="#Server-和-Client" class="headerlink" title="Server 和 Client"></a>Server 和 Client</h2><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><h4 id="Server-对象"><a href="#Server-对象" class="headerlink" title="Server 对象"></a>Server 对象</h4><p>在 Server 对象中定义了互斥锁用来保护请求数据，另外还包含请求信息和返回的信息以及注册的服务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server represents an RPC Server.</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	serviceMap sync.Map   <span class="comment">// map[string]*service</span></span><br><span class="line">	reqLock    sync.Mutex <span class="comment">// protects freeReq</span></span><br><span class="line">	freeReq    *Request</span><br><span class="line">	respLock   sync.Mutex <span class="comment">// protects freeResp</span></span><br><span class="line">	freeResp   *Response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 NewServer 初始化一个 Server 对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServer returns a new Server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">()</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Server&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server 对象有 8 个方法，下面进行介绍。</p>
<h4 id="func-server-Server-Register-rcvr-interface-error"><a href="#func-server-Server-Register-rcvr-interface-error" class="headerlink" title="func (server *Server) Register(rcvr interface{}) error"></a>func (server *Server) Register(rcvr interface{}) error</h4><p>Register 用来向 Server 注册 rpc 服务，rpc 服务必须满足下面五种要求：</p>
<ul>
<li>函数必须是导出的</li>
<li>必须有两个导出类型参数</li>
<li>第一个参数是接收参数</li>
<li>第二个参数是返回给客户端参数，必须是指针类型</li>
<li>函数还要有一个返回值 error</li>
</ul>
<p>注册之后的服务，Client 可以进行远程调用。</p>
<p>还有一个和 Registry 类似的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterName类似Register，但使用提供的name代替rcvr的具体类型名作为服务名。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">RegisterName</span><span class="params">(name <span class="keyword">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> server.register(rcvr, name, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept接收监听器l获取的连接，然后服务每一个连接。Accept会阻塞，调用者应另开线程：&quot;go server.Accept(l)&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">Accept</span><span class="params">(lis net.Listener)</span></span></span><br></pre></td></tr></table></figure>



<h4 id="服务端处理请求的相关方法"><a href="#服务端处理请求的相关方法" class="headerlink" title="服务端处理请求的相关方法"></a>服务端处理请求的相关方法</h4><ul>
<li><p>ServeConn 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeConn在单个连接上执行server。ServeConn会阻塞，服务该连接直到客户端挂起。</span></span><br><span class="line"><span class="comment">// 调用者一般应另开线程调用本函数：&quot;go server.ServeConn(conn)&quot;。ServeConn在该连接使用gob（参见encoding/gob包）有线格式。</span></span><br><span class="line"><span class="comment">// 要使用其他的编解码器，可调用ServeCodec方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeConn</span><span class="params">(conn io.ReadWriteCloser)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>ServeCodec 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeCodec类似ServeConn，但使用指定的编解码器，以编码请求主体和解码回复主体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeCodec</span><span class="params">(codec ServerCodec)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>ServeRequest 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeRequest类似ServeCodec，但异步的服务单个请求。它不会在调用结束后关闭codec。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeRequest</span><span class="params">(codec ServerCodec)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>ServeHTTP 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP实现了回应RPC请求的http.Handler接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>HandleHTTP 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleHTTP注册server的RPC信息HTTP处理器对应到rpcPath，注册server的debug信息HTTP处理器对应到debugPath。</span></span><br><span class="line"><span class="comment">// HandleHTTP会注册到http.DefaultServeMux。之后，仍需要调用http.Serve()，一般会另开线程：&quot;go http.Serve(l, nil)&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">HandleHTTP</span><span class="params">(rpcPath, debugPath <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><h4 id="Client-对象"><a href="#Client-对象" class="headerlink" title="Client 对象"></a>Client 对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client类型代表RPC客户端。同一个客户端可能有多个未返回的调用，也可能被多个go程同时使用。</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	codec ClientCodec</span><br><span class="line"></span><br><span class="line">	reqMutex sync.Mutex <span class="comment">// protects following</span></span><br><span class="line">	request  Request</span><br><span class="line"></span><br><span class="line">	mutex    sync.Mutex <span class="comment">// protects following</span></span><br><span class="line">	seq      <span class="keyword">uint64</span></span><br><span class="line">	pending  <span class="keyword">map</span>[<span class="keyword">uint64</span>]*Call</span><br><span class="line">	closing  <span class="keyword">bool</span> <span class="comment">// user has called Close</span></span><br><span class="line">	shutdown <span class="keyword">bool</span> <span class="comment">// server has told us to stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="新建一个-Client"><a href="#新建一个-Client" class="headerlink" title="新建一个 Client"></a>新建一个 Client</h4><ul>
<li><p>初始化一个 Client</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewClient返回一个新的Client，以管理对连接另一端的服务的请求。它添加缓冲到连接的写入侧，以便将回复的头域和有效负载作为一个单元发送。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn io.ReadWriteCloser)</span> *<span class="title">Client</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化一个 Client 并指定编码器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外还有一个NewClientWithCodec方法，NewClientWithCodec类似NewClient，但使用指定的编解码器，以编码请求主体和解码回复主体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClientWithCodec</span><span class="params">(codec ClientCodec)</span> *<span class="title">Client</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="连接服务端"><a href="#连接服务端" class="headerlink" title="连接服务端"></a>连接服务端</h4><ul>
<li><p>通过指定的网络和地址与 RPC 服务端连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>通过指定的网络和地址与在默认 HTTP RPC 路径监听的 HTTP RPC 服务端连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialHTTP</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>通过在指定的网络、地址和路径与 HTTP RPC 服务端连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialHTTPPath</span><span class="params">(network, address, path <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="调用服务端的服务"><a href="#调用服务端的服务" class="headerlink" title="调用服务端的服务"></a>调用服务端的服务</h4><ul>
<li><p>Call 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call调用指定的方法，等待调用返回，将结果写入reply，然后返回执行的错误状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Call</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>异步调用（Go 方法）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go异步的调用函数。</span></span><br><span class="line"><span class="comment">// 本方法Call结构体类型指针的返回值代表该次远程调用。通道类型的参数done会在本次调用完成时发出信号（通过返回本次Go方法的返回值）。</span></span><br><span class="line"><span class="comment">// 如果done为nil，Go会申请一个新的通道（写入返回值的Done字段）；如果done非nil，done必须有缓冲，否则Go方法会故意崩溃。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Go</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;, done <span class="keyword">chan</span> *Call)</span> *<span class="title">Call</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="关闭-Client"><a href="#关闭-Client" class="headerlink" title="关闭 Client"></a>关闭 Client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>



<h2 id="go-语言标准库中的-JSON-RPC"><a href="#go-语言标准库中的-JSON-RPC" class="headerlink" title="go 语言标准库中的 JSON-RPC"></a>go 语言标准库中的 JSON-RPC</h2><blockquote>
<p>JSON-RPC，是一个无状态且轻量级的远程过程调用（RPC）传送协议，其传递内容通过 JSON 为主。相较于一般的 REST 通过网址（如 GET /user）调用远程服务器，JSON-RPC 直接在内容中定义了欲调用的函数名称（如 {“method”: “getUser”}），这也令开发者不会陷于该使用 PUT 或者 PATCH 的问题之中。</p>
<p>更多 JSON-RPC 约定参见：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JSON-RPC">https://zh.wikipedia.org/wiki/JSON-RPC</a></p>
</blockquote>
<h3 id="连接-Server-端"><a href="#连接-Server-端" class="headerlink" title="连接 Server 端"></a>连接 Server 端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dial在指定的网络和地址连接一个JSON-RPC服务端。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(*rpc.Client, error)</span></span></span><br></pre></td></tr></table></figure>



<h3 id="创建-CLient"><a href="#创建-CLient" class="headerlink" title="创建 CLient"></a>创建 CLient</h3><ul>
<li><p>NewClient</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewClient返回一个新的rpc.Client，以管理对连接另一端的服务的请求。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn io.ReadWriteCloser)</span> *<span class="title">rpc</span>.<span class="title">Client</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>NewClientCodec</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewClientCodec返回一个在连接上使用JSON-RPC的rpc.ClientCodec。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClientCodec</span><span class="params">(conn io.ReadWriteCloser)</span> <span class="title">rpc</span>.<span class="title">ClientCodec</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>NewServerCodec</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServerCodec返回一个在连接上使用JSON-RPC的rpc. ServerCodec。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServerCodec</span><span class="params">(conn io.ReadWriteCloser)</span> <span class="title">rpc</span>.<span class="title">ServerCodec</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="处理客户端连接请求"><a href="#处理客户端连接请求" class="headerlink" title="处理客户端连接请求"></a>处理客户端连接请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeConn在单个连接上执行DefaultServer。ServeConn会阻塞，服务该连接直到客户端挂起。</span></span><br><span class="line"><span class="comment">// 调用者一般应另开线程调用本函数：&quot;go serveConn(conn)&quot;。ServeConn在该连接使用JSON编解码格式。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeConn</span><span class="params">(conn io.ReadWriteCloser)</span></span></span><br></pre></td></tr></table></figure>



<h2 id="Demo：rpc-通信的三种方式"><a href="#Demo：rpc-通信的三种方式" class="headerlink" title="Demo：rpc 通信的三种方式"></a>Demo：rpc 通信的三种方式</h2><p>使用 rpc 方式通信需要通过下面几步才能完成：</p>
<p><strong>Server 端：</strong></p>
<ul>
<li>初始化一个 Server 对象</li>
<li>注册服务</li>
<li>绑定处理器</li>
<li>监听服务</li>
</ul>
<p><strong>Client 端：</strong></p>
<ul>
<li>初始化一个 Client 对象</li>
<li>连接 RPC 服务端</li>
<li>发送请求</li>
<li>接收返回值</li>
</ul>
<p>下面介绍 net/rpc 的三种连接方式。</p>
<h3 id="1-Http-方式"><a href="#1-Http-方式" class="headerlink" title="1. Http 方式"></a>1. Http 方式</h3><p>Server 端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	School <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RpcServer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RpcServer)</span> <span class="title">Introduce</span><span class="params">(student Student, words *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;student: &quot;</span>, student)</span><br><span class="line">	*words = fmt.Sprintf(<span class="string">&quot;Hello everyone, my name is %s, and I am from %s&quot;</span>, student.Name, student.School)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpcServer := <span class="built_in">new</span>(RpcServer)</span><br><span class="line">	<span class="comment">// 注册rpc服务</span></span><br><span class="line">	_ = rpc.Register(rpcServer)</span><br><span class="line">	<span class="comment">//把服务处理绑定到http协议上</span></span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line">	log.Println(<span class="string">&quot;http rpc service start success addr:8080&quot;</span>)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client 端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name   <span class="keyword">string</span></span><br><span class="line">		School <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 连接RPC服务端 Dial会调用NewClient初始化一个Client</span></span><br><span class="line">	client, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line">	<span class="comment">// 发送请求</span></span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;RpcServer.Introduce&quot;</span>, &amp;Student&#123;Name: <span class="string">&quot;random_w&quot;</span>, School: <span class="string">&quot;Secret&quot;</span>&#125;, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>启动服务端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run httpRPC.go</span><br><span class="line">2020/07/15 16:28:30 http rpc service start success addr:8080</span><br><span class="line">student:  &#123;random_w Secret&#125;</span><br></pre></td></tr></table></figure>

<p>启动客户端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run httpRPCClient.go</span><br><span class="line">Hello everyone, my name is random_w, and I am from Secret</span><br></pre></td></tr></table></figure>

<p>从客户端的日志可以看到我们成功执行了服务端的 Introduce 方法，服务端的日志中也显示了接收到的 Student 信息。</p>
<h3 id="2-TCP-方式"><a href="#2-TCP-方式" class="headerlink" title="2. TCP 方式"></a>2. TCP 方式</h3><p>Server 端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	School <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RpcServer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RpcServer)</span> <span class="title">Introduce</span><span class="params">(student Student, words *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;student: &quot;</span>, student)</span><br><span class="line">	*words = fmt.Sprintf(<span class="string">&quot;Hello everyone, my name is %s, and I am from %s&quot;</span>, student.Name, student.School)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpcServer := <span class="built_in">new</span>(RpcServer)</span><br><span class="line">	<span class="comment">// 注册rpc服务</span></span><br><span class="line">	_ = rpc.Register(rpcServer)</span><br><span class="line">	<span class="comment">// 指定rpc模式为TCP模式，地址为127.0.0.1:8081</span></span><br><span class="line">	tcpAddr, _ := net.ResolveTCPAddr(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8081&quot;</span>)</span><br><span class="line">	tcpListen, err := net.ListenTCP(<span class="string">&quot;tcp&quot;</span>, tcpAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;tcp rpc service start success addr:8081&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 监听Client发送的请求</span></span><br><span class="line">		conn, err3 := tcpListen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 创建一个goroutine处理请求</span></span><br><span class="line">		<span class="keyword">go</span> rpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client 端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name   <span class="keyword">string</span></span><br><span class="line">		School <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 连接RPC服务端 Dial会调用NewClient初始化一个Client</span></span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8081&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line">	<span class="comment">// 发送请求</span></span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;RpcServer.Introduce&quot;</span>, &amp;Student&#123;Name: <span class="string">&quot;random_w&quot;</span>, School: <span class="string">&quot;Secret&quot;</span>&#125;, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>启动服务端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run tcpRPC.go</span><br><span class="line">2020/07/15 16:13:21 tcp rpc service start success addr:8081</span><br><span class="line">student:  &#123;random_w Secret&#125;</span><br></pre></td></tr></table></figure>

<p>运行客户端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run tcpRPCClient.go</span><br><span class="line">Hello everyone, my name is random_w, and I am from Secret</span><br></pre></td></tr></table></figure>

<p>从客户端的日志可以看到我们成功执行了服务端的 Introduce 方法，服务端的日志中也显示了接收到的 Student 信息。</p>
<h3 id="3-jsonrpc-方式"><a href="#3-jsonrpc-方式" class="headerlink" title="3. jsonrpc 方式"></a>3. jsonrpc 方式</h3><p>jsonrpc 方式支持跨语言调用。</p>
<p>Server 端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	School <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RpcServer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RpcServer)</span> <span class="title">Introduce</span><span class="params">(student Student, words *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;student: &quot;</span>, student)</span><br><span class="line">	*words = fmt.Sprintf(<span class="string">&quot;Hello everyone, my name is %s, and I am from %s&quot;</span>, student.Name, student.School)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpcServer := <span class="built_in">new</span>(RpcServer)</span><br><span class="line">	<span class="comment">// 注册rpc服务</span></span><br><span class="line">	_ = rpc.Register(rpcServer)</span><br><span class="line">  <span class="comment">// jsonrpc是基于TCP协议的，现在他还不支持http协议</span></span><br><span class="line">	tcpAddr, _ := net.ResolveTCPAddr(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8082&quot;</span>)</span><br><span class="line">	tcpListen, err := net.ListenTCP(<span class="string">&quot;tcp&quot;</span>, tcpAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;tcp json-rpc service start success addr:8082&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 监听客户端请求</span></span><br><span class="line">		conn, err3 := tcpListen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> jsonrpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client 端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name   <span class="keyword">string</span></span><br><span class="line">		School <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	client, err := jsonrpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8082&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line">	<span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 发送json格式的数据</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;RpcServer.Introduce&quot;</span>, &amp;Student&#123;</span><br><span class="line">		Name:   <span class="string">&quot;random_w&quot;</span>,</span><br><span class="line">		School: <span class="string">&quot;Secret&quot;</span>,</span><br><span class="line">	&#125;, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>启动服务端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run jsonRPC.go</span><br><span class="line">2020/07/15 17:15:42 tcp json-rpc service start success addr:8082</span><br><span class="line">student:  &#123;random_w Secret&#125;</span><br></pre></td></tr></table></figure>

<p>运行客户端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run jsonRPCClient.go</span><br><span class="line">Hello everyone, my name is random_w, and I am from Secret</span><br></pre></td></tr></table></figure>

<p>从客户端的日志可以看到我们成功执行了服务端的 Introduce 方法，服务端的日志中也显示了接收到的 Student 信息。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>