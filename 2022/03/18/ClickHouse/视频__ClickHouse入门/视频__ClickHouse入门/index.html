<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;OLTP-与-OLAP&quot;&gt;&lt;a href=&quot;#OLTP-与-OLAP&quot; class=&quot;headerlink&quot; title=&quot;OLTP 与 OLAP&quot;&gt;&lt;/a&gt;OLTP 与 OLAP&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;OLTP（On-Line Transaction Processing）：联机事务处理&lt;/li&gt;
&lt;li&gt;OLAP（On-Line Analytical Processing）：联机分析处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从字面上来看 OLTP 是做事务处理，OLAP 是做分析处理。&lt;strong&gt;从对数据库操作来看，OLTP 主要是对数据的增删改，OLAP 是对数据的查询&lt;/strong&gt;。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>ClickHouse入门 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/ClickHouse/" rel="tag">ClickHouse</a></div><div class="post-time">2022-03-18</div></div></div><div class="container post-header"><h1>ClickHouse入门</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#OLTP-%E4%B8%8E-OLAP"><span class="toc-number">1.</span> <span class="toc-text">OLTP 与 OLAP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OLTP-%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text">OLTP 的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OLAP-%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.</span> <span class="toc-text">OLAP 的特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClickHouse-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">ClickHouse 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">列式存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%90%9E%E5%90%90%E5%86%99%E5%85%A5%E8%83%BD%E5%8A%9B"><span class="toc-number">2.2.</span> <span class="toc-text">高吞吐写入能力</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array"><span class="toc-number">3.2.1.</span> <span class="toc-text">Array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tuple"><span class="toc-number">3.2.2.</span> <span class="toc-text">Tuple</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enum"><span class="toc-number">3.2.3.</span> <span class="toc-text">Enum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nested"><span class="toc-number">3.2.4.</span> <span class="toc-text">Nested</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nullable"><span class="toc-number">3.3.1.</span> <span class="toc-text">Nullable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Domain"><span class="toc-number">3.3.2.</span> <span class="toc-text">Domain</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%BC%95%E6%93%8E"><span class="toc-number">4.</span> <span class="toc-text">表引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TinyLog"><span class="toc-number">4.1.</span> <span class="toc-text">TinyLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory"><span class="toc-number">4.2.</span> <span class="toc-text">Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MergeTree"><span class="toc-number">4.3.</span> <span class="toc-text">MergeTree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#partition-by-%E5%88%86%E5%8C%BA-%E5%8F%AF%E9%80%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">partition by 分区(可选)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#primary-key-%E4%B8%BB%E9%94%AE-%E5%8F%AF%E9%80%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">primary key 主键(可选)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#order-by%EF%BC%88%E5%BF%85%E9%80%89%EF%BC%89"><span class="toc-number">4.3.3.</span> <span class="toc-text">order by（必选）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.4.</span> <span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TTL"><span class="toc-number">4.3.5.</span> <span class="toc-text">TTL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReplacingMergeTree"><span class="toc-number">4.4.</span> <span class="toc-text">ReplacingMergeTree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SummingMergeTree"><span class="toc-number">4.5.</span> <span class="toc-text">SummingMergeTree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">SQL 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%AF%BC%E5%87%BA"><span class="toc-number">5.1.</span> <span class="toc-text">连接与导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert"><span class="toc-number">5.2.</span> <span class="toc-text">insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update-delete"><span class="toc-number">5.3.</span> <span class="toc-text">update delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">5.4.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alter"><span class="toc-number">5.5.</span> <span class="toc-text">alter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC"><span class="toc-number">6.</span> <span class="toc-text">副本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">副本写入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.2.</span> <span class="toc-text">配置步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">7.</span> <span class="toc-text">分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">集群写入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">集群读取流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Explain-%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">8.</span> <span class="toc-text">Explain 查看执行计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">建表优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">9.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.1.1.</span> <span class="toc-text">时间类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.1.2.</span> <span class="toc-text">空值存储类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%92%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">9.2.</span> <span class="toc-text">分区和索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8F%82%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">表参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E4%BC%98%E5%8C%96"><span class="toc-number">9.4.</span> <span class="toc-text">写入和删除优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE"><span class="toc-number">9.5.</span> <span class="toc-text">常见配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU"><span class="toc-number">9.5.1.</span> <span class="toc-text">CPU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">9.5.2.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">9.5.3.</span> <span class="toc-text">存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClickHouse-%E8%AF%AD%E6%B3%95%E4%BC%98%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-number">10.</span> <span class="toc-text">ClickHouse 语法优化规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#COUNT-%E4%BC%98%E5%8C%96"><span class="toc-number">10.1.</span> <span class="toc-text">COUNT 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%AD%90%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">10.2.</span> <span class="toc-text">消除子查询重复字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D%E4%B8%8B%E6%8E%A8"><span class="toc-number">10.3.</span> <span class="toc-text">谓词下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E8%AE%A1%E7%AE%97%E5%A4%96%E6%8E%A8"><span class="toc-number">10.4.</span> <span class="toc-text">聚合计算外推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E6%B6%88%E9%99%A4"><span class="toc-number">10.5.</span> <span class="toc-text">聚合函数消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84-order-by-key"><span class="toc-number">10.6.</span> <span class="toc-text">删除重复的 order by key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84-limit-by-key"><span class="toc-number">10.7.</span> <span class="toc-text">删除重复的 limit by key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84-USING-Key"><span class="toc-number">10.8.</span> <span class="toc-text">删除重复的 USING Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-number">10.9.</span> <span class="toc-text">标量替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E4%BC%98%E5%8C%96"><span class="toc-number">10.10.</span> <span class="toc-text">三元运算优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">11.</span> <span class="toc-text">查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">11.1.</span> <span class="toc-text">单表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prewhere-%E6%9B%BF%E4%BB%A3-where"><span class="toc-number">11.1.1.</span> <span class="toc-text">Prewhere 替代 where</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7"><span class="toc-number">11.1.2.</span> <span class="toc-text">数据采样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A3%81%E5%89%AA%E4%B8%8E%E5%88%86%E5%8C%BA%E8%A3%81%E5%89%AA"><span class="toc-number">11.1.3.</span> <span class="toc-text">列裁剪与分区裁剪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%88%97"><span class="toc-number">11.1.4.</span> <span class="toc-text">避免构建虚拟列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniqCombined-%E6%9B%BF%E4%BB%A3-distinct"><span class="toc-number">11.1.5.</span> <span class="toc-text">uniqCombined 替代 distinct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.1.6.</span> <span class="toc-text">其他注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94"><span class="toc-number">11.2.</span> <span class="toc-text">多表关联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-IN-%E4%BB%A3%E6%9B%BF-JOIN"><span class="toc-number">11.2.1.</span> <span class="toc-text">用 IN 代替 JOIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E8%A1%A8-JOIN"><span class="toc-number">11.2.2.</span> <span class="toc-text">大小表 JOIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E8%B0%93%E8%AF%8D%E4%B8%8B%E6%8E%A8"><span class="toc-number">11.2.3.</span> <span class="toc-text">注意谓词下推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E4%BD%BF%E7%94%A8-GLOBAL"><span class="toc-number">11.2.4.</span> <span class="toc-text">分布式表使用 GLOBAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E8%A1%A8"><span class="toc-number">11.2.5.</span> <span class="toc-text">使用字典表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">12.</span> <span class="toc-text">数据一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8-OPTIMIZE"><span class="toc-number">12.1.</span> <span class="toc-text">手动 OPTIMIZE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Group-by-%E5%8E%BB%E9%87%8D"><span class="toc-number">12.2.</span> <span class="toc-text">通过 Group by 去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-FINAL-%E6%9F%A5%E8%AF%A2"><span class="toc-number">12.3.</span> <span class="toc-text">通过 FINAL 查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">13.</span> <span class="toc-text">物化视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">13.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">13.2.</span> <span class="toc-text">创建物化视图的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"><span class="toc-number">13.3.</span> <span class="toc-text">物化视图的数据更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MaterializeMySQL-%E5%BC%95%E6%93%8E"><span class="toc-number">14.</span> <span class="toc-text">MaterializeMySQL 引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">14.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E5%88%99"><span class="toc-number">14.2.</span> <span class="toc-text">使用细则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DDL-%E6%9F%A5%E8%AF%A2"><span class="toc-number">14.2.1.</span> <span class="toc-text">DDL 查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-number">14.2.2.</span> <span class="toc-text">数据复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SELECT-%E6%9F%A5%E8%AF%A2"><span class="toc-number">14.2.3.</span> <span class="toc-text">SELECT 查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.2.4.</span> <span class="toc-text">索引转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usage"><span class="toc-number">14.3.</span> <span class="toc-text">usage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">15.</span> <span class="toc-text">常见问题排查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-DDL-%E6%9F%90%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E7%9A%84%E5%89%AF%E6%9C%AC%E4%B8%8D%E6%89%A7%E8%A1%8C"><span class="toc-number">15.1.</span> <span class="toc-text">分布式 DDL 某数据节点的副本不执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%89%AF%E6%9C%AC%E8%A1%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">15.2.</span> <span class="toc-text">数据副本表和数据不一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC%E8%8A%82%E7%82%B9%E5%85%A8%E9%87%8F%E6%81%A2%E5%A4%8D"><span class="toc-number">15.3.</span> <span class="toc-text">副本节点全量恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%89%AF%E6%9C%AC%E5%90%AF%E5%8A%A8%E7%BC%BA%E5%B0%91-zk-%E8%A1%A8"><span class="toc-number">15.4.</span> <span class="toc-text">数据副本启动缺少 zk 表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZK-table-replicas-%E6%95%B0%E6%8D%AE%E6%9C%AA%E5%88%A0%E9%99%A4%EF%BC%8C%E5%AF%BC%E8%87%B4%E9%87%8D%E5%BB%BA%E8%A1%A8%E6%8A%A5%E9%94%99"><span class="toc-number">15.5.</span> <span class="toc-text">ZK table replicas 数据未删除，导致重建表报错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clickhouse-%E8%8A%82%E7%82%B9%E6%84%8F%E5%A4%96%E5%85%B3%E9%97%AD"><span class="toc-number">15.6.</span> <span class="toc-text">Clickhouse 节点意外关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClickHouse-%E7%9B%91%E6%8E%A7%E6%A6%82%E8%BF%B0"><span class="toc-number">16.</span> <span class="toc-text">ClickHouse 监控概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E5%8F%8A%E6%81%A2%E5%A4%8D"><span class="toc-number">17.</span> <span class="toc-text">备份及恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%A4%87%E4%BB%BD%E5%8F%8A%E6%81%A2%E5%A4%8D"><span class="toc-number">17.1.</span> <span class="toc-text">手动实现备份及恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-clickhouse-backup"><span class="toc-number">17.2.</span> <span class="toc-text">使用 clickhouse-backup</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="OLTP-与-OLAP"><a href="#OLTP-与-OLAP" class="headerlink" title="OLTP 与 OLAP"></a>OLTP 与 OLAP</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>OLTP（On-Line Transaction Processing）：联机事务处理</li>
<li>OLAP（On-Line Analytical Processing）：联机分析处理</li>
</ul>
<p>从字面上来看 OLTP 是做事务处理，OLAP 是做分析处理。<strong>从对数据库操作来看，OLTP 主要是对数据的增删改，OLAP 是对数据的查询</strong>。</p>
<p>OLTP 主要用来记录某类业务事件的发生，如购买行为，当行为产生后，系统会记录是谁在何时何地做了何事，这样的一行（或多行）数据会以增删改的方式在数据库中进行数据的更新处理操作，要求实时性高、稳定性强、确保数据及时更新成功，像公司常见的业务系统如 ERP，CRM，OA 等系统都属于 OLTP。</p>
<p>当数据积累到一定的程度，我们需要对过去发生的事情做一个总结分析时，就需要把过去一段时间内产生的数据拿出来进行统计分析，从中获取我们想要的信息，为公司做决策提供支持，这时候就是在做 OLAP 了。</p>
<p><img src="/images/c847ee1d2e5533a896f6bd99a8294727.png" alt="img"></p>
<h3 id="OLTP-的特征"><a href="#OLTP-的特征" class="headerlink" title="OLTP 的特征"></a>OLTP 的特征</h3><p>OLTP 通常是指<strong>事务性非常高的在线系统</strong>，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的 Transaction 以及 Execute SQL 的数量。在这样的系统中，单个数据库每秒处理的 Transaction 往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。典型的 OLTP 系统有电子商务系统、银行、证券等。</p>
<p>OLTP 应用的特点一般有：</p>
<ol>
<li>实时性要求高。以前银行异地汇款，要隔天才能到账，而现在是分分钟到账，说明现在银行的实时处理能力大大增强。</li>
<li>数据量不是很大，生产库上的数据量一般不会太大，而且会及时做相应的数据处理与转移。</li>
<li>交易一般是确定的，比如银行存取款的金额肯定是确定的，所以 OLTP 是对确定性的数据进行存取。</li>
<li>高并发，并且要求满足 ACID 原则。比如两人同时操作一个银行卡账户，比如大型的购物网站秒杀活动时上万的 QPS 请求。</li>
</ol>
<p>OLTP 的特点：</p>
<ul>
<li>每个 I/O 非常小，通常为 2KB~8KB</li>
<li>访问磁盘数据的位置非常随机</li>
<li>至少 30% 的数据是随机写操作</li>
<li>联机重做日志是写入非常频繁的顺序写</li>
</ul>
<p>1、业务特征：每个事务的读，写，更改涉及的数据量非常小，同时有很多用户连接到数据库，使用数据库，要求数据库有很快的响应时间，通常一个事务在几秒内完成，时延要求一般在 10-20ms。</p>
<p>2、IO 特征：针对 DATA LUN，随机小 IO，IO 大小主要为 8KB (IO 大小与数据库的 Block 块大小一致)，读写比约为 3:2，读全随机，写有一定合并。针对 LOG LUN，多路顺序小 IO，大小不定，几乎都是写 IO。</p>
<p>OLTP 系统最容易出现瓶颈的地方除了服务器的 CPU，就是存储系统 IOPS 处理能力。因为在 OLTP 环境中，硬盘物理读一般都是 db file sequential read，即单个数据块物理读，但是这个读的次数非常频繁。如果频繁到硬盘子系统都不能承载其 IOPS 的时候，就会出现大的性能问题。</p>
<h3 id="OLAP-的特征"><a href="#OLAP-的特征" class="headerlink" title="OLAP 的特征"></a>OLAP 的特征</h3><p>OLAP 系统，也称为 DSS 决策支持系统，就是我们说的数据仓库。在这样的系统中，绝大多数时候数据库上运行着的是报表作业，执行基本上是聚合类的 SQL 操作，比如 Group by，同时扫描非常多的行，一个查询将花费数小时，甚至数天，一次读取的数据量大；一般无数据修改，或者只有非常少的数据修改。</p>
<p>OLAP 应用的特点一般有：</p>
<ol>
<li>实时性要求不是很高，比如最常见的应用就是天级更新数据，然后出对应的数据报表。</li>
<li>数据量大，因为 OLAP 支持的是动态查询，所以用户也许要通过将很多数据的统计后才能得到想要知道的信息，例如时间序列分析等等，所以处理的数据量很大；</li>
<li>OLAP 系统的重点是通过数据提供决策支持，所以查询一般都是动态，自定义的。所以在 OLAP 中，维度的概念特别重要。一般会将用户所有关心的维度数据，存入对应数据平台。</li>
</ol>
<p>OLAP 的特点：</p>
<ul>
<li>单个 I/O 很大，典型的值为 64KB~1MB</li>
<li>读取操作为顺序读取</li>
<li>当读取操作进行时，发生的写操作通常在临时表空间内</li>
<li>平常对在线日志写入很少，除非在批量加载数据时</li>
</ul>
<p>1、业务特征：一般很少有数据修改，除非在批量加载数据时；系统调用非常复杂的查询语句，同时扫描非常多的行；一个查询将花费数小时，甚至数天；主要取决于查询语句的复杂程度；查询的输出通常是一个统计值，由 group by 与 order by 得出；当读取操作进行时，发生的写操作通常在临时表空间内；平常对在线日志写入很少，除非在批量加载数据时；分析型业务，一般对时延没有要求。</p>
<p>2、IO 特征：针对 DATA LUN，多路顺序大 IO (可以近似认为是随机大 IO)，IO 大小与主机侧设置的分条大小有关 (如 512KB)，90% 以上为读业务，混合间断读写。针对 TMP LUN，随机 IO，读写混合 (先写后读，计算时写，读临时表时读，大部分是写，占整个业务中很少部分的 IO)，IO 大小基本为 200KB 以上大 IO。</p>
<p>OLTP 系统最容易出现瓶颈的地方是存储系统的带宽。阵列的带宽则往往取决于主机到阵列的前端网络和后端硬盘的个数，这个时候，阵列 CACHE 基本是没有效果的，数据库的读写类型基本上是 db file scattered read 与 direct path read/write。</p>
<h2 id="ClickHouse-简介"><a href="#ClickHouse-简介" class="headerlink" title="ClickHouse 简介"></a>ClickHouse 简介</h2><p>ClickHouse 是开源的列式存储数据库（DBMS），使用 C++ 语言编写，主要用于在线分析处理查询（OLAP），能够使用 SQL 查询实时生成分析数据报告。</p>
<h3 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h3><p>以下面的表为例：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>Name</th>
<th>Age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>18</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>22</td>
</tr>
<tr>
<td>3</td>
<td>王五</td>
<td>34</td>
</tr>
</tbody></table>
<p>采用行式存储时，数据在磁盘上的组织结构为：</p>
<p><img src="/images/image-20220314180029092.png" alt="image-20220314180029092"></p>
<p>好处是想查某个人所有的属性时，可以通过一次磁盘查找加顺序读取就可以。但是<strong>当想查所有人的年龄时，需要不停的查找，或者全表扫描才行，遍历的很多数据都是不需要的</strong>。</p>
<p>采用列式存储时，数据在磁盘上的组织结构为：</p>
<p><img src="/images/image-20220314180056473.png" alt="image-20220314180056473"></p>
<p>这时想查所有人的年龄只需把年龄那一列拿出来就可以了。</p>
<p>列式储存的好处：</p>
<ul>
<li>对于列的聚合，计数，求和等统计操作原因优于行式存储。</li>
<li>由于某一列的数据类型都是相同的，针对于数据存储更容易进行数据压缩，每一列选择更优的数据压缩算法，大大提高了数据的压缩比重。</li>
<li>由于数据压缩比更好，一方面节省了磁盘空间，另一方面对于 cache 也有了更大的发挥空间。</li>
</ul>
<h3 id="高吞吐写入能力"><a href="#高吞吐写入能力" class="headerlink" title="高吞吐写入能力"></a>高吞吐写入能力</h3><p>ClickHouse 采用类 LSM Tree 的结构，数据写入后定期在后台 Compaction。通过类 LSM tree 的结构，ClickHouse 在数据导入时全部是顺序 append 写，写入后数据段不可更改，在后台 compaction 时也是多个段 merge sort 后<strong>顺序写回</strong>磁J盘。顺序写的特性，充分利用了磁盘的吞吐能力，即便在 HDD 上也有着优异的写入性能。 </p>
<p>官方公开 benchmark 测试显示能够达到 50MB-200MB/s 的写入吞吐能力，按照每行 100Byte 估算，大约相当于 50W-200W 条/s 的写入速度。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><code>ClickHouse</code> 的数据类型大致划分为：基本数据类型，复合数据类型，特殊类型。</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>只有数值，字符串，时间。没有 <code>Boolean</code> ，但可以通过 <code>0/1</code> 来替代。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应 Mysql</th>
</tr>
</thead>
<tbody><tr>
<td><code>Int8</code></td>
<td><code>Tinyint</code></td>
</tr>
<tr>
<td><code>Int16</code></td>
<td><code>Smallint</code></td>
</tr>
<tr>
<td><code>Int32</code></td>
<td><code>Int</code></td>
</tr>
<tr>
<td><code>Int64</code></td>
<td><code>Bigint</code></td>
</tr>
<tr>
<td><code>Float32</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>Float64</code></td>
<td><code>Double</code></td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>Varchar Text Blob</code></td>
</tr>
<tr>
<td><code>FixedString(N)</code></td>
<td><code>Char</code></td>
</tr>
<tr>
<td><code>UUID [8-4-4-4-12]</code></td>
<td>无</td>
</tr>
<tr>
<td><code>DateTime [到秒]</code></td>
<td></td>
</tr>
<tr>
<td><code>DateTime64 [到亚秒]</code></td>
<td></td>
</tr>
<tr>
<td><code>Date [到天]</code></td>
<td></td>
</tr>
</tbody></table>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>提供了数组，元组，枚举，嵌套四种复合类型。</p>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select [1,2,Null] as a, toTypeName(a);</span><br><span class="line"></span><br><span class="line">┌─a──────────┬─toTypeName([1, 2, NULL])─┐</span><br><span class="line">│ [1,2,NULL]   │ Array(Nullable(UInt8))   │</span><br><span class="line">└────────────┴──────────────────────┘</span><br></pre></td></tr></table></figure>

<p>一个数组里面时可以包含多个数据类型，但是多个数据类型必须兼容，<code>[1, &#39;click&#39;]</code> 这种的就会报错。</p>
<p>所以在建表建议标明字段类型【<strong>也建议在建表的时候将所有的字段名类型和注释都标注清楚</strong>】：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test (</span><br><span class="line">  c1 <span class="keyword">Array</span>(String)</span><br><span class="line">) engine <span class="operator">=</span> TinyLog;</span><br></pre></td></tr></table></figure>

<h4 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    (1, &#x27;click&#x27;, now()) AS a,</span><br><span class="line">    toTypeName(a)</span><br><span class="line"></span><br><span class="line">┌─a────────────────────────────┬─toTypeName(tuple(1, &#x27;click&#x27;, now()))─┐</span><br><span class="line">│ (1,&#x27;click&#x27;,&#x27;2020-06-06 05:59:57&#x27;) │ Tuple(UInt8, String, DateTime)       │</span><br><span class="line">└──────────────────────────────┴────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>可以看出，元组是支持不同的数据类型，彼此之间不需要兼容。所以在建表的时候也建议指定字段类型。</p>
<h4 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h4><p>定义常量时会经常使用该类型，分 <code>Enum8/Enum16</code>。<code>Enum</code> 固定使用 <code>Enum(String=Int)</code> 的键值对格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test (</span><br><span class="line">    `c1` Enum(&#x27;click&#x27; = 1, &#x27;house&#x27; = 2, &#x27;java&#x27; = 3)</span><br><span class="line">) ENGINE = TinyLog</span><br><span class="line"></span><br><span class="line">insert into test values (&#x27;click&#x27;);</span><br><span class="line">insert into test values (&#x27;house&#x27;);</span><br></pre></td></tr></table></figure>

<p>建表的时候 <code>Key/Value</code> 是不允许重复的。其次，<code>Key/Value</code> 不能同时为 <code>Null</code> ，但是 Key 允许空字符串。</p>
<h4 id="Nested"><a href="#Nested" class="headerlink" title="Nested"></a>Nested</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test_nest (</span><br><span class="line">    `name` String,</span><br><span class="line">    `age` Int8,</span><br><span class="line">    `dept` Nested(</span><br><span class="line">    		id UInt8,</span><br><span class="line">    		name String</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">ENGINE = TinyLog</span><br></pre></td></tr></table></figure>

<p>但是实际上 <code>Nested</code> 会传统的嵌套类型不一样，不能理解为 <code>test_nest</code> 和 <code>dept</code> 不是一对一的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into test_nest values (&#x27;nest&#x27;, 18, 1000, &#x27;大数据组&#x27;)</span><br><span class="line"></span><br><span class="line">Exception on client:</span><br><span class="line">Code: 53. DB::Exception: Type mismatch in IN or VALUES section. Expected: Array(UInt8). Got: UInt64</span><br></pre></td></tr></table></figure>

<p>异常显示需要 <code>Array</code>，而不是单纯的 <code>Int</code>。所以这里也就明白：<strong>嵌套类型本质是一个多维数组的结构</strong>。</p>
<p>嵌套类型的一个字段对应一个数组。字段对应的数组内的数量没有限制，但是字段之间需要数组内的数量对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    name,</span><br><span class="line">    dept.id,</span><br><span class="line">    dept.name</span><br><span class="line">FROM test_nest</span><br><span class="line"></span><br><span class="line">┌─name──┬─dept.id───────┬─dept.name─────────────────────┐</span><br><span class="line">│ nest  │ [232,233,235]   │ [&#x27;clickhouse&#x27;,&#x27;kafka&#x27;,&#x27;debezium&#x27;] │</span><br><span class="line">│ tube  │ [7,9,10]        │ [&#x27;flink&#x27;,&#x27;spark&#x27;,&#x27;kudu&#x27;]          │</span><br><span class="line">└──────┴──────────────┴──────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>访问的时候和 <code>struct</code> 的访问方式一致。</p>
<h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><h4 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h4><p><code>Nullable</code> 类似 java 的 <code>Optional</code>，表示某个基本类型可以为 <code>Null</code>。</p>
<p>从上面的介绍：</p>
<ol>
<li><p><code>Nullable</code> 只能和基本类型搭配使用；</p>
</li>
<li><p>不能使用在 <code>Array/Tuple</code> 这种复合类型上；</p>
</li>
<li><p>不能作为索引字段【<code>Order by()</code>】;</p>
</li>
<li><p>慎用 <code>Nullable</code> ，写入写出性能不好。因为它会生成单独的文件。</p>
<blockquote>
<p>这个和 <code>Mysql</code> 的设计类似，<code>Null</code> 也需要额外的空间存储，只是 mysql 是存储在每一个记录的头中。</p>
</blockquote>
</li>
</ol>
<h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>分为 <code>IPv4</code> <code>IPv6</code>。其实本质都是对整型，字符串进行的封装。</p>
<ul>
<li><code>IPv4</code> 使用 <code>UInt32</code> 存储。</li>
<li><code>IPv6</code> 使用 <code>FixedString(16)</code> 存储。</li>
</ul>
<p>可能会问，为什么不就直接使用整型和 String 存储呢？</p>
<ol>
<li><code>Domain</code> 类型支持格式检查，错误的 IP 数据是不被允许写入到数据库中；</li>
<li><code>IPv4</code> 不使用 String 存储，使用空间更小，查询性能更快。</li>
</ol>
<p>虽然本质是使用 String 存储，但是类型上是不属于 <code>String</code> ，所以不支持隐形的类型转换。如果你需要输出 IP 字符串形式，需要  <code>IPv4NumToString()</code> 进行显示转换。</p>
<h2 id="表引擎"><a href="#表引擎" class="headerlink" title="表引擎"></a>表引擎</h2><p>表引擎决定了如何存储表的数据。包括：</p>
<ul>
<li>数据的存储方式和位置，写到哪里以及从哪里读取数据。 </li>
<li>支持哪些查询以及如何支持。 </li>
<li>并发数据访问。 </li>
<li>索引的使用（如果存在）。 </li>
<li>是否可以执行多线程请求。 </li>
<li>数据复制参数。</li>
</ul>
<p> 表引擎的使用方式：必须显式在创建表时定义该表使用的引擎，以及引擎使用的相关参数。</p>
<h3 id="TinyLog"><a href="#TinyLog" class="headerlink" title="TinyLog"></a>TinyLog</h3><p>以列文件的形式保存在磁盘上，不支持索引，没有并发控制。一般保存少量数据的小表， 生产环境上作用有限。可以用于平时练习测试用。 如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t_tinylog ( id String, name String) engine=TinyLog;</span><br></pre></td></tr></table></figure>



<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存引擎，数据以未压缩的原始形式直接保存在内存当中，服务器重启数据就会消失。 读写操作不会相互阻塞，不支持索引。简单查询下有非常非常高的性能表现（超过 10G/s）。 一般用到它的地方不多，除了用来测试，就是在需要非常高的性能，同时数据量又不太大（上限大概 1 亿行）的场景。</p>
<h3 id="MergeTree"><a href="#MergeTree" class="headerlink" title="MergeTree"></a>MergeTree</h3><p>最强大的表引擎当属 MergeTree（合并树）引擎及该系列（*MergeTree） 中的其他引擎，支持索引和分区，地位可以相当于 innodb 之于 Mysql。而且基于 MergeTree， 还衍生除了很多小弟，也是非常有特色的引擎。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order_mt</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` <span class="type">Decimal</span>(<span class="number">16</span>, <span class="number">2</span>),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (id, sku_id);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_order_mt <span class="keyword">values</span></span><br><span class="line">(<span class="number">101</span>,<span class="string">&#x27;sku_001&#x27;</span>,<span class="number">1000.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>) ,</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 11:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_004&#x27;</span>,<span class="number">2500.00</span>,<span class="string">&#x27;2020-06-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">2000.00</span>,<span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">12000.00</span>,<span class="string">&#x27;2020-06-01 13:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>,<span class="string">&#x27;sku_002&#x27;</span>,<span class="number">600.00</span>,<span class="string">&#x27;2020-06-02 12:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>查询如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_order_mt</span><br><span class="line"></span><br><span class="line">┌──id─┬─sku_id──┬─total_amount─┬───────create_time─┐</span><br><span class="line">│ 101 │ sku_001  │         1000 │ 2020-06-01 12:00:00 │</span><br><span class="line">│ 102 │ sku_002  │         2000 │ 2020-06-01 11:00:00 │</span><br><span class="line">│ 102 │ sku_002  │         2000 │ 2020-06-01 13:00:00 │</span><br><span class="line">│ 102 │ sku_002  │        12000 │ 2020-06-01 13:00:00 │</span><br><span class="line">│ 102 │ sku_004  │         2500 │ 2020-06-01 12:00:00 │</span><br><span class="line">└────┴─────────┴────────────┴──────────────────┘</span><br><span class="line">┌──id─┬─sku_id──┬─total_amount─┬───────create_time─┐</span><br><span class="line">│ 102  │ sku_002 │          600 │ 2020-06-02 12:00:00 │</span><br><span class="line">└─────┴────────┴────────────┴─────────────────┘</span><br></pre></td></tr></table></figure>

<p>发现</p>
<ul>
<li>clickhouse 的 primary key 并没有唯一性限制。</li>
<li>因为使用了分区 PARTITION，所以搜索结果也就分成两个区。</li>
</ul>
<h4 id="partition-by-分区-可选"><a href="#partition-by-分区-可选" class="headerlink" title="partition by 分区(可选)"></a>partition by 分区(可选)</h4><ul>
<li><p>作用：降低扫描的范围，优化查询速度。</p>
</li>
<li><p>如果不填，只会使用一个分区。</p>
</li>
<li><p>分区目录：MergeTree 是以<strong>列文件+索引文件+表定义文件</strong>组成的，但是如果设定了分区那么这些文件就会保存到不同的分区目录中。</p>
</li>
<li><p>并行：<strong>分区后，面对涉及跨分区的查询统计，ClickHouse 会以分区为单位并行处理</strong>。</p>
</li>
<li><p>数据写入与分区合并：任何一个批次的数据写入都会产生一个临时分区，不会纳入任何一个已有的分区。写入后的某个时刻（大概 10-15 分钟后），ClickHouse 会自动执行合并操作（等不及也可以手动通过 optimize 执行），把临时分区的数据，合并到已有分区中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize table xxxx final;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="primary-key-主键-可选"><a href="#primary-key-主键-可选" class="headerlink" title="primary key 主键(可选)"></a>primary key 主键(可选)</h4><p>ClickHouse 中的主键，和其他数据库不太一样，它只提供了数据的一级索引，但是却不是唯一约束。这就意味着是可以存在相同 primary key 的数据的。</p>
<p><strong>主键的设定主要依据是查询语句中的 where 条件。 根据条件通过对主键进行某种形式的二分查找，能够定位到对应的 index granularity，避免了全表扫描</strong>。 </p>
<p>index granularity： 直接翻译的话就是索引粒度，指在<code>稀疏索引</code>中两个相邻索引对应数据的间隔。ClickHouse 中的 MergeTree 默认是 8192。官方不建议修改这个值，除非该列存在大量重复值，比如在一个分区中几万行才有一个不同数据。</p>
<p><img src="/images/image-20220315161847042.png" alt="image-20220315161847042"></p>
<p><img src="/images/FgipmO_qt8jkZdBvnaHCD8LEefqA" alt="img"></p>
<p>稀疏索引的好处就是可以用很少的索引数据，定位更多的数据，代价就是只能定位到索 引粒度的第一行，然后再进行进行一点扫描。</p>
<h4 id="order-by（必选）"><a href="#order-by（必选）" class="headerlink" title="order by（必选）"></a>order by（必选）</h4><p>order by 设定了<strong>分区内</strong>的数据按照哪些字段顺序进行有序保存。 </p>
<p>order by 是 MergeTree 中唯一一个必填项，甚至比 primary key 还重要，因为当用户不设置主键的情况，很多处理会依照 order by 的字段进行处理（比如后面会讲的去重和汇总）。</p>
<p>要求：主键必须是 order by 字段的前缀字段。</p>
<p>比如 order by 字段是 (id,sku_id) 那么主键必须是 id 或者(id,sku_id)</p>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>又称为<code>跳数索引</code>。功能：<strong>多区间合并，减少区间的判断次数</strong>。</p>
<ol>
<li>稀疏索引在磁盘中存储结构是链表，要想找到某条数据在哪个稀疏索引中，只能遍历这条链表。</li>
<li>为了提高效率，对这条链表进行更大粒度的汇总，形成的新的链表就是二级索引。</li>
<li>通过二级索引的链表，我们可以得知此条数据在一级索引的大概位置，进而跳过了很多无效的判断。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table t_order_mt2(</span><br><span class="line"> id UInt32,</span><br><span class="line"> sku_id String,</span><br><span class="line"> total_amount Decimal(16,2),</span><br><span class="line"> create_time Datetime,</span><br><span class="line">INDEX a total_amount TYPE minmax GRANULARITY 5</span><br><span class="line">) engine =MergeTree</span><br><span class="line"> partition by toYYYYMMDD(create_time)</span><br><span class="line"> primary key (id)</span><br><span class="line"> order by (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>GRANULARITY N 是<strong>设定二级索引对于一级索引粒度的粒度</strong>。</p>
<h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>MergeTree 提供了可以管理数据表或者列的生命周期的功能。</p>
<p>涉及判断的字段必须是 Date 或者 Datetime 类型，推荐使用分区的日期字段。</p>
<p>列级别 TTL：<strong>total_amount 列在 create_time 之后 10 秒丢失</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_order_mt3(</span><br><span class="line"> id UInt32,</span><br><span class="line"> sku_id String,</span><br><span class="line"> total_amount <span class="type">Decimal</span>(<span class="number">16</span>,<span class="number">2</span>) TTL create_time<span class="operator">+</span><span class="type">interval</span> <span class="number">10</span> <span class="keyword">SECOND</span>,</span><br><span class="line"> create_time Datetime</span><br><span class="line">) engine <span class="operator">=</span>MergeTree</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> toYYYYMMDD(create_time)</span><br><span class="line"> <span class="keyword">primary</span> key (id)</span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>表级 TTL：<strong>数据会在 create_time 之后 10 秒丢失</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_order_mt3 MODIFY TTL create_time + INTERVAL 10 SECOND;</span><br></pre></td></tr></table></figure>

<p>能够使用的时间周期： </p>
<ul>
<li>SECOND</li>
<li>MINUTE</li>
<li>HOUR</li>
<li>DAY</li>
<li>WEEK</li>
<li>MONTH</li>
<li>QUARTER</li>
<li>YEAR</li>
</ul>
<h3 id="ReplacingMergeTree"><a href="#ReplacingMergeTree" class="headerlink" title="ReplacingMergeTree"></a>ReplacingMergeTree</h3><p>ReplacingMergeTree 是 MergeTree 的一个变种，它存储特性完全继承 MergeTree，只是<strong>多了一个去重的功能</strong>。 </p>
<p>尽管 MergeTree 可以设置主键，但是 primary key 其实没有唯一约束的功能。如果你想处理掉重复的数据，可以借助这个 ReplacingMergeTree。</p>
<ul>
<li>去重时机：<strong>只会在合并的过程中执行</strong>。合并会在未知的时间在后台进行，所以你无法预先作出计划。有一些数据可能仍未被处理。</li>
<li>去重范围：如果表经过了分区，去重只会在分区内部进行去重，<strong>不能执行跨分区的去重</strong>。 所以 ReplacingMergeTree 能力有限， ReplacingMergeTree 适用于在后台清除重复的数据以节省空间，但是它不保证没有重复的数据出现。</li>
</ul>
<p>ReplacingMergeTree() 填入的参数为<code>版本字段</code>，重复数据保留版本字段值最大的。 如果不填版本字段，默认按照插入顺序保留最后一条。</p>
<blockquote>
<p>何为重复？注意并不是主键相同为重复，而是使用 order by 字段作为唯一键。order by相同，则为重复</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table t_order_rmt(</span><br><span class="line"> id UInt32,</span><br><span class="line"> sku_id String,</span><br><span class="line"> total_amount Decimal(16,2) ,</span><br><span class="line"> create_time Datetime</span><br><span class="line">) engine =ReplacingMergeTree(create_time)</span><br><span class="line"> partition by toYYYYMMDD(create_time)</span><br><span class="line"> primary key (id)</span><br><span class="line"> order by (id, sku_id);</span><br></pre></td></tr></table></figure>

<p>上面代码中，虽然使用 id 作为主键，但是实际判断重复的时候，使用的是(id, sku_id)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">insert into t_order_rmt values</span><br><span class="line">(101,&#x27;sku_001&#x27;,1000.00,&#x27;2020-06-01 12:00:00&#x27;) ,</span><br><span class="line">(102,&#x27;sku_002&#x27;,2000.00,&#x27;2020-06-01 11:00:00&#x27;),</span><br><span class="line">(102,&#x27;sku_004&#x27;,2500.00,&#x27;2020-06-01 12:00:00&#x27;),</span><br><span class="line">(102,&#x27;sku_002&#x27;,2000.00,&#x27;2020-06-01 13:00:00&#x27;),</span><br><span class="line">(102,&#x27;sku_002&#x27;,12000.00,&#x27;2020-06-01 13:00:00&#x27;),</span><br><span class="line">(102,&#x27;sku_002&#x27;,600.00,&#x27;2020-06-02 12:00:00&#x27;);</span><br><span class="line"></span><br><span class="line">select * from t_order_rmt;</span><br><span class="line">┌──id─┬─sku_id──┬─total_amount─┬───────create_time─┐</span><br><span class="line">│ 101 │ sku_001 │         1000  │ 2020-06-01 12:00:00 │</span><br><span class="line">│ 102 │ sku_002 │        12000  │ 2020-06-01 13:00:00 │</span><br><span class="line">│ 102 │ sku_004 │         2500  │ 2020-06-01 12:00:00 │</span><br><span class="line">└────┴────────┴─────────────┴─────────────────┘</span><br><span class="line">┌──id─┬─sku_id──┬─total_amount─┬───────create_time─┐</span><br><span class="line">│ 102  │ sku_002 │          600 │ 2020-06-02 12:00:00 │</span><br><span class="line">└─────┴────────┴────────────┴─────────────────┘</span><br></pre></td></tr></table></figure>



<h3 id="SummingMergeTree"><a href="#SummingMergeTree" class="headerlink" title="SummingMergeTree"></a>SummingMergeTree</h3><p>对于不查询明细，只关心<strong>以维度进行汇总聚合结果的场景</strong>。如果只使用普通的 MergeTree 的话，无论是存储空间的开销，还是查询时临时聚合的开销都比较大。 ClickHouse 为了这种场景，提供了一种能够<code>预聚合</code>的引擎 SummingMergeTree。</p>
<ul>
<li>以 SummingMergeTree() 中指定的列作为汇总数据列</li>
<li>可以填写多列必须数字列，如果不填，以所有非维度列且为数字列的字段为汇总数据列</li>
<li>以 order by 的列为准，作为维度列</li>
<li>其他的列按插入顺序保留第一行</li>
<li>不在一个分区的数据不会被聚合</li>
<li>只有在同一批次插入或分片合并时才会进行聚合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table t_order_smt(</span><br><span class="line"> id UInt32,</span><br><span class="line"> sku_id String,</span><br><span class="line"> total_amount Decimal(16,2) ,</span><br><span class="line"> create_time Datetime</span><br><span class="line">) engine=SummingMergeTree(total_amount)</span><br><span class="line"> partition by toYYYYMMDD(create_time)</span><br><span class="line"> primary key (id)</span><br><span class="line"> order by (id,sku_id);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">insert into t_order_smt values</span><br><span class="line">(101,&#x27;sku_001&#x27;,1000.00,&#x27;2020-06-01 12:00:00&#x27;),</span><br><span class="line">(102,&#x27;sku_002&#x27;,2000.00,&#x27;2020-06-01 11:00:00&#x27;),</span><br><span class="line">(102,&#x27;sku_004&#x27;,2500.00,&#x27;2020-06-01 12:00:00&#x27;),</span><br><span class="line">(102,&#x27;sku_002&#x27;,2000.00,&#x27;2020-06-01 13:00:00&#x27;),</span><br><span class="line">(102,&#x27;sku_002&#x27;,12000.00,&#x27;2020-06-01 13:00:00&#x27;),</span><br><span class="line">(102,&#x27;sku_002&#x27;,600.00,&#x27;2020-06-02 12:00:00&#x27;);</span><br><span class="line"></span><br><span class="line">select * from t_order_smt;</span><br><span class="line">┌──id─┬─sku_id──┬─total_amount─┬───────create_time─┐</span><br><span class="line">│ 102  │ sku_002 │          600 │ 2020-06-02 12:00:00 │</span><br><span class="line">└─────┴────────┴────────────┴─────────────────┘</span><br><span class="line">┌──id─┬─sku_id─┬─total_amount─┬───────create_time─┐</span><br><span class="line">│ 101 │ sku_001 │         1000 │ 2020-06-01 12:00:00 │</span><br><span class="line">│ 102 │ sku_002 │        16000 │ 2020-06-01 11:00:00 │</span><br><span class="line">│ 102 │ sku_004 │         2500 │ 2020-06-01 12:00:00 │</span><br><span class="line">└────┴────────┴────────────┴─────────────────┘</span><br></pre></td></tr></table></figure>



<h2 id="SQL-操作"><a href="#SQL-操作" class="headerlink" title="SQL 操作"></a>SQL 操作</h2><h3 id="连接与导出"><a href="#连接与导出" class="headerlink" title="连接与导出"></a>连接与导出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 连接clickhouse</span><br><span class="line">clickhouse-client --host localhost --port 9000 --user default  --password 123456 --multiline</span><br><span class="line"></span><br><span class="line"># 导出</span><br><span class="line">clickhouse-client --query &quot;select * from t_order_mt where</span><br><span class="line">create_time=&#x27;2020-06-01 12:00:00&#x27;&quot; --format CSVWithNames&gt;</span><br><span class="line">/opt/module/data/rs1.csv</span><br></pre></td></tr></table></figure>

<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>Insert 基本与标准 SQL 一致。</p>
<h3 id="update-delete"><a href="#update-delete" class="headerlink" title="update delete"></a>update delete</h3><p>Update 和 Delete 被称为 Mutation 查询，，Mutation 语句是一种很重的操作，而且<strong>不支持事务</strong>。</p>
<p>“重”的原因主要是每次修改或者删除都会导致放弃目标数据的原有分区，重建新分区。 所以<strong>尽量做批量的变更，不要进行频繁小数据的操作</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 删除操作</span><br><span class="line">alter table t_order_smt delete where sku_id =&#x27;sku_001&#x27;;</span><br><span class="line"></span><br><span class="line"># 修改操作</span><br><span class="line">alter table t_order_smt update total_amount=toDecimal32(2000.00,2) where id</span><br><span class="line">=102;</span><br></pre></td></tr></table></figure>

<p>由于操作比较“重”，所以 Mutation 语句分两步执行，同步执行的部分其实只是进行新增数据新增分区和并把旧分区打上逻辑上的失效标记。直到触发分区合并的时候，才会删除旧数据释放磁盘空间，一般不会开放这样的功能给用户，由管理员完成。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>ClickHouse 基本上与标准 SQL 差别不大</p>
<ul>
<li>支持子查询</li>
<li>支持 CTE(Common Table Expression 公用表表达式 with 子句)</li>
<li>支持各种 JOIN，但是 JOIN 操作无法使用缓存，所以即使是两次相同的 JOIN 语句， ClickHouse 也会视为两条新 SQL</li>
<li>窗口函数(官方正在测试中…)</li>
<li>不支持自定义函数</li>
<li>GROUP BY 操作增加了 <code>with rollup</code>，<code>with cube</code>，<code>with total</code> 用来计算小计和总计。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 插入数据</span><br><span class="line">CREATE TABLE t_order_mt</span><br><span class="line">(</span><br><span class="line">    `id` UInt32,</span><br><span class="line">    `sku_id` String,</span><br><span class="line">    `total_amount` Decimal(16, 2),</span><br><span class="line">    `create_time` Datetime</span><br><span class="line">)</span><br><span class="line">ENGINE = MergeTree</span><br><span class="line">PARTITION BY toYYYYMMDD(create_time)</span><br><span class="line">PRIMARY KEY id</span><br><span class="line">ORDER BY (id, sku_id);</span><br><span class="line"></span><br><span class="line">insert into t_order_mt values</span><br><span class="line">(101,&#x27;sku_001&#x27;,1000.00,&#x27;2020-06-01 12:00:00&#x27;),</span><br><span class="line">(101,&#x27;sku_002&#x27;,2000.00,&#x27;2020-06-01 12:00:00&#x27;),</span><br><span class="line">(103,&#x27;sku_004&#x27;,2500.00,&#x27;2020-06-01 12:00:00&#x27;),</span><br><span class="line">(104,&#x27;sku_002&#x27;,2000.00,&#x27;2020-06-01 12:00:00&#x27;),</span><br><span class="line">(105,&#x27;sku_003&#x27;,600.00,&#x27;2020-06-02 12:00:00&#x27;),</span><br><span class="line">(106,&#x27;sku_001&#x27;,1000.00,&#x27;2020-06-04 12:00:00&#x27;),</span><br><span class="line">(107,&#x27;sku_002&#x27;,2000.00,&#x27;2020-06-04 12:00:00&#x27;),</span><br><span class="line">(108,&#x27;sku_004&#x27;,2500.00,&#x27;2020-06-04 12:00:00&#x27;),</span><br><span class="line">(109,&#x27;sku_002&#x27;,2000.00,&#x27;2020-06-04 12:00:00&#x27;),</span><br><span class="line">(110,&#x27;sku_003&#x27;,600.00,&#x27;2020-06-01 12:00:00&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select * from t_order_mt;</span><br><span class="line">┌──id─┬─sku_id──┬─total_amount─┬───────create_time─┐</span><br><span class="line">│ 101  │ sku_001 │         1000 │ 2020-06-01 12:00:00 │</span><br><span class="line">│ 101  │ sku_002 │         2000 │ 2020-06-01 12:00:00 │</span><br><span class="line">│ 103  │ sku_004 │         2500 │ 2020-06-01 12:00:00 │</span><br><span class="line">│ 104  │ sku_002 │         2000 │ 2020-06-01 12:00:00 │</span><br><span class="line">│ 110  │ sku_003 │          600 │ 2020-06-01 12:00:00 │</span><br><span class="line">└─────┴────────┴────────────┴──────────────────┘</span><br><span class="line">┌──id─┬─sku_id──┬─total_amount─┬───────create_time─┐</span><br><span class="line">│ 106  │ sku_001 │         1000 │ 2020-06-04 12:00:00 │</span><br><span class="line">│ 107  │ sku_002 │         2000 │ 2020-06-04 12:00:00 │</span><br><span class="line">│ 108  │ sku_004 │         2500 │ 2020-06-04 12:00:00 │</span><br><span class="line">│ 109  │ sku_002 │         2000 │ 2020-06-04 12:00:00 │</span><br><span class="line">└─────┴────────┴────────────┴─────────────────┘</span><br><span class="line">┌──id─┬─sku_id──┬─total_amount─┬───────create_time─┐</span><br><span class="line">│ 105  │ sku_003 │          600 │ 2020-06-02 12:00:00 │</span><br><span class="line">└─────┴────────┴────────────┴─────────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># with rollup：从右至左去掉维度进行小计</span><br><span class="line"># 下面三个结果分别是:</span><br><span class="line"># 1.group by (id,sku_id) </span><br><span class="line"># 2.group by id</span><br><span class="line"># 3.group by</span><br><span class="line">select id, sku_id, sum(total_amount) from t_order_mt group by id,sku_id with rollup;</span><br><span class="line">┌──id─┬─sku_id──┬─sum(total_amount)─┐</span><br><span class="line">│ 110  │ sku_003 │               600 │</span><br><span class="line">│ 109  │ sku_002 │              2000 │</span><br><span class="line">│ 107  │ sku_002 │              2000 │</span><br><span class="line">│ 106  │ sku_001 │              1000 │</span><br><span class="line">│ 104  │ sku_002 │              2000 │</span><br><span class="line">│ 101  │ sku_002 │              2000 │</span><br><span class="line">│ 103  │ sku_004 │              2500 │</span><br><span class="line">│ 108  │ sku_004 │              2500 │</span><br><span class="line">│ 105  │ sku_003 │               600 │</span><br><span class="line">│ 101  │ sku_001 │              1000 │</span><br><span class="line">└─────┴────────┴────────────────┘</span><br><span class="line">┌──id─┬─sku_id─┬─sum(total_amount)─┐</span><br><span class="line">│ 110  │        │               600 │</span><br><span class="line">│ 106  │        │              1000 │</span><br><span class="line">│ 105  │        │               600 │</span><br><span class="line">│ 109  │        │              2000 │</span><br><span class="line">│ 107  │        │              2000 │</span><br><span class="line">│ 104  │        │              2000 │</span><br><span class="line">│ 103  │        │              2500 │</span><br><span class="line">│ 108  │        │              2500 │</span><br><span class="line">│ 101  │        │              3000 │</span><br><span class="line">└─────┴───────┴────────────────┘</span><br><span class="line">┌─id─┬─sku_id─┬─sum(total_amount)─┐</span><br><span class="line">│  0  │        │             16200 │</span><br><span class="line">└────┴───────┴────────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># with cube : 从右至左去掉维度进行小计，再从左至右去掉维度进行小计</span><br><span class="line"># 下面四个结果分别是:</span><br><span class="line"># 1.group by (id,sku_id) </span><br><span class="line"># 2.group by id</span><br><span class="line"># 3.group by sku_id</span><br><span class="line"># 4.group by</span><br><span class="line">select id, sku_id, sum(total_amount) from t_order_mt group by id,sku_id with cube;</span><br><span class="line">┌──id─┬─sku_id──┬─sum(total_amount)─┐</span><br><span class="line">│ 110  │ sku_003 │               600 │</span><br><span class="line">│ 109  │ sku_002 │              2000 │</span><br><span class="line">│ 107  │ sku_002 │              2000 │</span><br><span class="line">│ 106  │ sku_001 │              1000 │</span><br><span class="line">│ 104  │ sku_002 │              2000 │</span><br><span class="line">│ 101  │ sku_002 │              2000 │</span><br><span class="line">│ 103  │ sku_004 │              2500 │</span><br><span class="line">│ 108  │ sku_004 │              2500 │</span><br><span class="line">│ 105  │ sku_003 │               600 │</span><br><span class="line">│ 101  │ sku_001 │              1000 │</span><br><span class="line">└─────┴────────┴────────────────┘</span><br><span class="line">┌──id─┬─sku_id─┬─sum(total_amount)─┐</span><br><span class="line">│ 110  │        │               600 │</span><br><span class="line">│ 106  │        │              1000 │</span><br><span class="line">│ 105  │        │               600 │</span><br><span class="line">│ 109  │        │              2000 │</span><br><span class="line">│ 107  │        │              2000 │</span><br><span class="line">│ 104  │        │              2000 │</span><br><span class="line">│ 103  │        │              2500 │</span><br><span class="line">│ 108  │        │              2500 │</span><br><span class="line">│ 101  │        │              3000 │</span><br><span class="line">└─────┴───────┴────────────────┘</span><br><span class="line">┌─id─┬─sku_id──┬─sum(total_amount)─┐</span><br><span class="line">│  0  │ sku_003 │              1200 │</span><br><span class="line">│  0  │ sku_004 │              5000 │</span><br><span class="line">│  0  │ sku_001 │              2000 │</span><br><span class="line">│  0  │ sku_002 │              8000 │</span><br><span class="line">└────┴────────┴────────────────┘</span><br><span class="line">┌─id─┬─sku_id─┬─sum(total_amount)─┐</span><br><span class="line">│  0  │        │             16200 │</span><br><span class="line">└────┴───────┴────────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># with totals: 只计算合计</span><br><span class="line">select id, sku_id, sum(total_amount) from t_order_mt group by</span><br><span class="line">id,sku_id with totals;</span><br><span class="line">┌──id─┬─sku_id──┬─sum(total_amount)─┐</span><br><span class="line">│ 110  │ sku_003 │               600 │</span><br><span class="line">│ 109  │ sku_002 │              2000 │</span><br><span class="line">│ 107  │ sku_002 │              2000 │</span><br><span class="line">│ 106  │ sku_001 │              1000 │</span><br><span class="line">│ 104  │ sku_002 │              2000 │</span><br><span class="line">│ 101  │ sku_002 │              2000 │</span><br><span class="line">│ 103  │ sku_004 │              2500 │</span><br><span class="line">│ 108  │ sku_004 │              2500 │</span><br><span class="line">│ 105  │ sku_003 │               600 │</span><br><span class="line">│ 101  │ sku_001 │              1000 │</span><br><span class="line">└─────┴────────┴────────────────┘</span><br><span class="line"></span><br><span class="line">Totals:</span><br><span class="line">┌─id─┬─sku_id─┬─sum(total_amount)─┐</span><br><span class="line">│  0  │        │             16200 │</span><br><span class="line">└────┴───────┴────────────────┘</span><br></pre></td></tr></table></figure>

<p>假设维度是 a 和 b：</p>
<ul>
<li><p>rollup：上卷。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">group by (a, b)</span><br><span class="line">group by a</span><br><span class="line">group by</span><br></pre></td></tr></table></figure></li>
<li><p>cube：多维分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group by (a, b)</span><br><span class="line">group by a</span><br><span class="line">group by b</span><br><span class="line">group by</span><br></pre></td></tr></table></figure></li>
<li><p>total：总计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group by (a, b)</span><br><span class="line">group by</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="alter"><a href="#alter" class="headerlink" title="alter"></a>alter</h3><p>同 MySQL 的修改字段基本一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 新增字段</span><br><span class="line">alter table tableName add column newcolname String after col1;</span><br><span class="line"></span><br><span class="line"># 修改字段类型</span><br><span class="line">alter table tableName modify column newcolname String;</span><br><span class="line"></span><br><span class="line"># 删除字段</span><br><span class="line">alter table tableName drop column newcolname;</span><br></pre></td></tr></table></figure>



<h2 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h2><p>目的主要：<strong>保障数据的高可用性</strong>，即使一台 ClickHouse 节点宕机，那么也可以从其他服务器获得相同的数据。</p>
<h3 id="副本写入流程"><a href="#副本写入流程" class="headerlink" title="副本写入流程"></a>副本写入流程</h3><p><img src="/images/image-20220316103754510.png" alt="image-20220316103754510"></p>
<p>注意 a 和 b 互为主从。</p>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ol>
<li><p>启动 zookeeper 集群</p>
</li>
<li><p>在 clickhouse 的/etc/clickhouse-server/config.d 目录下创建一个名为 metrika.xml 的配置文件,内容如下： 注：也可以不创建外部文件，直接在 config.xml 中指定</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">yandex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">host</span>&gt;</span>XXXXXXX<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">host</span>&gt;</span>YYYYYYYY<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">host</span>&gt;</span>ZZZZZZZZ<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">yandex</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>同步到另外的机器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xsync /etc/clickhouse-server/config.d/metrika.xml</span><br></pre></td></tr></table></figure></li>
<li><p>在 clickhouse /etc/clickhouse-server/config.xml 中增加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;zookeeper incl=&quot;zookeeper-servers&quot; optional=&quot;true&quot; /&gt;</span><br><span class="line">&lt;include_from&gt;/etc/clickhouse-server/config.d/metrika.xml&lt;/include_from&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>将 /etc/clickhouse-server/config.xml 同步到另外的机器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xsync /etc/clickhouse-server/config.xml</span><br></pre></td></tr></table></figure></li>
<li><p>重启所有节点的 clickhouse 服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse restart</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table t_order_rep2 (</span><br><span class="line"> id UInt32,</span><br><span class="line"> sku_id String,</span><br><span class="line"> total_amount Decimal(16,2),</span><br><span class="line"> create_time Datetime</span><br><span class="line">) engine =ReplicatedMergeTree(&#x27;/clickhouse/table/01/t_order_rep&#x27;,&#x27;rep_102&#x27;)</span><br><span class="line"> partition by toYYYYMMDD(create_time)</span><br><span class="line"> primary key (id)</span><br><span class="line"> order by (id,sku_id);</span><br></pre></td></tr></table></figure>

<p>ReplicatedMergeTree 中，</p>
<ul>
<li>第一个参数是分片的 zk_path 一般按照：/clickhouse/table/{shard}/{table_name} 的格式写，如果只有一个分片就写 01 即可。</li>
<li>第二个参数是副本名称，相同的分片副本名称不能相同。</li>
</ul>
<h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><p>副本虽然能够提高数据的可用性，降低丢失风险，但是每台服务器实际上必须容纳全量数据，对数据的横向扩容没有解决。</p>
<p>要解决数据水平切分的问题，需要引入分片的概念。通过分片把一份完整的数据进行切分，不同的分片分布到不同的节点上，再通过 Distributed 表引擎把数据拼接起来一同使用。</p>
<p><strong>Distributed 表引擎本身不存储数据</strong>，有点类似于 MyCat 之于 MySql，成为一种中间件，通过分布式逻辑表来写入、分发、路由来操作多台节点不同分片的分布式数据。</p>
<blockquote>
<p>注意：ClickHouse 的集群是表级别的，实际企业中，大部分做了高可用，但是没有用分片，避免降低查询性能以及操作集群的复杂性。</p>
</blockquote>
<h3 id="集群写入流程"><a href="#集群写入流程" class="headerlink" title="集群写入流程"></a>集群写入流程</h3><p>3 分片 2 副本共 6 个节点</p>
<p><img src="/images/image-20220316115358617.png" alt="image-20220316115358617"></p>
<h3 id="集群读取流程"><a href="#集群读取流程" class="headerlink" title="集群读取流程"></a>集群读取流程</h3><p>3 分片 2 副本共 6 个节点</p>
<p><img src="/images/image-20220316115924826.png" alt="image-20220316115924826"></p>
<h2 id="Explain-查看执行计划"><a href="#Explain-查看执行计划" class="headerlink" title="Explain 查看执行计划"></a>Explain 查看执行计划</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN [AST | SYNTAX | PLAN | PIPELINE] [setting = value, ...]</span><br><span class="line">SELECT ... [FORMAT ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>PLAN：用于查看执行计划，默认值。 <ul>
<li>header 打印计划中各个步骤的 head 说明，默认关闭，默认值 0; </li>
<li>description 打印计划中各个步骤的描述，默认开启，默认值 1； </li>
<li>actions 打印计划中各个步骤的详细信息，默认关闭，默认值 0。 </li>
</ul>
</li>
<li>AST ：用于查看语法树; </li>
<li>SYNTAX：用于优化语法; </li>
<li>PIPELINE：用于查看 PIPELINE 计划。 <ul>
<li>header 打印计划中各个步骤的 head 说明，默认关闭; </li>
<li>graph 用 DOT 图形语言描述管道图，默认关闭，需要查看相关的图形需要配合 graphviz 查看； </li>
<li>actions 如果开启了 graph，紧凑打印打，默认开启。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：PLAN 和 PIPELINE 还可以进行额外的显示设置，如上参数所示。</p>
</blockquote>
<p><img src="/images/image-20220316122520830.png" alt="image-20220316122520830"></p>
<p><img src="/images/image-20220316122859710.png" alt="image-20220316122859710"></p>
<h2 id="建表优化"><a href="#建表优化" class="headerlink" title="建表优化"></a>建表优化</h2><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4><p>建表时能用数值型或日期时间型表示的字段就不要用字符串，全 String 类型在以 Hive 为中心的数仓建设中常见，但 ClickHouse 环境不应受此影响。 </p>
<p>虽然 ClickHouse 底层将 DateTime 存储为时间戳 Long 类型，但不建议存储 Long 类型， 因为 DateTime 不需要经过函数转换处理，执行效率高、可读性好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table t_type2(</span><br><span class="line"> id UInt32,</span><br><span class="line"> sku_id String,</span><br><span class="line"> total_amount Decimal(16,2) ,</span><br><span class="line"> create_time Int32</span><br><span class="line">) engine =ReplacingMergeTree(create_time)</span><br><span class="line"> partition by toYYYYMMDD(toDate(create_time)) –-需要转换一次，否则报错</span><br><span class="line"> primary key (id)</span><br><span class="line"> order by (id, sku_id);</span><br></pre></td></tr></table></figure>



<h4 id="空值存储类型"><a href="#空值存储类型" class="headerlink" title="空值存储类型"></a>空值存储类型</h4><p>Nullable 类型几乎总是会拖累性能，因为存储 Nullable 列时需要创建一个额外的文件来存储 NULL 的标记，并且 Nullable 列无法被索引。因此<strong>除非极特殊情况，应直接使用字段默认值表示空，或者自行指定一个在业务中无意义的值</strong>（例如用 -1 表示没有商品 ID）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t_null(x Int8, y Nullable(Int8)) ENGINE TinyLog;</span><br><span class="line"></span><br><span class="line">INSERT INTO t_null VALUES (1, NULL), (2, 3);</span><br><span class="line"></span><br><span class="line">SELECT x + y FROM t_null;</span><br></pre></td></tr></table></figure>



<h3 id="分区和索引"><a href="#分区和索引" class="headerlink" title="分区和索引"></a>分区和索引</h3><p>分区粒度根据业务特点决定，不宜过粗或过细。<strong>一般选择按天分区</strong>，也可以指定为 Tuple()， 以单表一亿数据为例，分区大小控制在 10-30 个为最佳。 </p>
<p>必须指定索引列，<strong>ClickHouse 中的索引列即排序列</strong>，通过 order by 指定，一般在查询条件中经常被用来充当筛选条件的属性被纳入进来；可以是单一维度，也可以是组合维度的索引；通常需要满足高级列在前、查询频率大的在前原则；还有基数特别大的不适合做索引列， 如用户表的 userid 字段；通常筛选后的数据满足在百万以内为最佳。</p>
<p>官方案例的 hits_v1 表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">…… </span><br><span class="line">PARTITION BY toYYYYMM(EventDate) </span><br><span class="line">ORDER BY (CounterID, EventDate, intHash32(UserID)) </span><br><span class="line">…… </span><br></pre></td></tr></table></figure>

<p>visits_v1 表： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">PARTITION BY toYYYYMM(StartDate)</span><br><span class="line">ORDER BY (CounterID, StartDate, intHash32(UserID), VisitID)</span><br><span class="line">……</span><br></pre></td></tr></table></figure>



<h3 id="表参数"><a href="#表参数" class="headerlink" title="表参数"></a>表参数</h3><ul>
<li>Index_granularity 是用来控制索引粒度的，默认是 8192，如非必须不建议调整。</li>
<li>如果表中不是必须保留全量历史数据，建议指定 TTL（生存时间值），可以免去手动过期 历史数据的麻烦。</li>
</ul>
<h3 id="写入和删除优化"><a href="#写入和删除优化" class="headerlink" title="写入和删除优化"></a>写入和删除优化</h3><ol>
<li>尽量不要执行单条或小批量删除和插入操作，这样会产生小分区文件，给后台 Merge 任务带来巨大压力</li>
<li>不要一次写入太多分区，或数据写入太快，数据写入太快会导致 Merge 速度跟不 上而报错，一般建议每秒钟发起 2-3 次写入操作，每次操作写入 2w~5w 条数据（依服务器 性能而定）</li>
</ol>
<h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><p>配置项主要在 config.xml 或 users.xml 中， 基本上都在 users.xml 里</p>
<ul>
<li>config.xml：<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/">https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings/</a></li>
<li>users.xml：<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/operations/settings/settings/">https://clickhouse.com/docs/en/operations/settings/settings/</a></li>
</ul>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background_pool_size</td>
<td>后台线程池的大小，merge 线程就是在该线程池中执行，该线程池 不仅仅是给 merge 线程用的，默认值 16，允许的前提下建议改成 c pu 个数的 2 倍（线程数）。</td>
</tr>
<tr>
<td>background_schedule_pool_size</td>
<td>执行后台任务（复制表、Kafka 流、DNS 缓存更新）的线程数。默 认 128，建议改成 cpu 个数的 2 倍（线程数）。</td>
</tr>
<tr>
<td>background_distributed_schedule_pool_size</td>
<td>设置为分布式发送执行后台任务的线程数，默认 16，建议改成 cpu 个数的 2 倍（线程数）。</td>
</tr>
<tr>
<td>max_concurrent_queries</td>
<td>最大并发处理的请求数(包含 select,insert 等)，默认值 100，推荐 1 50(不够再加)~300。</td>
</tr>
<tr>
<td>max_threads</td>
<td>设置单个查询所能使用的最大 cpu 个数，默认是 cpu 核数</td>
</tr>
</tbody></table>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>max_memory_usage</td>
<td>此参数在 users.xml 中,表示单次 Query 占用内存最大值，该值可 以设置的比较大，这样可以提升集群查询的上限。 保留一点给 OS，比如 128G 内存的机器，设置为 100GB。</td>
</tr>
<tr>
<td>max_bytes_before_external_group_by</td>
<td>一般按照 max_memory_usage 的一半设置内存，当 group 使用内 存超过阈值后会刷新到磁盘进行。 因为 clickhouse 聚合分两个阶段：查询并及建立中间数据、合并中 间数据，结合上一项，建议 50GB。</td>
</tr>
<tr>
<td>max_bytes_before_external_sort</td>
<td>当 order by 已使用 max_bytes_before_external_sort 内存就进行 溢写磁盘(基于磁盘排序)，如果不设置该值，那么当内存不够时直接 抛错，设置了该值 order by 可以正常完成，但是速度相对存内存来 说肯定要慢点(实测慢的非常多，无法接受)。</td>
</tr>
<tr>
<td>max_table_size_to_drop</td>
<td>此参数在 config.xml 中，应用于需要删除表或分区的情况，默认是 50GB，意思是如果删除 50GB 以上的分区表会失败。建议修改为 0， 这样不管多大的分区表都可以删除。</td>
</tr>
</tbody></table>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>ClickHouse 不支持设置多数据目录，为了提升数据 io 性能，可以挂载虚拟券组，一个券组绑定多块物理磁盘提升读写性能，多数据查询场景 SSD 会比普通机械硬盘快 2-3 倍。</p>
<h2 id="ClickHouse-语法优化规则"><a href="#ClickHouse-语法优化规则" class="headerlink" title="ClickHouse 语法优化规则"></a>ClickHouse 语法优化规则</h2><p>ClickHouse 的语法优化其实很弱，只能优化低级错误。</p>
<h3 id="COUNT-优化"><a href="#COUNT-优化" class="headerlink" title="COUNT 优化"></a>COUNT 优化</h3><p>在调用 count 函数时，如果使用的是 count() 或者 count(*)，且没有 where 条件，则 会直接使用 system.tables 的 total_rows，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT count()FROM datasets.hits_v1;</span><br><span class="line">Union</span><br><span class="line"> Expression (Projection)</span><br><span class="line">   Expression (Before ORDER BY and SELECT)</span><br><span class="line">     MergingAggregated</span><br><span class="line">	     ReadNothing (Optimized trivial count)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Optimized trivial count ，这是对 count 的优化。</p>
</blockquote>
<p>如果 count 具体的列字段，则不会使用此项优化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT count(CounterID) FROM datasets.hits_v1;</span><br><span class="line">Union</span><br><span class="line"> Expression (Projection)</span><br><span class="line">   Expression (Before ORDER BY and SELECT)</span><br><span class="line">     Aggregating</span><br><span class="line">       Expression (Before GROUP BY)</span><br><span class="line">	       ReadFromStorage (Read from MergeTree)</span><br></pre></td></tr></table></figure>



<h3 id="消除子查询重复字段"><a href="#消除子查询重复字段" class="headerlink" title="消除子查询重复字段"></a>消除子查询重复字段</h3><p>下面语句子查询中有两个重复的 id 字段，会被去重:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX SELECT</span><br><span class="line"> a.UserID,</span><br><span class="line"> b.VisitID,</span><br><span class="line"> a.URL,</span><br><span class="line"> b.UserID</span><br><span class="line"> FROM</span><br><span class="line"> hits_v1 AS a</span><br><span class="line"> LEFT JOIN (</span><br><span class="line">   SELECT</span><br><span class="line">     UserID,</span><br><span class="line">     UserID as HaHa,</span><br><span class="line">     VisitID</span><br><span class="line">   FROM visits_v1) AS b</span><br><span class="line"> USING (UserID)</span><br><span class="line"> limit 3;</span><br><span class="line"></span><br><span class="line">//返回优化语句：</span><br><span class="line">SELECT</span><br><span class="line"> UserID,</span><br><span class="line"> VisitID,</span><br><span class="line"> URL,</span><br><span class="line"> b.UserID</span><br><span class="line">FROM hits_v1 AS a</span><br><span class="line">ALL LEFT JOIN</span><br><span class="line">(</span><br><span class="line"> SELECT</span><br><span class="line">   UserID,</span><br><span class="line">   VisitID</span><br><span class="line"> FROM visits_v1</span><br><span class="line">) AS b USING (UserID)</span><br><span class="line">LIMIT 3</span><br></pre></td></tr></table></figure>



<h3 id="谓词下推"><a href="#谓词下推" class="headerlink" title="谓词下推"></a>谓词下推</h3><p>当 group by 有 having 子句，但是没有 with cube、with rollup 或者 with totals 修饰的时候，<strong>having 过滤会下推到 where 提前过滤</strong>。</p>
<p>例如下面的查询，HAVING name 变成了 WHERE name，在 group by 之前过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX SELECT UserID FROM hits_v1 GROUP BY UserID HAVING UserID =</span><br><span class="line">&#x27;8585742290196126178&#x27;;</span><br><span class="line"></span><br><span class="line">//返回优化语句</span><br><span class="line">SELECT UserID</span><br><span class="line">FROM hits_v1</span><br><span class="line">WHERE UserID = \&#x27;8585742290196126178\&#x27;</span><br><span class="line">GROUP BY UserID</span><br></pre></td></tr></table></figure>



<p>子查询也支持谓词下推：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line">SELECT *</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line"> SELECT UserID</span><br><span class="line"> FROM visits_v1</span><br><span class="line">)</span><br><span class="line">WHERE UserID = &#x27;8585742290196126178&#x27;</span><br><span class="line"></span><br><span class="line">//返回优化后的语句</span><br><span class="line">SELECT UserID</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line"> SELECT UserID</span><br><span class="line"> FROM visits_v1</span><br><span class="line"> WHERE UserID = \&#x27;8585742290196126178\&#x27;</span><br><span class="line">)</span><br><span class="line">WHERE UserID = \&#x27;8585742290196126178\&#x27;</span><br></pre></td></tr></table></figure>



<p>一个复杂例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line">SELECT * FROM (</span><br><span class="line"> SELECT * FROM (</span><br><span class="line"> 	SELECT UserID FROM visits_v1</span><br><span class="line"> )</span><br><span class="line"> UNION ALL</span><br><span class="line"> SELECT * FROM (</span><br><span class="line"> 	SELECT UserID FROM visits_v1</span><br><span class="line"> )</span><br><span class="line">)</span><br><span class="line">WHERE UserID = &#x27;8585742290196126178&#x27;</span><br><span class="line"></span><br><span class="line">//返回优化后的语句</span><br><span class="line">SELECT UserID FROM (</span><br><span class="line"> SELECT UserID FROM (</span><br><span class="line">	 SELECT UserID FROM visits_v1 WHERE UserID = \&#x27;8585742290196126178\&#x27;</span><br><span class="line"> )</span><br><span class="line"> WHERE UserID = \&#x27;8585742290196126178\&#x27;</span><br><span class="line"> UNION ALL</span><br><span class="line"> SELECT UserID FROM (</span><br><span class="line">	 SELECT UserID FROM visits_v1 WHERE UserID = \&#x27;8585742290196126178\&#x27;</span><br><span class="line"> )</span><br><span class="line"> WHERE UserID = \&#x27;8585742290196126178\&#x27;</span><br><span class="line">)</span><br><span class="line">WHERE UserID = \&#x27;8585742290196126178\&#x27;</span><br></pre></td></tr></table></figure>



<h3 id="聚合计算外推"><a href="#聚合计算外推" class="headerlink" title="聚合计算外推"></a>聚合计算外推</h3><p>聚合函数内的计算，会外推，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line">SELECT sum(UserID * 2) FROM visits_v1</span><br><span class="line"></span><br><span class="line">//返回优化后的语句</span><br><span class="line">SELECT sum(UserID) * 2 FROM visits_v1</span><br></pre></td></tr></table></figure>



<h3 id="聚合函数消除"><a href="#聚合函数消除" class="headerlink" title="聚合函数消除"></a>聚合函数消除</h3><p>如果对聚合键，也就是 group by key 使用 min、max、any 聚合函数，则将函数消除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line">SELECT</span><br><span class="line"> sum(UserID * 2),</span><br><span class="line"> max(VisitID),</span><br><span class="line"> max(UserID)</span><br><span class="line">FROM visits_v1</span><br><span class="line">GROUP BY UserID</span><br><span class="line"></span><br><span class="line">//返回优化后的语句</span><br><span class="line">SELECT</span><br><span class="line"> sum(UserID) * 2,</span><br><span class="line"> max(VisitID),</span><br><span class="line"> UserID</span><br><span class="line">FROM visits_v1</span><br><span class="line">GROUP BY UserID</span><br></pre></td></tr></table></figure>



<h3 id="删除重复的-order-by-key"><a href="#删除重复的-order-by-key" class="headerlink" title="删除重复的 order by key"></a>删除重复的 order by key</h3><p>重复的聚合键 id 字段会被去重:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line">SELECT *</span><br><span class="line">FROM visits_v1</span><br><span class="line">ORDER BY</span><br><span class="line">	UserID ASC,</span><br><span class="line">	UserID ASC,</span><br><span class="line">	VisitID ASC,</span><br><span class="line">	VisitID ASC</span><br><span class="line"></span><br><span class="line">//返回优化后的语句：</span><br><span class="line">select ……</span><br><span class="line">FROM visits_v1</span><br><span class="line">ORDER BY</span><br><span class="line">	UserID ASC,</span><br><span class="line">	VisitID ASC</span><br></pre></td></tr></table></figure>



<h3 id="删除重复的-limit-by-key"><a href="#删除重复的-limit-by-key" class="headerlink" title="删除重复的 limit by key"></a>删除重复的 limit by key</h3><p>重复声明的 name 字段会被去重：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line">SELECT *</span><br><span class="line">FROM visits_v1</span><br><span class="line">LIMIT 3 BY</span><br><span class="line">	VisitID,</span><br><span class="line">	VisitID</span><br><span class="line">LIMIT 10</span><br><span class="line"></span><br><span class="line">//返回优化后的语句：</span><br><span class="line">select ……</span><br><span class="line">FROM visits_v1</span><br><span class="line">LIMIT 3 BY </span><br><span class="line">	VisitID</span><br><span class="line">LIMIT 10</span><br></pre></td></tr></table></figure>



<h3 id="删除重复的-USING-Key"><a href="#删除重复的-USING-Key" class="headerlink" title="删除重复的 USING Key"></a>删除重复的 USING Key</h3><p>重复的关联键 id 字段会被去重：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line">SELECT</span><br><span class="line">  a.UserID,</span><br><span class="line">  a.UserID,</span><br><span class="line">  b.VisitID,</span><br><span class="line">  a.URL,</span><br><span class="line">  b.UserID</span><br><span class="line">FROM hits_v1 AS a</span><br><span class="line">LEFT JOIN visits_v1 AS b USING (UserID, UserID)</span><br><span class="line"></span><br><span class="line">//返回优化后的语句：</span><br><span class="line">SELECT</span><br><span class="line">  UserID,</span><br><span class="line">  UserID,</span><br><span class="line">  VisitID,</span><br><span class="line">  URL,</span><br><span class="line">  b.UserID</span><br><span class="line">FROM hits_v1 AS a</span><br><span class="line">ALL LEFT JOIN visits_v1 AS b USING (UserID)</span><br></pre></td></tr></table></figure>



<h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p>如果子查询只返回一行数据，在被引用的时候用标量替换，例如下面语句中的 total_disk_usage 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line">WITH</span><br><span class="line"> ( SELECT sum(bytes) FROM system.parts WHERE active) AS total_disk_usage</span><br><span class="line">SELECT</span><br><span class="line"> (sum(bytes) / total_disk_usage) * 100 AS table_disk_usage,</span><br><span class="line"> table</span><br><span class="line">FROM system.parts</span><br><span class="line">GROUP BY table</span><br><span class="line">ORDER BY table_disk_usage DESC</span><br><span class="line">LIMIT 10;</span><br><span class="line"></span><br><span class="line">//返回优化后的语句：</span><br><span class="line">WITH CAST(0, \&#x27;UInt64\&#x27;) AS total_disk_usage</span><br><span class="line">SELECT</span><br><span class="line"> (sum(bytes) / total_disk_usage) * 100 AS table_disk_usage,</span><br><span class="line"> table</span><br><span class="line">FROM system.parts</span><br><span class="line">GROUP BY table</span><br><span class="line">ORDER BY table_disk_usage DESC</span><br><span class="line">LIMIT 10</span><br></pre></td></tr></table></figure>



<h3 id="三元运算优化"><a href="#三元运算优化" class="headerlink" title="三元运算优化"></a>三元运算优化</h3><p> 如果开启了 optimize_if_chain_to_multiif 参数，三元运算符会被替换成 multiIf 函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SYNTAX</span><br><span class="line">SELECT number = 1 ? &#x27;hello&#x27; : (number = 2 ? &#x27;world&#x27; : &#x27;atguigu&#x27;)</span><br><span class="line">FROM numbers(10)</span><br><span class="line">settings optimize_if_chain_to_multiif = 1;</span><br><span class="line"></span><br><span class="line">//返回优化后的语句：</span><br><span class="line">SELECT multiIf(number = 1, \&#x27;hello\&#x27;, number = 2, \&#x27;world\&#x27;, \&#x27;atguigu\&#x27;)</span><br><span class="line">FROM numbers(10)</span><br></pre></td></tr></table></figure>



<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><h4 id="Prewhere-替代-where"><a href="#Prewhere-替代-where" class="headerlink" title="Prewhere 替代 where"></a>Prewhere 替代 where</h4><p>Prewhere 和 where 语句的作用相同，用来过滤数据。不同之处在于 prewhere 只支持 *MergeTree 族系列引擎的表，首先会读取<strong>指定列</strong>数据，来判断数据过滤，等待数据过滤之后再读取 select 声明的列字段来补全其余属性。</p>
<p>当查询列明显多于筛选列时使用 Prewhere 可十倍提升查询性能，Prewhere 会自动优化 执行过滤阶段的数据读取方式，降低 io 操作。<strong>默认情况下，where条件会自动优化成prewhere</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"># 关闭where自动转prewhere</span><br><span class="line">set optimize_move_to_prewhere=0;</span><br><span class="line"></span><br><span class="line"># 使用 where</span><br><span class="line">select WatchID,</span><br><span class="line">  JavaEnable,</span><br><span class="line">  Title,</span><br><span class="line">  GoodEvent,</span><br><span class="line">  EventTime,</span><br><span class="line">  EventDate,</span><br><span class="line">  CounterID,</span><br><span class="line">  ClientIP,</span><br><span class="line">  ClientIP6,</span><br><span class="line">  RegionID,</span><br><span class="line">  UserID,</span><br><span class="line">  CounterClass,</span><br><span class="line">  OS,</span><br><span class="line">  UserAgent,</span><br><span class="line">  URL,</span><br><span class="line">  Referer,</span><br><span class="line">  URLDomain,</span><br><span class="line">  RefererDomain,</span><br><span class="line">  Refresh,</span><br><span class="line">  IsRobot,</span><br><span class="line">  RefererCategories,</span><br><span class="line">  URLCategories,</span><br><span class="line">  URLRegions,</span><br><span class="line">  RefererRegions,</span><br><span class="line">  ResolutionWidth,</span><br><span class="line">  ResolutionHeight,</span><br><span class="line">  ResolutionDepth,</span><br><span class="line">  FlashMajor,</span><br><span class="line">  FlashMinor,</span><br><span class="line">  FlashMinor2</span><br><span class="line">from datasets.hits_v1 where UserID=&#x27;3198390223272470366&#x27;;</span><br><span class="line"></span><br><span class="line"># 使用 prewhere 关键字</span><br><span class="line">select WatchID,</span><br><span class="line">  JavaEnable,</span><br><span class="line">  Title,</span><br><span class="line">  GoodEvent,</span><br><span class="line">  EventTime,</span><br><span class="line">  EventDate,</span><br><span class="line">  CounterID,</span><br><span class="line">  ClientIP,</span><br><span class="line">  ClientIP6,</span><br><span class="line">  RegionID,</span><br><span class="line">  UserID,</span><br><span class="line">  CounterClass,</span><br><span class="line">  OS,</span><br><span class="line">  UserAgent,</span><br><span class="line">  URL,</span><br><span class="line">  Referer,</span><br><span class="line">  URLDomain,</span><br><span class="line">  RefererDomain,</span><br><span class="line">  Refresh,</span><br><span class="line">  IsRobot,</span><br><span class="line">  RefererCategories,</span><br><span class="line">  URLCategories,</span><br><span class="line">  URLRegions,</span><br><span class="line">  RefererRegions,</span><br><span class="line">  ResolutionWidth,</span><br><span class="line">  ResolutionHeight,</span><br><span class="line">  ResolutionDepth,</span><br><span class="line">  FlashMajor,</span><br><span class="line">  FlashMinor,</span><br><span class="line">  FlashMinor2</span><br><span class="line">from datasets.hits_v1 prewhere UserID=&#x27;3198390223272470366&#x27;;</span><br></pre></td></tr></table></figure>

<p>默认情况，我们肯定不会关闭 where 自动优化成 prewhere，但是某些场景即使开启优化，也不会自动转换成 prewhere，需要手动指定 prewhere：</p>
<ul>
<li> 使用常量表达式</li>
<li>使用默认值为 alias 类型的字段</li>
<li>包含了 arrayJOIN，globalIn，globalNotIn 或者 indexHint 的查询</li>
<li>select 查询的列字段和 where 的谓词相同</li>
<li>使用了主键字段</li>
</ul>
<h4 id="数据采样"><a href="#数据采样" class="headerlink" title="数据采样"></a>数据采样</h4><p>通过采样运算可极大提升数据分析的性能。采样修饰符只有在 MergeTree engine 表中才有效，且在创建表时需要指定采样策略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT Title,count(*) AS PageViews</span><br><span class="line">FROM hits_v1</span><br><span class="line">SAMPLE 0.1 #代表采样10%的数据,也可以是具体的条数</span><br><span class="line">WHERE CounterID =57</span><br><span class="line">GROUP BY Title</span><br><span class="line">ORDER BY PageViews DESC LIMIT 1000</span><br></pre></td></tr></table></figure>



<h4 id="列裁剪与分区裁剪"><a href="#列裁剪与分区裁剪" class="headerlink" title="列裁剪与分区裁剪"></a>列裁剪与分区裁剪</h4><p>查询的性能会与查询的字段大小和数量成线性 表换，字段越少，消耗的 io 资源越少，性能就会越高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 反例：</span><br><span class="line">select * from datasets.hits_v1;</span><br><span class="line"></span><br><span class="line"># 正例：</span><br><span class="line">select WatchID,</span><br><span class="line"> JavaEnable,</span><br><span class="line"> Title,</span><br><span class="line"> GoodEvent,</span><br><span class="line"> EventTime,</span><br><span class="line"> EventDate,</span><br><span class="line"> CounterID,</span><br><span class="line"> ClientIP,</span><br><span class="line"> ClientIP6,</span><br><span class="line"> RegionID,</span><br><span class="line"> UserID</span><br><span class="line">from datasets.hits_v1;</span><br></pre></td></tr></table></figure>



<p>分区裁剪就是只读取需要的分区，在过滤条件中指定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select WatchID,</span><br><span class="line">  JavaEnable,</span><br><span class="line">  Title,</span><br><span class="line">  GoodEvent,</span><br><span class="line">  EventTime,</span><br><span class="line">  EventDate,</span><br><span class="line">  CounterID,</span><br><span class="line">  ClientIP,</span><br><span class="line">  ClientIP6,</span><br><span class="line">  RegionID,</span><br><span class="line">  UserID</span><br><span class="line">from datasets.hits_v1</span><br><span class="line">where EventDate=&#x27;2014-03-23&#x27;;</span><br></pre></td></tr></table></figure>



<h4 id="避免构建虚拟列"><a href="#避免构建虚拟列" class="headerlink" title="避免构建虚拟列"></a>避免构建虚拟列</h4><p>如非必须，不要在结果集上构建虚拟列，虚拟列非常消耗资源浪费性能，可以考虑在前端进行处理，或者在表中构造实际字段进行额外存储。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 反例</span><br><span class="line">SELECT Income,Age,Income/Age as IncRate FROM datasets.hits_v1;</span><br><span class="line"></span><br><span class="line"># 正例：拿到 Income 和 Age 后，考虑在前端进行处理，或者在表中构造实际字段进行额外存储</span><br><span class="line">SELECT Income,Age FROM datasets.hits_v1;</span><br></pre></td></tr></table></figure>



<h4 id="uniqCombined-替代-distinct"><a href="#uniqCombined-替代-distinct" class="headerlink" title="uniqCombined 替代 distinct"></a>uniqCombined 替代 distinct</h4><p>性能可提升 10 倍以上，uniqCombined 底层采用类似 HyperLogLog 算法实现，如果能接受 2% 左右的数据误差，可直接使用这种去重方式提升查询性能。Count(distinct) 会使用 uniqExact 精确去重。</p>
<p>不建议在千万级不同数据上执行 distinct 去重查询，改为近似去重 uniqCombined</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 反例：</span><br><span class="line">select count(distinct rand()) from hits_v1;</span><br><span class="line"># 正例：</span><br><span class="line">SELECT uniqCombined(rand()) from datasets.hits_v1</span><br></pre></td></tr></table></figure>



<h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><ul>
<li><strong>查询熔断</strong>：为了避免因个别慢查询引起的服务雪崩的问题，除了可以为单个查询设置超时以外，还可以配置周期熔断，在一个查询周期内，如果用户频繁进行慢查询操作超出规定阈值后将无法继续进行查询操作。</li>
<li><strong>关闭虚拟内存</strong>：物理内存和虚拟内存的数据交换，会导致查询变慢，资源允许的情况下关闭虚拟内存。 </li>
<li><strong>配置 join_use_nulls</strong>：为每一个账户添加 join_use_nulls 配置，左表中的一条记录在右表中不存在，右表的相应字段会返回该字段相应数据类型的默认值，而不是标准 SQL 中的 Null 值。</li>
<li><strong>批量写入时先排序</strong>：批量写入数据时，必须控制每个批次的数据中涉及到的分区的数量，在写入之前最好对 需要导入的数据进行排序。无序的数据或者涉及的分区太多，会导致 ClickHouse 无法及时对新导入的数据进行合并，从而影响查询性能。</li>
<li><strong>关注 CPU</strong>：cpu 一般在 50% 左右会出现查询波动，达到 70% 会出现大范围的查询超时，cpu 是最关键的指标，要非常关注。</li>
</ul>
<h3 id="多表关联"><a href="#多表关联" class="headerlink" title="多表关联"></a>多表关联</h3><h4 id="用-IN-代替-JOIN"><a href="#用-IN-代替-JOIN" class="headerlink" title="用 IN 代替 JOIN"></a>用 IN 代替 JOIN</h4><p>当多表联查时，查询的数据仅从其中一张表出时，可考虑用 IN 操作而不是 JOIN</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert into hits_v2</span><br><span class="line">select a.* from hits_v1 a where a. CounterID in (select CounterID from</span><br><span class="line">visits_v1);</span><br><span class="line"></span><br><span class="line">#反例：使用 join</span><br><span class="line">insert into table hits_v2</span><br><span class="line">select a.* from hits_v1 a left join visits_v1 b on a. CounterID=b.</span><br><span class="line">CounterID;</span><br></pre></td></tr></table></figure>



<h4 id="大小表-JOIN"><a href="#大小表-JOIN" class="headerlink" title="大小表 JOIN"></a>大小表 JOIN</h4><p>多表 join 时要满足<strong>小表在右</strong>的原则，右表关联时被加载到内存中与左表进行比较，ClickHouse 中无论是 Left join 、Right join 还是 Inner join 永远都是拿着右表中的每一条记录到左表中查找该记录是否存在，所以右表必须是小表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 小表在右</span><br><span class="line">insert into table hits_v2</span><br><span class="line">select a.* from hits_v1 a left join visits_v2 b on a. CounterID=b.</span><br><span class="line">CounterID;</span><br><span class="line"></span><br><span class="line"># 大表在右</span><br><span class="line">insert into table hits_v2</span><br><span class="line">select a.* from visits_v2 b left join hits_v1 a on a. CounterID=b.</span><br><span class="line">CounterID;</span><br></pre></td></tr></table></figure>



<h4 id="注意谓词下推"><a href="#注意谓词下推" class="headerlink" title="注意谓词下推"></a>注意谓词下推</h4><p>ClickHouse 在 join 查询时不会主动发起谓词下推的操作，需要每个子查询提前完成过滤操作，需要注意的是，是否执行谓词下推，对性能影响差别很大（新版本中已经不存在此问题，但是需要注意谓词的位置的不同依然有性能的差异）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Explain syntax</span><br><span class="line">select a.* from hits_v1 a left join visits_v2 b on a. CounterID=b.</span><br><span class="line">CounterID</span><br><span class="line">having a.EventDate = &#x27;2014-03-17&#x27;;</span><br><span class="line"></span><br><span class="line">Explain syntax</span><br><span class="line">select a.* from hits_v1 a left join visits_v2 b on a. CounterID=b.</span><br><span class="line">CounterID</span><br><span class="line">having b.StartDate = &#x27;2014-03-17&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select a.* from hits_v1 a left join visits_v2 b on a. CounterID=b.</span><br><span class="line">CounterID</span><br><span class="line">where a.EventDate = &#x27;2014-03-17&#x27;;</span><br><span class="line"></span><br><span class="line">select a.* from (</span><br><span class="line"> select * from</span><br><span class="line"> hits_v1</span><br><span class="line"> where EventDate = &#x27;2014-03-17&#x27;</span><br><span class="line">) a left join visits_v2 b on a. CounterID=b. CounterID;</span><br></pre></td></tr></table></figure>



<h4 id="分布式表使用-GLOBAL"><a href="#分布式表使用-GLOBAL" class="headerlink" title="分布式表使用 GLOBAL"></a>分布式表使用 GLOBAL</h4><p>两张分布式表上的 IN 和 JOIN 之前必须加上 <code>GLOBAL</code> 关键字，右表只会在接收查询请求的那个节点查询一次，并将其分发到其他节点上。如果不加 GLOBAL 关键字的话，每个节点都会单独发起一次对右表的查询，而右表又是分布式表，就导致右表一共会被查询 N² 次（N 是该分布式表的分片数量），这就是查询放大，会带来很大开销。</p>
<h4 id="使用字典表"><a href="#使用字典表" class="headerlink" title="使用字典表"></a>使用字典表</h4><p>将一些需要关联分析的业务创建成字典表进行 join 操作，前提是字典表不宜太大，因为字典表会常驻内存。</p>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p>即便对数据一致性支持最好的 Mergetree，也只是<strong>保证最终一致性</strong>。</p>
<blockquote>
<p><strong>数据的去重只会在数据合并期间进行</strong>，合并会在后台一个不确定的时间进行，因此你无法预先作出计划。有一些数据可能仍未被处理。尽管你可以调用 OPTIMIZE 语句发起计划外的合并，但请不要依靠它，因OPTIMIZE语句会引发对数据的大量读写。<br>因此，ReplacingMergeTree 适用于在后台清除重复的数据以节省空间，但是它不保证没有重复的数据出现。</p>
</blockquote>
<p>我们在使用 ReplacingMergeTree、SummingMergeTree 这类表引擎的时候，会出现短暂数据不一致的情况。 在某些对一致性非常敏感的场景，通常有以下几种解决方案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 数据准备</span><br><span class="line">- user_id 是数据去重更新的标识;</span><br><span class="line">- create_time 是版本号字段，每组数据中 create_time 最大的一行表示最新的数据;</span><br><span class="line">- deleted 是自定的一个标记位，比如 0 代表未删除，1 代表删除数据。</span><br><span class="line">CREATE TABLE test_a(</span><br><span class="line"> user_id UInt64,</span><br><span class="line"> score String,</span><br><span class="line"> deleted UInt8 DEFAULT 0,</span><br><span class="line"> create_time DateTime DEFAULT toDateTime(0)</span><br><span class="line">)ENGINE= ReplacingMergeTree(create_time)</span><br><span class="line">ORDER BY user_id;</span><br><span class="line"></span><br><span class="line"># 写入 1000 万 测试数据</span><br><span class="line">INSERT INTO TABLE test_a(user_id,score)</span><br><span class="line">WITH(</span><br><span class="line"> SELECT [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;]</span><br><span class="line">)AS dict</span><br><span class="line">SELECT number AS user_id, dict[number%7+1] FROM numbers(10000000);</span><br><span class="line"></span><br><span class="line"># 修改前 50 万 行数据，修改内容包括 name 字段和 create_time 版本号字段</span><br><span class="line">INSERT INTO TABLE test_a(user_id,score,create_time)</span><br><span class="line">WITH(</span><br><span class="line"> SELECT [&#x27;AA&#x27;,&#x27;BB&#x27;,&#x27;CC&#x27;,&#x27;DD&#x27;,&#x27;EE&#x27;,&#x27;FF&#x27;,&#x27;GG&#x27;]</span><br><span class="line">)AS dict</span><br><span class="line">SELECT number AS user_id, dict[number%7+1], now() AS create_time FROM</span><br><span class="line">numbers(500000);</span><br><span class="line"></span><br><span class="line"># 统计总数</span><br><span class="line">SELECT COUNT() FROM test_a; # 10500000,还未触发分区合并，所以还未去重。</span><br></pre></td></tr></table></figure>



<h3 id="手动-OPTIMIZE"><a href="#手动-OPTIMIZE" class="headerlink" title="手动 OPTIMIZE"></a>手动 OPTIMIZE</h3><p>在写入数据后，立刻执行 OPTIMIZE 强制触发新写入分区的合并动作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">OPTIMIZE TABLE [db.]name [ON CLUSTER cluster] [PARTITION partition |</span><br><span class="line">PARTITION ID &#x27;partition_id&#x27;] [FINAL] [DEDUPLICATE [BY expression]]</span><br><span class="line"></span><br><span class="line">OPTIMIZE TABLE test_a FINAL;</span><br></pre></td></tr></table></figure>



<h3 id="通过-Group-by-去重"><a href="#通过-Group-by-去重" class="headerlink" title="通过 Group by 去重"></a>通过 Group by 去重</h3><p>执行去重的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  user_id ,</span><br><span class="line">  argMax(score, create_time) AS score,</span><br><span class="line">  argMax(deleted, create_time) AS deleted,</span><br><span class="line">  max(create_time) AS ctime</span><br><span class="line">FROM test_a</span><br><span class="line">GROUP BY user_id</span><br><span class="line">HAVING deleted = 0;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>argMax(field1，field2)</code>：按照 field2 的最大值取 field1 的值。</p>
</blockquote>
<p>注意数据并没有被真正的删除，而是被过滤掉了。在一些合适的场景下，可以结合表级别的 TTL 最终将物理数据删除。</p>
<h3 id="通过-FINAL-查询"><a href="#通过-FINAL-查询" class="headerlink" title="通过 FINAL 查询"></a>通过 FINAL 查询</h3><p>在查询语句后增加 FINAL 修饰符，这样在查询的过程中<strong>将会执行 Merge 的特殊逻辑</strong>（例如数据去重，预聚合等）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 普通查询语句</span><br><span class="line">select * from visits_v1 WHERE StartDate = &#x27;2014-03-17&#x27; limit 100 settings</span><br><span class="line">max_threads = 2;</span><br><span class="line"></span><br><span class="line"># 查看执行计划：</span><br><span class="line"># 明显将由 2 个线程并行读取 part 查询。</span><br><span class="line">explain pipeline select * from visits_v1 WHERE StartDate = &#x27;2014-03-17&#x27;</span><br><span class="line">limit 100 settings max_threads = 2;</span><br><span class="line">(Expression)</span><br><span class="line">ExpressionTransform × 2</span><br><span class="line">  (SettingQuotaAndLimits)</span><br><span class="line">  (Limit)</span><br><span class="line">  Limit 2 → 2</span><br><span class="line">    (ReadFromMergeTree) </span><br><span class="line">    MergeTreeThread × 2 0 → 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># FINAL 查询</span><br><span class="line">select * from visits_v1 final WHERE StartDate = &#x27;2014-03-17&#x27; limit 100</span><br><span class="line">settings max_final_threads = 2;</span><br><span class="line"></span><br><span class="line"># 查看执行计划：</span><br><span class="line"># 从 CollapsingSortedTransform 这一步开始已经是多线程执行，但是读取 part 部分的动</span><br><span class="line">作还是串行。</span><br><span class="line">explain pipeline select * from visits_v1 final WHERE StartDate = &#x27;2014-</span><br><span class="line">03-17&#x27; limit 100 settings max_final_threads = 2;</span><br><span class="line">(Expression)</span><br><span class="line">ExpressionTransform × 2</span><br><span class="line">  (SettingQuotaAndLimits)</span><br><span class="line">  (Limit)</span><br><span class="line">  Limit 2 → 2</span><br><span class="line">    (ReadFromMergeTree)</span><br><span class="line">    ExpressionTransform × 2</span><br><span class="line">      CollapsingSortedTransform × 2</span><br><span class="line">        Copy 1 → 2</span><br><span class="line">          AddingSelector</span><br><span class="line">            ExpressionTransform</span><br><span class="line">            	MergeTree 0 → 1</span><br></pre></td></tr></table></figure>



<h2 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h2><p>普通视图不保存数据，保存的仅仅是查询语句，查询的时候还是从原表读取数据，物化视图则是把查询的结果根据相应的引擎存入到了磁盘 或内存中。</p>
<p>物化视图是一种<strong>查询结果的持久化</strong>，它就是一张表，它也像是一张时刻在预计算的表，创建的过程它是用了一个特殊引擎，加上后来 as select，就是 create 一个 table as select 的写法。</p>
<ul>
<li>优点：查询速度快，要是把物化视图这些规则全部写好，它比原数据查询快了很多，总的行数少了，因为都预计算好了。 </li>
<li>缺点：它的<strong>本质是一个流式数据的使用场景，是累加式的技术</strong>，所以要用历史数据做去重、去核这样的分析，在物化视图里面是不太好用的。在某些场景的使用也是有限的。而且 如果一张表加了好多物化视图，在写这张表的时候，就会消耗很多机器的资源，比如数据带宽占满、存储一下子增加了很多。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [MATERIALIZED] VIEW [IF NOT EXISTS] [db.]table_name [TO[db.]name]</span><br><span class="line">[ENGINE = engine] [POPULATE] AS SELECT ...</span><br></pre></td></tr></table></figure>

<p>TO 表名：保存到一张显式的表。没有加 TO 表名，表名默认就是 <code>.inner.</code> 物化视图名</p>
<p>数据准备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 建表语句</span><br><span class="line">CREATE TABLE hits_test</span><br><span class="line">(</span><br><span class="line"> EventDate Date,</span><br><span class="line"> CounterID UInt32,</span><br><span class="line"> UserID UInt64,</span><br><span class="line"> URL String,</span><br><span class="line"> Income UInt8</span><br><span class="line">)</span><br><span class="line">ENGINE = MergeTree()</span><br><span class="line">PARTITION BY toYYYYMM(EventDate)</span><br><span class="line">ORDER BY (CounterID, EventDate, intHash32(UserID))</span><br><span class="line">SAMPLE BY intHash32(UserID)</span><br><span class="line">SETTINGS index_granularity = 8192</span><br><span class="line"></span><br><span class="line"># 导入数据</span><br><span class="line">INSERT INTO hits_test</span><br><span class="line"> SELECT</span><br><span class="line"> EventDate,</span><br><span class="line"> CounterID,</span><br><span class="line"> UserID,</span><br><span class="line"> URL,</span><br><span class="line"> Income</span><br><span class="line">FROM hits_v1</span><br><span class="line">limit 10000;</span><br></pre></td></tr></table></figure>

<p>创建物化视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 创建物化视图</span><br><span class="line">CREATE MATERIALIZED VIEW hits_mv</span><br><span class="line">ENGINE=SummingMergeTree</span><br><span class="line">PARTITION BY toYYYYMM(EventDate) ORDER BY (EventDate, intHash32(UserID))</span><br><span class="line">AS SELECT</span><br><span class="line">UserID,</span><br><span class="line">EventDate,</span><br><span class="line">count(URL) as ClickCount,</span><br><span class="line">sum(Income) AS IncomeSum</span><br><span class="line">FROM hits_test</span><br><span class="line">WHERE EventDate &gt;= &#x27;2014-03-20&#x27; #设置更新点,该时间点之前的数据可以另外通过</span><br><span class="line"> 																#insert into select …… 的方式进行插入</span><br><span class="line">GROUP BY UserID,EventDate;</span><br><span class="line"></span><br><span class="line"># 或者可以用下列语法，表 A 可以是一张 mergetree 表</span><br><span class="line">CREATE MATERIALIZED VIEW 物化视图名 TO 表 A</span><br><span class="line">AS SELECT FROM 表 B;</span><br><span class="line"></span><br><span class="line">#不建议添加 populate 关键字进行全量更新</span><br></pre></td></tr></table></figure>

<p>导入增量数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#导入增量数据</span><br><span class="line">INSERT INTO hits_test</span><br><span class="line">SELECT</span><br><span class="line"> EventDate,</span><br><span class="line"> CounterID,</span><br><span class="line"> UserID,</span><br><span class="line"> URL,</span><br><span class="line"> Income</span><br><span class="line">FROM hits_v1</span><br><span class="line">WHERE EventDate &gt;= &#x27;2014-03-23&#x27;</span><br><span class="line">limit 10;</span><br><span class="line"></span><br><span class="line">#查询物化视图</span><br><span class="line">SELECT * FROM hits_mv;</span><br></pre></td></tr></table></figure>

<p>导入历史数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#导入增量数据</span><br><span class="line">INSERT INTO hits_mv</span><br><span class="line">SELECT</span><br><span class="line"> UserID,</span><br><span class="line"> EventDate,</span><br><span class="line"> count(URL) as ClickCount,</span><br><span class="line"> sum(Income) AS IncomeSum</span><br><span class="line">FROM hits_test</span><br><span class="line">WHERE EventDate = &#x27;2014-03-20&#x27;</span><br><span class="line">GROUP BY UserID,EventDate</span><br><span class="line"></span><br><span class="line">#查询物化视图</span><br><span class="line">SELECT * FROM hits_mv;</span><br></pre></td></tr></table></figure>



<h3 id="创建物化视图的限制"><a href="#创建物化视图的限制" class="headerlink" title="创建物化视图的限制"></a>创建物化视图的限制</h3><ol>
<li>必须指定物化视图的 engine 用于数据存储 </li>
<li><code>TO [db].[table]</code> 语法的时候，不得使用 POPULATE。 </li>
<li>查询语句(select）可以包含下面的子句： DISTINCT, GROUP BY, ORDER BY, LIMIT… </li>
<li>物化视图的 alter 操作有些限制，操作起来不大方便。 </li>
<li>若物化视图的定义使用了 <code>TO [db.]name</code> 子语句，则可以将目标表的视图卸载 DETACH 再装载 ATTACH</li>
</ol>
<h3 id="物化视图的数据更新"><a href="#物化视图的数据更新" class="headerlink" title="物化视图的数据更新"></a>物化视图的数据更新</h3><ul>
<li><strong>物化视图创建好之后，若源表被写入新数据则物化视图也会同步更新</strong>。</li>
<li>POPULATE 关键字决定了物化视图的更新策略：<ul>
<li>若有 POPULATE 则在创建视图的过程会将源表已经存在的数据一并导入，类似于 create table … as </li>
<li>若无 POPULATE 则物化视图在创建之后没有数据，只会在创建只有同步之后写入源表的数据 </li>
<li>clickhouse 官方并不推荐使用 POPULATE，因为在创建物化视图的过程中同时写入的数据不能被插入物化视图。</li>
</ul>
</li>
<li><strong>物化视图不支持同步删除，若源表的数据不存在（删除了）则物化视图的数据仍然保留</strong>。</li>
<li>物化视图是一种特殊的数据表，可以用 show tables 查看</li>
</ul>
<h2 id="MaterializeMySQL-引擎"><a href="#MaterializeMySQL-引擎" class="headerlink" title="MaterializeMySQL 引擎"></a>MaterializeMySQL 引擎</h2><p>MaterializeMySQL 的 database 引擎能映射到 MySQL 中的某个 database，并自动在 ClickHouse 中创建对应的 ReplacingMergeTree。ClickHouse 服务做为 MySQL 副本，读取 Binlog 并执行 DDL 和 DML 请求，实现了基于 MySQL Binlog 机制的业务数据库实时同步功能。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>MaterializeMySQL 同时支持<code>全量</code>和<code>增量</code>同步，在 database 创建之初会全量同步 MySQL 中的表和数据，之后则会通过 binlog 进行增量同步。 </li>
<li>MaterializeMySQL database 为其所创建的每张 ReplacingMergeTree 自动增加了 <code>_sign</code> 和 <code>_version</code> 字段。 <ul>
<li><code>_version</code> 用作 ReplacingMergeTree 的 ver 版本参数，每当监听到 insert、update 和 delete 事件时，在 databse 内全局自增。</li>
<li><code>_sign</code> 则用于标记是否被删除，取值 1 或 者 -1。</li>
</ul>
</li>
</ul>
<p>目前 MaterializeMySQL 支持如下几种 binlog 事件：</p>
<ul>
<li>MYSQL_WRITE_ROWS_EVENT: <code>_sign</code> = 1，<code>_version</code> ++ </li>
<li>MYSQL_DELETE_ROWS_EVENT: <code>_sign</code> = -1，<code>_version</code> ++ </li>
<li>MYSQL_UPDATE_ROWS_EVENT: 新数据 <code>_sign</code> = 1 </li>
<li>MYSQL_QUERY_EVENT: 支持 CREATE TABLE 、DROP TABLE 、RENAME TABLE 等。</li>
</ul>
<h3 id="使用细则"><a href="#使用细则" class="headerlink" title="使用细则"></a>使用细则</h3><h4 id="DDL-查询"><a href="#DDL-查询" class="headerlink" title="DDL 查询"></a>DDL 查询</h4><p>MySQL DDL 查询被转换成相应的 ClickHouse DDL 查询（ALTER, CREATE, DROP, RENAME）。 如果 ClickHouse 不能解析某些 DDL 查询，该查询将被忽略。</p>
<h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4><p>MaterializeMySQL 不支持直接插入、删除和更新查询，而是将 DDL 语句进行相应转换： </p>
<ul>
<li>MySQL INSERT 查询被转换为 INSERT with _sign=1。 </li>
<li>MySQL DELETE 查询被转换为 INSERT with _sign=-1。 </li>
<li>MySQL UPDATE 查询被转换成 INSERT with _sign=1 和 INSERT with _sign=-1。</li>
</ul>
<h4 id="SELECT-查询"><a href="#SELECT-查询" class="headerlink" title="SELECT 查询"></a>SELECT 查询</h4><ul>
<li>如果在 SELECT 查询中没有指定 <code>_version</code>，则使用 FINAL 修饰符，返回 <code>_version</code> 的最大值对应的数据，即最新版本的数据。</li>
<li>如果在 SELECT 查询中没有指定 <code>_sign</code>，则默认使用 WHERE <code>_sign</code>=1，即返回未删除状态 （<code>_sign</code>=1)的数据。</li>
</ul>
<h4 id="索引转换"><a href="#索引转换" class="headerlink" title="索引转换"></a>索引转换</h4><p>ClickHouse 数据库表会自动将 MySQL 主键和索引子句转换为 ORDER BY 元组。</p>
<p>ClickHouse 只有一个物理顺序，由 ORDER BY 子句决定。如果需要创建新的物理顺序， 请使用物化视图。</p>
<h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><p>MySQL 数据准备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE testck;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `testck`.`t_organization` (</span><br><span class="line"> `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line"> `code` int NOT NULL,</span><br><span class="line"> `name` text DEFAULT NULL,</span><br><span class="line"> `updatetime` datetime DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY (`id`),</span><br><span class="line"> UNIQUE KEY (`code`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">INSERT INTO testck.t_organization (code, name,updatetime)</span><br><span class="line">VALUES(1000,&#x27;Realinsight&#x27;,NOW());</span><br><span class="line">INSERT INTO testck.t_organization (code, name,updatetime)</span><br><span class="line">VALUES(1001, &#x27;Realindex&#x27;,NOW());</span><br><span class="line">INSERT INTO testck.t_organization (code, name,updatetime)</span><br><span class="line">VALUES(1002,&#x27;EDT&#x27;,NOW());</span><br><span class="line"></span><br><span class="line">CREATE TABLE `testck`.`t_user` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line"> `code` int,</span><br><span class="line"> PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">INSERT INTO testck.t_user (code) VALUES(1);</span><br></pre></td></tr></table></figure>

<p>开启 ClickHouse 物化引擎：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set allow_experimental_database_materialize_mysql=1;</span><br></pre></td></tr></table></figure>

<p>创建复制管道：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ClickHouse 中创建 MaterializeMySQL 数据库</span><br><span class="line"># 其中 4 个参数分别是 MySQL 地址、databse、username 和 password。</span><br><span class="line">CREATE DATABASE test_binlog ENGINE =</span><br><span class="line">MaterializeMySQL(&#x27;your-MySQL-ip:3306&#x27;,&#x27;testck&#x27;,&#x27;root&#x27;,&#x27;000000&#x27;);</span><br><span class="line"></span><br><span class="line"># 查看 ClickHouse 的数据</span><br><span class="line">use test_binlog;</span><br><span class="line">show tables;</span><br><span class="line">select * from t_organization;</span><br><span class="line">select * from t_user;</span><br></pre></td></tr></table></figure>

<p>修改数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 在 MySQL 中修改数据:</span><br><span class="line">update t_organization set name = CONCAT(name,&#x27;-v1&#x27;) where id = 1</span><br><span class="line"></span><br><span class="line"># 查看 clickhouse 日志可以看到 binlog 监听事件，查询 clickhouse</span><br><span class="line">select * from t_organization;</span><br><span class="line"></span><br><span class="line"># 查询 _sign 和 _version 虚拟字段</span><br><span class="line">select *,_sign,_version from t_organization order by _sign</span><br><span class="line">desc,_version desc;</span><br></pre></td></tr></table></figure>



<h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><h3 id="分布式-DDL-某数据节点的副本不执行"><a href="#分布式-DDL-某数据节点的副本不执行" class="headerlink" title="分布式 DDL 某数据节点的副本不执行"></a>分布式 DDL 某数据节点的副本不执行</h3><p>使用分布式 ddl 执行命令 create table on cluster xxxx 某个节点上没有创建表，但是 client 返回正常，查看日志有如下报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Error&gt; xxx.xxx: Retrying createReplica(), because some other replicas</span><br><span class="line">were created at the same time</span><br></pre></td></tr></table></figure>

<p>解决办法：重启该不执行的节点。</p>
<h3 id="数据副本表和数据不一致"><a href="#数据副本表和数据不一致" class="headerlink" title="数据副本表和数据不一致"></a>数据副本表和数据不一致</h3><p>由于某个数据节点副本异常，导致两数据副本表不一致，某个数据副本缺 少表，需要将两个数据副本调整一致。</p>
<p>解决办法： 在缺少表的数据副本节点上创建缺少的表，创建为本地表，表结构可以在其他数据副本通过 show crete table xxxx 获取。 表结构创建后，clickhouse 会自动从其他副本同步该表数据，验证数据量是否一致即可。</p>
<h3 id="副本节点全量恢复"><a href="#副本节点全量恢复" class="headerlink" title="副本节点全量恢复"></a>副本节点全量恢复</h3><p>某个数据副本异常无法启动，需要重新搭建副本。</p>
<p>解决办法：</p>
<ol>
<li>清空异常副本节点的 metadata 和 data 目录。 </li>
<li>从另一个正常副本将 metadata 目录拷贝过来（这一步之后可以启动数据库，但是只有 表结构没有数据）。</li>
<li>执行 sudo -u clickhouse touch /data/clickhouse/flags/force_restore_data </li>
<li>启动数据库。</li>
</ol>
<h3 id="数据副本启动缺少-zk-表"><a href="#数据副本启动缺少-zk-表" class="headerlink" title="数据副本启动缺少 zk 表"></a>数据副本启动缺少 zk 表</h3><p>某个数据副本表在 zk 上丢失数据，或者不存在，但是 metadata 元数据里 存在，导致启动异常，报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Can’t get data for node /clickhouse/tables/01-</span><br><span class="line">02/xxxxx/xxxxxxx/replicas/xxx/metadata: node doesn’t exist (No node):</span><br><span class="line">Cannot attach table xxxxxxx</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<ol>
<li>metadata 中移除该表的结构文件，如果多个表报错都移除 </li>
<li>mv metadata/xxxxxx/xxxxxxxx.sql /tmp/ </li>
<li>启动数据库 </li>
<li>手工创建缺少的表，表结构从其他节点 show create table 获取。</li>
<li>创建后会自动同步数据，验证数据是否一致。</li>
</ol>
<h3 id="ZK-table-replicas-数据未删除，导致重建表报错"><a href="#ZK-table-replicas-数据未删除，导致重建表报错" class="headerlink" title="ZK table replicas 数据未删除，导致重建表报错"></a>ZK table replicas 数据未删除，导致重建表报错</h3><p>重建表过程中，先使用 drop table xxx on cluster xxx ,各节点在 clickhouse 上 table 已物理删除，但是 zk 里面针对某个 clickhouse 节点的 table meta 信息未被删除（低概率事件），因 zk 里仍存在该表的 meta 信息，导致再次创建该表 create table xxx on cluster, 该 节点无法创建表(其他节点创建表成功)，报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Replica /clickhouse/tables/01-03/xxxxxx/xxx/replicas/xxx already exists..</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<ol>
<li>从其他数据副本 cp 该 table 的 metadata sql 过来.</li>
<li>重启节点。</li>
</ol>
<h3 id="Clickhouse-节点意外关闭"><a href="#Clickhouse-节点意外关闭" class="headerlink" title="Clickhouse 节点意外关闭"></a>Clickhouse 节点意外关闭</h3><p>模拟其中一个节点意外宕机，在大量 insert 数据的情况下，关闭某个节点。</p>
<p>数据写入不受影响、数据查询不受影响、建表 DDL 执行到异常节点会卡住， 报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Code: 159. DB::Exception: Received from localhost:9000. DB::Exception:</span><br><span class="line">Watching task /clickhouse/task_queue/ddl/query-0000565925 is executing</span><br><span class="line">longer than distributed_ddl_task_timeout (=180) seconds. There are 1</span><br><span class="line">unfinished hosts (0 of them are currently active), they are going to</span><br><span class="line">execute the query in background.</span><br></pre></td></tr></table></figure>

<p>解决办法：启动异常节点，期间其他副本写入数据会自动同步过来，其他副本的建表 DDL 也会同步。</p>
<h2 id="ClickHouse-监控概述"><a href="#ClickHouse-监控概述" class="headerlink" title="ClickHouse 监控概述"></a>ClickHouse 监控概述</h2><p>ClickHouse 运行时会将一些个自身的运行状态记录到众多系统表中(system.*)。我们对于 ClickHouse 自身的一些运行指标的监控数据，也主要来自这些系统表。</p>
<p>但是直接查询这些系统表会有一些不足之处：</p>
<ul>
<li>这种方式太过底层，不够直观，我们还需要在此之上实现可视化展示；</li>
<li>系统表只记录了 ClickHouse 自己的运行指标，有些时候我们需要外部系统的指标进行关联分析，例如 ZooKeeper、服务器 CPU、IO 等等。</li>
</ul>
<p>现在 Prometheus + Grafana 的组合比较流行，安装简单易上手，可以集成很多框架，包括服务器的负载，其中 Prometheus 负责收集各类系统的运行指标；Grafana 负责可视化的部分。</p>
<p>ClickHouse 从 v20.1.2.4 开始，内置了对接 Prometheus 的功能，配置的方式也很简单, 可以将其作为 Prometheus 的 Endpoint 服务，从而自动的将 metrics 、 events 和 asynchronous_metrics 三张系统的表的数据发送给 Prometheus。</p>
<h2 id="备份及恢复"><a href="#备份及恢复" class="headerlink" title="备份及恢复"></a>备份及恢复</h2><h3 id="手动实现备份及恢复"><a href="#手动实现备份及恢复" class="headerlink" title="手动实现备份及恢复"></a>手动实现备份及恢复</h3><p>ClickHouse 允许使用 ALTER TABLE … FREEZE PARTITION … 查询以创建表分区的本地副本。 这是利用硬链接(hardlink)到 /var/lib/clickhouse/shadow/ 文件夹中实现的，所以它通常不会 因为旧数据而占用额外的磁盘空间。 创建的文件副本不由 ClickHouse 服务器处理，所以不 需要任何额外的外部系统就有一个简单的备份。防止硬件问题，最好将它们远程复制到另一 个位置，然后删除本地副本。</p>
<h3 id="使用-clickhouse-backup"><a href="#使用-clickhouse-backup" class="headerlink" title="使用 clickhouse-backup"></a>使用 clickhouse-backup</h3><p>也可以使用 Clickhouse 的备份工具 clickhouse-backup 帮我们自动化实现。</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>