<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;sql.DB&lt;/code&gt; 不是一个连接，它是数据库的抽象接口。它可以根据 driver 打开关闭数据库连接，管理连接池。正在使用的连接被标记为繁忙，用完后回到连接池等待下次使用。所以，如果你没有把连接释放回连接池，会导致过多连接使系统资源耗尽。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>database_sql | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-03-30</div></div></div><div class="container post-header"><h1>database_sql</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-DB"><span class="toc-number">2.</span> <span class="toc-text">使用 DB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-driver"><span class="toc-number">2.1.</span> <span class="toc-text">导入 driver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5-DB"><span class="toc-number">2.2.</span> <span class="toc-text">连接 DB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-DB"><span class="toc-number">2.3.</span> <span class="toc-text">读取 DB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C-Query"><span class="toc-number">2.4.</span> <span class="toc-text">单行 Query</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">修改数据，事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prepared-Statements"><span class="toc-number">4.</span> <span class="toc-text">Prepared Statements</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prepared-Statements-and-Connection"><span class="toc-number">4.1.</span> <span class="toc-text">Prepared Statements and Connection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Transaction-%E4%B8%AD%E4%BD%BF%E7%94%A8-PS"><span class="toc-number">4.2.</span> <span class="toc-text">在 Transaction 中使用 PS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86-Error"><span class="toc-number">5.</span> <span class="toc-text">处理 Error</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF-Rows-%E7%9A%84-Error"><span class="toc-number">5.1.</span> <span class="toc-text">循环 Rows 的 Error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD-Resultsets-%E6%97%B6%E7%9A%84-error"><span class="toc-number">5.2.</span> <span class="toc-text">关闭 Resultsets 时的 error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QueryRow-%E7%9A%84-error"><span class="toc-number">5.3.</span> <span class="toc-text">QueryRow () 的 error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%BA%93-Error"><span class="toc-number">5.4.</span> <span class="toc-text">分析数据库 Error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF"><span class="toc-number">5.5.</span> <span class="toc-text">连接错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NULL-%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">NULL 值处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E7%9F%A5-Column"><span class="toc-number">7.</span> <span class="toc-text">未知 Column</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">8.</span> <span class="toc-text">关于连接池</span></a></li></ol></details></div><div class="container post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>sql.DB</code> 不是一个连接，它是数据库的抽象接口。它可以根据 driver 打开关闭数据库连接，管理连接池。正在使用的连接被标记为繁忙，用完后回到连接池等待下次使用。所以，如果你没有把连接释放回连接池，会导致过多连接使系统资源耗尽。</p>
<h2 id="使用-DB"><a href="#使用-DB" class="headerlink" title="使用 DB"></a>使用 DB</h2><h3 id="导入-driver"><a href="#导入-driver" class="headerlink" title="导入 driver"></a>导入 driver</h3><p>这里使用的是 <a target="_blank" rel="noopener" href="https://github.com/go-sql-driver/mysql">MySQL drivers</a></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="literal">_</span> <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="连接-DB"><a href="#连接-DB" class="headerlink" title="连接 DB"></a>连接 DB</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>,<span class="string">&quot;user:password@tcp(127.0.0.1:3306)/hello&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sql.Open</code> 的第一个参数是 driver 名称，第二个参数是 driver 连接数据库的信息，各个 driver 可能不同。DB 不是连接，并且只有当需要使用时才会创建连接，如果想立即验证连接，需要用 <code>Ping()</code> 方法，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = db.Ping()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// do something here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sql.DB 的设计就是用来作为长连接使用的</strong>。不要频繁 Open，Close。</p>
<p>比较好的做法是，为每个不同的 datastore 建一个 DB 对象，保持这些对象 Open。如果需要短连接，那么把 DB 作为参数传入 function，而不要在 function 中 Open, Close。</p>
<h3 id="读取-DB"><a href="#读取-DB" class="headerlink" title="读取 DB"></a>读取 DB</h3><p>如果方法包含 <code>Query</code>，那么这个方法是用于查询并返回 rows 的。其他情况应该用 <code>Exec()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">rows, err := db.Query(<span class="string">&quot;select id, name from users where id = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    err := rows.Scan(&amp;id, &amp;name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(id, name)</span><br><span class="line">&#125;</span><br><span class="line">err = rows.Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的过程为：<code>db.Query()</code> 表示向数据库发送一个 query，<code>defer rows.Close()</code> 非常重要，遍历 rows 使用 <code>rows.Next()</code>， 把遍历到的数据存入变量使用 <code>rows.Scan()</code>, 遍历完成后检查 error。有几点需要注意：</p>
<ol>
<li>检查遍历是否有 error</li>
<li>结果集 (rows) 未关闭前，底层的连接处于繁忙状态。当遍历读到最后一条记录时，会发生一个内部 EOF 错误，自动调用 <code>rows.Close()</code>，但是如果提前退出循环，rows 不会关闭，连接不会回到连接池中，连接也不会关闭。所以手动关闭非常重要。<code>rows.Close()</code> 可以多次调用，是无害操作。</li>
</ol>
<h3 id="单行-Query"><a href="#单行-Query" class="headerlink" title="单行 Query"></a>单行 Query</h3><p>err 在 <code>Scan</code> 后才产生，所以可以如下写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">err = db.QueryRow(<span class="string">&quot;select name from users where id = ?&quot;</span>, <span class="number">1</span>).Scan(&amp;name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(name)</span><br></pre></td></tr></table></figure>



<h2 id="修改数据，事务"><a href="#修改数据，事务" class="headerlink" title="修改数据，事务"></a>修改数据，事务</h2><p>一般用 Prepared Statements 和 <code>Exec()</code> 完成 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(<span class="string">&quot;INSERT INTO users(name) VALUES(?)&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">res, err := stmt.Exec(<span class="string">&quot;Dolly&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">lastId, err := res.LastInsertId()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">rowCnt, err := res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;ID = %d, affected = %d\n&quot;</span>, lastId, rowCnt)</span><br></pre></td></tr></table></figure>

<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><code>db.Begin()</code> 开始事务，<code>Commit()</code> 或 <code>Rollback()</code> 关闭事务。<code>Tx</code> 从连接池中取出一个连接，在关闭之前都是使用这个连接。Tx 不能和 DB 层的 <code>BEGIN</code>, <code>COMMIT</code> 混合使用。</p>
<p>如果你需要通过多条语句修改连接状态，你必须使用 Tx，例如：</p>
<ul>
<li>创建仅对单个连接可见的临时表</li>
<li>设置变量，例如 <code>SET @var := somevalue</code></li>
<li>改变连接选项，例如字符集，超时</li>
</ul>
<h2 id="Prepared-Statements"><a href="#Prepared-Statements" class="headerlink" title="Prepared Statements"></a>Prepared Statements</h2><h3 id="Prepared-Statements-and-Connection"><a href="#Prepared-Statements-and-Connection" class="headerlink" title="Prepared Statements and Connection"></a>Prepared Statements and Connection</h3><p>在数据库层面，Prepared Statements 是和单个数据库连接绑定的。客户端发送一个有占位符的 statement 到服务端，服务器返回一个 statement ID，然后客户端发送 ID 和参数来执行 statement。</p>
<p>在 GO 中，连接不直接暴露，你不能为连接绑定 statement，而是只能为 DB 或 Tx 绑定。<code>database/sql</code> 包有自动重试等功能。当你生成一个 Prepared Statement</p>
<ol>
<li>自动在连接池中绑定到一个空闲连接</li>
<li><code>Stmt</code> 对象记住绑定了哪个连接</li>
<li>执行 <code>Stmt</code> 时，尝试使用该连接。如果不可用，例如连接被关闭或繁忙中，会自动 re-prepare，绑定到另一个连接。</li>
</ol>
<p>这就导致在高并发的场景，过度使用 statement 可能导致 statement 泄漏，statement 持续重复 prepare 和 re-prepare 的过程，甚至会达到服务器端 statement 数量上限。</p>
<p>某些操作使用了 PS，例如 <code>db.Query(sql, param1, param2)</code>, 并在最后自动关闭 statement。</p>
<p>有些场景不适合用 statement：</p>
<ol>
<li>数据库不支持。例如 Sphinx，MemSQL。他们支持 MySQL wire protocol, 但不支持 “binary” protocol。</li>
<li>statement 不需要重用很多次，并且有其他方法保证安全。<a target="_blank" rel="noopener" href="https://vividcortex.com/blog/2014/11/19/analyzing-prepared-statement-performance-with-vividcortex/">例子</a></li>
</ol>
<h3 id="在-Transaction-中使用-PS"><a href="#在-Transaction-中使用-PS" class="headerlink" title="在 Transaction 中使用 PS"></a>在 Transaction 中使用 PS</h3><p>PS 在 Tx 中唯一绑定一个连接，不会 re-prepare。</p>
<p>Tx 和 statement 不能分离，在 DB 中创建的 statement 也不能在 Tx 中使用，因为他们必定不是使用同一个连接使用 Tx 必须十分小心，例如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tx, err := db.Begin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> tx.Rollback()</span><br><span class="line">stmt, err := tx.Prepare(<span class="string">&quot;INSERT INTO foo VALUES (?)&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close() <span class="comment">// danger!</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    _, err = stmt.Exec(i)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">err = tx.Commit()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// stmt.Close() runs here!</span></span><br></pre></td></tr></table></figure>

<p><code>*sql.Tx</code> 一旦释放，连接就回到连接池中，这里 stmt 在关闭时就无法找到连接。所以必须在 Tx commit 或 rollback 之前关闭 statement。</p>
<h2 id="处理-Error"><a href="#处理-Error" class="headerlink" title="处理 Error"></a>处理 Error</h2><h3 id="循环-Rows-的-Error"><a href="#循环-Rows-的-Error" class="headerlink" title="循环 Rows 的 Error"></a>循环 Rows 的 Error</h3><p>如果循环中发生错误会自动运行 <code>rows.Close()</code>，用 <code>rows.Err()</code> 接收这个错误，Close 方法可以多次调用。循环之后判断 error 是非常必要的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle the error here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭-Resultsets-时的-error"><a href="#关闭-Resultsets-时的-error" class="headerlink" title="关闭 Resultsets 时的 error"></a>关闭 Resultsets 时的 error</h3><p>如果你在 rows 遍历结束之前退出循环，必须手动关闭 Resultset，并且接收 error。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// whoops, rows is not closed! memory leak...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do the usual &quot;if err = rows.Err()&quot; [omitted here]...</span></span><br><span class="line"><span class="comment">// it&#x27;s always safe to [re?]close here:</span></span><br><span class="line"><span class="keyword">if</span> err = rows.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// but what should we do if there&#x27;s an error?</span></span><br><span class="line">    log.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QueryRow-的-error"><a href="#QueryRow-的-error" class="headerlink" title="QueryRow () 的 error"></a>QueryRow () 的 error</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">err = db.QueryRow(<span class="string">&quot;select name from users where id = ?&quot;</span>, <span class="number">1</span>).Scan(&amp;name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(name)</span><br></pre></td></tr></table></figure>

<p>如果 id 为 1 的不存在，err 为 sql.ErrNoRows，一般应用中不存在的情况都需要单独处理。此外，Query 返回的错误都会延迟到 Scan 被调用，所以应该写成如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">err = db.QueryRow(<span class="string">&quot;select name from users where id = ?&quot;</span>, <span class="number">1</span>).Scan(&amp;name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">        <span class="comment">// there were no rows, but otherwise no error occurred</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(name)</span><br></pre></td></tr></table></figure>

<p>把空结果当做 Error 处理是为了强行让程序员处理结果为空的情况</p>
<h3 id="分析数据库-Error"><a href="#分析数据库-Error" class="headerlink" title="分析数据库 Error"></a>分析数据库 Error</h3><p>各个数据库处理方式不太一样，mysql 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> driverErr, ok := err.(*mysql.MySQLError); ok &#123; </span><br><span class="line">    <span class="comment">// Now the error number is accessible directly</span></span><br><span class="line">    <span class="keyword">if</span> driverErr.Number == <span class="number">1045</span> &#123;</span><br><span class="line">        <span class="comment">// Handle the permission-denied error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MySQLError</code>, <code>Number</code> 都是 DB 特异的，别的数据库可能是别的类型或字段。这里的数字可以替换为常量，例如这个包 <a target="_blank" rel="noopener" href="https://github.com/VividCortex/mysqlerr">MySQL error numbers maintained by VividCortex</a></p>
<h3 id="连接错误"><a href="#连接错误" class="headerlink" title="连接错误"></a>连接错误</h3><h2 id="NULL-值处理"><a href="#NULL-值处理" class="headerlink" title="NULL 值处理"></a>NULL 值处理</h2><p>简单说就是设计数据库的时候不要出现 null，处理起来非常费力。Null 的 type 很有限，例如没有 <code>sql.NullUint64</code>; null 值没有默认零值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    <span class="keyword">var</span> s sql.NullString</span><br><span class="line">    err := rows.Scan(&amp;s)</span><br><span class="line">    <span class="comment">// check err</span></span><br><span class="line">    <span class="keyword">if</span> s.Valid &#123;</span><br><span class="line">       <span class="comment">// use s.String</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// NULL value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="未知-Column"><a href="#未知-Column" class="headerlink" title="未知 Column"></a>未知 Column</h2><p><code>rows.Columns()</code> 的使用，用于处理不能得知结果字段个数或类型的情况，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cols, err := rows.Columns()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dest := []<span class="keyword">interface</span>&#123;&#125;&#123; <span class="comment">// Standard MySQL columns</span></span><br><span class="line">        <span class="built_in">new</span>(<span class="keyword">uint64</span>), <span class="comment">// id</span></span><br><span class="line">        <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="comment">// host</span></span><br><span class="line">        <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="comment">// user</span></span><br><span class="line">        <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="comment">// db</span></span><br><span class="line">        <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="comment">// command</span></span><br><span class="line">        <span class="built_in">new</span>(<span class="keyword">uint32</span>), <span class="comment">// time</span></span><br><span class="line">        <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="comment">// state</span></span><br><span class="line">        <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="comment">// info</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cols) == <span class="number">11</span> &#123;</span><br><span class="line">        <span class="comment">// Percona Server</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(cols) &gt; <span class="number">8</span> &#123;</span><br><span class="line">        <span class="comment">// Handle this case</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = rows.Scan(dest...)</span><br><span class="line">    <span class="comment">// Work with the values in dest</span></span><br><span class="line">&#125;</span><br><span class="line">cols, err := rows.Columns() <span class="comment">// Remember to check err afterwards</span></span><br><span class="line">vals := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(cols))</span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> cols &#123;</span><br><span class="line">    vals[i] = <span class="built_in">new</span>(sql.RawBytes)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    err = rows.Scan(vals...)</span><br><span class="line">    <span class="comment">// Now you can check each element of vals for nil-ness,</span></span><br><span class="line">    <span class="comment">// and you can use type introspection and type assertions</span></span><br><span class="line">    <span class="comment">// to fetch the column into a typed variable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于连接池"><a href="#关于连接池" class="headerlink" title="关于连接池"></a>关于连接池</h2><ol>
<li>避免错误操作，例如 LOCK TABLE 后用 INSERT 会死锁，因为两个操作不是同一个连接，insert 的连接没有 table lock。</li>
<li>当需要连接，且连接池中没有可用连接时，新的连接就会被创建。</li>
<li>默认没有连接上限，你可以设置一个，但这可能会导致数据库产生错误 “too many connections”</li>
<li><code>db.SetMaxIdleConns(N)</code> 设置最大空闲连接数</li>
<li><code>db.SetMaxOpenConns(N)</code> 设置最大打开连接数</li>
<li>长时间保持空闲连接可能会导致 db timeout</li>
</ol>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>