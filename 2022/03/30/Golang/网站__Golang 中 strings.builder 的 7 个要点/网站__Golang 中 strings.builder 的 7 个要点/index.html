<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;类写入（write）方法&quot;&gt;&lt;a href=&quot;#类写入（write）方法&quot; class=&quot;headerlink&quot; title=&quot;类写入（write）方法&quot;&gt;&lt;/a&gt;类写入（write）方法&lt;/h2&gt;&lt;p&gt;与 &lt;code&gt;bytes.Buffer&lt;/code&gt; 类似，&lt;code&gt;strings.Builder&lt;/code&gt; 也支持 4 类方法将数据写入 builder 中。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Golang 中 strings.builder 的 7 个要点 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-03-30</div></div></div><div class="container post-header"><h1>Golang 中 strings.builder 的 7 个要点</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%86%99%E5%85%A5%EF%BC%88write%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">类写入（write）方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">字符串的存储原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%95%88%E5%9C%B0%E4%BD%BF%E7%94%A8-strings-Builder"><span class="toc-number">3.</span> <span class="toc-text">高效地使用 strings.Builder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">4.</span> <span class="toc-text">String()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.</span> <span class="toc-text">不要拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%94%AF%E6%8C%81"><span class="toc-number">6.</span> <span class="toc-text">并行支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io-Writer-%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.</span> <span class="toc-text">io.Writer 接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="类写入（write）方法"><a href="#类写入（write）方法" class="headerlink" title="类写入（write）方法"></a>类写入（write）方法</h2><p>与 <code>bytes.Buffer</code> 类似，<code>strings.Builder</code> 也支持 4 类方法将数据写入 builder 中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>有了它们，用户可以根据输入数据的不同类型（byte 数组，byte， rune 或者 string），选择对应的写入方法。</p>
<h2 id="字符串的存储原理"><a href="#字符串的存储原理" class="headerlink" title="字符串的存储原理"></a>字符串的存储原理</h2><p>根据用法说明，我们通过调用 <code>string.Builder</code> 的写入方法来写入内容，然后通过调用 <code>String()</code> 方法来获取拼接的字符串。那么 <code>string.Builder</code> 是如何组织这些内容的呢？答：通过 slice</p>
<p><code>string.Builder</code> 通过使用一个内部的 slice 来存储数据片段。当开发者调用写入方法的时候，数据实际上是被追加（append）到了其内部的 slice 上。</p>
<p><img src="/images/1_luRaetJ4m36JH43xh0rHcA.png" alt="slice-store-data"></p>
<h2 id="高效地使用-strings-Builder"><a href="#高效地使用-strings-Builder" class="headerlink" title="高效地使用 strings.Builder"></a>高效地使用 strings.Builder</h2><p>strings.Builder 是通过其内部的 slice 来储存内容的，当你调用写入方法的时候，新的字节数据就被追加到 slice 上。如果达到了 slice 的容量（capacity）限制，一个新的 slice 就会被分配，然后老的 slice 上的内容会被拷贝到新的 slice 上。当 slice 长度很大时，这个操作就会很消耗资源甚至引起 <a target="_blank" rel="noopener" href="https://blog.siliconstraits.com/out-of-memory-with-append-in-golang-956e7eb2c70e">内存问题</a>。我们需要避免这一情况。</p>
<p>关于 slice，Go 语言提供了 <code>make([]TypeOfSlice, length, capacity)</code> 方法在初始化的时候预定义它的容量。这就避免了因达到最大容量而引起扩容。</p>
<p><code>strings.Builder</code> 同样也提供了 <code>Grow()</code> 来支持预定义容量。当我们可以预定义我们需要使用的容量时，<code>strings.Builder</code> 就能避免扩容而创建新的 slice 了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Grow</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>当调用 <code>Grow()</code> 时，我们必须定义要扩容的字节数（<code>n</code>）。 <code>Grow()</code> 方法保证了其内部的 slice 一定能够写入 <code>n</code> 个字节。只有当 slice 空余空间不足以写入 <code>n</code> 个字节时，扩容才有可能发生。举个例子：</p>
<ul>
<li>builder 内部 slice 容量为 10，长度为 5。</li>
<li>当我们调用 <code>Grow(3)</code> =&gt; 扩容操作并不会发生。因为当前的空余空间为 5，足以提供 3 个字节的写入。</li>
<li>当我们调用 <code>Grow(7)</code> =&gt; 扩容操作发生。因为当前的空余空间为 5，已不足以提供 7 个字节的写入。</li>
</ul>
<p>关于上面的情形，如果这时我们调用 <code>Grow(7)</code>，则扩容之后的实际容量是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17 还是 12?</span><br></pre></td></tr></table></figure>

<p>实际上，是 <code>27</code>。<code>strings.Builder</code> 的 <code>Grow()</code> 方法是通过 <code>current_capacity * 2 + n</code> （<code>n</code> 就是你想要扩充的容量）的方式来对内部的 slice 进行扩容的。所以说最后的容量是 <code>10*2+7</code> = <code>27</code>。</p>
<p>当你预定义 <code>strings.Builder</code> 容量的时候还要注意一点。调用 <code>WriteRune()</code> 和 <code>WriteString()</code> 时，<code>rune</code> 和 <code>string</code> 的字符可能不止 1 个字节。因为，你懂的，<a target="_blank" rel="noopener" href="https://golang.org/pkg/unicode/utf8/#pkg-constants">UTF-8</a> 的原因。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h2><p>和 <code>bytes.Buffer</code> 一样，<code>strings.Builder</code> 也支持使用 <code>String()</code> 来获取最终的字符串结果。为了节省内存分配，它通过使用指针技术将内部的 buffer bytes 转换为字符串。所以 <code>String()</code> 方法在转换的时候节省了时间和空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;bytes))</span><br></pre></td></tr></table></figure>



<h2 id="不要拷贝"><a href="#不要拷贝" class="headerlink" title="不要拷贝"></a>不要拷贝</h2><p><code>strings.Builder</code> 不推荐被拷贝。当你试图拷贝 <code>strings.Builder</code> 并写入的时候，你的程序就会崩溃。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 strings.Builder</span><br><span class="line">b1.WriteString(<span class="string">&quot;ABC&quot;</span>)</span><br><span class="line">b2 := b1</span><br><span class="line">b2.WriteString(<span class="string">&quot;DEF&quot;</span>) </span><br><span class="line"><span class="comment">// illegal use of non-zero Builder copied by value</span></span><br></pre></td></tr></table></figure>

<p>你已经知道，<code>strings.Builder</code> 内部通过 slice 来保存和管理内容。slice 内部则是通过一个指针指向实际保存内容的数组。</p>
<p><img src="/images/1_KD02pGfasisf8I_BWE_JKQ.png" alt="slice-internally"></p>
<p>当我们拷贝了 builder 以后，同样也拷贝了其 slice 的指针。但是它仍然指向同一个旧的数组。当你对源 builder 或者拷贝后的 builder 写入的时候，问题就产生了。另一个 builder 指向的数组内容也被改变了。这就是为什么 <code>strings.Builder</code> 不允许拷贝的原因。</p>
<p><img src="/images/1_Ppak_h63S_TvYzJa2sFCpA.png" alt="copy-and-write"></p>
<p>对于一个未写入任何东西的空内容 builder 则是个例外。我们可以拷贝空内容的 builder 而不报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 strings.Builder</span><br><span class="line">b2 := b1</span><br><span class="line">b2.WriteString(<span class="string">&quot;DEF&quot;</span>)</span><br><span class="line">b1.WriteString(<span class="string">&quot;ABC&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// b1 = ABC, b2 = DEF</span></span><br></pre></td></tr></table></figure>

<p><code>strings.Builder</code> 会在以下方法中检测拷贝操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Grow(n <span class="keyword">int</span>)</span><br><span class="line">Write(p []<span class="keyword">byte</span>)</span><br><span class="line">WriteRune(r <span class="keyword">rune</span>)</span><br><span class="line">WriteString(s <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>

<p>所以，拷贝并使用下列这些方法是允许的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset()</span></span><br><span class="line"><span class="comment">// Len()</span></span><br><span class="line"><span class="comment">// String()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 strings.Builder</span><br><span class="line">b1.WriteString(<span class="string">&quot;ABC&quot;</span>)</span><br><span class="line">b2 := b1</span><br><span class="line">fmt.Println(b2.Len())    <span class="comment">// 3</span></span><br><span class="line">fmt.Println(b2.String()) <span class="comment">// ABC</span></span><br><span class="line">b2.Reset()</span><br><span class="line">b2.WriteString(<span class="string">&quot;DEF&quot;</span>)</span><br><span class="line">fmt.Println(b2.String()) <span class="comment">// DEF</span></span><br></pre></td></tr></table></figure>



<h2 id="并行支持"><a href="#并行支持" class="headerlink" title="并行支持"></a>并行支持</h2><p>和 <code>bytes.Buffer</code> 一样，<code>strings.Builder</code> 也不支持并行的读或者写。所以我们们要稍加注意。</p>
<p>可以试一下，通过同时给 <code>strings.Builder</code> 添加 <code>1000</code> 个字符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b strings.Builder</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> n &lt; <span class="number">1000</span> &#123;</span><br><span class="line">        wait.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            b.WriteString(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">            n++</span><br><span class="line">            wait.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wait.Wait()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(b.String()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过运行，你会得到不同长度的结果。但它们都不到 <code>1000</code>。</p>
<h2 id="io-Writer-接口"><a href="#io-Writer-接口" class="headerlink" title="io.Writer 接口"></a>io.Writer 接口</h2><p><code>strings.Builder</code> 通过 <code>Write(p []byte) (n int, err error)</code> 方法实现了 <code>io.Writer</code> 接口。所以，我们多了很多使用它的情形：</p>
<ul>
<li><code>io.Copy(dst Writer, src Reader) (written int64, err error)</code></li>
<li><code>bufio.NewWriter(w io.Writer) *Writer</code></li>
<li><code>fmt.Fprint(w io.Writer, a …interface&#123;&#125;) (n int, err error)</code></li>
<li><code>func (r *http.Request) Write(w io.Writer) error</code></li>
<li>其他使用 io.Writer 的库</li>
</ul>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://studygolang.com/articles/12796">Golang 中 strings.builder 的 7 个要点</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>