<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;常用路径&quot;&gt;&lt;a href=&quot;#常用路径&quot; class=&quot;headerlink&quot; title=&quot;常用路径&quot;&gt;&lt;/a&gt;常用路径&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;路径&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;/var/lib/mysql&lt;/td&gt;
&lt;td&gt;mysql数据库文件的存放路径&lt;/td&gt;
&lt;td&gt;/var/lib/mysql/atguigu.cloud.pid&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/usr/share/mysql&lt;/td&gt;
&lt;td&gt;配置文件目录&lt;/td&gt;
&lt;td&gt;mysql.server命令及配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/usr/bin&lt;/td&gt;
&lt;td&gt;相关命令目录&lt;/td&gt;
&lt;td&gt;mysqladmin mysqldump等命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/etc/init.d/mysql&lt;/td&gt;
&lt;td&gt;启停相关脚本&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;数据文件&quot;&gt;&lt;a href=&quot;#数据文件&quot; class=&quot;headerlink&quot; title=&quot;数据文件&quot;&gt;&lt;/a&gt;数据文件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;frm&lt;/code&gt; 文件：存放表结构。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;myd&lt;/code&gt; 文件：存放表数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;myi&lt;/code&gt; 文件：存放表索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root@d12f15d0b339:/var/lib/mysql/mysql&lt;span class=&quot;comment&quot;&gt;# ll&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# mysql5.7 使用.frm文件来存储表结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 使用 .ibd文件来存储表索引和表数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw-r----- 1 mysql mysql      512 Apr 18  2021 user.MYD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw-r----- 1 mysql mysql     4096 Apr 18  2021 user.MYI&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw-r----- 1 mysql mysql    10816 Apr 18  2021 user.frm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;MySQL5.7&lt;/code&gt; 的 &lt;code&gt;Innodb&lt;/code&gt; 存储引擎可将所有数据存放于 &lt;code&gt;ibdata*&lt;/code&gt; 的共享表空间，也可将每张表存放于独立的&lt;code&gt;.ibd&lt;/code&gt; 文件的独立表空间。 共享表空间以及独立表空间都是针对数据的存储方式而言的。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>MySQL优化 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/MySQL/" rel="tag">MySQL</a></div><div class="post-time">2022-03-05</div></div></div><div class="container post-header"><h1>MySQL优化</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%B7%AF%E5%BE%84"><span class="toc-number">1.</span> <span class="toc-text">常用路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">数据文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">MySQL 逻辑架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">逻辑架构分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E5%92%8C-MyISAM-%E5%AF%B9%E6%AF%94"><span class="toc-number">5.</span> <span class="toc-text">InnoDB 和 MyISAM 对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.</span> <span class="toc-text">SQL 性能下降的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">SQL 执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E7%A7%8D-JOIN-%E7%90%86%E8%AE%BA"><span class="toc-number">8.</span> <span class="toc-text">七种 JOIN 理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">9.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF"><span class="toc-number">9.1.</span> <span class="toc-text">索引的优势和劣势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">9.3.</span> <span class="toc-text">索引结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTree-%E7%B4%A2%E5%BC%95%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86"><span class="toc-number">9.4.</span> <span class="toc-text">BTree 索引检索原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">9.5.</span> <span class="toc-text">哪些情况需要建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E8%A6%81%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">9.6.</span> <span class="toc-text">那些情况不要建索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">10.</span> <span class="toc-text">性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E7%9A%84%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88"><span class="toc-number">10.1.</span> <span class="toc-text">MySQL 的常见瓶颈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPLAIN-%E8%83%BD%E6%9F%A5%E7%9C%8B%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF"><span class="toc-number">10.2.</span> <span class="toc-text">EXPLAIN 能查看哪些信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id%EF%BC%9A%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">10.3.</span> <span class="toc-text">id：表的读取顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-type%EF%BC%9A%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.4.</span> <span class="toc-text">select_type：查询类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%98%AF%E5%85%B3%E4%BA%8E%E5%93%AA%E5%BC%A0%E8%A1%A8%E7%9A%84"><span class="toc-number">10.5.</span> <span class="toc-text">table：数据是关于哪张表的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type%EF%BC%9A%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E4%BA%86%E4%BD%95%E7%A7%8D%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.6.</span> <span class="toc-text">type：查询使用了何种访问类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E4%B8%8E-eq-ref-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.6.1.</span> <span class="toc-text">const 与 eq_ref 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#possible-keys-%E5%92%8C-key"><span class="toc-number">10.7.</span> <span class="toc-text">possible_keys 和 key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-len%EF%BC%9A%E7%B4%A2%E5%BC%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-number">10.8.</span> <span class="toc-text">key_len：索引中使用的字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref%EF%BC%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%93%AA%E4%B8%80%E5%88%97%E8%A2%AB%E4%BD%BF%E7%94%A8"><span class="toc-number">10.9.</span> <span class="toc-text">ref：索引的哪一列被使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rows%EF%BC%9A%E9%9C%80%E8%A6%81%E8%AF%BB%E5%8F%96%E7%9A%84%E8%A1%8C%E6%95%B0"><span class="toc-number">10.10.</span> <span class="toc-text">rows：需要读取的行数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extra%EF%BC%9A%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF"><span class="toc-number">10.11.</span> <span class="toc-text">Extra：额外信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.12.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90"><span class="toc-number">11.</span> <span class="toc-text">索引分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%A8%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90"><span class="toc-number">11.1.</span> <span class="toc-text">单表索引分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%A1%A8%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90"><span class="toc-number">11.2.</span> <span class="toc-text">两表索引分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%BC%A0%E8%A1%A8%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90"><span class="toc-number">11.3.</span> <span class="toc-text">三张表索引分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">11.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">12.</span> <span class="toc-text">避免索引失效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">12.1.</span> <span class="toc-text">最佳左前缀法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E4%B8%8D%E8%AE%A1%E7%AE%97"><span class="toc-number">12.2.</span> <span class="toc-text">索引列上不计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%90%8E%E5%85%A8%E5%A4%B1%E6%95%88"><span class="toc-number">12.3.</span> <span class="toc-text">范围之后全失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">12.4.</span> <span class="toc-text">尽量用覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-is-null-%E6%9C%89%E6%97%B6%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">12.5.</span> <span class="toc-text">!&#x3D; 和 is null 有时会失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#like-%E7%99%BE%E5%88%86%E5%8A%A0%E5%8F%B3%E8%BE%B9"><span class="toc-number">12.6.</span> <span class="toc-text">like 百分加右边</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%A6%81%E5%8A%A0%E5%8D%95%E5%BC%95%E5%8F%B7"><span class="toc-number">12.7.</span> <span class="toc-text">字符要加单引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">12.8.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">12.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%85%A2-SQL-%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">13.</span> <span class="toc-text">分析慢 SQL 的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">14.</span> <span class="toc-text">查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%A4%A7%E8%A1%A8"><span class="toc-number">14.1.</span> <span class="toc-text">小表驱动大表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ORDER-BY-%E4%BC%98%E5%8C%96"><span class="toc-number">14.2.</span> <span class="toc-text">ORDER BY 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GORUP-BY-%E4%BC%98%E5%8C%96"><span class="toc-number">14.3.</span> <span class="toc-text">GORUP BY 优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">15.</span> <span class="toc-text">慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">15.2.</span> <span class="toc-text">日志分析工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC"><span class="toc-number">16.</span> <span class="toc-text">批量插入数据脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">16.1.</span> <span class="toc-text">创建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">16.2.</span> <span class="toc-text">创建存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">16.3.</span> <span class="toc-text">调用存储过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Show-Profile"><span class="toc-number">17.</span> <span class="toc-text">Show Profile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%94%81-%E5%81%8F%E8%AF%BB"><span class="toc-number">18.</span> <span class="toc-text">表锁(偏读)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%A1%A8%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">18.1.</span> <span class="toc-text">锁表的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E9%94%81%E6%A1%88%E4%BE%8B"><span class="toc-number">18.2.</span> <span class="toc-text">读锁案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E9%94%81%E6%A1%88%E4%BE%8B"><span class="toc-number">18.3.</span> <span class="toc-text">写锁案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%BB%93%E8%AE%BA"><span class="toc-number">18.4.</span> <span class="toc-text">案例结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-number">18.5.</span> <span class="toc-text">表锁分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E9%94%81-%E5%81%8F%E5%86%99"><span class="toc-number">19.</span> <span class="toc-text">行锁 (偏写)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E6%A1%88%E4%BE%8B"><span class="toc-number">19.1.</span> <span class="toc-text">行锁案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%AF%BC%E8%87%B4%E8%A1%8C%E9%94%81%E5%8F%98%E8%A1%A8%E9%94%81"><span class="toc-number">19.2.</span> <span class="toc-text">索引失效导致行锁变表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">19.3.</span> <span class="toc-text">间隙锁的危害</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%BB%93%E8%AE%BA-1"><span class="toc-number">19.4.</span> <span class="toc-text">案例结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-number">19.5.</span> <span class="toc-text">行锁分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#refenence"><span class="toc-number"></span> <span class="toc-text">refenence</span></a></details></div><div class="container post-content"><h2 id="常用路径"><a href="#常用路径" class="headerlink" title="常用路径"></a>常用路径</h2><table>
<thead>
<tr>
<th>路径</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>/var/lib/mysql</td>
<td>mysql数据库文件的存放路径</td>
<td>/var/lib/mysql/atguigu.cloud.pid</td>
</tr>
<tr>
<td>/usr/share/mysql</td>
<td>配置文件目录</td>
<td>mysql.server命令及配置文件</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>相关命令目录</td>
<td>mysqladmin mysqldump等命令</td>
</tr>
<tr>
<td>/etc/init.d/mysql</td>
<td>启停相关脚本</td>
<td></td>
</tr>
</tbody></table>
<h2 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h2><ul>
<li><code>frm</code> 文件：存放表结构。</li>
<li><code>myd</code> 文件：存放表数据。</li>
<li><code>myi</code> 文件：存放表索引。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@d12f15d0b339:/var/lib/mysql/mysql<span class="comment"># ll</span></span><br><span class="line"><span class="comment"># mysql5.7 使用.frm文件来存储表结构</span></span><br><span class="line"><span class="comment"># 使用 .ibd文件来存储表索引和表数据</span></span><br><span class="line">-rw-r----- 1 mysql mysql      512 Apr 18  2021 user.MYD</span><br><span class="line">-rw-r----- 1 mysql mysql     4096 Apr 18  2021 user.MYI</span><br><span class="line">-rw-r----- 1 mysql mysql    10816 Apr 18  2021 user.frm</span><br></pre></td></tr></table></figure>

<p><code>MySQL5.7</code> 的 <code>Innodb</code> 存储引擎可将所有数据存放于 <code>ibdata*</code> 的共享表空间，也可将每张表存放于独立的<code>.ibd</code> 文件的独立表空间。 共享表空间以及独立表空间都是针对数据的存储方式而言的。</p>
<ul>
<li>共享表空间：某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 <code>data</code> 目录下。 默认的文件名为<code>:ibdata1</code> 初始化为 <code>10M</code>。</li>
<li>独立表空间：每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个<code>.frm</code> 表描述文件，还有一个<code>.ibd</code> 文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。在配置文件 <code>my.cnf</code> 中设置： <code>innodb_file_per_table</code>。</li>
</ul>
<h2 id="MySQL-逻辑架构"><a href="#MySQL-逻辑架构" class="headerlink" title="MySQL 逻辑架构"></a>MySQL 逻辑架构</h2><p><img src="/images/42.jfif" alt="MySQL逻辑架构"></p>
<ul>
<li><p><code>Connectors</code>：指的是不同语言中与 SQL 的交互。</p>
</li>
<li><p><code>Connection Pool</code>：管理缓冲用户连接，线程处理等需要缓存的需求。<strong>MySQL 数据库的连接层。</strong></p>
</li>
<li><p><code>Management Serveices &amp; Utilities</code>：系统管理和控制工具。备份、安全、复制、集群等。</p>
</li>
<li><p><code>SQL Interface</code>：接受用户的 SQL 命令，并且返回用户需要查询的结果。</p>
</li>
<li><p><code>Parser</code>：SQL 语句解析器。</p>
</li>
<li><p><code>Optimizer</code>：查询优化器，SQL 语句在查询之前会使用查询优化器对查询进行优化。<strong>就是优化客户端请求 query</strong>，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果。</p>
<blockquote>
<p>eg： <code>select uid,name from user where gender = 1;</code> 这个 <code>select </code> 查询先根据 <code>where </code>语句进行选取，而不是先将表全部查询出来以后再进行 <code>gender</code> 过滤；然后根据 <code>uid</code> 和 <code>name</code> 进行属性投影，而不是将属性全部取出以后再进行过滤。最后将这两个查询条件联接起来生成最终查询结果。</p>
</blockquote>
</li>
<li><p><code>Caches &amp; Buffers</code>：查询缓存。</p>
</li>
<li><p><code>Pluggable Storage Engines</code>：存储引擎接口。<strong>MySQL 区别于其他数据库的最重要的特点就是其插件式的表存储引擎 (注意：存储引擎是基于表的，而不是数据库)。</strong></p>
<blockquote>
<p>MySQL 与其他 SQL 与众不同，主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需求选择合适的存储引擎。</p>
</blockquote>
</li>
<li><p><code>File System</code>：数据落地到磁盘上，就是文件的存储。</p>
</li>
</ul>
<h2 id="逻辑架构分层"><a href="#逻辑架构分层" class="headerlink" title="逻辑架构分层"></a>逻辑架构分层</h2><p><img src="/images/6D.png" alt="MySQL逻辑架构"></p>
<ul>
<li>连接层：最上层是一些客户端和连接服务，包含本地 sock 通信和大多数基于客户端 / 服务端工具实现的类似于 <code>tcp/ip</code> 的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于 <code>SSL</code> 的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li>服务层：MySQL 的核心服务功能层，该层是 MySQL 的核心，包括查询缓存，解析器，解析树，预处理器，查询优化器。主要进行查询解析、分析、查询缓存、内置函数、存储过程、触发器、视图等，select 操作会先检查是否命中查询缓存，命中则直接返回缓存数据，否则解析查询并创建对应的解析树。</li>
<li>引擎层：存储引擎层，存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</li>
<li>存储层：数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</li>
</ul>
<h2 id="InnoDB-和-MyISAM-对比"><a href="#InnoDB-和-MyISAM-对比" class="headerlink" title="InnoDB 和 MyISAM 对比"></a>InnoDB 和 MyISAM 对比</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整张表，<strong>不适合高并发操作</strong></td>
<td>行锁，操作时只锁某一行，不对其他行有影响，<strong>适合高并发操作</strong></td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，対内存要求较高，而且内存大小対性能有决定性影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<h2 id="SQL-性能下降的原因"><a href="#SQL-性能下降的原因" class="headerlink" title="SQL 性能下降的原因"></a>SQL 性能下降的原因</h2><ul>
<li>查询语句写的差。</li>
<li>索引失效：索引建了，但是没有用上。</li>
<li>关联 查询太多 <code>join</code>（设计缺陷或者不得已的需求）。</li>
<li>服务器调优以及各个参数的设置（缓冲、线程数等）。</li>
</ul>
<h2 id="SQL-执行顺序"><a href="#SQL-执行顺序" class="headerlink" title="SQL 执行顺序"></a>SQL 执行顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select              # 5</span><br><span class="line">	... </span><br><span class="line">from                # 1</span><br><span class="line">	... </span><br><span class="line">where               # 2</span><br><span class="line">	.... </span><br><span class="line">group by            # 3</span><br><span class="line">	... </span><br><span class="line">having              # 4</span><br><span class="line">	... </span><br><span class="line">order by            # 6</span><br><span class="line">	... </span><br><span class="line">limit               # 7</span><br><span class="line">	[offset]</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220303120436589.png" alt="image-20220303120436589"></p>
<h2 id="七种-JOIN-理论"><a href="#七种-JOIN-理论" class="headerlink" title="七种 JOIN 理论"></a>七种 JOIN 理论</h2><p><img src="/images/a6.jfif" alt="image-20220303120436589"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* 1 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line">/* 2 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line">/* 3 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line">/* 4 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;</span><br><span class="line"></span><br><span class="line">/* 5 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;</span><br><span class="line"></span><br><span class="line">/* 6 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key;</span><br><span class="line">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 1+2 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key;</span><br><span class="line"></span><br><span class="line">/* 7 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL OR B.Key IS NULL;</span><br><span class="line">/* MySQL不支持FULL OUTER JOIN这种语法 可以改成 4+5 */</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key = B.Key WHERE B.Key IS NULL;</span><br><span class="line">UNION</span><br><span class="line">SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key = B.Key WHERE A.Key IS NULL;</span><br></pre></td></tr></table></figure>



<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>除了数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</p>
<blockquote>
<p>索引的本质：<strong>索引是排好序的快速查找数据结构。</strong></p>
</blockquote>
<p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。</p>
<p>为了加快 Col2 的查找，可以维护一个右边所示的二又查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p>
<p><img src="/images/image-20220303144532464.png" alt="image-20220303144532464"></p>
<h3 id="索引的优势和劣势"><a href="#索引的优势和劣势" class="headerlink" title="索引的优势和劣势"></a>索引的优势和劣势</h3><p>优势：</p>
<ul>
<li>查找：类似大学图书馆的书目索引，提高数据检索的效率，降低数据库的 IO 成本。</li>
<li>排序：通过索引対数据进行排序，降低数据排序的成本，降低了 CPU 的消耗。</li>
</ul>
<p>劣势：</p>
<ul>
<li>实际上<strong>索引也是一张表</strong>，<strong>该表保存了主键与索引字段，并指向实体表的记录</strong>，所以索引列也是要占用空间的。</li>
<li>虽然索引大大提高了查询速度，但是同时会降低表的更新速度，例如对表频繁的进行 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code>。因为更新表的时候，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li>
</ul>
<blockquote>
<p>一张表建的索引最好不要超过 5 个！</p>
</blockquote>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul>
<li>单值索引：一个索引只包含单个列，一个表可以有多个单列索引。</li>
<li>唯一索引：索引列的值必须唯一，但是允许空值。</li>
<li>复合索引：一个索引包含多个字段。</li>
</ul>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><ul>
<li>B-Tree</li>
<li>Hash</li>
<li>full-text</li>
<li>R-Tree</li>
</ul>
<h3 id="BTree-索引检索原理"><a href="#BTree-索引检索原理" class="headerlink" title="BTree 索引检索原理"></a>BTree 索引检索原理</h3><p><img src="/images/7d.png" alt="image-20220303144532464"></p>
<p>真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。<br>非叶子节点只不存储真实的数据，只存储指引搜素方向的数据项，如17、35并不真实存在于数据表中。</p>
<h3 id="哪些情况需要建索引"><a href="#哪些情况需要建索引" class="headerlink" title="哪些情况需要建索引"></a>哪些情况需要建索引</h3><ul>
<li>主键自动建立主键索引（唯一 + 非空）。</li>
<li>频繁作为查询条件的字段应该创建索引。</li>
<li>查询中与其他表关联的字段，外键关系建立索引。</li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。</li>
<li>查询中统计或者分组字段（group by 也和索引有关）。</li>
</ul>
<h3 id="那些情况不要建索引"><a href="#那些情况不要建索引" class="headerlink" title="那些情况不要建索引"></a>那些情况不要建索引</h3><ul>
<li><p>记录太少的表。</p>
</li>
<li><p>经常增删改的表。</p>
</li>
<li><p>频繁更新的字段不适合创建索引。</p>
</li>
<li><p>Where 条件里用不到的字段不创建索引。</p>
</li>
<li><p>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。</p>
<blockquote>
<p>注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。假如一个表有 10 万行记录，有一个字段 A 只有 true 和 false 两种值，并且每个值的分布概率大约为 50%，那么对 A 字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有 2000 条记录，表索引列有 1980 个不同的值，那么这个索引的选择性就是 1980/2000=0.99。一个索引的选择性越接近于 1，这个索引的效率就越高。</p>
</blockquote>
</li>
</ul>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="MySQL-的常见瓶颈"><a href="#MySQL-的常见瓶颈" class="headerlink" title="MySQL 的常见瓶颈"></a>MySQL 的常见瓶颈</h3><ul>
<li>CPU：CPU饱和一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>硬件：top，free，iostat和vmstat来查看系统的性能状态</li>
</ul>
<h3 id="EXPLAIN-能查看哪些信息"><a href="#EXPLAIN-能查看哪些信息" class="headerlink" title="EXPLAIN 能查看哪些信息"></a>EXPLAIN 能查看哪些信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from pms_category \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1425</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>id</code>：表的读取顺序。</li>
<li><code>select_type</code>：数据读取操作的操作类型。</li>
<li><code>type</code>：访问类型排列。</li>
<li><code>possible_keys</code>：哪些索引可以使用。</li>
<li><code>key</code>：哪些索引被实际使用。</li>
<li><code>ref</code>：表之间的引用。</li>
<li><code>rows</code>：每张表有多少行被优化器查询。</li>
</ul>
<h3 id="id：表的读取顺序"><a href="#id：表的读取顺序" class="headerlink" title="id：表的读取顺序"></a>id：表的读取顺序</h3><p><code>id</code>：表的读取和加载顺序。select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序。</p>
<p>值有以下三种情况：</p>
<ul>
<li><p><code>id</code> 相同，执行顺序由上至下。</p>
<p><img src="/images/image-20220303152122683.png" alt="image-20220303152122683"></p>
</li>
<li><p><code>id</code> 不同，如果是子查询，id 的序号会递增，<strong>id 值越大优先级越高，越先被执行。</strong></p>
<p><img src="/images/image-20220303153619242.png" alt="image-20220303153619242"></p>
</li>
<li><p><code>id</code> 同时存在相同和不同。<strong>永远是 id 大的优先级最高，id 相等的时候顺序执行。</strong></p>
<p><img src="/images/image-20220303153031298.png" alt="image-20220303153031298"></p>
</li>
</ul>
<h3 id="select-type：查询类型"><a href="#select-type：查询类型" class="headerlink" title="select_type：查询类型"></a>select_type：查询类型</h3><p><code>select_type</code>：数据查询的类型，主要是用于区别，普通查询、联合查询、子查询等的复杂查询。</p>
<ul>
<li><p><code>SIMPLE</code>：简单的 <code>SELECT</code> 查询，查询中不包含子查询或者 <code>UNION </code>。</p>
</li>
<li><p><code>PRIMARY</code>：查询中如果包含任何复杂的子部分，最外层查询则被标记为 <code>PRIMARY</code>。</p>
<p><img src="/images/24e95e20-image-20220303153619242.png" alt="image-20220303153619242"></p>
</li>
<li><p><code>SUBQUERY</code>：在 <code>SELECT</code> 或者 <code>WHERE</code> 子句中包含了子查询。</p>
</li>
<li><p><code>DERIVED(衍生)</code>：在 <code>FROM</code> 子句中包含的子查询。MySQL 会递归执行这些子查询，把结果放在临时表中。</p>
<p><img src="/images/9b2b6f3b-image-20220303153031298.png" alt="image-20220303153031298"></p>
</li>
<li><p><code>UNION</code>：如果第二个 <code>SELECT</code> 出现在 <code>UNION</code> 之后，则被标记为 <code>UNION</code>；若 <code>UNION</code> 包含在 <code>FROM</code> 子句的子查询中，外层 <code>SELECT</code> 将被标记为 <code>DERIVED</code>。</p>
</li>
<li><p><code>UNION RESULT</code>：从 <code>UNION</code> 表获取结果的 <code>SELECT</code>。</p>
</li>
</ul>
<h3 id="table：数据是关于哪张表的"><a href="#table：数据是关于哪张表的" class="headerlink" title="table：数据是关于哪张表的"></a>table：数据是关于哪张表的</h3><p><img src="/images/9b2b6f3b-image-20220303153031298.png" alt="image-20220303153031298"></p>
<h3 id="type：查询使用了何种访问类型"><a href="#type：查询使用了何种访问类型" class="headerlink" title="type：查询使用了何种访问类型"></a>type：查询使用了何种访问类型</h3><p><strong>从最好到最差依次是：</strong><code>system</code>&gt;<code>const</code>&gt;<code>eq_ref</code>&gt;<code>ref</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>ALL</code>。除了 <code>ALL</code> 没有用到索引，其他级别都用到索引了。</p>
<blockquote>
<p>一般来说，得保证查询至少达到 <code>range</code> 级别，最好达到 <code>ref</code>。</p>
</blockquote>
<ul>
<li><p><code>system</code>：表只有一行记录（等于系统表），这是 <code>const</code> 类型的特例，平时不会出现，这个也可以忽略不计。</p>
</li>
<li><p><code>const</code>：表示通过索引一次就找到了，<code>const</code> 用于比较 <code>primary key</code> 或者 <code>unique</code> 索引。因为只匹配一行数据，所以很快。如将主键置于 <code>where</code> 列表中，MySQL 就能将该查询转化为一个常量。</p>
<blockquote>
<p><img src="/images/image-20220303155304336.png" alt="image-20220303155304336"></p>
<ul>
<li><code>select * from t1 where id = 1;</code>：id 为 primary key，因此只匹配一行记录。</li>
<li><code>select * from (XXX) d1;</code>：此时的 d1 其实只有一行记录，因此为 system。</li>
</ul>
</blockquote>
</li>
<li><p><code>eq_ref</code>：唯一性索引扫描，读取<strong>本表中和关联表表中的每行组合成的一行</strong>，查出来只有一条记录。除 了 <code>system</code> 和<code> const</code> 类型之外，这是最好的联接类型。</p>
<p><img src="/images/image-20220303163358177.png" alt="image-20220303163358177"></p>
</li>
<li><p><code>ref</code>：非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录。</p>
<p><img src="/images/image-20220303163623252.png" alt="image-20220303163623252"></p>
</li>
<li><p><code>range</code>：命中索引的情况下，只检索给定范围的行，一般就是在 <code>WHERE</code> 语句中出现了 <code>BETWEEN</code>、<code>&lt; &gt;</code>、<code>in</code> 等的查询。这种范围扫描索引比全表扫描要好，因为它只需要<strong>开始于索引树的某一点</strong>，而结束于另一点，不用扫描全部索引。</p>
<p><img src="/images/image-20220303163907040.png" alt="image-20220303163907040"></p>
</li>
<li><p><code>index</code>：<code>Full Index Scan</code>，全索引扫描，<code>index</code> 和 <code>ALL</code> 的区别为 <code>index</code> 类型只遍历索引树。<strong>也就是说虽然 <code>ALL</code> 和 <code>index</code> 都是读全表，但是 <code>index</code> 是从索引中读的，<code>ALL</code> 是从磁盘中读取的。</strong></p>
<p><img src="/images/image-20220303164058635.png" alt="image-20220303164058635"></p>
</li>
<li><p><code>ALL</code>：<code>Full Table Scan</code>，没有用到索引，全表扫描。</p>
<p><img src="/images/image-20220303164230573.png" alt="image-20220303164230573"></p>
</li>
</ul>
<h4 id="const-与-eq-ref-的区别"><a href="#const-与-eq-ref-的区别" class="headerlink" title="const 与 eq_ref 的区别"></a>const 与 eq_ref 的区别</h4><ul>
<li><code>const</code> 是直接按主键或唯一键读取。</li>
<li><code>eq_ref</code> 用于联表查询的情况，按联表的主键或唯一键联合查询。</li>
</ul>
<p>const：该表最多有一个匹配行，在查询开始时读取。由于只有一行，因此该行中列的值可以被优化器的其余部分视为常量。const 表非常快，因为它们只读一次。const 用于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较。在下面的查询中，tbl_name 可以用作 const 表:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> primary_key_part1<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> primary_key_part2<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<p>eq_ref：<strong>读取本表中和关联表表中的每行组合成的一行</strong>。当连接使用索引的所有部分时，索引是主键或唯一非 NULL 索引时，将使用该值。eq_ref 可用于使用 <code>=</code> 运算符比较的索引列。比较值可以是常量或使用此表之前读取的表中的列的表达式。在下面的示例中，MySQL 可以使用 eq_ref 连接 (join) ref_table 来处理:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column<span class="operator">=</span>other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1<span class="operator">=</span>other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h3 id="possible-keys-和-key"><a href="#possible-keys-和-key" class="headerlink" title="possible_keys 和 key"></a>possible_keys 和 key</h3><ul>
<li><p><code>possible_keys</code>：哪些索引可以使用。显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用。</strong></p>
</li>
<li><p><code>key</code>：哪些索引被实际使用。如果为 <code>NULL</code>，则没有使用索引。</p>
<blockquote>
<p>查询中如果使用了覆盖索引，则该索引仅仅出现在 <code>key</code> 列表中。</p>
<p><img src="/images/image-20220303170446052.png" alt="image-20220303170446052"></p>
</blockquote>
</li>
</ul>
<h3 id="key-len：索引中使用的字节数"><a href="#key-len：索引中使用的字节数" class="headerlink" title="key_len：索引中使用的字节数"></a>key_len：索引中使用的字节数</h3><p><code>key_len</code>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。<code>key_len</code> 显示的值为索引字段的最大可能长度，并非实际使用长度，即 <strong>key_len 是根据表定义计算而得</strong>，不是通过表内检索出的。在不损失精度的情况下，长度越短越好。</p>
<p><img src="/images/image-20220303171154458.png" alt="image-20220303171154458"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc pms_category;</span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type       | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">| cat_id        | bigint(20) | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name          | char(50)   | YES  |     | NULL    |                |</span><br><span class="line">| parent_cid    | bigint(20) | YES  |     | NULL    |                |</span><br><span class="line">| cat_level     | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">| show_status   | tinyint(4) | YES  |     | NULL    |                |</span><br><span class="line">| sort          | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">| icon          | char(255)  | YES  |     | NULL    |                |</span><br><span class="line">| product_unit  | char(50)   | YES  |     | NULL    |                |</span><br><span class="line">| product_count | int(11)    | YES  |     | NULL    |                |</span><br><span class="line">+---------------+------------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; explain select cat_id from pms_category where cat_id between 10 and 20 \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY  # 用到了主键索引，通过查看表结构知道，cat_id是bigint类型，占用8个字节</span><br><span class="line">      key_len: 8        # 这里只用到了cat_id主键索引，所以长度就是8！</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 11</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="ref：索引的哪一列被使用"><a href="#ref：索引的哪一列被使用" class="headerlink" title="ref：索引的哪一列被使用"></a>ref：索引的哪一列被使用</h3><p><code>ref</code>：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p>
<p><img src="/images/dca48f04-image-20220303152122683.png" alt="image-20220303152122683"></p>
<h3 id="rows：需要读取的行数"><a href="#rows：需要读取的行数" class="headerlink" title="rows：需要读取的行数"></a>rows：需要读取的行数</h3><p><code>rows</code>：根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。</p>
<h3 id="Extra：额外信息"><a href="#Extra：额外信息" class="headerlink" title="Extra：额外信息"></a>Extra：额外信息</h3><p><code>Extra</code>：包含不适合在其他列中显示但十分重要的额外信息。</p>
<ul>
<li><p><code>Using filesort</code>：说明 MySQL 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<strong>MySQL 中无法利用索引完成的排序操作成为 “文件内排序”。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 为什么会有Using filesort？</span><br><span class="line"># 查询的时候使用到了索引，但是排序的时候没有使用索引</span><br><span class="line">mysql&gt; explain select name from pms_category where name=&#x27;Tangs&#x27; order by cat_level \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_name_parentCid_catLevel</span><br><span class="line">          key: idx_name_parentCid_catLevel</span><br><span class="line">      key_len: 201</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index; Using filesort</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 排序使用到了索引</span><br><span class="line">mysql&gt; explain select name from pms_category where name=&#x27;Tangs&#x27; order by parent_cid,cat_level\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_name_parentCid_catLevel</span><br><span class="line">          key: idx_name_parentCid_catLevel</span><br><span class="line">      key_len: 201</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Using temporary</code>：使用了临时表保存中间结果，MySQL 在対查询结果排序时使用了临时表。常见于排序 <code>order by</code> 和分组查询 <code>group by</code>。<strong>临时表対系统性能损耗很大。</strong></p>
<p><img src="/images/image-20220303173520455.png" alt="image-20220303173520455"></p>
</li>
<li><p><code>Using index</code>：表示相应的 <code>SELECT</code> 操作中使用了覆盖索引，避免访问了表的数据行，效率不错！如果同时出现 <code>Using where</code>，表示索引被用来执行索引键值的查找；如果没有同时出现 <code>Using where</code>，表明索引用来读取数据而非执行查找动作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 覆盖索引</span><br><span class="line"># 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</span><br><span class="line"># 注意：如果要使用覆盖索引，一定不能写SELECT *，要写出具体的字段。</span><br><span class="line">mysql&gt; explain select cat_id from pms_category \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: pms_category</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL       </span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1425</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index   # select的数据列只用从索引中就能够取得，不必从数据表中读取   </span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>覆盖索引：<strong>select 的数据列只用从索引中就能够取得</strong>，不必读取数据行，MySQL 可以利用素引返回 select 列表中的字段，而不必根据素引再次读取数据文件，换句话说就是：<strong>查询列要被所建的素引覆盖</strong>。</p>
<p>理解方式二：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据：当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖素引。</p>
</blockquote>
</li>
<li><p><code>Using where</code>：表明使用了 <code>WHERE</code> 过滤。</p>
</li>
<li><p><code>Using join buffer</code>：使用了连接缓存。</p>
</li>
<li><p><code>impossible where</code>：<code>WHERE</code> 子句的值总是 false，不能用来获取任何元组。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select name from pms_category where name = &#x27;zs&#x27; and name = &#x27;ls&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">     filtered: NULL</span><br><span class="line">        Extra: Impossible WHERE   # 不可能字段同时查到两个名字</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="/images/image-20220304112942379.png" alt="image-20220304112942379"></p>
<ul>
<li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为<code>&lt;derived3&gt;</code>，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name…】</li>
<li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包合在from中，所以为derived。【select id，name from t1 where other column=‘’】</li>
<li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li>
<li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name, id from t2】</li>
<li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的<code>&lt;union1,4&gt;</code>表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li>
</ul>
<h2 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h2><h3 id="单表索引分析"><a href="#单表索引分析" class="headerlink" title="单表索引分析"></a>单表索引分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `article`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS `article`(</span><br><span class="line">`id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">`author_id` INT(10) UNSIGNED NOT NULL COMMENT &#x27;作者id&#x27;,</span><br><span class="line">`category_id` INT(10) UNSIGNED NOT NULL COMMENT &#x27;分类id&#x27;,</span><br><span class="line">`views` INT(10) UNSIGNED NOT NULL COMMENT &#x27;被查看的次数&#x27;,</span><br><span class="line">`comments` INT(10) UNSIGNED NOT NULL COMMENT &#x27;回帖的备注&#x27;,</span><br><span class="line">`title` VARCHAR(255) NOT NULL COMMENT &#x27;标题&#x27;,</span><br><span class="line">`content` VARCHAR(255) NOT NULL COMMENT &#x27;正文内容&#x27;</span><br><span class="line">) COMMENT &#x27;文章&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(1,1,1,1,&#x27;1&#x27;,&#x27;1&#x27;);</span><br><span class="line">INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(2,2,2,2,&#x27;2&#x27;,&#x27;2&#x27;);</span><br><span class="line">INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(3,3,3,3,&#x27;3&#x27;,&#x27;3&#x27;);</span><br><span class="line">INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(1,1,3,3,&#x27;3&#x27;,&#x27;3&#x27;);</span><br><span class="line">INSERT INTO `article`(`author_id`, `category_id`, `views`, `comments`, `title`, `content`) VALUES(1,1,4,4,&#x27;4&#x27;,&#x27;4&#x27;);</span><br></pre></td></tr></table></figure>

<p>查询 <code>category_id</code> 为 1 且 <code>comments</code> 大于 1 的情况下，<code>views</code> 最多的 <code>article_id</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: article</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5</span><br><span class="line">     filtered: 20.00</span><br><span class="line">        Extra: Using where; Using filesort  # 产生了文件内排序，需要优化SQL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>发现 type 为 ALL，存在 Using filesort。</p>
<p>优化如下：</p>
<p>创建索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_article_ccv ON article(category_id,comments,views);</span><br></pre></td></tr></table></figure>

<p>查看当前索引：</p>
<p><img src="/images/8d.png" alt="image-20220304112942379"></p>
<p>查看现在 SQL 语句的执行计划：</p>
<p><img src="/images/67.png" alt="image-20220304112942379"></p>
<p>发现：创建符合索引 <code>idx_article_ccv</code> 之后，虽然解决了全表扫描的问题，但是在 <code>order by</code> 排序的时候没有用到索引，MySQL 居然还是用的 <code>Using filesort</code>，为什么？</p>
<p>尝试把 SQL 修改为以下， 看看 SQL 的执行计划。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,author_id FROM article WHERE category_id = 1 AND comments = 1 ORDER BY views DESC LIMIT 1;</span><br></pre></td></tr></table></figure>

<p><img src="/images/68.png" alt="image-20220304112942379"></p>
<p>推论：当 <code>comments &gt; 1</code> 的时候 <code>order by</code> 排序 <code>views</code> 字段索引就用不上，但是当 <code>comments = 1</code> 的时候 <code>order by</code> 排序 <code>views</code> 字段索引就可以用上！！！<strong>所以，范围之后的索引会失效。</strong></p>
<p>我们现在知道<strong>范围之后的索引会失效</strong>，原来的索引 <code>idx_article_ccv</code> 最后一个字段 <code>views</code> 会失效，那么我们如果删除这个索引，创建 <code>idx_article_cv</code> 索引呢？？？？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 创建索引 idx_article_cv */</span><br><span class="line">CREATE INDEX idx_article_cv ON article(category_id,views);</span><br></pre></td></tr></table></figure>

<p>查看当前的索引</p>
<p><img src="/images/70.png" alt="image-20220304112942379"></p>
<p>当前索引是 <code>idx_article_cv</code>，来看一下 SQL 执行计划。</p>
<p><img src="/images/71.png" alt="image-20220304112942379"></p>
<h3 id="两表索引分析"><a href="#两表索引分析" class="headerlink" title="两表索引分析"></a>两表索引分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `class`;</span><br><span class="line">DROP TABLE IF EXISTS `book`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS `class`(</span><br><span class="line">`id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">`card` INT(10) UNSIGNED NOT NULL COMMENT &#x27;分类&#x27; </span><br><span class="line">) COMMENT &#x27;商品类别&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS `book`(</span><br><span class="line">`bookid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">`card` INT(10) UNSIGNED NOT NULL COMMENT &#x27;分类&#x27;</span><br><span class="line">) COMMENT &#x27;书籍&#x27;;</span><br></pre></td></tr></table></figure>

<p>两表连接查询的 SQL 执行计划：</p>
<p>不创建索引的情况下，SQL 的执行计划。</p>
<p><img src="/images/72.png" alt="image-20220304112942379"></p>
<p>优化如下：</p>
<p><code>book</code> 和 <code>class</code> 两张表都是没有使用索引，全表扫描，那么如果进行优化，索引是创建在 <code>book</code> 表还是创建在 <code>class</code> 表呢？尝试如下：</p>
<p>左表 (<code>book</code> 表) 创建索引。</p>
<p>创建索引 <code>idx_book_card</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 在book表创建索引 */</span><br><span class="line">CREATE INDEX idx_book_card ON book(card);</span><br></pre></td></tr></table></figure>

<p>在 <code>book</code> 表中有 <code>idx_book_card</code> 索引的情况下，查看 SQL 执行计划</p>
<p><img src="/images/73.png" alt="image-20220304112942379"></p>
<p>删除 <code>book</code> 表的索引，右表 (<code>class</code> 表) 创建索引。</p>
<p>创建索引 <code>idx_class_card</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 在class表创建索引 */</span><br><span class="line">CREATE INDEX idx_class_card ON class(card);</span><br></pre></td></tr></table></figure>

<p>在 <code>class</code> 表中有 <code>idx_class_card</code> 索引的情况下，查看 SQL 执行计划</p>
<p><img src="/images/74.png" alt="image-20220304112942379"></p>
<blockquote>
<p>由此可见，<strong>左连接将索引创建在右表上更合适，右连接将索引创建在左表上更合适。</strong></p>
</blockquote>
<h3 id="三张表索引分析"><a href="#三张表索引分析" class="headerlink" title="三张表索引分析"></a>三张表索引分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `phone`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS `phone`(</span><br><span class="line">`phone_id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">`card` INT(10) UNSIGNED NOT NULL COMMENT &#x27;分类&#x27; </span><br><span class="line">) COMMENT &#x27;手机&#x27;;</span><br></pre></td></tr></table></figure>

<p>三表连接查询 SQL 优化</p>
<p>不加任何索引，查看 SQL 执行计划。</p>
<p><img src="/images/75.png" alt="image-20220304112942379"></p>
<p>优化如下：</p>
<p>根据两表查询优化的经验，左连接需要在右表上添加索引，所以尝试在 <code>book</code> 表和 <code>phone</code> 表上添加索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 在book表创建索引 */</span><br><span class="line">CREATE INDEX idx_book_card ON book(card);</span><br><span class="line"></span><br><span class="line">/* 在phone表上创建索引 */</span><br><span class="line">CREATE INDEX idx_phone_card ON phone(card);</span><br></pre></td></tr></table></figure>

<p>再次执行 SQL 的执行计划</p>
<p><img src="/images/76.png" alt="image-20220304112942379"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>JOIN</code> 语句的优化：</p>
<ul>
<li>尽可能减少 <code>JOIN</code> 语句中的 <code>NestedLoop</code>（嵌套循环）的总次数：<strong>永远都是小的结果集驱动大的结果集</strong>。</li>
<li>优先优化 <code>NestedLoop</code> 的内层循环。</li>
<li>保证 <code>JOIN</code> 语句中被驱动表上 <code>JOIN</code> 条件字段已经被索引。</li>
<li>当无法保证被驱动表的 <code>JOIN</code> 条件字段被索引且内存资源充足的前提下，不要太吝惜 <code>Join Buffer</code> 的设置。</li>
</ul>
<h2 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h2><p>数据准备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `staffs`(</span><br><span class="line">`id` INT(10) PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">`name` VARCHAR(24) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class="line">`age` INT(10) NOT NULL DEFAULT 0 COMMENT &#x27;年龄&#x27;,</span><br><span class="line">`pos` VARCHAR(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;职位&#x27;,</span><br><span class="line">`add_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;入职时间&#x27;</span><br><span class="line">)COMMENT &#x27;员工记录表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO `staffs`(`name`,`age`,`pos`) VALUES(&#x27;Ringo&#x27;, 18, &#x27;manager&#x27;);</span><br><span class="line">INSERT INTO `staffs`(`name`,`age`,`pos`) VALUES(&#x27;张三&#x27;, 20, &#x27;dev&#x27;);</span><br><span class="line">INSERT INTO `staffs`(`name`,`age`,`pos`) VALUES(&#x27;李四&#x27;, 21, &#x27;dev&#x27;);</span><br><span class="line"></span><br><span class="line">/* 创建索引 */</span><br><span class="line">CREATE INDEX idx_staffs_name_age_pos ON `staffs`(`name`,`age`,`pos`);</span><br></pre></td></tr></table></figure>



<h3 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h3><p>最佳左前缀法则：<strong>如果索引是多字段的复合索引，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的字段。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 用到了idx_staffs_name_age_pos索引中的name字段 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` = &#x27;Ringo&#x27;;</span><br><span class="line"></span><br><span class="line">/* 用到了idx_staffs_name_age_pos索引中的name, age字段 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` = &#x27;Ringo&#x27; AND `age` = 18;</span><br><span class="line"></span><br><span class="line">/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况*/</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` = &#x27;Ringo&#x27; AND `age` = 18 AND `pos` = &#x27;manager&#x27;;</span><br><span class="line"></span><br><span class="line">/* 索引没用上，ALL全表扫描 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `age` = 18 AND `pos` = &#x27;manager&#x27;;</span><br><span class="line"></span><br><span class="line">/* 索引没用上，ALL全表扫描 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `pos` = &#x27;manager&#x27;;</span><br><span class="line"></span><br><span class="line">/* 用到了idx_staffs_name_age_pos索引中的name字段，pos字段索引失效 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` = &#x27;Ringo&#x27; AND `pos` = &#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>



<h3 id="索引列上不计算"><a href="#索引列上不计算" class="headerlink" title="索引列上不计算"></a>索引列上不计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 现在要查询`name` = &#x27;Ringo&#x27;的记录下面有两种方式来查询！</span><br><span class="line"></span><br><span class="line"># 1、直接使用 字段 = 值的方式来计算</span><br><span class="line">mysql&gt; SELECT * FROM `staffs` WHERE `name` = &#x27;Ringo&#x27;;</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">| id | name  | age | pos     | add_time            |</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">|  1 | Ringo |  18 | manager | 2020-08-03 08:30:39 |</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 2、使用MySQL内置的函数</span><br><span class="line">mysql&gt; SELECT * FROM `staffs` WHERE LEFT(`name`, 5) = &#x27;Ringo&#x27;;</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">| id | name  | age | pos     | add_time            |</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">|  1 | Ringo |  18 | manager | 2020-08-03 08:30:39 |</span><br><span class="line">+----+-------+-----+---------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><img src="/images/77.png" alt="image-20220304112942379"></p>
<blockquote>
<p>由此可见，<strong>在索引列上进行计算，会使索引失效。</strong></p>
</blockquote>
<h3 id="范围之后全失效"><a href="#范围之后全失效" class="headerlink" title="范围之后全失效"></a>范围之后全失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 用到了idx_staffs_name_age_pos索引中的name，age，pos字段 这是属于全值匹配的情况！！！*/</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` = &#x27;Ringo&#x27; AND `age` = 18 AND `pos` = &#x27;manager&#x27;;</span><br><span class="line"></span><br><span class="line">/* 用到了idx_staffs_name_age_pos索引中的name，age字段，pos字段索引失效 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` = &#x27;张三&#x27; AND `age` &gt; 18 AND `pos` = &#x27;dev&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/78.png" alt="image-20220304112942379"></p>
<blockquote>
<p>由此可知，<strong>查询范围的字段使用到了索引，但是范围之后的索引字段会失效。</strong></p>
</blockquote>
<h3 id="尽量用覆盖索引"><a href="#尽量用覆盖索引" class="headerlink" title="尽量用覆盖索引"></a>尽量用覆盖索引</h3><p>在写 SQL 的不要使用 <code>SELECT *</code>，用什么字段就查询什么字段。尽量只访问索引的查询，保持索引列和查询列一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 没有用到覆盖索引 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` = &#x27;Ringo&#x27; AND `age` = 18 AND `pos` = &#x27;manager&#x27;;</span><br><span class="line"></span><br><span class="line">/* 用到了覆盖索引 */</span><br><span class="line">EXPLAIN SELECT `name`, `age`, `pos` FROM `staffs` WHERE `name` = &#x27;Ringo&#x27; AND `age` = 18 AND `pos` = &#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/79.png" alt="image-20220304112942379"></p>
<h3 id="和-is-null-有时会失效"><a href="#和-is-null-有时会失效" class="headerlink" title="!= 和 is null 有时会失效"></a>!= 和 is null 有时会失效</h3><p>默认为 Null 的列，存在 Null 值会导致 mysql 优化器处理起来比较复杂，但是到底走不走索引，或者走那个索引，是要靠 mysql 优化器预先预估走那个索引成本比较低来决定的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 会使用到覆盖索引 */</span><br><span class="line">EXPLAIN SELECT `name`, `age`, `pos` FROM `staffs` WHERE `name` = &#x27;Ringo&#x27;;</span><br><span class="line"></span><br><span class="line">/* 索引失效 全表扫描 */</span><br><span class="line">EXPLAIN SELECT `name`, `age`, `pos` FROM `staffs` WHERE `name` != &#x27;Ringo&#x27;;</span><br></pre></td></tr></table></figure>



<h3 id="like-百分加右边"><a href="#like-百分加右边" class="headerlink" title="like 百分加右边"></a>like 百分加右边</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 索引失效 全表扫描 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` LIKE &#x27;%ing%&#x27;;</span><br><span class="line"></span><br><span class="line">/* 索引失效 全表扫描 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` LIKE &#x27;%ing&#x27;;</span><br><span class="line"></span><br><span class="line">/* 使用索引范围查询 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` LIKE &#x27;Rin%&#x27;;</span><br></pre></td></tr></table></figure>

<p>如果一定要使用 <code>%like</code>，而且还要保证索引不失效，那么<strong>使用覆盖索引</strong>来编写 SQL。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 使用到了覆盖索引 */</span><br><span class="line">EXPLAIN SELECT `id` FROM `staffs` WHERE `name` LIKE &#x27;%in%&#x27;;</span><br><span class="line">EXPLAIN SELECT `name` FROM `staffs` WHERE `name` LIKE &#x27;%in%&#x27;;</span><br><span class="line">EXPLAIN SELECT `age` FROM `staffs` WHERE `name` LIKE &#x27;%in%&#x27;;</span><br><span class="line">EXPLAIN SELECT `pos` FROM `staffs` WHERE `name` LIKE &#x27;%in%&#x27;;</span><br><span class="line">EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `name` LIKE &#x27;%in%&#x27;;</span><br><span class="line">EXPLAIN SELECT `id`, `age` FROM `staffs` WHERE `name` LIKE &#x27;%in%&#x27;;</span><br><span class="line">EXPLAIN SELECT `id`,`name`, `age`, `pos` FROM `staffs` WHERE `name` LIKE &#x27;%in&#x27;;</span><br><span class="line">EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `pos` LIKE &#x27;%na&#x27;;</span><br><span class="line"></span><br><span class="line">/* 索引失效 全表扫描 */</span><br><span class="line">EXPLAIN SELECT `name`, `age`, `pos`, `add_time` FROM `staffs` WHERE `name` LIKE &#x27;%in&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/80.png" alt="image-20220304112942379"></p>
<h3 id="字符要加单引号"><a href="#字符要加单引号" class="headerlink" title="字符要加单引号"></a>字符要加单引号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 使用到了覆盖索引 */</span><br><span class="line">EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `name` = &#x27;Ringo&#x27;;</span><br><span class="line">EXPLAIN SELECT `id`, `name` FROM `staffs` WHERE `name` = 2000;</span><br><span class="line"></span><br><span class="line">/* 索引失效 全表扫描 */</span><br><span class="line">EXPLAIN SELECT * FROM `staffs` WHERE `name` = 2000;</span><br></pre></td></tr></table></figure>

<p>这里 name = 2000 在 MySQL 中会发生强制类型转换，将数字转成字符串。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 创建表 */</span><br><span class="line">CREATE TABLE `test03`(</span><br><span class="line">`id` INT PRIMARY KEY NOT NULL AUTO_INCREMENT,</span><br><span class="line">`c1` CHAR(10),</span><br><span class="line">`c2` CHAR(10),</span><br><span class="line">`c3` CHAR(10),</span><br><span class="line">`c4` CHAR(10),</span><br><span class="line">`c5` CHAR(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/* 插入数据 */</span><br><span class="line">INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES(&#x27;a1&#x27;,&#x27;a2&#x27;,&#x27;a3&#x27;,&#x27;a4&#x27;,&#x27;a5&#x27;);</span><br><span class="line">INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES(&#x27;b1&#x27;,&#x27;b22&#x27;,&#x27;b3&#x27;,&#x27;b4&#x27;,&#x27;b5&#x27;);</span><br><span class="line">INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES(&#x27;c1&#x27;,&#x27;c2&#x27;,&#x27;c3&#x27;,&#x27;c4&#x27;,&#x27;c5&#x27;);</span><br><span class="line">INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES(&#x27;d1&#x27;,&#x27;d2&#x27;,&#x27;d3&#x27;,&#x27;d4&#x27;,&#x27;d5&#x27;);</span><br><span class="line">INSERT INTO `test03`(`c1`,`c2`,`c3`,`c4`,`c5`) VALUES(&#x27;e1&#x27;,&#x27;e2&#x27;,&#x27;e3&#x27;,&#x27;e4&#x27;,&#x27;e5&#x27;);</span><br><span class="line"></span><br><span class="line">/* 创建复合索引 */</span><br><span class="line">CREATE INDEX idx_test03_c1234 ON `test03`(`c1`,`c2`,`c3`,`c4`);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* 全值匹配 用到索引c1 c2 c3 c4全字段 */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c2` = &#x27;a2&#x27; AND `c3` = &#x27;a3&#x27; AND `c4` = &#x27;a4&#x27;;</span><br><span class="line"></span><br><span class="line">/* 用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c4` = &#x27;a4&#x27; AND `c3` = &#x27;a3&#x27; AND `c2` = &#x27;a2&#x27; AND `c1` = &#x27;a1&#x27;;</span><br><span class="line"></span><br><span class="line">/* 用到索引c1 c2 c3 c4全字段 MySQL的查询优化器会优化SQL语句的顺序*/</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c2` = &#x27;a2&#x27; AND `c4` &gt; &#x27;a4&#x27; AND `c3` = &#x27;a3&#x27;;</span><br><span class="line"></span><br><span class="line">/* 用到索引c1 c2 c3字段，c4字段失效，范围之后全失效 */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c2` = &#x27;a2&#x27; AND `c3` &gt; &#x27;a3&#x27; AND `c4` = &#x27;a4&#x27;;</span><br><span class="line"></span><br><span class="line">/* 用到了索引c1 c2 c3三个字段, c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中，c4字段失效 */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c2` = &#x27;a2&#x27; AND `c4` = &#x27;a4&#x27; ORDER BY `c3`;</span><br><span class="line"></span><br><span class="line">/* 用到了索引c1 c2 c3三个字段，c1和c2两个字段用于查找, c3字段用于排序了但是没有统计到key_len中*/</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c2` = &#x27;a2&#x27; ORDER BY `c3`;</span><br><span class="line"></span><br><span class="line">/* 用到了索引c1 c2两个字段，c4失效，c1和c2两个字段用于查找，c4字段排序产生了Using filesort说明排序没有用到c4字段 */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c2` = &#x27;a2&#x27; ORDER BY `c4`;</span><br><span class="line"></span><br><span class="line">/* 用到了索引c1 c2 c3三个字段，c1用于查找，c2和c3用于排序 */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c5` = &#x27;a5&#x27; ORDER BY `c2`, `c3`;</span><br><span class="line"></span><br><span class="line">/* 用到了c1一个字段，c1用于查找，c3和c2两个字段索引失效，产生了Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c5` = &#x27;a5&#x27; ORDER BY `c3`, `c2`;</span><br><span class="line"></span><br><span class="line">/* 用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND  `c2` = &#x27;a2&#x27; ORDER BY c2, c3;</span><br><span class="line"></span><br><span class="line">/* 用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND  `c2` = &#x27;a2&#x27; AND `c5` = &#x27;a5&#x27; ORDER BY c2, c3;</span><br><span class="line"></span><br><span class="line">/* 用到了c1 c2 c3三个字段，c1 c2用于查找，c2 c3用于排序 没有产生Using filesort。因为之前c2这个字段已经确定了是&#x27;a2&#x27;了，这是一个常量，再去ORDER BY c3,c2 这时候c2已经不用排序了！*/</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c2` = &#x27;a2&#x27; AND `c5` = &#x27;a5&#x27; ORDER BY c3, c2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GROUP BY 表面上是叫做分组，但是分组之前必定排序。 */</span><br><span class="line"></span><br><span class="line">/* 用到c1 c2 c3三个字段，c1用于查找，c2 c3用于排序，c4失效 */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c4` = &#x27;a4&#x27; GROUP BY `c2`,`c3`;</span><br><span class="line"></span><br><span class="line">/* 用到c1这一个字段，c4失效，c2和c3排序失效产生了Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `test03` WHERE `c1` = &#x27;a1&#x27; AND `c4` = &#x27;a4&#x27; GROUP BY `c3`,`c2`;</span><br></pre></td></tr></table></figure>

<p><code>GROUP BY</code> 基本上都需要进行排序，索引优化几乎和 <code>ORDER BY</code> 一致，但是 <code>GROUP BY</code> 会有临时表的产生。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>索引优化的一般性建议：</p>
<ul>
<li>对于单值索引，尽量选择针对当前 <code>query</code> 过滤性更好的索引。</li>
<li>在选择复合索引的时候，当前 <code>query</code> 中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择复合索引的时候，尽量选择可以能够包含当前 <code>query</code> 中的 <code>where</code> 子句中更多字段的索引。</li>
<li>尽可能通过分析统计信息和调整 <code>query</code> 的写法来达到选择合适索引的目的。</li>
</ul>
<h2 id="分析慢-SQL-的步骤"><a href="#分析慢-SQL-的步骤" class="headerlink" title="分析慢 SQL 的步骤"></a>分析慢 SQL 的步骤</h2><p>总结（大纲）：</p>
<ol>
<li>慢查询日志的开启并捕获。</li>
<li>explain + 慢 SQL 分析。</li>
<li>show Profile 查询 SQL 在 MySQL 数据库中的执行细节和生命周期情况。</li>
<li>MySQL 数据库服务器的参数调优。</li>
</ol>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a>小表驱动大表</h3><p>优化原则：对于 MySQL 数据库而言，永远都是小表驱动大表。即：<strong>小的数据集驱动大的数据集</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 举个例子：可以使用嵌套的for循环来理解小表驱动大表。</span></span><br><span class="line"><span class="comment">* 以下两个循环结果都是一样的，但是对于MySQL来说不一样，</span></span><br><span class="line"><span class="comment">* 第一种可以理解为，和MySQL建立5次连接每次查询1000次。</span></span><br><span class="line"><span class="comment">* 第一种可以理解为，和MySQL建立1000次连接每次查询5次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IN 和 EXISTS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 优化原则：小表驱动大表，即小的数据集驱动大的数据集 */</span><br><span class="line"></span><br><span class="line">/* IN适合B表比A表数据小的情况*/</span><br><span class="line">SELECT * FROM `A` WHERE `id` IN (SELECT `id` FROM `B`)</span><br><span class="line"></span><br><span class="line">/* EXISTS适合B表比A表数据大的情况 */</span><br><span class="line">SELECT * FROM `A` WHERE EXISTS (SELECT 1 FROM `B` WHERE `B`.id = `A`.id);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>SELECT....FROM tab WHERE EXISTS(subquery);</code> 该语法可以理解为：<strong>将主查询的数据，放到子查询中做条件验证，根据验证结果（<code>true</code> 或是 <code>false</code>）来决定主查询的数据结果是否得以保留</strong>。</p>
</blockquote>
<blockquote>
<p>提示：</p>
<ul>
<li><code>EXISTS(subquery)</code> 子查询只返回 <code>true</code> 或者 <code>false</code>，因此子查询中的 <code>SELECT *</code> 可以是 <code>SELECT 1 OR SELECT X</code>，它们并没有区别。</li>
<li><code>EXISTS(subquery)</code> 子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担心效率问题，可进行实际检验以确定是否有效率问题。</li>
<li><code>EXISTS(subquery)</code> 子查询往往也可以用条件表达式，其他子查询或者 <code>JOIN</code> 替代，何种最优需要具体问题具体分析。</li>
</ul>
</blockquote>
<h3 id="ORDER-BY-优化"><a href="#ORDER-BY-优化" class="headerlink" title="ORDER BY 优化"></a>ORDER BY 优化</h3><p><code>ORDER BY</code> 子句，尽量使用索引排序，避免使用 <code>Using filesort</code> 排序。</p>
<p>MySQL 支持两种方式的排序，<code>FileSort</code> 和 <code>Index</code>，<code>Index</code> 的效率高，它指 MySQL 扫描索引本身完成排序。<code>FileSort</code> 方式效率较低。</p>
<p><code>ORDER BY</code> 满足两情况，会使用 <code>Index</code> 方式排序：</p>
<ul>
<li><code>ORDER BY</code> 语句使用索引最左前列。</li>
<li>使用 <code>WHERE</code> 子句与 <code>ORDER BY</code> 子句条件列组合满足索引最左前列。</li>
</ul>
<p><strong>结论：尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀原则。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `talA`(</span><br><span class="line">  `age` INT,</span><br><span class="line">  `birth` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO `talA`(`age`) VALUES(18);</span><br><span class="line">INSERT INTO `talA`(`age`) VALUES(19);</span><br><span class="line">INSERT INTO `talA`(`age`) VALUES(20);</span><br><span class="line">INSERT INTO `talA`(`age`) VALUES(21);</span><br><span class="line">INSERT INTO `talA`(`age`) VALUES(22);</span><br><span class="line">INSERT INTO `talA`(`age`) VALUES(23);</span><br><span class="line">INSERT INTO `talA`(`age`) VALUES(24);</span><br><span class="line">INSERT INTO `talA`(`age`) VALUES(25);</span><br><span class="line"></span><br><span class="line">/* 创建索引 */</span><br><span class="line">CREATE INDEX idx_talA_age_birth ON `talA`(`age`, `birth`);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 1.使用索引进行排序了 不会产生Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `talA` WHERE `age` &gt; 20 ORDER BY `age`;</span><br><span class="line"></span><br><span class="line">/* 2.使用索引进行排序了 不会产生Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `talA` WHERE `age` &gt; 20 ORDER BY `age`,`birth`;</span><br><span class="line"></span><br><span class="line">/* 3.没有使用索引进行排序 产生了Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `talA` WHERE `age` &gt; 20 ORDER BY `birth`;</span><br><span class="line"></span><br><span class="line">/* 4.没有使用索引进行排序 产生了Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `talA` WHERE `age` &gt; 20 ORDER BY `birth`,`age`;</span><br><span class="line"></span><br><span class="line">/* 5.没有使用索引进行排序 产生了Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `talA` ORDER BY `birth`;</span><br><span class="line"></span><br><span class="line">/* 6.没有使用索引进行排序 产生了Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `talA` WHERE `birth` &gt; &#x27;2020-08-04 07:42:21&#x27; ORDER BY `birth`;</span><br><span class="line"></span><br><span class="line">/* 7.使用索引进行排序了 不会产生Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `talA` WHERE `birth` &gt; &#x27;2020-08-04 07:42:21&#x27; ORDER BY `age`;</span><br><span class="line"></span><br><span class="line">/* 8.没有使用索引进行排序 产生了Using filesort */</span><br><span class="line">EXPLAIN SELECT * FROM `talA` ORDER BY `age` ASC, `birth` DESC;</span><br></pre></td></tr></table></figure>

<p>如果不在索引列上，File Sort 有两种算法：</p>
<ul>
<li><p><code>双路排序算法</code></p>
<p>MySQL4.1 之前使用双路排序，字面意思就是<strong>两次扫描磁盘，最终得到数据</strong>。</p>
<p>读取行指针和 <code>ORDER BY</code> 列，対他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。<strong>一句话，从磁盘取排序字段，在 <code>buffer</code> 中进行排序，再从磁盘取其他字段。</strong></p>
</li>
<li><p><code>单路排序算法</code></p>
<p>取一批数据，要对磁盘进行两次扫描，众所周知，IO 是很耗时的，所以在 MySQL4.1 之后，出现了改进的算法，就是单路排序算法。</p>
<p>从磁盘读取查询需要的所有列，按照 <code>ORDER BY</code> 列在 <code>buffer</code> 対它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间，因为它<strong>把每一行都保存在内存中</strong>了。</p>
<p>由于单路排序算法是后出的，总体而言效率好过双路排序算法。</p>
<p>但是单路排序算法也有可能出现问题：如果 <code>SortBuffer</code> 缓冲区太小，导致从磁盘中读取所有的列不能完全保存在 <code>SortBuffer</code> 缓冲区中，这时候单路复用算法就会出现问题，反而性能不如双路复用算法。</p>
<p>此时可以使用单路复用算法的优化策略：</p>
<ul>
<li>增大 <code>sort_buffer_size</code> 参数的设置。</li>
<li>增大 <code>max_length_for_sort_data</code> 参数的设置。</li>
</ul>
</li>
</ul>
<p>总结，提高 ORDER BY 排序的速度：</p>
<ul>
<li><code>ORDER BY</code> 时不要使用 <code>SELECT *</code> ，查什么字段就写什么字段，这点非常重要。在这里的影响是：<ul>
<li>当查询的字段大小总和小于 <code>max_length_for_sort_data</code> 而且排序字段不是 <code>TEXT|BLOB</code> 类型时，会使用单路排序算法，否则使用多路排序算法。</li>
<li>两种排序算法的数据都有可能超出 <code>sort_buffer</code> 缓冲区的容量，超出之后，会创建 <code>tmp</code> 临时文件进行合并排序，导致多次 IO，但是单路排序算法的风险会更大一些，所以要增大 <code>sort_buffer_size</code> 参数的设置。</li>
</ul>
</li>
<li>尝试提高 <code>sort_buffer_size</code>：不管使用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。</li>
<li>尝试提高 <code>max_length_for_sort_data</code>：提高这个参数，会增加用单路排序算法的概率。但是如果设置的太高，数据总容量 <code>sort_buffer_size</code> 的概率就增大，明显症状是高的磁盘 IO 活动和低的处理器使用率。</li>
</ul>
<h3 id="GORUP-BY-优化"><a href="#GORUP-BY-优化" class="headerlink" title="GORUP BY 优化"></a>GORUP BY 优化</h3><ul>
<li><code>GROUP BY</code> 实质是<strong>先排序后进行分组，遵照索引建的最佳左前缀</strong>。</li>
<li>当无法使用索引列时，会使用 <code>Using filesort</code> 进行排序，增大 <code>max_length_for_sort_data</code> 参数的设置和增大 <code>sort_buffer_size</code> 参数的设置，会提高性能。</li>
<li><code>WHERE</code> 执行顺序高于 <code>HAVING</code>，能写在 <code>WHERE</code> 限定条件里的就不要写在 <code>HAVING</code> 中了。</li>
</ul>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p>
</li>
<li><p><code>long_query_time</code> 的默认值为 10，意思是运行 10 秒以上的语句。</p>
</li>
<li><p>查看慢查询日志是否开启：<code>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</code>。</p>
</li>
<li><p>开启慢查询日志：<code>SET GLOBAL slow_query_log = 1;</code>。使用该方法开启 MySQL 的慢查询日志只对当前数据库生效，如果 MySQL 重启后会失效。</p>
</li>
<li><p>如果要使慢查询日志永久开启，需要修改 <code>my.cnf</code> 文件，在 <code>[mysqld]</code> 下增加修改参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"># 1.这个是开启慢查询。注意ON需要大写</span><br><span class="line">slow_query_log=ON  </span><br><span class="line"></span><br><span class="line"># 2.这个是存储慢查询的日志文件。这个文件不存在的话，需要自己创建</span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow.log</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h3><p>MySQL 提供了日志分析工具 <code>mysqldumpslow</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@1dcb5644392c:/usr/bin<span class="comment"># mysqldumpslow --help</span></span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"></span><br><span class="line">Parse and summarize the MySQL slow query <span class="built_in">log</span>. Options are</span><br><span class="line"></span><br><span class="line">  --verbose    verbose</span><br><span class="line">  --debug      debug</span><br><span class="line">  --<span class="built_in">help</span>       write this text to standard output</span><br><span class="line"></span><br><span class="line">  -v           verbose</span><br><span class="line">  -d           debug</span><br><span class="line">  -s ORDER     what to sort by (al, at, ar, c, l, r, t), <span class="string">&#x27;at&#x27;</span> is default  <span class="comment"># 按照何种方式排序</span></span><br><span class="line">                al: average lock time <span class="comment"># 平均锁定时间</span></span><br><span class="line">                ar: average rows sent <span class="comment"># 平均返回记录数</span></span><br><span class="line">                at: average query time <span class="comment"># 平均查询时间</span></span><br><span class="line">                 c: count  <span class="comment"># 访问次数</span></span><br><span class="line">                 l: lock time  <span class="comment"># 锁定时间</span></span><br><span class="line">                 r: rows sent  <span class="comment"># 返回记录</span></span><br><span class="line">                 t: query time  <span class="comment"># 查询时间 </span></span><br><span class="line">  -r           reverse the sort order (largest last instead of first)</span><br><span class="line">  -t NUM       just show the top n queries  <span class="comment"># 返回前面多少条记录</span></span><br><span class="line">  -a           don<span class="string">&#x27;t abstract all numbers to N and strings to &#x27;</span>S<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  -n NUM       abstract numbers with at least n digits within names</span></span><br><span class="line"><span class="string">  -g PATTERN   grep: only consider stmts that include this string  </span></span><br><span class="line"><span class="string">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span></span><br><span class="line"><span class="string">               default is &#x27;</span>*<span class="string">&#x27;, i.e. match all</span></span><br><span class="line"><span class="string">  -i NAME      name of server instance (if using mysql.server startup script)</span></span><br><span class="line"><span class="string">  -l           don&#x27;</span>t subtract lock time from total time</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g <span class="string">&quot;left join&quot;</span> /var/lib/mysql/slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外建议使用这些命令时结合|和more使用，否则出现爆屏的情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log | more</span><br></pre></td></tr></table></figure>



<h2 id="批量插入数据脚本"><a href="#批量插入数据脚本" class="headerlink" title="批量插入数据脚本"></a>批量插入数据脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* 1.dept表 */</span><br><span class="line">CREATE TABLE `dept` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `deptno` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;部门id&#x27;,</span><br><span class="line">  `dname` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;部门名字&#x27;,</span><br><span class="line">  `loc` varchar(13) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;部门地址&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;部门表&#x27;</span><br><span class="line"></span><br><span class="line">/* 2.emp表 */</span><br><span class="line">CREATE TABLE `emp` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `empno` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;员工编号&#x27;,</span><br><span class="line">  `ename` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;员工名字&#x27;,</span><br><span class="line">  `job` varchar(9) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;职位&#x27;,</span><br><span class="line">  `mgr` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;上级编号&#x27;,</span><br><span class="line">  `hiredata` date NOT NULL COMMENT &#x27;入职时间&#x27;,</span><br><span class="line">  `sal` decimal(7,2) NOT NULL COMMENT &#x27;薪水&#x27;,</span><br><span class="line">  `comm` decimal(7,2) NOT NULL COMMENT &#x27;分红&#x27;,</span><br><span class="line">  `deptno` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;部门id&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;员工表&#x27;</span><br></pre></td></tr></table></figure>

<p>由于开启过慢查询日志，开启了 <code>bin-log</code>，我们就必须为 <code>function</code> 指定一个参数，否则使用函数会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 在mysql中设置 </span><br><span class="line"># log_bin_trust_function_creators 默认是关闭的 需要手动开启</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;log_bin_trust_function_creators&#x27;;</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| Variable_name                   | Value |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| log_bin_trust_function_creators | OFF   |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET GLOBAL log_bin_trust_function_creators=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>上述修改方式 MySQL 重启后会失败，在 <code>my.cnf</code> 配置文件下修改永久有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_bin_trust_function_creators=ON</span><br></pre></td></tr></table></figure>



<h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 1、函数：随机产生字符串</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE chars_str VARCHAR(100) DEFAULT &#x27;abcdefghijklmnopqrstuvwsyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">    DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    SET return_str = CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END $$</span><br><span class="line"></span><br><span class="line"># 2、函数：随机产生部门编号</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION rand_num() RETURNS INT(5)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET i = FLOOR(100 + RAND() * 10);</span><br><span class="line">    RETURN i;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>



<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 1、函数：向dept表批量插入</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO dept(deptno,dname,loc) VALUES((START + i),rand_string(10),rand_string(8));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END $$</span><br><span class="line"></span><br><span class="line"># 2、函数：向emp表批量插入</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO emp(empno,ename,job,mgr,hiredata,sal,comm,deptno) VALUES((START + i),rand_string(6),&#x27;SALESMAN&#x27;,0001,CURDATE(),2000,400,rand_num());</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>



<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 1、调用存储过程向dept表插入10个部门。</span><br><span class="line">DELIMITER ;</span><br><span class="line">CALL insert_dept(100,10);</span><br><span class="line"></span><br><span class="line"># 2、调用存储过程向emp表插入50万条数据。</span><br><span class="line">DELIMITER ;</span><br><span class="line">CALL insert_emp(100001,500000);</span><br></pre></td></tr></table></figure>



<h2 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h2><p><code>Show Profile</code>：MySQL 提供可以用来分析当前会话中<strong>语句执行的资源消耗情况</strong>。可以用于 SQL 的调优的测量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查看Show Profile功能是否开启</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;profiling&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| profiling     | OFF   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 开启 `Show Profile` 功能</span><br><span class="line">mysql&gt; SET profiling=ON;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>运行 SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000;</span><br><span class="line">SELECT * FROM `emp` GROUP BY `id`%20 ORDER BY 5;</span><br></pre></td></tr></table></figure>

<p>查看结果，执行 <code>SHOW PROFILES;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILES;</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                             |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">|        1 | 0.00156100 | SHOW VARIABLES LIKE &#x27;profiling&#x27;                   |</span><br><span class="line">|        2 | 0.56296725 | SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000 |</span><br><span class="line">|        3 | 0.52105825 | SELECT * FROM `emp` GROUP BY `id`%10 LIMIT 150000 |</span><br><span class="line">|        4 | 0.51279775 | SELECT * FROM `emp` GROUP BY `id`%20 ORDER BY 5   |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">4 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>诊断 SQL，<code>SHOW PROFILE cpu,block io FOR QUERY Query_ID;</code>，可以看到<strong>一条SQL中完整的生命周期</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILE cpu,block io FOR QUERY 3;</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">| starting             | 0.000097 | 0.000090 |   0.000002 |            0 |             0 |</span><br><span class="line">| checking permissions | 0.000010 | 0.000009 |   0.000000 |            0 |             0 |</span><br><span class="line">| Opening tables       | 0.000039 | 0.000058 |   0.000000 |            0 |             0 |</span><br><span class="line">| init                 | 0.000046 | 0.000046 |   0.000000 |            0 |             0 |</span><br><span class="line">| System lock          | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| optimizing           | 0.000005 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| statistics           | 0.000023 | 0.000037 |   0.000000 |            0 |             0 |</span><br><span class="line">| preparing            | 0.000014 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| Creating tmp table   | 0.000041 | 0.000053 |   0.000000 |            0 |             0 |</span><br><span class="line">| Sorting result       | 0.000005 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| executing            | 0.000003 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| Sending data         | 0.520620 | 0.516267 |   0.000000 |            0 |             0 |</span><br><span class="line">| Creating sort index  | 0.000060 | 0.000051 |   0.000000 |            0 |             0 |</span><br><span class="line">| end                  | 0.000006 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| query end            | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| removing tmp table   | 0.000006 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| query end            | 0.000004 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| closing tables       | 0.000009 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">| freeing items        | 0.000032 | 0.000064 |   0.000000 |            0 |             0 |</span><br><span class="line">| cleaning up          | 0.000019 | 0.000000 |   0.000000 |            0 |             0 |</span><br><span class="line">+----------------------+----------+----------+------------+--------------+---------------+</span><br><span class="line">20 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><code>Show Profile</code> 查询参数备注：</p>
<ul>
<li><code>ALL</code>：显示所有的开销信息。</li>
<li><code>BLOCK IO</code>：显示块 IO 相关开销（通用）。</li>
<li><code>CONTEXT SWITCHES</code>：上下文切换相关开销。</li>
<li><code>CPU</code>：显示 CPU 相关开销信息（通用）。</li>
<li><code>IPC</code>：显示发送和接收相关开销信息。</li>
<li><code>MEMORY</code>：显示内存相关开销信息。</li>
<li><code>PAGE FAULTS</code>：显示页面错误相关开销信息。</li>
<li><code>SOURCE</code>：显示和 Source_function。</li>
<li><code>SWAPS</code>：显示交换次数相关开销的信息。</li>
</ul>
<p>日常开发需要注意 <code>Show Profile</code> 查询列表的结论：</p>
<ul>
<li><code>converting HEAP to MyISAM</code>：查询结果太大，内存都不够用了，往磁盘上搬了。</li>
<li><code>Creating tmp table</code>：创建临时表（拷贝数据到临时表，用完再删除），非常耗费数据库性能。</li>
<li><code>Copying to tmp table on disk</code>：把内存中的临时表复制到磁盘，危险。</li>
<li><code>locked</code>：死锁。</li>
</ul>
<h2 id="表锁-偏读"><a href="#表锁-偏读" class="headerlink" title="表锁(偏读)"></a>表锁(偏读)</h2><p>表锁偏向 <code>MyISAM</code> 存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<h3 id="锁表的命令"><a href="#锁表的命令" class="headerlink" title="锁表的命令"></a>锁表的命令</h3><ul>
<li><p>查看数据库的表锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1、创建表:ENGINE=MYISAM</span><br><span class="line">CREATE TABLE `mylock`(</span><br><span class="line">`id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">`name` VARCHAR(20)</span><br><span class="line">)ENGINE=MYISAM DEFAULT CHARSET=utf8 COMMENT=&#x27;测试表锁&#x27;;</span><br><span class="line"></span><br><span class="line"># 2、插入数据</span><br><span class="line">INSERT INTO `mylock`(`name`) VALUES(&#x27;ZhangSan&#x27;);</span><br><span class="line">INSERT INTO `mylock`(`name`) VALUES(&#x27;LiSi&#x27;);</span><br><span class="line">INSERT INTO `mylock`(`name`) VALUES(&#x27;WangWu&#x27;);</span><br><span class="line">INSERT INTO `mylock`(`name`) VALUES(&#x27;ZhaoLiu&#x27;);</span><br><span class="line"></span><br><span class="line"># 查看数据库表锁的命令</span><br><span class="line">SHOW OPEN TABLES;</span><br></pre></td></tr></table></figure></li>
<li><p>给 <code>mylock</code> 表上读锁，给 <code>book</code> 表上写锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 给mylock表上读锁，给book表上写锁</span><br><span class="line">LOCK TABLE `mylock` READ, `book` WRITE;</span><br><span class="line"></span><br><span class="line"># 查看当前表的状态</span><br><span class="line">mysql&gt; SHOW OPEN TABLES;</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br><span class="line">| Database           | Table                                                | In_use | Name_locked |</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br><span class="line">| sql_analysis       | book                                                 |      1 |           0 |</span><br><span class="line">| sql_analysis       | mylock                                               |      1 |           0 |</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br></pre></td></tr></table></figure></li>
<li><p>释放表锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 释放给表添加的锁</span><br><span class="line">UNLOCK TABLES;</span><br><span class="line"></span><br><span class="line"># 查看当前表的状态</span><br><span class="line">mysql&gt; SHOW OPEN TABLES;</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br><span class="line">| Database           | Table                                                | In_use | Name_locked |</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br><span class="line">| sql_analysis       | book                                                 |      0 |           0 |</span><br><span class="line">| sql_analysis       | mylock                                               |      0 |           0 |</span><br><span class="line">+--------------------+------------------------------------------------------+--------+-------------+</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="读锁案例"><a href="#读锁案例" class="headerlink" title="读锁案例"></a>读锁案例</h3><p>打开两个会话，<code>SESSION1</code> 为 <code>mylock</code> 表添加读锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 为mylock表添加读锁</span><br><span class="line">LOCK TABLE `mylock` READ;</span><br></pre></td></tr></table></figure>

<p>此时：</p>
<ul>
<li><strong>SESSION1 可以读自己锁的表，不可以修改自己锁的表，不可以读其他的表</strong>。</li>
<li><strong>SESSION2 可以读别人锁的表，修改别人锁的表会被阻塞，可以读其他的表</strong>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了读锁，可以读mylock表！</span><br><span class="line">mysql&gt; SELECT * FROM `mylock`;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | ZhangSan |</span><br><span class="line">|  2 | LiSi     |</span><br><span class="line">|  3 | WangWu   |</span><br><span class="line">|  4 | ZhaoLiu  |</span><br><span class="line">+----+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了读锁，不可以修改mylock表！</span><br><span class="line">mysql&gt; UPDATE `mylock` SET `name` = &#x27;abc&#x27; WHERE `id` = 1;</span><br><span class="line">ERROR 1099 (HY000): Table &#x27;mylock&#x27; was locked with a READ lock and can&#x27;t be updated</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了读锁，不可以读其他的表！</span><br><span class="line">mysql&gt; SELECT * FROM `book`;</span><br><span class="line">ERROR 1100 (HY000): Table &#x27;book&#x27; was not locked with LOCK TABLES</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># SESSION2</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了读锁，SESSION2可以读mylock表！</span><br><span class="line">mysql&gt; SELECT * FROM `mylock`;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | ZhangSan |</span><br><span class="line">|  2 | LiSi     |</span><br><span class="line">|  3 | WangWu   |</span><br><span class="line">|  4 | ZhaoLiu  |</span><br><span class="line">+----+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了读锁，SESSION2修改mylock表会被阻塞，需要等待SESSION1释放mylock表！</span><br><span class="line">mysql&gt; UPDATE `mylock` SET `name` = &#x27;abc&#x27; WHERE `id` = 1;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了读锁，SESSION2可以读其他表！</span><br><span class="line">mysql&gt; SELECT * FROM `book`;</span><br><span class="line">+--------+------+</span><br><span class="line">| bookid | card |</span><br><span class="line">+--------+------+</span><br><span class="line">|      1 |    1 |</span><br><span class="line">|      7 |    4 |</span><br><span class="line">|      8 |    4 |</span><br><span class="line">|      9 |    5 |</span><br><span class="line">|      5 |    6 |</span><br><span class="line">|     17 |    6 |</span><br><span class="line">|     15 |    8 |</span><br><span class="line">+--------+------+</span><br><span class="line">24 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="写锁案例"><a href="#写锁案例" class="headerlink" title="写锁案例"></a>写锁案例</h3><p>打开两个会话，<code>SESSION1</code> 为 <code>mylock</code> 表添加写锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 为mylock表添加写锁</span><br><span class="line">LOCK TABLE `mylock` WRITE;</span><br></pre></td></tr></table></figure>

<p>此时：</p>
<ul>
<li><strong>SESSION1 可以读自己锁的表，可以修改自己锁的表，不可以读其他的表</strong>。</li>
<li><strong>SESSION2 读别人锁的表会阻塞，修改别人锁的表会阻塞，可以读其他表</strong>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了写锁，可以读mylock的表！</span><br><span class="line">mysql&gt; SELECT * FROM `mylock`;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | ZhangSan |</span><br><span class="line">|  2 | LiSi     |</span><br><span class="line">|  3 | WangWu   |</span><br><span class="line">|  4 | ZhaoLiu  |</span><br><span class="line">+----+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了写锁，可以修改mylock表!</span><br><span class="line">mysql&gt; UPDATE `mylock` SET `name` = &#x27;abc&#x27; WHERE `id` = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了写锁，不能读其他表!</span><br><span class="line">mysql&gt; SELECT * FROM `book`;</span><br><span class="line">ERROR 1100 (HY000): Table &#x27;book&#x27; was not locked with LOCK TABLES</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># SESSION2</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了写锁，SESSION2读mylock表会阻塞，等待SESSION1释放！</span><br><span class="line">mysql&gt; SELECT * FROM `mylock`;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了写锁，SESSION2修改mylock表会阻塞，等待SESSION1释放！</span><br><span class="line">mysql&gt; UPDATE `mylock` SET `name` = &#x27;abc&#x27; WHERE `id` = 1;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line"></span><br><span class="line"># SESSION1为mylock表加了写锁，SESSION2可以读其他表！</span><br><span class="line">mysql&gt; SELECT * FROM `book`;</span><br><span class="line">+--------+------+</span><br><span class="line">| bookid | card |</span><br><span class="line">+--------+------+</span><br><span class="line">|      1 |    1 |</span><br><span class="line">|      7 |    4 |</span><br><span class="line">|      8 |    4 |</span><br><span class="line">|      9 |    5 |</span><br><span class="line">|      5 |    6 |</span><br><span class="line">|     17 |    6 |</span><br><span class="line">|     15 |    8 |</span><br><span class="line">+--------+------+</span><br><span class="line">24 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h3><p><strong><code>MyISAM</code> 引擎在执行查询语句 <code>SELECT</code> 之前，会自动给涉及到的所有表加读锁，在执行增删改之前，会自动给涉及的表加写锁。</strong></p>
<p>MySQL 的表级锁有两种模式：</p>
<ul>
<li>表共享读锁（Table Read Lock）。</li>
<li>表独占写锁（Table Write Lock）。</li>
</ul>
<p>对 <code>MyISAM</code> 表进行操作，会有以下情况：</p>
<ul>
<li>对 <code>MyISAM</code> 表的读操作（加读锁），不会阻塞其他线程对同一表的读操作，但是会阻塞其他线程对同一表的写操作。只有当读锁释放之后，才会执行其他线程的写操作。</li>
<li>对 <code>MyISAM</code> 表的写操作（加写锁），会阻塞其他线程对同一表的读和写操作，只有当写锁释放之后，才会执行其他线程的读写操作。</li>
</ul>
<blockquote>
<p>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。</p>
</blockquote>
<h3 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;table%&#x27;;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Table_locks_immediate      | 173   |</span><br><span class="line">| Table_locks_waited         | 0     |</span><br><span class="line">| Table_open_cache_hits      | 5     |</span><br><span class="line">| Table_open_cache_misses    | 8     |</span><br><span class="line">| Table_open_cache_overflows | 0     |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>Table_locks_immediate</code> 和 <code>Table_locks_waited</code> 状态变量来分析系统上的表锁定。</p>
<ul>
<li><code>Table_locks_immediate</code>：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加 1。</li>
<li><code>Table_locks_waited</code>：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加 1），此值高则说明存在较严重的表级锁争用情况。</li>
</ul>
<p>此外，<code>MyISAM</code> 的读写锁调度是写优先，这也是 <code>MyISAM</code> 不适合作为主表的引擎。因为写锁后，其他线程不能进行任何操作，大量的写操作会使查询很难得到锁，从而造成永远阻塞。</p>
<h2 id="行锁-偏写"><a href="#行锁-偏写" class="headerlink" title="行锁 (偏写)"></a>行锁 (偏写)</h2><p>偏向 <code>InnoDB</code> 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p>
<blockquote>
<p><code>InnoDB</code> 存储引擎和 <code>MyISAM</code> 存储引擎最大不同有两点：一是支持事务，二是采用行锁。</p>
</blockquote>
<h3 id="行锁案例"><a href="#行锁案例" class="headerlink" title="行锁案例"></a>行锁案例</h3><p>打开 <code>SESSION1</code> 和 <code>SESSION2</code> 两个会话，都开启手动提交。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 建表语句：ENGINE=INNODB</span><br><span class="line">CREATE TABLE `test_innodb_lock`(</span><br><span class="line">`a` INT,</span><br><span class="line">`b` VARCHAR(16)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT=&#x27;测试行锁&#x27;; </span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">INSERT INTO `test_innodb_lock`(`a`, `b`) VALUES(1, &#x27;b2&#x27;);</span><br><span class="line">INSERT INTO `test_innodb_lock`(`a`, `b`) VALUES(2, &#x27;3&#x27;);</span><br><span class="line">INSERT INTO `test_innodb_lock`(`a`, `b`) VALUES(3, &#x27;4000&#x27;);</span><br><span class="line">INSERT INTO `test_innodb_lock`(`a`, `b`) VALUES(4, &#x27;5000&#x27;);</span><br><span class="line">INSERT INTO `test_innodb_lock`(`a`, `b`) VALUES(5, &#x27;6000&#x27;);</span><br><span class="line">INSERT INTO `test_innodb_lock`(`a`, `b`) VALUES(6, &#x27;7000&#x27;);</span><br><span class="line">INSERT INTO `test_innodb_lock`(`a`, `b`) VALUES(7, &#x27;8000&#x27;);</span><br><span class="line">INSERT INTO `test_innodb_lock`(`a`, `b`) VALUES(8, &#x27;9000&#x27;);</span><br><span class="line"></span><br><span class="line"># 创建索引</span><br><span class="line">CREATE INDEX idx_test_a ON `test_innodb_lock`(a);</span><br><span class="line">CREATE INDEX idx_test_b ON `test_innodb_lock`(b);</span><br><span class="line"></span><br><span class="line"># 开启MySQL数据库的手动提交</span><br><span class="line">mysql&gt; SET autocommit=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1 </span><br><span class="line"></span><br><span class="line"># SESSION1对test_innodb_lock表做写操作，但是没有commit。</span><br><span class="line"># 执行修改SQL之后，查询一下test_innodb_lock表，发现数据被修改了。</span><br><span class="line">mysql&gt; UPDATE `test_innodb_lock` SET `b` = &#x27;88&#x27; WHERE `a` = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM `test_innodb_lock`;</span><br><span class="line">+------+------+</span><br><span class="line">| a    | b    |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | 88   |</span><br><span class="line">|    2 | 3    |</span><br><span class="line">|    3 | 4000 |</span><br><span class="line">|    4 | 5000 |</span><br><span class="line">|    5 | 6000 |</span><br><span class="line">|    6 | 7000 |</span><br><span class="line">|    7 | 8000 |</span><br><span class="line">|    8 | 9000 |</span><br><span class="line">+------+------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># SESSION2 </span><br><span class="line"></span><br><span class="line"># SESSION2这时候来查询test_innodb_lock表。</span><br><span class="line"># 发现SESSION2是读不到SESSION1未提交的数据的。</span><br><span class="line">mysql&gt; SELECT * FROM `test_innodb_lock`;</span><br><span class="line">+------+------+</span><br><span class="line">| a    | b    |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | b2   |</span><br><span class="line">|    2 | 3    |</span><br><span class="line">|    3 | 4000 |</span><br><span class="line">|    4 | 5000 |</span><br><span class="line">|    5 | 6000 |</span><br><span class="line">|    6 | 7000 |</span><br><span class="line">|    7 | 8000 |</span><br><span class="line">|    8 | 9000 |</span><br><span class="line">+------+------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>行锁两个 SESSION 同时对一条记录进行写操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1 对test_innodb_lock表的`a`=1这一行进行写操作，但是没有commit</span><br><span class="line">mysql&gt; UPDATE `test_innodb_lock` SET `b` = &#x27;99&#x27; WHERE `a` = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line"># SESSION2 也对test_innodb_lock表的`a`=1这一行进行写操作，但是发现阻塞了！</span><br><span class="line"># 等SESSION1执行commit语句之后，SESSION2的SQL就会执行了</span><br><span class="line">mysql&gt; UPDATE `test_innodb_lock` SET `b` = &#x27;asdasd&#x27; WHERE `a` = 1;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>

<p>行锁两个 SESSION 同时对不同记录进行写操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1 对test_innodb_lock表的`a`=6这一行进行写操作，但是没有commit</span><br><span class="line">mysql&gt; UPDATE `test_innodb_lock` SET `b` = &#x27;8976&#x27; WHERE `a` = 6;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line"># SESSION2 対test_innodb_lock表的`a`=4这一行进行写操作，没有阻塞！</span><br><span class="line"># SESSION1和SESSION2同时对不同的行进行写操作互不影响</span><br><span class="line">mysql&gt; UPDATE `test_innodb_lock` SET `b` = &#x27;Ringo&#x27; WHERE `a` = 4;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>



<h3 id="索引失效导致行锁变表锁"><a href="#索引失效导致行锁变表锁" class="headerlink" title="索引失效导致行锁变表锁"></a>索引失效导致行锁变表锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># SESSION1执行SQL语句，没有执行commit。</span><br><span class="line"># 由于`b`字段是字符串，但是没有加单引号导致索引失效</span><br><span class="line">mysql&gt; UPDATE `test_innodb_lock` SET `a` = 888 WHERE `b` = 8000;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 1</span><br><span class="line"></span><br><span class="line"># SESSION2和SESSION1操作的并不是同一行，但是也被阻塞了？</span><br><span class="line"># 由于SESSION1执行的SQL索引失效，导致行锁升级为表锁。</span><br><span class="line">mysql&gt; UPDATE `test_innodb_lock` SET `b` = &#x27;1314&#x27; WHERE `a` = 1;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>



<h3 id="间隙锁的危害"><a href="#间隙锁的危害" class="headerlink" title="间隙锁的危害"></a>间隙锁的危害</h3><p>当我们<strong>用范围条件</strong>而不是相等条件检索数据，并请求共享或者排他锁时，<code>InnoDB</code> 会给符合条件的已有数据记录的索引项加锁，对于键值在条件范文内但并不存在的记录，叫做 <code>间隙 (GAP)</code>。<code>InnoDB</code> 也会对这个 “间隙” 加锁，这种锁的机制就是所谓的 <code>间隙锁</code>。</p>
<p>my_table 有三条记录：(2,99),(3,99),(5,99)。现在 session1 执行下面的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># session1</span><br><span class="line">update my_table set b=1 where a&gt;1 and a&lt;6;</span><br></pre></td></tr></table></figure>

<p>此时的 where 范围是 (1,6)，其中 4 在数据表中并不存在。这里的 4 就称为 <code>间隙</code>。</p>
<p>MySQL 在执行上面语句上锁的时候，本着<strong>宁可错杀不可放过</strong>的原则，就算 4 不存在，一样也会把 4 锁定。如果在上锁期间，session2 执行下面语句，此时<strong>因为 4 已经被锁定，此语句会被阻塞</strong>，直到 session1 将锁释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># session2</span><br><span class="line">insert into my_table (a,b) values(4,9999);</span><br></pre></td></tr></table></figure>

<p><code>Query</code> 执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值不存在。</p>
<p>间隙锁有一个比较致的缺点，就是 <strong>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。</strong> 在某些场景下这可能会対性能造成很大的危害。</p>
<h3 id="案例结论-1"><a href="#案例结论-1" class="headerlink" title="案例结论"></a>案例结论</h3><p><code>InnoDB</code> 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于 <code>MyISAM</code> 的表级锁定的。当系统并发量较高的时候，<code>InnoDB</code> 的整体性能和 <code>MyISAM</code> 相比就会有比较明显的优势了。</p>
<p>但是，<code>InnoDB</code> 的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让 <code>InnoDB</code> 的整体性能表现不仅不能比 <code>MyISAM</code> 高，甚至可能会更差。</p>
<h3 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE &#x27;innodb_row_lock%&#x27;;</span><br><span class="line">+-------------------------------+--------+</span><br><span class="line">| Variable_name                 | Value  |</span><br><span class="line">+-------------------------------+--------+</span><br><span class="line">| Innodb_row_lock_current_waits | 0      |</span><br><span class="line">| Innodb_row_lock_time          | 124150 |</span><br><span class="line">| Innodb_row_lock_time_avg      | 31037  |</span><br><span class="line">| Innodb_row_lock_time_max      | 51004  |</span><br><span class="line">| Innodb_row_lock_waits         | 4      |</span><br><span class="line">+-------------------------------+--------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>対各个状态量的说明如下：</p>
<ul>
<li><code>Innodb_row_lock_current_waits</code>：当前正在等待锁定的数量。</li>
<li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度（重要）。</li>
<li><code>Innodb_row_lock_time_avg</code>：每次等待所花的平均时间（重要）。</li>
<li><code>Innodb_row_lock_time_max</code>：从系统启动到现在等待最长的一次所花的时间。</li>
<li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数（重要）。</li>
</ul>
<p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化策略。</p>
<h1 id="refenence"><a href="#refenence" class="headerlink" title="refenence"></a>refenence</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KW411u7vy">尚硅谷MySQL数据库高级，mysql优化，数据库优化</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>