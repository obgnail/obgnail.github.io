<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;看懂UML类图&quot;&gt;&lt;a href=&quot;#看懂UML类图&quot; class=&quot;headerlink&quot; title=&quot;看懂UML类图&quot;&gt;&lt;/a&gt;看懂UML类图&lt;/h1&gt;&lt;p&gt;目标："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>看懂UML中的类图 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Unified-Modeling-Language/" rel="tag">Unified Modeling Language</a></div><div class="post-time">2022-01-26</div></div></div><div class="container post-header"><h1>看懂UML中的类图</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%8B%E6%87%82UML%E7%B1%BB%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">看懂UML类图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UML%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.</span> <span class="toc-text">UML类图表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8UML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E8%A1%A8%E7%A4%BA%E5%85%B7%E4%BD%93%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">在UML类图中表示具体类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8UML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E8%A1%A8%E7%A4%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">在UML类图中表示抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8UML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E8%A1%A8%E7%A4%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.3.</span> <span class="toc-text">在UML类图中表示接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8UML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E8%A1%A8%E7%A4%BA%E5%8C%85"><span class="toc-number">1.1.4.</span> <span class="toc-text">在UML类图中表示包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%BC%80%E5%A7%8B"><span class="toc-number">1.2.</span> <span class="toc-text">从一个示例开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB-generalization"><span class="toc-number">1.3.1.</span> <span class="toc-text">泛化关系(generalization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB-realize"><span class="toc-number">1.3.2.</span> <span class="toc-text">实现关系(realize)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB-aggregation"><span class="toc-number">1.3.3.</span> <span class="toc-text">聚合关系(aggregation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB-composition"><span class="toc-number">1.3.4.</span> <span class="toc-text">组合关系(composition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB-association"><span class="toc-number">1.3.5.</span> <span class="toc-text">关联关系(association)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB-dependency"><span class="toc-number">1.3.6.</span> <span class="toc-text">依赖关系(dependency)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number">2.</span> <span class="toc-text">reference</span></a></li></ol></details></div><div class="container post-content"><h1 id="看懂UML类图"><a href="#看懂UML类图" class="headerlink" title="看懂UML类图"></a>看懂UML类图</h1><p>目标：</p>
<ul>
<li>能看懂类图中各个类之间的线条、箭头代表什么意思，足够应对日常的工作和交流； </li>
<li>能将类图所表达的含义和最终的代码对应起来； </li>
</ul>
<h2 id="UML类图表示"><a href="#UML类图表示" class="headerlink" title="UML类图表示"></a>UML类图表示</h2><h3 id="在UML类图中表示具体类"><a href="#在UML类图中表示具体类" class="headerlink" title="在UML类图中表示具体类"></a>在UML类图中表示具体类</h3><p>具体类在类图中用矩形框表示，矩形框分为三层：</p>
<ul>
<li>第一层是<code>类名字</code>。</li>
<li>第二层是<code>类的成员变量</code>；</li>
<li>第三层是<code>类的方法</code>。</li>
</ul>
<p>成员变量以及方法前的访问修饰符用符号来表示：</p>
<ul>
<li>“+”表示 <code>public</code>；</li>
<li>“-”表示 <code>private</code>；</li>
<li>“#”表示 <code>protected</code>；</li>
<li>不带符号表示 <code>default</code>。</li>
</ul>
<p><img src="/images/v2-71b22158f5b09dffa57a123d72ec4653_1440w.jpg" alt="img"></p>
<h3 id="在UML类图中表示抽象类"><a href="#在UML类图中表示抽象类" class="headerlink" title="在UML类图中表示抽象类"></a>在UML类图中表示抽象类</h3><p>抽象类在UML类图中同样用矩形框表示，但是抽象类的类名以及抽象方法的名字都用斜体字表示，如图所示。</p>
<p><img src="/images/v2-5c69cd9ff703377f7bbf37cee8199451_1440w.jpg" alt="img"></p>
<h3 id="在UML类图中表示接口"><a href="#在UML类图中表示接口" class="headerlink" title="在UML类图中表示接口"></a>在UML类图中表示接口</h3><p>接口在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 <code>&lt;&lt;interface&gt;&gt;</code>表示，下面是接口的名字，第二层是方法，如图所示。</p>
<p>此外，接口还有另一种表示法，俗称棒棒糖表示法，就是类上面的一根棒棒糖（圆圈+实线）。圆圈旁为接口名称，接口方法在实现类中出现。</p>
<p><img src="/images/v2-e39bdff5514c38e7797848372ac51365_1440w.jpg" alt="img"></p>
<h3 id="在UML类图中表示包"><a href="#在UML类图中表示包" class="headerlink" title="在UML类图中表示包"></a>在UML类图中表示包</h3><p>类和接口一般都出现在包中，UML类图中包的表示形式如图所示。</p>
<p><img src="/images/v2-b421c9c15219feba7dd9cf7681070682_1440w.jpg" alt="img"></p>
<h2 id="从一个示例开始"><a href="#从一个示例开始" class="headerlink" title="从一个示例开始"></a>从一个示例开始</h2><p>请看以下这个类图，类之间的关系是我们需要关注的：</p>
<p><img src="/images/uml_class_struct.jpg" alt="_images/uml_class_struct.jpg"></p>
<ul>
<li>车的类图结构为<code>&lt;&lt;abstract&gt;&gt;</code>，表示车是一个抽象类；</li>
<li>它有两个继承类：小汽车和自行车；它们之间的关系为<code>实现关系</code>，使用带空心箭头的虚线表示；</li>
<li>小汽车为与SUV之间也是继承关系，它们之间的关系为<code>泛化关系</code>，使用带空心箭头的实线表示；</li>
<li>小汽车与发动机之间是<code>组合关系</code>，使用带实心箭头的实线表示；</li>
<li>学生与班级之间是<code>聚合关系</code>，使用带空心箭头的实线表示；</li>
<li>学生与身份证之间为<code>关联关系</code>，使用一根实线表示；</li>
<li>学生上学需要用到自行车，与自行车是一种<code>依赖关系</code>，使用带箭头的虚线表示；</li>
</ul>
<p>下面我们将介绍这六种关系；</p>
<h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p><img src="/images/v2-e6a48521352fff8270e753ea4a79d9fb_1440w.jpg" alt="img"></p>
<h3 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h3><p>类的继承结构表现在 UML 中为：<code>泛化(generalize)</code>与<code>实现(realize)</code>：</p>
<p>继承关系为  is-a 的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p>
<p>eg：自行车是车、猫是动物</p>
<p>泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）；</p>
<p><img src="/images/uml_generalization.jpg" alt="_images/uml_generalization.jpg"></p>
<p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p>
<p><img src="/images/uml_generalize.jpg" alt="_images/uml_generalize.jpg"></p>
<p>注：最终代码中，泛化关系表现为继承非抽象类；</p>
<blockquote>
<p>泛化关系（Generalization）是指对象与对象之间的继承关系。如果对象A和对象B之间的“is a”关系成立，那么二者之间就存在继承关系，对象B是父对象，对象A是子对象。例如，一个年薪制员工“is a”员工，很显然年薪制员工Salary对象和员工Employee对象之间存在继承关系，Employee对象是父对象，Salary对象是子对象。</p>
<p>在UML类图中，泛化关系用空心三角和实线组成的箭头表示，从子类指向父类，如图所示。在Java代码中，对象之间的泛化关系可以直接翻译为关键字 <code>extends</code>。</p>
<p><img src="/images/v2-04064db11797cf36229d67407fea1b83_1440w.jpg" alt="img"></p>
</blockquote>
<h3 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h3><p>实现关系用一条带空心箭头的虚线表示；</p>
<p>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）</p>
<p><img src="/images/uml_realize.jpg" alt="_images/uml_realize.jpg"></p>
<p>注：最终代码中，实现关系表现为继承抽象类；</p>
<blockquote>
<p>实现关系是指接口及其实现类之间的关系。在UML类图中，实现关系用空心三角和虚线组成的箭头来表示，从实现类指向接口，如图所示。在Java代码中，实现关系可以直接翻译为关键字 <code>implements</code>。</p>
<p><img src="/images/v2-616c153ec74d496a811ac50c83c3653c_1440w.jpg" alt="img"></p>
</blockquote>
<h3 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p>
<p><img src="/images/uml_aggregation.jpg" alt="_images/uml_aggregation.jpg"></p>
<p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p>
<p>与组合关系不同的是，<strong>聚合的整体和部分不是强依赖的，即使整体不存在了，部分仍然存在</strong>；例如， 部门撤销了，人员不会消失，他们依然存在；</p>
<blockquote>
<p>聚合（Aggregation）是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 “has a” 的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。</p>
<p>在UML图中，聚合关系用空心菱形加实线箭头表示，空心菱形在整体一方，箭头指向部分一方，如图所示。</p>
<p><img src="/images/v2-82cb160ed1566d1d04ea320575b54d5f_1440w.jpg" alt="img"></p>
</blockquote>
<h3 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p>
<p><img src="/images/uml_composition.jpg" alt="_images/uml_composition.jpg"></p>
<p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p>
<p>但<strong>组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了</strong>；例如， 公司不存在了，部门也将不存在了；</p>
<blockquote>
<p>组合（Composition）也是关联关系的一种特例，它同样体现整体与部分间的包含关系，即 “contains a” 的关系。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。如果<code>A</code>组合<code>B</code>，则<code>A</code>需要知道<code>B</code>的生存周期，即可能<code>A</code>负责生成或者释放<code>B</code>，或者<code>A</code>通过某种途径知道<code>B</code>的生成和释放。</p>
<p>例如，人包含头、躯干、四肢，它们的生命周期一致。当人出生时，头、躯干、四肢同时诞生。当人死亡时，作为人体组成部分的头、躯干、四肢同时死亡。</p>
<p>在UML图中，组合关系用实心菱形加实线箭头表示，实心菱形在整体一方，箭头指向部分一方，如图12所示。</p>
<p><img src="/images/v2-e651244eeca9c0881cbdd2add429e850_1440w.jpg" alt="img"></p>
<p>在Java代码形式上，聚合和组合关系中的部分对象是整体对象的一个成员变量。</p>
<ul>
<li>但是，<strong>在实际应用开发时，两个对象之间的关系到底是聚合还是组合，有时候很难区别</strong>。在Java中，仅从类代码本身是区分不了聚合和组合的。</li>
<li><strong>如果一定要区分，那么如果在删除整体对象的时候，必须删掉部分对象，那么就是组合关系，否则可能就是聚合关系</strong>。</li>
<li>从业务角度上来看，如果作为整体的对象必须要部分对象的参与，才能完成自己的职责，那么二者之间就是组合关系，否则就是聚合关系。</li>
</ul>
<p>例如，汽车与轮胎，汽车作为整体，轮胎作为部分。</p>
<ul>
<li>如果用在二手车销售业务环境下，二者之间就是聚合关系。因为轮胎作为汽车的一个组成部分，它和汽车可以分别生产以后装配起来使用，但汽车可以换新轮胎，轮胎也可以卸下来给其它汽车使用。</li>
<li>如果用在驾驶系统业务环境上，汽车如果没有轮胎，就无法完成行驶任务，二者之间就是一个组合关系。</li>
</ul>
<p><strong>比如网上书店业务中的订单和订单项之间的关系，如果订单没有订单项，也就无法完成订单的业务，所以二者之间是组合关系</strong>。而购物车和商品之间的关系，因为商品的生命周期并不被购物车控制，商品可以被多个购物车共享，因此，二者之间是聚合关系。</p>
</blockquote>
<h3 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h3><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p>
<p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p>
<p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p>
<p><img src="/images/uml_association.jpg" alt="_images/uml_association.jpg"></p>
<p>注：在最终代码中，关联对象通常是以成员变量的形式实现的；</p>
<blockquote>
<p>关联关系（Association）是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。<strong>在Java中，关联关系的代码表现形式为一个对象含有另一个对象的引用。</strong>也就是说，如果一个对象的类代码中，包含有另一个对象的引用，那么这两个对象之间就是关联关系。</p>
<p>关联关系有单向关联和双向关联。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。</p>
<p>在UML图中，双向关联关系用带双箭头的实线或者无箭头的实线双线表示。单向关联用一个带箭头的实线表示，箭头指向被关联的对象，如图所示。这就是导航性（Navigatity）。</p>
<p><img src="/images/v2-3f331f3dc075abb4215413014688638f_1440w.jpg" alt="img"></p>
<p>一个对象可以持有其它对象的数组或者集合。在UML中，通过放置多重性（multipicity）表达式在关联线的末端来表示。多重性表达式可以是一个数字、一段范围或者是它们的组合。多重性允许的表达式示例如下：</p>
<ul>
<li>数字：精确的数量</li>
<li><code>*</code>或者<code>0..*</code>：表示0到多个</li>
<li><code>0..1</code>：表示0或者1个，在Java中经常用一个空引用来实现</li>
<li><code>1..*</code>：表示1到多个</li>
</ul>
<p>关联关系又分为依赖关联、聚合关联和组合关联三种类型。</p>
</blockquote>
<h3 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h3><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p>
<p><img src="/images/uml_dependency.jpg" alt="_images/uml_dependency.jpg"></p>
<p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p>
<p>显然，依赖也有方向，<strong>双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生</strong>；</p>
<p>注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>
<blockquote>
<p>依赖（Dependency）关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。如果对象A依赖于对象B，则 A “use a” B。比如驾驶员和汽车的关系，驾驶员使用汽车，二者之间就是依赖关系。</p>
<p>在UML类图中，依赖关系用一个带虚线的箭头表示，由使用方指向被使用方，表示使用方对象持有被使用方对象的引用，如图10所示。</p>
<p><img src="/images/v2-431e044bbf26778a20dd788968e22aac_1440w.jpg" alt="img"></p>
<p>依赖关系在Java中的具体代码表现形式为<strong>B为A的构造器</strong>或<strong>方法中的局部变量</strong>、<strong>方法或构造器的参数</strong>、<strong>方法的返回值</strong>，或者<strong>A调用B的静态方法</strong>。</p>
<p>下面我们用代码清单1和代码清单2所示的Java代码来演示对象和对象之间的依赖关系。</p>
<p>代码清单1所示的<code>B</code>类定义了一个成员变量 <code>field1</code>，一个普通方法 <code>method1()</code> 和一个静态方法 <code>method2()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单1 B.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String field1;   <span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.println(<span class="string">&quot;在类B的方法1中&quot;</span>);</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;  <span class="comment">//静态方法</span></span><br><span class="line">      System.out.println(<span class="string">&quot;在类B的静态方法2中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码清单2所示的<code>A</code>类依赖于<code>B</code>类，在<code>A</code>类中定义了四个方法，分别演示四种依赖形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码清单2 A.java</span></span><br><span class="line"><span class="comment">  A依赖于B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//A依赖于B的第一种表现形式：B为A的局部变量</span></span><br><span class="line">      B b = <span class="keyword">new</span> B();</span><br><span class="line">      b.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//A依赖于B的第二种表现形式： 调用B的静态方法</span></span><br><span class="line">      B.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(B b)</span>  </span>&#123;</span><br><span class="line">      <span class="comment">//A依赖于B的第三种表现形式：B作为A的方法参数</span></span><br><span class="line">      String s = b.field1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//A依赖于B的第四种表现形式：B作为A的方法的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109655171">30分钟学会UML类图</a></li>
<li><a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">看懂UML类图和时序图</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>