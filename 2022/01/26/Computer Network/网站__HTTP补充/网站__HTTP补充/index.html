<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;请求报文&quot;&gt;&lt;a href=&quot;#请求报文&quot; class=&quot;headerlink&quot; title=&quot;请求报文&quot;&gt;&lt;/a&gt;请求报文&lt;/h2&gt;&lt;p&gt;HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样："><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>HTTP补充 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Computer-Network/" rel="tag">Computer Network</a></div><div class="post-time">2022-01-26</div></div></div><div class="container post-header"><h1>HTTP补充</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">请求报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POST-%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">POST 提交数据的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#application-x-www-form-urlencoded"><span class="toc-number">2.1.</span> <span class="toc-text">application&#x2F;x-www-form-urlencoded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multipart-form-data"><span class="toc-number">2.2.</span> <span class="toc-text">multipart&#x2F;form-data</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-multipart-form-data"><span class="toc-number">3.</span> <span class="toc-text">深入解析 multipart&#x2F;form-data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA-HTML-%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84-enctype-%E6%9C%89%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">一个 HTML 表单中的 enctype 有三种类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#application-x-www-urlencoded"><span class="toc-number">3.2.</span> <span class="toc-text">application&#x2F;x-www-urlencoded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multipart-form-data-1"><span class="toc-number">3.3.</span> <span class="toc-text">multipart&#x2F;form-data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.4.</span> <span class="toc-text">实验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">4.</span> <span class="toc-text">响应报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6GET"><span class="toc-number">5.</span> <span class="toc-text">条件GET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.</span> <span class="toc-text">持久连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transfer-Encoding"><span class="toc-number">7.</span> <span class="toc-text">Transfer-Encoding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-Pipelining%EF%BC%88HTTP-%E7%AE%A1%E7%BA%BF%E5%8C%96%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">HTTP Pipelining（HTTP 管线化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA"><span class="toc-number">9.</span> <span class="toc-text">会话跟踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB"><span class="toc-number">10.</span> <span class="toc-text">跨站攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF"><span class="toc-number">10.1.</span> <span class="toc-text">CSRF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS"><span class="toc-number">10.2.</span> <span class="toc-text">XSS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number"></span> <span class="toc-text">reference</span></a></details></div><div class="container post-content"><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>GET 用于信息获取，而且应该是<strong>安全</strong>的和<strong>幂等</strong>的。换句话说，GET 请求一般不应产生副作用。</li>
<li>POST 表示可能修改变服务器上的资源的请求。</li>
</ol>
<p><img src="/images/HTTPMsgStructure2.png" alt="Requests and responses share a common structure in HTTP"></p>
<h2 id="POST-提交数据的方式"><a href="#POST-提交数据的方式" class="headerlink" title="POST 提交数据的方式"></a>POST 提交数据的方式</h2><ul>
<li>HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是<strong>协议中没有规定数据使用哪种编码方式或者数据格式</strong>。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</li>
<li>服务端通常是根据headers中的 <strong>Content-Type</strong> 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。</li>
</ul>
<h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a><code>application/x-www-form-urlencoded</code></h3><p>这是最常见的 POST 数据提交方式。浏览器的原生 <code>&lt;form&gt;</code> 表单，如果不设置 enctype 属性，那么最终就会以 <code>application/x-www-form-urlencoded</code> 方式提交数据。可以看到 body 当中的内容和 GET 请求是完全相同的。</p>
<h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a><code>multipart/form-data</code></h3><p>这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <code>&lt;form&gt;</code> 表单的 enctype 等于 <code>multipart/form-data</code>。直接来看一个请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">title</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure>

<ol>
<li>这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。</li>
<li>然后 <code>Content-Type</code> 里指明了数据是以 <code>multipart/form-data</code> 来编码，本次请求的 boundary 是什么内容。</li>
<li>消息主体里按照字段个数又分为多个结构类似的部分，<strong>每部分都是以 –boundary 开始</strong>，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。</li>
</ol>
<p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p>
<p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <code>&lt;form&gt;</code> 表单也只支持这两种方式（通过 <code>&lt;form&gt;</code> 元素的 enctype 属性指定，默认为 <code>application/x-www-form-urlencoded</code>。其实 enctype 还支持 text/plain，不过用得非常少）。</p>
<p>随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 <code>application/json</code>，<code>text/xml</code>，乃至 <code>application/x-protobuf</code> 这种二进制格式，只要服务器可以根据 <code>Content-Type</code> 和 <code>Content-Encoding</code> 正确地解析出请求，都是没有问题的。</p>
<h2 id="深入解析-multipart-form-data"><a href="#深入解析-multipart-form-data" class="headerlink" title="深入解析 multipart/form-data"></a>深入解析 multipart/form-data</h2><h3 id="一个-HTML-表单中的-enctype-有三种类型"><a href="#一个-HTML-表单中的-enctype-有三种类型" class="headerlink" title="一个 HTML 表单中的 enctype 有三种类型"></a>一个 HTML 表单中的 enctype 有三种类型</h3><ul>
<li>application/x-www-urlencoded</li>
<li>multipart/form-data</li>
<li>text-plain</li>
</ul>
<p>默认情况下是 <code>application/x-www-urlencoded</code>，当表单使用 POST 请求时，数据会被以 x-www-urlencoded 方式编码到 Body 中来传送，而如果 GET 请求，则是附在 url 链接后面来发送。</p>
<p><strong>GET 请求只支持 ASCII 字符集，因此，如果我们要发送更大字符集的内容，我们应使用 POST 请求</strong>。</p>
<blockquote>
<ul>
<li><code>&quot;application/x-www-form-urlencoded&quot;</code> 编码的格式是 ASCII，如果 form 中传递的是二进制等 Media Type 类型的数据，那么 <code>application/x-www-form-urlencoded</code> 会把其编码转换成 ASCII 类型。</li>
<li>对于 1 个 non-ASCII 字符，它需要用 3 个 ASCII 字符来表示，如果要发送大量的二进制数据（non-ASCII），<code>&quot;application/x-www-form-urlencoded&quot;</code> 显然是低效的。因此，这种情况下，应该使用 <code>&quot;multipart/form-data&quot;</code> 格式。</li>
</ul>
</blockquote>
<h3 id="application-x-www-urlencoded"><a href="#application-x-www-urlencoded" class="headerlink" title="application/x-www-urlencoded"></a>application/x-www-urlencoded</h3><p>我们在通过 HTTP 向服务器发送 POST 请求提交数据，都是通过 form 表单形式提交的，代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://w.sohu.com&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txt1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;txt2&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>提交时会向服务器端发出这样的数据（已经去除部分不相关的头信息），数据如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/<span class="number">1.1</span></span><br><span class="line">Content-<span class="built_in">Type</span>:application/x-www-form-urlencoded</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: w.sohu.com</span><br><span class="line">Content-Length: <span class="number">21</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"> </span><br><span class="line">txt1=hello&amp;txt2=world</span><br></pre></td></tr></table></figure>

<ul>
<li>对于普通的 HTML Form POST 请求，它会在头信息里使用 <code>Content-Length</code> 注明内容长度。</li>
<li>请求头信息每行一条，空行之后便是 Body，即 “内容”（entity）。内容的格式是在头信息中的 Content-Type 指定的，如上是 <code>application/x-www-form-urlencoded</code>，这意味着消息内容会经过 URL 格式编码，就像在 GET 请 求时 URL 里的 QueryString 那样：<code>txt1=hello&amp;txt2=world</code></li>
</ul>
<h3 id="multipart-form-data-1"><a href="#multipart-form-data-1" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><ul>
<li><code>multipart/form-data</code> 定义在 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://tools.ietf.org/html/rfc2388">rfc2388</a> 中，最早的 HTTP POST 是不支持文件上传的，给编程开发带来很多问题。但是在 1995 年，ietf 出台了 rfc1867，也就是《RFC 1867 -Form-based File Upload in HTML》，<strong>用以支持文件上传</strong>。所以 Content-Type 的类型扩充了 multipart/form-data 用以支持向服务器发送二进制数据。</li>
<li>因此，发送 POST 请求时候，表单 <code>&lt;form&gt; </code>属性 enctype 共有二个值可选，这个属性管理的是表单的 MIME 编码：<ul>
<li>application/x-www-form-urlencoded (默认值)</li>
<li>multipart/form-data</li>
</ul>
</li>
</ul>
<p>通过 form 表单提交文件操作如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://w.sohu.com/t2/upload.do&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Santa colo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;desc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pic&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器将会发送以下数据：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POST /t2/upload.<span class="keyword">do</span> HTTP/<span class="number">1.1</span></span><br><span class="line">User-Agent: SOHUWapRebot</span><br><span class="line">Accept-Language: zh-cn,zh;q=<span class="number">0.5</span></span><br><span class="line">Accept-Charset: GBK,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: <span class="number">60408</span></span><br><span class="line">Content-Type:multipart/form-<span class="keyword">data</span>; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line">Host: w.sohu.com</span><br><span class="line"></span><br><span class="line">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line">Content-Disposition: form-<span class="keyword">data</span>; name=<span class="string">&quot;city&quot;</span></span><br><span class="line"></span><br><span class="line">Santa colo</span><br><span class="line">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line">Content-Disposition: form-<span class="keyword">data</span>;name=<span class="string">&quot;desc&quot;</span></span><br><span class="line">Content-Type: text/plain; charset=UTF-<span class="number">8</span></span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line">Content-Disposition: form-<span class="keyword">data</span>;name=<span class="string">&quot;pic&quot;</span>; filename=<span class="string">&quot;photo.jpg&quot;</span></span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line">Content-Transfer-Encoding: binary</span><br><span class="line"> </span><br><span class="line">... binary <span class="keyword">data</span> of the jpg ...</span><br><span class="line">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每个部分使用 <code>--boundary</code> 分割开来，最后一行使用 <code>--boundary--</code> 结尾。</p>
</li>
<li><p>从上面的 <code>multipart/form-data</code> 格式发送的请求的样式来看，它包含了多个 <strong>Parts</strong>，每个 <strong>Part</strong> 都包含头信息部分，<br> <strong>Part</strong> 头信息中必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code> 等。</p>
</li>
<li><p><strong><code>Content-Disposition</code></strong> 包含了 type 和 一个名字为 name 的 parameter，type 是 form-data，name 参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 filename 参数，值就是文件名。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;user&quot;; filename=&quot;hello.txt&quot;</span><br></pre></td></tr></table></figure>

<p>上面的 “user” 就是表单中的控件的名字，后面的参数 filename 则是点选的文件名。对于可选的 Content-Type（如果没有的话），默认就是 <code>text/plain</code>。</p>
</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>如果文件内容是通过填充表单来获得，那么上传的时候，Content-Type 会被自动设置（识别）成相应的格式，如果没法识别，那么就会被设置成 <code>&quot;application/octet-stream&quot;</code></li>
<li>如果多个文件被填充成单个表单项，那么它们的请求格式则会是 multipart/mixed。</li>
<li>如果 Part 的内容跟默认的 encoding 方式不同，那么会有一个 <code>&quot;content-transfer-encoding&quot;</code> 头信息来指定。</li>
</ul>
</blockquote>
<p>下面，我们填充两个文件到一个表单项中，行程的请求信息如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="built_in">Type</span>: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;submit-name&quot;</span></span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;files&quot;</span></span><br><span class="line">Content-<span class="built_in">Type</span>: multipart/mixed; boundary=BbC04y</span><br><span class="line"></span><br><span class="line">--BbC04y</span><br><span class="line">Content-Disposition: file; filename=<span class="string">&quot;file1.txt&quot;</span></span><br><span class="line">Content-<span class="built_in">Type</span>: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--BbC04y</span><br><span class="line">Content-Disposition: file; filename=<span class="string">&quot;file2.gif&quot;</span></span><br><span class="line">Content-<span class="built_in">Type</span>: image/gif</span><br><span class="line">Content-Transfer-Encoding: binary</span><br><span class="line"></span><br><span class="line">...contents of file2.gif...</span><br><span class="line">--BbC04y--</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure>



<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>To see exactly what is happening, use <code>nc -l</code> and an user agent like a browser or cURL.</p>
<p>Save the form to an .html file:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8000&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;text default&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">BUTTON</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">BUTTON</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Create files to upload:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;Content of a.txt.&#x27; &gt; a.txt</span><br><span class="line">echo &#x27;&lt;!DOCTYPE html&gt;&lt;title&gt;Content of a.html.&lt;/title&gt;&#x27; &gt; a.html</span><br></pre></td></tr></table></figure>

<p>Run:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l localhost 8000</span><br></pre></td></tr></table></figure>

<p>Open the HTML on your browser, select the files and click on submit and check the terminal.</p>
<p>nc prints the request received. Firefox sent:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: localhost:8000</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:29.0) Gecko/20100101 Firefox/29.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Cookie: __atuvc=34%7C7; permanent=0; _gitlab_session=226ad8a0be43681acf38c2fab9497240; __profilin=p%3Dt; request_method=GET</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------9051914041544843365972754266</span><br><span class="line">Content-Length: 554</span><br><span class="line"></span><br><span class="line">-----------------------------9051914041544843365972754266</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">text default</span><br><span class="line">-----------------------------9051914041544843365972754266</span><br><span class="line">Content-Disposition: form-data; name=&quot;file1&quot;; filename=&quot;a.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Content of a.txt.</span><br><span class="line"></span><br><span class="line">-----------------------------9051914041544843365972754266</span><br><span class="line">Content-Disposition: form-data; name=&quot;file2&quot;; filename=&quot;a.html&quot;</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Content of a.html.<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">-----------------------------9051914041544843365972754266--</span><br></pre></td></tr></table></figure>

<p>Aternativelly, cURL should send the same POST request as your a browser form:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -l localhost 8000</span><br><span class="line">curl -F &quot;text=default&quot; -F &quot;file1=@a.html&quot; -F &quot;file1=@a.txt&quot; localhost:8000</span><br></pre></td></tr></table></figure>

<p>You can do multiple tests with:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while true; do printf &#x27;&#x27; | nc -l localhost 8000; done</span><br></pre></td></tr></table></figure>



<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：</p>
<ul>
<li>状态行</li>
<li>响应头(Response Header)</li>
<li>响应正文</li>
</ul>
<p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p>
<p>下面是一个HTTP响应的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">Server:Apache Tomcat/5.0.12</span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...</span><br></pre></td></tr></table></figure>



<h2 id="条件GET"><a href="#条件GET" class="headerlink" title="条件GET"></a>条件GET</h2><p>HTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。</p>
<ol>
<li><p>HTTP 条件 GET 使用的时机？</p>
<p><strong>客户端之前已经访问过某网站，并打算再次访问该网站</strong>。</p>
</li>
<li><p>HTTP 条件 GET 使用的方法？</p>
<p>客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p>
</li>
</ol>
<p>下面是一个具体的发送接受报文示例：</p>
<p>客户端发送请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1  </span><br><span class="line">Host: www.sina.com.cn:80  </span><br><span class="line">If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT  </span><br><span class="line">Connection: Close  </span><br></pre></td></tr></table></figure>

<p>第一次请求时，服务器端返回请求数据，之后的请求，<strong>服务器根据请求中的 <code>If-Modified-Since</code> 字段判断响应文件没有更新，如果没有更新，服务器返回一个 <code>304 Not Modified</code>响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 304 Not Modified  </span><br><span class="line">Date: Thu, 04 Feb 2010 12:38:41 GMT  </span><br><span class="line">Content-Type: text/html  </span><br><span class="line">Expires: Thu, 04 Feb 2010 12:39:41 GMT  </span><br><span class="line">Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT  </span><br><span class="line">Age: 28  </span><br><span class="line">X-Cache: HIT from sy32-21.sina.com.cn  </span><br><span class="line">Connection: close </span><br></pre></td></tr></table></figure>

<p>如果服务器端资源已经更新的话，就返回正常的响应。</p>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><ul>
<li>HTTP 长连接不可能一直保持，例如 <code>Keep-Alive: timeout=5, max=100</code>，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。</li>
<li>HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。另外，Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP1.1 版本中也如此。<strong>唯一能保证的就是当连接被关闭时你能得到一个通知</strong>，所以不应该让程序依赖于 Keep-Alive 的保持连接特性，否则会有意想不到的后果。</li>
<li>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？<ol>
<li>判断传输数据是否达到了Content-Length 指示的大小；</li>
<li>动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束。</li>
</ol>
</li>
</ul>
<h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><p>什么是 chunked 分块传输呢？</p>
<p>Transfer-Encoding 是一个用来标示 HTTP 报文<strong>传输格式</strong>的头部值。尽管这个取值理论上可以有很多，但是当前的 HTTP 规范里实际上只定义了一种传输取值——chunked。</p>
<p>如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，<strong>消息体由数量未定的块组成，并以最后一个大小为0的块为结束。</strong></p>
<p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF （回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。消息最后以CRLF结尾。</p>
<p>一个示例响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1A</span><br><span class="line">and this is the second one</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>chunked 和 multipart 两个名词在意义上有类似的地方，不过在 HTTP 协议当中这两个概念则不是一个类别的。</p>
<ul>
<li>multipart 是一种 Content-Type，标示 HTTP 报文内容的类型，</li>
<li>chunked 是一种传输格式，标示报头将以何种方式进行传输。</li>
</ul>
</li>
<li><p><strong>chunked 传输不能事先知道内容的长度，只能靠最后的空 chunk 块来判断，因此对于下载请求来说，是没有办法实现进度的。</strong>在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用 chunked 方式进行下载。</p>
</li>
<li><p>chunked 的优势在于，<strong>服务器端可以边生成内容边发送，无需事先生成全部的内容</strong>。</p>
</li>
<li><p>HTTP/2 不支持 Transfer-Encoding: chunked，因为 HTTP2 有自己的 streaming 传输方式。</p>
</li>
</ul>
<h2 id="HTTP-Pipelining（HTTP-管线化）"><a href="#HTTP-Pipelining（HTTP-管线化）" class="headerlink" title="HTTP Pipelining（HTTP 管线化）"></a>HTTP Pipelining（HTTP 管线化）</h2><p>默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于<code>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3</code>。</p>
<p>HTTP Pipelining（管线化）是<strong>将多个 HTTP 请求整批提交</strong>的技术，在传送过程中不需等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样<code>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</code>。</p>
<p>注意：</p>
<ul>
<li>管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0不支持）</li>
<li>只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制</li>
<li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议</li>
<li><strong>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</strong></li>
<li>HTTP /1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>
<li>由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持</li>
</ul>
<h2 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h2><ol>
<li><p>什么是会话？</p>
<p>客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。</p>
</li>
<li><p>什么是会话跟踪？</p>
<p>会话跟踪指的是对<strong>同一个用户</strong>对服务器的连续的请求和接受响应的监视。</p>
</li>
<li><p>为什么需要会话跟踪？</p>
<p>浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。</p>
</li>
<li><p>会话跟踪常用的方法:</p>
<ol>
<li><p><code>URL 重写</code>：URL重写的技术就是在URL结尾添加一个附加数据以标识该会话，把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。</p>
</li>
<li><p><code>隐藏表单域</code>：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示</p>
</li>
<li><p><code>Cookie</code>：Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。</p>
<p>对于客户端的每次请求，服务器都会将 Cookie 发送到客户端，在客户端可以进行保存,以便下次使用。客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。</p>
<p>Cookie 是可以被客户端禁用的。</p>
</li>
<li><p><code>Session</code>：每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。</p>
</li>
</ol>
</li>
</ol>
<h2 id="跨站攻击"><a href="#跨站攻击" class="headerlink" title="跨站攻击"></a>跨站攻击</h2><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF（Cross-site request forgery，跨站请求伪造）：顾名思义，是伪造请求，冒充用户在站内的正常操作。</p>
<p>例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/bbs/create_post.php?title=标题&amp;content=内容</span><br></pre></td></tr></table></figure>

<p>那么，我们只需要在论坛中发一帖，包含一链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈</span><br></pre></td></tr></table></figure>

<p>只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。</p>
<p>如何防范 CSRF 攻击？</p>
<ul>
<li><p>关键操作只接受 POST 请求</p>
</li>
<li><p>验证码</p>
<p>CSRF 攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。</p>
</li>
<li><p>检测 Referer</p>
<p>常见的互联网页面与页面之间是存在联系的，比如你在 <code>www.baidu.com</code> 应该是找不到通往<code>www.google.com</code> 的链接的，再比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 <code>Referer</code> 中。</p>
<p>通过检查 <code>Referer</code> 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 <code>Referer</code> 的值，所以 <strong>Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。</strong></p>
</li>
<li><p>Token</p>
<p>目前主流的做法是使用 Token 抵御 CSRF 攻击。</p>
<p><strong>CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求</strong>。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击。</p>
<p>另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的。这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击。</p>
<p>Token 使用原则</p>
<ul>
<li>Token 要足够随机————只有这样才算不可预测</li>
<li>Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度</li>
<li>Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中</li>
</ul>
<blockquote>
<p>注意：过滤用户输入的内容<strong>不能</strong>阻挡 csrf，我们需要做的是过滤请求的<strong>来源</strong>。</p>
</blockquote>
</li>
</ul>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS（Cross Site Scripting，跨站脚本攻击）：“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>
<p>运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	alert(<span class="string">&quot;你关不掉我&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 <code>XSRF</code>。</p>
<p>如何防御 XSS 攻击？</p>
<ul>
<li>理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于 script。</li>
<li>防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。</li>
</ul>
<p>如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML escape 。下面一小段脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>经过 escape 之后就成了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure>

<p>它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。</p>
<p>当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理：</p>
<ul>
<li><strong>仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。</strong></li>
<li>更好的方法可能是，将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从<strong>白名单</strong>中拿取。</li>
</ul>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/29e38bcc8a1d">深入解析 multipart/form-data</a></li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>