<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;golang-import-cycle&quot;&gt;&lt;a href=&quot;#golang-import-cycle&quot; class=&quot;headerlink&quot; title=&quot;golang import cycle&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://wangzhezhe.github.io/2019/06/16/golang-import-cycle/&quot;&gt;golang import cycle&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;简单介绍循环引用的起因以及出现循环引用之后应该如何解决。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>如何避免交叉引用 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Golang/" rel="tag">Golang</a></div><div class="post-time">2022-01-26</div></div></div><div class="container post-header"><h1>如何避免交叉引用</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#golang-import-cycle"><span class="toc-number">1.</span> <span class="toc-text">golang import cycle</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%80%A6%E5%90%88"><span class="toc-number">1.1.</span> <span class="toc-text">使用接口来实现解耦合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E5%B1%82%E6%AC%A1%E8%A7%84%E5%88%92"><span class="toc-number">1.2.</span> <span class="toc-text">项目的目录层次规划</span></a></li></ol></li></ol></details></div><div class="container post-content"><h1 id="golang-import-cycle"><a href="#golang-import-cycle" class="headerlink" title="golang import cycle"></a><a target="_blank" rel="noopener" href="https://wangzhezhe.github.io/2019/06/16/golang-import-cycle/">golang import cycle</a></h1><p>简单介绍循环引用的起因以及出现循环引用之后应该如何解决。</p>
<h2 id="使用接口来实现解耦合"><a href="#使用接口来实现解耦合" class="headerlink" title="使用接口来实现解耦合"></a>使用接口来实现解耦合</h2><ul>
<li>通过解耦合来达到消除循环引用的目的，在 Golang 中<strong>通过接口的方式进行接耦合</strong>是相当方便的。</li>
<li>由于 golang 中 struct 是通过 duck type 的方式实现接口，比如一个 struct 实现了 interfaceA 以及 interfaceB, 那么在这个 struct 的定义文件中是<strong>不需要直接引用到 interfaceA 以及 interfaceB 这两个文件的</strong>，这里就实现了所谓的解耦合（从直接诶引用文件所在的目录到才用 duck type 的方式解除耦合）。</li>
</ul>
<p>看一个例子：</p>
<ul>
<li>一个 parent package 引用了 children package，因为 parent 中定义了一个 CreateNewChild 的方法，需要引用 children 的结构体定义，</li>
<li>同时 children package 也需要引用 parent package，因为 Children 需要记录下来到底是哪个 Parent 实例创建了它。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> parent</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;child&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Parent <span class="keyword">struct</span> &#123;</span><br><span class="line">	message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(parent *Parent)</span> <span class="title">PrintMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(parent.message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(parent *Parent)</span> <span class="title">CreateNewChild</span><span class="params">()</span> *<span class="title">child</span>.<span class="title">Child</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> child.NewChild(parent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewParent</span><span class="params">()</span> *<span class="title">Parent</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Parent&#123;message: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> child</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;Parent&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">	parent *Parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(child *Child)</span> <span class="title">PrintParentMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">	child.parent.PrintMessage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChild</span><span class="params">(parent *Parent)</span> *<span class="title">Child</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Child&#123;parent: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此时就出现了交叉引用，按照之前说到的思路，将直接引用变成接口的引用。</p>
<ul>
<li>在 Child 实例中使用到 parent 的方法只有 <code>PrintParentMessage</code> 这个函数，将起抽象成一个 interface，interface 中定义了 <code>PrintParentMessage</code> 方法。</li>
<li><strong>原本 Child 中对于 Parent 的直接引用也变成了对于 IParent 的接口的引用</strong>。</li>
<li>本质上来讲，child 引用 parent 的功能仅仅是获取其中的某些信息，因此并不需要通过 child 完全得到 parent, 只需要通过 child 得到 parent 的一些方法，这些方法可以被定义在一个接口中，因此不必要把 parent 整个实例都暴露给 child，仅仅是暴露出其中的一些方法即可。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> child</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IParent <span class="keyword">interface</span> &#123;</span><br><span class="line">  PrintMessage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">  parent IParent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(child *Child)</span> <span class="title">PrintParentMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">  child.parent.PrintMessage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChild</span><span class="params">(parent *Parent)</span> *<span class="title">Child</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Child&#123;parent: parent &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是整个流程如下，</p>
<ol>
<li>在创建 child 的时，parent 实例被封装成为一个 IParent interface 实例存再了 child 的字段 parent 中，</li>
<li>之后 child 再次调用的 print 方法的时候，通过接口实例去调用 printmessage 的方法，由于此时接口中存的 value 类型是 Parent, 因此会自动匹配到 Parent struct 所实现的 <code>PrintMessage</code> 方法进行调用，这样就实现了最初的消除交叉引用的目的。</li>
</ol>
<h2 id="项目的目录层次规划"><a href="#项目的目录层次规划" class="headerlink" title="项目的目录层次规划"></a>项目的目录层次规划</h2><ul>
<li>此外，还有一种消除交叉引用的方式就是按照项目本身的逻辑层次来规划项目的目录，</li>
<li>比如向这个例子中定义的 Child 以及 Parent 的 struct，都可以<strong>提炼出来放在一个新的名为 type.go 的文件中，这个文件算是整个项目的最底层文件了，其他所有的 Package 可能都需要引用这个文件中定义的内容</strong>，这个文件不再需要引用其他的 package 了，因此也就消除了交叉引用。</li>
<li>另外还有一些经验比如涉及到 util 相关的函数也都会独立出来放在一个新的文件中使用，这样也可以避免一些交叉引用的问题。</li>
</ul>
<p>比较好的方法论是这一篇 <a target="_blank" rel="noopener" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a>，这里摘一些主要的内容：</p>
<ul>
<li>软件是分层次的，外部层次的代码依赖内部的层次代码，<strong>内部层次的代码不知道外部层次代码的行为，并且不对其产生依赖</strong>，一般最常见<strong>最靠近中心的内部层次就是某些抽象程度很高的接口的定义</strong>，以及用于抽象功能的一些 struct 定义。</li>
<li><strong>层次越向内，逻辑的抽象程度越高</strong>，最内层的代码是抽象程度最高的也是最通用的代码，外层的代码是具体的实现细节。抽象代码不能依赖细节代码，细节代码应该依赖抽象代码。<br>这样的方法对阅读源码来说也是有好处的，比如拿来一个新的项目，按照分层的逻辑去阅读就会清晰许多了。虽然说项目运行起来有一个数据流和功能步骤，但是项目在实现和设计的时候从实现的角度来讲都是按照这种层次化的关系来进行的，分析代码的时候从数据流的角度和项目实现的角度应该是两条线了。</li>
</ul>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>