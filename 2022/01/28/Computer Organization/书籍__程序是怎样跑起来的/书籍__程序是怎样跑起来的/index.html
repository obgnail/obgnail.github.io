<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;第-1-章-对程序员来说-CPU-是什么&quot;&gt;&lt;a href=&quot;#第-1-章-对程序员来说-CPU-是什么&quot; class=&quot;headerlink&quot; title=&quot;第 1 章 对程序员来说 CPU 是什么&quot;&gt;&lt;/a&gt;第 1 章 对程序员来说 CPU 是什么&lt;/h2&gt;&lt;h3 id=&quot;CPU-的内部结构&quot;&gt;&lt;a href=&quot;#CPU-的内部结构&quot; class=&quot;headerlink&quot; title=&quot;CPU 的内部结构&quot;&gt;&lt;/a&gt;CPU 的内部结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CPU 的内部由 &lt;code&gt;寄存器&lt;/code&gt;、&lt;code&gt;控制器&lt;/code&gt;、&lt;code&gt;运算器&lt;/code&gt;和&lt;code&gt;时钟&lt;/code&gt;四个部分构成，各部分之间由电流信号相互连通。&lt;/li&gt;
&lt;li&gt;寄存器：可用来暂存指令、数据等处理对象，可以将其看 作是内存的一种。根据种类的不同，一个 CPU 内部会有 20～100 个寄存器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制器：负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;运算器：负责运算从内存读入寄存器的数据。&lt;/li&gt;
&lt;li&gt;时钟：负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;程序启动后，根据时钟信号，控制器会从内存中读取指令和数据。通过对这些指令加以解释和运行，运算器就会对数据进行运算， 控制器根据该运算结果来控制计算机。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>程序是怎样跑起来的 | 凉薄的自动书记人偶</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Tags</a><a class="sidebar-nav-item" href="/About">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Computer-Organization/" rel="tag">Computer Organization</a></div><div class="post-time">2022-01-28</div></div></div><div class="container post-header"><h1>程序是怎样跑起来的</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E5%AF%B9%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9D%A5%E8%AF%B4-CPU-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">第 1 章 对程序员来说 CPU 是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">CPU 的内部结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E6%95%B0%E6%8D%AE%E6%98%AF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%A1%A8%E7%A4%BA%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">第 2 章 数据是用二进制数表示的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E4%B8%A4%E4%B8%AA%E6%9C%AF%E8%AF%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">算术和逻辑两个术语的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%9B%E8%A1%8C%E5%B0%8F%E6%95%B0%E8%BF%90%E7%AE%97%E6%97%B6%E5%87%BA%E9%94%99%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.</span> <span class="toc-text">第 3 章 计算机进行小数运算时出错的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AE%A1%E7%AE%97%E5%87%BA%E9%94%99"><span class="toc-number">3.1.</span> <span class="toc-text">如何避免计算机计算出错</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8%E6%9C%89%E6%A3%B1%E6%9C%89%E8%A7%92%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">第 4 章 熟练使用有棱有角的内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.1.</span> <span class="toc-text">高级语言中数据类型的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E5%86%85%E5%AD%98%E5%92%8C%E7%A3%81%E7%9B%98%E7%9A%84%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB"><span class="toc-number">5.</span> <span class="toc-text">第 5 章 内存和磁盘的亲密关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">5.1.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-DLL-%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%85%B1%E6%9C%89%E6%9D%A5%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98"><span class="toc-number">5.2.</span> <span class="toc-text">通过 DLL 文件实现函数共有来节约内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%B8%85%E7%90%86%E5%A4%84%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">栈清理处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8-stdcall-%E6%9D%A5%E5%87%8F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.4.</span> <span class="toc-text">通过调用 _stdcall 来减小程序文件的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">5.5.</span> <span class="toc-text">磁盘的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ZBR-%E5%8C%BA%E4%BD%8D%E8%AE%B0%E5%BD%95"><span class="toc-number">5.5.1.</span> <span class="toc-text">ZBR 区位记录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E4%BA%B2%E8%87%AA%E5%B0%9D%E8%AF%95%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE"><span class="toc-number">6.</span> <span class="toc-text">第 6 章 亲自尝试压缩数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RLE-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">RLE 压缩算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JPEG-%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E6%9C%89-3-%E7%A7%8D%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">JPEG 格式文件有 3 种压缩方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%9C%A8%E4%BD%95%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%9A%84"><span class="toc-number">7.</span> <span class="toc-text">第 7 章 程序是在何种环境中运行的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">7.1.</span> <span class="toc-text">什么是运行环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeBSD-%E7%9A%84-Ports-%E6%9C%BA%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">FreeBSD 的 Ports 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E7%9B%B8%E5%90%8C%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.3.</span> <span class="toc-text">提供相同运行环境的 Java 虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIOS-%E5%92%8C%E5%BC%95%E5%AF%BC"><span class="toc-number">7.4.</span> <span class="toc-text">BIOS 和引导</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-8-%E7%AB%A0-%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">第 8 章 从源文件到可执行文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E4%B8%AD%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">8.1.</span> <span class="toc-text">Windows 中的编译和链接机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">8.2.</span> <span class="toc-text">可执行文件运行时的必要条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%BA%94%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">9.</span> <span class="toc-text">第 9 章 操作系统和应用的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="toc-number">9.1.</span> <span class="toc-text">系统调用和高级编程语言的移植性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">9.2.</span> <span class="toc-text">Windows 操作系统的特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-10-%E7%AB%A0-%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BA%86%E8%A7%A3%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E9%99%85%E6%9E%84%E6%88%90"><span class="toc-number">10.</span> <span class="toc-text">第 10 章 通过汇编语言了解程序的实际构成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E9%80%9A%E8%BF%87%E6%A0%88%E6%9D%A5%E4%BC%A0%E9%80%92%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E9%80%9A%E8%BF%87%E5%AF%84%E5%AD%98%E5%99%A8%E6%9D%A5%E8%BF%94%E5%9B%9E%E7%9A%84"><span class="toc-number">10.1.</span> <span class="toc-text">函数的参数是通过栈来传递，返回值是通过寄存器来返回的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%8B%E7%BB%88%E7%A1%AE%E4%BF%9D%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">10.2.</span> <span class="toc-text">始终确保全局变量用的内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E8%A7%A3%E9%87%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8Brace%E7%9A%84%E5%8F%91%E7%94%9F"><span class="toc-number">10.3.</span> <span class="toc-text">从汇编角度解释多线程下race的发生</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-11-%E7%AB%A0-%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">第 11 章 硬件控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IN-%E6%8C%87%E4%BB%A4%E5%92%8C-OUT-%E6%8C%87%E4%BB%A4%E5%9C%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%92%8C-CPU-%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">11.1.</span> <span class="toc-text">IN 指令和 OUT 指令在端口号指定的端口和 CPU 之间进行数据的输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IN-OUT-%E6%8C%87%E4%BB%A4%E6%9D%A5%E6%8E%A7%E5%88%B6%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">11.2.</span> <span class="toc-text">利用 IN&#x2F;OUT 指令来控制蜂鸣器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">11.3.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA-%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%9F%AD%E6%97%B6%E9%97%B4%E5%86%85%E4%BC%A0%E9%80%81%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">11.4.</span> <span class="toc-text">DMA 可以实现短时间内传送大量数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-12-%E7%AB%A0-%E8%AE%A9%E8%AE%A1%E7%AE%97%E6%9C%BA%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D"><span class="toc-number">12.</span> <span class="toc-text">第 12 章 让计算机“思考”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">随机算法：线性同余法</span></a></li></ol></li></ol></details></div><div class="container post-content"><h2 id="第-1-章-对程序员来说-CPU-是什么"><a href="#第-1-章-对程序员来说-CPU-是什么" class="headerlink" title="第 1 章 对程序员来说 CPU 是什么"></a>第 1 章 对程序员来说 CPU 是什么</h2><h3 id="CPU-的内部结构"><a href="#CPU-的内部结构" class="headerlink" title="CPU 的内部结构"></a>CPU 的内部结构</h3><ul>
<li>CPU 的内部由 <code>寄存器</code>、<code>控制器</code>、<code>运算器</code>和<code>时钟</code>四个部分构成，各部分之间由电流信号相互连通。</li>
<li>寄存器：可用来暂存指令、数据等处理对象，可以将其看 作是内存的一种。根据种类的不同，一个 CPU 内部会有 20～100 个寄存器。</li>
<li><strong>控制器：负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机</strong>。</li>
<li>运算器：负责运算从内存读入寄存器的数据。</li>
<li>时钟：负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部。</li>
</ul>
<blockquote>
<p>程序启动后，根据时钟信号，控制器会从内存中读取指令和数据。通过对这些指令加以解释和运行，运算器就会对数据进行运算， 控制器根据该运算结果来控制计算机。</p>
<p>看到“控制”一词时，大家可能会将事情想象得过于复杂，其实所谓的控制就是指数据运算以外的处理（主要是数据输入输出的时机控制）。比如内存和磁盘等媒介的输入输出、键盘和鼠标的输入、显示器和打印机的输出等，这些都是控制的内容。</p>
</blockquote>
<ul>
<li>程序是把寄存器作为对象来描述的。</li>
<li>哪怕是高级语言编写的程序，函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的。</li>
</ul>
<h2 id="第-2-章-数据是用二进制数表示的"><a href="#第-2-章-数据是用二进制数表示的" class="headerlink" title="第 2 章 数据是用二进制数表示的"></a>第 2 章 数据是用二进制数表示的</h2><h3 id="算术和逻辑两个术语的区别"><a href="#算术和逻辑两个术语的区别" class="headerlink" title="算术和逻辑两个术语的区别"></a>算术和逻辑两个术语的区别</h3><ul>
<li>在运算中，与<code>逻辑</code>相对的术语是<code>算术</code>。</li>
<li>我们不妨这样考虑，<strong>将二进制数表示的信息作为四则运算的数值来处理就是算术，而像图形模式那样，将数值处理为单纯的 0 和 1 的罗列就是逻辑</strong> 。</li>
<li>计算机能处理的运算，大体可分为<code>算术运算</code>和<code>逻辑运算</code>。算术运算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的 0 和 1 分别进行处理的运算，包括逻辑非（NOT 运算）、逻辑与（AND 运 算）、逻辑或（OR 运算）和逻辑异或（XOR 运算 ）四种。</li>
</ul>
<h2 id="第-3-章-计算机进行小数运算时出错的原因"><a href="#第-3-章-计算机进行小数运算时出错的原因" class="headerlink" title="第 3 章 计算机进行小数运算时出错的原因"></a>第 3 章 计算机进行小数运算时出错的原因</h2><h3 id="如何避免计算机计算出错"><a href="#如何避免计算机计算出错" class="headerlink" title="如何避免计算机计算出错"></a>如何避免计算机计算出错</h3><ul>
<li><p>把小数转换成整数来计算。</p>
<ul>
<li><p>计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题。因此，进行小数的计算时可以暂时使用整数，然后再把计算结果用小数表示出来即可。</p>
</li>
<li><p>例如，将 0.1 相 加 100 次这一计算，就可以转换为将 0.1 扩大 10 倍后再将 1 相加 100 次的计算，最后把结果除以 10 就可以了。</p>
</li>
</ul>
</li>
<li><p>使用BCD（Binary Coded Decimal）：用 4 位来表示 0～9 的 1 位数字</p>
</li>
</ul>
<h2 id="第-4-章-熟练使用有棱有角的内存"><a href="#第-4-章-熟练使用有棱有角的内存" class="headerlink" title="第 4 章 熟练使用有棱有角的内存"></a>第 4 章 熟练使用有棱有角的内存</h2><h3 id="高级语言中数据类型的本质"><a href="#高级语言中数据类型的本质" class="headerlink" title="高级语言中数据类型的本质"></a>高级语言中数据类型的本质</h3><p>高级编程语言中的数据类型表示的是什么？<strong>占据内存区域的大小和存储在该内存区域的数据类型</strong>。</p>
<h2 id="第-5-章-内存和磁盘的亲密关系"><a href="#第-5-章-内存和磁盘的亲密关系" class="headerlink" title="第 5 章 内存和磁盘的亲密关系"></a>第 5 章 内存和磁盘的亲密关系</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul>
<li>虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的。</li>
<li>也就是说，为了实现虚拟内存，就必须把实际内存 （也可称为物理内存 ）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。</li>
</ul>
<p>虚拟内存的方法有 <code>分页式</code> 和<code>分段式</code> 两种：</p>
<ul>
<li>分段式是指，把要运行的程序分割成以处理集合及数据集合等为单位的段落，然后再以分割后的段落为单位在内存和磁盘之间进行数据置换。</li>
<li>分页式是指，在不考虑程序构造的情况下，把运行的程序按照一定大小的页（page） 进行分割，并以页为单位在内存和磁盘间进行置换。Windows 计算机的页的大小是 4KB。也就是说，把大程序用 4KB 的页来进行切分，并以页为单位放入磁盘（虚拟 内存）或内存中。</li>
</ul>
<h3 id="通过-DLL-文件实现函数共有来节约内存"><a href="#通过-DLL-文件实现函数共有来节约内存" class="headerlink" title="通过 DLL 文件实现函数共有来节约内存"></a>通过 DLL 文件实现函数共有来节约内存</h3><p>通过多个应用共有同一个 DLL 文件可以达到节约内存的效果。</p>
<ul>
<li><p>有一个函数 MyFunc()。应用 A 和应用 B 都会使用这个函数。在各个应用的运行文件中内置函数 MyFunc()（这个称为 Static Link，静态链接）后同时运行这两个应用， 内存中就存在了具有同一函数的两个程序。但这会导致内存的利用效率降低。</p>
<p><img src="/images/image-20220128120115846.png" alt="image-20220128120115846"></p>
</li>
<li><p>如果函数 MyFunc() 是独立的 DLL 文件而不是应用的执行文件 （EXE 文件）。由于同一个 DLL 文件的内容在运行时可以被多个应用共有，因此内存中存在的函数 MyFunc() 的程序就 只有 1 个。这样一来，内存的利用效率也就提高了。</p>
<p><img src="/images/image-20220128120225704.png" alt="image-20220128120225704"></p>
</li>
</ul>
<p>Windows 的操作系统本身也是多个 DLL 文件的集合体。有时在安装新应用时，DLL 文件也会被追加。应用则会通过利用这些 DLL 文件的功能来运行。之所以要利用多个 DLL 文件，其中一个原因就是可以节约内存。而且 <strong>DLL 文件还有一个优点就是，在不变更 EXE 文件的情况下，只通过升级 DLL 文件就可以更新</strong>。</p>
<h3 id="栈清理处理"><a href="#栈清理处理" class="headerlink" title="栈清理处理"></a>栈清理处理</h3><ul>
<li>C 语言中，在调用函数后，需要执行栈清理处理指令。</li>
<li><code>栈清理处理</code>是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。</li>
<li>该命令不是程序记述的，而是<strong>在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用方</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  a = MyFunc(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对应的汇编程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 1C8h                        # 将参数456(=1c8h)入栈</span><br><span class="line">push 7Bh                         # 将参数123(=7Bh)入栈</span><br><span class="line">call @LTD+15 (MyFYNC)(00401014)  # 调用MyFunc()函数</span><br><span class="line">add esp, 8                       # 运行栈清理</span><br></pre></td></tr></table></figure>

<ul>
<li>C 语言通过栈来传递函数的参数。push是往栈中存入数据的指令。32 位 CPU 中，1 次 push 指令可以存储 4 个字节的数据。</li>
<li>由于使用了两次 push 指令把两个参数（456 和 123）存入到了栈中，因此存储了 8 字节的数据。通过 call 指令调用函数 MyFunc() 后，栈中存储的数据就不再需要了。于是这时就通过 <code>add esp, 8</code> 这个指令，使存储着栈数据的 esp 寄存器前进 8 位（设定为指向高 8 位字节地址），来进行数据清理。由于栈是在各种情况下都可以再利用的内存领域，因此使用完毕后有必要将其恢复到原状态。上述这些操作就是栈的清理处理。</li>
<li>另外，在 C 语言中，函数的返回值，是通过寄存器而非栈来返回的。</li>
</ul>
<blockquote>
<p>说人话：所谓的 <code>栈清理</code> 指的就是 <code>add esp, 8</code> 这句汇编代码。</p>
</blockquote>
<h3 id="通过调用-stdcall-来减小程序文件的大小"><a href="#通过调用-stdcall-来减小程序文件的大小" class="headerlink" title="通过调用 _stdcall 来减小程序文件的大小"></a>通过调用 <code>_stdcall</code> 来减小程序文件的大小</h3><ul>
<li><p>通过调用 <code>_stdcall</code> 来减小程序文件的方法，是用 C 语言编写应用时可以利用的高级技巧，也可以应用在其他编程语言中。</p>
</li>
<li><p><code> _stdcall</code> 是 standard call（标准调用）的略称。Windows 提供的 DLL 文件内的函数，基本上都是 _stdcall 调用方式。这主要是为了节约内存。</p>
</li>
<li><p>另一方面，用 C 语言编写的程序内的函数，默认设置都不是 _stdcall。C 语言特有的调用方式称为 C 调用。C 语言之所以 默认不使用 _stdcall，是因为 C 语言所对应的函数的传入参数是可变的（可以设定任意参数），只有函数调用方才能知道到底有多少个参数，而这种情况下，栈的清理作业便无法进行。不过，在 C 语言中，如果函数的参数数量固定的话，指定 _stdcall 是没有任何问题的。</p>
</li>
<li><p>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。这时所使用的就是 _stdcall。在函数前加上 _stdcall，就可以把栈清理处理变为在被调用函数一方进行。把前面代码中的 <code>int MyFunc(int a, int b)</code> 部分转成 <code>int _stdcall MyFunc(int a, int b)</code> 进行再编译后，<code>add esp, 8</code> 就会在函数 MyFunc() 一方执行。虽然该处理只能节约 3 个字节（add esp, 8 是机器语的 3 个字节）的程序大小，不过在整个程序中还是有效果的。</p>
<p><img src="/images/image-20220128122320956.png" alt="image-20220128122320956"></p>
</li>
</ul>
<h3 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h3><ul>
<li><p>磁盘的物理结构是指磁盘存储数据的形式。</p>
</li>
<li><p>磁盘是通过把其物理表面划分成多个空间来使用的。划分的方式有 <code>扇区方式</code> 和 <code>可变长方式</code> 两种，</p>
<ul>
<li><code>扇区方式</code> 是指将磁盘划分为固定长度的空间， </li>
<li><code>可变长方式</code> 则是指把磁盘划分为长度可变的空间。</li>
</ul>
</li>
<li><p>Windows 采用的是扇区方式。扇区方式中，把磁盘表面分成若干个同心圆的空间就是 <code>磁道</code> ，把磁道按照固定大小（能存储的 数据长度相同）划分而成的空间就是扇区。</p>
</li>
<li><p><strong>扇区是对磁盘进行物理读写的最小单位</strong>。Windows 中使用的磁盘， 1 个扇区是 512 字节。不过，Windows 在逻辑方面（软件方面）对磁盘进行读写的单位是扇区整数倍<code>簇</code> 。根据磁盘容量的不同，1 簇可以是 512 字节（1 簇 = 1 扇区）、1KB（1 簇 = 2 扇区）、2KB、4KB、 8KB、16KB、32KB（1 簇 = 64 扇区）。磁盘的容量越大，簇的容量也越大。不过，在软盘中，1 簇 = 512 字节 = 1 扇区，簇和扇区的大小是相等的。</p>
<p><img src="/images/image-20220128141343321.png" alt="image-20220128141343321"></p>
</li>
<li><p>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件， 都会占用 1 簇的空间。这样一来，所有的文件都会占用 1 簇的整数倍的磁盘空间。</p>
</li>
<li><p>大多数磁盘分区方案旨在使文件占据整数个扇区，而不管文件的实际大小如何。未填充完整个扇区的文件将最后一个扇区的其余部分填充零。实际上，操作系统通常使用数据块操作，数据块可跨越多个扇区。</p>
</li>
</ul>
<h4 id="ZBR-区位记录"><a href="#ZBR-区位记录" class="headerlink" title="ZBR 区位记录"></a>ZBR 区位记录</h4><ul>
<li>在早期的硬盘驱动器中，所有的磁道包含的扇区数目都是一样的，按照固定的圆心角辐射出去，就可以简单的将各磁道的扇区数进行统一。这样，在磁道边缘的扇区弧长就要大于内部的扇区弧长，其存储数据的密度也要比内部磁道的密度要小。最终，导致外部磁道的空间浪费。</li>
<li>为了有效利用外部磁道空间，让所有的磁道扇区存储数据密度一致，就需要保证所有扇区的<strong>弧长一致</strong>。这样就要根据磁道的半径来重新分配扇区数目。</li>
<li>ZBR 区位记录，是指为了提高磁盘的存储容量，充分利用磁盘外面磁道的存储能力，现代磁盘不再把内外磁道划分为相同数目的扇区。ZBR通过在外部磁道上每个区域放置比内部磁道更多的扇区来实现此目的。</li>
<li>如下图片所示，可以看到粉红色、绿色、灰色部分的扇区数量不一样。</li>
</ul>
<p><img src="/images/image-20220128142150257.png" alt="image-20220128142150257"></p>
<h2 id="第-6-章-亲自尝试压缩数据"><a href="#第-6-章-亲自尝试压缩数据" class="headerlink" title="第 6 章 亲自尝试压缩数据"></a>第 6 章 亲自尝试压缩数据</h2><h3 id="RLE-压缩算法"><a href="#RLE-压缩算法" class="headerlink" title="RLE 压缩算法"></a>RLE 压缩算法</h3><ul>
<li>RLE（Run Length Encoding，行程长度编码）压缩算法：将文件的内容用“字符 × 重复次数”这样的方式来压缩。</li>
<li>比如： AAAAAABBCDDEEEEEF 就可以用 A6B2C1D2E5F1 来表示。</li>
<li>RLE 算法经常被用于传真 FAX 等。G3 类传真机是把文字和图形都作为黑白图像来发送的。由于黑白图像的数据中，白或黑通常是部分连续的，因此就没有必要再发送这部分数据的值（白或者黑），而只需附带上重复次数即可，这样压缩效率就得到了大幅提升。例如，像白色部分重复 5 次，黑色部分重复 7 次，白色部分重复 4 次，黑色部分重复 6 次这样的部分图像，就可以用 5746 这样的重复次数数字来进行压缩。</li>
</ul>
<h3 id="JPEG-格式文件有-3-种压缩方式"><a href="#JPEG-格式文件有-3-种压缩方式" class="headerlink" title="JPEG 格式文件有 3 种压缩方式"></a>JPEG 格式文件有 3 种压缩方式</h3><ol>
<li>把构成图像的点阵的颜色信息由 RGB（红色、绿色、蓝色）形式转化成 YCbCr（亮度、蓝色色度、红色色度）形式。我们知道，人眼对亮度很敏感，但对颜色的变化却有些迟钝。因此，人眼比较敏感的亮度 Y 就是一个很重要的参数，而表示颜色的 Cb、Cr 则没有那么重要。于是我们就可以通过减少 Cb 和 Cr 的信息间距来缩小图像数据的大小。</li>
<li>将每个点的色素变化看作是波形的信号变化，进行傅里叶变换。傅里叶变换是指将波形按照频率分量进行分解。照片等图像文件的特点是低频率（柔和的颜色变化）的部分较多，高频率（强烈的颜色变化）的部分较少。因此，我们就可以把高频率的部分剪切掉。这样一来，图像数据也就会缩小。虽然剪切掉了高频率部分，但人眼分辨不 出什么差别。不过，如果是用 Windows 画笔描绘的简单图形，其中颜色变化强烈的部分就会出现模糊现象。大家不妨使用 Windows 画笔做一个圆形或者四方形的图形，并将其保存成 JPEG 格式。然后再打开这个 JPEG 文件，你就会发现颜色变化强烈的部分变模糊了。</li>
<li>将已经瘦身的图像数据通过哈夫曼算法进行压缩。这样就可以使图像数据进一步缩小。</li>
</ol>
<h2 id="第-7-章-程序是在何种环境中运行的"><a href="#第-7-章-程序是在何种环境中运行的" class="headerlink" title="第 7 章 程序是在何种环境中运行的"></a>第 7 章 程序是在何种环境中运行的</h2><h3 id="什么是运行环境"><a href="#什么是运行环境" class="headerlink" title="什么是运行环境"></a>什么是运行环境</h3><ul>
<li><p>Mac 的软件不能在 Windows 中运行。为什么？因为运行环境不同。这里的 <strong><code>运行环境</code> 指的就是操作系统和计算机本身 ( 硬件 ) 的种类</strong>。</p>
</li>
<li><p>应用的运行环境通常是用类似于 Windows(OS) 和 AT 兼容机（硬件）这样的 OS 和硬件的种类来表示的。</p>
</li>
<li><p>简单来讲：<strong>运行环境 = 操作系统 ＋ 硬件</strong></p>
</li>
<li><p>我们下载软件的时候，下载页面一定会列出<code>操作系统</code>和<code>硬件</code>。这里指的就是软件的运行环境。</p>
<p><img src="/images/image-20220128150255362.png" alt="image-20220128150255362"></p>
</li>
</ul>
<h3 id="FreeBSD-的-Ports-机制"><a href="#FreeBSD-的-Ports-机制" class="headerlink" title="FreeBSD 的 Ports 机制"></a>FreeBSD 的 Ports 机制</h3><ul>
<li>众所周知，操作系统抹平了除 CPU 以外的全部差异。</li>
<li>既然 CPU 类型不同会导致机器代码无法重复利用，那么为何不直接把源代码分发给程序呢？FreeBSD 的 Ports 机制能够结合当前运行的硬件环境来编译应用的源代码，进而得到可以运行的机器代码。</li>
<li>可以说 Ports 能够克服包含 CPU 在内的所有硬件差异的系统。而且 Ports 这个术语表示的是 porting（移植）的意思。而根据不同的运行环境来重新调整程序，一般也称为 <code>移植</code>。</li>
</ul>
<h3 id="提供相同运行环境的-Java-虚拟机"><a href="#提供相同运行环境的-Java-虚拟机" class="headerlink" title="提供相同运行环境的 Java 虚拟机"></a>提供相同运行环境的 Java 虚拟机</h3><ul>
<li><p>同其他编程语言相同，Java 也是将 Java 语法记述的源代码编译后运行。不过，编译后生成的并不是特定 CPU 使用的本地代码，而是名为 <code>字节代码</code> 的程序。字节代码的运行环境就称为 Java 虚拟机。Java 虚拟机是一边把 Java 字节代码逐一转换成本地代码一边运行的。</p>
</li>
<li><p>在程序运行时，将编译后的字节代码转换成本地代码，由此可以实现同样的字节代码在不同的环境下运行。</p>
<p><img src="/images/image-20220128152110615.png" alt="image-20220128152110615"></p>
</li>
<li><p><strong>从 Java 应用方面来看，Java 虚拟机就是运行环境。</strong>Java 虚拟机每次运行时都要把字节代码变换成本机代码，这一机制是造成运行速度慢的原因。</p>
</li>
</ul>
<h3 id="BIOS-和引导"><a href="#BIOS-和引导" class="headerlink" title="BIOS 和引导"></a>BIOS 和引导</h3><ul>
<li>BIOS 存储在 ROM 中，是预先内置在计算机主机内部的程序。</li>
<li>BIOS 除了键盘、磁盘、显卡等基本控制程序外，还有启动 <code>引导程序</code> 的功能。</li>
<li>引导程序是存储在启动驱动器起始区域的小程序。开机后，BIOS 会确认硬件是否正常运行，没有问题的话就会启动引导程序。引导程序的功能是把在硬盘等记录的 OS 加载到内存中运行。虽然启动应用是 OS 的功能，但 OS 并不能自己启动自己，而是通过引导程序来启动。</li>
</ul>
<h2 id="第-8-章-从源文件到可执行文件"><a href="#第-8-章-从源文件到可执行文件" class="headerlink" title="第 8 章 从源文件到可执行文件"></a>第 8 章 从源文件到可执行文件</h2><h3 id="Windows-中的编译和链接机制"><a href="#Windows-中的编译和链接机制" class="headerlink" title="Windows 中的编译和链接机制"></a>Windows 中的编译和链接机制</h3><p><img src="/images/image-20220128154244959.png" alt="image-20220128154244959"></p>
<h3 id="可执行文件运行时的必要条件"><a href="#可执行文件运行时的必要条件" class="headerlink" title="可执行文件运行时的必要条件"></a>可执行文件运行时的必要条件</h3><ul>
<li><p>本地代码在对程序中记述的变量进行读写时，是参照数据存储的内存地址来运行命令的。在调用函数时，程序的处理流程就会跳转到存储着函数处理内容的内存地址上。<strong>EXE 文件作为本地代码的程序，并没有指定变量及函数的实际内存地址</strong>。在类似于 Windows 操作系统这样的可以加载多个可执行程序的运行环境中，每次运行时，程序内的变量及函数被分配到的内存地址都是不同的。</p>
</li>
<li><p>那么，在 EXE 文件中，变量和函数的内存地址的值，是如何来表示的呢？那就是 EXE 文件中给变量及函数分配了<strong>虚拟的内存地址</strong>。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在 EXE 文件的开头，追加转换内存地址所需的必要信 息。这个信息称为 <code>再配置信息</code> 。</p>
</li>
<li><p>EXE 文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离。<strong>在源代码中，虽然变量及函数是在不同位置分散记述的，但在链接后的 EXE 文件中，变量及函数就会变成一个连续排列的组</strong>。这样一来，各变量的内存地址就可以用相对于变量组起始位置这一基点的偏移量来表示，同样，各函数的内存地址也可以用相对于函数组起始位置这一基点的偏移量来表示。而各组基点的内存地址则是在程序运行时被分配的。</p>
<p><img src="/images/image-20220128154858007.png" alt="image-20220128154858007"></p>
</li>
</ul>
<blockquote>
<p>简单来说：</p>
<ul>
<li>多个程序可以同时运行，在单个 CPU 上共享时间，操作系统的这种能力叫<code>多任务处理</code>。</li>
<li>同时运行多个程序有个问题，每个程序都会占一些内存，当切换到另一个程序时，我们不能丢失数据。解决办法是，给每个程序分配专属内存块。举个例子，假设计算机一共有 10000 个内存位置，程序 A 分配到内存地址 0 到 999，而程序 B 分配到内存地址 1000 到 1999，以此类推。如果一个程序请求更多内存，操作系统会决定是否同意，如果同意，分配哪些内存块。</li>
<li>这种灵活性很好，但带来一个奇怪的后果，程序 A 可能会<strong>分配到非连续的内存块</strong>，比如内存地址 0 到 999，以及 2000 到 2999，也就是说程序可能会分配到内存中数十个地方。程序员来说很难跟踪。</li>
<li>为了隐藏这种复杂性，操作系统会把内存地址进行 “虚拟化”，这叫<code>虚拟内存</code>，程序可以假定内存总是从地址0开始。而<strong>实际物理位置被操作系统隐藏和抽象</strong>了，<strong>操作系统会自动处理虚拟内存和物理内存之间的映射</strong>。</li>
<li>这种机制使程序的内存大小可以灵活增减，叫<code>动态内存分配</code>。对程序来说，内存看起来是连续的，它简化了一切，为操作系统同时运行多个程序，提供了极大的灵活性。</li>
</ul>
</blockquote>
<h2 id="第-9-章-操作系统和应用的关系"><a href="#第-9-章-操作系统和应用的关系" class="headerlink" title="第 9 章 操作系统和应用的关系"></a>第 9 章 操作系统和应用的关系</h2><h3 id="系统调用和高级编程语言的移植性"><a href="#系统调用和高级编程语言的移植性" class="headerlink" title="系统调用和高级编程语言的移植性"></a>系统调用和高级编程语言的移植性</h3><ul>
<li><p>操作系统的硬件控制功能，通常是通过一些小的函数集合体的形式来提供的。这些函数及调用函数的行为统称为 <code>系统调用</code> （system call）， 也就是<strong>应用对操作系统（system）的功能进行调用（call）的意思</strong>。</p>
</li>
<li><p>time() 及 printf() 等函数内部也都使用了系统调用。</p>
<blockquote>
<p>这里之所以用“内部”这个词，是因为在 Windows 操作系统中，提供返回当前日期和时刻，以及在显示器中显示字符串等功能系统调用的函数名，并不是 time() 和 printf()。系统调用是在 time() 和 printf() 函数的内部执行的。</p>
</blockquote>
</li>
<li><p>C 语言等高级编程语言并不依存于特定的操作系统。这是因为人们希望不管是 Windows 还是 Linux，都能使用几乎相同的源代码。因此， 高级编程语言的机制就是，使用独自的函数名，然后再在编译时将其转换成相应操作系统的系统调用。</p>
</li>
<li><p>在高级编程语言中，也存在可以直接调用系统调用的编程语言。不过，利用这种方式做成的应用，移植性并不友好。</p>
</li>
</ul>
<h3 id="Windows-操作系统的特征"><a href="#Windows-操作系统的特征" class="headerlink" title="Windows 操作系统的特征"></a>Windows 操作系统的特征</h3><ul>
<li><p>32 位操作系统（也有 64 位版本）</p>
</li>
<li><p><strong>通过 API 函数集来提供系统调用</strong></p>
<blockquote>
<ul>
<li>32 位版 Windows API 也称为 <code>Win32 API</code> 。64 位版的称为 <code>Win64 API</code>。</li>
<li><strong>API 通过多个 DLL 文件来提供</strong>。</li>
<li>各 API 的实体都是用 C 语言编写的函数。因而，C 语言程序的情况下，API 的使用更加容易。</li>
</ul>
</blockquote>
</li>
<li><p>提供采用了图形用户界面的用户界面</p>
</li>
<li><p>通过 WYSIWYG 实现打印输出</p>
</li>
<li><p>提供多任务功能</p>
<blockquote>
<ul>
<li>Windows 是通过 <code>时钟分割</code> 技术来实现多任务功能的。</li>
<li>时钟分割指的是在短时间间隔内，多个程序切换运行的方式。在用户看来，就是多个程序在同时运行。</li>
</ul>
</blockquote>
</li>
<li><p>提供网络功能及数据库功能</p>
</li>
<li><p>通过即插即用实现设备驱动的自动设定</p>
<blockquote>
<ul>
<li>即插即用 （Plug-and-Play）指的是<strong>新的设备连接（Plug）后立刻就可以 使用（Play）的机制</strong>。</li>
<li>新的设备连接到计算机后，系统就会自动安装和设定用来控制该设备的设备驱动程序。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="第-10-章-通过汇编语言了解程序的实际构成"><a href="#第-10-章-通过汇编语言了解程序的实际构成" class="headerlink" title="第 10 章 通过汇编语言了解程序的实际构成"></a>第 10 章 通过汇编语言了解程序的实际构成</h2><h3 id="函数的参数是通过栈来传递，返回值是通过寄存器来返回的"><a href="#函数的参数是通过栈来传递，返回值是通过寄存器来返回的" class="headerlink" title="函数的参数是通过栈来传递，返回值是通过寄存器来返回的"></a>函数的参数是通过栈来传递，返回值是通过寄存器来返回的</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddNum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  c = AddNum(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_MyFunc proc near</span><br><span class="line"> push ebp ; 将 ebp 寄存器的值存入栈中----------------------（1）</span><br><span class="line"> mov ebp,esp ; 将 ebp 寄存器的值存入 ebp 寄存器---------------（2）</span><br><span class="line"> push 456 ; 456 入栈---------------------------------------（3）</span><br><span class="line"> push 123 ; 123 入栈---------------------------------------（4）</span><br><span class="line"> call _AddNum ; 调用 AddNum 函数-------------------------------（5）</span><br><span class="line"> add esp,8 ; esp 寄存器的值加 8-----------------------------（6）</span><br><span class="line"> pop ebp ; 读出栈中的数值存入 ebp 寄存器------------------（7）</span><br><span class="line"> ret ; 结束 MyFunc 函数，返回到调用源-----------------（8）</span><br><span class="line">_MyFunc endp</span><br></pre></td></tr></table></figure>

<ul>
<li>虽然记述为函数 AddNum(123，456)，但入栈时则会按照 456、123 这样的顺序，也就是位于后面的数值先入栈。 这是 C 语言的规定。</li>
<li>编译器有最优化功能。编译器在本地代码上费尽功夫实现的，其目的是让编译后的程序运行速度更快、文件更小。由于存储着 AddNum 函数返回值的变量 c 在后面没有被用到，因此编译器就会认为“该处理没有意义”， 进而也就没有生成与之对应的汇编语言代码。</li>
<li><strong>函数的参数是通过栈来传递，返回值是通过寄存器来返回的。</strong></li>
</ul>
<h3 id="始终确保全局变量用的内存空间"><a href="#始终确保全局变量用的内存空间" class="headerlink" title="始终确保全局变量用的内存空间"></a>始终确保全局变量用的内存空间</h3><ul>
<li>C 语言中，在函数外部定义的变量称为<code>全局变量</code> ，在函数内部定义的变量称为<code>局部变量</code> 。全局变量可以引用源代码的任意部分，而局部变量只能在定义该变量的函数内进行引用。我们通过汇编语言的源代码，来看一下全局变量和局部变量的不同。</li>
<li>简单来讲：<code>全局变量</code> 会被放置在自己的数据段。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义被初始化的全局变量</span></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> a5 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//定义没有初始化的全局变量</span></span><br><span class="line"><span class="keyword">int</span> b1, b2, b3, b4, b5;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义局部变量</span></span><br><span class="line">  <span class="keyword">int</span> c1, c2, c3, c4, c5, c6, c7, c8, c9, c10;</span><br><span class="line">  <span class="comment">//给局部变量赋值</span></span><br><span class="line">  c1 = <span class="number">1</span>;</span><br><span class="line">  c2 = <span class="number">2</span>;</span><br><span class="line">  c3 = <span class="number">3</span>;</span><br><span class="line">  c4 = <span class="number">4</span>;</span><br><span class="line">  c5 = <span class="number">5</span>;</span><br><span class="line">  c6 = <span class="number">6</span>;</span><br><span class="line">  c7 = <span class="number">7</span>;</span><br><span class="line">  c8 = <span class="number">8</span>;</span><br><span class="line">  c9 = <span class="number">9</span>;</span><br><span class="line">  c10 = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//把局部变量的值赋给全局变量</span></span><br><span class="line">  a1 = c1;</span><br><span class="line">  a2 = c2;</span><br><span class="line">  a3 = c3;</span><br><span class="line">  a4 = c4;</span><br><span class="line">  a5 = c5;</span><br><span class="line">  b1 = c6;</span><br><span class="line">  b2 = c7;</span><br><span class="line">  b3 = c8;</span><br><span class="line">  b4 = c9;</span><br><span class="line">  b5 = c10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">_DATA segment dword public use32 &#x27;DATA&#x27;--------------------┐</span><br><span class="line">_a1 label dword ----------------------------------（4）     │</span><br><span class="line"> dd 1 --------------------------------------（5）           │</span><br><span class="line">_a2 label dword                                            │</span><br><span class="line"> dd 2                                                      │</span><br><span class="line">_a3 label dword                                           （1）</span><br><span class="line"> dd 3                                                      │</span><br><span class="line">_a4 label dword                                            │</span><br><span class="line"> dd 4                                                      │</span><br><span class="line">_a5 label dword                                            │</span><br><span class="line"> dd 5                                                      │</span><br><span class="line">_DATA ends ------------------------------------------------┘</span><br><span class="line"></span><br><span class="line">_BSS segment dword public use32 &#x27;BSS&#x27; --------------------┐</span><br><span class="line">_b1 label dword                                           │</span><br><span class="line"> db 4 dup(?) -------------------------------（6）          │</span><br><span class="line">_b2 label dword                                           │</span><br><span class="line"> db 4 dup(?)                                              │</span><br><span class="line">_b3 label dword                                          （2）</span><br><span class="line"> db 4 dup(?)                                              │</span><br><span class="line">_b4 label dword                                           │</span><br><span class="line"> db 4 dup(?)                                              │</span><br><span class="line">_b5 label dword                                           │</span><br><span class="line"> db 4 dup(?) ---------------------------------------------┘</span><br><span class="line">_BSS ends</span><br><span class="line"></span><br><span class="line">_TEXT segment dword public use32 &#x27;CODE&#x27; --------------------┐</span><br><span class="line">_MyFunc proc near ----------------------------------┐      │</span><br><span class="line"> push ebp                                           │      │</span><br><span class="line"> mov ebp,esp ------------------------（11）          │      │</span><br><span class="line"> add esp,-20 ------------------------（10）          │      │</span><br><span class="line"> push ebx                                           │       │</span><br><span class="line"> push esi                                           │       │</span><br><span class="line"> mov eax,1 ---------------------------┐             │      │</span><br><span class="line"> mov edx,2                            │             │      │</span><br><span class="line"> mov ecx,3                           （8）           │      │</span><br><span class="line"> mov ebx,4                            │             │      │</span><br><span class="line"> mov esi,5 ---------------------------┘             │      │</span><br><span class="line"> mov dword ptr [ebp-4],6 -------------┐             │      │</span><br><span class="line"> mov dword ptr [ebp-8],7              │             │      │</span><br><span class="line"> mov dword ptr [ebp-12],8            （9）           │      │</span><br><span class="line"> mov dword ptr [ebp-16],9             │             │      │</span><br><span class="line"> mov dword ptr [ebp-20],10 -----------┘             │      │</span><br><span class="line"> mov dword ptr [_a1],eax                             │      │</span><br><span class="line"> mov dword ptr [_a2],edx                             │      │</span><br><span class="line"> mov dword ptr [_a3],ecx                            （7）   （3）</span><br><span class="line"> mov dword ptr [_a4],ebx                             │      │</span><br><span class="line"> mov dword ptr [_a5],esi                             │      │</span><br><span class="line"> mov eax,dword ptr [ebp-4]                           │      │</span><br><span class="line"> mov dword ptr [_b1],eax                             │      │</span><br><span class="line"> mov edx,dword ptr [ebp-8]                           │      │</span><br><span class="line"> mov dword ptr [_b2],edx                             │      │</span><br><span class="line"> mov ecx,dword ptr [ebp-12]                          │      │</span><br><span class="line"> mov dword ptr [_b3],ecx                             │      │</span><br><span class="line"> mov eax,dword ptr [ebp-16]                          │      │</span><br><span class="line"> mov dword ptr [_b4],eax                             │      │</span><br><span class="line"> mov edx,dword ptr [ebp-20]                          │      │</span><br><span class="line"> mov dword ptr [_b5],edx                             │      │</span><br><span class="line"> pop esi                                             │      │</span><br><span class="line"> pop ebx                                             │      │</span><br><span class="line"> mov esp,ebp -----------------------（12）            │      │ </span><br><span class="line"> pop ebp                                             │      │</span><br><span class="line"> ret                                                 │      │</span><br><span class="line">_MyFunc endp ----------------------------------------┘      │</span><br><span class="line">_TEXT ends --------------------------------------------------┘</span><br></pre></td></tr></table></figure>

<ul>
<li>编译后的程序，会被归类到名为段定义的组。<ul>
<li>初始化的全局变量，就像（1）一样，被汇总到名为 <code>_DATA</code> 的段定义中，</li>
<li>没有初始化的全局变量，就像（2）一样，被汇总到名为 <code>_BSS </code>的段定义中。</li>
<li>指令则会像（3）那样被汇总到名为 <code>_TEXT</code> 的段定义中。这些段定义的名称是由 Borland C++ 的使用规范来决定的。</li>
</ul>
</li>
<li>观察（8）（9），发现在 MyFunc 函数中定义的局部变量所需要的内存领域，会<strong>被尽可能地分配在寄存器中。寄存器空闲时就使用寄存器，寄存器空间不足的话就使用栈</strong>。</li>
</ul>
<h3 id="从汇编角度解释多线程下race的发生"><a href="#从汇编角度解释多线程下race的发生" class="headerlink" title="从汇编角度解释多线程下race的发生"></a>从汇编角度解释多线程下race的发生</h3><p>两个线程同时执行，一个跑MyFunc1，另一个跑MyFunc2。理想结果 counter 应变成 100×2×2 = 400。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counter = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  counter *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  counter *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转成汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_DATA segment dword public use32 &#x27;DATA&#x27;</span><br><span class="line">_counter label dword</span><br><span class="line"> dd 100</span><br><span class="line">_DATA ends</span><br><span class="line"></span><br><span class="line">mov eax,dword ptr[_counter] ; 将counter的值读入eax寄存器</span><br><span class="line">add eax,eax                 ; 将eax寄存器的值扩大至原来的2倍</span><br><span class="line">mov dword ptr[_counter],eax ; 将eax寄存器的数值存入counter中</span><br></pre></td></tr></table></figure>

<ul>
<li>在多线程处理中，<strong>用汇编语言记述的代码每运行 1 行，处理都有可能切换到其他线程（函数）中</strong>。</li>
<li>因而，假设 MyFunc1 函数在读出 counter 的数值 100 后，还未来得及将它的 2 倍值 200 写入 counter 时，正巧 MyFunc2 函数读出了 counter 的数值 100，那么结果就会导致 counter 的数值变成了 200。</li>
</ul>
<p><img src="/images/image-20220128200721061.png" alt="image-20220128200721061"></p>
<h2 id="第-11-章-硬件控制方法"><a href="#第-11-章-硬件控制方法" class="headerlink" title="第 11 章 硬件控制方法"></a>第 11 章 硬件控制方法</h2><ul>
<li><p>在用 C 语言等高级编程语言开发的 Windows 应用中，大家很少能接触到直接控制硬件的指令。这是因为<strong>硬件的控制是由 Windows 全权负责的</strong>。</p>
</li>
<li><p>不过，Windows 提供了通过应用来间接控制硬件的方法。利用操作系统提供的 <code>系统调用</code> 功能就可以实现对硬件的控制。这些函数的实体被存储在 DLL 文件中。</p>
<p><img src="/images/image-20220128201209397.png" alt="image-20220128201209397"></p>
</li>
<li><p>但 Windows 本身也是 软件，由此可见，Windows 应该向 CPU 传递了某些指令，从而通过软件控制了硬件。</p>
</li>
</ul>
<h3 id="IN-指令和-OUT-指令在端口号指定的端口和-CPU-之间进行数据的输入输出"><a href="#IN-指令和-OUT-指令在端口号指定的端口和-CPU-之间进行数据的输入输出" class="headerlink" title="IN 指令和 OUT 指令在端口号指定的端口和 CPU 之间进行数据的输入输出"></a>IN 指令和 OUT 指令在端口号指定的端口和 CPU 之间进行数据的输入输出</h3><p><img src="/images/image-20220128201642750.png" alt="image-20220128201642750"></p>
<h3 id="利用-IN-OUT-指令来控制蜂鸣器"><a href="#利用-IN-OUT-指令来控制蜂鸣器" class="headerlink" title="利用 IN/OUT 指令来控制蜂鸣器"></a>利用 IN/OUT 指令来控制蜂鸣器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main（）&#123;</span><br><span class="line">  <span class="comment">// 计数器</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 蜂鸣器发声</span></span><br><span class="line">  _asm &#123;</span><br><span class="line">    IN EAX, <span class="number">61</span>H </span><br><span class="line">    OR EAX, <span class="number">03</span>H </span><br><span class="line">    OUT <span class="number">61</span>H, EAX</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待一段时间</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000</span> ; i++) ; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 蜂鸣器停止发声</span></span><br><span class="line">  _asm &#123;</span><br><span class="line">    IN EAX, <span class="number">61</span>H</span><br><span class="line">    AND EAX, <span class="number">0F</span>CH</span><br><span class="line">    OUT <span class="number">61</span>H, EAX</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在现在的 Windows 其实执行不了的。因为现在的 Windows 禁止了应用直接控制硬件的方式。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul>
<li>中断处理程序的第一步处理，就是把 CPU <strong>所有</strong>寄存器的数值保存到内存的栈中。</li>
<li>因为不同程序访问的内存不同，其他程序是无法修改不同程序所使用的内存的，所以中断发生后，只要寄存器的值保持不变，主程序就可以像没有发生任何事情一样继续处理。</li>
</ul>
<h3 id="DMA-可以实现短时间内传送大量数据"><a href="#DMA-可以实现短时间内传送大量数据" class="headerlink" title="DMA 可以实现短时间内传送大量数据"></a>DMA 可以实现短时间内传送大量数据</h3><ul>
<li><p>DMA（Direct Memory Access）：是指<strong>在不通过 CPU 的情况下，外围设备直接和主内存进行数据传送</strong>。</p>
</li>
<li><p>磁盘等都用到了 DMA 机制。通过利用 DMA，大量数据就可以在短时间内转送到主内存。之所以这么快速，是因为 CPU 作为中介的时间被节省了。</p>
<p><img src="/images/image-20220128204014149.png" alt="image-20220128204014149"></p>
</li>
<li><p>不同的外围设置使用不同的编号，这个编号称为 <code>DMA 通道</code> 。CPU 借助 DMA 通道，来识别是哪一个外围设备使用了 DMA。</p>
</li>
</ul>
<h2 id="第-12-章-让计算机“思考”"><a href="#第-12-章-让计算机“思考”" class="headerlink" title="第 12 章 让计算机“思考”"></a>第 12 章 让计算机“思考”</h2><h3 id="随机算法：线性同余法"><a href="#随机算法：线性同余法" class="headerlink" title="随机算法：线性同余法"></a>随机算法：线性同余法</h3><p>把 Ri 作为当前随机数，那么下一个出现的随机数 Ri + 1 就可以用下面的公式来获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ri + 1 = (a × Ri + b ) mod c</span><br></pre></td></tr></table></figure>

<ul>
<li>对 a 、b 、c 各参数设定合适的整数后，可以从该公式获得的随机数的范围就是 0 到 c （不包含）。</li>
<li>把 a 设定为 5，b 设定为 3，c 设定为 8，就可以获得的随机数。不过，产生 8 次随机数后，下 8 次产生的随机数就和前面的数值相同了。这种<strong>周期性是伪随机数的特征</strong>，也是为什么不是真随机数的原因。</li>
<li>C 语言的随机种子：获取当前时间的参数。以 time(NULL) 的值为基础，来设定 Ri 、a 、b 、c 的数值。</li>
</ul>
<p>没什么阅读价值的书，鉴定完毕。</p>
<p>FIN</p>
</div></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>